
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:44.035] plan(): Setting new future strategy stack:
[17:42:44.036] List of future strategies:
[17:42:44.036] 1. sequential:
[17:42:44.036]    - args: function (..., envir = parent.frame())
[17:42:44.036]    - tweaked: FALSE
[17:42:44.036]    - call: future::plan("sequential")
[17:42:44.049] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[17:42:44.144] plan(): Setting new future strategy stack:
[17:42:44.144] List of future strategies:
[17:42:44.144] 1. sequential:
[17:42:44.144]    - args: function (..., envir = parent.frame())
[17:42:44.144]    - tweaked: FALSE
[17:42:44.144]    - call: plan(strategy)
[17:42:44.155] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.157] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.158] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.164] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.164] Searching for globals ... DONE
[17:42:44.165] Resolving globals: TRUE
[17:42:44.165] Resolving any globals that are futures ...
[17:42:44.165] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.165] Resolving any globals that are futures ... DONE
[17:42:44.165] 
[17:42:44.166] 
[17:42:44.166] getGlobalsAndPackages() ... DONE
[17:42:44.166] run() for ‘Future’ ...
[17:42:44.166] - state: ‘created’
[17:42:44.167] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.167] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.167]   - Field: ‘label’
[17:42:44.167]   - Field: ‘local’
[17:42:44.168]   - Field: ‘owner’
[17:42:44.168]   - Field: ‘envir’
[17:42:44.168]   - Field: ‘packages’
[17:42:44.168]   - Field: ‘gc’
[17:42:44.168]   - Field: ‘conditions’
[17:42:44.168]   - Field: ‘expr’
[17:42:44.168]   - Field: ‘uuid’
[17:42:44.168]   - Field: ‘seed’
[17:42:44.171]   - Field: ‘version’
[17:42:44.171]   - Field: ‘result’
[17:42:44.171]   - Field: ‘asynchronous’
[17:42:44.171]   - Field: ‘calls’
[17:42:44.171]   - Field: ‘globals’
[17:42:44.171]   - Field: ‘stdout’
[17:42:44.172]   - Field: ‘earlySignal’
[17:42:44.172]   - Field: ‘lazy’
[17:42:44.172]   - Field: ‘state’
[17:42:44.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.172] - Launch lazy future ...
[17:42:44.173] Packages needed by the future expression (n = 0): <none>
[17:42:44.173] Packages needed by future strategies (n = 0): <none>
[17:42:44.174] {
[17:42:44.174]     {
[17:42:44.174]         {
[17:42:44.174]             ...future.startTime <- base::Sys.time()
[17:42:44.174]             {
[17:42:44.174]                 {
[17:42:44.174]                   {
[17:42:44.174]                     base::local({
[17:42:44.174]                       has_future <- base::requireNamespace("future", 
[17:42:44.174]                         quietly = TRUE)
[17:42:44.174]                       if (has_future) {
[17:42:44.174]                         ns <- base::getNamespace("future")
[17:42:44.174]                         version <- ns[[".package"]][["version"]]
[17:42:44.174]                         if (is.null(version)) 
[17:42:44.174]                           version <- utils::packageVersion("future")
[17:42:44.174]                       }
[17:42:44.174]                       else {
[17:42:44.174]                         version <- NULL
[17:42:44.174]                       }
[17:42:44.174]                       if (!has_future || version < "1.8.0") {
[17:42:44.174]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.174]                           "", base::R.version$version.string), 
[17:42:44.174]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.174]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.174]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.174]                             "release", "version")], collapse = " "), 
[17:42:44.174]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.174]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.174]                           info)
[17:42:44.174]                         info <- base::paste(info, collapse = "; ")
[17:42:44.174]                         if (!has_future) {
[17:42:44.174]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.174]                             info)
[17:42:44.174]                         }
[17:42:44.174]                         else {
[17:42:44.174]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.174]                             info, version)
[17:42:44.174]                         }
[17:42:44.174]                         base::stop(msg)
[17:42:44.174]                       }
[17:42:44.174]                     })
[17:42:44.174]                   }
[17:42:44.174]                   options(future.plan = NULL)
[17:42:44.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.174]                 }
[17:42:44.174]                 ...future.workdir <- getwd()
[17:42:44.174]             }
[17:42:44.174]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.174]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.174]         }
[17:42:44.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.174]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.174]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.174]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.174]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.174]             base::names(...future.oldOptions))
[17:42:44.174]     }
[17:42:44.174]     if (FALSE) {
[17:42:44.174]     }
[17:42:44.174]     else {
[17:42:44.174]         if (TRUE) {
[17:42:44.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.174]                 open = "w")
[17:42:44.174]         }
[17:42:44.174]         else {
[17:42:44.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.174]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.174]         }
[17:42:44.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.174]             base::sink(type = "output", split = FALSE)
[17:42:44.174]             base::close(...future.stdout)
[17:42:44.174]         }, add = TRUE)
[17:42:44.174]     }
[17:42:44.174]     ...future.frame <- base::sys.nframe()
[17:42:44.174]     ...future.conditions <- base::list()
[17:42:44.174]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.174]     if (FALSE) {
[17:42:44.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.174]     }
[17:42:44.174]     ...future.result <- base::tryCatch({
[17:42:44.174]         base::withCallingHandlers({
[17:42:44.174]             ...future.value <- base::withVisible(base::local({
[17:42:44.174]                 b <- a
[17:42:44.174]                 a <- 2
[17:42:44.174]                 a * b
[17:42:44.174]             }))
[17:42:44.174]             future::FutureResult(value = ...future.value$value, 
[17:42:44.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.174]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.174]                     ...future.globalenv.names))
[17:42:44.174]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.174]         }, condition = base::local({
[17:42:44.174]             c <- base::c
[17:42:44.174]             inherits <- base::inherits
[17:42:44.174]             invokeRestart <- base::invokeRestart
[17:42:44.174]             length <- base::length
[17:42:44.174]             list <- base::list
[17:42:44.174]             seq.int <- base::seq.int
[17:42:44.174]             signalCondition <- base::signalCondition
[17:42:44.174]             sys.calls <- base::sys.calls
[17:42:44.174]             `[[` <- base::`[[`
[17:42:44.174]             `+` <- base::`+`
[17:42:44.174]             `<<-` <- base::`<<-`
[17:42:44.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.174]                   3L)]
[17:42:44.174]             }
[17:42:44.174]             function(cond) {
[17:42:44.174]                 is_error <- inherits(cond, "error")
[17:42:44.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.174]                   NULL)
[17:42:44.174]                 if (is_error) {
[17:42:44.174]                   sessionInformation <- function() {
[17:42:44.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.174]                       search = base::search(), system = base::Sys.info())
[17:42:44.174]                   }
[17:42:44.174]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.174]                     cond$call), session = sessionInformation(), 
[17:42:44.174]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.174]                   signalCondition(cond)
[17:42:44.174]                 }
[17:42:44.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.174]                 "immediateCondition"))) {
[17:42:44.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.174]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.174]                   if (TRUE && !signal) {
[17:42:44.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.174]                     {
[17:42:44.174]                       inherits <- base::inherits
[17:42:44.174]                       invokeRestart <- base::invokeRestart
[17:42:44.174]                       is.null <- base::is.null
[17:42:44.174]                       muffled <- FALSE
[17:42:44.174]                       if (inherits(cond, "message")) {
[17:42:44.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.174]                         if (muffled) 
[17:42:44.174]                           invokeRestart("muffleMessage")
[17:42:44.174]                       }
[17:42:44.174]                       else if (inherits(cond, "warning")) {
[17:42:44.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.174]                         if (muffled) 
[17:42:44.174]                           invokeRestart("muffleWarning")
[17:42:44.174]                       }
[17:42:44.174]                       else if (inherits(cond, "condition")) {
[17:42:44.174]                         if (!is.null(pattern)) {
[17:42:44.174]                           computeRestarts <- base::computeRestarts
[17:42:44.174]                           grepl <- base::grepl
[17:42:44.174]                           restarts <- computeRestarts(cond)
[17:42:44.174]                           for (restart in restarts) {
[17:42:44.174]                             name <- restart$name
[17:42:44.174]                             if (is.null(name)) 
[17:42:44.174]                               next
[17:42:44.174]                             if (!grepl(pattern, name)) 
[17:42:44.174]                               next
[17:42:44.174]                             invokeRestart(restart)
[17:42:44.174]                             muffled <- TRUE
[17:42:44.174]                             break
[17:42:44.174]                           }
[17:42:44.174]                         }
[17:42:44.174]                       }
[17:42:44.174]                       invisible(muffled)
[17:42:44.174]                     }
[17:42:44.174]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.174]                   }
[17:42:44.174]                 }
[17:42:44.174]                 else {
[17:42:44.174]                   if (TRUE) {
[17:42:44.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.174]                     {
[17:42:44.174]                       inherits <- base::inherits
[17:42:44.174]                       invokeRestart <- base::invokeRestart
[17:42:44.174]                       is.null <- base::is.null
[17:42:44.174]                       muffled <- FALSE
[17:42:44.174]                       if (inherits(cond, "message")) {
[17:42:44.174]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.174]                         if (muffled) 
[17:42:44.174]                           invokeRestart("muffleMessage")
[17:42:44.174]                       }
[17:42:44.174]                       else if (inherits(cond, "warning")) {
[17:42:44.174]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.174]                         if (muffled) 
[17:42:44.174]                           invokeRestart("muffleWarning")
[17:42:44.174]                       }
[17:42:44.174]                       else if (inherits(cond, "condition")) {
[17:42:44.174]                         if (!is.null(pattern)) {
[17:42:44.174]                           computeRestarts <- base::computeRestarts
[17:42:44.174]                           grepl <- base::grepl
[17:42:44.174]                           restarts <- computeRestarts(cond)
[17:42:44.174]                           for (restart in restarts) {
[17:42:44.174]                             name <- restart$name
[17:42:44.174]                             if (is.null(name)) 
[17:42:44.174]                               next
[17:42:44.174]                             if (!grepl(pattern, name)) 
[17:42:44.174]                               next
[17:42:44.174]                             invokeRestart(restart)
[17:42:44.174]                             muffled <- TRUE
[17:42:44.174]                             break
[17:42:44.174]                           }
[17:42:44.174]                         }
[17:42:44.174]                       }
[17:42:44.174]                       invisible(muffled)
[17:42:44.174]                     }
[17:42:44.174]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.174]                   }
[17:42:44.174]                 }
[17:42:44.174]             }
[17:42:44.174]         }))
[17:42:44.174]     }, error = function(ex) {
[17:42:44.174]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.174]                 ...future.rng), started = ...future.startTime, 
[17:42:44.174]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.174]             version = "1.8"), class = "FutureResult")
[17:42:44.174]     }, finally = {
[17:42:44.174]         if (!identical(...future.workdir, getwd())) 
[17:42:44.174]             setwd(...future.workdir)
[17:42:44.174]         {
[17:42:44.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.174]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.174]             }
[17:42:44.174]             base::options(...future.oldOptions)
[17:42:44.174]             if (.Platform$OS.type == "windows") {
[17:42:44.174]                 old_names <- names(...future.oldEnvVars)
[17:42:44.174]                 envs <- base::Sys.getenv()
[17:42:44.174]                 names <- names(envs)
[17:42:44.174]                 common <- intersect(names, old_names)
[17:42:44.174]                 added <- setdiff(names, old_names)
[17:42:44.174]                 removed <- setdiff(old_names, names)
[17:42:44.174]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.174]                   envs[common]]
[17:42:44.174]                 NAMES <- toupper(changed)
[17:42:44.174]                 args <- list()
[17:42:44.174]                 for (kk in seq_along(NAMES)) {
[17:42:44.174]                   name <- changed[[kk]]
[17:42:44.174]                   NAME <- NAMES[[kk]]
[17:42:44.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.174]                     next
[17:42:44.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.174]                 }
[17:42:44.174]                 NAMES <- toupper(added)
[17:42:44.174]                 for (kk in seq_along(NAMES)) {
[17:42:44.174]                   name <- added[[kk]]
[17:42:44.174]                   NAME <- NAMES[[kk]]
[17:42:44.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.174]                     next
[17:42:44.174]                   args[[name]] <- ""
[17:42:44.174]                 }
[17:42:44.174]                 NAMES <- toupper(removed)
[17:42:44.174]                 for (kk in seq_along(NAMES)) {
[17:42:44.174]                   name <- removed[[kk]]
[17:42:44.174]                   NAME <- NAMES[[kk]]
[17:42:44.174]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.174]                     next
[17:42:44.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.174]                 }
[17:42:44.174]                 if (length(args) > 0) 
[17:42:44.174]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.174]             }
[17:42:44.174]             else {
[17:42:44.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.174]             }
[17:42:44.174]             {
[17:42:44.174]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.174]                   0L) {
[17:42:44.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.174]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.174]                   base::options(opts)
[17:42:44.174]                 }
[17:42:44.174]                 {
[17:42:44.174]                   {
[17:42:44.174]                     NULL
[17:42:44.174]                     RNGkind("Mersenne-Twister")
[17:42:44.174]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.174]                       inherits = FALSE)
[17:42:44.174]                   }
[17:42:44.174]                   options(future.plan = NULL)
[17:42:44.174]                   if (is.na(NA_character_)) 
[17:42:44.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.174]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.174]                   {
[17:42:44.174]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.174]                     if (!future$lazy) 
[17:42:44.174]                       future <- run(future)
[17:42:44.174]                     invisible(future)
[17:42:44.174]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.174]                 }
[17:42:44.174]             }
[17:42:44.174]         }
[17:42:44.174]     })
[17:42:44.174]     if (TRUE) {
[17:42:44.174]         base::sink(type = "output", split = FALSE)
[17:42:44.174]         if (TRUE) {
[17:42:44.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.174]         }
[17:42:44.174]         else {
[17:42:44.174]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.174]         }
[17:42:44.174]         base::close(...future.stdout)
[17:42:44.174]         ...future.stdout <- NULL
[17:42:44.174]     }
[17:42:44.174]     ...future.result$conditions <- ...future.conditions
[17:42:44.174]     ...future.result$finished <- base::Sys.time()
[17:42:44.174]     ...future.result
[17:42:44.174] }
[17:42:44.176] plan(): Setting new future strategy stack:
[17:42:44.176] List of future strategies:
[17:42:44.176] 1. sequential:
[17:42:44.176]    - args: function (..., envir = parent.frame())
[17:42:44.176]    - tweaked: FALSE
[17:42:44.176]    - call: NULL
[17:42:44.176] plan(): nbrOfWorkers() = 1
[17:42:44.178] plan(): Setting new future strategy stack:
[17:42:44.178] List of future strategies:
[17:42:44.178] 1. sequential:
[17:42:44.178]    - args: function (..., envir = parent.frame())
[17:42:44.178]    - tweaked: FALSE
[17:42:44.178]    - call: plan(strategy)
[17:42:44.178] plan(): nbrOfWorkers() = 1
[17:42:44.178] SequentialFuture started (and completed)
[17:42:44.179] - Launch lazy future ... done
[17:42:44.179] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.180] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.180] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.181] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.181] Searching for globals ... DONE
[17:42:44.181] Resolving globals: TRUE
[17:42:44.181] Resolving any globals that are futures ...
[17:42:44.182] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.182] Resolving any globals that are futures ... DONE
[17:42:44.182] 
[17:42:44.182] 
[17:42:44.182] getGlobalsAndPackages() ... DONE
[17:42:44.182] run() for ‘Future’ ...
[17:42:44.183] - state: ‘created’
[17:42:44.183] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.183] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.183] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.183]   - Field: ‘label’
[17:42:44.183]   - Field: ‘local’
[17:42:44.183]   - Field: ‘owner’
[17:42:44.184]   - Field: ‘envir’
[17:42:44.184]   - Field: ‘packages’
[17:42:44.184]   - Field: ‘gc’
[17:42:44.184]   - Field: ‘conditions’
[17:42:44.184]   - Field: ‘expr’
[17:42:44.184]   - Field: ‘uuid’
[17:42:44.184]   - Field: ‘seed’
[17:42:44.184]   - Field: ‘version’
[17:42:44.184]   - Field: ‘result’
[17:42:44.184]   - Field: ‘asynchronous’
[17:42:44.184]   - Field: ‘calls’
[17:42:44.185]   - Field: ‘globals’
[17:42:44.185]   - Field: ‘stdout’
[17:42:44.185]   - Field: ‘earlySignal’
[17:42:44.185]   - Field: ‘lazy’
[17:42:44.185]   - Field: ‘state’
[17:42:44.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.185] - Launch lazy future ...
[17:42:44.185] Packages needed by the future expression (n = 0): <none>
[17:42:44.185] Packages needed by future strategies (n = 0): <none>
[17:42:44.186] {
[17:42:44.186]     {
[17:42:44.186]         {
[17:42:44.186]             ...future.startTime <- base::Sys.time()
[17:42:44.186]             {
[17:42:44.186]                 {
[17:42:44.186]                   {
[17:42:44.186]                     base::local({
[17:42:44.186]                       has_future <- base::requireNamespace("future", 
[17:42:44.186]                         quietly = TRUE)
[17:42:44.186]                       if (has_future) {
[17:42:44.186]                         ns <- base::getNamespace("future")
[17:42:44.186]                         version <- ns[[".package"]][["version"]]
[17:42:44.186]                         if (is.null(version)) 
[17:42:44.186]                           version <- utils::packageVersion("future")
[17:42:44.186]                       }
[17:42:44.186]                       else {
[17:42:44.186]                         version <- NULL
[17:42:44.186]                       }
[17:42:44.186]                       if (!has_future || version < "1.8.0") {
[17:42:44.186]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.186]                           "", base::R.version$version.string), 
[17:42:44.186]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.186]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.186]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.186]                             "release", "version")], collapse = " "), 
[17:42:44.186]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.186]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.186]                           info)
[17:42:44.186]                         info <- base::paste(info, collapse = "; ")
[17:42:44.186]                         if (!has_future) {
[17:42:44.186]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.186]                             info)
[17:42:44.186]                         }
[17:42:44.186]                         else {
[17:42:44.186]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.186]                             info, version)
[17:42:44.186]                         }
[17:42:44.186]                         base::stop(msg)
[17:42:44.186]                       }
[17:42:44.186]                     })
[17:42:44.186]                   }
[17:42:44.186]                   options(future.plan = NULL)
[17:42:44.186]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.186]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.186]                 }
[17:42:44.186]                 ...future.workdir <- getwd()
[17:42:44.186]             }
[17:42:44.186]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.186]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.186]         }
[17:42:44.186]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.186]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.186]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.186]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.186]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.186]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.186]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.186]             base::names(...future.oldOptions))
[17:42:44.186]     }
[17:42:44.186]     if (FALSE) {
[17:42:44.186]     }
[17:42:44.186]     else {
[17:42:44.186]         if (TRUE) {
[17:42:44.186]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.186]                 open = "w")
[17:42:44.186]         }
[17:42:44.186]         else {
[17:42:44.186]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.186]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.186]         }
[17:42:44.186]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.186]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.186]             base::sink(type = "output", split = FALSE)
[17:42:44.186]             base::close(...future.stdout)
[17:42:44.186]         }, add = TRUE)
[17:42:44.186]     }
[17:42:44.186]     ...future.frame <- base::sys.nframe()
[17:42:44.186]     ...future.conditions <- base::list()
[17:42:44.186]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.186]     if (FALSE) {
[17:42:44.186]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.186]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.186]     }
[17:42:44.186]     ...future.result <- base::tryCatch({
[17:42:44.186]         base::withCallingHandlers({
[17:42:44.186]             ...future.value <- base::withVisible(base::local({
[17:42:44.186]                 b <- a
[17:42:44.186]                 a <- 2
[17:42:44.186]                 a * b
[17:42:44.186]             }))
[17:42:44.186]             future::FutureResult(value = ...future.value$value, 
[17:42:44.186]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.186]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.186]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.186]                     ...future.globalenv.names))
[17:42:44.186]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.186]         }, condition = base::local({
[17:42:44.186]             c <- base::c
[17:42:44.186]             inherits <- base::inherits
[17:42:44.186]             invokeRestart <- base::invokeRestart
[17:42:44.186]             length <- base::length
[17:42:44.186]             list <- base::list
[17:42:44.186]             seq.int <- base::seq.int
[17:42:44.186]             signalCondition <- base::signalCondition
[17:42:44.186]             sys.calls <- base::sys.calls
[17:42:44.186]             `[[` <- base::`[[`
[17:42:44.186]             `+` <- base::`+`
[17:42:44.186]             `<<-` <- base::`<<-`
[17:42:44.186]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.186]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.186]                   3L)]
[17:42:44.186]             }
[17:42:44.186]             function(cond) {
[17:42:44.186]                 is_error <- inherits(cond, "error")
[17:42:44.186]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.186]                   NULL)
[17:42:44.186]                 if (is_error) {
[17:42:44.186]                   sessionInformation <- function() {
[17:42:44.186]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.186]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.186]                       search = base::search(), system = base::Sys.info())
[17:42:44.186]                   }
[17:42:44.186]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.186]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.186]                     cond$call), session = sessionInformation(), 
[17:42:44.186]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.186]                   signalCondition(cond)
[17:42:44.186]                 }
[17:42:44.186]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.186]                 "immediateCondition"))) {
[17:42:44.186]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.186]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.186]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.186]                   if (TRUE && !signal) {
[17:42:44.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.186]                     {
[17:42:44.186]                       inherits <- base::inherits
[17:42:44.186]                       invokeRestart <- base::invokeRestart
[17:42:44.186]                       is.null <- base::is.null
[17:42:44.186]                       muffled <- FALSE
[17:42:44.186]                       if (inherits(cond, "message")) {
[17:42:44.186]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.186]                         if (muffled) 
[17:42:44.186]                           invokeRestart("muffleMessage")
[17:42:44.186]                       }
[17:42:44.186]                       else if (inherits(cond, "warning")) {
[17:42:44.186]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.186]                         if (muffled) 
[17:42:44.186]                           invokeRestart("muffleWarning")
[17:42:44.186]                       }
[17:42:44.186]                       else if (inherits(cond, "condition")) {
[17:42:44.186]                         if (!is.null(pattern)) {
[17:42:44.186]                           computeRestarts <- base::computeRestarts
[17:42:44.186]                           grepl <- base::grepl
[17:42:44.186]                           restarts <- computeRestarts(cond)
[17:42:44.186]                           for (restart in restarts) {
[17:42:44.186]                             name <- restart$name
[17:42:44.186]                             if (is.null(name)) 
[17:42:44.186]                               next
[17:42:44.186]                             if (!grepl(pattern, name)) 
[17:42:44.186]                               next
[17:42:44.186]                             invokeRestart(restart)
[17:42:44.186]                             muffled <- TRUE
[17:42:44.186]                             break
[17:42:44.186]                           }
[17:42:44.186]                         }
[17:42:44.186]                       }
[17:42:44.186]                       invisible(muffled)
[17:42:44.186]                     }
[17:42:44.186]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.186]                   }
[17:42:44.186]                 }
[17:42:44.186]                 else {
[17:42:44.186]                   if (TRUE) {
[17:42:44.186]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.186]                     {
[17:42:44.186]                       inherits <- base::inherits
[17:42:44.186]                       invokeRestart <- base::invokeRestart
[17:42:44.186]                       is.null <- base::is.null
[17:42:44.186]                       muffled <- FALSE
[17:42:44.186]                       if (inherits(cond, "message")) {
[17:42:44.186]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.186]                         if (muffled) 
[17:42:44.186]                           invokeRestart("muffleMessage")
[17:42:44.186]                       }
[17:42:44.186]                       else if (inherits(cond, "warning")) {
[17:42:44.186]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.186]                         if (muffled) 
[17:42:44.186]                           invokeRestart("muffleWarning")
[17:42:44.186]                       }
[17:42:44.186]                       else if (inherits(cond, "condition")) {
[17:42:44.186]                         if (!is.null(pattern)) {
[17:42:44.186]                           computeRestarts <- base::computeRestarts
[17:42:44.186]                           grepl <- base::grepl
[17:42:44.186]                           restarts <- computeRestarts(cond)
[17:42:44.186]                           for (restart in restarts) {
[17:42:44.186]                             name <- restart$name
[17:42:44.186]                             if (is.null(name)) 
[17:42:44.186]                               next
[17:42:44.186]                             if (!grepl(pattern, name)) 
[17:42:44.186]                               next
[17:42:44.186]                             invokeRestart(restart)
[17:42:44.186]                             muffled <- TRUE
[17:42:44.186]                             break
[17:42:44.186]                           }
[17:42:44.186]                         }
[17:42:44.186]                       }
[17:42:44.186]                       invisible(muffled)
[17:42:44.186]                     }
[17:42:44.186]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.186]                   }
[17:42:44.186]                 }
[17:42:44.186]             }
[17:42:44.186]         }))
[17:42:44.186]     }, error = function(ex) {
[17:42:44.186]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.186]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.186]                 ...future.rng), started = ...future.startTime, 
[17:42:44.186]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.186]             version = "1.8"), class = "FutureResult")
[17:42:44.186]     }, finally = {
[17:42:44.186]         if (!identical(...future.workdir, getwd())) 
[17:42:44.186]             setwd(...future.workdir)
[17:42:44.186]         {
[17:42:44.186]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.186]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.186]             }
[17:42:44.186]             base::options(...future.oldOptions)
[17:42:44.186]             if (.Platform$OS.type == "windows") {
[17:42:44.186]                 old_names <- names(...future.oldEnvVars)
[17:42:44.186]                 envs <- base::Sys.getenv()
[17:42:44.186]                 names <- names(envs)
[17:42:44.186]                 common <- intersect(names, old_names)
[17:42:44.186]                 added <- setdiff(names, old_names)
[17:42:44.186]                 removed <- setdiff(old_names, names)
[17:42:44.186]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.186]                   envs[common]]
[17:42:44.186]                 NAMES <- toupper(changed)
[17:42:44.186]                 args <- list()
[17:42:44.186]                 for (kk in seq_along(NAMES)) {
[17:42:44.186]                   name <- changed[[kk]]
[17:42:44.186]                   NAME <- NAMES[[kk]]
[17:42:44.186]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.186]                     next
[17:42:44.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.186]                 }
[17:42:44.186]                 NAMES <- toupper(added)
[17:42:44.186]                 for (kk in seq_along(NAMES)) {
[17:42:44.186]                   name <- added[[kk]]
[17:42:44.186]                   NAME <- NAMES[[kk]]
[17:42:44.186]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.186]                     next
[17:42:44.186]                   args[[name]] <- ""
[17:42:44.186]                 }
[17:42:44.186]                 NAMES <- toupper(removed)
[17:42:44.186]                 for (kk in seq_along(NAMES)) {
[17:42:44.186]                   name <- removed[[kk]]
[17:42:44.186]                   NAME <- NAMES[[kk]]
[17:42:44.186]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.186]                     next
[17:42:44.186]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.186]                 }
[17:42:44.186]                 if (length(args) > 0) 
[17:42:44.186]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.186]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.186]             }
[17:42:44.186]             else {
[17:42:44.186]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.186]             }
[17:42:44.186]             {
[17:42:44.186]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.186]                   0L) {
[17:42:44.186]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.186]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.186]                   base::options(opts)
[17:42:44.186]                 }
[17:42:44.186]                 {
[17:42:44.186]                   {
[17:42:44.186]                     NULL
[17:42:44.186]                     RNGkind("Mersenne-Twister")
[17:42:44.186]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.186]                       inherits = FALSE)
[17:42:44.186]                   }
[17:42:44.186]                   options(future.plan = NULL)
[17:42:44.186]                   if (is.na(NA_character_)) 
[17:42:44.186]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.186]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.186]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.186]                   {
[17:42:44.186]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.186]                     if (!future$lazy) 
[17:42:44.186]                       future <- run(future)
[17:42:44.186]                     invisible(future)
[17:42:44.186]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.186]                 }
[17:42:44.186]             }
[17:42:44.186]         }
[17:42:44.186]     })
[17:42:44.186]     if (TRUE) {
[17:42:44.186]         base::sink(type = "output", split = FALSE)
[17:42:44.186]         if (TRUE) {
[17:42:44.186]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.186]         }
[17:42:44.186]         else {
[17:42:44.186]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.186]         }
[17:42:44.186]         base::close(...future.stdout)
[17:42:44.186]         ...future.stdout <- NULL
[17:42:44.186]     }
[17:42:44.186]     ...future.result$conditions <- ...future.conditions
[17:42:44.186]     ...future.result$finished <- base::Sys.time()
[17:42:44.186]     ...future.result
[17:42:44.186] }
[17:42:44.188] plan(): Setting new future strategy stack:
[17:42:44.188] List of future strategies:
[17:42:44.188] 1. sequential:
[17:42:44.188]    - args: function (..., envir = parent.frame())
[17:42:44.188]    - tweaked: FALSE
[17:42:44.188]    - call: NULL
[17:42:44.188] plan(): nbrOfWorkers() = 1
[17:42:44.189] plan(): Setting new future strategy stack:
[17:42:44.189] List of future strategies:
[17:42:44.189] 1. sequential:
[17:42:44.189]    - args: function (..., envir = parent.frame())
[17:42:44.189]    - tweaked: FALSE
[17:42:44.189]    - call: plan(strategy)
[17:42:44.189] plan(): nbrOfWorkers() = 1
[17:42:44.190] SequentialFuture started (and completed)
[17:42:44.190] signalConditions() ...
[17:42:44.190]  - include = ‘immediateCondition’
[17:42:44.190]  - exclude = 
[17:42:44.190]  - resignal = FALSE
[17:42:44.190]  - Number of conditions: 1
[17:42:44.190] signalConditions() ... done
[17:42:44.190] - Launch lazy future ... done
[17:42:44.190] run() for ‘SequentialFuture’ ... done
[17:42:44.190] signalConditions() ...
[17:42:44.191]  - include = ‘immediateCondition’
[17:42:44.191]  - exclude = 
[17:42:44.191]  - resignal = FALSE
[17:42:44.191]  - Number of conditions: 1
[17:42:44.191] signalConditions() ... done
[17:42:44.191] Future state: ‘finished’
[17:42:44.191] signalConditions() ...
[17:42:44.191]  - include = ‘condition’
[17:42:44.191]  - exclude = ‘immediateCondition’
[17:42:44.191]  - resignal = TRUE
[17:42:44.192]  - Number of conditions: 1
[17:42:44.192]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:44.192] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:44"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.211] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.211] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.213] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.213] Searching for globals ... DONE
[17:42:44.213] Resolving globals: TRUE
[17:42:44.213] Resolving any globals that are futures ...
[17:42:44.213] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.213] Resolving any globals that are futures ... DONE
[17:42:44.214] Resolving futures part of globals (recursively) ...
[17:42:44.214] resolve() on list ...
[17:42:44.214]  recursive: 99
[17:42:44.215]  length: 1
[17:42:44.215]  elements: ‘ii’
[17:42:44.215]  length: 0 (resolved future 1)
[17:42:44.215] resolve() on list ... DONE
[17:42:44.215] - globals: [1] ‘ii’
[17:42:44.215] Resolving futures part of globals (recursively) ... DONE
[17:42:44.216] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.216] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.216] - globals: [1] ‘ii’
[17:42:44.216] 
[17:42:44.217] getGlobalsAndPackages() ... DONE
[17:42:44.217] run() for ‘Future’ ...
[17:42:44.217] - state: ‘created’
[17:42:44.217] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.218]   - Field: ‘label’
[17:42:44.218]   - Field: ‘local’
[17:42:44.218]   - Field: ‘owner’
[17:42:44.218]   - Field: ‘envir’
[17:42:44.218]   - Field: ‘packages’
[17:42:44.218]   - Field: ‘gc’
[17:42:44.218]   - Field: ‘conditions’
[17:42:44.218]   - Field: ‘expr’
[17:42:44.218]   - Field: ‘uuid’
[17:42:44.218]   - Field: ‘seed’
[17:42:44.219]   - Field: ‘version’
[17:42:44.219]   - Field: ‘result’
[17:42:44.219]   - Field: ‘asynchronous’
[17:42:44.219]   - Field: ‘calls’
[17:42:44.219]   - Field: ‘globals’
[17:42:44.219]   - Field: ‘stdout’
[17:42:44.219]   - Field: ‘earlySignal’
[17:42:44.219]   - Field: ‘lazy’
[17:42:44.219]   - Field: ‘state’
[17:42:44.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.220] - Launch lazy future ...
[17:42:44.220] Packages needed by the future expression (n = 0): <none>
[17:42:44.220] Packages needed by future strategies (n = 0): <none>
[17:42:44.220] {
[17:42:44.220]     {
[17:42:44.220]         {
[17:42:44.220]             ...future.startTime <- base::Sys.time()
[17:42:44.220]             {
[17:42:44.220]                 {
[17:42:44.220]                   {
[17:42:44.220]                     base::local({
[17:42:44.220]                       has_future <- base::requireNamespace("future", 
[17:42:44.220]                         quietly = TRUE)
[17:42:44.220]                       if (has_future) {
[17:42:44.220]                         ns <- base::getNamespace("future")
[17:42:44.220]                         version <- ns[[".package"]][["version"]]
[17:42:44.220]                         if (is.null(version)) 
[17:42:44.220]                           version <- utils::packageVersion("future")
[17:42:44.220]                       }
[17:42:44.220]                       else {
[17:42:44.220]                         version <- NULL
[17:42:44.220]                       }
[17:42:44.220]                       if (!has_future || version < "1.8.0") {
[17:42:44.220]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.220]                           "", base::R.version$version.string), 
[17:42:44.220]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.220]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.220]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.220]                             "release", "version")], collapse = " "), 
[17:42:44.220]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.220]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.220]                           info)
[17:42:44.220]                         info <- base::paste(info, collapse = "; ")
[17:42:44.220]                         if (!has_future) {
[17:42:44.220]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.220]                             info)
[17:42:44.220]                         }
[17:42:44.220]                         else {
[17:42:44.220]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.220]                             info, version)
[17:42:44.220]                         }
[17:42:44.220]                         base::stop(msg)
[17:42:44.220]                       }
[17:42:44.220]                     })
[17:42:44.220]                   }
[17:42:44.220]                   options(future.plan = NULL)
[17:42:44.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.220]                 }
[17:42:44.220]                 ...future.workdir <- getwd()
[17:42:44.220]             }
[17:42:44.220]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.220]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.220]         }
[17:42:44.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.220]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.220]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.220]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.220]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.220]             base::names(...future.oldOptions))
[17:42:44.220]     }
[17:42:44.220]     if (FALSE) {
[17:42:44.220]     }
[17:42:44.220]     else {
[17:42:44.220]         if (TRUE) {
[17:42:44.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.220]                 open = "w")
[17:42:44.220]         }
[17:42:44.220]         else {
[17:42:44.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.220]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.220]         }
[17:42:44.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.220]             base::sink(type = "output", split = FALSE)
[17:42:44.220]             base::close(...future.stdout)
[17:42:44.220]         }, add = TRUE)
[17:42:44.220]     }
[17:42:44.220]     ...future.frame <- base::sys.nframe()
[17:42:44.220]     ...future.conditions <- base::list()
[17:42:44.220]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.220]     if (FALSE) {
[17:42:44.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.220]     }
[17:42:44.220]     ...future.result <- base::tryCatch({
[17:42:44.220]         base::withCallingHandlers({
[17:42:44.220]             ...future.value <- base::withVisible(base::local({
[17:42:44.220]                 b <- a * ii
[17:42:44.220]                 a <- 0
[17:42:44.220]                 b
[17:42:44.220]             }))
[17:42:44.220]             future::FutureResult(value = ...future.value$value, 
[17:42:44.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.220]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.220]                     ...future.globalenv.names))
[17:42:44.220]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.220]         }, condition = base::local({
[17:42:44.220]             c <- base::c
[17:42:44.220]             inherits <- base::inherits
[17:42:44.220]             invokeRestart <- base::invokeRestart
[17:42:44.220]             length <- base::length
[17:42:44.220]             list <- base::list
[17:42:44.220]             seq.int <- base::seq.int
[17:42:44.220]             signalCondition <- base::signalCondition
[17:42:44.220]             sys.calls <- base::sys.calls
[17:42:44.220]             `[[` <- base::`[[`
[17:42:44.220]             `+` <- base::`+`
[17:42:44.220]             `<<-` <- base::`<<-`
[17:42:44.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.220]                   3L)]
[17:42:44.220]             }
[17:42:44.220]             function(cond) {
[17:42:44.220]                 is_error <- inherits(cond, "error")
[17:42:44.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.220]                   NULL)
[17:42:44.220]                 if (is_error) {
[17:42:44.220]                   sessionInformation <- function() {
[17:42:44.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.220]                       search = base::search(), system = base::Sys.info())
[17:42:44.220]                   }
[17:42:44.220]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.220]                     cond$call), session = sessionInformation(), 
[17:42:44.220]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.220]                   signalCondition(cond)
[17:42:44.220]                 }
[17:42:44.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.220]                 "immediateCondition"))) {
[17:42:44.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.220]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.220]                   if (TRUE && !signal) {
[17:42:44.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.220]                     {
[17:42:44.220]                       inherits <- base::inherits
[17:42:44.220]                       invokeRestart <- base::invokeRestart
[17:42:44.220]                       is.null <- base::is.null
[17:42:44.220]                       muffled <- FALSE
[17:42:44.220]                       if (inherits(cond, "message")) {
[17:42:44.220]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.220]                         if (muffled) 
[17:42:44.220]                           invokeRestart("muffleMessage")
[17:42:44.220]                       }
[17:42:44.220]                       else if (inherits(cond, "warning")) {
[17:42:44.220]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.220]                         if (muffled) 
[17:42:44.220]                           invokeRestart("muffleWarning")
[17:42:44.220]                       }
[17:42:44.220]                       else if (inherits(cond, "condition")) {
[17:42:44.220]                         if (!is.null(pattern)) {
[17:42:44.220]                           computeRestarts <- base::computeRestarts
[17:42:44.220]                           grepl <- base::grepl
[17:42:44.220]                           restarts <- computeRestarts(cond)
[17:42:44.220]                           for (restart in restarts) {
[17:42:44.220]                             name <- restart$name
[17:42:44.220]                             if (is.null(name)) 
[17:42:44.220]                               next
[17:42:44.220]                             if (!grepl(pattern, name)) 
[17:42:44.220]                               next
[17:42:44.220]                             invokeRestart(restart)
[17:42:44.220]                             muffled <- TRUE
[17:42:44.220]                             break
[17:42:44.220]                           }
[17:42:44.220]                         }
[17:42:44.220]                       }
[17:42:44.220]                       invisible(muffled)
[17:42:44.220]                     }
[17:42:44.220]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.220]                   }
[17:42:44.220]                 }
[17:42:44.220]                 else {
[17:42:44.220]                   if (TRUE) {
[17:42:44.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.220]                     {
[17:42:44.220]                       inherits <- base::inherits
[17:42:44.220]                       invokeRestart <- base::invokeRestart
[17:42:44.220]                       is.null <- base::is.null
[17:42:44.220]                       muffled <- FALSE
[17:42:44.220]                       if (inherits(cond, "message")) {
[17:42:44.220]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.220]                         if (muffled) 
[17:42:44.220]                           invokeRestart("muffleMessage")
[17:42:44.220]                       }
[17:42:44.220]                       else if (inherits(cond, "warning")) {
[17:42:44.220]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.220]                         if (muffled) 
[17:42:44.220]                           invokeRestart("muffleWarning")
[17:42:44.220]                       }
[17:42:44.220]                       else if (inherits(cond, "condition")) {
[17:42:44.220]                         if (!is.null(pattern)) {
[17:42:44.220]                           computeRestarts <- base::computeRestarts
[17:42:44.220]                           grepl <- base::grepl
[17:42:44.220]                           restarts <- computeRestarts(cond)
[17:42:44.220]                           for (restart in restarts) {
[17:42:44.220]                             name <- restart$name
[17:42:44.220]                             if (is.null(name)) 
[17:42:44.220]                               next
[17:42:44.220]                             if (!grepl(pattern, name)) 
[17:42:44.220]                               next
[17:42:44.220]                             invokeRestart(restart)
[17:42:44.220]                             muffled <- TRUE
[17:42:44.220]                             break
[17:42:44.220]                           }
[17:42:44.220]                         }
[17:42:44.220]                       }
[17:42:44.220]                       invisible(muffled)
[17:42:44.220]                     }
[17:42:44.220]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.220]                   }
[17:42:44.220]                 }
[17:42:44.220]             }
[17:42:44.220]         }))
[17:42:44.220]     }, error = function(ex) {
[17:42:44.220]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.220]                 ...future.rng), started = ...future.startTime, 
[17:42:44.220]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.220]             version = "1.8"), class = "FutureResult")
[17:42:44.220]     }, finally = {
[17:42:44.220]         if (!identical(...future.workdir, getwd())) 
[17:42:44.220]             setwd(...future.workdir)
[17:42:44.220]         {
[17:42:44.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.220]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.220]             }
[17:42:44.220]             base::options(...future.oldOptions)
[17:42:44.220]             if (.Platform$OS.type == "windows") {
[17:42:44.220]                 old_names <- names(...future.oldEnvVars)
[17:42:44.220]                 envs <- base::Sys.getenv()
[17:42:44.220]                 names <- names(envs)
[17:42:44.220]                 common <- intersect(names, old_names)
[17:42:44.220]                 added <- setdiff(names, old_names)
[17:42:44.220]                 removed <- setdiff(old_names, names)
[17:42:44.220]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.220]                   envs[common]]
[17:42:44.220]                 NAMES <- toupper(changed)
[17:42:44.220]                 args <- list()
[17:42:44.220]                 for (kk in seq_along(NAMES)) {
[17:42:44.220]                   name <- changed[[kk]]
[17:42:44.220]                   NAME <- NAMES[[kk]]
[17:42:44.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.220]                     next
[17:42:44.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.220]                 }
[17:42:44.220]                 NAMES <- toupper(added)
[17:42:44.220]                 for (kk in seq_along(NAMES)) {
[17:42:44.220]                   name <- added[[kk]]
[17:42:44.220]                   NAME <- NAMES[[kk]]
[17:42:44.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.220]                     next
[17:42:44.220]                   args[[name]] <- ""
[17:42:44.220]                 }
[17:42:44.220]                 NAMES <- toupper(removed)
[17:42:44.220]                 for (kk in seq_along(NAMES)) {
[17:42:44.220]                   name <- removed[[kk]]
[17:42:44.220]                   NAME <- NAMES[[kk]]
[17:42:44.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.220]                     next
[17:42:44.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.220]                 }
[17:42:44.220]                 if (length(args) > 0) 
[17:42:44.220]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.220]             }
[17:42:44.220]             else {
[17:42:44.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.220]             }
[17:42:44.220]             {
[17:42:44.220]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.220]                   0L) {
[17:42:44.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.220]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.220]                   base::options(opts)
[17:42:44.220]                 }
[17:42:44.220]                 {
[17:42:44.220]                   {
[17:42:44.220]                     NULL
[17:42:44.220]                     RNGkind("Mersenne-Twister")
[17:42:44.220]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.220]                       inherits = FALSE)
[17:42:44.220]                   }
[17:42:44.220]                   options(future.plan = NULL)
[17:42:44.220]                   if (is.na(NA_character_)) 
[17:42:44.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.220]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.220]                   {
[17:42:44.220]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.220]                     if (!future$lazy) 
[17:42:44.220]                       future <- run(future)
[17:42:44.220]                     invisible(future)
[17:42:44.220]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.220]                 }
[17:42:44.220]             }
[17:42:44.220]         }
[17:42:44.220]     })
[17:42:44.220]     if (TRUE) {
[17:42:44.220]         base::sink(type = "output", split = FALSE)
[17:42:44.220]         if (TRUE) {
[17:42:44.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.220]         }
[17:42:44.220]         else {
[17:42:44.220]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.220]         }
[17:42:44.220]         base::close(...future.stdout)
[17:42:44.220]         ...future.stdout <- NULL
[17:42:44.220]     }
[17:42:44.220]     ...future.result$conditions <- ...future.conditions
[17:42:44.220]     ...future.result$finished <- base::Sys.time()
[17:42:44.220]     ...future.result
[17:42:44.220] }
[17:42:44.222] assign_globals() ...
[17:42:44.222] List of 1
[17:42:44.222]  $ ii: int 1
[17:42:44.222]  - attr(*, "where")=List of 1
[17:42:44.222]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.222]  - attr(*, "resolved")= logi TRUE
[17:42:44.222]  - attr(*, "total_size")= num 56
[17:42:44.222]  - attr(*, "already-done")= logi TRUE
[17:42:44.225] - copied ‘ii’ to environment
[17:42:44.225] assign_globals() ... done
[17:42:44.225] plan(): Setting new future strategy stack:
[17:42:44.225] List of future strategies:
[17:42:44.225] 1. sequential:
[17:42:44.225]    - args: function (..., envir = parent.frame())
[17:42:44.225]    - tweaked: FALSE
[17:42:44.225]    - call: NULL
[17:42:44.225] plan(): nbrOfWorkers() = 1
[17:42:44.226] plan(): Setting new future strategy stack:
[17:42:44.226] List of future strategies:
[17:42:44.226] 1. sequential:
[17:42:44.226]    - args: function (..., envir = parent.frame())
[17:42:44.226]    - tweaked: FALSE
[17:42:44.226]    - call: plan(strategy)
[17:42:44.227] plan(): nbrOfWorkers() = 1
[17:42:44.227] SequentialFuture started (and completed)
[17:42:44.227] - Launch lazy future ... done
[17:42:44.227] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.227] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.228] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.229] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.229] Searching for globals ... DONE
[17:42:44.229] Resolving globals: TRUE
[17:42:44.229] Resolving any globals that are futures ...
[17:42:44.229] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.229] Resolving any globals that are futures ... DONE
[17:42:44.230] Resolving futures part of globals (recursively) ...
[17:42:44.230] resolve() on list ...
[17:42:44.230]  recursive: 99
[17:42:44.230]  length: 1
[17:42:44.230]  elements: ‘ii’
[17:42:44.230]  length: 0 (resolved future 1)
[17:42:44.230] resolve() on list ... DONE
[17:42:44.231] - globals: [1] ‘ii’
[17:42:44.231] Resolving futures part of globals (recursively) ... DONE
[17:42:44.231] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.231] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.231] - globals: [1] ‘ii’
[17:42:44.231] 
[17:42:44.231] getGlobalsAndPackages() ... DONE
[17:42:44.232] run() for ‘Future’ ...
[17:42:44.232] - state: ‘created’
[17:42:44.232] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.232] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.232]   - Field: ‘label’
[17:42:44.232]   - Field: ‘local’
[17:42:44.233]   - Field: ‘owner’
[17:42:44.233]   - Field: ‘envir’
[17:42:44.233]   - Field: ‘packages’
[17:42:44.233]   - Field: ‘gc’
[17:42:44.233]   - Field: ‘conditions’
[17:42:44.233]   - Field: ‘expr’
[17:42:44.233]   - Field: ‘uuid’
[17:42:44.233]   - Field: ‘seed’
[17:42:44.233]   - Field: ‘version’
[17:42:44.233]   - Field: ‘result’
[17:42:44.234]   - Field: ‘asynchronous’
[17:42:44.234]   - Field: ‘calls’
[17:42:44.234]   - Field: ‘globals’
[17:42:44.234]   - Field: ‘stdout’
[17:42:44.234]   - Field: ‘earlySignal’
[17:42:44.236]   - Field: ‘lazy’
[17:42:44.236]   - Field: ‘state’
[17:42:44.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.236] - Launch lazy future ...
[17:42:44.236] Packages needed by the future expression (n = 0): <none>
[17:42:44.237] Packages needed by future strategies (n = 0): <none>
[17:42:44.237] {
[17:42:44.237]     {
[17:42:44.237]         {
[17:42:44.237]             ...future.startTime <- base::Sys.time()
[17:42:44.237]             {
[17:42:44.237]                 {
[17:42:44.237]                   {
[17:42:44.237]                     base::local({
[17:42:44.237]                       has_future <- base::requireNamespace("future", 
[17:42:44.237]                         quietly = TRUE)
[17:42:44.237]                       if (has_future) {
[17:42:44.237]                         ns <- base::getNamespace("future")
[17:42:44.237]                         version <- ns[[".package"]][["version"]]
[17:42:44.237]                         if (is.null(version)) 
[17:42:44.237]                           version <- utils::packageVersion("future")
[17:42:44.237]                       }
[17:42:44.237]                       else {
[17:42:44.237]                         version <- NULL
[17:42:44.237]                       }
[17:42:44.237]                       if (!has_future || version < "1.8.0") {
[17:42:44.237]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.237]                           "", base::R.version$version.string), 
[17:42:44.237]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.237]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.237]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.237]                             "release", "version")], collapse = " "), 
[17:42:44.237]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.237]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.237]                           info)
[17:42:44.237]                         info <- base::paste(info, collapse = "; ")
[17:42:44.237]                         if (!has_future) {
[17:42:44.237]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.237]                             info)
[17:42:44.237]                         }
[17:42:44.237]                         else {
[17:42:44.237]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.237]                             info, version)
[17:42:44.237]                         }
[17:42:44.237]                         base::stop(msg)
[17:42:44.237]                       }
[17:42:44.237]                     })
[17:42:44.237]                   }
[17:42:44.237]                   options(future.plan = NULL)
[17:42:44.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.237]                 }
[17:42:44.237]                 ...future.workdir <- getwd()
[17:42:44.237]             }
[17:42:44.237]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.237]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.237]         }
[17:42:44.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.237]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.237]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.237]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.237]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.237]             base::names(...future.oldOptions))
[17:42:44.237]     }
[17:42:44.237]     if (FALSE) {
[17:42:44.237]     }
[17:42:44.237]     else {
[17:42:44.237]         if (TRUE) {
[17:42:44.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.237]                 open = "w")
[17:42:44.237]         }
[17:42:44.237]         else {
[17:42:44.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.237]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.237]         }
[17:42:44.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.237]             base::sink(type = "output", split = FALSE)
[17:42:44.237]             base::close(...future.stdout)
[17:42:44.237]         }, add = TRUE)
[17:42:44.237]     }
[17:42:44.237]     ...future.frame <- base::sys.nframe()
[17:42:44.237]     ...future.conditions <- base::list()
[17:42:44.237]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.237]     if (FALSE) {
[17:42:44.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.237]     }
[17:42:44.237]     ...future.result <- base::tryCatch({
[17:42:44.237]         base::withCallingHandlers({
[17:42:44.237]             ...future.value <- base::withVisible(base::local({
[17:42:44.237]                 b <- a * ii
[17:42:44.237]                 a <- 0
[17:42:44.237]                 b
[17:42:44.237]             }))
[17:42:44.237]             future::FutureResult(value = ...future.value$value, 
[17:42:44.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.237]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.237]                     ...future.globalenv.names))
[17:42:44.237]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.237]         }, condition = base::local({
[17:42:44.237]             c <- base::c
[17:42:44.237]             inherits <- base::inherits
[17:42:44.237]             invokeRestart <- base::invokeRestart
[17:42:44.237]             length <- base::length
[17:42:44.237]             list <- base::list
[17:42:44.237]             seq.int <- base::seq.int
[17:42:44.237]             signalCondition <- base::signalCondition
[17:42:44.237]             sys.calls <- base::sys.calls
[17:42:44.237]             `[[` <- base::`[[`
[17:42:44.237]             `+` <- base::`+`
[17:42:44.237]             `<<-` <- base::`<<-`
[17:42:44.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.237]                   3L)]
[17:42:44.237]             }
[17:42:44.237]             function(cond) {
[17:42:44.237]                 is_error <- inherits(cond, "error")
[17:42:44.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.237]                   NULL)
[17:42:44.237]                 if (is_error) {
[17:42:44.237]                   sessionInformation <- function() {
[17:42:44.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.237]                       search = base::search(), system = base::Sys.info())
[17:42:44.237]                   }
[17:42:44.237]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.237]                     cond$call), session = sessionInformation(), 
[17:42:44.237]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.237]                   signalCondition(cond)
[17:42:44.237]                 }
[17:42:44.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.237]                 "immediateCondition"))) {
[17:42:44.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.237]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.237]                   if (TRUE && !signal) {
[17:42:44.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.237]                     {
[17:42:44.237]                       inherits <- base::inherits
[17:42:44.237]                       invokeRestart <- base::invokeRestart
[17:42:44.237]                       is.null <- base::is.null
[17:42:44.237]                       muffled <- FALSE
[17:42:44.237]                       if (inherits(cond, "message")) {
[17:42:44.237]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.237]                         if (muffled) 
[17:42:44.237]                           invokeRestart("muffleMessage")
[17:42:44.237]                       }
[17:42:44.237]                       else if (inherits(cond, "warning")) {
[17:42:44.237]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.237]                         if (muffled) 
[17:42:44.237]                           invokeRestart("muffleWarning")
[17:42:44.237]                       }
[17:42:44.237]                       else if (inherits(cond, "condition")) {
[17:42:44.237]                         if (!is.null(pattern)) {
[17:42:44.237]                           computeRestarts <- base::computeRestarts
[17:42:44.237]                           grepl <- base::grepl
[17:42:44.237]                           restarts <- computeRestarts(cond)
[17:42:44.237]                           for (restart in restarts) {
[17:42:44.237]                             name <- restart$name
[17:42:44.237]                             if (is.null(name)) 
[17:42:44.237]                               next
[17:42:44.237]                             if (!grepl(pattern, name)) 
[17:42:44.237]                               next
[17:42:44.237]                             invokeRestart(restart)
[17:42:44.237]                             muffled <- TRUE
[17:42:44.237]                             break
[17:42:44.237]                           }
[17:42:44.237]                         }
[17:42:44.237]                       }
[17:42:44.237]                       invisible(muffled)
[17:42:44.237]                     }
[17:42:44.237]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.237]                   }
[17:42:44.237]                 }
[17:42:44.237]                 else {
[17:42:44.237]                   if (TRUE) {
[17:42:44.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.237]                     {
[17:42:44.237]                       inherits <- base::inherits
[17:42:44.237]                       invokeRestart <- base::invokeRestart
[17:42:44.237]                       is.null <- base::is.null
[17:42:44.237]                       muffled <- FALSE
[17:42:44.237]                       if (inherits(cond, "message")) {
[17:42:44.237]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.237]                         if (muffled) 
[17:42:44.237]                           invokeRestart("muffleMessage")
[17:42:44.237]                       }
[17:42:44.237]                       else if (inherits(cond, "warning")) {
[17:42:44.237]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.237]                         if (muffled) 
[17:42:44.237]                           invokeRestart("muffleWarning")
[17:42:44.237]                       }
[17:42:44.237]                       else if (inherits(cond, "condition")) {
[17:42:44.237]                         if (!is.null(pattern)) {
[17:42:44.237]                           computeRestarts <- base::computeRestarts
[17:42:44.237]                           grepl <- base::grepl
[17:42:44.237]                           restarts <- computeRestarts(cond)
[17:42:44.237]                           for (restart in restarts) {
[17:42:44.237]                             name <- restart$name
[17:42:44.237]                             if (is.null(name)) 
[17:42:44.237]                               next
[17:42:44.237]                             if (!grepl(pattern, name)) 
[17:42:44.237]                               next
[17:42:44.237]                             invokeRestart(restart)
[17:42:44.237]                             muffled <- TRUE
[17:42:44.237]                             break
[17:42:44.237]                           }
[17:42:44.237]                         }
[17:42:44.237]                       }
[17:42:44.237]                       invisible(muffled)
[17:42:44.237]                     }
[17:42:44.237]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.237]                   }
[17:42:44.237]                 }
[17:42:44.237]             }
[17:42:44.237]         }))
[17:42:44.237]     }, error = function(ex) {
[17:42:44.237]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.237]                 ...future.rng), started = ...future.startTime, 
[17:42:44.237]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.237]             version = "1.8"), class = "FutureResult")
[17:42:44.237]     }, finally = {
[17:42:44.237]         if (!identical(...future.workdir, getwd())) 
[17:42:44.237]             setwd(...future.workdir)
[17:42:44.237]         {
[17:42:44.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.237]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.237]             }
[17:42:44.237]             base::options(...future.oldOptions)
[17:42:44.237]             if (.Platform$OS.type == "windows") {
[17:42:44.237]                 old_names <- names(...future.oldEnvVars)
[17:42:44.237]                 envs <- base::Sys.getenv()
[17:42:44.237]                 names <- names(envs)
[17:42:44.237]                 common <- intersect(names, old_names)
[17:42:44.237]                 added <- setdiff(names, old_names)
[17:42:44.237]                 removed <- setdiff(old_names, names)
[17:42:44.237]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.237]                   envs[common]]
[17:42:44.237]                 NAMES <- toupper(changed)
[17:42:44.237]                 args <- list()
[17:42:44.237]                 for (kk in seq_along(NAMES)) {
[17:42:44.237]                   name <- changed[[kk]]
[17:42:44.237]                   NAME <- NAMES[[kk]]
[17:42:44.237]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.237]                     next
[17:42:44.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.237]                 }
[17:42:44.237]                 NAMES <- toupper(added)
[17:42:44.237]                 for (kk in seq_along(NAMES)) {
[17:42:44.237]                   name <- added[[kk]]
[17:42:44.237]                   NAME <- NAMES[[kk]]
[17:42:44.237]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.237]                     next
[17:42:44.237]                   args[[name]] <- ""
[17:42:44.237]                 }
[17:42:44.237]                 NAMES <- toupper(removed)
[17:42:44.237]                 for (kk in seq_along(NAMES)) {
[17:42:44.237]                   name <- removed[[kk]]
[17:42:44.237]                   NAME <- NAMES[[kk]]
[17:42:44.237]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.237]                     next
[17:42:44.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.237]                 }
[17:42:44.237]                 if (length(args) > 0) 
[17:42:44.237]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.237]             }
[17:42:44.237]             else {
[17:42:44.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.237]             }
[17:42:44.237]             {
[17:42:44.237]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.237]                   0L) {
[17:42:44.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.237]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.237]                   base::options(opts)
[17:42:44.237]                 }
[17:42:44.237]                 {
[17:42:44.237]                   {
[17:42:44.237]                     NULL
[17:42:44.237]                     RNGkind("Mersenne-Twister")
[17:42:44.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.237]                       inherits = FALSE)
[17:42:44.237]                   }
[17:42:44.237]                   options(future.plan = NULL)
[17:42:44.237]                   if (is.na(NA_character_)) 
[17:42:44.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.237]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.237]                   {
[17:42:44.237]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.237]                     if (!future$lazy) 
[17:42:44.237]                       future <- run(future)
[17:42:44.237]                     invisible(future)
[17:42:44.237]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.237]                 }
[17:42:44.237]             }
[17:42:44.237]         }
[17:42:44.237]     })
[17:42:44.237]     if (TRUE) {
[17:42:44.237]         base::sink(type = "output", split = FALSE)
[17:42:44.237]         if (TRUE) {
[17:42:44.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.237]         }
[17:42:44.237]         else {
[17:42:44.237]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.237]         }
[17:42:44.237]         base::close(...future.stdout)
[17:42:44.237]         ...future.stdout <- NULL
[17:42:44.237]     }
[17:42:44.237]     ...future.result$conditions <- ...future.conditions
[17:42:44.237]     ...future.result$finished <- base::Sys.time()
[17:42:44.237]     ...future.result
[17:42:44.237] }
[17:42:44.239] assign_globals() ...
[17:42:44.239] List of 1
[17:42:44.239]  $ ii: int 2
[17:42:44.239]  - attr(*, "where")=List of 1
[17:42:44.239]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.239]  - attr(*, "resolved")= logi TRUE
[17:42:44.239]  - attr(*, "total_size")= num 56
[17:42:44.239]  - attr(*, "already-done")= logi TRUE
[17:42:44.241] - copied ‘ii’ to environment
[17:42:44.241] assign_globals() ... done
[17:42:44.242] plan(): Setting new future strategy stack:
[17:42:44.242] List of future strategies:
[17:42:44.242] 1. sequential:
[17:42:44.242]    - args: function (..., envir = parent.frame())
[17:42:44.242]    - tweaked: FALSE
[17:42:44.242]    - call: NULL
[17:42:44.242] plan(): nbrOfWorkers() = 1
[17:42:44.243] plan(): Setting new future strategy stack:
[17:42:44.243] List of future strategies:
[17:42:44.243] 1. sequential:
[17:42:44.243]    - args: function (..., envir = parent.frame())
[17:42:44.243]    - tweaked: FALSE
[17:42:44.243]    - call: plan(strategy)
[17:42:44.243] plan(): nbrOfWorkers() = 1
[17:42:44.244] SequentialFuture started (and completed)
[17:42:44.244] - Launch lazy future ... done
[17:42:44.244] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.244] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.245] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.246] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.246] Searching for globals ... DONE
[17:42:44.246] Resolving globals: TRUE
[17:42:44.246] Resolving any globals that are futures ...
[17:42:44.246] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.246] Resolving any globals that are futures ... DONE
[17:42:44.247] Resolving futures part of globals (recursively) ...
[17:42:44.247] resolve() on list ...
[17:42:44.247]  recursive: 99
[17:42:44.247]  length: 1
[17:42:44.247]  elements: ‘ii’
[17:42:44.247]  length: 0 (resolved future 1)
[17:42:44.247] resolve() on list ... DONE
[17:42:44.248] - globals: [1] ‘ii’
[17:42:44.248] Resolving futures part of globals (recursively) ... DONE
[17:42:44.248] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.248] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.248] - globals: [1] ‘ii’
[17:42:44.248] 
[17:42:44.248] getGlobalsAndPackages() ... DONE
[17:42:44.249] run() for ‘Future’ ...
[17:42:44.249] - state: ‘created’
[17:42:44.249] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.249] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.249]   - Field: ‘label’
[17:42:44.249]   - Field: ‘local’
[17:42:44.250]   - Field: ‘owner’
[17:42:44.250]   - Field: ‘envir’
[17:42:44.250]   - Field: ‘packages’
[17:42:44.250]   - Field: ‘gc’
[17:42:44.250]   - Field: ‘conditions’
[17:42:44.250]   - Field: ‘expr’
[17:42:44.250]   - Field: ‘uuid’
[17:42:44.250]   - Field: ‘seed’
[17:42:44.250]   - Field: ‘version’
[17:42:44.250]   - Field: ‘result’
[17:42:44.251]   - Field: ‘asynchronous’
[17:42:44.251]   - Field: ‘calls’
[17:42:44.251]   - Field: ‘globals’
[17:42:44.251]   - Field: ‘stdout’
[17:42:44.251]   - Field: ‘earlySignal’
[17:42:44.251]   - Field: ‘lazy’
[17:42:44.251]   - Field: ‘state’
[17:42:44.251] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.251] - Launch lazy future ...
[17:42:44.251] Packages needed by the future expression (n = 0): <none>
[17:42:44.252] Packages needed by future strategies (n = 0): <none>
[17:42:44.252] {
[17:42:44.252]     {
[17:42:44.252]         {
[17:42:44.252]             ...future.startTime <- base::Sys.time()
[17:42:44.252]             {
[17:42:44.252]                 {
[17:42:44.252]                   {
[17:42:44.252]                     base::local({
[17:42:44.252]                       has_future <- base::requireNamespace("future", 
[17:42:44.252]                         quietly = TRUE)
[17:42:44.252]                       if (has_future) {
[17:42:44.252]                         ns <- base::getNamespace("future")
[17:42:44.252]                         version <- ns[[".package"]][["version"]]
[17:42:44.252]                         if (is.null(version)) 
[17:42:44.252]                           version <- utils::packageVersion("future")
[17:42:44.252]                       }
[17:42:44.252]                       else {
[17:42:44.252]                         version <- NULL
[17:42:44.252]                       }
[17:42:44.252]                       if (!has_future || version < "1.8.0") {
[17:42:44.252]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.252]                           "", base::R.version$version.string), 
[17:42:44.252]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.252]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.252]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.252]                             "release", "version")], collapse = " "), 
[17:42:44.252]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.252]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.252]                           info)
[17:42:44.252]                         info <- base::paste(info, collapse = "; ")
[17:42:44.252]                         if (!has_future) {
[17:42:44.252]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.252]                             info)
[17:42:44.252]                         }
[17:42:44.252]                         else {
[17:42:44.252]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.252]                             info, version)
[17:42:44.252]                         }
[17:42:44.252]                         base::stop(msg)
[17:42:44.252]                       }
[17:42:44.252]                     })
[17:42:44.252]                   }
[17:42:44.252]                   options(future.plan = NULL)
[17:42:44.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.252]                 }
[17:42:44.252]                 ...future.workdir <- getwd()
[17:42:44.252]             }
[17:42:44.252]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.252]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.252]         }
[17:42:44.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.252]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.252]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.252]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.252]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.252]             base::names(...future.oldOptions))
[17:42:44.252]     }
[17:42:44.252]     if (FALSE) {
[17:42:44.252]     }
[17:42:44.252]     else {
[17:42:44.252]         if (TRUE) {
[17:42:44.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.252]                 open = "w")
[17:42:44.252]         }
[17:42:44.252]         else {
[17:42:44.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.252]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.252]         }
[17:42:44.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.252]             base::sink(type = "output", split = FALSE)
[17:42:44.252]             base::close(...future.stdout)
[17:42:44.252]         }, add = TRUE)
[17:42:44.252]     }
[17:42:44.252]     ...future.frame <- base::sys.nframe()
[17:42:44.252]     ...future.conditions <- base::list()
[17:42:44.252]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.252]     if (FALSE) {
[17:42:44.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.252]     }
[17:42:44.252]     ...future.result <- base::tryCatch({
[17:42:44.252]         base::withCallingHandlers({
[17:42:44.252]             ...future.value <- base::withVisible(base::local({
[17:42:44.252]                 b <- a * ii
[17:42:44.252]                 a <- 0
[17:42:44.252]                 b
[17:42:44.252]             }))
[17:42:44.252]             future::FutureResult(value = ...future.value$value, 
[17:42:44.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.252]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.252]                     ...future.globalenv.names))
[17:42:44.252]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.252]         }, condition = base::local({
[17:42:44.252]             c <- base::c
[17:42:44.252]             inherits <- base::inherits
[17:42:44.252]             invokeRestart <- base::invokeRestart
[17:42:44.252]             length <- base::length
[17:42:44.252]             list <- base::list
[17:42:44.252]             seq.int <- base::seq.int
[17:42:44.252]             signalCondition <- base::signalCondition
[17:42:44.252]             sys.calls <- base::sys.calls
[17:42:44.252]             `[[` <- base::`[[`
[17:42:44.252]             `+` <- base::`+`
[17:42:44.252]             `<<-` <- base::`<<-`
[17:42:44.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.252]                   3L)]
[17:42:44.252]             }
[17:42:44.252]             function(cond) {
[17:42:44.252]                 is_error <- inherits(cond, "error")
[17:42:44.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.252]                   NULL)
[17:42:44.252]                 if (is_error) {
[17:42:44.252]                   sessionInformation <- function() {
[17:42:44.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.252]                       search = base::search(), system = base::Sys.info())
[17:42:44.252]                   }
[17:42:44.252]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.252]                     cond$call), session = sessionInformation(), 
[17:42:44.252]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.252]                   signalCondition(cond)
[17:42:44.252]                 }
[17:42:44.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.252]                 "immediateCondition"))) {
[17:42:44.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.252]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.252]                   if (TRUE && !signal) {
[17:42:44.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.252]                     {
[17:42:44.252]                       inherits <- base::inherits
[17:42:44.252]                       invokeRestart <- base::invokeRestart
[17:42:44.252]                       is.null <- base::is.null
[17:42:44.252]                       muffled <- FALSE
[17:42:44.252]                       if (inherits(cond, "message")) {
[17:42:44.252]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.252]                         if (muffled) 
[17:42:44.252]                           invokeRestart("muffleMessage")
[17:42:44.252]                       }
[17:42:44.252]                       else if (inherits(cond, "warning")) {
[17:42:44.252]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.252]                         if (muffled) 
[17:42:44.252]                           invokeRestart("muffleWarning")
[17:42:44.252]                       }
[17:42:44.252]                       else if (inherits(cond, "condition")) {
[17:42:44.252]                         if (!is.null(pattern)) {
[17:42:44.252]                           computeRestarts <- base::computeRestarts
[17:42:44.252]                           grepl <- base::grepl
[17:42:44.252]                           restarts <- computeRestarts(cond)
[17:42:44.252]                           for (restart in restarts) {
[17:42:44.252]                             name <- restart$name
[17:42:44.252]                             if (is.null(name)) 
[17:42:44.252]                               next
[17:42:44.252]                             if (!grepl(pattern, name)) 
[17:42:44.252]                               next
[17:42:44.252]                             invokeRestart(restart)
[17:42:44.252]                             muffled <- TRUE
[17:42:44.252]                             break
[17:42:44.252]                           }
[17:42:44.252]                         }
[17:42:44.252]                       }
[17:42:44.252]                       invisible(muffled)
[17:42:44.252]                     }
[17:42:44.252]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.252]                   }
[17:42:44.252]                 }
[17:42:44.252]                 else {
[17:42:44.252]                   if (TRUE) {
[17:42:44.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.252]                     {
[17:42:44.252]                       inherits <- base::inherits
[17:42:44.252]                       invokeRestart <- base::invokeRestart
[17:42:44.252]                       is.null <- base::is.null
[17:42:44.252]                       muffled <- FALSE
[17:42:44.252]                       if (inherits(cond, "message")) {
[17:42:44.252]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.252]                         if (muffled) 
[17:42:44.252]                           invokeRestart("muffleMessage")
[17:42:44.252]                       }
[17:42:44.252]                       else if (inherits(cond, "warning")) {
[17:42:44.252]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.252]                         if (muffled) 
[17:42:44.252]                           invokeRestart("muffleWarning")
[17:42:44.252]                       }
[17:42:44.252]                       else if (inherits(cond, "condition")) {
[17:42:44.252]                         if (!is.null(pattern)) {
[17:42:44.252]                           computeRestarts <- base::computeRestarts
[17:42:44.252]                           grepl <- base::grepl
[17:42:44.252]                           restarts <- computeRestarts(cond)
[17:42:44.252]                           for (restart in restarts) {
[17:42:44.252]                             name <- restart$name
[17:42:44.252]                             if (is.null(name)) 
[17:42:44.252]                               next
[17:42:44.252]                             if (!grepl(pattern, name)) 
[17:42:44.252]                               next
[17:42:44.252]                             invokeRestart(restart)
[17:42:44.252]                             muffled <- TRUE
[17:42:44.252]                             break
[17:42:44.252]                           }
[17:42:44.252]                         }
[17:42:44.252]                       }
[17:42:44.252]                       invisible(muffled)
[17:42:44.252]                     }
[17:42:44.252]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.252]                   }
[17:42:44.252]                 }
[17:42:44.252]             }
[17:42:44.252]         }))
[17:42:44.252]     }, error = function(ex) {
[17:42:44.252]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.252]                 ...future.rng), started = ...future.startTime, 
[17:42:44.252]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.252]             version = "1.8"), class = "FutureResult")
[17:42:44.252]     }, finally = {
[17:42:44.252]         if (!identical(...future.workdir, getwd())) 
[17:42:44.252]             setwd(...future.workdir)
[17:42:44.252]         {
[17:42:44.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.252]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.252]             }
[17:42:44.252]             base::options(...future.oldOptions)
[17:42:44.252]             if (.Platform$OS.type == "windows") {
[17:42:44.252]                 old_names <- names(...future.oldEnvVars)
[17:42:44.252]                 envs <- base::Sys.getenv()
[17:42:44.252]                 names <- names(envs)
[17:42:44.252]                 common <- intersect(names, old_names)
[17:42:44.252]                 added <- setdiff(names, old_names)
[17:42:44.252]                 removed <- setdiff(old_names, names)
[17:42:44.252]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.252]                   envs[common]]
[17:42:44.252]                 NAMES <- toupper(changed)
[17:42:44.252]                 args <- list()
[17:42:44.252]                 for (kk in seq_along(NAMES)) {
[17:42:44.252]                   name <- changed[[kk]]
[17:42:44.252]                   NAME <- NAMES[[kk]]
[17:42:44.252]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.252]                     next
[17:42:44.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.252]                 }
[17:42:44.252]                 NAMES <- toupper(added)
[17:42:44.252]                 for (kk in seq_along(NAMES)) {
[17:42:44.252]                   name <- added[[kk]]
[17:42:44.252]                   NAME <- NAMES[[kk]]
[17:42:44.252]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.252]                     next
[17:42:44.252]                   args[[name]] <- ""
[17:42:44.252]                 }
[17:42:44.252]                 NAMES <- toupper(removed)
[17:42:44.252]                 for (kk in seq_along(NAMES)) {
[17:42:44.252]                   name <- removed[[kk]]
[17:42:44.252]                   NAME <- NAMES[[kk]]
[17:42:44.252]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.252]                     next
[17:42:44.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.252]                 }
[17:42:44.252]                 if (length(args) > 0) 
[17:42:44.252]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.252]             }
[17:42:44.252]             else {
[17:42:44.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.252]             }
[17:42:44.252]             {
[17:42:44.252]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.252]                   0L) {
[17:42:44.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.252]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.252]                   base::options(opts)
[17:42:44.252]                 }
[17:42:44.252]                 {
[17:42:44.252]                   {
[17:42:44.252]                     NULL
[17:42:44.252]                     RNGkind("Mersenne-Twister")
[17:42:44.252]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.252]                       inherits = FALSE)
[17:42:44.252]                   }
[17:42:44.252]                   options(future.plan = NULL)
[17:42:44.252]                   if (is.na(NA_character_)) 
[17:42:44.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.252]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.252]                   {
[17:42:44.252]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.252]                     if (!future$lazy) 
[17:42:44.252]                       future <- run(future)
[17:42:44.252]                     invisible(future)
[17:42:44.252]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.252]                 }
[17:42:44.252]             }
[17:42:44.252]         }
[17:42:44.252]     })
[17:42:44.252]     if (TRUE) {
[17:42:44.252]         base::sink(type = "output", split = FALSE)
[17:42:44.252]         if (TRUE) {
[17:42:44.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.252]         }
[17:42:44.252]         else {
[17:42:44.252]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.252]         }
[17:42:44.252]         base::close(...future.stdout)
[17:42:44.252]         ...future.stdout <- NULL
[17:42:44.252]     }
[17:42:44.252]     ...future.result$conditions <- ...future.conditions
[17:42:44.252]     ...future.result$finished <- base::Sys.time()
[17:42:44.252]     ...future.result
[17:42:44.252] }
[17:42:44.254] assign_globals() ...
[17:42:44.254] List of 1
[17:42:44.254]  $ ii: int 3
[17:42:44.254]  - attr(*, "where")=List of 1
[17:42:44.254]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.254]  - attr(*, "resolved")= logi TRUE
[17:42:44.254]  - attr(*, "total_size")= num 56
[17:42:44.254]  - attr(*, "already-done")= logi TRUE
[17:42:44.256] - copied ‘ii’ to environment
[17:42:44.256] assign_globals() ... done
[17:42:44.256] plan(): Setting new future strategy stack:
[17:42:44.257] List of future strategies:
[17:42:44.257] 1. sequential:
[17:42:44.257]    - args: function (..., envir = parent.frame())
[17:42:44.257]    - tweaked: FALSE
[17:42:44.257]    - call: NULL
[17:42:44.257] plan(): nbrOfWorkers() = 1
[17:42:44.258] plan(): Setting new future strategy stack:
[17:42:44.258] List of future strategies:
[17:42:44.258] 1. sequential:
[17:42:44.258]    - args: function (..., envir = parent.frame())
[17:42:44.258]    - tweaked: FALSE
[17:42:44.258]    - call: plan(strategy)
[17:42:44.258] plan(): nbrOfWorkers() = 1
[17:42:44.258] SequentialFuture started (and completed)
[17:42:44.258] - Launch lazy future ... done
[17:42:44.258] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.259] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.260] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.261] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.261] Searching for globals ... DONE
[17:42:44.261] Resolving globals: TRUE
[17:42:44.262] Resolving any globals that are futures ...
[17:42:44.262] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.262] Resolving any globals that are futures ... DONE
[17:42:44.262] Resolving futures part of globals (recursively) ...
[17:42:44.262] resolve() on list ...
[17:42:44.262]  recursive: 99
[17:42:44.263]  length: 1
[17:42:44.263]  elements: ‘ii’
[17:42:44.263]  length: 0 (resolved future 1)
[17:42:44.263] resolve() on list ... DONE
[17:42:44.263] - globals: [1] ‘ii’
[17:42:44.263] Resolving futures part of globals (recursively) ... DONE
[17:42:44.265] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.265] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.266] - globals: [1] ‘ii’
[17:42:44.266] 
[17:42:44.266] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.266] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.267] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.268] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.268] Searching for globals ... DONE
[17:42:44.268] Resolving globals: TRUE
[17:42:44.268] Resolving any globals that are futures ...
[17:42:44.269] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.269] Resolving any globals that are futures ... DONE
[17:42:44.269] Resolving futures part of globals (recursively) ...
[17:42:44.269] resolve() on list ...
[17:42:44.269]  recursive: 99
[17:42:44.269]  length: 1
[17:42:44.269]  elements: ‘ii’
[17:42:44.270]  length: 0 (resolved future 1)
[17:42:44.270] resolve() on list ... DONE
[17:42:44.270] - globals: [1] ‘ii’
[17:42:44.270] Resolving futures part of globals (recursively) ... DONE
[17:42:44.270] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.270] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.271] - globals: [1] ‘ii’
[17:42:44.271] 
[17:42:44.271] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.271] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.272] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.273] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.273] Searching for globals ... DONE
[17:42:44.273] Resolving globals: TRUE
[17:42:44.273] Resolving any globals that are futures ...
[17:42:44.273] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.273] Resolving any globals that are futures ... DONE
[17:42:44.274] Resolving futures part of globals (recursively) ...
[17:42:44.274] resolve() on list ...
[17:42:44.274]  recursive: 99
[17:42:44.274]  length: 1
[17:42:44.274]  elements: ‘ii’
[17:42:44.274]  length: 0 (resolved future 1)
[17:42:44.274] resolve() on list ... DONE
[17:42:44.275] - globals: [1] ‘ii’
[17:42:44.275] Resolving futures part of globals (recursively) ... DONE
[17:42:44.275] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.275] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.275] - globals: [1] ‘ii’
[17:42:44.275] 
[17:42:44.276] getGlobalsAndPackages() ... DONE
[17:42:44.276] run() for ‘Future’ ...
[17:42:44.276] - state: ‘created’
[17:42:44.276] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.276] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.277]   - Field: ‘label’
[17:42:44.277]   - Field: ‘local’
[17:42:44.277]   - Field: ‘owner’
[17:42:44.277]   - Field: ‘envir’
[17:42:44.277]   - Field: ‘packages’
[17:42:44.277]   - Field: ‘gc’
[17:42:44.277]   - Field: ‘conditions’
[17:42:44.277]   - Field: ‘expr’
[17:42:44.277]   - Field: ‘uuid’
[17:42:44.277]   - Field: ‘seed’
[17:42:44.278]   - Field: ‘version’
[17:42:44.278]   - Field: ‘result’
[17:42:44.278]   - Field: ‘asynchronous’
[17:42:44.278]   - Field: ‘calls’
[17:42:44.278]   - Field: ‘globals’
[17:42:44.278]   - Field: ‘stdout’
[17:42:44.278]   - Field: ‘earlySignal’
[17:42:44.278]   - Field: ‘lazy’
[17:42:44.278]   - Field: ‘state’
[17:42:44.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.278] - Launch lazy future ...
[17:42:44.279] Packages needed by the future expression (n = 0): <none>
[17:42:44.279] Packages needed by future strategies (n = 0): <none>
[17:42:44.279] {
[17:42:44.279]     {
[17:42:44.279]         {
[17:42:44.279]             ...future.startTime <- base::Sys.time()
[17:42:44.279]             {
[17:42:44.279]                 {
[17:42:44.279]                   {
[17:42:44.279]                     base::local({
[17:42:44.279]                       has_future <- base::requireNamespace("future", 
[17:42:44.279]                         quietly = TRUE)
[17:42:44.279]                       if (has_future) {
[17:42:44.279]                         ns <- base::getNamespace("future")
[17:42:44.279]                         version <- ns[[".package"]][["version"]]
[17:42:44.279]                         if (is.null(version)) 
[17:42:44.279]                           version <- utils::packageVersion("future")
[17:42:44.279]                       }
[17:42:44.279]                       else {
[17:42:44.279]                         version <- NULL
[17:42:44.279]                       }
[17:42:44.279]                       if (!has_future || version < "1.8.0") {
[17:42:44.279]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.279]                           "", base::R.version$version.string), 
[17:42:44.279]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.279]                             "release", "version")], collapse = " "), 
[17:42:44.279]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.279]                           info)
[17:42:44.279]                         info <- base::paste(info, collapse = "; ")
[17:42:44.279]                         if (!has_future) {
[17:42:44.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.279]                             info)
[17:42:44.279]                         }
[17:42:44.279]                         else {
[17:42:44.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.279]                             info, version)
[17:42:44.279]                         }
[17:42:44.279]                         base::stop(msg)
[17:42:44.279]                       }
[17:42:44.279]                     })
[17:42:44.279]                   }
[17:42:44.279]                   options(future.plan = NULL)
[17:42:44.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.279]                 }
[17:42:44.279]                 ...future.workdir <- getwd()
[17:42:44.279]             }
[17:42:44.279]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.279]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.279]         }
[17:42:44.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.279]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.279]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.279]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.279]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.279]             base::names(...future.oldOptions))
[17:42:44.279]     }
[17:42:44.279]     if (FALSE) {
[17:42:44.279]     }
[17:42:44.279]     else {
[17:42:44.279]         if (TRUE) {
[17:42:44.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.279]                 open = "w")
[17:42:44.279]         }
[17:42:44.279]         else {
[17:42:44.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.279]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.279]         }
[17:42:44.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.279]             base::sink(type = "output", split = FALSE)
[17:42:44.279]             base::close(...future.stdout)
[17:42:44.279]         }, add = TRUE)
[17:42:44.279]     }
[17:42:44.279]     ...future.frame <- base::sys.nframe()
[17:42:44.279]     ...future.conditions <- base::list()
[17:42:44.279]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.279]     if (FALSE) {
[17:42:44.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.279]     }
[17:42:44.279]     ...future.result <- base::tryCatch({
[17:42:44.279]         base::withCallingHandlers({
[17:42:44.279]             ...future.value <- base::withVisible(base::local({
[17:42:44.279]                 b <- a * ii
[17:42:44.279]                 a <- 0
[17:42:44.279]                 b
[17:42:44.279]             }))
[17:42:44.279]             future::FutureResult(value = ...future.value$value, 
[17:42:44.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.279]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.279]                     ...future.globalenv.names))
[17:42:44.279]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.279]         }, condition = base::local({
[17:42:44.279]             c <- base::c
[17:42:44.279]             inherits <- base::inherits
[17:42:44.279]             invokeRestart <- base::invokeRestart
[17:42:44.279]             length <- base::length
[17:42:44.279]             list <- base::list
[17:42:44.279]             seq.int <- base::seq.int
[17:42:44.279]             signalCondition <- base::signalCondition
[17:42:44.279]             sys.calls <- base::sys.calls
[17:42:44.279]             `[[` <- base::`[[`
[17:42:44.279]             `+` <- base::`+`
[17:42:44.279]             `<<-` <- base::`<<-`
[17:42:44.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.279]                   3L)]
[17:42:44.279]             }
[17:42:44.279]             function(cond) {
[17:42:44.279]                 is_error <- inherits(cond, "error")
[17:42:44.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.279]                   NULL)
[17:42:44.279]                 if (is_error) {
[17:42:44.279]                   sessionInformation <- function() {
[17:42:44.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.279]                       search = base::search(), system = base::Sys.info())
[17:42:44.279]                   }
[17:42:44.279]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.279]                     cond$call), session = sessionInformation(), 
[17:42:44.279]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.279]                   signalCondition(cond)
[17:42:44.279]                 }
[17:42:44.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.279]                 "immediateCondition"))) {
[17:42:44.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.279]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.279]                   if (TRUE && !signal) {
[17:42:44.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.279]                     {
[17:42:44.279]                       inherits <- base::inherits
[17:42:44.279]                       invokeRestart <- base::invokeRestart
[17:42:44.279]                       is.null <- base::is.null
[17:42:44.279]                       muffled <- FALSE
[17:42:44.279]                       if (inherits(cond, "message")) {
[17:42:44.279]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.279]                         if (muffled) 
[17:42:44.279]                           invokeRestart("muffleMessage")
[17:42:44.279]                       }
[17:42:44.279]                       else if (inherits(cond, "warning")) {
[17:42:44.279]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.279]                         if (muffled) 
[17:42:44.279]                           invokeRestart("muffleWarning")
[17:42:44.279]                       }
[17:42:44.279]                       else if (inherits(cond, "condition")) {
[17:42:44.279]                         if (!is.null(pattern)) {
[17:42:44.279]                           computeRestarts <- base::computeRestarts
[17:42:44.279]                           grepl <- base::grepl
[17:42:44.279]                           restarts <- computeRestarts(cond)
[17:42:44.279]                           for (restart in restarts) {
[17:42:44.279]                             name <- restart$name
[17:42:44.279]                             if (is.null(name)) 
[17:42:44.279]                               next
[17:42:44.279]                             if (!grepl(pattern, name)) 
[17:42:44.279]                               next
[17:42:44.279]                             invokeRestart(restart)
[17:42:44.279]                             muffled <- TRUE
[17:42:44.279]                             break
[17:42:44.279]                           }
[17:42:44.279]                         }
[17:42:44.279]                       }
[17:42:44.279]                       invisible(muffled)
[17:42:44.279]                     }
[17:42:44.279]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.279]                   }
[17:42:44.279]                 }
[17:42:44.279]                 else {
[17:42:44.279]                   if (TRUE) {
[17:42:44.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.279]                     {
[17:42:44.279]                       inherits <- base::inherits
[17:42:44.279]                       invokeRestart <- base::invokeRestart
[17:42:44.279]                       is.null <- base::is.null
[17:42:44.279]                       muffled <- FALSE
[17:42:44.279]                       if (inherits(cond, "message")) {
[17:42:44.279]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.279]                         if (muffled) 
[17:42:44.279]                           invokeRestart("muffleMessage")
[17:42:44.279]                       }
[17:42:44.279]                       else if (inherits(cond, "warning")) {
[17:42:44.279]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.279]                         if (muffled) 
[17:42:44.279]                           invokeRestart("muffleWarning")
[17:42:44.279]                       }
[17:42:44.279]                       else if (inherits(cond, "condition")) {
[17:42:44.279]                         if (!is.null(pattern)) {
[17:42:44.279]                           computeRestarts <- base::computeRestarts
[17:42:44.279]                           grepl <- base::grepl
[17:42:44.279]                           restarts <- computeRestarts(cond)
[17:42:44.279]                           for (restart in restarts) {
[17:42:44.279]                             name <- restart$name
[17:42:44.279]                             if (is.null(name)) 
[17:42:44.279]                               next
[17:42:44.279]                             if (!grepl(pattern, name)) 
[17:42:44.279]                               next
[17:42:44.279]                             invokeRestart(restart)
[17:42:44.279]                             muffled <- TRUE
[17:42:44.279]                             break
[17:42:44.279]                           }
[17:42:44.279]                         }
[17:42:44.279]                       }
[17:42:44.279]                       invisible(muffled)
[17:42:44.279]                     }
[17:42:44.279]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.279]                   }
[17:42:44.279]                 }
[17:42:44.279]             }
[17:42:44.279]         }))
[17:42:44.279]     }, error = function(ex) {
[17:42:44.279]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.279]                 ...future.rng), started = ...future.startTime, 
[17:42:44.279]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.279]             version = "1.8"), class = "FutureResult")
[17:42:44.279]     }, finally = {
[17:42:44.279]         if (!identical(...future.workdir, getwd())) 
[17:42:44.279]             setwd(...future.workdir)
[17:42:44.279]         {
[17:42:44.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.279]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.279]             }
[17:42:44.279]             base::options(...future.oldOptions)
[17:42:44.279]             if (.Platform$OS.type == "windows") {
[17:42:44.279]                 old_names <- names(...future.oldEnvVars)
[17:42:44.279]                 envs <- base::Sys.getenv()
[17:42:44.279]                 names <- names(envs)
[17:42:44.279]                 common <- intersect(names, old_names)
[17:42:44.279]                 added <- setdiff(names, old_names)
[17:42:44.279]                 removed <- setdiff(old_names, names)
[17:42:44.279]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.279]                   envs[common]]
[17:42:44.279]                 NAMES <- toupper(changed)
[17:42:44.279]                 args <- list()
[17:42:44.279]                 for (kk in seq_along(NAMES)) {
[17:42:44.279]                   name <- changed[[kk]]
[17:42:44.279]                   NAME <- NAMES[[kk]]
[17:42:44.279]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.279]                     next
[17:42:44.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.279]                 }
[17:42:44.279]                 NAMES <- toupper(added)
[17:42:44.279]                 for (kk in seq_along(NAMES)) {
[17:42:44.279]                   name <- added[[kk]]
[17:42:44.279]                   NAME <- NAMES[[kk]]
[17:42:44.279]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.279]                     next
[17:42:44.279]                   args[[name]] <- ""
[17:42:44.279]                 }
[17:42:44.279]                 NAMES <- toupper(removed)
[17:42:44.279]                 for (kk in seq_along(NAMES)) {
[17:42:44.279]                   name <- removed[[kk]]
[17:42:44.279]                   NAME <- NAMES[[kk]]
[17:42:44.279]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.279]                     next
[17:42:44.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.279]                 }
[17:42:44.279]                 if (length(args) > 0) 
[17:42:44.279]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.279]             }
[17:42:44.279]             else {
[17:42:44.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.279]             }
[17:42:44.279]             {
[17:42:44.279]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.279]                   0L) {
[17:42:44.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.279]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.279]                   base::options(opts)
[17:42:44.279]                 }
[17:42:44.279]                 {
[17:42:44.279]                   {
[17:42:44.279]                     NULL
[17:42:44.279]                     RNGkind("Mersenne-Twister")
[17:42:44.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.279]                       inherits = FALSE)
[17:42:44.279]                   }
[17:42:44.279]                   options(future.plan = NULL)
[17:42:44.279]                   if (is.na(NA_character_)) 
[17:42:44.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.279]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.279]                   {
[17:42:44.279]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.279]                     if (!future$lazy) 
[17:42:44.279]                       future <- run(future)
[17:42:44.279]                     invisible(future)
[17:42:44.279]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.279]                 }
[17:42:44.279]             }
[17:42:44.279]         }
[17:42:44.279]     })
[17:42:44.279]     if (TRUE) {
[17:42:44.279]         base::sink(type = "output", split = FALSE)
[17:42:44.279]         if (TRUE) {
[17:42:44.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.279]         }
[17:42:44.279]         else {
[17:42:44.279]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.279]         }
[17:42:44.279]         base::close(...future.stdout)
[17:42:44.279]         ...future.stdout <- NULL
[17:42:44.279]     }
[17:42:44.279]     ...future.result$conditions <- ...future.conditions
[17:42:44.279]     ...future.result$finished <- base::Sys.time()
[17:42:44.279]     ...future.result
[17:42:44.279] }
[17:42:44.281] assign_globals() ...
[17:42:44.281] List of 1
[17:42:44.281]  $ ii: int 1
[17:42:44.281]  - attr(*, "where")=List of 1
[17:42:44.281]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.281]  - attr(*, "resolved")= logi TRUE
[17:42:44.281]  - attr(*, "total_size")= num 56
[17:42:44.281]  - attr(*, "already-done")= logi TRUE
[17:42:44.284] - copied ‘ii’ to environment
[17:42:44.284] assign_globals() ... done
[17:42:44.284] plan(): Setting new future strategy stack:
[17:42:44.284] List of future strategies:
[17:42:44.284] 1. sequential:
[17:42:44.284]    - args: function (..., envir = parent.frame())
[17:42:44.284]    - tweaked: FALSE
[17:42:44.284]    - call: NULL
[17:42:44.285] plan(): nbrOfWorkers() = 1
[17:42:44.285] plan(): Setting new future strategy stack:
[17:42:44.286] List of future strategies:
[17:42:44.286] 1. sequential:
[17:42:44.286]    - args: function (..., envir = parent.frame())
[17:42:44.286]    - tweaked: FALSE
[17:42:44.286]    - call: plan(strategy)
[17:42:44.286] plan(): nbrOfWorkers() = 1
[17:42:44.286] SequentialFuture started (and completed)
[17:42:44.286] signalConditions() ...
[17:42:44.286]  - include = ‘immediateCondition’
[17:42:44.286]  - exclude = 
[17:42:44.286]  - resignal = FALSE
[17:42:44.287]  - Number of conditions: 1
[17:42:44.287] signalConditions() ... done
[17:42:44.287] - Launch lazy future ... done
[17:42:44.287] run() for ‘SequentialFuture’ ... done
[17:42:44.287] signalConditions() ...
[17:42:44.287]  - include = ‘immediateCondition’
[17:42:44.287]  - exclude = 
[17:42:44.287]  - resignal = FALSE
[17:42:44.287]  - Number of conditions: 1
[17:42:44.287] signalConditions() ... done
[17:42:44.288] Future state: ‘finished’
[17:42:44.288] signalConditions() ...
[17:42:44.288]  - include = ‘condition’
[17:42:44.288]  - exclude = ‘immediateCondition’
[17:42:44.288]  - resignal = TRUE
[17:42:44.288]  - Number of conditions: 1
[17:42:44.288]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:44.288] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:44"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.304] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.304] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.305] 
[17:42:44.305] Searching for globals ... DONE
[17:42:44.305] - globals: [0] <none>
[17:42:44.305] getGlobalsAndPackages() ... DONE
[17:42:44.305] run() for ‘Future’ ...
[17:42:44.305] - state: ‘created’
[17:42:44.306] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.306]   - Field: ‘label’
[17:42:44.306]   - Field: ‘local’
[17:42:44.306]   - Field: ‘owner’
[17:42:44.306]   - Field: ‘envir’
[17:42:44.306]   - Field: ‘packages’
[17:42:44.307]   - Field: ‘gc’
[17:42:44.307]   - Field: ‘conditions’
[17:42:44.307]   - Field: ‘expr’
[17:42:44.307]   - Field: ‘uuid’
[17:42:44.307]   - Field: ‘seed’
[17:42:44.307]   - Field: ‘version’
[17:42:44.307]   - Field: ‘result’
[17:42:44.307]   - Field: ‘asynchronous’
[17:42:44.307]   - Field: ‘calls’
[17:42:44.307]   - Field: ‘globals’
[17:42:44.308]   - Field: ‘stdout’
[17:42:44.308]   - Field: ‘earlySignal’
[17:42:44.308]   - Field: ‘lazy’
[17:42:44.308]   - Field: ‘state’
[17:42:44.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.308] - Launch lazy future ...
[17:42:44.308] Packages needed by the future expression (n = 0): <none>
[17:42:44.308] Packages needed by future strategies (n = 0): <none>
[17:42:44.309] {
[17:42:44.309]     {
[17:42:44.309]         {
[17:42:44.309]             ...future.startTime <- base::Sys.time()
[17:42:44.309]             {
[17:42:44.309]                 {
[17:42:44.309]                   {
[17:42:44.309]                     base::local({
[17:42:44.309]                       has_future <- base::requireNamespace("future", 
[17:42:44.309]                         quietly = TRUE)
[17:42:44.309]                       if (has_future) {
[17:42:44.309]                         ns <- base::getNamespace("future")
[17:42:44.309]                         version <- ns[[".package"]][["version"]]
[17:42:44.309]                         if (is.null(version)) 
[17:42:44.309]                           version <- utils::packageVersion("future")
[17:42:44.309]                       }
[17:42:44.309]                       else {
[17:42:44.309]                         version <- NULL
[17:42:44.309]                       }
[17:42:44.309]                       if (!has_future || version < "1.8.0") {
[17:42:44.309]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.309]                           "", base::R.version$version.string), 
[17:42:44.309]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.309]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.309]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.309]                             "release", "version")], collapse = " "), 
[17:42:44.309]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.309]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.309]                           info)
[17:42:44.309]                         info <- base::paste(info, collapse = "; ")
[17:42:44.309]                         if (!has_future) {
[17:42:44.309]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.309]                             info)
[17:42:44.309]                         }
[17:42:44.309]                         else {
[17:42:44.309]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.309]                             info, version)
[17:42:44.309]                         }
[17:42:44.309]                         base::stop(msg)
[17:42:44.309]                       }
[17:42:44.309]                     })
[17:42:44.309]                   }
[17:42:44.309]                   options(future.plan = NULL)
[17:42:44.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.309]                 }
[17:42:44.309]                 ...future.workdir <- getwd()
[17:42:44.309]             }
[17:42:44.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.309]         }
[17:42:44.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.309]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.309]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.309]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.309]             base::names(...future.oldOptions))
[17:42:44.309]     }
[17:42:44.309]     if (FALSE) {
[17:42:44.309]     }
[17:42:44.309]     else {
[17:42:44.309]         if (TRUE) {
[17:42:44.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.309]                 open = "w")
[17:42:44.309]         }
[17:42:44.309]         else {
[17:42:44.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.309]         }
[17:42:44.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.309]             base::sink(type = "output", split = FALSE)
[17:42:44.309]             base::close(...future.stdout)
[17:42:44.309]         }, add = TRUE)
[17:42:44.309]     }
[17:42:44.309]     ...future.frame <- base::sys.nframe()
[17:42:44.309]     ...future.conditions <- base::list()
[17:42:44.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.309]     if (FALSE) {
[17:42:44.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.309]     }
[17:42:44.309]     ...future.result <- base::tryCatch({
[17:42:44.309]         base::withCallingHandlers({
[17:42:44.309]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.309]             future::FutureResult(value = ...future.value$value, 
[17:42:44.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.309]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.309]                     ...future.globalenv.names))
[17:42:44.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.309]         }, condition = base::local({
[17:42:44.309]             c <- base::c
[17:42:44.309]             inherits <- base::inherits
[17:42:44.309]             invokeRestart <- base::invokeRestart
[17:42:44.309]             length <- base::length
[17:42:44.309]             list <- base::list
[17:42:44.309]             seq.int <- base::seq.int
[17:42:44.309]             signalCondition <- base::signalCondition
[17:42:44.309]             sys.calls <- base::sys.calls
[17:42:44.309]             `[[` <- base::`[[`
[17:42:44.309]             `+` <- base::`+`
[17:42:44.309]             `<<-` <- base::`<<-`
[17:42:44.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.309]                   3L)]
[17:42:44.309]             }
[17:42:44.309]             function(cond) {
[17:42:44.309]                 is_error <- inherits(cond, "error")
[17:42:44.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.309]                   NULL)
[17:42:44.309]                 if (is_error) {
[17:42:44.309]                   sessionInformation <- function() {
[17:42:44.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.309]                       search = base::search(), system = base::Sys.info())
[17:42:44.309]                   }
[17:42:44.309]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.309]                     cond$call), session = sessionInformation(), 
[17:42:44.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.309]                   signalCondition(cond)
[17:42:44.309]                 }
[17:42:44.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.309]                 "immediateCondition"))) {
[17:42:44.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.309]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.309]                   if (TRUE && !signal) {
[17:42:44.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.309]                     {
[17:42:44.309]                       inherits <- base::inherits
[17:42:44.309]                       invokeRestart <- base::invokeRestart
[17:42:44.309]                       is.null <- base::is.null
[17:42:44.309]                       muffled <- FALSE
[17:42:44.309]                       if (inherits(cond, "message")) {
[17:42:44.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.309]                         if (muffled) 
[17:42:44.309]                           invokeRestart("muffleMessage")
[17:42:44.309]                       }
[17:42:44.309]                       else if (inherits(cond, "warning")) {
[17:42:44.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.309]                         if (muffled) 
[17:42:44.309]                           invokeRestart("muffleWarning")
[17:42:44.309]                       }
[17:42:44.309]                       else if (inherits(cond, "condition")) {
[17:42:44.309]                         if (!is.null(pattern)) {
[17:42:44.309]                           computeRestarts <- base::computeRestarts
[17:42:44.309]                           grepl <- base::grepl
[17:42:44.309]                           restarts <- computeRestarts(cond)
[17:42:44.309]                           for (restart in restarts) {
[17:42:44.309]                             name <- restart$name
[17:42:44.309]                             if (is.null(name)) 
[17:42:44.309]                               next
[17:42:44.309]                             if (!grepl(pattern, name)) 
[17:42:44.309]                               next
[17:42:44.309]                             invokeRestart(restart)
[17:42:44.309]                             muffled <- TRUE
[17:42:44.309]                             break
[17:42:44.309]                           }
[17:42:44.309]                         }
[17:42:44.309]                       }
[17:42:44.309]                       invisible(muffled)
[17:42:44.309]                     }
[17:42:44.309]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.309]                   }
[17:42:44.309]                 }
[17:42:44.309]                 else {
[17:42:44.309]                   if (TRUE) {
[17:42:44.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.309]                     {
[17:42:44.309]                       inherits <- base::inherits
[17:42:44.309]                       invokeRestart <- base::invokeRestart
[17:42:44.309]                       is.null <- base::is.null
[17:42:44.309]                       muffled <- FALSE
[17:42:44.309]                       if (inherits(cond, "message")) {
[17:42:44.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.309]                         if (muffled) 
[17:42:44.309]                           invokeRestart("muffleMessage")
[17:42:44.309]                       }
[17:42:44.309]                       else if (inherits(cond, "warning")) {
[17:42:44.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.309]                         if (muffled) 
[17:42:44.309]                           invokeRestart("muffleWarning")
[17:42:44.309]                       }
[17:42:44.309]                       else if (inherits(cond, "condition")) {
[17:42:44.309]                         if (!is.null(pattern)) {
[17:42:44.309]                           computeRestarts <- base::computeRestarts
[17:42:44.309]                           grepl <- base::grepl
[17:42:44.309]                           restarts <- computeRestarts(cond)
[17:42:44.309]                           for (restart in restarts) {
[17:42:44.309]                             name <- restart$name
[17:42:44.309]                             if (is.null(name)) 
[17:42:44.309]                               next
[17:42:44.309]                             if (!grepl(pattern, name)) 
[17:42:44.309]                               next
[17:42:44.309]                             invokeRestart(restart)
[17:42:44.309]                             muffled <- TRUE
[17:42:44.309]                             break
[17:42:44.309]                           }
[17:42:44.309]                         }
[17:42:44.309]                       }
[17:42:44.309]                       invisible(muffled)
[17:42:44.309]                     }
[17:42:44.309]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.309]                   }
[17:42:44.309]                 }
[17:42:44.309]             }
[17:42:44.309]         }))
[17:42:44.309]     }, error = function(ex) {
[17:42:44.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.309]                 ...future.rng), started = ...future.startTime, 
[17:42:44.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.309]             version = "1.8"), class = "FutureResult")
[17:42:44.309]     }, finally = {
[17:42:44.309]         if (!identical(...future.workdir, getwd())) 
[17:42:44.309]             setwd(...future.workdir)
[17:42:44.309]         {
[17:42:44.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.309]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.309]             }
[17:42:44.309]             base::options(...future.oldOptions)
[17:42:44.309]             if (.Platform$OS.type == "windows") {
[17:42:44.309]                 old_names <- names(...future.oldEnvVars)
[17:42:44.309]                 envs <- base::Sys.getenv()
[17:42:44.309]                 names <- names(envs)
[17:42:44.309]                 common <- intersect(names, old_names)
[17:42:44.309]                 added <- setdiff(names, old_names)
[17:42:44.309]                 removed <- setdiff(old_names, names)
[17:42:44.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.309]                   envs[common]]
[17:42:44.309]                 NAMES <- toupper(changed)
[17:42:44.309]                 args <- list()
[17:42:44.309]                 for (kk in seq_along(NAMES)) {
[17:42:44.309]                   name <- changed[[kk]]
[17:42:44.309]                   NAME <- NAMES[[kk]]
[17:42:44.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.309]                     next
[17:42:44.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.309]                 }
[17:42:44.309]                 NAMES <- toupper(added)
[17:42:44.309]                 for (kk in seq_along(NAMES)) {
[17:42:44.309]                   name <- added[[kk]]
[17:42:44.309]                   NAME <- NAMES[[kk]]
[17:42:44.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.309]                     next
[17:42:44.309]                   args[[name]] <- ""
[17:42:44.309]                 }
[17:42:44.309]                 NAMES <- toupper(removed)
[17:42:44.309]                 for (kk in seq_along(NAMES)) {
[17:42:44.309]                   name <- removed[[kk]]
[17:42:44.309]                   NAME <- NAMES[[kk]]
[17:42:44.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.309]                     next
[17:42:44.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.309]                 }
[17:42:44.309]                 if (length(args) > 0) 
[17:42:44.309]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.309]             }
[17:42:44.309]             else {
[17:42:44.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.309]             }
[17:42:44.309]             {
[17:42:44.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.309]                   0L) {
[17:42:44.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.309]                   base::options(opts)
[17:42:44.309]                 }
[17:42:44.309]                 {
[17:42:44.309]                   {
[17:42:44.309]                     NULL
[17:42:44.309]                     RNGkind("Mersenne-Twister")
[17:42:44.309]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.309]                       inherits = FALSE)
[17:42:44.309]                   }
[17:42:44.309]                   options(future.plan = NULL)
[17:42:44.309]                   if (is.na(NA_character_)) 
[17:42:44.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.309]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.309]                   {
[17:42:44.309]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.309]                     if (!future$lazy) 
[17:42:44.309]                       future <- run(future)
[17:42:44.309]                     invisible(future)
[17:42:44.309]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.309]                 }
[17:42:44.309]             }
[17:42:44.309]         }
[17:42:44.309]     })
[17:42:44.309]     if (TRUE) {
[17:42:44.309]         base::sink(type = "output", split = FALSE)
[17:42:44.309]         if (TRUE) {
[17:42:44.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.309]         }
[17:42:44.309]         else {
[17:42:44.309]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.309]         }
[17:42:44.309]         base::close(...future.stdout)
[17:42:44.309]         ...future.stdout <- NULL
[17:42:44.309]     }
[17:42:44.309]     ...future.result$conditions <- ...future.conditions
[17:42:44.309]     ...future.result$finished <- base::Sys.time()
[17:42:44.309]     ...future.result
[17:42:44.309] }
[17:42:44.311] plan(): Setting new future strategy stack:
[17:42:44.311] List of future strategies:
[17:42:44.311] 1. sequential:
[17:42:44.311]    - args: function (..., envir = parent.frame())
[17:42:44.311]    - tweaked: FALSE
[17:42:44.311]    - call: NULL
[17:42:44.311] plan(): nbrOfWorkers() = 1
[17:42:44.312] plan(): Setting new future strategy stack:
[17:42:44.312] List of future strategies:
[17:42:44.312] 1. sequential:
[17:42:44.312]    - args: function (..., envir = parent.frame())
[17:42:44.312]    - tweaked: FALSE
[17:42:44.312]    - call: plan(strategy)
[17:42:44.312] plan(): nbrOfWorkers() = 1
[17:42:44.313] SequentialFuture started (and completed)
[17:42:44.313] - Launch lazy future ... done
[17:42:44.313] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.313] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.313] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.314] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.314] Searching for globals ... DONE
[17:42:44.314] Resolving globals: TRUE
[17:42:44.314] Resolving any globals that are futures ...
[17:42:44.315] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.315] Resolving any globals that are futures ... DONE
[17:42:44.315] Resolving futures part of globals (recursively) ...
[17:42:44.315] resolve() on list ...
[17:42:44.315]  recursive: 99
[17:42:44.315]  length: 1
[17:42:44.316]  elements: ‘a’
[17:42:44.316] resolved() for ‘SequentialFuture’ ...
[17:42:44.316] - state: ‘finished’
[17:42:44.316] - run: TRUE
[17:42:44.316] - result: ‘FutureResult’
[17:42:44.316] resolved() for ‘SequentialFuture’ ... done
[17:42:44.316] Future #1
[17:42:44.317] resolved() for ‘SequentialFuture’ ...
[17:42:44.317] - state: ‘finished’
[17:42:44.317] - run: TRUE
[17:42:44.317] - result: ‘FutureResult’
[17:42:44.317] resolved() for ‘SequentialFuture’ ... done
[17:42:44.317] A SequentialFuture was resolved
[17:42:44.317]  length: 0 (resolved future 1)
[17:42:44.317] resolve() on list ... DONE
[17:42:44.317] - globals: [1] ‘a’
[17:42:44.317] Resolving futures part of globals (recursively) ... DONE
[17:42:44.318] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:42:44.320] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:42:44.321] - globals: [1] ‘a’
[17:42:44.321] - packages: [1] ‘future’
[17:42:44.321] getGlobalsAndPackages() ... DONE
[17:42:44.321] run() for ‘Future’ ...
[17:42:44.321] - state: ‘created’
[17:42:44.321] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.322] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.322]   - Field: ‘label’
[17:42:44.322]   - Field: ‘local’
[17:42:44.322]   - Field: ‘owner’
[17:42:44.322]   - Field: ‘envir’
[17:42:44.322]   - Field: ‘packages’
[17:42:44.322]   - Field: ‘gc’
[17:42:44.322]   - Field: ‘conditions’
[17:42:44.322]   - Field: ‘expr’
[17:42:44.323]   - Field: ‘uuid’
[17:42:44.323]   - Field: ‘seed’
[17:42:44.323]   - Field: ‘version’
[17:42:44.323]   - Field: ‘result’
[17:42:44.323]   - Field: ‘asynchronous’
[17:42:44.323]   - Field: ‘calls’
[17:42:44.323]   - Field: ‘globals’
[17:42:44.323]   - Field: ‘stdout’
[17:42:44.323]   - Field: ‘earlySignal’
[17:42:44.323]   - Field: ‘lazy’
[17:42:44.323]   - Field: ‘state’
[17:42:44.324] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.324] - Launch lazy future ...
[17:42:44.324] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.324] Packages needed by future strategies (n = 0): <none>
[17:42:44.324] {
[17:42:44.324]     {
[17:42:44.324]         {
[17:42:44.324]             ...future.startTime <- base::Sys.time()
[17:42:44.324]             {
[17:42:44.324]                 {
[17:42:44.324]                   {
[17:42:44.324]                     {
[17:42:44.324]                       base::local({
[17:42:44.324]                         has_future <- base::requireNamespace("future", 
[17:42:44.324]                           quietly = TRUE)
[17:42:44.324]                         if (has_future) {
[17:42:44.324]                           ns <- base::getNamespace("future")
[17:42:44.324]                           version <- ns[[".package"]][["version"]]
[17:42:44.324]                           if (is.null(version)) 
[17:42:44.324]                             version <- utils::packageVersion("future")
[17:42:44.324]                         }
[17:42:44.324]                         else {
[17:42:44.324]                           version <- NULL
[17:42:44.324]                         }
[17:42:44.324]                         if (!has_future || version < "1.8.0") {
[17:42:44.324]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.324]                             "", base::R.version$version.string), 
[17:42:44.324]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.324]                               "release", "version")], collapse = " "), 
[17:42:44.324]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.324]                             info)
[17:42:44.324]                           info <- base::paste(info, collapse = "; ")
[17:42:44.324]                           if (!has_future) {
[17:42:44.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.324]                               info)
[17:42:44.324]                           }
[17:42:44.324]                           else {
[17:42:44.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.324]                               info, version)
[17:42:44.324]                           }
[17:42:44.324]                           base::stop(msg)
[17:42:44.324]                         }
[17:42:44.324]                       })
[17:42:44.324]                     }
[17:42:44.324]                     base::local({
[17:42:44.324]                       for (pkg in "future") {
[17:42:44.324]                         base::loadNamespace(pkg)
[17:42:44.324]                         base::library(pkg, character.only = TRUE)
[17:42:44.324]                       }
[17:42:44.324]                     })
[17:42:44.324]                   }
[17:42:44.324]                   options(future.plan = NULL)
[17:42:44.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.324]                 }
[17:42:44.324]                 ...future.workdir <- getwd()
[17:42:44.324]             }
[17:42:44.324]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.324]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.324]         }
[17:42:44.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.324]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.324]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.324]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.324]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.324]             base::names(...future.oldOptions))
[17:42:44.324]     }
[17:42:44.324]     if (FALSE) {
[17:42:44.324]     }
[17:42:44.324]     else {
[17:42:44.324]         if (TRUE) {
[17:42:44.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.324]                 open = "w")
[17:42:44.324]         }
[17:42:44.324]         else {
[17:42:44.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.324]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.324]         }
[17:42:44.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.324]             base::sink(type = "output", split = FALSE)
[17:42:44.324]             base::close(...future.stdout)
[17:42:44.324]         }, add = TRUE)
[17:42:44.324]     }
[17:42:44.324]     ...future.frame <- base::sys.nframe()
[17:42:44.324]     ...future.conditions <- base::list()
[17:42:44.324]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.324]     if (FALSE) {
[17:42:44.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.324]     }
[17:42:44.324]     ...future.result <- base::tryCatch({
[17:42:44.324]         base::withCallingHandlers({
[17:42:44.324]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.324]                 1))
[17:42:44.324]             future::FutureResult(value = ...future.value$value, 
[17:42:44.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.324]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.324]                     ...future.globalenv.names))
[17:42:44.324]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.324]         }, condition = base::local({
[17:42:44.324]             c <- base::c
[17:42:44.324]             inherits <- base::inherits
[17:42:44.324]             invokeRestart <- base::invokeRestart
[17:42:44.324]             length <- base::length
[17:42:44.324]             list <- base::list
[17:42:44.324]             seq.int <- base::seq.int
[17:42:44.324]             signalCondition <- base::signalCondition
[17:42:44.324]             sys.calls <- base::sys.calls
[17:42:44.324]             `[[` <- base::`[[`
[17:42:44.324]             `+` <- base::`+`
[17:42:44.324]             `<<-` <- base::`<<-`
[17:42:44.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.324]                   3L)]
[17:42:44.324]             }
[17:42:44.324]             function(cond) {
[17:42:44.324]                 is_error <- inherits(cond, "error")
[17:42:44.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.324]                   NULL)
[17:42:44.324]                 if (is_error) {
[17:42:44.324]                   sessionInformation <- function() {
[17:42:44.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.324]                       search = base::search(), system = base::Sys.info())
[17:42:44.324]                   }
[17:42:44.324]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.324]                     cond$call), session = sessionInformation(), 
[17:42:44.324]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.324]                   signalCondition(cond)
[17:42:44.324]                 }
[17:42:44.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.324]                 "immediateCondition"))) {
[17:42:44.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.324]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.324]                   if (TRUE && !signal) {
[17:42:44.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.324]                     {
[17:42:44.324]                       inherits <- base::inherits
[17:42:44.324]                       invokeRestart <- base::invokeRestart
[17:42:44.324]                       is.null <- base::is.null
[17:42:44.324]                       muffled <- FALSE
[17:42:44.324]                       if (inherits(cond, "message")) {
[17:42:44.324]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.324]                         if (muffled) 
[17:42:44.324]                           invokeRestart("muffleMessage")
[17:42:44.324]                       }
[17:42:44.324]                       else if (inherits(cond, "warning")) {
[17:42:44.324]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.324]                         if (muffled) 
[17:42:44.324]                           invokeRestart("muffleWarning")
[17:42:44.324]                       }
[17:42:44.324]                       else if (inherits(cond, "condition")) {
[17:42:44.324]                         if (!is.null(pattern)) {
[17:42:44.324]                           computeRestarts <- base::computeRestarts
[17:42:44.324]                           grepl <- base::grepl
[17:42:44.324]                           restarts <- computeRestarts(cond)
[17:42:44.324]                           for (restart in restarts) {
[17:42:44.324]                             name <- restart$name
[17:42:44.324]                             if (is.null(name)) 
[17:42:44.324]                               next
[17:42:44.324]                             if (!grepl(pattern, name)) 
[17:42:44.324]                               next
[17:42:44.324]                             invokeRestart(restart)
[17:42:44.324]                             muffled <- TRUE
[17:42:44.324]                             break
[17:42:44.324]                           }
[17:42:44.324]                         }
[17:42:44.324]                       }
[17:42:44.324]                       invisible(muffled)
[17:42:44.324]                     }
[17:42:44.324]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.324]                   }
[17:42:44.324]                 }
[17:42:44.324]                 else {
[17:42:44.324]                   if (TRUE) {
[17:42:44.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.324]                     {
[17:42:44.324]                       inherits <- base::inherits
[17:42:44.324]                       invokeRestart <- base::invokeRestart
[17:42:44.324]                       is.null <- base::is.null
[17:42:44.324]                       muffled <- FALSE
[17:42:44.324]                       if (inherits(cond, "message")) {
[17:42:44.324]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.324]                         if (muffled) 
[17:42:44.324]                           invokeRestart("muffleMessage")
[17:42:44.324]                       }
[17:42:44.324]                       else if (inherits(cond, "warning")) {
[17:42:44.324]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.324]                         if (muffled) 
[17:42:44.324]                           invokeRestart("muffleWarning")
[17:42:44.324]                       }
[17:42:44.324]                       else if (inherits(cond, "condition")) {
[17:42:44.324]                         if (!is.null(pattern)) {
[17:42:44.324]                           computeRestarts <- base::computeRestarts
[17:42:44.324]                           grepl <- base::grepl
[17:42:44.324]                           restarts <- computeRestarts(cond)
[17:42:44.324]                           for (restart in restarts) {
[17:42:44.324]                             name <- restart$name
[17:42:44.324]                             if (is.null(name)) 
[17:42:44.324]                               next
[17:42:44.324]                             if (!grepl(pattern, name)) 
[17:42:44.324]                               next
[17:42:44.324]                             invokeRestart(restart)
[17:42:44.324]                             muffled <- TRUE
[17:42:44.324]                             break
[17:42:44.324]                           }
[17:42:44.324]                         }
[17:42:44.324]                       }
[17:42:44.324]                       invisible(muffled)
[17:42:44.324]                     }
[17:42:44.324]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.324]                   }
[17:42:44.324]                 }
[17:42:44.324]             }
[17:42:44.324]         }))
[17:42:44.324]     }, error = function(ex) {
[17:42:44.324]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.324]                 ...future.rng), started = ...future.startTime, 
[17:42:44.324]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.324]             version = "1.8"), class = "FutureResult")
[17:42:44.324]     }, finally = {
[17:42:44.324]         if (!identical(...future.workdir, getwd())) 
[17:42:44.324]             setwd(...future.workdir)
[17:42:44.324]         {
[17:42:44.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.324]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.324]             }
[17:42:44.324]             base::options(...future.oldOptions)
[17:42:44.324]             if (.Platform$OS.type == "windows") {
[17:42:44.324]                 old_names <- names(...future.oldEnvVars)
[17:42:44.324]                 envs <- base::Sys.getenv()
[17:42:44.324]                 names <- names(envs)
[17:42:44.324]                 common <- intersect(names, old_names)
[17:42:44.324]                 added <- setdiff(names, old_names)
[17:42:44.324]                 removed <- setdiff(old_names, names)
[17:42:44.324]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.324]                   envs[common]]
[17:42:44.324]                 NAMES <- toupper(changed)
[17:42:44.324]                 args <- list()
[17:42:44.324]                 for (kk in seq_along(NAMES)) {
[17:42:44.324]                   name <- changed[[kk]]
[17:42:44.324]                   NAME <- NAMES[[kk]]
[17:42:44.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.324]                     next
[17:42:44.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.324]                 }
[17:42:44.324]                 NAMES <- toupper(added)
[17:42:44.324]                 for (kk in seq_along(NAMES)) {
[17:42:44.324]                   name <- added[[kk]]
[17:42:44.324]                   NAME <- NAMES[[kk]]
[17:42:44.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.324]                     next
[17:42:44.324]                   args[[name]] <- ""
[17:42:44.324]                 }
[17:42:44.324]                 NAMES <- toupper(removed)
[17:42:44.324]                 for (kk in seq_along(NAMES)) {
[17:42:44.324]                   name <- removed[[kk]]
[17:42:44.324]                   NAME <- NAMES[[kk]]
[17:42:44.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.324]                     next
[17:42:44.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.324]                 }
[17:42:44.324]                 if (length(args) > 0) 
[17:42:44.324]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.324]             }
[17:42:44.324]             else {
[17:42:44.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.324]             }
[17:42:44.324]             {
[17:42:44.324]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.324]                   0L) {
[17:42:44.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.324]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.324]                   base::options(opts)
[17:42:44.324]                 }
[17:42:44.324]                 {
[17:42:44.324]                   {
[17:42:44.324]                     NULL
[17:42:44.324]                     RNGkind("Mersenne-Twister")
[17:42:44.324]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.324]                       inherits = FALSE)
[17:42:44.324]                   }
[17:42:44.324]                   options(future.plan = NULL)
[17:42:44.324]                   if (is.na(NA_character_)) 
[17:42:44.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.324]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.324]                   {
[17:42:44.324]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.324]                     if (!future$lazy) 
[17:42:44.324]                       future <- run(future)
[17:42:44.324]                     invisible(future)
[17:42:44.324]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.324]                 }
[17:42:44.324]             }
[17:42:44.324]         }
[17:42:44.324]     })
[17:42:44.324]     if (TRUE) {
[17:42:44.324]         base::sink(type = "output", split = FALSE)
[17:42:44.324]         if (TRUE) {
[17:42:44.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.324]         }
[17:42:44.324]         else {
[17:42:44.324]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.324]         }
[17:42:44.324]         base::close(...future.stdout)
[17:42:44.324]         ...future.stdout <- NULL
[17:42:44.324]     }
[17:42:44.324]     ...future.result$conditions <- ...future.conditions
[17:42:44.324]     ...future.result$finished <- base::Sys.time()
[17:42:44.324]     ...future.result
[17:42:44.324] }
[17:42:44.326] assign_globals() ...
[17:42:44.326] List of 1
[17:42:44.326]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56181a92b258> 
[17:42:44.326]  - attr(*, "where")=List of 1
[17:42:44.326]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.326]  - attr(*, "resolved")= logi TRUE
[17:42:44.326]  - attr(*, "total_size")= num 10424
[17:42:44.326]  - attr(*, "already-done")= logi TRUE
[17:42:44.329] - copied ‘a’ to environment
[17:42:44.329] assign_globals() ... done
[17:42:44.329] plan(): Setting new future strategy stack:
[17:42:44.329] List of future strategies:
[17:42:44.329] 1. sequential:
[17:42:44.329]    - args: function (..., envir = parent.frame())
[17:42:44.329]    - tweaked: FALSE
[17:42:44.329]    - call: NULL
[17:42:44.330] plan(): nbrOfWorkers() = 1
[17:42:44.330] plan(): Setting new future strategy stack:
[17:42:44.330] List of future strategies:
[17:42:44.330] 1. sequential:
[17:42:44.330]    - args: function (..., envir = parent.frame())
[17:42:44.330]    - tweaked: FALSE
[17:42:44.330]    - call: plan(strategy)
[17:42:44.331] plan(): nbrOfWorkers() = 1
[17:42:44.331] SequentialFuture started (and completed)
[17:42:44.331] - Launch lazy future ... done
[17:42:44.331] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.332] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.332] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.332] 
[17:42:44.332] Searching for globals ... DONE
[17:42:44.332] - globals: [0] <none>
[17:42:44.333] getGlobalsAndPackages() ... DONE
[17:42:44.333] run() for ‘Future’ ...
[17:42:44.333] - state: ‘created’
[17:42:44.333] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.333]   - Field: ‘label’
[17:42:44.334]   - Field: ‘local’
[17:42:44.334]   - Field: ‘owner’
[17:42:44.334]   - Field: ‘envir’
[17:42:44.334]   - Field: ‘packages’
[17:42:44.334]   - Field: ‘gc’
[17:42:44.334]   - Field: ‘conditions’
[17:42:44.334]   - Field: ‘expr’
[17:42:44.334]   - Field: ‘uuid’
[17:42:44.334]   - Field: ‘seed’
[17:42:44.334]   - Field: ‘version’
[17:42:44.335]   - Field: ‘result’
[17:42:44.335]   - Field: ‘asynchronous’
[17:42:44.335]   - Field: ‘calls’
[17:42:44.335]   - Field: ‘globals’
[17:42:44.335]   - Field: ‘stdout’
[17:42:44.335]   - Field: ‘earlySignal’
[17:42:44.335]   - Field: ‘lazy’
[17:42:44.335]   - Field: ‘state’
[17:42:44.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.335] - Launch lazy future ...
[17:42:44.336] Packages needed by the future expression (n = 0): <none>
[17:42:44.336] Packages needed by future strategies (n = 0): <none>
[17:42:44.336] {
[17:42:44.336]     {
[17:42:44.336]         {
[17:42:44.336]             ...future.startTime <- base::Sys.time()
[17:42:44.336]             {
[17:42:44.336]                 {
[17:42:44.336]                   {
[17:42:44.336]                     base::local({
[17:42:44.336]                       has_future <- base::requireNamespace("future", 
[17:42:44.336]                         quietly = TRUE)
[17:42:44.336]                       if (has_future) {
[17:42:44.336]                         ns <- base::getNamespace("future")
[17:42:44.336]                         version <- ns[[".package"]][["version"]]
[17:42:44.336]                         if (is.null(version)) 
[17:42:44.336]                           version <- utils::packageVersion("future")
[17:42:44.336]                       }
[17:42:44.336]                       else {
[17:42:44.336]                         version <- NULL
[17:42:44.336]                       }
[17:42:44.336]                       if (!has_future || version < "1.8.0") {
[17:42:44.336]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.336]                           "", base::R.version$version.string), 
[17:42:44.336]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.336]                             "release", "version")], collapse = " "), 
[17:42:44.336]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.336]                           info)
[17:42:44.336]                         info <- base::paste(info, collapse = "; ")
[17:42:44.336]                         if (!has_future) {
[17:42:44.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.336]                             info)
[17:42:44.336]                         }
[17:42:44.336]                         else {
[17:42:44.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.336]                             info, version)
[17:42:44.336]                         }
[17:42:44.336]                         base::stop(msg)
[17:42:44.336]                       }
[17:42:44.336]                     })
[17:42:44.336]                   }
[17:42:44.336]                   options(future.plan = NULL)
[17:42:44.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.336]                 }
[17:42:44.336]                 ...future.workdir <- getwd()
[17:42:44.336]             }
[17:42:44.336]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.336]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.336]         }
[17:42:44.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.336]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.336]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.336]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.336]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.336]             base::names(...future.oldOptions))
[17:42:44.336]     }
[17:42:44.336]     if (FALSE) {
[17:42:44.336]     }
[17:42:44.336]     else {
[17:42:44.336]         if (TRUE) {
[17:42:44.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.336]                 open = "w")
[17:42:44.336]         }
[17:42:44.336]         else {
[17:42:44.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.336]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.336]         }
[17:42:44.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.336]             base::sink(type = "output", split = FALSE)
[17:42:44.336]             base::close(...future.stdout)
[17:42:44.336]         }, add = TRUE)
[17:42:44.336]     }
[17:42:44.336]     ...future.frame <- base::sys.nframe()
[17:42:44.336]     ...future.conditions <- base::list()
[17:42:44.336]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.336]     if (FALSE) {
[17:42:44.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.336]     }
[17:42:44.336]     ...future.result <- base::tryCatch({
[17:42:44.336]         base::withCallingHandlers({
[17:42:44.336]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.336]             future::FutureResult(value = ...future.value$value, 
[17:42:44.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.336]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.336]                     ...future.globalenv.names))
[17:42:44.336]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.336]         }, condition = base::local({
[17:42:44.336]             c <- base::c
[17:42:44.336]             inherits <- base::inherits
[17:42:44.336]             invokeRestart <- base::invokeRestart
[17:42:44.336]             length <- base::length
[17:42:44.336]             list <- base::list
[17:42:44.336]             seq.int <- base::seq.int
[17:42:44.336]             signalCondition <- base::signalCondition
[17:42:44.336]             sys.calls <- base::sys.calls
[17:42:44.336]             `[[` <- base::`[[`
[17:42:44.336]             `+` <- base::`+`
[17:42:44.336]             `<<-` <- base::`<<-`
[17:42:44.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.336]                   3L)]
[17:42:44.336]             }
[17:42:44.336]             function(cond) {
[17:42:44.336]                 is_error <- inherits(cond, "error")
[17:42:44.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.336]                   NULL)
[17:42:44.336]                 if (is_error) {
[17:42:44.336]                   sessionInformation <- function() {
[17:42:44.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.336]                       search = base::search(), system = base::Sys.info())
[17:42:44.336]                   }
[17:42:44.336]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.336]                     cond$call), session = sessionInformation(), 
[17:42:44.336]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.336]                   signalCondition(cond)
[17:42:44.336]                 }
[17:42:44.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.336]                 "immediateCondition"))) {
[17:42:44.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.336]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.336]                   if (TRUE && !signal) {
[17:42:44.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.336]                     {
[17:42:44.336]                       inherits <- base::inherits
[17:42:44.336]                       invokeRestart <- base::invokeRestart
[17:42:44.336]                       is.null <- base::is.null
[17:42:44.336]                       muffled <- FALSE
[17:42:44.336]                       if (inherits(cond, "message")) {
[17:42:44.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.336]                         if (muffled) 
[17:42:44.336]                           invokeRestart("muffleMessage")
[17:42:44.336]                       }
[17:42:44.336]                       else if (inherits(cond, "warning")) {
[17:42:44.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.336]                         if (muffled) 
[17:42:44.336]                           invokeRestart("muffleWarning")
[17:42:44.336]                       }
[17:42:44.336]                       else if (inherits(cond, "condition")) {
[17:42:44.336]                         if (!is.null(pattern)) {
[17:42:44.336]                           computeRestarts <- base::computeRestarts
[17:42:44.336]                           grepl <- base::grepl
[17:42:44.336]                           restarts <- computeRestarts(cond)
[17:42:44.336]                           for (restart in restarts) {
[17:42:44.336]                             name <- restart$name
[17:42:44.336]                             if (is.null(name)) 
[17:42:44.336]                               next
[17:42:44.336]                             if (!grepl(pattern, name)) 
[17:42:44.336]                               next
[17:42:44.336]                             invokeRestart(restart)
[17:42:44.336]                             muffled <- TRUE
[17:42:44.336]                             break
[17:42:44.336]                           }
[17:42:44.336]                         }
[17:42:44.336]                       }
[17:42:44.336]                       invisible(muffled)
[17:42:44.336]                     }
[17:42:44.336]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.336]                   }
[17:42:44.336]                 }
[17:42:44.336]                 else {
[17:42:44.336]                   if (TRUE) {
[17:42:44.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.336]                     {
[17:42:44.336]                       inherits <- base::inherits
[17:42:44.336]                       invokeRestart <- base::invokeRestart
[17:42:44.336]                       is.null <- base::is.null
[17:42:44.336]                       muffled <- FALSE
[17:42:44.336]                       if (inherits(cond, "message")) {
[17:42:44.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.336]                         if (muffled) 
[17:42:44.336]                           invokeRestart("muffleMessage")
[17:42:44.336]                       }
[17:42:44.336]                       else if (inherits(cond, "warning")) {
[17:42:44.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.336]                         if (muffled) 
[17:42:44.336]                           invokeRestart("muffleWarning")
[17:42:44.336]                       }
[17:42:44.336]                       else if (inherits(cond, "condition")) {
[17:42:44.336]                         if (!is.null(pattern)) {
[17:42:44.336]                           computeRestarts <- base::computeRestarts
[17:42:44.336]                           grepl <- base::grepl
[17:42:44.336]                           restarts <- computeRestarts(cond)
[17:42:44.336]                           for (restart in restarts) {
[17:42:44.336]                             name <- restart$name
[17:42:44.336]                             if (is.null(name)) 
[17:42:44.336]                               next
[17:42:44.336]                             if (!grepl(pattern, name)) 
[17:42:44.336]                               next
[17:42:44.336]                             invokeRestart(restart)
[17:42:44.336]                             muffled <- TRUE
[17:42:44.336]                             break
[17:42:44.336]                           }
[17:42:44.336]                         }
[17:42:44.336]                       }
[17:42:44.336]                       invisible(muffled)
[17:42:44.336]                     }
[17:42:44.336]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.336]                   }
[17:42:44.336]                 }
[17:42:44.336]             }
[17:42:44.336]         }))
[17:42:44.336]     }, error = function(ex) {
[17:42:44.336]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.336]                 ...future.rng), started = ...future.startTime, 
[17:42:44.336]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.336]             version = "1.8"), class = "FutureResult")
[17:42:44.336]     }, finally = {
[17:42:44.336]         if (!identical(...future.workdir, getwd())) 
[17:42:44.336]             setwd(...future.workdir)
[17:42:44.336]         {
[17:42:44.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.336]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.336]             }
[17:42:44.336]             base::options(...future.oldOptions)
[17:42:44.336]             if (.Platform$OS.type == "windows") {
[17:42:44.336]                 old_names <- names(...future.oldEnvVars)
[17:42:44.336]                 envs <- base::Sys.getenv()
[17:42:44.336]                 names <- names(envs)
[17:42:44.336]                 common <- intersect(names, old_names)
[17:42:44.336]                 added <- setdiff(names, old_names)
[17:42:44.336]                 removed <- setdiff(old_names, names)
[17:42:44.336]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.336]                   envs[common]]
[17:42:44.336]                 NAMES <- toupper(changed)
[17:42:44.336]                 args <- list()
[17:42:44.336]                 for (kk in seq_along(NAMES)) {
[17:42:44.336]                   name <- changed[[kk]]
[17:42:44.336]                   NAME <- NAMES[[kk]]
[17:42:44.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.336]                     next
[17:42:44.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.336]                 }
[17:42:44.336]                 NAMES <- toupper(added)
[17:42:44.336]                 for (kk in seq_along(NAMES)) {
[17:42:44.336]                   name <- added[[kk]]
[17:42:44.336]                   NAME <- NAMES[[kk]]
[17:42:44.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.336]                     next
[17:42:44.336]                   args[[name]] <- ""
[17:42:44.336]                 }
[17:42:44.336]                 NAMES <- toupper(removed)
[17:42:44.336]                 for (kk in seq_along(NAMES)) {
[17:42:44.336]                   name <- removed[[kk]]
[17:42:44.336]                   NAME <- NAMES[[kk]]
[17:42:44.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.336]                     next
[17:42:44.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.336]                 }
[17:42:44.336]                 if (length(args) > 0) 
[17:42:44.336]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.336]             }
[17:42:44.336]             else {
[17:42:44.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.336]             }
[17:42:44.336]             {
[17:42:44.336]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.336]                   0L) {
[17:42:44.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.336]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.336]                   base::options(opts)
[17:42:44.336]                 }
[17:42:44.336]                 {
[17:42:44.336]                   {
[17:42:44.336]                     NULL
[17:42:44.336]                     RNGkind("Mersenne-Twister")
[17:42:44.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.336]                       inherits = FALSE)
[17:42:44.336]                   }
[17:42:44.336]                   options(future.plan = NULL)
[17:42:44.336]                   if (is.na(NA_character_)) 
[17:42:44.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.336]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.336]                   {
[17:42:44.336]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.336]                     if (!future$lazy) 
[17:42:44.336]                       future <- run(future)
[17:42:44.336]                     invisible(future)
[17:42:44.336]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.336]                 }
[17:42:44.336]             }
[17:42:44.336]         }
[17:42:44.336]     })
[17:42:44.336]     if (TRUE) {
[17:42:44.336]         base::sink(type = "output", split = FALSE)
[17:42:44.336]         if (TRUE) {
[17:42:44.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.336]         }
[17:42:44.336]         else {
[17:42:44.336]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.336]         }
[17:42:44.336]         base::close(...future.stdout)
[17:42:44.336]         ...future.stdout <- NULL
[17:42:44.336]     }
[17:42:44.336]     ...future.result$conditions <- ...future.conditions
[17:42:44.336]     ...future.result$finished <- base::Sys.time()
[17:42:44.336]     ...future.result
[17:42:44.336] }
[17:42:44.338] plan(): Setting new future strategy stack:
[17:42:44.338] List of future strategies:
[17:42:44.338] 1. sequential:
[17:42:44.338]    - args: function (..., envir = parent.frame())
[17:42:44.338]    - tweaked: FALSE
[17:42:44.338]    - call: NULL
[17:42:44.338] plan(): nbrOfWorkers() = 1
[17:42:44.339] plan(): Setting new future strategy stack:
[17:42:44.339] List of future strategies:
[17:42:44.339] 1. sequential:
[17:42:44.339]    - args: function (..., envir = parent.frame())
[17:42:44.339]    - tweaked: FALSE
[17:42:44.339]    - call: plan(strategy)
[17:42:44.339] plan(): nbrOfWorkers() = 1
[17:42:44.340] SequentialFuture started (and completed)
[17:42:44.340] - Launch lazy future ... done
[17:42:44.340] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.340] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.340] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.341] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.341] Searching for globals ... DONE
[17:42:44.341] Resolving globals: TRUE
[17:42:44.341] Resolving any globals that are futures ...
[17:42:44.341] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.342] Resolving any globals that are futures ... DONE
[17:42:44.342] Resolving futures part of globals (recursively) ...
[17:42:44.342] resolve() on list ...
[17:42:44.342]  recursive: 99
[17:42:44.342]  length: 1
[17:42:44.342]  elements: ‘a’
[17:42:44.342] resolved() for ‘SequentialFuture’ ...
[17:42:44.342] - state: ‘finished’
[17:42:44.343] - run: TRUE
[17:42:44.343] - result: ‘FutureResult’
[17:42:44.343] resolved() for ‘SequentialFuture’ ... done
[17:42:44.343] Future #1
[17:42:44.343] resolved() for ‘SequentialFuture’ ...
[17:42:44.343] - state: ‘finished’
[17:42:44.343] - run: TRUE
[17:42:44.343] - result: ‘FutureResult’
[17:42:44.343] resolved() for ‘SequentialFuture’ ... done
[17:42:44.344] A SequentialFuture was resolved
[17:42:44.344]  length: 0 (resolved future 1)
[17:42:44.344] resolve() on list ... DONE
[17:42:44.344] - globals: [1] ‘a’
[17:42:44.344] Resolving futures part of globals (recursively) ... DONE
[17:42:44.345] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[17:42:44.345] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[17:42:44.345] - globals: [1] ‘a’
[17:42:44.345] - packages: [1] ‘future’
[17:42:44.345] getGlobalsAndPackages() ... DONE
[17:42:44.345] run() for ‘Future’ ...
[17:42:44.346] - state: ‘created’
[17:42:44.346] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.346] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.346]   - Field: ‘label’
[17:42:44.346]   - Field: ‘local’
[17:42:44.348]   - Field: ‘owner’
[17:42:44.348]   - Field: ‘envir’
[17:42:44.348]   - Field: ‘packages’
[17:42:44.348]   - Field: ‘gc’
[17:42:44.348]   - Field: ‘conditions’
[17:42:44.348]   - Field: ‘expr’
[17:42:44.349]   - Field: ‘uuid’
[17:42:44.349]   - Field: ‘seed’
[17:42:44.349]   - Field: ‘version’
[17:42:44.349]   - Field: ‘result’
[17:42:44.349]   - Field: ‘asynchronous’
[17:42:44.349]   - Field: ‘calls’
[17:42:44.349]   - Field: ‘globals’
[17:42:44.349]   - Field: ‘stdout’
[17:42:44.349]   - Field: ‘earlySignal’
[17:42:44.349]   - Field: ‘lazy’
[17:42:44.349]   - Field: ‘state’
[17:42:44.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.350] - Launch lazy future ...
[17:42:44.350] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.350] Packages needed by future strategies (n = 0): <none>
[17:42:44.350] {
[17:42:44.350]     {
[17:42:44.350]         {
[17:42:44.350]             ...future.startTime <- base::Sys.time()
[17:42:44.350]             {
[17:42:44.350]                 {
[17:42:44.350]                   {
[17:42:44.350]                     {
[17:42:44.350]                       base::local({
[17:42:44.350]                         has_future <- base::requireNamespace("future", 
[17:42:44.350]                           quietly = TRUE)
[17:42:44.350]                         if (has_future) {
[17:42:44.350]                           ns <- base::getNamespace("future")
[17:42:44.350]                           version <- ns[[".package"]][["version"]]
[17:42:44.350]                           if (is.null(version)) 
[17:42:44.350]                             version <- utils::packageVersion("future")
[17:42:44.350]                         }
[17:42:44.350]                         else {
[17:42:44.350]                           version <- NULL
[17:42:44.350]                         }
[17:42:44.350]                         if (!has_future || version < "1.8.0") {
[17:42:44.350]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.350]                             "", base::R.version$version.string), 
[17:42:44.350]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.350]                               "release", "version")], collapse = " "), 
[17:42:44.350]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.350]                             info)
[17:42:44.350]                           info <- base::paste(info, collapse = "; ")
[17:42:44.350]                           if (!has_future) {
[17:42:44.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.350]                               info)
[17:42:44.350]                           }
[17:42:44.350]                           else {
[17:42:44.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.350]                               info, version)
[17:42:44.350]                           }
[17:42:44.350]                           base::stop(msg)
[17:42:44.350]                         }
[17:42:44.350]                       })
[17:42:44.350]                     }
[17:42:44.350]                     base::local({
[17:42:44.350]                       for (pkg in "future") {
[17:42:44.350]                         base::loadNamespace(pkg)
[17:42:44.350]                         base::library(pkg, character.only = TRUE)
[17:42:44.350]                       }
[17:42:44.350]                     })
[17:42:44.350]                   }
[17:42:44.350]                   options(future.plan = NULL)
[17:42:44.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.350]                 }
[17:42:44.350]                 ...future.workdir <- getwd()
[17:42:44.350]             }
[17:42:44.350]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.350]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.350]         }
[17:42:44.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.350]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.350]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.350]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.350]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.350]             base::names(...future.oldOptions))
[17:42:44.350]     }
[17:42:44.350]     if (FALSE) {
[17:42:44.350]     }
[17:42:44.350]     else {
[17:42:44.350]         if (TRUE) {
[17:42:44.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.350]                 open = "w")
[17:42:44.350]         }
[17:42:44.350]         else {
[17:42:44.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.350]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.350]         }
[17:42:44.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.350]             base::sink(type = "output", split = FALSE)
[17:42:44.350]             base::close(...future.stdout)
[17:42:44.350]         }, add = TRUE)
[17:42:44.350]     }
[17:42:44.350]     ...future.frame <- base::sys.nframe()
[17:42:44.350]     ...future.conditions <- base::list()
[17:42:44.350]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.350]     if (FALSE) {
[17:42:44.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.350]     }
[17:42:44.350]     ...future.result <- base::tryCatch({
[17:42:44.350]         base::withCallingHandlers({
[17:42:44.350]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.350]                 1))
[17:42:44.350]             future::FutureResult(value = ...future.value$value, 
[17:42:44.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.350]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.350]                     ...future.globalenv.names))
[17:42:44.350]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.350]         }, condition = base::local({
[17:42:44.350]             c <- base::c
[17:42:44.350]             inherits <- base::inherits
[17:42:44.350]             invokeRestart <- base::invokeRestart
[17:42:44.350]             length <- base::length
[17:42:44.350]             list <- base::list
[17:42:44.350]             seq.int <- base::seq.int
[17:42:44.350]             signalCondition <- base::signalCondition
[17:42:44.350]             sys.calls <- base::sys.calls
[17:42:44.350]             `[[` <- base::`[[`
[17:42:44.350]             `+` <- base::`+`
[17:42:44.350]             `<<-` <- base::`<<-`
[17:42:44.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.350]                   3L)]
[17:42:44.350]             }
[17:42:44.350]             function(cond) {
[17:42:44.350]                 is_error <- inherits(cond, "error")
[17:42:44.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.350]                   NULL)
[17:42:44.350]                 if (is_error) {
[17:42:44.350]                   sessionInformation <- function() {
[17:42:44.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.350]                       search = base::search(), system = base::Sys.info())
[17:42:44.350]                   }
[17:42:44.350]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.350]                     cond$call), session = sessionInformation(), 
[17:42:44.350]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.350]                   signalCondition(cond)
[17:42:44.350]                 }
[17:42:44.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.350]                 "immediateCondition"))) {
[17:42:44.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.350]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.350]                   if (TRUE && !signal) {
[17:42:44.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.350]                     {
[17:42:44.350]                       inherits <- base::inherits
[17:42:44.350]                       invokeRestart <- base::invokeRestart
[17:42:44.350]                       is.null <- base::is.null
[17:42:44.350]                       muffled <- FALSE
[17:42:44.350]                       if (inherits(cond, "message")) {
[17:42:44.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.350]                         if (muffled) 
[17:42:44.350]                           invokeRestart("muffleMessage")
[17:42:44.350]                       }
[17:42:44.350]                       else if (inherits(cond, "warning")) {
[17:42:44.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.350]                         if (muffled) 
[17:42:44.350]                           invokeRestart("muffleWarning")
[17:42:44.350]                       }
[17:42:44.350]                       else if (inherits(cond, "condition")) {
[17:42:44.350]                         if (!is.null(pattern)) {
[17:42:44.350]                           computeRestarts <- base::computeRestarts
[17:42:44.350]                           grepl <- base::grepl
[17:42:44.350]                           restarts <- computeRestarts(cond)
[17:42:44.350]                           for (restart in restarts) {
[17:42:44.350]                             name <- restart$name
[17:42:44.350]                             if (is.null(name)) 
[17:42:44.350]                               next
[17:42:44.350]                             if (!grepl(pattern, name)) 
[17:42:44.350]                               next
[17:42:44.350]                             invokeRestart(restart)
[17:42:44.350]                             muffled <- TRUE
[17:42:44.350]                             break
[17:42:44.350]                           }
[17:42:44.350]                         }
[17:42:44.350]                       }
[17:42:44.350]                       invisible(muffled)
[17:42:44.350]                     }
[17:42:44.350]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.350]                   }
[17:42:44.350]                 }
[17:42:44.350]                 else {
[17:42:44.350]                   if (TRUE) {
[17:42:44.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.350]                     {
[17:42:44.350]                       inherits <- base::inherits
[17:42:44.350]                       invokeRestart <- base::invokeRestart
[17:42:44.350]                       is.null <- base::is.null
[17:42:44.350]                       muffled <- FALSE
[17:42:44.350]                       if (inherits(cond, "message")) {
[17:42:44.350]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.350]                         if (muffled) 
[17:42:44.350]                           invokeRestart("muffleMessage")
[17:42:44.350]                       }
[17:42:44.350]                       else if (inherits(cond, "warning")) {
[17:42:44.350]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.350]                         if (muffled) 
[17:42:44.350]                           invokeRestart("muffleWarning")
[17:42:44.350]                       }
[17:42:44.350]                       else if (inherits(cond, "condition")) {
[17:42:44.350]                         if (!is.null(pattern)) {
[17:42:44.350]                           computeRestarts <- base::computeRestarts
[17:42:44.350]                           grepl <- base::grepl
[17:42:44.350]                           restarts <- computeRestarts(cond)
[17:42:44.350]                           for (restart in restarts) {
[17:42:44.350]                             name <- restart$name
[17:42:44.350]                             if (is.null(name)) 
[17:42:44.350]                               next
[17:42:44.350]                             if (!grepl(pattern, name)) 
[17:42:44.350]                               next
[17:42:44.350]                             invokeRestart(restart)
[17:42:44.350]                             muffled <- TRUE
[17:42:44.350]                             break
[17:42:44.350]                           }
[17:42:44.350]                         }
[17:42:44.350]                       }
[17:42:44.350]                       invisible(muffled)
[17:42:44.350]                     }
[17:42:44.350]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.350]                   }
[17:42:44.350]                 }
[17:42:44.350]             }
[17:42:44.350]         }))
[17:42:44.350]     }, error = function(ex) {
[17:42:44.350]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.350]                 ...future.rng), started = ...future.startTime, 
[17:42:44.350]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.350]             version = "1.8"), class = "FutureResult")
[17:42:44.350]     }, finally = {
[17:42:44.350]         if (!identical(...future.workdir, getwd())) 
[17:42:44.350]             setwd(...future.workdir)
[17:42:44.350]         {
[17:42:44.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.350]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.350]             }
[17:42:44.350]             base::options(...future.oldOptions)
[17:42:44.350]             if (.Platform$OS.type == "windows") {
[17:42:44.350]                 old_names <- names(...future.oldEnvVars)
[17:42:44.350]                 envs <- base::Sys.getenv()
[17:42:44.350]                 names <- names(envs)
[17:42:44.350]                 common <- intersect(names, old_names)
[17:42:44.350]                 added <- setdiff(names, old_names)
[17:42:44.350]                 removed <- setdiff(old_names, names)
[17:42:44.350]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.350]                   envs[common]]
[17:42:44.350]                 NAMES <- toupper(changed)
[17:42:44.350]                 args <- list()
[17:42:44.350]                 for (kk in seq_along(NAMES)) {
[17:42:44.350]                   name <- changed[[kk]]
[17:42:44.350]                   NAME <- NAMES[[kk]]
[17:42:44.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.350]                     next
[17:42:44.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.350]                 }
[17:42:44.350]                 NAMES <- toupper(added)
[17:42:44.350]                 for (kk in seq_along(NAMES)) {
[17:42:44.350]                   name <- added[[kk]]
[17:42:44.350]                   NAME <- NAMES[[kk]]
[17:42:44.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.350]                     next
[17:42:44.350]                   args[[name]] <- ""
[17:42:44.350]                 }
[17:42:44.350]                 NAMES <- toupper(removed)
[17:42:44.350]                 for (kk in seq_along(NAMES)) {
[17:42:44.350]                   name <- removed[[kk]]
[17:42:44.350]                   NAME <- NAMES[[kk]]
[17:42:44.350]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.350]                     next
[17:42:44.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.350]                 }
[17:42:44.350]                 if (length(args) > 0) 
[17:42:44.350]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.350]             }
[17:42:44.350]             else {
[17:42:44.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.350]             }
[17:42:44.350]             {
[17:42:44.350]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.350]                   0L) {
[17:42:44.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.350]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.350]                   base::options(opts)
[17:42:44.350]                 }
[17:42:44.350]                 {
[17:42:44.350]                   {
[17:42:44.350]                     NULL
[17:42:44.350]                     RNGkind("Mersenne-Twister")
[17:42:44.350]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.350]                       inherits = FALSE)
[17:42:44.350]                   }
[17:42:44.350]                   options(future.plan = NULL)
[17:42:44.350]                   if (is.na(NA_character_)) 
[17:42:44.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.350]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.350]                   {
[17:42:44.350]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.350]                     if (!future$lazy) 
[17:42:44.350]                       future <- run(future)
[17:42:44.350]                     invisible(future)
[17:42:44.350]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.350]                 }
[17:42:44.350]             }
[17:42:44.350]         }
[17:42:44.350]     })
[17:42:44.350]     if (TRUE) {
[17:42:44.350]         base::sink(type = "output", split = FALSE)
[17:42:44.350]         if (TRUE) {
[17:42:44.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.350]         }
[17:42:44.350]         else {
[17:42:44.350]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.350]         }
[17:42:44.350]         base::close(...future.stdout)
[17:42:44.350]         ...future.stdout <- NULL
[17:42:44.350]     }
[17:42:44.350]     ...future.result$conditions <- ...future.conditions
[17:42:44.350]     ...future.result$finished <- base::Sys.time()
[17:42:44.350]     ...future.result
[17:42:44.350] }
[17:42:44.352] assign_globals() ...
[17:42:44.352] List of 1
[17:42:44.352]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56181a6e4f38> 
[17:42:44.352]  - attr(*, "where")=List of 1
[17:42:44.352]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.352]  - attr(*, "resolved")= logi TRUE
[17:42:44.352]  - attr(*, "total_size")= num 10424
[17:42:44.352]  - attr(*, "already-done")= logi TRUE
[17:42:44.355] - copied ‘a’ to environment
[17:42:44.355] assign_globals() ... done
[17:42:44.355] plan(): Setting new future strategy stack:
[17:42:44.356] List of future strategies:
[17:42:44.356] 1. sequential:
[17:42:44.356]    - args: function (..., envir = parent.frame())
[17:42:44.356]    - tweaked: FALSE
[17:42:44.356]    - call: NULL
[17:42:44.356] plan(): nbrOfWorkers() = 1
[17:42:44.357] plan(): Setting new future strategy stack:
[17:42:44.357] List of future strategies:
[17:42:44.357] 1. sequential:
[17:42:44.357]    - args: function (..., envir = parent.frame())
[17:42:44.357]    - tweaked: FALSE
[17:42:44.357]    - call: plan(strategy)
[17:42:44.357] plan(): nbrOfWorkers() = 1
[17:42:44.357] SequentialFuture started (and completed)
[17:42:44.357] - Launch lazy future ... done
[17:42:44.358] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.358] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.358] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.359] 
[17:42:44.359] Searching for globals ... DONE
[17:42:44.359] - globals: [0] <none>
[17:42:44.359] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.359] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.360] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.360] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.361] Searching for globals ... DONE
[17:42:44.361] Resolving globals: TRUE
[17:42:44.361] Resolving any globals that are futures ...
[17:42:44.361] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.361] Resolving any globals that are futures ... DONE
[17:42:44.361] Resolving futures part of globals (recursively) ...
[17:42:44.361] resolve() on list ...
[17:42:44.362]  recursive: 99
[17:42:44.362]  length: 1
[17:42:44.362]  elements: ‘a’
[17:42:44.362] run() for ‘Future’ ...
[17:42:44.362] - state: ‘created’
[17:42:44.362] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.362] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.363]   - Field: ‘label’
[17:42:44.363]   - Field: ‘local’
[17:42:44.363]   - Field: ‘owner’
[17:42:44.363]   - Field: ‘envir’
[17:42:44.363]   - Field: ‘packages’
[17:42:44.363]   - Field: ‘gc’
[17:42:44.363]   - Field: ‘conditions’
[17:42:44.363]   - Field: ‘expr’
[17:42:44.363]   - Field: ‘uuid’
[17:42:44.363]   - Field: ‘seed’
[17:42:44.364]   - Field: ‘version’
[17:42:44.364]   - Field: ‘result’
[17:42:44.364]   - Field: ‘asynchronous’
[17:42:44.364]   - Field: ‘calls’
[17:42:44.364]   - Field: ‘globals’
[17:42:44.364]   - Field: ‘stdout’
[17:42:44.364]   - Field: ‘earlySignal’
[17:42:44.364]   - Field: ‘lazy’
[17:42:44.364]   - Field: ‘state’
[17:42:44.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.364] - Launch lazy future ...
[17:42:44.365] Packages needed by the future expression (n = 0): <none>
[17:42:44.365] Packages needed by future strategies (n = 0): <none>
[17:42:44.365] {
[17:42:44.365]     {
[17:42:44.365]         {
[17:42:44.365]             ...future.startTime <- base::Sys.time()
[17:42:44.365]             {
[17:42:44.365]                 {
[17:42:44.365]                   {
[17:42:44.365]                     base::local({
[17:42:44.365]                       has_future <- base::requireNamespace("future", 
[17:42:44.365]                         quietly = TRUE)
[17:42:44.365]                       if (has_future) {
[17:42:44.365]                         ns <- base::getNamespace("future")
[17:42:44.365]                         version <- ns[[".package"]][["version"]]
[17:42:44.365]                         if (is.null(version)) 
[17:42:44.365]                           version <- utils::packageVersion("future")
[17:42:44.365]                       }
[17:42:44.365]                       else {
[17:42:44.365]                         version <- NULL
[17:42:44.365]                       }
[17:42:44.365]                       if (!has_future || version < "1.8.0") {
[17:42:44.365]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.365]                           "", base::R.version$version.string), 
[17:42:44.365]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.365]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.365]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.365]                             "release", "version")], collapse = " "), 
[17:42:44.365]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.365]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.365]                           info)
[17:42:44.365]                         info <- base::paste(info, collapse = "; ")
[17:42:44.365]                         if (!has_future) {
[17:42:44.365]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.365]                             info)
[17:42:44.365]                         }
[17:42:44.365]                         else {
[17:42:44.365]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.365]                             info, version)
[17:42:44.365]                         }
[17:42:44.365]                         base::stop(msg)
[17:42:44.365]                       }
[17:42:44.365]                     })
[17:42:44.365]                   }
[17:42:44.365]                   options(future.plan = NULL)
[17:42:44.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.365]                 }
[17:42:44.365]                 ...future.workdir <- getwd()
[17:42:44.365]             }
[17:42:44.365]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.365]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.365]         }
[17:42:44.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.365]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.365]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.365]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.365]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.365]             base::names(...future.oldOptions))
[17:42:44.365]     }
[17:42:44.365]     if (FALSE) {
[17:42:44.365]     }
[17:42:44.365]     else {
[17:42:44.365]         if (TRUE) {
[17:42:44.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.365]                 open = "w")
[17:42:44.365]         }
[17:42:44.365]         else {
[17:42:44.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.365]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.365]         }
[17:42:44.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.365]             base::sink(type = "output", split = FALSE)
[17:42:44.365]             base::close(...future.stdout)
[17:42:44.365]         }, add = TRUE)
[17:42:44.365]     }
[17:42:44.365]     ...future.frame <- base::sys.nframe()
[17:42:44.365]     ...future.conditions <- base::list()
[17:42:44.365]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.365]     if (FALSE) {
[17:42:44.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.365]     }
[17:42:44.365]     ...future.result <- base::tryCatch({
[17:42:44.365]         base::withCallingHandlers({
[17:42:44.365]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.365]             future::FutureResult(value = ...future.value$value, 
[17:42:44.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.365]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.365]                     ...future.globalenv.names))
[17:42:44.365]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.365]         }, condition = base::local({
[17:42:44.365]             c <- base::c
[17:42:44.365]             inherits <- base::inherits
[17:42:44.365]             invokeRestart <- base::invokeRestart
[17:42:44.365]             length <- base::length
[17:42:44.365]             list <- base::list
[17:42:44.365]             seq.int <- base::seq.int
[17:42:44.365]             signalCondition <- base::signalCondition
[17:42:44.365]             sys.calls <- base::sys.calls
[17:42:44.365]             `[[` <- base::`[[`
[17:42:44.365]             `+` <- base::`+`
[17:42:44.365]             `<<-` <- base::`<<-`
[17:42:44.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.365]                   3L)]
[17:42:44.365]             }
[17:42:44.365]             function(cond) {
[17:42:44.365]                 is_error <- inherits(cond, "error")
[17:42:44.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.365]                   NULL)
[17:42:44.365]                 if (is_error) {
[17:42:44.365]                   sessionInformation <- function() {
[17:42:44.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.365]                       search = base::search(), system = base::Sys.info())
[17:42:44.365]                   }
[17:42:44.365]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.365]                     cond$call), session = sessionInformation(), 
[17:42:44.365]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.365]                   signalCondition(cond)
[17:42:44.365]                 }
[17:42:44.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.365]                 "immediateCondition"))) {
[17:42:44.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.365]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.365]                   if (TRUE && !signal) {
[17:42:44.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.365]                     {
[17:42:44.365]                       inherits <- base::inherits
[17:42:44.365]                       invokeRestart <- base::invokeRestart
[17:42:44.365]                       is.null <- base::is.null
[17:42:44.365]                       muffled <- FALSE
[17:42:44.365]                       if (inherits(cond, "message")) {
[17:42:44.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.365]                         if (muffled) 
[17:42:44.365]                           invokeRestart("muffleMessage")
[17:42:44.365]                       }
[17:42:44.365]                       else if (inherits(cond, "warning")) {
[17:42:44.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.365]                         if (muffled) 
[17:42:44.365]                           invokeRestart("muffleWarning")
[17:42:44.365]                       }
[17:42:44.365]                       else if (inherits(cond, "condition")) {
[17:42:44.365]                         if (!is.null(pattern)) {
[17:42:44.365]                           computeRestarts <- base::computeRestarts
[17:42:44.365]                           grepl <- base::grepl
[17:42:44.365]                           restarts <- computeRestarts(cond)
[17:42:44.365]                           for (restart in restarts) {
[17:42:44.365]                             name <- restart$name
[17:42:44.365]                             if (is.null(name)) 
[17:42:44.365]                               next
[17:42:44.365]                             if (!grepl(pattern, name)) 
[17:42:44.365]                               next
[17:42:44.365]                             invokeRestart(restart)
[17:42:44.365]                             muffled <- TRUE
[17:42:44.365]                             break
[17:42:44.365]                           }
[17:42:44.365]                         }
[17:42:44.365]                       }
[17:42:44.365]                       invisible(muffled)
[17:42:44.365]                     }
[17:42:44.365]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.365]                   }
[17:42:44.365]                 }
[17:42:44.365]                 else {
[17:42:44.365]                   if (TRUE) {
[17:42:44.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.365]                     {
[17:42:44.365]                       inherits <- base::inherits
[17:42:44.365]                       invokeRestart <- base::invokeRestart
[17:42:44.365]                       is.null <- base::is.null
[17:42:44.365]                       muffled <- FALSE
[17:42:44.365]                       if (inherits(cond, "message")) {
[17:42:44.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.365]                         if (muffled) 
[17:42:44.365]                           invokeRestart("muffleMessage")
[17:42:44.365]                       }
[17:42:44.365]                       else if (inherits(cond, "warning")) {
[17:42:44.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.365]                         if (muffled) 
[17:42:44.365]                           invokeRestart("muffleWarning")
[17:42:44.365]                       }
[17:42:44.365]                       else if (inherits(cond, "condition")) {
[17:42:44.365]                         if (!is.null(pattern)) {
[17:42:44.365]                           computeRestarts <- base::computeRestarts
[17:42:44.365]                           grepl <- base::grepl
[17:42:44.365]                           restarts <- computeRestarts(cond)
[17:42:44.365]                           for (restart in restarts) {
[17:42:44.365]                             name <- restart$name
[17:42:44.365]                             if (is.null(name)) 
[17:42:44.365]                               next
[17:42:44.365]                             if (!grepl(pattern, name)) 
[17:42:44.365]                               next
[17:42:44.365]                             invokeRestart(restart)
[17:42:44.365]                             muffled <- TRUE
[17:42:44.365]                             break
[17:42:44.365]                           }
[17:42:44.365]                         }
[17:42:44.365]                       }
[17:42:44.365]                       invisible(muffled)
[17:42:44.365]                     }
[17:42:44.365]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.365]                   }
[17:42:44.365]                 }
[17:42:44.365]             }
[17:42:44.365]         }))
[17:42:44.365]     }, error = function(ex) {
[17:42:44.365]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.365]                 ...future.rng), started = ...future.startTime, 
[17:42:44.365]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.365]             version = "1.8"), class = "FutureResult")
[17:42:44.365]     }, finally = {
[17:42:44.365]         if (!identical(...future.workdir, getwd())) 
[17:42:44.365]             setwd(...future.workdir)
[17:42:44.365]         {
[17:42:44.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.365]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.365]             }
[17:42:44.365]             base::options(...future.oldOptions)
[17:42:44.365]             if (.Platform$OS.type == "windows") {
[17:42:44.365]                 old_names <- names(...future.oldEnvVars)
[17:42:44.365]                 envs <- base::Sys.getenv()
[17:42:44.365]                 names <- names(envs)
[17:42:44.365]                 common <- intersect(names, old_names)
[17:42:44.365]                 added <- setdiff(names, old_names)
[17:42:44.365]                 removed <- setdiff(old_names, names)
[17:42:44.365]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.365]                   envs[common]]
[17:42:44.365]                 NAMES <- toupper(changed)
[17:42:44.365]                 args <- list()
[17:42:44.365]                 for (kk in seq_along(NAMES)) {
[17:42:44.365]                   name <- changed[[kk]]
[17:42:44.365]                   NAME <- NAMES[[kk]]
[17:42:44.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.365]                     next
[17:42:44.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.365]                 }
[17:42:44.365]                 NAMES <- toupper(added)
[17:42:44.365]                 for (kk in seq_along(NAMES)) {
[17:42:44.365]                   name <- added[[kk]]
[17:42:44.365]                   NAME <- NAMES[[kk]]
[17:42:44.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.365]                     next
[17:42:44.365]                   args[[name]] <- ""
[17:42:44.365]                 }
[17:42:44.365]                 NAMES <- toupper(removed)
[17:42:44.365]                 for (kk in seq_along(NAMES)) {
[17:42:44.365]                   name <- removed[[kk]]
[17:42:44.365]                   NAME <- NAMES[[kk]]
[17:42:44.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.365]                     next
[17:42:44.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.365]                 }
[17:42:44.365]                 if (length(args) > 0) 
[17:42:44.365]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.365]             }
[17:42:44.365]             else {
[17:42:44.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.365]             }
[17:42:44.365]             {
[17:42:44.365]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.365]                   0L) {
[17:42:44.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.365]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.365]                   base::options(opts)
[17:42:44.365]                 }
[17:42:44.365]                 {
[17:42:44.365]                   {
[17:42:44.365]                     NULL
[17:42:44.365]                     RNGkind("Mersenne-Twister")
[17:42:44.365]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.365]                       inherits = FALSE)
[17:42:44.365]                   }
[17:42:44.365]                   options(future.plan = NULL)
[17:42:44.365]                   if (is.na(NA_character_)) 
[17:42:44.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.365]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.365]                   {
[17:42:44.365]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.365]                     if (!future$lazy) 
[17:42:44.365]                       future <- run(future)
[17:42:44.365]                     invisible(future)
[17:42:44.365]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.365]                 }
[17:42:44.365]             }
[17:42:44.365]         }
[17:42:44.365]     })
[17:42:44.365]     if (TRUE) {
[17:42:44.365]         base::sink(type = "output", split = FALSE)
[17:42:44.365]         if (TRUE) {
[17:42:44.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.365]         }
[17:42:44.365]         else {
[17:42:44.365]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.365]         }
[17:42:44.365]         base::close(...future.stdout)
[17:42:44.365]         ...future.stdout <- NULL
[17:42:44.365]     }
[17:42:44.365]     ...future.result$conditions <- ...future.conditions
[17:42:44.365]     ...future.result$finished <- base::Sys.time()
[17:42:44.365]     ...future.result
[17:42:44.365] }
[17:42:44.367] plan(): Setting new future strategy stack:
[17:42:44.367] List of future strategies:
[17:42:44.367] 1. sequential:
[17:42:44.367]    - args: function (..., envir = parent.frame())
[17:42:44.367]    - tweaked: FALSE
[17:42:44.367]    - call: NULL
[17:42:44.367] plan(): nbrOfWorkers() = 1
[17:42:44.368] plan(): Setting new future strategy stack:
[17:42:44.368] List of future strategies:
[17:42:44.368] 1. sequential:
[17:42:44.368]    - args: function (..., envir = parent.frame())
[17:42:44.368]    - tweaked: FALSE
[17:42:44.368]    - call: plan(strategy)
[17:42:44.369] plan(): nbrOfWorkers() = 1
[17:42:44.369] SequentialFuture started (and completed)
[17:42:44.369] - Launch lazy future ... done
[17:42:44.369] run() for ‘SequentialFuture’ ... done
[17:42:44.369] resolved() for ‘SequentialFuture’ ...
[17:42:44.369] - state: ‘finished’
[17:42:44.369] - run: TRUE
[17:42:44.369] - result: ‘FutureResult’
[17:42:44.370] resolved() for ‘SequentialFuture’ ... done
[17:42:44.370] Future #1
[17:42:44.370] resolved() for ‘SequentialFuture’ ...
[17:42:44.370] - state: ‘finished’
[17:42:44.370] - run: TRUE
[17:42:44.370] - result: ‘FutureResult’
[17:42:44.370] resolved() for ‘SequentialFuture’ ... done
[17:42:44.370] A SequentialFuture was resolved
[17:42:44.370]  length: 0 (resolved future 1)
[17:42:44.370] resolve() on list ... DONE
[17:42:44.371] - globals: [1] ‘a’
[17:42:44.371] Resolving futures part of globals (recursively) ... DONE
[17:42:44.371] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:42:44.372] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:42:44.372] - globals: [1] ‘a’
[17:42:44.372] - packages: [1] ‘future’
[17:42:44.372] getGlobalsAndPackages() ... DONE
[17:42:44.372] run() for ‘Future’ ...
[17:42:44.373] - state: ‘created’
[17:42:44.373] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.373] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.373]   - Field: ‘label’
[17:42:44.373]   - Field: ‘local’
[17:42:44.373]   - Field: ‘owner’
[17:42:44.374]   - Field: ‘envir’
[17:42:44.374]   - Field: ‘packages’
[17:42:44.374]   - Field: ‘gc’
[17:42:44.374]   - Field: ‘conditions’
[17:42:44.374]   - Field: ‘expr’
[17:42:44.374]   - Field: ‘uuid’
[17:42:44.374]   - Field: ‘seed’
[17:42:44.374]   - Field: ‘version’
[17:42:44.374]   - Field: ‘result’
[17:42:44.374]   - Field: ‘asynchronous’
[17:42:44.374]   - Field: ‘calls’
[17:42:44.375]   - Field: ‘globals’
[17:42:44.375]   - Field: ‘stdout’
[17:42:44.377]   - Field: ‘earlySignal’
[17:42:44.377]   - Field: ‘lazy’
[17:42:44.377]   - Field: ‘state’
[17:42:44.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.377] - Launch lazy future ...
[17:42:44.377] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.377] Packages needed by future strategies (n = 0): <none>
[17:42:44.378] {
[17:42:44.378]     {
[17:42:44.378]         {
[17:42:44.378]             ...future.startTime <- base::Sys.time()
[17:42:44.378]             {
[17:42:44.378]                 {
[17:42:44.378]                   {
[17:42:44.378]                     {
[17:42:44.378]                       base::local({
[17:42:44.378]                         has_future <- base::requireNamespace("future", 
[17:42:44.378]                           quietly = TRUE)
[17:42:44.378]                         if (has_future) {
[17:42:44.378]                           ns <- base::getNamespace("future")
[17:42:44.378]                           version <- ns[[".package"]][["version"]]
[17:42:44.378]                           if (is.null(version)) 
[17:42:44.378]                             version <- utils::packageVersion("future")
[17:42:44.378]                         }
[17:42:44.378]                         else {
[17:42:44.378]                           version <- NULL
[17:42:44.378]                         }
[17:42:44.378]                         if (!has_future || version < "1.8.0") {
[17:42:44.378]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.378]                             "", base::R.version$version.string), 
[17:42:44.378]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.378]                               "release", "version")], collapse = " "), 
[17:42:44.378]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.378]                             info)
[17:42:44.378]                           info <- base::paste(info, collapse = "; ")
[17:42:44.378]                           if (!has_future) {
[17:42:44.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.378]                               info)
[17:42:44.378]                           }
[17:42:44.378]                           else {
[17:42:44.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.378]                               info, version)
[17:42:44.378]                           }
[17:42:44.378]                           base::stop(msg)
[17:42:44.378]                         }
[17:42:44.378]                       })
[17:42:44.378]                     }
[17:42:44.378]                     base::local({
[17:42:44.378]                       for (pkg in "future") {
[17:42:44.378]                         base::loadNamespace(pkg)
[17:42:44.378]                         base::library(pkg, character.only = TRUE)
[17:42:44.378]                       }
[17:42:44.378]                     })
[17:42:44.378]                   }
[17:42:44.378]                   options(future.plan = NULL)
[17:42:44.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.378]                 }
[17:42:44.378]                 ...future.workdir <- getwd()
[17:42:44.378]             }
[17:42:44.378]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.378]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.378]         }
[17:42:44.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.378]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.378]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.378]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.378]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.378]             base::names(...future.oldOptions))
[17:42:44.378]     }
[17:42:44.378]     if (FALSE) {
[17:42:44.378]     }
[17:42:44.378]     else {
[17:42:44.378]         if (TRUE) {
[17:42:44.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.378]                 open = "w")
[17:42:44.378]         }
[17:42:44.378]         else {
[17:42:44.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.378]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.378]         }
[17:42:44.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.378]             base::sink(type = "output", split = FALSE)
[17:42:44.378]             base::close(...future.stdout)
[17:42:44.378]         }, add = TRUE)
[17:42:44.378]     }
[17:42:44.378]     ...future.frame <- base::sys.nframe()
[17:42:44.378]     ...future.conditions <- base::list()
[17:42:44.378]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.378]     if (FALSE) {
[17:42:44.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.378]     }
[17:42:44.378]     ...future.result <- base::tryCatch({
[17:42:44.378]         base::withCallingHandlers({
[17:42:44.378]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.378]                 1))
[17:42:44.378]             future::FutureResult(value = ...future.value$value, 
[17:42:44.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.378]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.378]                     ...future.globalenv.names))
[17:42:44.378]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.378]         }, condition = base::local({
[17:42:44.378]             c <- base::c
[17:42:44.378]             inherits <- base::inherits
[17:42:44.378]             invokeRestart <- base::invokeRestart
[17:42:44.378]             length <- base::length
[17:42:44.378]             list <- base::list
[17:42:44.378]             seq.int <- base::seq.int
[17:42:44.378]             signalCondition <- base::signalCondition
[17:42:44.378]             sys.calls <- base::sys.calls
[17:42:44.378]             `[[` <- base::`[[`
[17:42:44.378]             `+` <- base::`+`
[17:42:44.378]             `<<-` <- base::`<<-`
[17:42:44.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.378]                   3L)]
[17:42:44.378]             }
[17:42:44.378]             function(cond) {
[17:42:44.378]                 is_error <- inherits(cond, "error")
[17:42:44.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.378]                   NULL)
[17:42:44.378]                 if (is_error) {
[17:42:44.378]                   sessionInformation <- function() {
[17:42:44.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.378]                       search = base::search(), system = base::Sys.info())
[17:42:44.378]                   }
[17:42:44.378]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.378]                     cond$call), session = sessionInformation(), 
[17:42:44.378]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.378]                   signalCondition(cond)
[17:42:44.378]                 }
[17:42:44.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.378]                 "immediateCondition"))) {
[17:42:44.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.378]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.378]                   if (TRUE && !signal) {
[17:42:44.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.378]                     {
[17:42:44.378]                       inherits <- base::inherits
[17:42:44.378]                       invokeRestart <- base::invokeRestart
[17:42:44.378]                       is.null <- base::is.null
[17:42:44.378]                       muffled <- FALSE
[17:42:44.378]                       if (inherits(cond, "message")) {
[17:42:44.378]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.378]                         if (muffled) 
[17:42:44.378]                           invokeRestart("muffleMessage")
[17:42:44.378]                       }
[17:42:44.378]                       else if (inherits(cond, "warning")) {
[17:42:44.378]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.378]                         if (muffled) 
[17:42:44.378]                           invokeRestart("muffleWarning")
[17:42:44.378]                       }
[17:42:44.378]                       else if (inherits(cond, "condition")) {
[17:42:44.378]                         if (!is.null(pattern)) {
[17:42:44.378]                           computeRestarts <- base::computeRestarts
[17:42:44.378]                           grepl <- base::grepl
[17:42:44.378]                           restarts <- computeRestarts(cond)
[17:42:44.378]                           for (restart in restarts) {
[17:42:44.378]                             name <- restart$name
[17:42:44.378]                             if (is.null(name)) 
[17:42:44.378]                               next
[17:42:44.378]                             if (!grepl(pattern, name)) 
[17:42:44.378]                               next
[17:42:44.378]                             invokeRestart(restart)
[17:42:44.378]                             muffled <- TRUE
[17:42:44.378]                             break
[17:42:44.378]                           }
[17:42:44.378]                         }
[17:42:44.378]                       }
[17:42:44.378]                       invisible(muffled)
[17:42:44.378]                     }
[17:42:44.378]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.378]                   }
[17:42:44.378]                 }
[17:42:44.378]                 else {
[17:42:44.378]                   if (TRUE) {
[17:42:44.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.378]                     {
[17:42:44.378]                       inherits <- base::inherits
[17:42:44.378]                       invokeRestart <- base::invokeRestart
[17:42:44.378]                       is.null <- base::is.null
[17:42:44.378]                       muffled <- FALSE
[17:42:44.378]                       if (inherits(cond, "message")) {
[17:42:44.378]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.378]                         if (muffled) 
[17:42:44.378]                           invokeRestart("muffleMessage")
[17:42:44.378]                       }
[17:42:44.378]                       else if (inherits(cond, "warning")) {
[17:42:44.378]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.378]                         if (muffled) 
[17:42:44.378]                           invokeRestart("muffleWarning")
[17:42:44.378]                       }
[17:42:44.378]                       else if (inherits(cond, "condition")) {
[17:42:44.378]                         if (!is.null(pattern)) {
[17:42:44.378]                           computeRestarts <- base::computeRestarts
[17:42:44.378]                           grepl <- base::grepl
[17:42:44.378]                           restarts <- computeRestarts(cond)
[17:42:44.378]                           for (restart in restarts) {
[17:42:44.378]                             name <- restart$name
[17:42:44.378]                             if (is.null(name)) 
[17:42:44.378]                               next
[17:42:44.378]                             if (!grepl(pattern, name)) 
[17:42:44.378]                               next
[17:42:44.378]                             invokeRestart(restart)
[17:42:44.378]                             muffled <- TRUE
[17:42:44.378]                             break
[17:42:44.378]                           }
[17:42:44.378]                         }
[17:42:44.378]                       }
[17:42:44.378]                       invisible(muffled)
[17:42:44.378]                     }
[17:42:44.378]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.378]                   }
[17:42:44.378]                 }
[17:42:44.378]             }
[17:42:44.378]         }))
[17:42:44.378]     }, error = function(ex) {
[17:42:44.378]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.378]                 ...future.rng), started = ...future.startTime, 
[17:42:44.378]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.378]             version = "1.8"), class = "FutureResult")
[17:42:44.378]     }, finally = {
[17:42:44.378]         if (!identical(...future.workdir, getwd())) 
[17:42:44.378]             setwd(...future.workdir)
[17:42:44.378]         {
[17:42:44.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.378]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.378]             }
[17:42:44.378]             base::options(...future.oldOptions)
[17:42:44.378]             if (.Platform$OS.type == "windows") {
[17:42:44.378]                 old_names <- names(...future.oldEnvVars)
[17:42:44.378]                 envs <- base::Sys.getenv()
[17:42:44.378]                 names <- names(envs)
[17:42:44.378]                 common <- intersect(names, old_names)
[17:42:44.378]                 added <- setdiff(names, old_names)
[17:42:44.378]                 removed <- setdiff(old_names, names)
[17:42:44.378]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.378]                   envs[common]]
[17:42:44.378]                 NAMES <- toupper(changed)
[17:42:44.378]                 args <- list()
[17:42:44.378]                 for (kk in seq_along(NAMES)) {
[17:42:44.378]                   name <- changed[[kk]]
[17:42:44.378]                   NAME <- NAMES[[kk]]
[17:42:44.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.378]                     next
[17:42:44.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.378]                 }
[17:42:44.378]                 NAMES <- toupper(added)
[17:42:44.378]                 for (kk in seq_along(NAMES)) {
[17:42:44.378]                   name <- added[[kk]]
[17:42:44.378]                   NAME <- NAMES[[kk]]
[17:42:44.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.378]                     next
[17:42:44.378]                   args[[name]] <- ""
[17:42:44.378]                 }
[17:42:44.378]                 NAMES <- toupper(removed)
[17:42:44.378]                 for (kk in seq_along(NAMES)) {
[17:42:44.378]                   name <- removed[[kk]]
[17:42:44.378]                   NAME <- NAMES[[kk]]
[17:42:44.378]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.378]                     next
[17:42:44.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.378]                 }
[17:42:44.378]                 if (length(args) > 0) 
[17:42:44.378]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.378]             }
[17:42:44.378]             else {
[17:42:44.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.378]             }
[17:42:44.378]             {
[17:42:44.378]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.378]                   0L) {
[17:42:44.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.378]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.378]                   base::options(opts)
[17:42:44.378]                 }
[17:42:44.378]                 {
[17:42:44.378]                   {
[17:42:44.378]                     NULL
[17:42:44.378]                     RNGkind("Mersenne-Twister")
[17:42:44.378]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.378]                       inherits = FALSE)
[17:42:44.378]                   }
[17:42:44.378]                   options(future.plan = NULL)
[17:42:44.378]                   if (is.na(NA_character_)) 
[17:42:44.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.378]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.378]                   {
[17:42:44.378]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.378]                     if (!future$lazy) 
[17:42:44.378]                       future <- run(future)
[17:42:44.378]                     invisible(future)
[17:42:44.378]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.378]                 }
[17:42:44.378]             }
[17:42:44.378]         }
[17:42:44.378]     })
[17:42:44.378]     if (TRUE) {
[17:42:44.378]         base::sink(type = "output", split = FALSE)
[17:42:44.378]         if (TRUE) {
[17:42:44.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.378]         }
[17:42:44.378]         else {
[17:42:44.378]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.378]         }
[17:42:44.378]         base::close(...future.stdout)
[17:42:44.378]         ...future.stdout <- NULL
[17:42:44.378]     }
[17:42:44.378]     ...future.result$conditions <- ...future.conditions
[17:42:44.378]     ...future.result$finished <- base::Sys.time()
[17:42:44.378]     ...future.result
[17:42:44.378] }
[17:42:44.380] assign_globals() ...
[17:42:44.380] List of 1
[17:42:44.380]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56181a5d4c50> 
[17:42:44.380]  - attr(*, "where")=List of 1
[17:42:44.380]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.380]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.380]  - attr(*, "resolved")= logi TRUE
[17:42:44.380]  - attr(*, "total_size")= num 10592
[17:42:44.380]  - attr(*, "already-done")= logi TRUE
[17:42:44.382] - copied ‘a’ to environment
[17:42:44.382] assign_globals() ... done
[17:42:44.383] plan(): Setting new future strategy stack:
[17:42:44.383] List of future strategies:
[17:42:44.383] 1. sequential:
[17:42:44.383]    - args: function (..., envir = parent.frame())
[17:42:44.383]    - tweaked: FALSE
[17:42:44.383]    - call: NULL
[17:42:44.383] plan(): nbrOfWorkers() = 1
[17:42:44.384] plan(): Setting new future strategy stack:
[17:42:44.384] List of future strategies:
[17:42:44.384] 1. sequential:
[17:42:44.384]    - args: function (..., envir = parent.frame())
[17:42:44.384]    - tweaked: FALSE
[17:42:44.384]    - call: plan(strategy)
[17:42:44.385] plan(): nbrOfWorkers() = 1
[17:42:44.385] SequentialFuture started (and completed)
[17:42:44.385] - Launch lazy future ... done
[17:42:44.385] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.386] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.386] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.386] 
[17:42:44.386] Searching for globals ... DONE
[17:42:44.387] - globals: [0] <none>
[17:42:44.387] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.387] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.387] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.388] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.388] Searching for globals ... DONE
[17:42:44.388] Resolving globals: TRUE
[17:42:44.388] Resolving any globals that are futures ...
[17:42:44.388] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.389] Resolving any globals that are futures ... DONE
[17:42:44.389] Resolving futures part of globals (recursively) ...
[17:42:44.389] resolve() on list ...
[17:42:44.389]  recursive: 99
[17:42:44.389]  length: 1
[17:42:44.389]  elements: ‘a’
[17:42:44.389] run() for ‘Future’ ...
[17:42:44.390] - state: ‘created’
[17:42:44.390] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.390] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.390]   - Field: ‘label’
[17:42:44.390]   - Field: ‘local’
[17:42:44.390]   - Field: ‘owner’
[17:42:44.391]   - Field: ‘envir’
[17:42:44.391]   - Field: ‘packages’
[17:42:44.391]   - Field: ‘gc’
[17:42:44.391]   - Field: ‘conditions’
[17:42:44.391]   - Field: ‘expr’
[17:42:44.391]   - Field: ‘uuid’
[17:42:44.391]   - Field: ‘seed’
[17:42:44.391]   - Field: ‘version’
[17:42:44.391]   - Field: ‘result’
[17:42:44.391]   - Field: ‘asynchronous’
[17:42:44.391]   - Field: ‘calls’
[17:42:44.392]   - Field: ‘globals’
[17:42:44.392]   - Field: ‘stdout’
[17:42:44.392]   - Field: ‘earlySignal’
[17:42:44.392]   - Field: ‘lazy’
[17:42:44.392]   - Field: ‘state’
[17:42:44.392] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.392] - Launch lazy future ...
[17:42:44.392] Packages needed by the future expression (n = 0): <none>
[17:42:44.392] Packages needed by future strategies (n = 0): <none>
[17:42:44.393] {
[17:42:44.393]     {
[17:42:44.393]         {
[17:42:44.393]             ...future.startTime <- base::Sys.time()
[17:42:44.393]             {
[17:42:44.393]                 {
[17:42:44.393]                   {
[17:42:44.393]                     base::local({
[17:42:44.393]                       has_future <- base::requireNamespace("future", 
[17:42:44.393]                         quietly = TRUE)
[17:42:44.393]                       if (has_future) {
[17:42:44.393]                         ns <- base::getNamespace("future")
[17:42:44.393]                         version <- ns[[".package"]][["version"]]
[17:42:44.393]                         if (is.null(version)) 
[17:42:44.393]                           version <- utils::packageVersion("future")
[17:42:44.393]                       }
[17:42:44.393]                       else {
[17:42:44.393]                         version <- NULL
[17:42:44.393]                       }
[17:42:44.393]                       if (!has_future || version < "1.8.0") {
[17:42:44.393]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.393]                           "", base::R.version$version.string), 
[17:42:44.393]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.393]                             "release", "version")], collapse = " "), 
[17:42:44.393]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.393]                           info)
[17:42:44.393]                         info <- base::paste(info, collapse = "; ")
[17:42:44.393]                         if (!has_future) {
[17:42:44.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.393]                             info)
[17:42:44.393]                         }
[17:42:44.393]                         else {
[17:42:44.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.393]                             info, version)
[17:42:44.393]                         }
[17:42:44.393]                         base::stop(msg)
[17:42:44.393]                       }
[17:42:44.393]                     })
[17:42:44.393]                   }
[17:42:44.393]                   options(future.plan = NULL)
[17:42:44.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.393]                 }
[17:42:44.393]                 ...future.workdir <- getwd()
[17:42:44.393]             }
[17:42:44.393]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.393]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.393]         }
[17:42:44.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.393]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.393]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.393]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.393]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.393]             base::names(...future.oldOptions))
[17:42:44.393]     }
[17:42:44.393]     if (FALSE) {
[17:42:44.393]     }
[17:42:44.393]     else {
[17:42:44.393]         if (TRUE) {
[17:42:44.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.393]                 open = "w")
[17:42:44.393]         }
[17:42:44.393]         else {
[17:42:44.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.393]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.393]         }
[17:42:44.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.393]             base::sink(type = "output", split = FALSE)
[17:42:44.393]             base::close(...future.stdout)
[17:42:44.393]         }, add = TRUE)
[17:42:44.393]     }
[17:42:44.393]     ...future.frame <- base::sys.nframe()
[17:42:44.393]     ...future.conditions <- base::list()
[17:42:44.393]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.393]     if (FALSE) {
[17:42:44.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.393]     }
[17:42:44.393]     ...future.result <- base::tryCatch({
[17:42:44.393]         base::withCallingHandlers({
[17:42:44.393]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.393]             future::FutureResult(value = ...future.value$value, 
[17:42:44.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.393]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.393]                     ...future.globalenv.names))
[17:42:44.393]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.393]         }, condition = base::local({
[17:42:44.393]             c <- base::c
[17:42:44.393]             inherits <- base::inherits
[17:42:44.393]             invokeRestart <- base::invokeRestart
[17:42:44.393]             length <- base::length
[17:42:44.393]             list <- base::list
[17:42:44.393]             seq.int <- base::seq.int
[17:42:44.393]             signalCondition <- base::signalCondition
[17:42:44.393]             sys.calls <- base::sys.calls
[17:42:44.393]             `[[` <- base::`[[`
[17:42:44.393]             `+` <- base::`+`
[17:42:44.393]             `<<-` <- base::`<<-`
[17:42:44.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.393]                   3L)]
[17:42:44.393]             }
[17:42:44.393]             function(cond) {
[17:42:44.393]                 is_error <- inherits(cond, "error")
[17:42:44.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.393]                   NULL)
[17:42:44.393]                 if (is_error) {
[17:42:44.393]                   sessionInformation <- function() {
[17:42:44.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.393]                       search = base::search(), system = base::Sys.info())
[17:42:44.393]                   }
[17:42:44.393]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.393]                     cond$call), session = sessionInformation(), 
[17:42:44.393]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.393]                   signalCondition(cond)
[17:42:44.393]                 }
[17:42:44.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.393]                 "immediateCondition"))) {
[17:42:44.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.393]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.393]                   if (TRUE && !signal) {
[17:42:44.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.393]                     {
[17:42:44.393]                       inherits <- base::inherits
[17:42:44.393]                       invokeRestart <- base::invokeRestart
[17:42:44.393]                       is.null <- base::is.null
[17:42:44.393]                       muffled <- FALSE
[17:42:44.393]                       if (inherits(cond, "message")) {
[17:42:44.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.393]                         if (muffled) 
[17:42:44.393]                           invokeRestart("muffleMessage")
[17:42:44.393]                       }
[17:42:44.393]                       else if (inherits(cond, "warning")) {
[17:42:44.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.393]                         if (muffled) 
[17:42:44.393]                           invokeRestart("muffleWarning")
[17:42:44.393]                       }
[17:42:44.393]                       else if (inherits(cond, "condition")) {
[17:42:44.393]                         if (!is.null(pattern)) {
[17:42:44.393]                           computeRestarts <- base::computeRestarts
[17:42:44.393]                           grepl <- base::grepl
[17:42:44.393]                           restarts <- computeRestarts(cond)
[17:42:44.393]                           for (restart in restarts) {
[17:42:44.393]                             name <- restart$name
[17:42:44.393]                             if (is.null(name)) 
[17:42:44.393]                               next
[17:42:44.393]                             if (!grepl(pattern, name)) 
[17:42:44.393]                               next
[17:42:44.393]                             invokeRestart(restart)
[17:42:44.393]                             muffled <- TRUE
[17:42:44.393]                             break
[17:42:44.393]                           }
[17:42:44.393]                         }
[17:42:44.393]                       }
[17:42:44.393]                       invisible(muffled)
[17:42:44.393]                     }
[17:42:44.393]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.393]                   }
[17:42:44.393]                 }
[17:42:44.393]                 else {
[17:42:44.393]                   if (TRUE) {
[17:42:44.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.393]                     {
[17:42:44.393]                       inherits <- base::inherits
[17:42:44.393]                       invokeRestart <- base::invokeRestart
[17:42:44.393]                       is.null <- base::is.null
[17:42:44.393]                       muffled <- FALSE
[17:42:44.393]                       if (inherits(cond, "message")) {
[17:42:44.393]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.393]                         if (muffled) 
[17:42:44.393]                           invokeRestart("muffleMessage")
[17:42:44.393]                       }
[17:42:44.393]                       else if (inherits(cond, "warning")) {
[17:42:44.393]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.393]                         if (muffled) 
[17:42:44.393]                           invokeRestart("muffleWarning")
[17:42:44.393]                       }
[17:42:44.393]                       else if (inherits(cond, "condition")) {
[17:42:44.393]                         if (!is.null(pattern)) {
[17:42:44.393]                           computeRestarts <- base::computeRestarts
[17:42:44.393]                           grepl <- base::grepl
[17:42:44.393]                           restarts <- computeRestarts(cond)
[17:42:44.393]                           for (restart in restarts) {
[17:42:44.393]                             name <- restart$name
[17:42:44.393]                             if (is.null(name)) 
[17:42:44.393]                               next
[17:42:44.393]                             if (!grepl(pattern, name)) 
[17:42:44.393]                               next
[17:42:44.393]                             invokeRestart(restart)
[17:42:44.393]                             muffled <- TRUE
[17:42:44.393]                             break
[17:42:44.393]                           }
[17:42:44.393]                         }
[17:42:44.393]                       }
[17:42:44.393]                       invisible(muffled)
[17:42:44.393]                     }
[17:42:44.393]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.393]                   }
[17:42:44.393]                 }
[17:42:44.393]             }
[17:42:44.393]         }))
[17:42:44.393]     }, error = function(ex) {
[17:42:44.393]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.393]                 ...future.rng), started = ...future.startTime, 
[17:42:44.393]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.393]             version = "1.8"), class = "FutureResult")
[17:42:44.393]     }, finally = {
[17:42:44.393]         if (!identical(...future.workdir, getwd())) 
[17:42:44.393]             setwd(...future.workdir)
[17:42:44.393]         {
[17:42:44.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.393]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.393]             }
[17:42:44.393]             base::options(...future.oldOptions)
[17:42:44.393]             if (.Platform$OS.type == "windows") {
[17:42:44.393]                 old_names <- names(...future.oldEnvVars)
[17:42:44.393]                 envs <- base::Sys.getenv()
[17:42:44.393]                 names <- names(envs)
[17:42:44.393]                 common <- intersect(names, old_names)
[17:42:44.393]                 added <- setdiff(names, old_names)
[17:42:44.393]                 removed <- setdiff(old_names, names)
[17:42:44.393]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.393]                   envs[common]]
[17:42:44.393]                 NAMES <- toupper(changed)
[17:42:44.393]                 args <- list()
[17:42:44.393]                 for (kk in seq_along(NAMES)) {
[17:42:44.393]                   name <- changed[[kk]]
[17:42:44.393]                   NAME <- NAMES[[kk]]
[17:42:44.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.393]                     next
[17:42:44.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.393]                 }
[17:42:44.393]                 NAMES <- toupper(added)
[17:42:44.393]                 for (kk in seq_along(NAMES)) {
[17:42:44.393]                   name <- added[[kk]]
[17:42:44.393]                   NAME <- NAMES[[kk]]
[17:42:44.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.393]                     next
[17:42:44.393]                   args[[name]] <- ""
[17:42:44.393]                 }
[17:42:44.393]                 NAMES <- toupper(removed)
[17:42:44.393]                 for (kk in seq_along(NAMES)) {
[17:42:44.393]                   name <- removed[[kk]]
[17:42:44.393]                   NAME <- NAMES[[kk]]
[17:42:44.393]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.393]                     next
[17:42:44.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.393]                 }
[17:42:44.393]                 if (length(args) > 0) 
[17:42:44.393]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.393]             }
[17:42:44.393]             else {
[17:42:44.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.393]             }
[17:42:44.393]             {
[17:42:44.393]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.393]                   0L) {
[17:42:44.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.393]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.393]                   base::options(opts)
[17:42:44.393]                 }
[17:42:44.393]                 {
[17:42:44.393]                   {
[17:42:44.393]                     NULL
[17:42:44.393]                     RNGkind("Mersenne-Twister")
[17:42:44.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.393]                       inherits = FALSE)
[17:42:44.393]                   }
[17:42:44.393]                   options(future.plan = NULL)
[17:42:44.393]                   if (is.na(NA_character_)) 
[17:42:44.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.393]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.393]                   {
[17:42:44.393]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.393]                     if (!future$lazy) 
[17:42:44.393]                       future <- run(future)
[17:42:44.393]                     invisible(future)
[17:42:44.393]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.393]                 }
[17:42:44.393]             }
[17:42:44.393]         }
[17:42:44.393]     })
[17:42:44.393]     if (TRUE) {
[17:42:44.393]         base::sink(type = "output", split = FALSE)
[17:42:44.393]         if (TRUE) {
[17:42:44.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.393]         }
[17:42:44.393]         else {
[17:42:44.393]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.393]         }
[17:42:44.393]         base::close(...future.stdout)
[17:42:44.393]         ...future.stdout <- NULL
[17:42:44.393]     }
[17:42:44.393]     ...future.result$conditions <- ...future.conditions
[17:42:44.393]     ...future.result$finished <- base::Sys.time()
[17:42:44.393]     ...future.result
[17:42:44.393] }
[17:42:44.395] plan(): Setting new future strategy stack:
[17:42:44.395] List of future strategies:
[17:42:44.395] 1. sequential:
[17:42:44.395]    - args: function (..., envir = parent.frame())
[17:42:44.395]    - tweaked: FALSE
[17:42:44.395]    - call: NULL
[17:42:44.395] plan(): nbrOfWorkers() = 1
[17:42:44.396] plan(): Setting new future strategy stack:
[17:42:44.396] List of future strategies:
[17:42:44.396] 1. sequential:
[17:42:44.396]    - args: function (..., envir = parent.frame())
[17:42:44.396]    - tweaked: FALSE
[17:42:44.396]    - call: plan(strategy)
[17:42:44.396] plan(): nbrOfWorkers() = 1
[17:42:44.396] SequentialFuture started (and completed)
[17:42:44.397] - Launch lazy future ... done
[17:42:44.397] run() for ‘SequentialFuture’ ... done
[17:42:44.397] resolved() for ‘SequentialFuture’ ...
[17:42:44.397] - state: ‘finished’
[17:42:44.397] - run: TRUE
[17:42:44.397] - result: ‘FutureResult’
[17:42:44.397] resolved() for ‘SequentialFuture’ ... done
[17:42:44.397] Future #1
[17:42:44.397] resolved() for ‘SequentialFuture’ ...
[17:42:44.398] - state: ‘finished’
[17:42:44.398] - run: TRUE
[17:42:44.398] - result: ‘FutureResult’
[17:42:44.398] resolved() for ‘SequentialFuture’ ... done
[17:42:44.398] A SequentialFuture was resolved
[17:42:44.398]  length: 0 (resolved future 1)
[17:42:44.398] resolve() on list ... DONE
[17:42:44.398] - globals: [1] ‘a’
[17:42:44.398] Resolving futures part of globals (recursively) ... DONE
[17:42:44.399] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[17:42:44.399] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[17:42:44.400] - globals: [1] ‘a’
[17:42:44.400] - packages: [1] ‘future’
[17:42:44.400] getGlobalsAndPackages() ... DONE
[17:42:44.400] run() for ‘Future’ ...
[17:42:44.400] - state: ‘created’
[17:42:44.400] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.401] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.401] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.401]   - Field: ‘label’
[17:42:44.401]   - Field: ‘local’
[17:42:44.401]   - Field: ‘owner’
[17:42:44.401]   - Field: ‘envir’
[17:42:44.401]   - Field: ‘packages’
[17:42:44.401]   - Field: ‘gc’
[17:42:44.401]   - Field: ‘conditions’
[17:42:44.401]   - Field: ‘expr’
[17:42:44.402]   - Field: ‘uuid’
[17:42:44.402]   - Field: ‘seed’
[17:42:44.402]   - Field: ‘version’
[17:42:44.402]   - Field: ‘result’
[17:42:44.402]   - Field: ‘asynchronous’
[17:42:44.402]   - Field: ‘calls’
[17:42:44.402]   - Field: ‘globals’
[17:42:44.402]   - Field: ‘stdout’
[17:42:44.402]   - Field: ‘earlySignal’
[17:42:44.402]   - Field: ‘lazy’
[17:42:44.402]   - Field: ‘state’
[17:42:44.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.403] - Launch lazy future ...
[17:42:44.403] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.403] Packages needed by future strategies (n = 0): <none>
[17:42:44.406] {
[17:42:44.406]     {
[17:42:44.406]         {
[17:42:44.406]             ...future.startTime <- base::Sys.time()
[17:42:44.406]             {
[17:42:44.406]                 {
[17:42:44.406]                   {
[17:42:44.406]                     {
[17:42:44.406]                       base::local({
[17:42:44.406]                         has_future <- base::requireNamespace("future", 
[17:42:44.406]                           quietly = TRUE)
[17:42:44.406]                         if (has_future) {
[17:42:44.406]                           ns <- base::getNamespace("future")
[17:42:44.406]                           version <- ns[[".package"]][["version"]]
[17:42:44.406]                           if (is.null(version)) 
[17:42:44.406]                             version <- utils::packageVersion("future")
[17:42:44.406]                         }
[17:42:44.406]                         else {
[17:42:44.406]                           version <- NULL
[17:42:44.406]                         }
[17:42:44.406]                         if (!has_future || version < "1.8.0") {
[17:42:44.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.406]                             "", base::R.version$version.string), 
[17:42:44.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.406]                               "release", "version")], collapse = " "), 
[17:42:44.406]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.406]                             info)
[17:42:44.406]                           info <- base::paste(info, collapse = "; ")
[17:42:44.406]                           if (!has_future) {
[17:42:44.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.406]                               info)
[17:42:44.406]                           }
[17:42:44.406]                           else {
[17:42:44.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.406]                               info, version)
[17:42:44.406]                           }
[17:42:44.406]                           base::stop(msg)
[17:42:44.406]                         }
[17:42:44.406]                       })
[17:42:44.406]                     }
[17:42:44.406]                     base::local({
[17:42:44.406]                       for (pkg in "future") {
[17:42:44.406]                         base::loadNamespace(pkg)
[17:42:44.406]                         base::library(pkg, character.only = TRUE)
[17:42:44.406]                       }
[17:42:44.406]                     })
[17:42:44.406]                   }
[17:42:44.406]                   options(future.plan = NULL)
[17:42:44.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.406]                 }
[17:42:44.406]                 ...future.workdir <- getwd()
[17:42:44.406]             }
[17:42:44.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.406]         }
[17:42:44.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.406]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.406]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.406]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.406]             base::names(...future.oldOptions))
[17:42:44.406]     }
[17:42:44.406]     if (FALSE) {
[17:42:44.406]     }
[17:42:44.406]     else {
[17:42:44.406]         if (TRUE) {
[17:42:44.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.406]                 open = "w")
[17:42:44.406]         }
[17:42:44.406]         else {
[17:42:44.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.406]         }
[17:42:44.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.406]             base::sink(type = "output", split = FALSE)
[17:42:44.406]             base::close(...future.stdout)
[17:42:44.406]         }, add = TRUE)
[17:42:44.406]     }
[17:42:44.406]     ...future.frame <- base::sys.nframe()
[17:42:44.406]     ...future.conditions <- base::list()
[17:42:44.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.406]     if (FALSE) {
[17:42:44.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.406]     }
[17:42:44.406]     ...future.result <- base::tryCatch({
[17:42:44.406]         base::withCallingHandlers({
[17:42:44.406]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.406]                 1))
[17:42:44.406]             future::FutureResult(value = ...future.value$value, 
[17:42:44.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.406]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.406]                     ...future.globalenv.names))
[17:42:44.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.406]         }, condition = base::local({
[17:42:44.406]             c <- base::c
[17:42:44.406]             inherits <- base::inherits
[17:42:44.406]             invokeRestart <- base::invokeRestart
[17:42:44.406]             length <- base::length
[17:42:44.406]             list <- base::list
[17:42:44.406]             seq.int <- base::seq.int
[17:42:44.406]             signalCondition <- base::signalCondition
[17:42:44.406]             sys.calls <- base::sys.calls
[17:42:44.406]             `[[` <- base::`[[`
[17:42:44.406]             `+` <- base::`+`
[17:42:44.406]             `<<-` <- base::`<<-`
[17:42:44.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.406]                   3L)]
[17:42:44.406]             }
[17:42:44.406]             function(cond) {
[17:42:44.406]                 is_error <- inherits(cond, "error")
[17:42:44.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.406]                   NULL)
[17:42:44.406]                 if (is_error) {
[17:42:44.406]                   sessionInformation <- function() {
[17:42:44.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.406]                       search = base::search(), system = base::Sys.info())
[17:42:44.406]                   }
[17:42:44.406]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.406]                     cond$call), session = sessionInformation(), 
[17:42:44.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.406]                   signalCondition(cond)
[17:42:44.406]                 }
[17:42:44.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.406]                 "immediateCondition"))) {
[17:42:44.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.406]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.406]                   if (TRUE && !signal) {
[17:42:44.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.406]                     {
[17:42:44.406]                       inherits <- base::inherits
[17:42:44.406]                       invokeRestart <- base::invokeRestart
[17:42:44.406]                       is.null <- base::is.null
[17:42:44.406]                       muffled <- FALSE
[17:42:44.406]                       if (inherits(cond, "message")) {
[17:42:44.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.406]                         if (muffled) 
[17:42:44.406]                           invokeRestart("muffleMessage")
[17:42:44.406]                       }
[17:42:44.406]                       else if (inherits(cond, "warning")) {
[17:42:44.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.406]                         if (muffled) 
[17:42:44.406]                           invokeRestart("muffleWarning")
[17:42:44.406]                       }
[17:42:44.406]                       else if (inherits(cond, "condition")) {
[17:42:44.406]                         if (!is.null(pattern)) {
[17:42:44.406]                           computeRestarts <- base::computeRestarts
[17:42:44.406]                           grepl <- base::grepl
[17:42:44.406]                           restarts <- computeRestarts(cond)
[17:42:44.406]                           for (restart in restarts) {
[17:42:44.406]                             name <- restart$name
[17:42:44.406]                             if (is.null(name)) 
[17:42:44.406]                               next
[17:42:44.406]                             if (!grepl(pattern, name)) 
[17:42:44.406]                               next
[17:42:44.406]                             invokeRestart(restart)
[17:42:44.406]                             muffled <- TRUE
[17:42:44.406]                             break
[17:42:44.406]                           }
[17:42:44.406]                         }
[17:42:44.406]                       }
[17:42:44.406]                       invisible(muffled)
[17:42:44.406]                     }
[17:42:44.406]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.406]                   }
[17:42:44.406]                 }
[17:42:44.406]                 else {
[17:42:44.406]                   if (TRUE) {
[17:42:44.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.406]                     {
[17:42:44.406]                       inherits <- base::inherits
[17:42:44.406]                       invokeRestart <- base::invokeRestart
[17:42:44.406]                       is.null <- base::is.null
[17:42:44.406]                       muffled <- FALSE
[17:42:44.406]                       if (inherits(cond, "message")) {
[17:42:44.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.406]                         if (muffled) 
[17:42:44.406]                           invokeRestart("muffleMessage")
[17:42:44.406]                       }
[17:42:44.406]                       else if (inherits(cond, "warning")) {
[17:42:44.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.406]                         if (muffled) 
[17:42:44.406]                           invokeRestart("muffleWarning")
[17:42:44.406]                       }
[17:42:44.406]                       else if (inherits(cond, "condition")) {
[17:42:44.406]                         if (!is.null(pattern)) {
[17:42:44.406]                           computeRestarts <- base::computeRestarts
[17:42:44.406]                           grepl <- base::grepl
[17:42:44.406]                           restarts <- computeRestarts(cond)
[17:42:44.406]                           for (restart in restarts) {
[17:42:44.406]                             name <- restart$name
[17:42:44.406]                             if (is.null(name)) 
[17:42:44.406]                               next
[17:42:44.406]                             if (!grepl(pattern, name)) 
[17:42:44.406]                               next
[17:42:44.406]                             invokeRestart(restart)
[17:42:44.406]                             muffled <- TRUE
[17:42:44.406]                             break
[17:42:44.406]                           }
[17:42:44.406]                         }
[17:42:44.406]                       }
[17:42:44.406]                       invisible(muffled)
[17:42:44.406]                     }
[17:42:44.406]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.406]                   }
[17:42:44.406]                 }
[17:42:44.406]             }
[17:42:44.406]         }))
[17:42:44.406]     }, error = function(ex) {
[17:42:44.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.406]                 ...future.rng), started = ...future.startTime, 
[17:42:44.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.406]             version = "1.8"), class = "FutureResult")
[17:42:44.406]     }, finally = {
[17:42:44.406]         if (!identical(...future.workdir, getwd())) 
[17:42:44.406]             setwd(...future.workdir)
[17:42:44.406]         {
[17:42:44.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.406]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.406]             }
[17:42:44.406]             base::options(...future.oldOptions)
[17:42:44.406]             if (.Platform$OS.type == "windows") {
[17:42:44.406]                 old_names <- names(...future.oldEnvVars)
[17:42:44.406]                 envs <- base::Sys.getenv()
[17:42:44.406]                 names <- names(envs)
[17:42:44.406]                 common <- intersect(names, old_names)
[17:42:44.406]                 added <- setdiff(names, old_names)
[17:42:44.406]                 removed <- setdiff(old_names, names)
[17:42:44.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.406]                   envs[common]]
[17:42:44.406]                 NAMES <- toupper(changed)
[17:42:44.406]                 args <- list()
[17:42:44.406]                 for (kk in seq_along(NAMES)) {
[17:42:44.406]                   name <- changed[[kk]]
[17:42:44.406]                   NAME <- NAMES[[kk]]
[17:42:44.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.406]                     next
[17:42:44.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.406]                 }
[17:42:44.406]                 NAMES <- toupper(added)
[17:42:44.406]                 for (kk in seq_along(NAMES)) {
[17:42:44.406]                   name <- added[[kk]]
[17:42:44.406]                   NAME <- NAMES[[kk]]
[17:42:44.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.406]                     next
[17:42:44.406]                   args[[name]] <- ""
[17:42:44.406]                 }
[17:42:44.406]                 NAMES <- toupper(removed)
[17:42:44.406]                 for (kk in seq_along(NAMES)) {
[17:42:44.406]                   name <- removed[[kk]]
[17:42:44.406]                   NAME <- NAMES[[kk]]
[17:42:44.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.406]                     next
[17:42:44.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.406]                 }
[17:42:44.406]                 if (length(args) > 0) 
[17:42:44.406]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.406]             }
[17:42:44.406]             else {
[17:42:44.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.406]             }
[17:42:44.406]             {
[17:42:44.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.406]                   0L) {
[17:42:44.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.406]                   base::options(opts)
[17:42:44.406]                 }
[17:42:44.406]                 {
[17:42:44.406]                   {
[17:42:44.406]                     NULL
[17:42:44.406]                     RNGkind("Mersenne-Twister")
[17:42:44.406]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.406]                       inherits = FALSE)
[17:42:44.406]                   }
[17:42:44.406]                   options(future.plan = NULL)
[17:42:44.406]                   if (is.na(NA_character_)) 
[17:42:44.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.406]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.406]                   {
[17:42:44.406]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.406]                     if (!future$lazy) 
[17:42:44.406]                       future <- run(future)
[17:42:44.406]                     invisible(future)
[17:42:44.406]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.406]                 }
[17:42:44.406]             }
[17:42:44.406]         }
[17:42:44.406]     })
[17:42:44.406]     if (TRUE) {
[17:42:44.406]         base::sink(type = "output", split = FALSE)
[17:42:44.406]         if (TRUE) {
[17:42:44.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.406]         }
[17:42:44.406]         else {
[17:42:44.406]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.406]         }
[17:42:44.406]         base::close(...future.stdout)
[17:42:44.406]         ...future.stdout <- NULL
[17:42:44.406]     }
[17:42:44.406]     ...future.result$conditions <- ...future.conditions
[17:42:44.406]     ...future.result$finished <- base::Sys.time()
[17:42:44.406]     ...future.result
[17:42:44.406] }
[17:42:44.407] assign_globals() ...
[17:42:44.407] List of 1
[17:42:44.407]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56181a47ab78> 
[17:42:44.407]  - attr(*, "where")=List of 1
[17:42:44.407]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.407]  - attr(*, "resolved")= logi TRUE
[17:42:44.407]  - attr(*, "total_size")= num 10592
[17:42:44.407]  - attr(*, "already-done")= logi TRUE
[17:42:44.410] - copied ‘a’ to environment
[17:42:44.410] assign_globals() ... done
[17:42:44.411] plan(): Setting new future strategy stack:
[17:42:44.411] List of future strategies:
[17:42:44.411] 1. sequential:
[17:42:44.411]    - args: function (..., envir = parent.frame())
[17:42:44.411]    - tweaked: FALSE
[17:42:44.411]    - call: NULL
[17:42:44.411] plan(): nbrOfWorkers() = 1
[17:42:44.412] plan(): Setting new future strategy stack:
[17:42:44.412] List of future strategies:
[17:42:44.412] 1. sequential:
[17:42:44.412]    - args: function (..., envir = parent.frame())
[17:42:44.412]    - tweaked: FALSE
[17:42:44.412]    - call: plan(strategy)
[17:42:44.412] plan(): nbrOfWorkers() = 1
[17:42:44.413] SequentialFuture started (and completed)
[17:42:44.413] - Launch lazy future ... done
[17:42:44.413] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.413] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.413] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.414] - globals found: [2] ‘{’, ‘pkg’
[17:42:44.414] Searching for globals ... DONE
[17:42:44.414] Resolving globals: TRUE
[17:42:44.414] Resolving any globals that are futures ...
[17:42:44.415] - globals: [2] ‘{’, ‘pkg’
[17:42:44.415] Resolving any globals that are futures ... DONE
[17:42:44.415] Resolving futures part of globals (recursively) ...
[17:42:44.415] resolve() on list ...
[17:42:44.415]  recursive: 99
[17:42:44.415]  length: 1
[17:42:44.416]  elements: ‘pkg’
[17:42:44.416]  length: 0 (resolved future 1)
[17:42:44.416] resolve() on list ... DONE
[17:42:44.416] - globals: [1] ‘pkg’
[17:42:44.416] Resolving futures part of globals (recursively) ... DONE
[17:42:44.416] The total size of the 1 globals is 112 bytes (112 bytes)
[17:42:44.416] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:42:44.416] - globals: [1] ‘pkg’
[17:42:44.417] 
[17:42:44.417] getGlobalsAndPackages() ... DONE
[17:42:44.417] Packages needed by the future expression (n = 0): <none>
[17:42:44.417] Packages needed by future strategies (n = 0): <none>
[17:42:44.418] {
[17:42:44.418]     {
[17:42:44.418]         {
[17:42:44.418]             ...future.startTime <- base::Sys.time()
[17:42:44.418]             {
[17:42:44.418]                 {
[17:42:44.418]                   {
[17:42:44.418]                     base::local({
[17:42:44.418]                       has_future <- base::requireNamespace("future", 
[17:42:44.418]                         quietly = TRUE)
[17:42:44.418]                       if (has_future) {
[17:42:44.418]                         ns <- base::getNamespace("future")
[17:42:44.418]                         version <- ns[[".package"]][["version"]]
[17:42:44.418]                         if (is.null(version)) 
[17:42:44.418]                           version <- utils::packageVersion("future")
[17:42:44.418]                       }
[17:42:44.418]                       else {
[17:42:44.418]                         version <- NULL
[17:42:44.418]                       }
[17:42:44.418]                       if (!has_future || version < "1.8.0") {
[17:42:44.418]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.418]                           "", base::R.version$version.string), 
[17:42:44.418]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.418]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.418]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.418]                             "release", "version")], collapse = " "), 
[17:42:44.418]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.418]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.418]                           info)
[17:42:44.418]                         info <- base::paste(info, collapse = "; ")
[17:42:44.418]                         if (!has_future) {
[17:42:44.418]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.418]                             info)
[17:42:44.418]                         }
[17:42:44.418]                         else {
[17:42:44.418]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.418]                             info, version)
[17:42:44.418]                         }
[17:42:44.418]                         base::stop(msg)
[17:42:44.418]                       }
[17:42:44.418]                     })
[17:42:44.418]                   }
[17:42:44.418]                   options(future.plan = NULL)
[17:42:44.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.418]                 }
[17:42:44.418]                 ...future.workdir <- getwd()
[17:42:44.418]             }
[17:42:44.418]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.418]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.418]         }
[17:42:44.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.418]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.418]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.418]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.418]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.418]             base::names(...future.oldOptions))
[17:42:44.418]     }
[17:42:44.418]     if (FALSE) {
[17:42:44.418]     }
[17:42:44.418]     else {
[17:42:44.418]         if (TRUE) {
[17:42:44.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.418]                 open = "w")
[17:42:44.418]         }
[17:42:44.418]         else {
[17:42:44.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.418]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.418]         }
[17:42:44.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.418]             base::sink(type = "output", split = FALSE)
[17:42:44.418]             base::close(...future.stdout)
[17:42:44.418]         }, add = TRUE)
[17:42:44.418]     }
[17:42:44.418]     ...future.frame <- base::sys.nframe()
[17:42:44.418]     ...future.conditions <- base::list()
[17:42:44.418]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.418]     if (FALSE) {
[17:42:44.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.418]     }
[17:42:44.418]     ...future.result <- base::tryCatch({
[17:42:44.418]         base::withCallingHandlers({
[17:42:44.418]             ...future.value <- base::withVisible(base::local({
[17:42:44.418]                 pkg
[17:42:44.418]             }))
[17:42:44.418]             future::FutureResult(value = ...future.value$value, 
[17:42:44.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.418]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.418]                     ...future.globalenv.names))
[17:42:44.418]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.418]         }, condition = base::local({
[17:42:44.418]             c <- base::c
[17:42:44.418]             inherits <- base::inherits
[17:42:44.418]             invokeRestart <- base::invokeRestart
[17:42:44.418]             length <- base::length
[17:42:44.418]             list <- base::list
[17:42:44.418]             seq.int <- base::seq.int
[17:42:44.418]             signalCondition <- base::signalCondition
[17:42:44.418]             sys.calls <- base::sys.calls
[17:42:44.418]             `[[` <- base::`[[`
[17:42:44.418]             `+` <- base::`+`
[17:42:44.418]             `<<-` <- base::`<<-`
[17:42:44.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.418]                   3L)]
[17:42:44.418]             }
[17:42:44.418]             function(cond) {
[17:42:44.418]                 is_error <- inherits(cond, "error")
[17:42:44.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.418]                   NULL)
[17:42:44.418]                 if (is_error) {
[17:42:44.418]                   sessionInformation <- function() {
[17:42:44.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.418]                       search = base::search(), system = base::Sys.info())
[17:42:44.418]                   }
[17:42:44.418]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.418]                     cond$call), session = sessionInformation(), 
[17:42:44.418]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.418]                   signalCondition(cond)
[17:42:44.418]                 }
[17:42:44.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.418]                 "immediateCondition"))) {
[17:42:44.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.418]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.418]                   if (TRUE && !signal) {
[17:42:44.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.418]                     {
[17:42:44.418]                       inherits <- base::inherits
[17:42:44.418]                       invokeRestart <- base::invokeRestart
[17:42:44.418]                       is.null <- base::is.null
[17:42:44.418]                       muffled <- FALSE
[17:42:44.418]                       if (inherits(cond, "message")) {
[17:42:44.418]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.418]                         if (muffled) 
[17:42:44.418]                           invokeRestart("muffleMessage")
[17:42:44.418]                       }
[17:42:44.418]                       else if (inherits(cond, "warning")) {
[17:42:44.418]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.418]                         if (muffled) 
[17:42:44.418]                           invokeRestart("muffleWarning")
[17:42:44.418]                       }
[17:42:44.418]                       else if (inherits(cond, "condition")) {
[17:42:44.418]                         if (!is.null(pattern)) {
[17:42:44.418]                           computeRestarts <- base::computeRestarts
[17:42:44.418]                           grepl <- base::grepl
[17:42:44.418]                           restarts <- computeRestarts(cond)
[17:42:44.418]                           for (restart in restarts) {
[17:42:44.418]                             name <- restart$name
[17:42:44.418]                             if (is.null(name)) 
[17:42:44.418]                               next
[17:42:44.418]                             if (!grepl(pattern, name)) 
[17:42:44.418]                               next
[17:42:44.418]                             invokeRestart(restart)
[17:42:44.418]                             muffled <- TRUE
[17:42:44.418]                             break
[17:42:44.418]                           }
[17:42:44.418]                         }
[17:42:44.418]                       }
[17:42:44.418]                       invisible(muffled)
[17:42:44.418]                     }
[17:42:44.418]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.418]                   }
[17:42:44.418]                 }
[17:42:44.418]                 else {
[17:42:44.418]                   if (TRUE) {
[17:42:44.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.418]                     {
[17:42:44.418]                       inherits <- base::inherits
[17:42:44.418]                       invokeRestart <- base::invokeRestart
[17:42:44.418]                       is.null <- base::is.null
[17:42:44.418]                       muffled <- FALSE
[17:42:44.418]                       if (inherits(cond, "message")) {
[17:42:44.418]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.418]                         if (muffled) 
[17:42:44.418]                           invokeRestart("muffleMessage")
[17:42:44.418]                       }
[17:42:44.418]                       else if (inherits(cond, "warning")) {
[17:42:44.418]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.418]                         if (muffled) 
[17:42:44.418]                           invokeRestart("muffleWarning")
[17:42:44.418]                       }
[17:42:44.418]                       else if (inherits(cond, "condition")) {
[17:42:44.418]                         if (!is.null(pattern)) {
[17:42:44.418]                           computeRestarts <- base::computeRestarts
[17:42:44.418]                           grepl <- base::grepl
[17:42:44.418]                           restarts <- computeRestarts(cond)
[17:42:44.418]                           for (restart in restarts) {
[17:42:44.418]                             name <- restart$name
[17:42:44.418]                             if (is.null(name)) 
[17:42:44.418]                               next
[17:42:44.418]                             if (!grepl(pattern, name)) 
[17:42:44.418]                               next
[17:42:44.418]                             invokeRestart(restart)
[17:42:44.418]                             muffled <- TRUE
[17:42:44.418]                             break
[17:42:44.418]                           }
[17:42:44.418]                         }
[17:42:44.418]                       }
[17:42:44.418]                       invisible(muffled)
[17:42:44.418]                     }
[17:42:44.418]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.418]                   }
[17:42:44.418]                 }
[17:42:44.418]             }
[17:42:44.418]         }))
[17:42:44.418]     }, error = function(ex) {
[17:42:44.418]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.418]                 ...future.rng), started = ...future.startTime, 
[17:42:44.418]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.418]             version = "1.8"), class = "FutureResult")
[17:42:44.418]     }, finally = {
[17:42:44.418]         if (!identical(...future.workdir, getwd())) 
[17:42:44.418]             setwd(...future.workdir)
[17:42:44.418]         {
[17:42:44.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.418]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.418]             }
[17:42:44.418]             base::options(...future.oldOptions)
[17:42:44.418]             if (.Platform$OS.type == "windows") {
[17:42:44.418]                 old_names <- names(...future.oldEnvVars)
[17:42:44.418]                 envs <- base::Sys.getenv()
[17:42:44.418]                 names <- names(envs)
[17:42:44.418]                 common <- intersect(names, old_names)
[17:42:44.418]                 added <- setdiff(names, old_names)
[17:42:44.418]                 removed <- setdiff(old_names, names)
[17:42:44.418]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.418]                   envs[common]]
[17:42:44.418]                 NAMES <- toupper(changed)
[17:42:44.418]                 args <- list()
[17:42:44.418]                 for (kk in seq_along(NAMES)) {
[17:42:44.418]                   name <- changed[[kk]]
[17:42:44.418]                   NAME <- NAMES[[kk]]
[17:42:44.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.418]                     next
[17:42:44.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.418]                 }
[17:42:44.418]                 NAMES <- toupper(added)
[17:42:44.418]                 for (kk in seq_along(NAMES)) {
[17:42:44.418]                   name <- added[[kk]]
[17:42:44.418]                   NAME <- NAMES[[kk]]
[17:42:44.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.418]                     next
[17:42:44.418]                   args[[name]] <- ""
[17:42:44.418]                 }
[17:42:44.418]                 NAMES <- toupper(removed)
[17:42:44.418]                 for (kk in seq_along(NAMES)) {
[17:42:44.418]                   name <- removed[[kk]]
[17:42:44.418]                   NAME <- NAMES[[kk]]
[17:42:44.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.418]                     next
[17:42:44.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.418]                 }
[17:42:44.418]                 if (length(args) > 0) 
[17:42:44.418]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.418]             }
[17:42:44.418]             else {
[17:42:44.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.418]             }
[17:42:44.418]             {
[17:42:44.418]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.418]                   0L) {
[17:42:44.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.418]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.418]                   base::options(opts)
[17:42:44.418]                 }
[17:42:44.418]                 {
[17:42:44.418]                   {
[17:42:44.418]                     NULL
[17:42:44.418]                     RNGkind("Mersenne-Twister")
[17:42:44.418]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.418]                       inherits = FALSE)
[17:42:44.418]                   }
[17:42:44.418]                   options(future.plan = NULL)
[17:42:44.418]                   if (is.na(NA_character_)) 
[17:42:44.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.418]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.418]                   {
[17:42:44.418]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.418]                     if (!future$lazy) 
[17:42:44.418]                       future <- run(future)
[17:42:44.418]                     invisible(future)
[17:42:44.418]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.418]                 }
[17:42:44.418]             }
[17:42:44.418]         }
[17:42:44.418]     })
[17:42:44.418]     if (TRUE) {
[17:42:44.418]         base::sink(type = "output", split = FALSE)
[17:42:44.418]         if (TRUE) {
[17:42:44.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.418]         }
[17:42:44.418]         else {
[17:42:44.418]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.418]         }
[17:42:44.418]         base::close(...future.stdout)
[17:42:44.418]         ...future.stdout <- NULL
[17:42:44.418]     }
[17:42:44.418]     ...future.result$conditions <- ...future.conditions
[17:42:44.418]     ...future.result$finished <- base::Sys.time()
[17:42:44.418]     ...future.result
[17:42:44.418] }
[17:42:44.419] assign_globals() ...
[17:42:44.419] List of 1
[17:42:44.419]  $ pkg: chr "foo"
[17:42:44.419]  - attr(*, "where")=List of 1
[17:42:44.419]   ..$ pkg:<environment: R_EmptyEnv> 
[17:42:44.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.419]  - attr(*, "resolved")= logi TRUE
[17:42:44.419]  - attr(*, "total_size")= num 112
[17:42:44.421] - copied ‘pkg’ to environment
[17:42:44.421] assign_globals() ... done
[17:42:44.422] plan(): Setting new future strategy stack:
[17:42:44.422] List of future strategies:
[17:42:44.422] 1. sequential:
[17:42:44.422]    - args: function (..., envir = parent.frame())
[17:42:44.422]    - tweaked: FALSE
[17:42:44.422]    - call: NULL
[17:42:44.422] plan(): nbrOfWorkers() = 1
[17:42:44.423] plan(): Setting new future strategy stack:
[17:42:44.423] List of future strategies:
[17:42:44.423] 1. sequential:
[17:42:44.423]    - args: function (..., envir = parent.frame())
[17:42:44.423]    - tweaked: FALSE
[17:42:44.423]    - call: plan(strategy)
[17:42:44.423] plan(): nbrOfWorkers() = 1
[17:42:44.423] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.424] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.424] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.427] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:44.427] Searching for globals ... DONE
[17:42:44.427] Resolving globals: TRUE
[17:42:44.427] Resolving any globals that are futures ...
[17:42:44.427] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:44.427] Resolving any globals that are futures ... DONE
[17:42:44.427] Resolving futures part of globals (recursively) ...
[17:42:44.428] resolve() on list ...
[17:42:44.428]  recursive: 99
[17:42:44.428]  length: 1
[17:42:44.428]  elements: ‘a’
[17:42:44.428]  length: 0 (resolved future 1)
[17:42:44.428] resolve() on list ... DONE
[17:42:44.428] - globals: [1] ‘a’
[17:42:44.428] Resolving futures part of globals (recursively) ... DONE
[17:42:44.429] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.429] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:44.429] - globals: [1] ‘a’
[17:42:44.429] 
[17:42:44.429] getGlobalsAndPackages() ... DONE
[17:42:44.429] run() for ‘Future’ ...
[17:42:44.429] - state: ‘created’
[17:42:44.430] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.430] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.430]   - Field: ‘label’
[17:42:44.430]   - Field: ‘local’
[17:42:44.430]   - Field: ‘owner’
[17:42:44.430]   - Field: ‘envir’
[17:42:44.430]   - Field: ‘packages’
[17:42:44.431]   - Field: ‘gc’
[17:42:44.431]   - Field: ‘conditions’
[17:42:44.431]   - Field: ‘expr’
[17:42:44.431]   - Field: ‘uuid’
[17:42:44.431]   - Field: ‘seed’
[17:42:44.431]   - Field: ‘version’
[17:42:44.431]   - Field: ‘result’
[17:42:44.431]   - Field: ‘asynchronous’
[17:42:44.431]   - Field: ‘calls’
[17:42:44.431]   - Field: ‘globals’
[17:42:44.432]   - Field: ‘stdout’
[17:42:44.432]   - Field: ‘earlySignal’
[17:42:44.432]   - Field: ‘lazy’
[17:42:44.432]   - Field: ‘state’
[17:42:44.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.434] - Launch lazy future ...
[17:42:44.434] Packages needed by the future expression (n = 0): <none>
[17:42:44.434] Packages needed by future strategies (n = 0): <none>
[17:42:44.434] {
[17:42:44.434]     {
[17:42:44.434]         {
[17:42:44.434]             ...future.startTime <- base::Sys.time()
[17:42:44.434]             {
[17:42:44.434]                 {
[17:42:44.434]                   {
[17:42:44.434]                     base::local({
[17:42:44.434]                       has_future <- base::requireNamespace("future", 
[17:42:44.434]                         quietly = TRUE)
[17:42:44.434]                       if (has_future) {
[17:42:44.434]                         ns <- base::getNamespace("future")
[17:42:44.434]                         version <- ns[[".package"]][["version"]]
[17:42:44.434]                         if (is.null(version)) 
[17:42:44.434]                           version <- utils::packageVersion("future")
[17:42:44.434]                       }
[17:42:44.434]                       else {
[17:42:44.434]                         version <- NULL
[17:42:44.434]                       }
[17:42:44.434]                       if (!has_future || version < "1.8.0") {
[17:42:44.434]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.434]                           "", base::R.version$version.string), 
[17:42:44.434]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.434]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.434]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.434]                             "release", "version")], collapse = " "), 
[17:42:44.434]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.434]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.434]                           info)
[17:42:44.434]                         info <- base::paste(info, collapse = "; ")
[17:42:44.434]                         if (!has_future) {
[17:42:44.434]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.434]                             info)
[17:42:44.434]                         }
[17:42:44.434]                         else {
[17:42:44.434]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.434]                             info, version)
[17:42:44.434]                         }
[17:42:44.434]                         base::stop(msg)
[17:42:44.434]                       }
[17:42:44.434]                     })
[17:42:44.434]                   }
[17:42:44.434]                   options(future.plan = NULL)
[17:42:44.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.434]                 }
[17:42:44.434]                 ...future.workdir <- getwd()
[17:42:44.434]             }
[17:42:44.434]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.434]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.434]         }
[17:42:44.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.434]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.434]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.434]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.434]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.434]             base::names(...future.oldOptions))
[17:42:44.434]     }
[17:42:44.434]     if (FALSE) {
[17:42:44.434]     }
[17:42:44.434]     else {
[17:42:44.434]         if (TRUE) {
[17:42:44.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.434]                 open = "w")
[17:42:44.434]         }
[17:42:44.434]         else {
[17:42:44.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.434]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.434]         }
[17:42:44.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.434]             base::sink(type = "output", split = FALSE)
[17:42:44.434]             base::close(...future.stdout)
[17:42:44.434]         }, add = TRUE)
[17:42:44.434]     }
[17:42:44.434]     ...future.frame <- base::sys.nframe()
[17:42:44.434]     ...future.conditions <- base::list()
[17:42:44.434]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.434]     if (FALSE) {
[17:42:44.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.434]     }
[17:42:44.434]     ...future.result <- base::tryCatch({
[17:42:44.434]         base::withCallingHandlers({
[17:42:44.434]             ...future.value <- base::withVisible(base::local({
[17:42:44.434]                 b <- a
[17:42:44.434]                 a <- 2
[17:42:44.434]                 a * b
[17:42:44.434]             }))
[17:42:44.434]             future::FutureResult(value = ...future.value$value, 
[17:42:44.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.434]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.434]                     ...future.globalenv.names))
[17:42:44.434]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.434]         }, condition = base::local({
[17:42:44.434]             c <- base::c
[17:42:44.434]             inherits <- base::inherits
[17:42:44.434]             invokeRestart <- base::invokeRestart
[17:42:44.434]             length <- base::length
[17:42:44.434]             list <- base::list
[17:42:44.434]             seq.int <- base::seq.int
[17:42:44.434]             signalCondition <- base::signalCondition
[17:42:44.434]             sys.calls <- base::sys.calls
[17:42:44.434]             `[[` <- base::`[[`
[17:42:44.434]             `+` <- base::`+`
[17:42:44.434]             `<<-` <- base::`<<-`
[17:42:44.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.434]                   3L)]
[17:42:44.434]             }
[17:42:44.434]             function(cond) {
[17:42:44.434]                 is_error <- inherits(cond, "error")
[17:42:44.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.434]                   NULL)
[17:42:44.434]                 if (is_error) {
[17:42:44.434]                   sessionInformation <- function() {
[17:42:44.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.434]                       search = base::search(), system = base::Sys.info())
[17:42:44.434]                   }
[17:42:44.434]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.434]                     cond$call), session = sessionInformation(), 
[17:42:44.434]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.434]                   signalCondition(cond)
[17:42:44.434]                 }
[17:42:44.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.434]                 "immediateCondition"))) {
[17:42:44.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.434]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.434]                   if (TRUE && !signal) {
[17:42:44.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.434]                     {
[17:42:44.434]                       inherits <- base::inherits
[17:42:44.434]                       invokeRestart <- base::invokeRestart
[17:42:44.434]                       is.null <- base::is.null
[17:42:44.434]                       muffled <- FALSE
[17:42:44.434]                       if (inherits(cond, "message")) {
[17:42:44.434]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.434]                         if (muffled) 
[17:42:44.434]                           invokeRestart("muffleMessage")
[17:42:44.434]                       }
[17:42:44.434]                       else if (inherits(cond, "warning")) {
[17:42:44.434]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.434]                         if (muffled) 
[17:42:44.434]                           invokeRestart("muffleWarning")
[17:42:44.434]                       }
[17:42:44.434]                       else if (inherits(cond, "condition")) {
[17:42:44.434]                         if (!is.null(pattern)) {
[17:42:44.434]                           computeRestarts <- base::computeRestarts
[17:42:44.434]                           grepl <- base::grepl
[17:42:44.434]                           restarts <- computeRestarts(cond)
[17:42:44.434]                           for (restart in restarts) {
[17:42:44.434]                             name <- restart$name
[17:42:44.434]                             if (is.null(name)) 
[17:42:44.434]                               next
[17:42:44.434]                             if (!grepl(pattern, name)) 
[17:42:44.434]                               next
[17:42:44.434]                             invokeRestart(restart)
[17:42:44.434]                             muffled <- TRUE
[17:42:44.434]                             break
[17:42:44.434]                           }
[17:42:44.434]                         }
[17:42:44.434]                       }
[17:42:44.434]                       invisible(muffled)
[17:42:44.434]                     }
[17:42:44.434]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.434]                   }
[17:42:44.434]                 }
[17:42:44.434]                 else {
[17:42:44.434]                   if (TRUE) {
[17:42:44.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.434]                     {
[17:42:44.434]                       inherits <- base::inherits
[17:42:44.434]                       invokeRestart <- base::invokeRestart
[17:42:44.434]                       is.null <- base::is.null
[17:42:44.434]                       muffled <- FALSE
[17:42:44.434]                       if (inherits(cond, "message")) {
[17:42:44.434]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.434]                         if (muffled) 
[17:42:44.434]                           invokeRestart("muffleMessage")
[17:42:44.434]                       }
[17:42:44.434]                       else if (inherits(cond, "warning")) {
[17:42:44.434]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.434]                         if (muffled) 
[17:42:44.434]                           invokeRestart("muffleWarning")
[17:42:44.434]                       }
[17:42:44.434]                       else if (inherits(cond, "condition")) {
[17:42:44.434]                         if (!is.null(pattern)) {
[17:42:44.434]                           computeRestarts <- base::computeRestarts
[17:42:44.434]                           grepl <- base::grepl
[17:42:44.434]                           restarts <- computeRestarts(cond)
[17:42:44.434]                           for (restart in restarts) {
[17:42:44.434]                             name <- restart$name
[17:42:44.434]                             if (is.null(name)) 
[17:42:44.434]                               next
[17:42:44.434]                             if (!grepl(pattern, name)) 
[17:42:44.434]                               next
[17:42:44.434]                             invokeRestart(restart)
[17:42:44.434]                             muffled <- TRUE
[17:42:44.434]                             break
[17:42:44.434]                           }
[17:42:44.434]                         }
[17:42:44.434]                       }
[17:42:44.434]                       invisible(muffled)
[17:42:44.434]                     }
[17:42:44.434]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.434]                   }
[17:42:44.434]                 }
[17:42:44.434]             }
[17:42:44.434]         }))
[17:42:44.434]     }, error = function(ex) {
[17:42:44.434]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.434]                 ...future.rng), started = ...future.startTime, 
[17:42:44.434]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.434]             version = "1.8"), class = "FutureResult")
[17:42:44.434]     }, finally = {
[17:42:44.434]         if (!identical(...future.workdir, getwd())) 
[17:42:44.434]             setwd(...future.workdir)
[17:42:44.434]         {
[17:42:44.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.434]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.434]             }
[17:42:44.434]             base::options(...future.oldOptions)
[17:42:44.434]             if (.Platform$OS.type == "windows") {
[17:42:44.434]                 old_names <- names(...future.oldEnvVars)
[17:42:44.434]                 envs <- base::Sys.getenv()
[17:42:44.434]                 names <- names(envs)
[17:42:44.434]                 common <- intersect(names, old_names)
[17:42:44.434]                 added <- setdiff(names, old_names)
[17:42:44.434]                 removed <- setdiff(old_names, names)
[17:42:44.434]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.434]                   envs[common]]
[17:42:44.434]                 NAMES <- toupper(changed)
[17:42:44.434]                 args <- list()
[17:42:44.434]                 for (kk in seq_along(NAMES)) {
[17:42:44.434]                   name <- changed[[kk]]
[17:42:44.434]                   NAME <- NAMES[[kk]]
[17:42:44.434]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.434]                     next
[17:42:44.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.434]                 }
[17:42:44.434]                 NAMES <- toupper(added)
[17:42:44.434]                 for (kk in seq_along(NAMES)) {
[17:42:44.434]                   name <- added[[kk]]
[17:42:44.434]                   NAME <- NAMES[[kk]]
[17:42:44.434]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.434]                     next
[17:42:44.434]                   args[[name]] <- ""
[17:42:44.434]                 }
[17:42:44.434]                 NAMES <- toupper(removed)
[17:42:44.434]                 for (kk in seq_along(NAMES)) {
[17:42:44.434]                   name <- removed[[kk]]
[17:42:44.434]                   NAME <- NAMES[[kk]]
[17:42:44.434]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.434]                     next
[17:42:44.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.434]                 }
[17:42:44.434]                 if (length(args) > 0) 
[17:42:44.434]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.434]             }
[17:42:44.434]             else {
[17:42:44.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.434]             }
[17:42:44.434]             {
[17:42:44.434]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.434]                   0L) {
[17:42:44.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.434]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.434]                   base::options(opts)
[17:42:44.434]                 }
[17:42:44.434]                 {
[17:42:44.434]                   {
[17:42:44.434]                     NULL
[17:42:44.434]                     RNGkind("Mersenne-Twister")
[17:42:44.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.434]                       inherits = FALSE)
[17:42:44.434]                   }
[17:42:44.434]                   options(future.plan = NULL)
[17:42:44.434]                   if (is.na(NA_character_)) 
[17:42:44.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.434]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.434]                   {
[17:42:44.434]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.434]                     if (!future$lazy) 
[17:42:44.434]                       future <- run(future)
[17:42:44.434]                     invisible(future)
[17:42:44.434]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.434]                 }
[17:42:44.434]             }
[17:42:44.434]         }
[17:42:44.434]     })
[17:42:44.434]     if (TRUE) {
[17:42:44.434]         base::sink(type = "output", split = FALSE)
[17:42:44.434]         if (TRUE) {
[17:42:44.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.434]         }
[17:42:44.434]         else {
[17:42:44.434]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.434]         }
[17:42:44.434]         base::close(...future.stdout)
[17:42:44.434]         ...future.stdout <- NULL
[17:42:44.434]     }
[17:42:44.434]     ...future.result$conditions <- ...future.conditions
[17:42:44.434]     ...future.result$finished <- base::Sys.time()
[17:42:44.434]     ...future.result
[17:42:44.434] }
[17:42:44.436] assign_globals() ...
[17:42:44.436] List of 1
[17:42:44.436]  $ a: num 3
[17:42:44.436]  - attr(*, "where")=List of 1
[17:42:44.436]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.436]  - attr(*, "resolved")= logi TRUE
[17:42:44.436]  - attr(*, "total_size")= num 56
[17:42:44.436]  - attr(*, "already-done")= logi TRUE
[17:42:44.439] - copied ‘a’ to environment
[17:42:44.439] assign_globals() ... done
[17:42:44.439] plan(): Setting new future strategy stack:
[17:42:44.439] List of future strategies:
[17:42:44.439] 1. sequential:
[17:42:44.439]    - args: function (..., envir = parent.frame())
[17:42:44.439]    - tweaked: FALSE
[17:42:44.439]    - call: NULL
[17:42:44.439] plan(): nbrOfWorkers() = 1
[17:42:44.440] plan(): Setting new future strategy stack:
[17:42:44.440] List of future strategies:
[17:42:44.440] 1. sequential:
[17:42:44.440]    - args: function (..., envir = parent.frame())
[17:42:44.440]    - tweaked: FALSE
[17:42:44.440]    - call: plan(strategy)
[17:42:44.441] plan(): nbrOfWorkers() = 1
[17:42:44.441] SequentialFuture started (and completed)
[17:42:44.441] - Launch lazy future ... done
[17:42:44.441] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.441] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.442] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.444] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:44.444] Searching for globals ... DONE
[17:42:44.444] Resolving globals: TRUE
[17:42:44.444] Resolving any globals that are futures ...
[17:42:44.444] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:44.444] Resolving any globals that are futures ... DONE
[17:42:44.445] Resolving futures part of globals (recursively) ...
[17:42:44.445] resolve() on list ...
[17:42:44.445]  recursive: 99
[17:42:44.445]  length: 1
[17:42:44.445]  elements: ‘a’
[17:42:44.445]  length: 0 (resolved future 1)
[17:42:44.445] resolve() on list ... DONE
[17:42:44.445] - globals: [1] ‘a’
[17:42:44.445] Resolving futures part of globals (recursively) ... DONE
[17:42:44.446] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.446] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:44.446] - globals: [1] ‘a’
[17:42:44.446] 
[17:42:44.446] getGlobalsAndPackages() ... DONE
[17:42:44.447] run() for ‘Future’ ...
[17:42:44.447] - state: ‘created’
[17:42:44.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.447] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.447]   - Field: ‘label’
[17:42:44.447]   - Field: ‘local’
[17:42:44.448]   - Field: ‘owner’
[17:42:44.448]   - Field: ‘envir’
[17:42:44.448]   - Field: ‘packages’
[17:42:44.448]   - Field: ‘gc’
[17:42:44.448]   - Field: ‘conditions’
[17:42:44.448]   - Field: ‘expr’
[17:42:44.448]   - Field: ‘uuid’
[17:42:44.448]   - Field: ‘seed’
[17:42:44.448]   - Field: ‘version’
[17:42:44.448]   - Field: ‘result’
[17:42:44.448]   - Field: ‘asynchronous’
[17:42:44.449]   - Field: ‘calls’
[17:42:44.449]   - Field: ‘globals’
[17:42:44.449]   - Field: ‘stdout’
[17:42:44.449]   - Field: ‘earlySignal’
[17:42:44.449]   - Field: ‘lazy’
[17:42:44.449]   - Field: ‘state’
[17:42:44.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.449] - Launch lazy future ...
[17:42:44.449] Packages needed by the future expression (n = 0): <none>
[17:42:44.449] Packages needed by future strategies (n = 0): <none>
[17:42:44.450] {
[17:42:44.450]     {
[17:42:44.450]         {
[17:42:44.450]             ...future.startTime <- base::Sys.time()
[17:42:44.450]             {
[17:42:44.450]                 {
[17:42:44.450]                   {
[17:42:44.450]                     base::local({
[17:42:44.450]                       has_future <- base::requireNamespace("future", 
[17:42:44.450]                         quietly = TRUE)
[17:42:44.450]                       if (has_future) {
[17:42:44.450]                         ns <- base::getNamespace("future")
[17:42:44.450]                         version <- ns[[".package"]][["version"]]
[17:42:44.450]                         if (is.null(version)) 
[17:42:44.450]                           version <- utils::packageVersion("future")
[17:42:44.450]                       }
[17:42:44.450]                       else {
[17:42:44.450]                         version <- NULL
[17:42:44.450]                       }
[17:42:44.450]                       if (!has_future || version < "1.8.0") {
[17:42:44.450]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.450]                           "", base::R.version$version.string), 
[17:42:44.450]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.450]                             "release", "version")], collapse = " "), 
[17:42:44.450]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.450]                           info)
[17:42:44.450]                         info <- base::paste(info, collapse = "; ")
[17:42:44.450]                         if (!has_future) {
[17:42:44.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.450]                             info)
[17:42:44.450]                         }
[17:42:44.450]                         else {
[17:42:44.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.450]                             info, version)
[17:42:44.450]                         }
[17:42:44.450]                         base::stop(msg)
[17:42:44.450]                       }
[17:42:44.450]                     })
[17:42:44.450]                   }
[17:42:44.450]                   options(future.plan = NULL)
[17:42:44.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.450]                 }
[17:42:44.450]                 ...future.workdir <- getwd()
[17:42:44.450]             }
[17:42:44.450]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.450]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.450]         }
[17:42:44.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.450]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.450]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.450]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.450]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.450]             base::names(...future.oldOptions))
[17:42:44.450]     }
[17:42:44.450]     if (FALSE) {
[17:42:44.450]     }
[17:42:44.450]     else {
[17:42:44.450]         if (TRUE) {
[17:42:44.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.450]                 open = "w")
[17:42:44.450]         }
[17:42:44.450]         else {
[17:42:44.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.450]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.450]         }
[17:42:44.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.450]             base::sink(type = "output", split = FALSE)
[17:42:44.450]             base::close(...future.stdout)
[17:42:44.450]         }, add = TRUE)
[17:42:44.450]     }
[17:42:44.450]     ...future.frame <- base::sys.nframe()
[17:42:44.450]     ...future.conditions <- base::list()
[17:42:44.450]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.450]     if (FALSE) {
[17:42:44.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.450]     }
[17:42:44.450]     ...future.result <- base::tryCatch({
[17:42:44.450]         base::withCallingHandlers({
[17:42:44.450]             ...future.value <- base::withVisible(base::local({
[17:42:44.450]                 b <- a
[17:42:44.450]                 a <- 2
[17:42:44.450]                 a * b
[17:42:44.450]             }))
[17:42:44.450]             future::FutureResult(value = ...future.value$value, 
[17:42:44.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.450]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.450]                     ...future.globalenv.names))
[17:42:44.450]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.450]         }, condition = base::local({
[17:42:44.450]             c <- base::c
[17:42:44.450]             inherits <- base::inherits
[17:42:44.450]             invokeRestart <- base::invokeRestart
[17:42:44.450]             length <- base::length
[17:42:44.450]             list <- base::list
[17:42:44.450]             seq.int <- base::seq.int
[17:42:44.450]             signalCondition <- base::signalCondition
[17:42:44.450]             sys.calls <- base::sys.calls
[17:42:44.450]             `[[` <- base::`[[`
[17:42:44.450]             `+` <- base::`+`
[17:42:44.450]             `<<-` <- base::`<<-`
[17:42:44.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.450]                   3L)]
[17:42:44.450]             }
[17:42:44.450]             function(cond) {
[17:42:44.450]                 is_error <- inherits(cond, "error")
[17:42:44.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.450]                   NULL)
[17:42:44.450]                 if (is_error) {
[17:42:44.450]                   sessionInformation <- function() {
[17:42:44.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.450]                       search = base::search(), system = base::Sys.info())
[17:42:44.450]                   }
[17:42:44.450]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.450]                     cond$call), session = sessionInformation(), 
[17:42:44.450]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.450]                   signalCondition(cond)
[17:42:44.450]                 }
[17:42:44.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.450]                 "immediateCondition"))) {
[17:42:44.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.450]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.450]                   if (TRUE && !signal) {
[17:42:44.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.450]                     {
[17:42:44.450]                       inherits <- base::inherits
[17:42:44.450]                       invokeRestart <- base::invokeRestart
[17:42:44.450]                       is.null <- base::is.null
[17:42:44.450]                       muffled <- FALSE
[17:42:44.450]                       if (inherits(cond, "message")) {
[17:42:44.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.450]                         if (muffled) 
[17:42:44.450]                           invokeRestart("muffleMessage")
[17:42:44.450]                       }
[17:42:44.450]                       else if (inherits(cond, "warning")) {
[17:42:44.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.450]                         if (muffled) 
[17:42:44.450]                           invokeRestart("muffleWarning")
[17:42:44.450]                       }
[17:42:44.450]                       else if (inherits(cond, "condition")) {
[17:42:44.450]                         if (!is.null(pattern)) {
[17:42:44.450]                           computeRestarts <- base::computeRestarts
[17:42:44.450]                           grepl <- base::grepl
[17:42:44.450]                           restarts <- computeRestarts(cond)
[17:42:44.450]                           for (restart in restarts) {
[17:42:44.450]                             name <- restart$name
[17:42:44.450]                             if (is.null(name)) 
[17:42:44.450]                               next
[17:42:44.450]                             if (!grepl(pattern, name)) 
[17:42:44.450]                               next
[17:42:44.450]                             invokeRestart(restart)
[17:42:44.450]                             muffled <- TRUE
[17:42:44.450]                             break
[17:42:44.450]                           }
[17:42:44.450]                         }
[17:42:44.450]                       }
[17:42:44.450]                       invisible(muffled)
[17:42:44.450]                     }
[17:42:44.450]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.450]                   }
[17:42:44.450]                 }
[17:42:44.450]                 else {
[17:42:44.450]                   if (TRUE) {
[17:42:44.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.450]                     {
[17:42:44.450]                       inherits <- base::inherits
[17:42:44.450]                       invokeRestart <- base::invokeRestart
[17:42:44.450]                       is.null <- base::is.null
[17:42:44.450]                       muffled <- FALSE
[17:42:44.450]                       if (inherits(cond, "message")) {
[17:42:44.450]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.450]                         if (muffled) 
[17:42:44.450]                           invokeRestart("muffleMessage")
[17:42:44.450]                       }
[17:42:44.450]                       else if (inherits(cond, "warning")) {
[17:42:44.450]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.450]                         if (muffled) 
[17:42:44.450]                           invokeRestart("muffleWarning")
[17:42:44.450]                       }
[17:42:44.450]                       else if (inherits(cond, "condition")) {
[17:42:44.450]                         if (!is.null(pattern)) {
[17:42:44.450]                           computeRestarts <- base::computeRestarts
[17:42:44.450]                           grepl <- base::grepl
[17:42:44.450]                           restarts <- computeRestarts(cond)
[17:42:44.450]                           for (restart in restarts) {
[17:42:44.450]                             name <- restart$name
[17:42:44.450]                             if (is.null(name)) 
[17:42:44.450]                               next
[17:42:44.450]                             if (!grepl(pattern, name)) 
[17:42:44.450]                               next
[17:42:44.450]                             invokeRestart(restart)
[17:42:44.450]                             muffled <- TRUE
[17:42:44.450]                             break
[17:42:44.450]                           }
[17:42:44.450]                         }
[17:42:44.450]                       }
[17:42:44.450]                       invisible(muffled)
[17:42:44.450]                     }
[17:42:44.450]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.450]                   }
[17:42:44.450]                 }
[17:42:44.450]             }
[17:42:44.450]         }))
[17:42:44.450]     }, error = function(ex) {
[17:42:44.450]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.450]                 ...future.rng), started = ...future.startTime, 
[17:42:44.450]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.450]             version = "1.8"), class = "FutureResult")
[17:42:44.450]     }, finally = {
[17:42:44.450]         if (!identical(...future.workdir, getwd())) 
[17:42:44.450]             setwd(...future.workdir)
[17:42:44.450]         {
[17:42:44.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.450]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.450]             }
[17:42:44.450]             base::options(...future.oldOptions)
[17:42:44.450]             if (.Platform$OS.type == "windows") {
[17:42:44.450]                 old_names <- names(...future.oldEnvVars)
[17:42:44.450]                 envs <- base::Sys.getenv()
[17:42:44.450]                 names <- names(envs)
[17:42:44.450]                 common <- intersect(names, old_names)
[17:42:44.450]                 added <- setdiff(names, old_names)
[17:42:44.450]                 removed <- setdiff(old_names, names)
[17:42:44.450]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.450]                   envs[common]]
[17:42:44.450]                 NAMES <- toupper(changed)
[17:42:44.450]                 args <- list()
[17:42:44.450]                 for (kk in seq_along(NAMES)) {
[17:42:44.450]                   name <- changed[[kk]]
[17:42:44.450]                   NAME <- NAMES[[kk]]
[17:42:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.450]                     next
[17:42:44.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.450]                 }
[17:42:44.450]                 NAMES <- toupper(added)
[17:42:44.450]                 for (kk in seq_along(NAMES)) {
[17:42:44.450]                   name <- added[[kk]]
[17:42:44.450]                   NAME <- NAMES[[kk]]
[17:42:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.450]                     next
[17:42:44.450]                   args[[name]] <- ""
[17:42:44.450]                 }
[17:42:44.450]                 NAMES <- toupper(removed)
[17:42:44.450]                 for (kk in seq_along(NAMES)) {
[17:42:44.450]                   name <- removed[[kk]]
[17:42:44.450]                   NAME <- NAMES[[kk]]
[17:42:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.450]                     next
[17:42:44.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.450]                 }
[17:42:44.450]                 if (length(args) > 0) 
[17:42:44.450]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.450]             }
[17:42:44.450]             else {
[17:42:44.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.450]             }
[17:42:44.450]             {
[17:42:44.450]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.450]                   0L) {
[17:42:44.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.450]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.450]                   base::options(opts)
[17:42:44.450]                 }
[17:42:44.450]                 {
[17:42:44.450]                   {
[17:42:44.450]                     NULL
[17:42:44.450]                     RNGkind("Mersenne-Twister")
[17:42:44.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.450]                       inherits = FALSE)
[17:42:44.450]                   }
[17:42:44.450]                   options(future.plan = NULL)
[17:42:44.450]                   if (is.na(NA_character_)) 
[17:42:44.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.450]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.450]                   {
[17:42:44.450]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.450]                     if (!future$lazy) 
[17:42:44.450]                       future <- run(future)
[17:42:44.450]                     invisible(future)
[17:42:44.450]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.450]                 }
[17:42:44.450]             }
[17:42:44.450]         }
[17:42:44.450]     })
[17:42:44.450]     if (TRUE) {
[17:42:44.450]         base::sink(type = "output", split = FALSE)
[17:42:44.450]         if (TRUE) {
[17:42:44.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.450]         }
[17:42:44.450]         else {
[17:42:44.450]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.450]         }
[17:42:44.450]         base::close(...future.stdout)
[17:42:44.450]         ...future.stdout <- NULL
[17:42:44.450]     }
[17:42:44.450]     ...future.result$conditions <- ...future.conditions
[17:42:44.450]     ...future.result$finished <- base::Sys.time()
[17:42:44.450]     ...future.result
[17:42:44.450] }
[17:42:44.452] assign_globals() ...
[17:42:44.452] List of 1
[17:42:44.452]  $ a: num 3
[17:42:44.452]  - attr(*, "where")=List of 1
[17:42:44.452]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.452]  - attr(*, "resolved")= logi TRUE
[17:42:44.452]  - attr(*, "total_size")= num 56
[17:42:44.452]  - attr(*, "already-done")= logi TRUE
[17:42:44.454] - copied ‘a’ to environment
[17:42:44.454] assign_globals() ... done
[17:42:44.455] plan(): Setting new future strategy stack:
[17:42:44.455] List of future strategies:
[17:42:44.455] 1. sequential:
[17:42:44.455]    - args: function (..., envir = parent.frame())
[17:42:44.455]    - tweaked: FALSE
[17:42:44.455]    - call: NULL
[17:42:44.455] plan(): nbrOfWorkers() = 1
[17:42:44.456] plan(): Setting new future strategy stack:
[17:42:44.456] List of future strategies:
[17:42:44.456] 1. sequential:
[17:42:44.456]    - args: function (..., envir = parent.frame())
[17:42:44.456]    - tweaked: FALSE
[17:42:44.456]    - call: plan(strategy)
[17:42:44.456] plan(): nbrOfWorkers() = 1
[17:42:44.456] SequentialFuture started (and completed)
[17:42:44.456] - Launch lazy future ... done
[17:42:44.457] run() for ‘SequentialFuture’ ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.457] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.457] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.461] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.461] Searching for globals ... DONE
[17:42:44.461] Resolving globals: TRUE
[17:42:44.461] Resolving any globals that are futures ...
[17:42:44.461] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.462] Resolving any globals that are futures ... DONE
[17:42:44.462] Resolving futures part of globals (recursively) ...
[17:42:44.462] resolve() on list ...
[17:42:44.462]  recursive: 99
[17:42:44.462]  length: 2
[17:42:44.462]  elements: ‘a’, ‘ii’
[17:42:44.463]  length: 1 (resolved future 1)
[17:42:44.463]  length: 0 (resolved future 2)
[17:42:44.463] resolve() on list ... DONE
[17:42:44.463] - globals: [2] ‘a’, ‘ii’
[17:42:44.463] Resolving futures part of globals (recursively) ... DONE
[17:42:44.463] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:44.464] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.464] - globals: [2] ‘a’, ‘ii’
[17:42:44.464] 
[17:42:44.464] getGlobalsAndPackages() ... DONE
[17:42:44.464] run() for ‘Future’ ...
[17:42:44.464] - state: ‘created’
[17:42:44.464] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.465]   - Field: ‘label’
[17:42:44.465]   - Field: ‘local’
[17:42:44.465]   - Field: ‘owner’
[17:42:44.465]   - Field: ‘envir’
[17:42:44.465]   - Field: ‘packages’
[17:42:44.465]   - Field: ‘gc’
[17:42:44.465]   - Field: ‘conditions’
[17:42:44.465]   - Field: ‘expr’
[17:42:44.466]   - Field: ‘uuid’
[17:42:44.466]   - Field: ‘seed’
[17:42:44.466]   - Field: ‘version’
[17:42:44.466]   - Field: ‘result’
[17:42:44.466]   - Field: ‘asynchronous’
[17:42:44.466]   - Field: ‘calls’
[17:42:44.466]   - Field: ‘globals’
[17:42:44.466]   - Field: ‘stdout’
[17:42:44.466]   - Field: ‘earlySignal’
[17:42:44.466]   - Field: ‘lazy’
[17:42:44.466]   - Field: ‘state’
[17:42:44.467] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.467] - Launch lazy future ...
[17:42:44.467] Packages needed by the future expression (n = 0): <none>
[17:42:44.467] Packages needed by future strategies (n = 0): <none>
[17:42:44.467] {
[17:42:44.467]     {
[17:42:44.467]         {
[17:42:44.467]             ...future.startTime <- base::Sys.time()
[17:42:44.467]             {
[17:42:44.467]                 {
[17:42:44.467]                   {
[17:42:44.467]                     base::local({
[17:42:44.467]                       has_future <- base::requireNamespace("future", 
[17:42:44.467]                         quietly = TRUE)
[17:42:44.467]                       if (has_future) {
[17:42:44.467]                         ns <- base::getNamespace("future")
[17:42:44.467]                         version <- ns[[".package"]][["version"]]
[17:42:44.467]                         if (is.null(version)) 
[17:42:44.467]                           version <- utils::packageVersion("future")
[17:42:44.467]                       }
[17:42:44.467]                       else {
[17:42:44.467]                         version <- NULL
[17:42:44.467]                       }
[17:42:44.467]                       if (!has_future || version < "1.8.0") {
[17:42:44.467]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.467]                           "", base::R.version$version.string), 
[17:42:44.467]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.467]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.467]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.467]                             "release", "version")], collapse = " "), 
[17:42:44.467]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.467]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.467]                           info)
[17:42:44.467]                         info <- base::paste(info, collapse = "; ")
[17:42:44.467]                         if (!has_future) {
[17:42:44.467]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.467]                             info)
[17:42:44.467]                         }
[17:42:44.467]                         else {
[17:42:44.467]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.467]                             info, version)
[17:42:44.467]                         }
[17:42:44.467]                         base::stop(msg)
[17:42:44.467]                       }
[17:42:44.467]                     })
[17:42:44.467]                   }
[17:42:44.467]                   options(future.plan = NULL)
[17:42:44.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.467]                 }
[17:42:44.467]                 ...future.workdir <- getwd()
[17:42:44.467]             }
[17:42:44.467]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.467]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.467]         }
[17:42:44.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.467]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.467]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.467]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.467]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.467]             base::names(...future.oldOptions))
[17:42:44.467]     }
[17:42:44.467]     if (FALSE) {
[17:42:44.467]     }
[17:42:44.467]     else {
[17:42:44.467]         if (TRUE) {
[17:42:44.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.467]                 open = "w")
[17:42:44.467]         }
[17:42:44.467]         else {
[17:42:44.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.467]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.467]         }
[17:42:44.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.467]             base::sink(type = "output", split = FALSE)
[17:42:44.467]             base::close(...future.stdout)
[17:42:44.467]         }, add = TRUE)
[17:42:44.467]     }
[17:42:44.467]     ...future.frame <- base::sys.nframe()
[17:42:44.467]     ...future.conditions <- base::list()
[17:42:44.467]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.467]     if (FALSE) {
[17:42:44.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.467]     }
[17:42:44.467]     ...future.result <- base::tryCatch({
[17:42:44.467]         base::withCallingHandlers({
[17:42:44.467]             ...future.value <- base::withVisible(base::local({
[17:42:44.467]                 b <- a * ii
[17:42:44.467]                 a <- 0
[17:42:44.467]                 b
[17:42:44.467]             }))
[17:42:44.467]             future::FutureResult(value = ...future.value$value, 
[17:42:44.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.467]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.467]                     ...future.globalenv.names))
[17:42:44.467]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.467]         }, condition = base::local({
[17:42:44.467]             c <- base::c
[17:42:44.467]             inherits <- base::inherits
[17:42:44.467]             invokeRestart <- base::invokeRestart
[17:42:44.467]             length <- base::length
[17:42:44.467]             list <- base::list
[17:42:44.467]             seq.int <- base::seq.int
[17:42:44.467]             signalCondition <- base::signalCondition
[17:42:44.467]             sys.calls <- base::sys.calls
[17:42:44.467]             `[[` <- base::`[[`
[17:42:44.467]             `+` <- base::`+`
[17:42:44.467]             `<<-` <- base::`<<-`
[17:42:44.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.467]                   3L)]
[17:42:44.467]             }
[17:42:44.467]             function(cond) {
[17:42:44.467]                 is_error <- inherits(cond, "error")
[17:42:44.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.467]                   NULL)
[17:42:44.467]                 if (is_error) {
[17:42:44.467]                   sessionInformation <- function() {
[17:42:44.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.467]                       search = base::search(), system = base::Sys.info())
[17:42:44.467]                   }
[17:42:44.467]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.467]                     cond$call), session = sessionInformation(), 
[17:42:44.467]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.467]                   signalCondition(cond)
[17:42:44.467]                 }
[17:42:44.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.467]                 "immediateCondition"))) {
[17:42:44.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.467]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.467]                   if (TRUE && !signal) {
[17:42:44.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.467]                     {
[17:42:44.467]                       inherits <- base::inherits
[17:42:44.467]                       invokeRestart <- base::invokeRestart
[17:42:44.467]                       is.null <- base::is.null
[17:42:44.467]                       muffled <- FALSE
[17:42:44.467]                       if (inherits(cond, "message")) {
[17:42:44.467]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.467]                         if (muffled) 
[17:42:44.467]                           invokeRestart("muffleMessage")
[17:42:44.467]                       }
[17:42:44.467]                       else if (inherits(cond, "warning")) {
[17:42:44.467]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.467]                         if (muffled) 
[17:42:44.467]                           invokeRestart("muffleWarning")
[17:42:44.467]                       }
[17:42:44.467]                       else if (inherits(cond, "condition")) {
[17:42:44.467]                         if (!is.null(pattern)) {
[17:42:44.467]                           computeRestarts <- base::computeRestarts
[17:42:44.467]                           grepl <- base::grepl
[17:42:44.467]                           restarts <- computeRestarts(cond)
[17:42:44.467]                           for (restart in restarts) {
[17:42:44.467]                             name <- restart$name
[17:42:44.467]                             if (is.null(name)) 
[17:42:44.467]                               next
[17:42:44.467]                             if (!grepl(pattern, name)) 
[17:42:44.467]                               next
[17:42:44.467]                             invokeRestart(restart)
[17:42:44.467]                             muffled <- TRUE
[17:42:44.467]                             break
[17:42:44.467]                           }
[17:42:44.467]                         }
[17:42:44.467]                       }
[17:42:44.467]                       invisible(muffled)
[17:42:44.467]                     }
[17:42:44.467]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.467]                   }
[17:42:44.467]                 }
[17:42:44.467]                 else {
[17:42:44.467]                   if (TRUE) {
[17:42:44.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.467]                     {
[17:42:44.467]                       inherits <- base::inherits
[17:42:44.467]                       invokeRestart <- base::invokeRestart
[17:42:44.467]                       is.null <- base::is.null
[17:42:44.467]                       muffled <- FALSE
[17:42:44.467]                       if (inherits(cond, "message")) {
[17:42:44.467]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.467]                         if (muffled) 
[17:42:44.467]                           invokeRestart("muffleMessage")
[17:42:44.467]                       }
[17:42:44.467]                       else if (inherits(cond, "warning")) {
[17:42:44.467]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.467]                         if (muffled) 
[17:42:44.467]                           invokeRestart("muffleWarning")
[17:42:44.467]                       }
[17:42:44.467]                       else if (inherits(cond, "condition")) {
[17:42:44.467]                         if (!is.null(pattern)) {
[17:42:44.467]                           computeRestarts <- base::computeRestarts
[17:42:44.467]                           grepl <- base::grepl
[17:42:44.467]                           restarts <- computeRestarts(cond)
[17:42:44.467]                           for (restart in restarts) {
[17:42:44.467]                             name <- restart$name
[17:42:44.467]                             if (is.null(name)) 
[17:42:44.467]                               next
[17:42:44.467]                             if (!grepl(pattern, name)) 
[17:42:44.467]                               next
[17:42:44.467]                             invokeRestart(restart)
[17:42:44.467]                             muffled <- TRUE
[17:42:44.467]                             break
[17:42:44.467]                           }
[17:42:44.467]                         }
[17:42:44.467]                       }
[17:42:44.467]                       invisible(muffled)
[17:42:44.467]                     }
[17:42:44.467]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.467]                   }
[17:42:44.467]                 }
[17:42:44.467]             }
[17:42:44.467]         }))
[17:42:44.467]     }, error = function(ex) {
[17:42:44.467]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.467]                 ...future.rng), started = ...future.startTime, 
[17:42:44.467]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.467]             version = "1.8"), class = "FutureResult")
[17:42:44.467]     }, finally = {
[17:42:44.467]         if (!identical(...future.workdir, getwd())) 
[17:42:44.467]             setwd(...future.workdir)
[17:42:44.467]         {
[17:42:44.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.467]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.467]             }
[17:42:44.467]             base::options(...future.oldOptions)
[17:42:44.467]             if (.Platform$OS.type == "windows") {
[17:42:44.467]                 old_names <- names(...future.oldEnvVars)
[17:42:44.467]                 envs <- base::Sys.getenv()
[17:42:44.467]                 names <- names(envs)
[17:42:44.467]                 common <- intersect(names, old_names)
[17:42:44.467]                 added <- setdiff(names, old_names)
[17:42:44.467]                 removed <- setdiff(old_names, names)
[17:42:44.467]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.467]                   envs[common]]
[17:42:44.467]                 NAMES <- toupper(changed)
[17:42:44.467]                 args <- list()
[17:42:44.467]                 for (kk in seq_along(NAMES)) {
[17:42:44.467]                   name <- changed[[kk]]
[17:42:44.467]                   NAME <- NAMES[[kk]]
[17:42:44.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.467]                     next
[17:42:44.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.467]                 }
[17:42:44.467]                 NAMES <- toupper(added)
[17:42:44.467]                 for (kk in seq_along(NAMES)) {
[17:42:44.467]                   name <- added[[kk]]
[17:42:44.467]                   NAME <- NAMES[[kk]]
[17:42:44.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.467]                     next
[17:42:44.467]                   args[[name]] <- ""
[17:42:44.467]                 }
[17:42:44.467]                 NAMES <- toupper(removed)
[17:42:44.467]                 for (kk in seq_along(NAMES)) {
[17:42:44.467]                   name <- removed[[kk]]
[17:42:44.467]                   NAME <- NAMES[[kk]]
[17:42:44.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.467]                     next
[17:42:44.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.467]                 }
[17:42:44.467]                 if (length(args) > 0) 
[17:42:44.467]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.467]             }
[17:42:44.467]             else {
[17:42:44.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.467]             }
[17:42:44.467]             {
[17:42:44.467]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.467]                   0L) {
[17:42:44.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.467]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.467]                   base::options(opts)
[17:42:44.467]                 }
[17:42:44.467]                 {
[17:42:44.467]                   {
[17:42:44.467]                     NULL
[17:42:44.467]                     RNGkind("Mersenne-Twister")
[17:42:44.467]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.467]                       inherits = FALSE)
[17:42:44.467]                   }
[17:42:44.467]                   options(future.plan = NULL)
[17:42:44.467]                   if (is.na(NA_character_)) 
[17:42:44.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.467]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.467]                   {
[17:42:44.467]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.467]                     if (!future$lazy) 
[17:42:44.467]                       future <- run(future)
[17:42:44.467]                     invisible(future)
[17:42:44.467]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.467]                 }
[17:42:44.467]             }
[17:42:44.467]         }
[17:42:44.467]     })
[17:42:44.467]     if (TRUE) {
[17:42:44.467]         base::sink(type = "output", split = FALSE)
[17:42:44.467]         if (TRUE) {
[17:42:44.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.467]         }
[17:42:44.467]         else {
[17:42:44.467]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.467]         }
[17:42:44.467]         base::close(...future.stdout)
[17:42:44.467]         ...future.stdout <- NULL
[17:42:44.467]     }
[17:42:44.467]     ...future.result$conditions <- ...future.conditions
[17:42:44.467]     ...future.result$finished <- base::Sys.time()
[17:42:44.467]     ...future.result
[17:42:44.467] }
[17:42:44.469] assign_globals() ...
[17:42:44.469] List of 2
[17:42:44.469]  $ a : num 1
[17:42:44.469]  $ ii: int 1
[17:42:44.469]  - attr(*, "where")=List of 2
[17:42:44.469]   ..$ a :<environment: R_EmptyEnv> 
[17:42:44.469]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.469]  - attr(*, "resolved")= logi TRUE
[17:42:44.469]  - attr(*, "total_size")= num 112
[17:42:44.469]  - attr(*, "already-done")= logi TRUE
[17:42:44.472] - copied ‘a’ to environment
[17:42:44.473] - copied ‘ii’ to environment
[17:42:44.473] assign_globals() ... done
[17:42:44.473] plan(): Setting new future strategy stack:
[17:42:44.473] List of future strategies:
[17:42:44.473] 1. sequential:
[17:42:44.473]    - args: function (..., envir = parent.frame())
[17:42:44.473]    - tweaked: FALSE
[17:42:44.473]    - call: NULL
[17:42:44.473] plan(): nbrOfWorkers() = 1
[17:42:44.474] plan(): Setting new future strategy stack:
[17:42:44.474] List of future strategies:
[17:42:44.474] 1. sequential:
[17:42:44.474]    - args: function (..., envir = parent.frame())
[17:42:44.474]    - tweaked: FALSE
[17:42:44.474]    - call: plan(strategy)
[17:42:44.475] plan(): nbrOfWorkers() = 1
[17:42:44.475] SequentialFuture started (and completed)
[17:42:44.475] - Launch lazy future ... done
[17:42:44.475] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.476] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.476] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.478] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.478] Searching for globals ... DONE
[17:42:44.478] Resolving globals: TRUE
[17:42:44.478] Resolving any globals that are futures ...
[17:42:44.478] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.478] Resolving any globals that are futures ... DONE
[17:42:44.479] Resolving futures part of globals (recursively) ...
[17:42:44.479] resolve() on list ...
[17:42:44.479]  recursive: 99
[17:42:44.479]  length: 2
[17:42:44.479]  elements: ‘a’, ‘ii’
[17:42:44.479]  length: 1 (resolved future 1)
[17:42:44.479]  length: 0 (resolved future 2)
[17:42:44.480] resolve() on list ... DONE
[17:42:44.480] - globals: [2] ‘a’, ‘ii’
[17:42:44.480] Resolving futures part of globals (recursively) ... DONE
[17:42:44.480] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:44.480] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.480] - globals: [2] ‘a’, ‘ii’
[17:42:44.481] 
[17:42:44.481] getGlobalsAndPackages() ... DONE
[17:42:44.481] run() for ‘Future’ ...
[17:42:44.481] - state: ‘created’
[17:42:44.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.482]   - Field: ‘label’
[17:42:44.482]   - Field: ‘local’
[17:42:44.482]   - Field: ‘owner’
[17:42:44.482]   - Field: ‘envir’
[17:42:44.482]   - Field: ‘packages’
[17:42:44.482]   - Field: ‘gc’
[17:42:44.482]   - Field: ‘conditions’
[17:42:44.482]   - Field: ‘expr’
[17:42:44.482]   - Field: ‘uuid’
[17:42:44.482]   - Field: ‘seed’
[17:42:44.483]   - Field: ‘version’
[17:42:44.483]   - Field: ‘result’
[17:42:44.483]   - Field: ‘asynchronous’
[17:42:44.483]   - Field: ‘calls’
[17:42:44.483]   - Field: ‘globals’
[17:42:44.483]   - Field: ‘stdout’
[17:42:44.483]   - Field: ‘earlySignal’
[17:42:44.483]   - Field: ‘lazy’
[17:42:44.483]   - Field: ‘state’
[17:42:44.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.484] - Launch lazy future ...
[17:42:44.484] Packages needed by the future expression (n = 0): <none>
[17:42:44.484] Packages needed by future strategies (n = 0): <none>
[17:42:44.484] {
[17:42:44.484]     {
[17:42:44.484]         {
[17:42:44.484]             ...future.startTime <- base::Sys.time()
[17:42:44.484]             {
[17:42:44.484]                 {
[17:42:44.484]                   {
[17:42:44.484]                     base::local({
[17:42:44.484]                       has_future <- base::requireNamespace("future", 
[17:42:44.484]                         quietly = TRUE)
[17:42:44.484]                       if (has_future) {
[17:42:44.484]                         ns <- base::getNamespace("future")
[17:42:44.484]                         version <- ns[[".package"]][["version"]]
[17:42:44.484]                         if (is.null(version)) 
[17:42:44.484]                           version <- utils::packageVersion("future")
[17:42:44.484]                       }
[17:42:44.484]                       else {
[17:42:44.484]                         version <- NULL
[17:42:44.484]                       }
[17:42:44.484]                       if (!has_future || version < "1.8.0") {
[17:42:44.484]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.484]                           "", base::R.version$version.string), 
[17:42:44.484]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.484]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.484]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.484]                             "release", "version")], collapse = " "), 
[17:42:44.484]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.484]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.484]                           info)
[17:42:44.484]                         info <- base::paste(info, collapse = "; ")
[17:42:44.484]                         if (!has_future) {
[17:42:44.484]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.484]                             info)
[17:42:44.484]                         }
[17:42:44.484]                         else {
[17:42:44.484]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.484]                             info, version)
[17:42:44.484]                         }
[17:42:44.484]                         base::stop(msg)
[17:42:44.484]                       }
[17:42:44.484]                     })
[17:42:44.484]                   }
[17:42:44.484]                   options(future.plan = NULL)
[17:42:44.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.484]                 }
[17:42:44.484]                 ...future.workdir <- getwd()
[17:42:44.484]             }
[17:42:44.484]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.484]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.484]         }
[17:42:44.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.484]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.484]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.484]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.484]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.484]             base::names(...future.oldOptions))
[17:42:44.484]     }
[17:42:44.484]     if (FALSE) {
[17:42:44.484]     }
[17:42:44.484]     else {
[17:42:44.484]         if (TRUE) {
[17:42:44.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.484]                 open = "w")
[17:42:44.484]         }
[17:42:44.484]         else {
[17:42:44.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.484]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.484]         }
[17:42:44.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.484]             base::sink(type = "output", split = FALSE)
[17:42:44.484]             base::close(...future.stdout)
[17:42:44.484]         }, add = TRUE)
[17:42:44.484]     }
[17:42:44.484]     ...future.frame <- base::sys.nframe()
[17:42:44.484]     ...future.conditions <- base::list()
[17:42:44.484]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.484]     if (FALSE) {
[17:42:44.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.484]     }
[17:42:44.484]     ...future.result <- base::tryCatch({
[17:42:44.484]         base::withCallingHandlers({
[17:42:44.484]             ...future.value <- base::withVisible(base::local({
[17:42:44.484]                 b <- a * ii
[17:42:44.484]                 a <- 0
[17:42:44.484]                 b
[17:42:44.484]             }))
[17:42:44.484]             future::FutureResult(value = ...future.value$value, 
[17:42:44.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.484]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.484]                     ...future.globalenv.names))
[17:42:44.484]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.484]         }, condition = base::local({
[17:42:44.484]             c <- base::c
[17:42:44.484]             inherits <- base::inherits
[17:42:44.484]             invokeRestart <- base::invokeRestart
[17:42:44.484]             length <- base::length
[17:42:44.484]             list <- base::list
[17:42:44.484]             seq.int <- base::seq.int
[17:42:44.484]             signalCondition <- base::signalCondition
[17:42:44.484]             sys.calls <- base::sys.calls
[17:42:44.484]             `[[` <- base::`[[`
[17:42:44.484]             `+` <- base::`+`
[17:42:44.484]             `<<-` <- base::`<<-`
[17:42:44.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.484]                   3L)]
[17:42:44.484]             }
[17:42:44.484]             function(cond) {
[17:42:44.484]                 is_error <- inherits(cond, "error")
[17:42:44.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.484]                   NULL)
[17:42:44.484]                 if (is_error) {
[17:42:44.484]                   sessionInformation <- function() {
[17:42:44.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.484]                       search = base::search(), system = base::Sys.info())
[17:42:44.484]                   }
[17:42:44.484]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.484]                     cond$call), session = sessionInformation(), 
[17:42:44.484]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.484]                   signalCondition(cond)
[17:42:44.484]                 }
[17:42:44.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.484]                 "immediateCondition"))) {
[17:42:44.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.484]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.484]                   if (TRUE && !signal) {
[17:42:44.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.484]                     {
[17:42:44.484]                       inherits <- base::inherits
[17:42:44.484]                       invokeRestart <- base::invokeRestart
[17:42:44.484]                       is.null <- base::is.null
[17:42:44.484]                       muffled <- FALSE
[17:42:44.484]                       if (inherits(cond, "message")) {
[17:42:44.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.484]                         if (muffled) 
[17:42:44.484]                           invokeRestart("muffleMessage")
[17:42:44.484]                       }
[17:42:44.484]                       else if (inherits(cond, "warning")) {
[17:42:44.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.484]                         if (muffled) 
[17:42:44.484]                           invokeRestart("muffleWarning")
[17:42:44.484]                       }
[17:42:44.484]                       else if (inherits(cond, "condition")) {
[17:42:44.484]                         if (!is.null(pattern)) {
[17:42:44.484]                           computeRestarts <- base::computeRestarts
[17:42:44.484]                           grepl <- base::grepl
[17:42:44.484]                           restarts <- computeRestarts(cond)
[17:42:44.484]                           for (restart in restarts) {
[17:42:44.484]                             name <- restart$name
[17:42:44.484]                             if (is.null(name)) 
[17:42:44.484]                               next
[17:42:44.484]                             if (!grepl(pattern, name)) 
[17:42:44.484]                               next
[17:42:44.484]                             invokeRestart(restart)
[17:42:44.484]                             muffled <- TRUE
[17:42:44.484]                             break
[17:42:44.484]                           }
[17:42:44.484]                         }
[17:42:44.484]                       }
[17:42:44.484]                       invisible(muffled)
[17:42:44.484]                     }
[17:42:44.484]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.484]                   }
[17:42:44.484]                 }
[17:42:44.484]                 else {
[17:42:44.484]                   if (TRUE) {
[17:42:44.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.484]                     {
[17:42:44.484]                       inherits <- base::inherits
[17:42:44.484]                       invokeRestart <- base::invokeRestart
[17:42:44.484]                       is.null <- base::is.null
[17:42:44.484]                       muffled <- FALSE
[17:42:44.484]                       if (inherits(cond, "message")) {
[17:42:44.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.484]                         if (muffled) 
[17:42:44.484]                           invokeRestart("muffleMessage")
[17:42:44.484]                       }
[17:42:44.484]                       else if (inherits(cond, "warning")) {
[17:42:44.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.484]                         if (muffled) 
[17:42:44.484]                           invokeRestart("muffleWarning")
[17:42:44.484]                       }
[17:42:44.484]                       else if (inherits(cond, "condition")) {
[17:42:44.484]                         if (!is.null(pattern)) {
[17:42:44.484]                           computeRestarts <- base::computeRestarts
[17:42:44.484]                           grepl <- base::grepl
[17:42:44.484]                           restarts <- computeRestarts(cond)
[17:42:44.484]                           for (restart in restarts) {
[17:42:44.484]                             name <- restart$name
[17:42:44.484]                             if (is.null(name)) 
[17:42:44.484]                               next
[17:42:44.484]                             if (!grepl(pattern, name)) 
[17:42:44.484]                               next
[17:42:44.484]                             invokeRestart(restart)
[17:42:44.484]                             muffled <- TRUE
[17:42:44.484]                             break
[17:42:44.484]                           }
[17:42:44.484]                         }
[17:42:44.484]                       }
[17:42:44.484]                       invisible(muffled)
[17:42:44.484]                     }
[17:42:44.484]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.484]                   }
[17:42:44.484]                 }
[17:42:44.484]             }
[17:42:44.484]         }))
[17:42:44.484]     }, error = function(ex) {
[17:42:44.484]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.484]                 ...future.rng), started = ...future.startTime, 
[17:42:44.484]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.484]             version = "1.8"), class = "FutureResult")
[17:42:44.484]     }, finally = {
[17:42:44.484]         if (!identical(...future.workdir, getwd())) 
[17:42:44.484]             setwd(...future.workdir)
[17:42:44.484]         {
[17:42:44.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.484]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.484]             }
[17:42:44.484]             base::options(...future.oldOptions)
[17:42:44.484]             if (.Platform$OS.type == "windows") {
[17:42:44.484]                 old_names <- names(...future.oldEnvVars)
[17:42:44.484]                 envs <- base::Sys.getenv()
[17:42:44.484]                 names <- names(envs)
[17:42:44.484]                 common <- intersect(names, old_names)
[17:42:44.484]                 added <- setdiff(names, old_names)
[17:42:44.484]                 removed <- setdiff(old_names, names)
[17:42:44.484]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.484]                   envs[common]]
[17:42:44.484]                 NAMES <- toupper(changed)
[17:42:44.484]                 args <- list()
[17:42:44.484]                 for (kk in seq_along(NAMES)) {
[17:42:44.484]                   name <- changed[[kk]]
[17:42:44.484]                   NAME <- NAMES[[kk]]
[17:42:44.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.484]                     next
[17:42:44.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.484]                 }
[17:42:44.484]                 NAMES <- toupper(added)
[17:42:44.484]                 for (kk in seq_along(NAMES)) {
[17:42:44.484]                   name <- added[[kk]]
[17:42:44.484]                   NAME <- NAMES[[kk]]
[17:42:44.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.484]                     next
[17:42:44.484]                   args[[name]] <- ""
[17:42:44.484]                 }
[17:42:44.484]                 NAMES <- toupper(removed)
[17:42:44.484]                 for (kk in seq_along(NAMES)) {
[17:42:44.484]                   name <- removed[[kk]]
[17:42:44.484]                   NAME <- NAMES[[kk]]
[17:42:44.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.484]                     next
[17:42:44.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.484]                 }
[17:42:44.484]                 if (length(args) > 0) 
[17:42:44.484]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.484]             }
[17:42:44.484]             else {
[17:42:44.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.484]             }
[17:42:44.484]             {
[17:42:44.484]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.484]                   0L) {
[17:42:44.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.484]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.484]                   base::options(opts)
[17:42:44.484]                 }
[17:42:44.484]                 {
[17:42:44.484]                   {
[17:42:44.484]                     NULL
[17:42:44.484]                     RNGkind("Mersenne-Twister")
[17:42:44.484]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.484]                       inherits = FALSE)
[17:42:44.484]                   }
[17:42:44.484]                   options(future.plan = NULL)
[17:42:44.484]                   if (is.na(NA_character_)) 
[17:42:44.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.484]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.484]                   {
[17:42:44.484]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.484]                     if (!future$lazy) 
[17:42:44.484]                       future <- run(future)
[17:42:44.484]                     invisible(future)
[17:42:44.484]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.484]                 }
[17:42:44.484]             }
[17:42:44.484]         }
[17:42:44.484]     })
[17:42:44.484]     if (TRUE) {
[17:42:44.484]         base::sink(type = "output", split = FALSE)
[17:42:44.484]         if (TRUE) {
[17:42:44.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.484]         }
[17:42:44.484]         else {
[17:42:44.484]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.484]         }
[17:42:44.484]         base::close(...future.stdout)
[17:42:44.484]         ...future.stdout <- NULL
[17:42:44.484]     }
[17:42:44.484]     ...future.result$conditions <- ...future.conditions
[17:42:44.484]     ...future.result$finished <- base::Sys.time()
[17:42:44.484]     ...future.result
[17:42:44.484] }
[17:42:44.488] assign_globals() ...
[17:42:44.488] List of 2
[17:42:44.488]  $ a : num 1
[17:42:44.488]  $ ii: int 2
[17:42:44.488]  - attr(*, "where")=List of 2
[17:42:44.488]   ..$ a :<environment: R_EmptyEnv> 
[17:42:44.488]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.488]  - attr(*, "resolved")= logi TRUE
[17:42:44.488]  - attr(*, "total_size")= num 112
[17:42:44.488]  - attr(*, "already-done")= logi TRUE
[17:42:44.491] - copied ‘a’ to environment
[17:42:44.492] - copied ‘ii’ to environment
[17:42:44.492] assign_globals() ... done
[17:42:44.492] plan(): Setting new future strategy stack:
[17:42:44.492] List of future strategies:
[17:42:44.492] 1. sequential:
[17:42:44.492]    - args: function (..., envir = parent.frame())
[17:42:44.492]    - tweaked: FALSE
[17:42:44.492]    - call: NULL
[17:42:44.492] plan(): nbrOfWorkers() = 1
[17:42:44.493] plan(): Setting new future strategy stack:
[17:42:44.493] List of future strategies:
[17:42:44.493] 1. sequential:
[17:42:44.493]    - args: function (..., envir = parent.frame())
[17:42:44.493]    - tweaked: FALSE
[17:42:44.493]    - call: plan(strategy)
[17:42:44.494] plan(): nbrOfWorkers() = 1
[17:42:44.494] SequentialFuture started (and completed)
[17:42:44.494] - Launch lazy future ... done
[17:42:44.494] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.495] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.495] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.497] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.497] Searching for globals ... DONE
[17:42:44.497] Resolving globals: TRUE
[17:42:44.497] Resolving any globals that are futures ...
[17:42:44.497] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.497] Resolving any globals that are futures ... DONE
[17:42:44.497] Resolving futures part of globals (recursively) ...
[17:42:44.498] resolve() on list ...
[17:42:44.498]  recursive: 99
[17:42:44.498]  length: 2
[17:42:44.498]  elements: ‘a’, ‘ii’
[17:42:44.498]  length: 1 (resolved future 1)
[17:42:44.498]  length: 0 (resolved future 2)
[17:42:44.498] resolve() on list ... DONE
[17:42:44.498] - globals: [2] ‘a’, ‘ii’
[17:42:44.498] Resolving futures part of globals (recursively) ... DONE
[17:42:44.499] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:44.499] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.499] - globals: [2] ‘a’, ‘ii’
[17:42:44.499] 
[17:42:44.499] getGlobalsAndPackages() ... DONE
[17:42:44.500] run() for ‘Future’ ...
[17:42:44.500] - state: ‘created’
[17:42:44.500] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.500] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.500]   - Field: ‘label’
[17:42:44.501]   - Field: ‘local’
[17:42:44.501]   - Field: ‘owner’
[17:42:44.501]   - Field: ‘envir’
[17:42:44.501]   - Field: ‘packages’
[17:42:44.501]   - Field: ‘gc’
[17:42:44.501]   - Field: ‘conditions’
[17:42:44.501]   - Field: ‘expr’
[17:42:44.501]   - Field: ‘uuid’
[17:42:44.501]   - Field: ‘seed’
[17:42:44.502]   - Field: ‘version’
[17:42:44.502]   - Field: ‘result’
[17:42:44.502]   - Field: ‘asynchronous’
[17:42:44.502]   - Field: ‘calls’
[17:42:44.502]   - Field: ‘globals’
[17:42:44.502]   - Field: ‘stdout’
[17:42:44.502]   - Field: ‘earlySignal’
[17:42:44.502]   - Field: ‘lazy’
[17:42:44.502]   - Field: ‘state’
[17:42:44.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.502] - Launch lazy future ...
[17:42:44.503] Packages needed by the future expression (n = 0): <none>
[17:42:44.503] Packages needed by future strategies (n = 0): <none>
[17:42:44.503] {
[17:42:44.503]     {
[17:42:44.503]         {
[17:42:44.503]             ...future.startTime <- base::Sys.time()
[17:42:44.503]             {
[17:42:44.503]                 {
[17:42:44.503]                   {
[17:42:44.503]                     base::local({
[17:42:44.503]                       has_future <- base::requireNamespace("future", 
[17:42:44.503]                         quietly = TRUE)
[17:42:44.503]                       if (has_future) {
[17:42:44.503]                         ns <- base::getNamespace("future")
[17:42:44.503]                         version <- ns[[".package"]][["version"]]
[17:42:44.503]                         if (is.null(version)) 
[17:42:44.503]                           version <- utils::packageVersion("future")
[17:42:44.503]                       }
[17:42:44.503]                       else {
[17:42:44.503]                         version <- NULL
[17:42:44.503]                       }
[17:42:44.503]                       if (!has_future || version < "1.8.0") {
[17:42:44.503]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.503]                           "", base::R.version$version.string), 
[17:42:44.503]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.503]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.503]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.503]                             "release", "version")], collapse = " "), 
[17:42:44.503]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.503]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.503]                           info)
[17:42:44.503]                         info <- base::paste(info, collapse = "; ")
[17:42:44.503]                         if (!has_future) {
[17:42:44.503]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.503]                             info)
[17:42:44.503]                         }
[17:42:44.503]                         else {
[17:42:44.503]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.503]                             info, version)
[17:42:44.503]                         }
[17:42:44.503]                         base::stop(msg)
[17:42:44.503]                       }
[17:42:44.503]                     })
[17:42:44.503]                   }
[17:42:44.503]                   options(future.plan = NULL)
[17:42:44.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.503]                 }
[17:42:44.503]                 ...future.workdir <- getwd()
[17:42:44.503]             }
[17:42:44.503]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.503]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.503]         }
[17:42:44.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.503]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.503]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.503]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.503]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.503]             base::names(...future.oldOptions))
[17:42:44.503]     }
[17:42:44.503]     if (FALSE) {
[17:42:44.503]     }
[17:42:44.503]     else {
[17:42:44.503]         if (TRUE) {
[17:42:44.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.503]                 open = "w")
[17:42:44.503]         }
[17:42:44.503]         else {
[17:42:44.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.503]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.503]         }
[17:42:44.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.503]             base::sink(type = "output", split = FALSE)
[17:42:44.503]             base::close(...future.stdout)
[17:42:44.503]         }, add = TRUE)
[17:42:44.503]     }
[17:42:44.503]     ...future.frame <- base::sys.nframe()
[17:42:44.503]     ...future.conditions <- base::list()
[17:42:44.503]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.503]     if (FALSE) {
[17:42:44.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.503]     }
[17:42:44.503]     ...future.result <- base::tryCatch({
[17:42:44.503]         base::withCallingHandlers({
[17:42:44.503]             ...future.value <- base::withVisible(base::local({
[17:42:44.503]                 b <- a * ii
[17:42:44.503]                 a <- 0
[17:42:44.503]                 b
[17:42:44.503]             }))
[17:42:44.503]             future::FutureResult(value = ...future.value$value, 
[17:42:44.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.503]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.503]                     ...future.globalenv.names))
[17:42:44.503]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.503]         }, condition = base::local({
[17:42:44.503]             c <- base::c
[17:42:44.503]             inherits <- base::inherits
[17:42:44.503]             invokeRestart <- base::invokeRestart
[17:42:44.503]             length <- base::length
[17:42:44.503]             list <- base::list
[17:42:44.503]             seq.int <- base::seq.int
[17:42:44.503]             signalCondition <- base::signalCondition
[17:42:44.503]             sys.calls <- base::sys.calls
[17:42:44.503]             `[[` <- base::`[[`
[17:42:44.503]             `+` <- base::`+`
[17:42:44.503]             `<<-` <- base::`<<-`
[17:42:44.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.503]                   3L)]
[17:42:44.503]             }
[17:42:44.503]             function(cond) {
[17:42:44.503]                 is_error <- inherits(cond, "error")
[17:42:44.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.503]                   NULL)
[17:42:44.503]                 if (is_error) {
[17:42:44.503]                   sessionInformation <- function() {
[17:42:44.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.503]                       search = base::search(), system = base::Sys.info())
[17:42:44.503]                   }
[17:42:44.503]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.503]                     cond$call), session = sessionInformation(), 
[17:42:44.503]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.503]                   signalCondition(cond)
[17:42:44.503]                 }
[17:42:44.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.503]                 "immediateCondition"))) {
[17:42:44.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.503]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.503]                   if (TRUE && !signal) {
[17:42:44.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.503]                     {
[17:42:44.503]                       inherits <- base::inherits
[17:42:44.503]                       invokeRestart <- base::invokeRestart
[17:42:44.503]                       is.null <- base::is.null
[17:42:44.503]                       muffled <- FALSE
[17:42:44.503]                       if (inherits(cond, "message")) {
[17:42:44.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.503]                         if (muffled) 
[17:42:44.503]                           invokeRestart("muffleMessage")
[17:42:44.503]                       }
[17:42:44.503]                       else if (inherits(cond, "warning")) {
[17:42:44.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.503]                         if (muffled) 
[17:42:44.503]                           invokeRestart("muffleWarning")
[17:42:44.503]                       }
[17:42:44.503]                       else if (inherits(cond, "condition")) {
[17:42:44.503]                         if (!is.null(pattern)) {
[17:42:44.503]                           computeRestarts <- base::computeRestarts
[17:42:44.503]                           grepl <- base::grepl
[17:42:44.503]                           restarts <- computeRestarts(cond)
[17:42:44.503]                           for (restart in restarts) {
[17:42:44.503]                             name <- restart$name
[17:42:44.503]                             if (is.null(name)) 
[17:42:44.503]                               next
[17:42:44.503]                             if (!grepl(pattern, name)) 
[17:42:44.503]                               next
[17:42:44.503]                             invokeRestart(restart)
[17:42:44.503]                             muffled <- TRUE
[17:42:44.503]                             break
[17:42:44.503]                           }
[17:42:44.503]                         }
[17:42:44.503]                       }
[17:42:44.503]                       invisible(muffled)
[17:42:44.503]                     }
[17:42:44.503]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.503]                   }
[17:42:44.503]                 }
[17:42:44.503]                 else {
[17:42:44.503]                   if (TRUE) {
[17:42:44.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.503]                     {
[17:42:44.503]                       inherits <- base::inherits
[17:42:44.503]                       invokeRestart <- base::invokeRestart
[17:42:44.503]                       is.null <- base::is.null
[17:42:44.503]                       muffled <- FALSE
[17:42:44.503]                       if (inherits(cond, "message")) {
[17:42:44.503]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.503]                         if (muffled) 
[17:42:44.503]                           invokeRestart("muffleMessage")
[17:42:44.503]                       }
[17:42:44.503]                       else if (inherits(cond, "warning")) {
[17:42:44.503]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.503]                         if (muffled) 
[17:42:44.503]                           invokeRestart("muffleWarning")
[17:42:44.503]                       }
[17:42:44.503]                       else if (inherits(cond, "condition")) {
[17:42:44.503]                         if (!is.null(pattern)) {
[17:42:44.503]                           computeRestarts <- base::computeRestarts
[17:42:44.503]                           grepl <- base::grepl
[17:42:44.503]                           restarts <- computeRestarts(cond)
[17:42:44.503]                           for (restart in restarts) {
[17:42:44.503]                             name <- restart$name
[17:42:44.503]                             if (is.null(name)) 
[17:42:44.503]                               next
[17:42:44.503]                             if (!grepl(pattern, name)) 
[17:42:44.503]                               next
[17:42:44.503]                             invokeRestart(restart)
[17:42:44.503]                             muffled <- TRUE
[17:42:44.503]                             break
[17:42:44.503]                           }
[17:42:44.503]                         }
[17:42:44.503]                       }
[17:42:44.503]                       invisible(muffled)
[17:42:44.503]                     }
[17:42:44.503]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.503]                   }
[17:42:44.503]                 }
[17:42:44.503]             }
[17:42:44.503]         }))
[17:42:44.503]     }, error = function(ex) {
[17:42:44.503]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.503]                 ...future.rng), started = ...future.startTime, 
[17:42:44.503]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.503]             version = "1.8"), class = "FutureResult")
[17:42:44.503]     }, finally = {
[17:42:44.503]         if (!identical(...future.workdir, getwd())) 
[17:42:44.503]             setwd(...future.workdir)
[17:42:44.503]         {
[17:42:44.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.503]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.503]             }
[17:42:44.503]             base::options(...future.oldOptions)
[17:42:44.503]             if (.Platform$OS.type == "windows") {
[17:42:44.503]                 old_names <- names(...future.oldEnvVars)
[17:42:44.503]                 envs <- base::Sys.getenv()
[17:42:44.503]                 names <- names(envs)
[17:42:44.503]                 common <- intersect(names, old_names)
[17:42:44.503]                 added <- setdiff(names, old_names)
[17:42:44.503]                 removed <- setdiff(old_names, names)
[17:42:44.503]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.503]                   envs[common]]
[17:42:44.503]                 NAMES <- toupper(changed)
[17:42:44.503]                 args <- list()
[17:42:44.503]                 for (kk in seq_along(NAMES)) {
[17:42:44.503]                   name <- changed[[kk]]
[17:42:44.503]                   NAME <- NAMES[[kk]]
[17:42:44.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.503]                     next
[17:42:44.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.503]                 }
[17:42:44.503]                 NAMES <- toupper(added)
[17:42:44.503]                 for (kk in seq_along(NAMES)) {
[17:42:44.503]                   name <- added[[kk]]
[17:42:44.503]                   NAME <- NAMES[[kk]]
[17:42:44.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.503]                     next
[17:42:44.503]                   args[[name]] <- ""
[17:42:44.503]                 }
[17:42:44.503]                 NAMES <- toupper(removed)
[17:42:44.503]                 for (kk in seq_along(NAMES)) {
[17:42:44.503]                   name <- removed[[kk]]
[17:42:44.503]                   NAME <- NAMES[[kk]]
[17:42:44.503]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.503]                     next
[17:42:44.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.503]                 }
[17:42:44.503]                 if (length(args) > 0) 
[17:42:44.503]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.503]             }
[17:42:44.503]             else {
[17:42:44.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.503]             }
[17:42:44.503]             {
[17:42:44.503]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.503]                   0L) {
[17:42:44.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.503]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.503]                   base::options(opts)
[17:42:44.503]                 }
[17:42:44.503]                 {
[17:42:44.503]                   {
[17:42:44.503]                     NULL
[17:42:44.503]                     RNGkind("Mersenne-Twister")
[17:42:44.503]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.503]                       inherits = FALSE)
[17:42:44.503]                   }
[17:42:44.503]                   options(future.plan = NULL)
[17:42:44.503]                   if (is.na(NA_character_)) 
[17:42:44.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.503]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.503]                   {
[17:42:44.503]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.503]                     if (!future$lazy) 
[17:42:44.503]                       future <- run(future)
[17:42:44.503]                     invisible(future)
[17:42:44.503]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.503]                 }
[17:42:44.503]             }
[17:42:44.503]         }
[17:42:44.503]     })
[17:42:44.503]     if (TRUE) {
[17:42:44.503]         base::sink(type = "output", split = FALSE)
[17:42:44.503]         if (TRUE) {
[17:42:44.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.503]         }
[17:42:44.503]         else {
[17:42:44.503]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.503]         }
[17:42:44.503]         base::close(...future.stdout)
[17:42:44.503]         ...future.stdout <- NULL
[17:42:44.503]     }
[17:42:44.503]     ...future.result$conditions <- ...future.conditions
[17:42:44.503]     ...future.result$finished <- base::Sys.time()
[17:42:44.503]     ...future.result
[17:42:44.503] }
[17:42:44.505] assign_globals() ...
[17:42:44.505] List of 2
[17:42:44.505]  $ a : num 1
[17:42:44.505]  $ ii: int 3
[17:42:44.505]  - attr(*, "where")=List of 2
[17:42:44.505]   ..$ a :<environment: R_EmptyEnv> 
[17:42:44.505]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.505]  - attr(*, "resolved")= logi TRUE
[17:42:44.505]  - attr(*, "total_size")= num 112
[17:42:44.505]  - attr(*, "already-done")= logi TRUE
[17:42:44.509] - copied ‘a’ to environment
[17:42:44.509] - copied ‘ii’ to environment
[17:42:44.509] assign_globals() ... done
[17:42:44.509] plan(): Setting new future strategy stack:
[17:42:44.509] List of future strategies:
[17:42:44.509] 1. sequential:
[17:42:44.509]    - args: function (..., envir = parent.frame())
[17:42:44.509]    - tweaked: FALSE
[17:42:44.509]    - call: NULL
[17:42:44.510] plan(): nbrOfWorkers() = 1
[17:42:44.510] plan(): Setting new future strategy stack:
[17:42:44.511] List of future strategies:
[17:42:44.511] 1. sequential:
[17:42:44.511]    - args: function (..., envir = parent.frame())
[17:42:44.511]    - tweaked: FALSE
[17:42:44.511]    - call: plan(strategy)
[17:42:44.511] plan(): nbrOfWorkers() = 1
[17:42:44.511] SequentialFuture started (and completed)
[17:42:44.511] - Launch lazy future ... done
[17:42:44.511] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.512] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.513] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.517] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.517] Searching for globals ... DONE
[17:42:44.517] Resolving globals: TRUE
[17:42:44.517] Resolving any globals that are futures ...
[17:42:44.517] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.517] Resolving any globals that are futures ... DONE
[17:42:44.518] Resolving futures part of globals (recursively) ...
[17:42:44.518] resolve() on list ...
[17:42:44.518]  recursive: 99
[17:42:44.518]  length: 2
[17:42:44.518]  elements: ‘a’, ‘ii’
[17:42:44.519]  length: 1 (resolved future 1)
[17:42:44.519]  length: 0 (resolved future 2)
[17:42:44.519] resolve() on list ... DONE
[17:42:44.519] - globals: [2] ‘a’, ‘ii’
[17:42:44.519] Resolving futures part of globals (recursively) ... DONE
[17:42:44.519] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:44.520] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.520] - globals: [2] ‘a’, ‘ii’
[17:42:44.520] 
[17:42:44.520] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.520] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.521] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.522] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.523] Searching for globals ... DONE
[17:42:44.523] Resolving globals: TRUE
[17:42:44.523] Resolving any globals that are futures ...
[17:42:44.523] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.523] Resolving any globals that are futures ... DONE
[17:42:44.523] Resolving futures part of globals (recursively) ...
[17:42:44.524] resolve() on list ...
[17:42:44.524]  recursive: 99
[17:42:44.524]  length: 2
[17:42:44.524]  elements: ‘a’, ‘ii’
[17:42:44.524]  length: 1 (resolved future 1)
[17:42:44.524]  length: 0 (resolved future 2)
[17:42:44.524] resolve() on list ... DONE
[17:42:44.524] - globals: [2] ‘a’, ‘ii’
[17:42:44.524] Resolving futures part of globals (recursively) ... DONE
[17:42:44.525] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:44.525] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.525] - globals: [2] ‘a’, ‘ii’
[17:42:44.525] 
[17:42:44.525] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.526] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.526] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.528] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.528] Searching for globals ... DONE
[17:42:44.528] Resolving globals: TRUE
[17:42:44.528] Resolving any globals that are futures ...
[17:42:44.528] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:44.528] Resolving any globals that are futures ... DONE
[17:42:44.529] Resolving futures part of globals (recursively) ...
[17:42:44.529] resolve() on list ...
[17:42:44.529]  recursive: 99
[17:42:44.529]  length: 2
[17:42:44.529]  elements: ‘a’, ‘ii’
[17:42:44.529]  length: 1 (resolved future 1)
[17:42:44.529]  length: 0 (resolved future 2)
[17:42:44.530] resolve() on list ... DONE
[17:42:44.530] - globals: [2] ‘a’, ‘ii’
[17:42:44.530] Resolving futures part of globals (recursively) ... DONE
[17:42:44.530] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:44.530] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.530] - globals: [2] ‘a’, ‘ii’
[17:42:44.530] 
[17:42:44.531] getGlobalsAndPackages() ... DONE
[17:42:44.531] run() for ‘Future’ ...
[17:42:44.531] - state: ‘created’
[17:42:44.531] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.531] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.532]   - Field: ‘label’
[17:42:44.532]   - Field: ‘local’
[17:42:44.532]   - Field: ‘owner’
[17:42:44.532]   - Field: ‘envir’
[17:42:44.532]   - Field: ‘packages’
[17:42:44.532]   - Field: ‘gc’
[17:42:44.532]   - Field: ‘conditions’
[17:42:44.532]   - Field: ‘expr’
[17:42:44.532]   - Field: ‘uuid’
[17:42:44.533]   - Field: ‘seed’
[17:42:44.533]   - Field: ‘version’
[17:42:44.533]   - Field: ‘result’
[17:42:44.533]   - Field: ‘asynchronous’
[17:42:44.533]   - Field: ‘calls’
[17:42:44.533]   - Field: ‘globals’
[17:42:44.533]   - Field: ‘stdout’
[17:42:44.533]   - Field: ‘earlySignal’
[17:42:44.533]   - Field: ‘lazy’
[17:42:44.533]   - Field: ‘state’
[17:42:44.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.534] - Launch lazy future ...
[17:42:44.534] Packages needed by the future expression (n = 0): <none>
[17:42:44.534] Packages needed by future strategies (n = 0): <none>
[17:42:44.534] {
[17:42:44.534]     {
[17:42:44.534]         {
[17:42:44.534]             ...future.startTime <- base::Sys.time()
[17:42:44.534]             {
[17:42:44.534]                 {
[17:42:44.534]                   {
[17:42:44.534]                     base::local({
[17:42:44.534]                       has_future <- base::requireNamespace("future", 
[17:42:44.534]                         quietly = TRUE)
[17:42:44.534]                       if (has_future) {
[17:42:44.534]                         ns <- base::getNamespace("future")
[17:42:44.534]                         version <- ns[[".package"]][["version"]]
[17:42:44.534]                         if (is.null(version)) 
[17:42:44.534]                           version <- utils::packageVersion("future")
[17:42:44.534]                       }
[17:42:44.534]                       else {
[17:42:44.534]                         version <- NULL
[17:42:44.534]                       }
[17:42:44.534]                       if (!has_future || version < "1.8.0") {
[17:42:44.534]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.534]                           "", base::R.version$version.string), 
[17:42:44.534]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.534]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.534]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.534]                             "release", "version")], collapse = " "), 
[17:42:44.534]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.534]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.534]                           info)
[17:42:44.534]                         info <- base::paste(info, collapse = "; ")
[17:42:44.534]                         if (!has_future) {
[17:42:44.534]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.534]                             info)
[17:42:44.534]                         }
[17:42:44.534]                         else {
[17:42:44.534]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.534]                             info, version)
[17:42:44.534]                         }
[17:42:44.534]                         base::stop(msg)
[17:42:44.534]                       }
[17:42:44.534]                     })
[17:42:44.534]                   }
[17:42:44.534]                   options(future.plan = NULL)
[17:42:44.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.534]                 }
[17:42:44.534]                 ...future.workdir <- getwd()
[17:42:44.534]             }
[17:42:44.534]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.534]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.534]         }
[17:42:44.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.534]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.534]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.534]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.534]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.534]             base::names(...future.oldOptions))
[17:42:44.534]     }
[17:42:44.534]     if (FALSE) {
[17:42:44.534]     }
[17:42:44.534]     else {
[17:42:44.534]         if (TRUE) {
[17:42:44.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.534]                 open = "w")
[17:42:44.534]         }
[17:42:44.534]         else {
[17:42:44.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.534]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.534]         }
[17:42:44.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.534]             base::sink(type = "output", split = FALSE)
[17:42:44.534]             base::close(...future.stdout)
[17:42:44.534]         }, add = TRUE)
[17:42:44.534]     }
[17:42:44.534]     ...future.frame <- base::sys.nframe()
[17:42:44.534]     ...future.conditions <- base::list()
[17:42:44.534]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.534]     if (FALSE) {
[17:42:44.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.534]     }
[17:42:44.534]     ...future.result <- base::tryCatch({
[17:42:44.534]         base::withCallingHandlers({
[17:42:44.534]             ...future.value <- base::withVisible(base::local({
[17:42:44.534]                 b <- a * ii
[17:42:44.534]                 a <- 0
[17:42:44.534]                 b
[17:42:44.534]             }))
[17:42:44.534]             future::FutureResult(value = ...future.value$value, 
[17:42:44.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.534]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.534]                     ...future.globalenv.names))
[17:42:44.534]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.534]         }, condition = base::local({
[17:42:44.534]             c <- base::c
[17:42:44.534]             inherits <- base::inherits
[17:42:44.534]             invokeRestart <- base::invokeRestart
[17:42:44.534]             length <- base::length
[17:42:44.534]             list <- base::list
[17:42:44.534]             seq.int <- base::seq.int
[17:42:44.534]             signalCondition <- base::signalCondition
[17:42:44.534]             sys.calls <- base::sys.calls
[17:42:44.534]             `[[` <- base::`[[`
[17:42:44.534]             `+` <- base::`+`
[17:42:44.534]             `<<-` <- base::`<<-`
[17:42:44.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.534]                   3L)]
[17:42:44.534]             }
[17:42:44.534]             function(cond) {
[17:42:44.534]                 is_error <- inherits(cond, "error")
[17:42:44.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.534]                   NULL)
[17:42:44.534]                 if (is_error) {
[17:42:44.534]                   sessionInformation <- function() {
[17:42:44.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.534]                       search = base::search(), system = base::Sys.info())
[17:42:44.534]                   }
[17:42:44.534]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.534]                     cond$call), session = sessionInformation(), 
[17:42:44.534]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.534]                   signalCondition(cond)
[17:42:44.534]                 }
[17:42:44.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.534]                 "immediateCondition"))) {
[17:42:44.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.534]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.534]                   if (TRUE && !signal) {
[17:42:44.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.534]                     {
[17:42:44.534]                       inherits <- base::inherits
[17:42:44.534]                       invokeRestart <- base::invokeRestart
[17:42:44.534]                       is.null <- base::is.null
[17:42:44.534]                       muffled <- FALSE
[17:42:44.534]                       if (inherits(cond, "message")) {
[17:42:44.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.534]                         if (muffled) 
[17:42:44.534]                           invokeRestart("muffleMessage")
[17:42:44.534]                       }
[17:42:44.534]                       else if (inherits(cond, "warning")) {
[17:42:44.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.534]                         if (muffled) 
[17:42:44.534]                           invokeRestart("muffleWarning")
[17:42:44.534]                       }
[17:42:44.534]                       else if (inherits(cond, "condition")) {
[17:42:44.534]                         if (!is.null(pattern)) {
[17:42:44.534]                           computeRestarts <- base::computeRestarts
[17:42:44.534]                           grepl <- base::grepl
[17:42:44.534]                           restarts <- computeRestarts(cond)
[17:42:44.534]                           for (restart in restarts) {
[17:42:44.534]                             name <- restart$name
[17:42:44.534]                             if (is.null(name)) 
[17:42:44.534]                               next
[17:42:44.534]                             if (!grepl(pattern, name)) 
[17:42:44.534]                               next
[17:42:44.534]                             invokeRestart(restart)
[17:42:44.534]                             muffled <- TRUE
[17:42:44.534]                             break
[17:42:44.534]                           }
[17:42:44.534]                         }
[17:42:44.534]                       }
[17:42:44.534]                       invisible(muffled)
[17:42:44.534]                     }
[17:42:44.534]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.534]                   }
[17:42:44.534]                 }
[17:42:44.534]                 else {
[17:42:44.534]                   if (TRUE) {
[17:42:44.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.534]                     {
[17:42:44.534]                       inherits <- base::inherits
[17:42:44.534]                       invokeRestart <- base::invokeRestart
[17:42:44.534]                       is.null <- base::is.null
[17:42:44.534]                       muffled <- FALSE
[17:42:44.534]                       if (inherits(cond, "message")) {
[17:42:44.534]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.534]                         if (muffled) 
[17:42:44.534]                           invokeRestart("muffleMessage")
[17:42:44.534]                       }
[17:42:44.534]                       else if (inherits(cond, "warning")) {
[17:42:44.534]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.534]                         if (muffled) 
[17:42:44.534]                           invokeRestart("muffleWarning")
[17:42:44.534]                       }
[17:42:44.534]                       else if (inherits(cond, "condition")) {
[17:42:44.534]                         if (!is.null(pattern)) {
[17:42:44.534]                           computeRestarts <- base::computeRestarts
[17:42:44.534]                           grepl <- base::grepl
[17:42:44.534]                           restarts <- computeRestarts(cond)
[17:42:44.534]                           for (restart in restarts) {
[17:42:44.534]                             name <- restart$name
[17:42:44.534]                             if (is.null(name)) 
[17:42:44.534]                               next
[17:42:44.534]                             if (!grepl(pattern, name)) 
[17:42:44.534]                               next
[17:42:44.534]                             invokeRestart(restart)
[17:42:44.534]                             muffled <- TRUE
[17:42:44.534]                             break
[17:42:44.534]                           }
[17:42:44.534]                         }
[17:42:44.534]                       }
[17:42:44.534]                       invisible(muffled)
[17:42:44.534]                     }
[17:42:44.534]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.534]                   }
[17:42:44.534]                 }
[17:42:44.534]             }
[17:42:44.534]         }))
[17:42:44.534]     }, error = function(ex) {
[17:42:44.534]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.534]                 ...future.rng), started = ...future.startTime, 
[17:42:44.534]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.534]             version = "1.8"), class = "FutureResult")
[17:42:44.534]     }, finally = {
[17:42:44.534]         if (!identical(...future.workdir, getwd())) 
[17:42:44.534]             setwd(...future.workdir)
[17:42:44.534]         {
[17:42:44.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.534]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.534]             }
[17:42:44.534]             base::options(...future.oldOptions)
[17:42:44.534]             if (.Platform$OS.type == "windows") {
[17:42:44.534]                 old_names <- names(...future.oldEnvVars)
[17:42:44.534]                 envs <- base::Sys.getenv()
[17:42:44.534]                 names <- names(envs)
[17:42:44.534]                 common <- intersect(names, old_names)
[17:42:44.534]                 added <- setdiff(names, old_names)
[17:42:44.534]                 removed <- setdiff(old_names, names)
[17:42:44.534]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.534]                   envs[common]]
[17:42:44.534]                 NAMES <- toupper(changed)
[17:42:44.534]                 args <- list()
[17:42:44.534]                 for (kk in seq_along(NAMES)) {
[17:42:44.534]                   name <- changed[[kk]]
[17:42:44.534]                   NAME <- NAMES[[kk]]
[17:42:44.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.534]                     next
[17:42:44.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.534]                 }
[17:42:44.534]                 NAMES <- toupper(added)
[17:42:44.534]                 for (kk in seq_along(NAMES)) {
[17:42:44.534]                   name <- added[[kk]]
[17:42:44.534]                   NAME <- NAMES[[kk]]
[17:42:44.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.534]                     next
[17:42:44.534]                   args[[name]] <- ""
[17:42:44.534]                 }
[17:42:44.534]                 NAMES <- toupper(removed)
[17:42:44.534]                 for (kk in seq_along(NAMES)) {
[17:42:44.534]                   name <- removed[[kk]]
[17:42:44.534]                   NAME <- NAMES[[kk]]
[17:42:44.534]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.534]                     next
[17:42:44.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.534]                 }
[17:42:44.534]                 if (length(args) > 0) 
[17:42:44.534]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.534]             }
[17:42:44.534]             else {
[17:42:44.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.534]             }
[17:42:44.534]             {
[17:42:44.534]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.534]                   0L) {
[17:42:44.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.534]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.534]                   base::options(opts)
[17:42:44.534]                 }
[17:42:44.534]                 {
[17:42:44.534]                   {
[17:42:44.534]                     NULL
[17:42:44.534]                     RNGkind("Mersenne-Twister")
[17:42:44.534]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.534]                       inherits = FALSE)
[17:42:44.534]                   }
[17:42:44.534]                   options(future.plan = NULL)
[17:42:44.534]                   if (is.na(NA_character_)) 
[17:42:44.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.534]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.534]                   {
[17:42:44.534]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.534]                     if (!future$lazy) 
[17:42:44.534]                       future <- run(future)
[17:42:44.534]                     invisible(future)
[17:42:44.534]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.534]                 }
[17:42:44.534]             }
[17:42:44.534]         }
[17:42:44.534]     })
[17:42:44.534]     if (TRUE) {
[17:42:44.534]         base::sink(type = "output", split = FALSE)
[17:42:44.534]         if (TRUE) {
[17:42:44.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.534]         }
[17:42:44.534]         else {
[17:42:44.534]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.534]         }
[17:42:44.534]         base::close(...future.stdout)
[17:42:44.534]         ...future.stdout <- NULL
[17:42:44.534]     }
[17:42:44.534]     ...future.result$conditions <- ...future.conditions
[17:42:44.534]     ...future.result$finished <- base::Sys.time()
[17:42:44.534]     ...future.result
[17:42:44.534] }
[17:42:44.536] assign_globals() ...
[17:42:44.536] List of 2
[17:42:44.536]  $ a : num 1
[17:42:44.536]  $ ii: int 1
[17:42:44.536]  - attr(*, "where")=List of 2
[17:42:44.536]   ..$ a :<environment: R_EmptyEnv> 
[17:42:44.536]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.536]  - attr(*, "resolved")= logi TRUE
[17:42:44.536]  - attr(*, "total_size")= num 112
[17:42:44.536]  - attr(*, "already-done")= logi TRUE
[17:42:44.542] - copied ‘a’ to environment
[17:42:44.542] - copied ‘ii’ to environment
[17:42:44.542] assign_globals() ... done
[17:42:44.542] plan(): Setting new future strategy stack:
[17:42:44.542] List of future strategies:
[17:42:44.542] 1. sequential:
[17:42:44.542]    - args: function (..., envir = parent.frame())
[17:42:44.542]    - tweaked: FALSE
[17:42:44.542]    - call: NULL
[17:42:44.543] plan(): nbrOfWorkers() = 1
[17:42:44.543] plan(): Setting new future strategy stack:
[17:42:44.544] List of future strategies:
[17:42:44.544] 1. sequential:
[17:42:44.544]    - args: function (..., envir = parent.frame())
[17:42:44.544]    - tweaked: FALSE
[17:42:44.544]    - call: plan(strategy)
[17:42:44.544] plan(): nbrOfWorkers() = 1
[17:42:44.544] SequentialFuture started (and completed)
[17:42:44.544] - Launch lazy future ... done
[17:42:44.544] run() for ‘SequentialFuture’ ... done
[17:42:44.545] run() for ‘Future’ ...
[17:42:44.545] - state: ‘created’
[17:42:44.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.545]   - Field: ‘label’
[17:42:44.545]   - Field: ‘local’
[17:42:44.546]   - Field: ‘owner’
[17:42:44.546]   - Field: ‘envir’
[17:42:44.546]   - Field: ‘packages’
[17:42:44.546]   - Field: ‘gc’
[17:42:44.546]   - Field: ‘conditions’
[17:42:44.546]   - Field: ‘expr’
[17:42:44.546]   - Field: ‘uuid’
[17:42:44.546]   - Field: ‘seed’
[17:42:44.546]   - Field: ‘version’
[17:42:44.546]   - Field: ‘result’
[17:42:44.546]   - Field: ‘asynchronous’
[17:42:44.547]   - Field: ‘calls’
[17:42:44.547]   - Field: ‘globals’
[17:42:44.547]   - Field: ‘stdout’
[17:42:44.547]   - Field: ‘earlySignal’
[17:42:44.547]   - Field: ‘lazy’
[17:42:44.547]   - Field: ‘state’
[17:42:44.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.547] - Launch lazy future ...
[17:42:44.547] Packages needed by the future expression (n = 0): <none>
[17:42:44.548] Packages needed by future strategies (n = 0): <none>
[17:42:44.548] {
[17:42:44.548]     {
[17:42:44.548]         {
[17:42:44.548]             ...future.startTime <- base::Sys.time()
[17:42:44.548]             {
[17:42:44.548]                 {
[17:42:44.548]                   {
[17:42:44.548]                     base::local({
[17:42:44.548]                       has_future <- base::requireNamespace("future", 
[17:42:44.548]                         quietly = TRUE)
[17:42:44.548]                       if (has_future) {
[17:42:44.548]                         ns <- base::getNamespace("future")
[17:42:44.548]                         version <- ns[[".package"]][["version"]]
[17:42:44.548]                         if (is.null(version)) 
[17:42:44.548]                           version <- utils::packageVersion("future")
[17:42:44.548]                       }
[17:42:44.548]                       else {
[17:42:44.548]                         version <- NULL
[17:42:44.548]                       }
[17:42:44.548]                       if (!has_future || version < "1.8.0") {
[17:42:44.548]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.548]                           "", base::R.version$version.string), 
[17:42:44.548]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.548]                             "release", "version")], collapse = " "), 
[17:42:44.548]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.548]                           info)
[17:42:44.548]                         info <- base::paste(info, collapse = "; ")
[17:42:44.548]                         if (!has_future) {
[17:42:44.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.548]                             info)
[17:42:44.548]                         }
[17:42:44.548]                         else {
[17:42:44.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.548]                             info, version)
[17:42:44.548]                         }
[17:42:44.548]                         base::stop(msg)
[17:42:44.548]                       }
[17:42:44.548]                     })
[17:42:44.548]                   }
[17:42:44.548]                   options(future.plan = NULL)
[17:42:44.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.548]                 }
[17:42:44.548]                 ...future.workdir <- getwd()
[17:42:44.548]             }
[17:42:44.548]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.548]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.548]         }
[17:42:44.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.548]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.548]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.548]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.548]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.548]             base::names(...future.oldOptions))
[17:42:44.548]     }
[17:42:44.548]     if (FALSE) {
[17:42:44.548]     }
[17:42:44.548]     else {
[17:42:44.548]         if (TRUE) {
[17:42:44.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.548]                 open = "w")
[17:42:44.548]         }
[17:42:44.548]         else {
[17:42:44.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.548]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.548]         }
[17:42:44.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.548]             base::sink(type = "output", split = FALSE)
[17:42:44.548]             base::close(...future.stdout)
[17:42:44.548]         }, add = TRUE)
[17:42:44.548]     }
[17:42:44.548]     ...future.frame <- base::sys.nframe()
[17:42:44.548]     ...future.conditions <- base::list()
[17:42:44.548]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.548]     if (FALSE) {
[17:42:44.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.548]     }
[17:42:44.548]     ...future.result <- base::tryCatch({
[17:42:44.548]         base::withCallingHandlers({
[17:42:44.548]             ...future.value <- base::withVisible(base::local({
[17:42:44.548]                 b <- a * ii
[17:42:44.548]                 a <- 0
[17:42:44.548]                 b
[17:42:44.548]             }))
[17:42:44.548]             future::FutureResult(value = ...future.value$value, 
[17:42:44.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.548]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.548]                     ...future.globalenv.names))
[17:42:44.548]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.548]         }, condition = base::local({
[17:42:44.548]             c <- base::c
[17:42:44.548]             inherits <- base::inherits
[17:42:44.548]             invokeRestart <- base::invokeRestart
[17:42:44.548]             length <- base::length
[17:42:44.548]             list <- base::list
[17:42:44.548]             seq.int <- base::seq.int
[17:42:44.548]             signalCondition <- base::signalCondition
[17:42:44.548]             sys.calls <- base::sys.calls
[17:42:44.548]             `[[` <- base::`[[`
[17:42:44.548]             `+` <- base::`+`
[17:42:44.548]             `<<-` <- base::`<<-`
[17:42:44.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.548]                   3L)]
[17:42:44.548]             }
[17:42:44.548]             function(cond) {
[17:42:44.548]                 is_error <- inherits(cond, "error")
[17:42:44.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.548]                   NULL)
[17:42:44.548]                 if (is_error) {
[17:42:44.548]                   sessionInformation <- function() {
[17:42:44.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.548]                       search = base::search(), system = base::Sys.info())
[17:42:44.548]                   }
[17:42:44.548]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.548]                     cond$call), session = sessionInformation(), 
[17:42:44.548]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.548]                   signalCondition(cond)
[17:42:44.548]                 }
[17:42:44.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.548]                 "immediateCondition"))) {
[17:42:44.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.548]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.548]                   if (TRUE && !signal) {
[17:42:44.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.548]                     {
[17:42:44.548]                       inherits <- base::inherits
[17:42:44.548]                       invokeRestart <- base::invokeRestart
[17:42:44.548]                       is.null <- base::is.null
[17:42:44.548]                       muffled <- FALSE
[17:42:44.548]                       if (inherits(cond, "message")) {
[17:42:44.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.548]                         if (muffled) 
[17:42:44.548]                           invokeRestart("muffleMessage")
[17:42:44.548]                       }
[17:42:44.548]                       else if (inherits(cond, "warning")) {
[17:42:44.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.548]                         if (muffled) 
[17:42:44.548]                           invokeRestart("muffleWarning")
[17:42:44.548]                       }
[17:42:44.548]                       else if (inherits(cond, "condition")) {
[17:42:44.548]                         if (!is.null(pattern)) {
[17:42:44.548]                           computeRestarts <- base::computeRestarts
[17:42:44.548]                           grepl <- base::grepl
[17:42:44.548]                           restarts <- computeRestarts(cond)
[17:42:44.548]                           for (restart in restarts) {
[17:42:44.548]                             name <- restart$name
[17:42:44.548]                             if (is.null(name)) 
[17:42:44.548]                               next
[17:42:44.548]                             if (!grepl(pattern, name)) 
[17:42:44.548]                               next
[17:42:44.548]                             invokeRestart(restart)
[17:42:44.548]                             muffled <- TRUE
[17:42:44.548]                             break
[17:42:44.548]                           }
[17:42:44.548]                         }
[17:42:44.548]                       }
[17:42:44.548]                       invisible(muffled)
[17:42:44.548]                     }
[17:42:44.548]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.548]                   }
[17:42:44.548]                 }
[17:42:44.548]                 else {
[17:42:44.548]                   if (TRUE) {
[17:42:44.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.548]                     {
[17:42:44.548]                       inherits <- base::inherits
[17:42:44.548]                       invokeRestart <- base::invokeRestart
[17:42:44.548]                       is.null <- base::is.null
[17:42:44.548]                       muffled <- FALSE
[17:42:44.548]                       if (inherits(cond, "message")) {
[17:42:44.548]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.548]                         if (muffled) 
[17:42:44.548]                           invokeRestart("muffleMessage")
[17:42:44.548]                       }
[17:42:44.548]                       else if (inherits(cond, "warning")) {
[17:42:44.548]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.548]                         if (muffled) 
[17:42:44.548]                           invokeRestart("muffleWarning")
[17:42:44.548]                       }
[17:42:44.548]                       else if (inherits(cond, "condition")) {
[17:42:44.548]                         if (!is.null(pattern)) {
[17:42:44.548]                           computeRestarts <- base::computeRestarts
[17:42:44.548]                           grepl <- base::grepl
[17:42:44.548]                           restarts <- computeRestarts(cond)
[17:42:44.548]                           for (restart in restarts) {
[17:42:44.548]                             name <- restart$name
[17:42:44.548]                             if (is.null(name)) 
[17:42:44.548]                               next
[17:42:44.548]                             if (!grepl(pattern, name)) 
[17:42:44.548]                               next
[17:42:44.548]                             invokeRestart(restart)
[17:42:44.548]                             muffled <- TRUE
[17:42:44.548]                             break
[17:42:44.548]                           }
[17:42:44.548]                         }
[17:42:44.548]                       }
[17:42:44.548]                       invisible(muffled)
[17:42:44.548]                     }
[17:42:44.548]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.548]                   }
[17:42:44.548]                 }
[17:42:44.548]             }
[17:42:44.548]         }))
[17:42:44.548]     }, error = function(ex) {
[17:42:44.548]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.548]                 ...future.rng), started = ...future.startTime, 
[17:42:44.548]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.548]             version = "1.8"), class = "FutureResult")
[17:42:44.548]     }, finally = {
[17:42:44.548]         if (!identical(...future.workdir, getwd())) 
[17:42:44.548]             setwd(...future.workdir)
[17:42:44.548]         {
[17:42:44.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.548]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.548]             }
[17:42:44.548]             base::options(...future.oldOptions)
[17:42:44.548]             if (.Platform$OS.type == "windows") {
[17:42:44.548]                 old_names <- names(...future.oldEnvVars)
[17:42:44.548]                 envs <- base::Sys.getenv()
[17:42:44.548]                 names <- names(envs)
[17:42:44.548]                 common <- intersect(names, old_names)
[17:42:44.548]                 added <- setdiff(names, old_names)
[17:42:44.548]                 removed <- setdiff(old_names, names)
[17:42:44.548]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.548]                   envs[common]]
[17:42:44.548]                 NAMES <- toupper(changed)
[17:42:44.548]                 args <- list()
[17:42:44.548]                 for (kk in seq_along(NAMES)) {
[17:42:44.548]                   name <- changed[[kk]]
[17:42:44.548]                   NAME <- NAMES[[kk]]
[17:42:44.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.548]                     next
[17:42:44.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.548]                 }
[17:42:44.548]                 NAMES <- toupper(added)
[17:42:44.548]                 for (kk in seq_along(NAMES)) {
[17:42:44.548]                   name <- added[[kk]]
[17:42:44.548]                   NAME <- NAMES[[kk]]
[17:42:44.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.548]                     next
[17:42:44.548]                   args[[name]] <- ""
[17:42:44.548]                 }
[17:42:44.548]                 NAMES <- toupper(removed)
[17:42:44.548]                 for (kk in seq_along(NAMES)) {
[17:42:44.548]                   name <- removed[[kk]]
[17:42:44.548]                   NAME <- NAMES[[kk]]
[17:42:44.548]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.548]                     next
[17:42:44.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.548]                 }
[17:42:44.548]                 if (length(args) > 0) 
[17:42:44.548]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.548]             }
[17:42:44.548]             else {
[17:42:44.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.548]             }
[17:42:44.548]             {
[17:42:44.548]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.548]                   0L) {
[17:42:44.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.548]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.548]                   base::options(opts)
[17:42:44.548]                 }
[17:42:44.548]                 {
[17:42:44.548]                   {
[17:42:44.548]                     NULL
[17:42:44.548]                     RNGkind("Mersenne-Twister")
[17:42:44.548]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.548]                       inherits = FALSE)
[17:42:44.548]                   }
[17:42:44.548]                   options(future.plan = NULL)
[17:42:44.548]                   if (is.na(NA_character_)) 
[17:42:44.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.548]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.548]                   {
[17:42:44.548]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.548]                     if (!future$lazy) 
[17:42:44.548]                       future <- run(future)
[17:42:44.548]                     invisible(future)
[17:42:44.548]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.548]                 }
[17:42:44.548]             }
[17:42:44.548]         }
[17:42:44.548]     })
[17:42:44.548]     if (TRUE) {
[17:42:44.548]         base::sink(type = "output", split = FALSE)
[17:42:44.548]         if (TRUE) {
[17:42:44.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.548]         }
[17:42:44.548]         else {
[17:42:44.548]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.548]         }
[17:42:44.548]         base::close(...future.stdout)
[17:42:44.548]         ...future.stdout <- NULL
[17:42:44.548]     }
[17:42:44.548]     ...future.result$conditions <- ...future.conditions
[17:42:44.548]     ...future.result$finished <- base::Sys.time()
[17:42:44.548]     ...future.result
[17:42:44.548] }
[17:42:44.550] assign_globals() ...
[17:42:44.550] List of 2
[17:42:44.550]  $ a : num 1
[17:42:44.550]  $ ii: int 2
[17:42:44.550]  - attr(*, "where")=List of 2
[17:42:44.550]   ..$ a :<environment: R_EmptyEnv> 
[17:42:44.550]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.550]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.550]  - attr(*, "resolved")= logi TRUE
[17:42:44.550]  - attr(*, "total_size")= num 112
[17:42:44.550]  - attr(*, "already-done")= logi TRUE
[17:42:44.553] - copied ‘a’ to environment
[17:42:44.553] - copied ‘ii’ to environment
[17:42:44.553] assign_globals() ... done
[17:42:44.553] plan(): Setting new future strategy stack:
[17:42:44.553] List of future strategies:
[17:42:44.553] 1. sequential:
[17:42:44.553]    - args: function (..., envir = parent.frame())
[17:42:44.553]    - tweaked: FALSE
[17:42:44.553]    - call: NULL
[17:42:44.554] plan(): nbrOfWorkers() = 1
[17:42:44.554] plan(): Setting new future strategy stack:
[17:42:44.554] List of future strategies:
[17:42:44.554] 1. sequential:
[17:42:44.554]    - args: function (..., envir = parent.frame())
[17:42:44.554]    - tweaked: FALSE
[17:42:44.554]    - call: plan(strategy)
[17:42:44.555] plan(): nbrOfWorkers() = 1
[17:42:44.555] SequentialFuture started (and completed)
[17:42:44.555] - Launch lazy future ... done
[17:42:44.555] run() for ‘SequentialFuture’ ... done
[17:42:44.555] run() for ‘Future’ ...
[17:42:44.556] - state: ‘created’
[17:42:44.556] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.556] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.556]   - Field: ‘label’
[17:42:44.556]   - Field: ‘local’
[17:42:44.556]   - Field: ‘owner’
[17:42:44.556]   - Field: ‘envir’
[17:42:44.557]   - Field: ‘packages’
[17:42:44.557]   - Field: ‘gc’
[17:42:44.557]   - Field: ‘conditions’
[17:42:44.557]   - Field: ‘expr’
[17:42:44.557]   - Field: ‘uuid’
[17:42:44.557]   - Field: ‘seed’
[17:42:44.557]   - Field: ‘version’
[17:42:44.557]   - Field: ‘result’
[17:42:44.557]   - Field: ‘asynchronous’
[17:42:44.557]   - Field: ‘calls’
[17:42:44.558]   - Field: ‘globals’
[17:42:44.558]   - Field: ‘stdout’
[17:42:44.558]   - Field: ‘earlySignal’
[17:42:44.558]   - Field: ‘lazy’
[17:42:44.558]   - Field: ‘state’
[17:42:44.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.558] - Launch lazy future ...
[17:42:44.558] Packages needed by the future expression (n = 0): <none>
[17:42:44.558] Packages needed by future strategies (n = 0): <none>
[17:42:44.559] {
[17:42:44.559]     {
[17:42:44.559]         {
[17:42:44.559]             ...future.startTime <- base::Sys.time()
[17:42:44.559]             {
[17:42:44.559]                 {
[17:42:44.559]                   {
[17:42:44.559]                     base::local({
[17:42:44.559]                       has_future <- base::requireNamespace("future", 
[17:42:44.559]                         quietly = TRUE)
[17:42:44.559]                       if (has_future) {
[17:42:44.559]                         ns <- base::getNamespace("future")
[17:42:44.559]                         version <- ns[[".package"]][["version"]]
[17:42:44.559]                         if (is.null(version)) 
[17:42:44.559]                           version <- utils::packageVersion("future")
[17:42:44.559]                       }
[17:42:44.559]                       else {
[17:42:44.559]                         version <- NULL
[17:42:44.559]                       }
[17:42:44.559]                       if (!has_future || version < "1.8.0") {
[17:42:44.559]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.559]                           "", base::R.version$version.string), 
[17:42:44.559]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.559]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.559]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.559]                             "release", "version")], collapse = " "), 
[17:42:44.559]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.559]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.559]                           info)
[17:42:44.559]                         info <- base::paste(info, collapse = "; ")
[17:42:44.559]                         if (!has_future) {
[17:42:44.559]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.559]                             info)
[17:42:44.559]                         }
[17:42:44.559]                         else {
[17:42:44.559]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.559]                             info, version)
[17:42:44.559]                         }
[17:42:44.559]                         base::stop(msg)
[17:42:44.559]                       }
[17:42:44.559]                     })
[17:42:44.559]                   }
[17:42:44.559]                   options(future.plan = NULL)
[17:42:44.559]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.559]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.559]                 }
[17:42:44.559]                 ...future.workdir <- getwd()
[17:42:44.559]             }
[17:42:44.559]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.559]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.559]         }
[17:42:44.559]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.559]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.559]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.559]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.559]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.559]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.559]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.559]             base::names(...future.oldOptions))
[17:42:44.559]     }
[17:42:44.559]     if (FALSE) {
[17:42:44.559]     }
[17:42:44.559]     else {
[17:42:44.559]         if (TRUE) {
[17:42:44.559]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.559]                 open = "w")
[17:42:44.559]         }
[17:42:44.559]         else {
[17:42:44.559]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.559]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.559]         }
[17:42:44.559]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.559]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.559]             base::sink(type = "output", split = FALSE)
[17:42:44.559]             base::close(...future.stdout)
[17:42:44.559]         }, add = TRUE)
[17:42:44.559]     }
[17:42:44.559]     ...future.frame <- base::sys.nframe()
[17:42:44.559]     ...future.conditions <- base::list()
[17:42:44.559]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.559]     if (FALSE) {
[17:42:44.559]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.559]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.559]     }
[17:42:44.559]     ...future.result <- base::tryCatch({
[17:42:44.559]         base::withCallingHandlers({
[17:42:44.559]             ...future.value <- base::withVisible(base::local({
[17:42:44.559]                 b <- a * ii
[17:42:44.559]                 a <- 0
[17:42:44.559]                 b
[17:42:44.559]             }))
[17:42:44.559]             future::FutureResult(value = ...future.value$value, 
[17:42:44.559]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.559]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.559]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.559]                     ...future.globalenv.names))
[17:42:44.559]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.559]         }, condition = base::local({
[17:42:44.559]             c <- base::c
[17:42:44.559]             inherits <- base::inherits
[17:42:44.559]             invokeRestart <- base::invokeRestart
[17:42:44.559]             length <- base::length
[17:42:44.559]             list <- base::list
[17:42:44.559]             seq.int <- base::seq.int
[17:42:44.559]             signalCondition <- base::signalCondition
[17:42:44.559]             sys.calls <- base::sys.calls
[17:42:44.559]             `[[` <- base::`[[`
[17:42:44.559]             `+` <- base::`+`
[17:42:44.559]             `<<-` <- base::`<<-`
[17:42:44.559]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.559]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.559]                   3L)]
[17:42:44.559]             }
[17:42:44.559]             function(cond) {
[17:42:44.559]                 is_error <- inherits(cond, "error")
[17:42:44.559]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.559]                   NULL)
[17:42:44.559]                 if (is_error) {
[17:42:44.559]                   sessionInformation <- function() {
[17:42:44.559]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.559]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.559]                       search = base::search(), system = base::Sys.info())
[17:42:44.559]                   }
[17:42:44.559]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.559]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.559]                     cond$call), session = sessionInformation(), 
[17:42:44.559]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.559]                   signalCondition(cond)
[17:42:44.559]                 }
[17:42:44.559]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.559]                 "immediateCondition"))) {
[17:42:44.559]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.559]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.559]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.559]                   if (TRUE && !signal) {
[17:42:44.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.559]                     {
[17:42:44.559]                       inherits <- base::inherits
[17:42:44.559]                       invokeRestart <- base::invokeRestart
[17:42:44.559]                       is.null <- base::is.null
[17:42:44.559]                       muffled <- FALSE
[17:42:44.559]                       if (inherits(cond, "message")) {
[17:42:44.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.559]                         if (muffled) 
[17:42:44.559]                           invokeRestart("muffleMessage")
[17:42:44.559]                       }
[17:42:44.559]                       else if (inherits(cond, "warning")) {
[17:42:44.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.559]                         if (muffled) 
[17:42:44.559]                           invokeRestart("muffleWarning")
[17:42:44.559]                       }
[17:42:44.559]                       else if (inherits(cond, "condition")) {
[17:42:44.559]                         if (!is.null(pattern)) {
[17:42:44.559]                           computeRestarts <- base::computeRestarts
[17:42:44.559]                           grepl <- base::grepl
[17:42:44.559]                           restarts <- computeRestarts(cond)
[17:42:44.559]                           for (restart in restarts) {
[17:42:44.559]                             name <- restart$name
[17:42:44.559]                             if (is.null(name)) 
[17:42:44.559]                               next
[17:42:44.559]                             if (!grepl(pattern, name)) 
[17:42:44.559]                               next
[17:42:44.559]                             invokeRestart(restart)
[17:42:44.559]                             muffled <- TRUE
[17:42:44.559]                             break
[17:42:44.559]                           }
[17:42:44.559]                         }
[17:42:44.559]                       }
[17:42:44.559]                       invisible(muffled)
[17:42:44.559]                     }
[17:42:44.559]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.559]                   }
[17:42:44.559]                 }
[17:42:44.559]                 else {
[17:42:44.559]                   if (TRUE) {
[17:42:44.559]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.559]                     {
[17:42:44.559]                       inherits <- base::inherits
[17:42:44.559]                       invokeRestart <- base::invokeRestart
[17:42:44.559]                       is.null <- base::is.null
[17:42:44.559]                       muffled <- FALSE
[17:42:44.559]                       if (inherits(cond, "message")) {
[17:42:44.559]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.559]                         if (muffled) 
[17:42:44.559]                           invokeRestart("muffleMessage")
[17:42:44.559]                       }
[17:42:44.559]                       else if (inherits(cond, "warning")) {
[17:42:44.559]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.559]                         if (muffled) 
[17:42:44.559]                           invokeRestart("muffleWarning")
[17:42:44.559]                       }
[17:42:44.559]                       else if (inherits(cond, "condition")) {
[17:42:44.559]                         if (!is.null(pattern)) {
[17:42:44.559]                           computeRestarts <- base::computeRestarts
[17:42:44.559]                           grepl <- base::grepl
[17:42:44.559]                           restarts <- computeRestarts(cond)
[17:42:44.559]                           for (restart in restarts) {
[17:42:44.559]                             name <- restart$name
[17:42:44.559]                             if (is.null(name)) 
[17:42:44.559]                               next
[17:42:44.559]                             if (!grepl(pattern, name)) 
[17:42:44.559]                               next
[17:42:44.559]                             invokeRestart(restart)
[17:42:44.559]                             muffled <- TRUE
[17:42:44.559]                             break
[17:42:44.559]                           }
[17:42:44.559]                         }
[17:42:44.559]                       }
[17:42:44.559]                       invisible(muffled)
[17:42:44.559]                     }
[17:42:44.559]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.559]                   }
[17:42:44.559]                 }
[17:42:44.559]             }
[17:42:44.559]         }))
[17:42:44.559]     }, error = function(ex) {
[17:42:44.559]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.559]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.559]                 ...future.rng), started = ...future.startTime, 
[17:42:44.559]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.559]             version = "1.8"), class = "FutureResult")
[17:42:44.559]     }, finally = {
[17:42:44.559]         if (!identical(...future.workdir, getwd())) 
[17:42:44.559]             setwd(...future.workdir)
[17:42:44.559]         {
[17:42:44.559]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.559]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.559]             }
[17:42:44.559]             base::options(...future.oldOptions)
[17:42:44.559]             if (.Platform$OS.type == "windows") {
[17:42:44.559]                 old_names <- names(...future.oldEnvVars)
[17:42:44.559]                 envs <- base::Sys.getenv()
[17:42:44.559]                 names <- names(envs)
[17:42:44.559]                 common <- intersect(names, old_names)
[17:42:44.559]                 added <- setdiff(names, old_names)
[17:42:44.559]                 removed <- setdiff(old_names, names)
[17:42:44.559]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.559]                   envs[common]]
[17:42:44.559]                 NAMES <- toupper(changed)
[17:42:44.559]                 args <- list()
[17:42:44.559]                 for (kk in seq_along(NAMES)) {
[17:42:44.559]                   name <- changed[[kk]]
[17:42:44.559]                   NAME <- NAMES[[kk]]
[17:42:44.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.559]                     next
[17:42:44.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.559]                 }
[17:42:44.559]                 NAMES <- toupper(added)
[17:42:44.559]                 for (kk in seq_along(NAMES)) {
[17:42:44.559]                   name <- added[[kk]]
[17:42:44.559]                   NAME <- NAMES[[kk]]
[17:42:44.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.559]                     next
[17:42:44.559]                   args[[name]] <- ""
[17:42:44.559]                 }
[17:42:44.559]                 NAMES <- toupper(removed)
[17:42:44.559]                 for (kk in seq_along(NAMES)) {
[17:42:44.559]                   name <- removed[[kk]]
[17:42:44.559]                   NAME <- NAMES[[kk]]
[17:42:44.559]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.559]                     next
[17:42:44.559]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.559]                 }
[17:42:44.559]                 if (length(args) > 0) 
[17:42:44.559]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.559]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.559]             }
[17:42:44.559]             else {
[17:42:44.559]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.559]             }
[17:42:44.559]             {
[17:42:44.559]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.559]                   0L) {
[17:42:44.559]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.559]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.559]                   base::options(opts)
[17:42:44.559]                 }
[17:42:44.559]                 {
[17:42:44.559]                   {
[17:42:44.559]                     NULL
[17:42:44.559]                     RNGkind("Mersenne-Twister")
[17:42:44.559]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.559]                       inherits = FALSE)
[17:42:44.559]                   }
[17:42:44.559]                   options(future.plan = NULL)
[17:42:44.559]                   if (is.na(NA_character_)) 
[17:42:44.559]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.559]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.559]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.559]                   {
[17:42:44.559]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.559]                     if (!future$lazy) 
[17:42:44.559]                       future <- run(future)
[17:42:44.559]                     invisible(future)
[17:42:44.559]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.559]                 }
[17:42:44.559]             }
[17:42:44.559]         }
[17:42:44.559]     })
[17:42:44.559]     if (TRUE) {
[17:42:44.559]         base::sink(type = "output", split = FALSE)
[17:42:44.559]         if (TRUE) {
[17:42:44.559]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.559]         }
[17:42:44.559]         else {
[17:42:44.559]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.559]         }
[17:42:44.559]         base::close(...future.stdout)
[17:42:44.559]         ...future.stdout <- NULL
[17:42:44.559]     }
[17:42:44.559]     ...future.result$conditions <- ...future.conditions
[17:42:44.559]     ...future.result$finished <- base::Sys.time()
[17:42:44.559]     ...future.result
[17:42:44.559] }
[17:42:44.561] assign_globals() ...
[17:42:44.562] List of 2
[17:42:44.562]  $ a : num 1
[17:42:44.562]  $ ii: int 3
[17:42:44.562]  - attr(*, "where")=List of 2
[17:42:44.562]   ..$ a :<environment: R_EmptyEnv> 
[17:42:44.562]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.562]  - attr(*, "resolved")= logi TRUE
[17:42:44.562]  - attr(*, "total_size")= num 112
[17:42:44.562]  - attr(*, "already-done")= logi TRUE
[17:42:44.566] - copied ‘a’ to environment
[17:42:44.566] - copied ‘ii’ to environment
[17:42:44.566] assign_globals() ... done
[17:42:44.567] plan(): Setting new future strategy stack:
[17:42:44.567] List of future strategies:
[17:42:44.567] 1. sequential:
[17:42:44.567]    - args: function (..., envir = parent.frame())
[17:42:44.567]    - tweaked: FALSE
[17:42:44.567]    - call: NULL
[17:42:44.567] plan(): nbrOfWorkers() = 1
[17:42:44.572] plan(): Setting new future strategy stack:
[17:42:44.572] List of future strategies:
[17:42:44.572] 1. sequential:
[17:42:44.572]    - args: function (..., envir = parent.frame())
[17:42:44.572]    - tweaked: FALSE
[17:42:44.572]    - call: plan(strategy)
[17:42:44.573] plan(): nbrOfWorkers() = 1
[17:42:44.573] SequentialFuture started (and completed)
[17:42:44.573] - Launch lazy future ... done
[17:42:44.573] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.574] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.574] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.574] 
[17:42:44.574] Searching for globals ... DONE
[17:42:44.574] - globals: [0] <none>
[17:42:44.575] getGlobalsAndPackages() ... DONE
[17:42:44.575] run() for ‘Future’ ...
[17:42:44.575] - state: ‘created’
[17:42:44.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.576] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.576]   - Field: ‘label’
[17:42:44.576]   - Field: ‘local’
[17:42:44.576]   - Field: ‘owner’
[17:42:44.576]   - Field: ‘envir’
[17:42:44.576]   - Field: ‘packages’
[17:42:44.576]   - Field: ‘gc’
[17:42:44.576]   - Field: ‘conditions’
[17:42:44.576]   - Field: ‘expr’
[17:42:44.576]   - Field: ‘uuid’
[17:42:44.576]   - Field: ‘seed’
[17:42:44.577]   - Field: ‘version’
[17:42:44.577]   - Field: ‘result’
[17:42:44.577]   - Field: ‘asynchronous’
[17:42:44.577]   - Field: ‘calls’
[17:42:44.577]   - Field: ‘globals’
[17:42:44.577]   - Field: ‘stdout’
[17:42:44.577]   - Field: ‘earlySignal’
[17:42:44.577]   - Field: ‘lazy’
[17:42:44.577]   - Field: ‘state’
[17:42:44.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.578] - Launch lazy future ...
[17:42:44.578] Packages needed by the future expression (n = 0): <none>
[17:42:44.578] Packages needed by future strategies (n = 0): <none>
[17:42:44.578] {
[17:42:44.578]     {
[17:42:44.578]         {
[17:42:44.578]             ...future.startTime <- base::Sys.time()
[17:42:44.578]             {
[17:42:44.578]                 {
[17:42:44.578]                   {
[17:42:44.578]                     base::local({
[17:42:44.578]                       has_future <- base::requireNamespace("future", 
[17:42:44.578]                         quietly = TRUE)
[17:42:44.578]                       if (has_future) {
[17:42:44.578]                         ns <- base::getNamespace("future")
[17:42:44.578]                         version <- ns[[".package"]][["version"]]
[17:42:44.578]                         if (is.null(version)) 
[17:42:44.578]                           version <- utils::packageVersion("future")
[17:42:44.578]                       }
[17:42:44.578]                       else {
[17:42:44.578]                         version <- NULL
[17:42:44.578]                       }
[17:42:44.578]                       if (!has_future || version < "1.8.0") {
[17:42:44.578]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.578]                           "", base::R.version$version.string), 
[17:42:44.578]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.578]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.578]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.578]                             "release", "version")], collapse = " "), 
[17:42:44.578]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.578]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.578]                           info)
[17:42:44.578]                         info <- base::paste(info, collapse = "; ")
[17:42:44.578]                         if (!has_future) {
[17:42:44.578]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.578]                             info)
[17:42:44.578]                         }
[17:42:44.578]                         else {
[17:42:44.578]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.578]                             info, version)
[17:42:44.578]                         }
[17:42:44.578]                         base::stop(msg)
[17:42:44.578]                       }
[17:42:44.578]                     })
[17:42:44.578]                   }
[17:42:44.578]                   options(future.plan = NULL)
[17:42:44.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.578]                 }
[17:42:44.578]                 ...future.workdir <- getwd()
[17:42:44.578]             }
[17:42:44.578]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.578]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.578]         }
[17:42:44.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.578]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.578]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.578]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.578]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.578]             base::names(...future.oldOptions))
[17:42:44.578]     }
[17:42:44.578]     if (FALSE) {
[17:42:44.578]     }
[17:42:44.578]     else {
[17:42:44.578]         if (TRUE) {
[17:42:44.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.578]                 open = "w")
[17:42:44.578]         }
[17:42:44.578]         else {
[17:42:44.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.578]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.578]         }
[17:42:44.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.578]             base::sink(type = "output", split = FALSE)
[17:42:44.578]             base::close(...future.stdout)
[17:42:44.578]         }, add = TRUE)
[17:42:44.578]     }
[17:42:44.578]     ...future.frame <- base::sys.nframe()
[17:42:44.578]     ...future.conditions <- base::list()
[17:42:44.578]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.578]     if (FALSE) {
[17:42:44.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.578]     }
[17:42:44.578]     ...future.result <- base::tryCatch({
[17:42:44.578]         base::withCallingHandlers({
[17:42:44.578]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.578]             future::FutureResult(value = ...future.value$value, 
[17:42:44.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.578]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.578]                     ...future.globalenv.names))
[17:42:44.578]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.578]         }, condition = base::local({
[17:42:44.578]             c <- base::c
[17:42:44.578]             inherits <- base::inherits
[17:42:44.578]             invokeRestart <- base::invokeRestart
[17:42:44.578]             length <- base::length
[17:42:44.578]             list <- base::list
[17:42:44.578]             seq.int <- base::seq.int
[17:42:44.578]             signalCondition <- base::signalCondition
[17:42:44.578]             sys.calls <- base::sys.calls
[17:42:44.578]             `[[` <- base::`[[`
[17:42:44.578]             `+` <- base::`+`
[17:42:44.578]             `<<-` <- base::`<<-`
[17:42:44.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.578]                   3L)]
[17:42:44.578]             }
[17:42:44.578]             function(cond) {
[17:42:44.578]                 is_error <- inherits(cond, "error")
[17:42:44.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.578]                   NULL)
[17:42:44.578]                 if (is_error) {
[17:42:44.578]                   sessionInformation <- function() {
[17:42:44.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.578]                       search = base::search(), system = base::Sys.info())
[17:42:44.578]                   }
[17:42:44.578]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.578]                     cond$call), session = sessionInformation(), 
[17:42:44.578]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.578]                   signalCondition(cond)
[17:42:44.578]                 }
[17:42:44.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.578]                 "immediateCondition"))) {
[17:42:44.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.578]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.578]                   if (TRUE && !signal) {
[17:42:44.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.578]                     {
[17:42:44.578]                       inherits <- base::inherits
[17:42:44.578]                       invokeRestart <- base::invokeRestart
[17:42:44.578]                       is.null <- base::is.null
[17:42:44.578]                       muffled <- FALSE
[17:42:44.578]                       if (inherits(cond, "message")) {
[17:42:44.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.578]                         if (muffled) 
[17:42:44.578]                           invokeRestart("muffleMessage")
[17:42:44.578]                       }
[17:42:44.578]                       else if (inherits(cond, "warning")) {
[17:42:44.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.578]                         if (muffled) 
[17:42:44.578]                           invokeRestart("muffleWarning")
[17:42:44.578]                       }
[17:42:44.578]                       else if (inherits(cond, "condition")) {
[17:42:44.578]                         if (!is.null(pattern)) {
[17:42:44.578]                           computeRestarts <- base::computeRestarts
[17:42:44.578]                           grepl <- base::grepl
[17:42:44.578]                           restarts <- computeRestarts(cond)
[17:42:44.578]                           for (restart in restarts) {
[17:42:44.578]                             name <- restart$name
[17:42:44.578]                             if (is.null(name)) 
[17:42:44.578]                               next
[17:42:44.578]                             if (!grepl(pattern, name)) 
[17:42:44.578]                               next
[17:42:44.578]                             invokeRestart(restart)
[17:42:44.578]                             muffled <- TRUE
[17:42:44.578]                             break
[17:42:44.578]                           }
[17:42:44.578]                         }
[17:42:44.578]                       }
[17:42:44.578]                       invisible(muffled)
[17:42:44.578]                     }
[17:42:44.578]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.578]                   }
[17:42:44.578]                 }
[17:42:44.578]                 else {
[17:42:44.578]                   if (TRUE) {
[17:42:44.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.578]                     {
[17:42:44.578]                       inherits <- base::inherits
[17:42:44.578]                       invokeRestart <- base::invokeRestart
[17:42:44.578]                       is.null <- base::is.null
[17:42:44.578]                       muffled <- FALSE
[17:42:44.578]                       if (inherits(cond, "message")) {
[17:42:44.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.578]                         if (muffled) 
[17:42:44.578]                           invokeRestart("muffleMessage")
[17:42:44.578]                       }
[17:42:44.578]                       else if (inherits(cond, "warning")) {
[17:42:44.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.578]                         if (muffled) 
[17:42:44.578]                           invokeRestart("muffleWarning")
[17:42:44.578]                       }
[17:42:44.578]                       else if (inherits(cond, "condition")) {
[17:42:44.578]                         if (!is.null(pattern)) {
[17:42:44.578]                           computeRestarts <- base::computeRestarts
[17:42:44.578]                           grepl <- base::grepl
[17:42:44.578]                           restarts <- computeRestarts(cond)
[17:42:44.578]                           for (restart in restarts) {
[17:42:44.578]                             name <- restart$name
[17:42:44.578]                             if (is.null(name)) 
[17:42:44.578]                               next
[17:42:44.578]                             if (!grepl(pattern, name)) 
[17:42:44.578]                               next
[17:42:44.578]                             invokeRestart(restart)
[17:42:44.578]                             muffled <- TRUE
[17:42:44.578]                             break
[17:42:44.578]                           }
[17:42:44.578]                         }
[17:42:44.578]                       }
[17:42:44.578]                       invisible(muffled)
[17:42:44.578]                     }
[17:42:44.578]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.578]                   }
[17:42:44.578]                 }
[17:42:44.578]             }
[17:42:44.578]         }))
[17:42:44.578]     }, error = function(ex) {
[17:42:44.578]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.578]                 ...future.rng), started = ...future.startTime, 
[17:42:44.578]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.578]             version = "1.8"), class = "FutureResult")
[17:42:44.578]     }, finally = {
[17:42:44.578]         if (!identical(...future.workdir, getwd())) 
[17:42:44.578]             setwd(...future.workdir)
[17:42:44.578]         {
[17:42:44.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.578]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.578]             }
[17:42:44.578]             base::options(...future.oldOptions)
[17:42:44.578]             if (.Platform$OS.type == "windows") {
[17:42:44.578]                 old_names <- names(...future.oldEnvVars)
[17:42:44.578]                 envs <- base::Sys.getenv()
[17:42:44.578]                 names <- names(envs)
[17:42:44.578]                 common <- intersect(names, old_names)
[17:42:44.578]                 added <- setdiff(names, old_names)
[17:42:44.578]                 removed <- setdiff(old_names, names)
[17:42:44.578]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.578]                   envs[common]]
[17:42:44.578]                 NAMES <- toupper(changed)
[17:42:44.578]                 args <- list()
[17:42:44.578]                 for (kk in seq_along(NAMES)) {
[17:42:44.578]                   name <- changed[[kk]]
[17:42:44.578]                   NAME <- NAMES[[kk]]
[17:42:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.578]                     next
[17:42:44.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.578]                 }
[17:42:44.578]                 NAMES <- toupper(added)
[17:42:44.578]                 for (kk in seq_along(NAMES)) {
[17:42:44.578]                   name <- added[[kk]]
[17:42:44.578]                   NAME <- NAMES[[kk]]
[17:42:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.578]                     next
[17:42:44.578]                   args[[name]] <- ""
[17:42:44.578]                 }
[17:42:44.578]                 NAMES <- toupper(removed)
[17:42:44.578]                 for (kk in seq_along(NAMES)) {
[17:42:44.578]                   name <- removed[[kk]]
[17:42:44.578]                   NAME <- NAMES[[kk]]
[17:42:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.578]                     next
[17:42:44.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.578]                 }
[17:42:44.578]                 if (length(args) > 0) 
[17:42:44.578]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.578]             }
[17:42:44.578]             else {
[17:42:44.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.578]             }
[17:42:44.578]             {
[17:42:44.578]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.578]                   0L) {
[17:42:44.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.578]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.578]                   base::options(opts)
[17:42:44.578]                 }
[17:42:44.578]                 {
[17:42:44.578]                   {
[17:42:44.578]                     NULL
[17:42:44.578]                     RNGkind("Mersenne-Twister")
[17:42:44.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.578]                       inherits = FALSE)
[17:42:44.578]                   }
[17:42:44.578]                   options(future.plan = NULL)
[17:42:44.578]                   if (is.na(NA_character_)) 
[17:42:44.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.578]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.578]                   {
[17:42:44.578]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.578]                     if (!future$lazy) 
[17:42:44.578]                       future <- run(future)
[17:42:44.578]                     invisible(future)
[17:42:44.578]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.578]                 }
[17:42:44.578]             }
[17:42:44.578]         }
[17:42:44.578]     })
[17:42:44.578]     if (TRUE) {
[17:42:44.578]         base::sink(type = "output", split = FALSE)
[17:42:44.578]         if (TRUE) {
[17:42:44.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.578]         }
[17:42:44.578]         else {
[17:42:44.578]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.578]         }
[17:42:44.578]         base::close(...future.stdout)
[17:42:44.578]         ...future.stdout <- NULL
[17:42:44.578]     }
[17:42:44.578]     ...future.result$conditions <- ...future.conditions
[17:42:44.578]     ...future.result$finished <- base::Sys.time()
[17:42:44.578]     ...future.result
[17:42:44.578] }
[17:42:44.580] plan(): Setting new future strategy stack:
[17:42:44.580] List of future strategies:
[17:42:44.580] 1. sequential:
[17:42:44.580]    - args: function (..., envir = parent.frame())
[17:42:44.580]    - tweaked: FALSE
[17:42:44.580]    - call: NULL
[17:42:44.581] plan(): nbrOfWorkers() = 1
[17:42:44.582] plan(): Setting new future strategy stack:
[17:42:44.582] List of future strategies:
[17:42:44.582] 1. sequential:
[17:42:44.582]    - args: function (..., envir = parent.frame())
[17:42:44.582]    - tweaked: FALSE
[17:42:44.582]    - call: plan(strategy)
[17:42:44.582] plan(): nbrOfWorkers() = 1
[17:42:44.582] SequentialFuture started (and completed)
[17:42:44.582] - Launch lazy future ... done
[17:42:44.582] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.583] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.583] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.584] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.584] Searching for globals ... DONE
[17:42:44.584] Resolving globals: TRUE
[17:42:44.584] Resolving any globals that are futures ...
[17:42:44.584] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.584] Resolving any globals that are futures ... DONE
[17:42:44.584] Resolving futures part of globals (recursively) ...
[17:42:44.585] resolve() on list ...
[17:42:44.585]  recursive: 99
[17:42:44.585]  length: 1
[17:42:44.585]  elements: ‘a’
[17:42:44.585] resolved() for ‘SequentialFuture’ ...
[17:42:44.585] - state: ‘finished’
[17:42:44.585] - run: TRUE
[17:42:44.585] - result: ‘FutureResult’
[17:42:44.585] resolved() for ‘SequentialFuture’ ... done
[17:42:44.586] Future #1
[17:42:44.586] resolved() for ‘SequentialFuture’ ...
[17:42:44.586] - state: ‘finished’
[17:42:44.586] - run: TRUE
[17:42:44.586] - result: ‘FutureResult’
[17:42:44.586] resolved() for ‘SequentialFuture’ ... done
[17:42:44.586] A SequentialFuture was resolved
[17:42:44.586]  length: 0 (resolved future 1)
[17:42:44.586] resolve() on list ... DONE
[17:42:44.587] - globals: [1] ‘a’
[17:42:44.587] Resolving futures part of globals (recursively) ... DONE
[17:42:44.589] The total size of the 1 globals is 1.52 MiB (1595728 bytes)
[17:42:44.589] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[17:42:44.589] - globals: [1] ‘a’
[17:42:44.589] - packages: [1] ‘future’
[17:42:44.589] getGlobalsAndPackages() ... DONE
[17:42:44.590] run() for ‘Future’ ...
[17:42:44.590] - state: ‘created’
[17:42:44.590] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.590] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.590] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.590]   - Field: ‘label’
[17:42:44.590]   - Field: ‘local’
[17:42:44.590]   - Field: ‘owner’
[17:42:44.591]   - Field: ‘envir’
[17:42:44.591]   - Field: ‘packages’
[17:42:44.591]   - Field: ‘gc’
[17:42:44.591]   - Field: ‘conditions’
[17:42:44.591]   - Field: ‘expr’
[17:42:44.591]   - Field: ‘uuid’
[17:42:44.591]   - Field: ‘seed’
[17:42:44.591]   - Field: ‘version’
[17:42:44.591]   - Field: ‘result’
[17:42:44.591]   - Field: ‘asynchronous’
[17:42:44.591]   - Field: ‘calls’
[17:42:44.592]   - Field: ‘globals’
[17:42:44.592]   - Field: ‘stdout’
[17:42:44.592]   - Field: ‘earlySignal’
[17:42:44.592]   - Field: ‘lazy’
[17:42:44.592]   - Field: ‘state’
[17:42:44.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.592] - Launch lazy future ...
[17:42:44.592] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.592] Packages needed by future strategies (n = 0): <none>
[17:42:44.593] {
[17:42:44.593]     {
[17:42:44.593]         {
[17:42:44.593]             ...future.startTime <- base::Sys.time()
[17:42:44.593]             {
[17:42:44.593]                 {
[17:42:44.593]                   {
[17:42:44.593]                     {
[17:42:44.593]                       base::local({
[17:42:44.593]                         has_future <- base::requireNamespace("future", 
[17:42:44.593]                           quietly = TRUE)
[17:42:44.593]                         if (has_future) {
[17:42:44.593]                           ns <- base::getNamespace("future")
[17:42:44.593]                           version <- ns[[".package"]][["version"]]
[17:42:44.593]                           if (is.null(version)) 
[17:42:44.593]                             version <- utils::packageVersion("future")
[17:42:44.593]                         }
[17:42:44.593]                         else {
[17:42:44.593]                           version <- NULL
[17:42:44.593]                         }
[17:42:44.593]                         if (!has_future || version < "1.8.0") {
[17:42:44.593]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.593]                             "", base::R.version$version.string), 
[17:42:44.593]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.593]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.593]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.593]                               "release", "version")], collapse = " "), 
[17:42:44.593]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.593]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.593]                             info)
[17:42:44.593]                           info <- base::paste(info, collapse = "; ")
[17:42:44.593]                           if (!has_future) {
[17:42:44.593]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.593]                               info)
[17:42:44.593]                           }
[17:42:44.593]                           else {
[17:42:44.593]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.593]                               info, version)
[17:42:44.593]                           }
[17:42:44.593]                           base::stop(msg)
[17:42:44.593]                         }
[17:42:44.593]                       })
[17:42:44.593]                     }
[17:42:44.593]                     base::local({
[17:42:44.593]                       for (pkg in "future") {
[17:42:44.593]                         base::loadNamespace(pkg)
[17:42:44.593]                         base::library(pkg, character.only = TRUE)
[17:42:44.593]                       }
[17:42:44.593]                     })
[17:42:44.593]                   }
[17:42:44.593]                   options(future.plan = NULL)
[17:42:44.593]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.593]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.593]                 }
[17:42:44.593]                 ...future.workdir <- getwd()
[17:42:44.593]             }
[17:42:44.593]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.593]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.593]         }
[17:42:44.593]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.593]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.593]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.593]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.593]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.593]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.593]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.593]             base::names(...future.oldOptions))
[17:42:44.593]     }
[17:42:44.593]     if (FALSE) {
[17:42:44.593]     }
[17:42:44.593]     else {
[17:42:44.593]         if (TRUE) {
[17:42:44.593]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.593]                 open = "w")
[17:42:44.593]         }
[17:42:44.593]         else {
[17:42:44.593]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.593]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.593]         }
[17:42:44.593]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.593]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.593]             base::sink(type = "output", split = FALSE)
[17:42:44.593]             base::close(...future.stdout)
[17:42:44.593]         }, add = TRUE)
[17:42:44.593]     }
[17:42:44.593]     ...future.frame <- base::sys.nframe()
[17:42:44.593]     ...future.conditions <- base::list()
[17:42:44.593]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.593]     if (FALSE) {
[17:42:44.593]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.593]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.593]     }
[17:42:44.593]     ...future.result <- base::tryCatch({
[17:42:44.593]         base::withCallingHandlers({
[17:42:44.593]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.593]                 1))
[17:42:44.593]             future::FutureResult(value = ...future.value$value, 
[17:42:44.593]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.593]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.593]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.593]                     ...future.globalenv.names))
[17:42:44.593]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.593]         }, condition = base::local({
[17:42:44.593]             c <- base::c
[17:42:44.593]             inherits <- base::inherits
[17:42:44.593]             invokeRestart <- base::invokeRestart
[17:42:44.593]             length <- base::length
[17:42:44.593]             list <- base::list
[17:42:44.593]             seq.int <- base::seq.int
[17:42:44.593]             signalCondition <- base::signalCondition
[17:42:44.593]             sys.calls <- base::sys.calls
[17:42:44.593]             `[[` <- base::`[[`
[17:42:44.593]             `+` <- base::`+`
[17:42:44.593]             `<<-` <- base::`<<-`
[17:42:44.593]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.593]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.593]                   3L)]
[17:42:44.593]             }
[17:42:44.593]             function(cond) {
[17:42:44.593]                 is_error <- inherits(cond, "error")
[17:42:44.593]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.593]                   NULL)
[17:42:44.593]                 if (is_error) {
[17:42:44.593]                   sessionInformation <- function() {
[17:42:44.593]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.593]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.593]                       search = base::search(), system = base::Sys.info())
[17:42:44.593]                   }
[17:42:44.593]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.593]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.593]                     cond$call), session = sessionInformation(), 
[17:42:44.593]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.593]                   signalCondition(cond)
[17:42:44.593]                 }
[17:42:44.593]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.593]                 "immediateCondition"))) {
[17:42:44.593]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.593]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.593]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.593]                   if (TRUE && !signal) {
[17:42:44.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.593]                     {
[17:42:44.593]                       inherits <- base::inherits
[17:42:44.593]                       invokeRestart <- base::invokeRestart
[17:42:44.593]                       is.null <- base::is.null
[17:42:44.593]                       muffled <- FALSE
[17:42:44.593]                       if (inherits(cond, "message")) {
[17:42:44.593]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.593]                         if (muffled) 
[17:42:44.593]                           invokeRestart("muffleMessage")
[17:42:44.593]                       }
[17:42:44.593]                       else if (inherits(cond, "warning")) {
[17:42:44.593]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.593]                         if (muffled) 
[17:42:44.593]                           invokeRestart("muffleWarning")
[17:42:44.593]                       }
[17:42:44.593]                       else if (inherits(cond, "condition")) {
[17:42:44.593]                         if (!is.null(pattern)) {
[17:42:44.593]                           computeRestarts <- base::computeRestarts
[17:42:44.593]                           grepl <- base::grepl
[17:42:44.593]                           restarts <- computeRestarts(cond)
[17:42:44.593]                           for (restart in restarts) {
[17:42:44.593]                             name <- restart$name
[17:42:44.593]                             if (is.null(name)) 
[17:42:44.593]                               next
[17:42:44.593]                             if (!grepl(pattern, name)) 
[17:42:44.593]                               next
[17:42:44.593]                             invokeRestart(restart)
[17:42:44.593]                             muffled <- TRUE
[17:42:44.593]                             break
[17:42:44.593]                           }
[17:42:44.593]                         }
[17:42:44.593]                       }
[17:42:44.593]                       invisible(muffled)
[17:42:44.593]                     }
[17:42:44.593]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.593]                   }
[17:42:44.593]                 }
[17:42:44.593]                 else {
[17:42:44.593]                   if (TRUE) {
[17:42:44.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.593]                     {
[17:42:44.593]                       inherits <- base::inherits
[17:42:44.593]                       invokeRestart <- base::invokeRestart
[17:42:44.593]                       is.null <- base::is.null
[17:42:44.593]                       muffled <- FALSE
[17:42:44.593]                       if (inherits(cond, "message")) {
[17:42:44.593]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.593]                         if (muffled) 
[17:42:44.593]                           invokeRestart("muffleMessage")
[17:42:44.593]                       }
[17:42:44.593]                       else if (inherits(cond, "warning")) {
[17:42:44.593]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.593]                         if (muffled) 
[17:42:44.593]                           invokeRestart("muffleWarning")
[17:42:44.593]                       }
[17:42:44.593]                       else if (inherits(cond, "condition")) {
[17:42:44.593]                         if (!is.null(pattern)) {
[17:42:44.593]                           computeRestarts <- base::computeRestarts
[17:42:44.593]                           grepl <- base::grepl
[17:42:44.593]                           restarts <- computeRestarts(cond)
[17:42:44.593]                           for (restart in restarts) {
[17:42:44.593]                             name <- restart$name
[17:42:44.593]                             if (is.null(name)) 
[17:42:44.593]                               next
[17:42:44.593]                             if (!grepl(pattern, name)) 
[17:42:44.593]                               next
[17:42:44.593]                             invokeRestart(restart)
[17:42:44.593]                             muffled <- TRUE
[17:42:44.593]                             break
[17:42:44.593]                           }
[17:42:44.593]                         }
[17:42:44.593]                       }
[17:42:44.593]                       invisible(muffled)
[17:42:44.593]                     }
[17:42:44.593]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.593]                   }
[17:42:44.593]                 }
[17:42:44.593]             }
[17:42:44.593]         }))
[17:42:44.593]     }, error = function(ex) {
[17:42:44.593]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.593]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.593]                 ...future.rng), started = ...future.startTime, 
[17:42:44.593]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.593]             version = "1.8"), class = "FutureResult")
[17:42:44.593]     }, finally = {
[17:42:44.593]         if (!identical(...future.workdir, getwd())) 
[17:42:44.593]             setwd(...future.workdir)
[17:42:44.593]         {
[17:42:44.593]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.593]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.593]             }
[17:42:44.593]             base::options(...future.oldOptions)
[17:42:44.593]             if (.Platform$OS.type == "windows") {
[17:42:44.593]                 old_names <- names(...future.oldEnvVars)
[17:42:44.593]                 envs <- base::Sys.getenv()
[17:42:44.593]                 names <- names(envs)
[17:42:44.593]                 common <- intersect(names, old_names)
[17:42:44.593]                 added <- setdiff(names, old_names)
[17:42:44.593]                 removed <- setdiff(old_names, names)
[17:42:44.593]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.593]                   envs[common]]
[17:42:44.593]                 NAMES <- toupper(changed)
[17:42:44.593]                 args <- list()
[17:42:44.593]                 for (kk in seq_along(NAMES)) {
[17:42:44.593]                   name <- changed[[kk]]
[17:42:44.593]                   NAME <- NAMES[[kk]]
[17:42:44.593]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.593]                     next
[17:42:44.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.593]                 }
[17:42:44.593]                 NAMES <- toupper(added)
[17:42:44.593]                 for (kk in seq_along(NAMES)) {
[17:42:44.593]                   name <- added[[kk]]
[17:42:44.593]                   NAME <- NAMES[[kk]]
[17:42:44.593]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.593]                     next
[17:42:44.593]                   args[[name]] <- ""
[17:42:44.593]                 }
[17:42:44.593]                 NAMES <- toupper(removed)
[17:42:44.593]                 for (kk in seq_along(NAMES)) {
[17:42:44.593]                   name <- removed[[kk]]
[17:42:44.593]                   NAME <- NAMES[[kk]]
[17:42:44.593]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.593]                     next
[17:42:44.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.593]                 }
[17:42:44.593]                 if (length(args) > 0) 
[17:42:44.593]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.593]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.593]             }
[17:42:44.593]             else {
[17:42:44.593]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.593]             }
[17:42:44.593]             {
[17:42:44.593]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.593]                   0L) {
[17:42:44.593]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.593]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.593]                   base::options(opts)
[17:42:44.593]                 }
[17:42:44.593]                 {
[17:42:44.593]                   {
[17:42:44.593]                     NULL
[17:42:44.593]                     RNGkind("Mersenne-Twister")
[17:42:44.593]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.593]                       inherits = FALSE)
[17:42:44.593]                   }
[17:42:44.593]                   options(future.plan = NULL)
[17:42:44.593]                   if (is.na(NA_character_)) 
[17:42:44.593]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.593]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.593]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.593]                   {
[17:42:44.593]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.593]                     if (!future$lazy) 
[17:42:44.593]                       future <- run(future)
[17:42:44.593]                     invisible(future)
[17:42:44.593]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.593]                 }
[17:42:44.593]             }
[17:42:44.593]         }
[17:42:44.593]     })
[17:42:44.593]     if (TRUE) {
[17:42:44.593]         base::sink(type = "output", split = FALSE)
[17:42:44.593]         if (TRUE) {
[17:42:44.593]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.593]         }
[17:42:44.593]         else {
[17:42:44.593]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.593]         }
[17:42:44.593]         base::close(...future.stdout)
[17:42:44.593]         ...future.stdout <- NULL
[17:42:44.593]     }
[17:42:44.593]     ...future.result$conditions <- ...future.conditions
[17:42:44.593]     ...future.result$finished <- base::Sys.time()
[17:42:44.593]     ...future.result
[17:42:44.593] }
[17:42:44.595] assign_globals() ...
[17:42:44.595] List of 1
[17:42:44.595]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56181945aca0> 
[17:42:44.595]  - attr(*, "where")=List of 1
[17:42:44.595]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.595]  - attr(*, "resolved")= logi TRUE
[17:42:44.595]  - attr(*, "total_size")= num 1595728
[17:42:44.595]  - attr(*, "already-done")= logi TRUE
[17:42:44.627] - copied ‘a’ to environment
[17:42:44.627] assign_globals() ... done
[17:42:44.627] plan(): Setting new future strategy stack:
[17:42:44.627] List of future strategies:
[17:42:44.627] 1. sequential:
[17:42:44.627]    - args: function (..., envir = parent.frame())
[17:42:44.627]    - tweaked: FALSE
[17:42:44.627]    - call: NULL
[17:42:44.628] plan(): nbrOfWorkers() = 1
[17:42:44.629] plan(): Setting new future strategy stack:
[17:42:44.629] List of future strategies:
[17:42:44.629] 1. sequential:
[17:42:44.629]    - args: function (..., envir = parent.frame())
[17:42:44.629]    - tweaked: FALSE
[17:42:44.629]    - call: plan(strategy)
[17:42:44.630] plan(): nbrOfWorkers() = 1
[17:42:44.630] SequentialFuture started (and completed)
[17:42:44.630] - Launch lazy future ... done
[17:42:44.630] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.631] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.631] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.631] 
[17:42:44.631] Searching for globals ... DONE
[17:42:44.632] - globals: [0] <none>
[17:42:44.632] getGlobalsAndPackages() ... DONE
[17:42:44.632] run() for ‘Future’ ...
[17:42:44.632] - state: ‘created’
[17:42:44.632] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.633] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.633]   - Field: ‘label’
[17:42:44.633]   - Field: ‘local’
[17:42:44.633]   - Field: ‘owner’
[17:42:44.633]   - Field: ‘envir’
[17:42:44.633]   - Field: ‘packages’
[17:42:44.633]   - Field: ‘gc’
[17:42:44.633]   - Field: ‘conditions’
[17:42:44.633]   - Field: ‘expr’
[17:42:44.633]   - Field: ‘uuid’
[17:42:44.634]   - Field: ‘seed’
[17:42:44.634]   - Field: ‘version’
[17:42:44.634]   - Field: ‘result’
[17:42:44.634]   - Field: ‘asynchronous’
[17:42:44.634]   - Field: ‘calls’
[17:42:44.634]   - Field: ‘globals’
[17:42:44.634]   - Field: ‘stdout’
[17:42:44.634]   - Field: ‘earlySignal’
[17:42:44.634]   - Field: ‘lazy’
[17:42:44.634]   - Field: ‘state’
[17:42:44.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.635] - Launch lazy future ...
[17:42:44.635] Packages needed by the future expression (n = 0): <none>
[17:42:44.635] Packages needed by future strategies (n = 0): <none>
[17:42:44.636] {
[17:42:44.636]     {
[17:42:44.636]         {
[17:42:44.636]             ...future.startTime <- base::Sys.time()
[17:42:44.636]             {
[17:42:44.636]                 {
[17:42:44.636]                   {
[17:42:44.636]                     base::local({
[17:42:44.636]                       has_future <- base::requireNamespace("future", 
[17:42:44.636]                         quietly = TRUE)
[17:42:44.636]                       if (has_future) {
[17:42:44.636]                         ns <- base::getNamespace("future")
[17:42:44.636]                         version <- ns[[".package"]][["version"]]
[17:42:44.636]                         if (is.null(version)) 
[17:42:44.636]                           version <- utils::packageVersion("future")
[17:42:44.636]                       }
[17:42:44.636]                       else {
[17:42:44.636]                         version <- NULL
[17:42:44.636]                       }
[17:42:44.636]                       if (!has_future || version < "1.8.0") {
[17:42:44.636]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.636]                           "", base::R.version$version.string), 
[17:42:44.636]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.636]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.636]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.636]                             "release", "version")], collapse = " "), 
[17:42:44.636]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.636]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.636]                           info)
[17:42:44.636]                         info <- base::paste(info, collapse = "; ")
[17:42:44.636]                         if (!has_future) {
[17:42:44.636]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.636]                             info)
[17:42:44.636]                         }
[17:42:44.636]                         else {
[17:42:44.636]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.636]                             info, version)
[17:42:44.636]                         }
[17:42:44.636]                         base::stop(msg)
[17:42:44.636]                       }
[17:42:44.636]                     })
[17:42:44.636]                   }
[17:42:44.636]                   options(future.plan = NULL)
[17:42:44.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.636]                 }
[17:42:44.636]                 ...future.workdir <- getwd()
[17:42:44.636]             }
[17:42:44.636]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.636]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.636]         }
[17:42:44.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.636]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.636]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.636]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.636]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.636]             base::names(...future.oldOptions))
[17:42:44.636]     }
[17:42:44.636]     if (FALSE) {
[17:42:44.636]     }
[17:42:44.636]     else {
[17:42:44.636]         if (TRUE) {
[17:42:44.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.636]                 open = "w")
[17:42:44.636]         }
[17:42:44.636]         else {
[17:42:44.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.636]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.636]         }
[17:42:44.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.636]             base::sink(type = "output", split = FALSE)
[17:42:44.636]             base::close(...future.stdout)
[17:42:44.636]         }, add = TRUE)
[17:42:44.636]     }
[17:42:44.636]     ...future.frame <- base::sys.nframe()
[17:42:44.636]     ...future.conditions <- base::list()
[17:42:44.636]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.636]     if (FALSE) {
[17:42:44.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.636]     }
[17:42:44.636]     ...future.result <- base::tryCatch({
[17:42:44.636]         base::withCallingHandlers({
[17:42:44.636]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.636]             future::FutureResult(value = ...future.value$value, 
[17:42:44.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.636]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.636]                     ...future.globalenv.names))
[17:42:44.636]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.636]         }, condition = base::local({
[17:42:44.636]             c <- base::c
[17:42:44.636]             inherits <- base::inherits
[17:42:44.636]             invokeRestart <- base::invokeRestart
[17:42:44.636]             length <- base::length
[17:42:44.636]             list <- base::list
[17:42:44.636]             seq.int <- base::seq.int
[17:42:44.636]             signalCondition <- base::signalCondition
[17:42:44.636]             sys.calls <- base::sys.calls
[17:42:44.636]             `[[` <- base::`[[`
[17:42:44.636]             `+` <- base::`+`
[17:42:44.636]             `<<-` <- base::`<<-`
[17:42:44.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.636]                   3L)]
[17:42:44.636]             }
[17:42:44.636]             function(cond) {
[17:42:44.636]                 is_error <- inherits(cond, "error")
[17:42:44.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.636]                   NULL)
[17:42:44.636]                 if (is_error) {
[17:42:44.636]                   sessionInformation <- function() {
[17:42:44.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.636]                       search = base::search(), system = base::Sys.info())
[17:42:44.636]                   }
[17:42:44.636]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.636]                     cond$call), session = sessionInformation(), 
[17:42:44.636]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.636]                   signalCondition(cond)
[17:42:44.636]                 }
[17:42:44.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.636]                 "immediateCondition"))) {
[17:42:44.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.636]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.636]                   if (TRUE && !signal) {
[17:42:44.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.636]                     {
[17:42:44.636]                       inherits <- base::inherits
[17:42:44.636]                       invokeRestart <- base::invokeRestart
[17:42:44.636]                       is.null <- base::is.null
[17:42:44.636]                       muffled <- FALSE
[17:42:44.636]                       if (inherits(cond, "message")) {
[17:42:44.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.636]                         if (muffled) 
[17:42:44.636]                           invokeRestart("muffleMessage")
[17:42:44.636]                       }
[17:42:44.636]                       else if (inherits(cond, "warning")) {
[17:42:44.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.636]                         if (muffled) 
[17:42:44.636]                           invokeRestart("muffleWarning")
[17:42:44.636]                       }
[17:42:44.636]                       else if (inherits(cond, "condition")) {
[17:42:44.636]                         if (!is.null(pattern)) {
[17:42:44.636]                           computeRestarts <- base::computeRestarts
[17:42:44.636]                           grepl <- base::grepl
[17:42:44.636]                           restarts <- computeRestarts(cond)
[17:42:44.636]                           for (restart in restarts) {
[17:42:44.636]                             name <- restart$name
[17:42:44.636]                             if (is.null(name)) 
[17:42:44.636]                               next
[17:42:44.636]                             if (!grepl(pattern, name)) 
[17:42:44.636]                               next
[17:42:44.636]                             invokeRestart(restart)
[17:42:44.636]                             muffled <- TRUE
[17:42:44.636]                             break
[17:42:44.636]                           }
[17:42:44.636]                         }
[17:42:44.636]                       }
[17:42:44.636]                       invisible(muffled)
[17:42:44.636]                     }
[17:42:44.636]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.636]                   }
[17:42:44.636]                 }
[17:42:44.636]                 else {
[17:42:44.636]                   if (TRUE) {
[17:42:44.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.636]                     {
[17:42:44.636]                       inherits <- base::inherits
[17:42:44.636]                       invokeRestart <- base::invokeRestart
[17:42:44.636]                       is.null <- base::is.null
[17:42:44.636]                       muffled <- FALSE
[17:42:44.636]                       if (inherits(cond, "message")) {
[17:42:44.636]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.636]                         if (muffled) 
[17:42:44.636]                           invokeRestart("muffleMessage")
[17:42:44.636]                       }
[17:42:44.636]                       else if (inherits(cond, "warning")) {
[17:42:44.636]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.636]                         if (muffled) 
[17:42:44.636]                           invokeRestart("muffleWarning")
[17:42:44.636]                       }
[17:42:44.636]                       else if (inherits(cond, "condition")) {
[17:42:44.636]                         if (!is.null(pattern)) {
[17:42:44.636]                           computeRestarts <- base::computeRestarts
[17:42:44.636]                           grepl <- base::grepl
[17:42:44.636]                           restarts <- computeRestarts(cond)
[17:42:44.636]                           for (restart in restarts) {
[17:42:44.636]                             name <- restart$name
[17:42:44.636]                             if (is.null(name)) 
[17:42:44.636]                               next
[17:42:44.636]                             if (!grepl(pattern, name)) 
[17:42:44.636]                               next
[17:42:44.636]                             invokeRestart(restart)
[17:42:44.636]                             muffled <- TRUE
[17:42:44.636]                             break
[17:42:44.636]                           }
[17:42:44.636]                         }
[17:42:44.636]                       }
[17:42:44.636]                       invisible(muffled)
[17:42:44.636]                     }
[17:42:44.636]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.636]                   }
[17:42:44.636]                 }
[17:42:44.636]             }
[17:42:44.636]         }))
[17:42:44.636]     }, error = function(ex) {
[17:42:44.636]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.636]                 ...future.rng), started = ...future.startTime, 
[17:42:44.636]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.636]             version = "1.8"), class = "FutureResult")
[17:42:44.636]     }, finally = {
[17:42:44.636]         if (!identical(...future.workdir, getwd())) 
[17:42:44.636]             setwd(...future.workdir)
[17:42:44.636]         {
[17:42:44.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.636]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.636]             }
[17:42:44.636]             base::options(...future.oldOptions)
[17:42:44.636]             if (.Platform$OS.type == "windows") {
[17:42:44.636]                 old_names <- names(...future.oldEnvVars)
[17:42:44.636]                 envs <- base::Sys.getenv()
[17:42:44.636]                 names <- names(envs)
[17:42:44.636]                 common <- intersect(names, old_names)
[17:42:44.636]                 added <- setdiff(names, old_names)
[17:42:44.636]                 removed <- setdiff(old_names, names)
[17:42:44.636]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.636]                   envs[common]]
[17:42:44.636]                 NAMES <- toupper(changed)
[17:42:44.636]                 args <- list()
[17:42:44.636]                 for (kk in seq_along(NAMES)) {
[17:42:44.636]                   name <- changed[[kk]]
[17:42:44.636]                   NAME <- NAMES[[kk]]
[17:42:44.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.636]                     next
[17:42:44.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.636]                 }
[17:42:44.636]                 NAMES <- toupper(added)
[17:42:44.636]                 for (kk in seq_along(NAMES)) {
[17:42:44.636]                   name <- added[[kk]]
[17:42:44.636]                   NAME <- NAMES[[kk]]
[17:42:44.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.636]                     next
[17:42:44.636]                   args[[name]] <- ""
[17:42:44.636]                 }
[17:42:44.636]                 NAMES <- toupper(removed)
[17:42:44.636]                 for (kk in seq_along(NAMES)) {
[17:42:44.636]                   name <- removed[[kk]]
[17:42:44.636]                   NAME <- NAMES[[kk]]
[17:42:44.636]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.636]                     next
[17:42:44.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.636]                 }
[17:42:44.636]                 if (length(args) > 0) 
[17:42:44.636]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.636]             }
[17:42:44.636]             else {
[17:42:44.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.636]             }
[17:42:44.636]             {
[17:42:44.636]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.636]                   0L) {
[17:42:44.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.636]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.636]                   base::options(opts)
[17:42:44.636]                 }
[17:42:44.636]                 {
[17:42:44.636]                   {
[17:42:44.636]                     NULL
[17:42:44.636]                     RNGkind("Mersenne-Twister")
[17:42:44.636]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.636]                       inherits = FALSE)
[17:42:44.636]                   }
[17:42:44.636]                   options(future.plan = NULL)
[17:42:44.636]                   if (is.na(NA_character_)) 
[17:42:44.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.636]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.636]                   {
[17:42:44.636]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.636]                     if (!future$lazy) 
[17:42:44.636]                       future <- run(future)
[17:42:44.636]                     invisible(future)
[17:42:44.636]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.636]                 }
[17:42:44.636]             }
[17:42:44.636]         }
[17:42:44.636]     })
[17:42:44.636]     if (TRUE) {
[17:42:44.636]         base::sink(type = "output", split = FALSE)
[17:42:44.636]         if (TRUE) {
[17:42:44.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.636]         }
[17:42:44.636]         else {
[17:42:44.636]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.636]         }
[17:42:44.636]         base::close(...future.stdout)
[17:42:44.636]         ...future.stdout <- NULL
[17:42:44.636]     }
[17:42:44.636]     ...future.result$conditions <- ...future.conditions
[17:42:44.636]     ...future.result$finished <- base::Sys.time()
[17:42:44.636]     ...future.result
[17:42:44.636] }
[17:42:44.638] plan(): Setting new future strategy stack:
[17:42:44.638] List of future strategies:
[17:42:44.638] 1. sequential:
[17:42:44.638]    - args: function (..., envir = parent.frame())
[17:42:44.638]    - tweaked: FALSE
[17:42:44.638]    - call: NULL
[17:42:44.638] plan(): nbrOfWorkers() = 1
[17:42:44.639] plan(): Setting new future strategy stack:
[17:42:44.639] List of future strategies:
[17:42:44.639] 1. sequential:
[17:42:44.639]    - args: function (..., envir = parent.frame())
[17:42:44.639]    - tweaked: FALSE
[17:42:44.639]    - call: plan(strategy)
[17:42:44.640] plan(): nbrOfWorkers() = 1
[17:42:44.640] SequentialFuture started (and completed)
[17:42:44.640] - Launch lazy future ... done
[17:42:44.640] run() for ‘SequentialFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.640] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.640] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.641] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.641] Searching for globals ... DONE
[17:42:44.641] Resolving globals: TRUE
[17:42:44.642] Resolving any globals that are futures ...
[17:42:44.642] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.642] Resolving any globals that are futures ... DONE
[17:42:44.642] Resolving futures part of globals (recursively) ...
[17:42:44.642] resolve() on list ...
[17:42:44.642]  recursive: 99
[17:42:44.643]  length: 1
[17:42:44.643]  elements: ‘a’
[17:42:44.643] resolved() for ‘SequentialFuture’ ...
[17:42:44.643] - state: ‘finished’
[17:42:44.643] - run: TRUE
[17:42:44.643] - result: ‘FutureResult’
[17:42:44.643] resolved() for ‘SequentialFuture’ ... done
[17:42:44.643] Future #1
[17:42:44.643] resolved() for ‘SequentialFuture’ ...
[17:42:44.644] - state: ‘finished’
[17:42:44.644] - run: TRUE
[17:42:44.644] - result: ‘FutureResult’
[17:42:44.644] resolved() for ‘SequentialFuture’ ... done
[17:42:44.644] A SequentialFuture was resolved
[17:42:44.644]  length: 0 (resolved future 1)
[17:42:44.644] resolve() on list ... DONE
[17:42:44.644] - globals: [1] ‘a’
[17:42:44.644] Resolving futures part of globals (recursively) ... DONE
[17:42:44.646] The total size of the 1 globals is 1.52 MiB (1595728 bytes)
[17:42:44.646] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[17:42:44.647] - globals: [1] ‘a’
[17:42:44.647] - packages: [1] ‘future’
[17:42:44.647] getGlobalsAndPackages() ... DONE
[17:42:44.647] run() for ‘Future’ ...
[17:42:44.647] - state: ‘created’
[17:42:44.647] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.648] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.648]   - Field: ‘label’
[17:42:44.648]   - Field: ‘local’
[17:42:44.648]   - Field: ‘owner’
[17:42:44.648]   - Field: ‘envir’
[17:42:44.648]   - Field: ‘packages’
[17:42:44.648]   - Field: ‘gc’
[17:42:44.648]   - Field: ‘conditions’
[17:42:44.649]   - Field: ‘expr’
[17:42:44.649]   - Field: ‘uuid’
[17:42:44.649]   - Field: ‘seed’
[17:42:44.649]   - Field: ‘version’
[17:42:44.649]   - Field: ‘result’
[17:42:44.649]   - Field: ‘asynchronous’
[17:42:44.649]   - Field: ‘calls’
[17:42:44.649]   - Field: ‘globals’
[17:42:44.649]   - Field: ‘stdout’
[17:42:44.649]   - Field: ‘earlySignal’
[17:42:44.650]   - Field: ‘lazy’
[17:42:44.650]   - Field: ‘state’
[17:42:44.650] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.650] - Launch lazy future ...
[17:42:44.650] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.650] Packages needed by future strategies (n = 0): <none>
[17:42:44.651] {
[17:42:44.651]     {
[17:42:44.651]         {
[17:42:44.651]             ...future.startTime <- base::Sys.time()
[17:42:44.651]             {
[17:42:44.651]                 {
[17:42:44.651]                   {
[17:42:44.651]                     {
[17:42:44.651]                       base::local({
[17:42:44.651]                         has_future <- base::requireNamespace("future", 
[17:42:44.651]                           quietly = TRUE)
[17:42:44.651]                         if (has_future) {
[17:42:44.651]                           ns <- base::getNamespace("future")
[17:42:44.651]                           version <- ns[[".package"]][["version"]]
[17:42:44.651]                           if (is.null(version)) 
[17:42:44.651]                             version <- utils::packageVersion("future")
[17:42:44.651]                         }
[17:42:44.651]                         else {
[17:42:44.651]                           version <- NULL
[17:42:44.651]                         }
[17:42:44.651]                         if (!has_future || version < "1.8.0") {
[17:42:44.651]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.651]                             "", base::R.version$version.string), 
[17:42:44.651]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.651]                               "release", "version")], collapse = " "), 
[17:42:44.651]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.651]                             info)
[17:42:44.651]                           info <- base::paste(info, collapse = "; ")
[17:42:44.651]                           if (!has_future) {
[17:42:44.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.651]                               info)
[17:42:44.651]                           }
[17:42:44.651]                           else {
[17:42:44.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.651]                               info, version)
[17:42:44.651]                           }
[17:42:44.651]                           base::stop(msg)
[17:42:44.651]                         }
[17:42:44.651]                       })
[17:42:44.651]                     }
[17:42:44.651]                     base::local({
[17:42:44.651]                       for (pkg in "future") {
[17:42:44.651]                         base::loadNamespace(pkg)
[17:42:44.651]                         base::library(pkg, character.only = TRUE)
[17:42:44.651]                       }
[17:42:44.651]                     })
[17:42:44.651]                   }
[17:42:44.651]                   options(future.plan = NULL)
[17:42:44.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.651]                 }
[17:42:44.651]                 ...future.workdir <- getwd()
[17:42:44.651]             }
[17:42:44.651]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.651]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.651]         }
[17:42:44.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.651]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.651]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.651]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.651]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.651]             base::names(...future.oldOptions))
[17:42:44.651]     }
[17:42:44.651]     if (FALSE) {
[17:42:44.651]     }
[17:42:44.651]     else {
[17:42:44.651]         if (TRUE) {
[17:42:44.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.651]                 open = "w")
[17:42:44.651]         }
[17:42:44.651]         else {
[17:42:44.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.651]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.651]         }
[17:42:44.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.651]             base::sink(type = "output", split = FALSE)
[17:42:44.651]             base::close(...future.stdout)
[17:42:44.651]         }, add = TRUE)
[17:42:44.651]     }
[17:42:44.651]     ...future.frame <- base::sys.nframe()
[17:42:44.651]     ...future.conditions <- base::list()
[17:42:44.651]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.651]     if (FALSE) {
[17:42:44.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.651]     }
[17:42:44.651]     ...future.result <- base::tryCatch({
[17:42:44.651]         base::withCallingHandlers({
[17:42:44.651]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.651]                 1))
[17:42:44.651]             future::FutureResult(value = ...future.value$value, 
[17:42:44.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.651]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.651]                     ...future.globalenv.names))
[17:42:44.651]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.651]         }, condition = base::local({
[17:42:44.651]             c <- base::c
[17:42:44.651]             inherits <- base::inherits
[17:42:44.651]             invokeRestart <- base::invokeRestart
[17:42:44.651]             length <- base::length
[17:42:44.651]             list <- base::list
[17:42:44.651]             seq.int <- base::seq.int
[17:42:44.651]             signalCondition <- base::signalCondition
[17:42:44.651]             sys.calls <- base::sys.calls
[17:42:44.651]             `[[` <- base::`[[`
[17:42:44.651]             `+` <- base::`+`
[17:42:44.651]             `<<-` <- base::`<<-`
[17:42:44.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.651]                   3L)]
[17:42:44.651]             }
[17:42:44.651]             function(cond) {
[17:42:44.651]                 is_error <- inherits(cond, "error")
[17:42:44.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.651]                   NULL)
[17:42:44.651]                 if (is_error) {
[17:42:44.651]                   sessionInformation <- function() {
[17:42:44.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.651]                       search = base::search(), system = base::Sys.info())
[17:42:44.651]                   }
[17:42:44.651]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.651]                     cond$call), session = sessionInformation(), 
[17:42:44.651]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.651]                   signalCondition(cond)
[17:42:44.651]                 }
[17:42:44.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.651]                 "immediateCondition"))) {
[17:42:44.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.651]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.651]                   if (TRUE && !signal) {
[17:42:44.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.651]                     {
[17:42:44.651]                       inherits <- base::inherits
[17:42:44.651]                       invokeRestart <- base::invokeRestart
[17:42:44.651]                       is.null <- base::is.null
[17:42:44.651]                       muffled <- FALSE
[17:42:44.651]                       if (inherits(cond, "message")) {
[17:42:44.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.651]                         if (muffled) 
[17:42:44.651]                           invokeRestart("muffleMessage")
[17:42:44.651]                       }
[17:42:44.651]                       else if (inherits(cond, "warning")) {
[17:42:44.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.651]                         if (muffled) 
[17:42:44.651]                           invokeRestart("muffleWarning")
[17:42:44.651]                       }
[17:42:44.651]                       else if (inherits(cond, "condition")) {
[17:42:44.651]                         if (!is.null(pattern)) {
[17:42:44.651]                           computeRestarts <- base::computeRestarts
[17:42:44.651]                           grepl <- base::grepl
[17:42:44.651]                           restarts <- computeRestarts(cond)
[17:42:44.651]                           for (restart in restarts) {
[17:42:44.651]                             name <- restart$name
[17:42:44.651]                             if (is.null(name)) 
[17:42:44.651]                               next
[17:42:44.651]                             if (!grepl(pattern, name)) 
[17:42:44.651]                               next
[17:42:44.651]                             invokeRestart(restart)
[17:42:44.651]                             muffled <- TRUE
[17:42:44.651]                             break
[17:42:44.651]                           }
[17:42:44.651]                         }
[17:42:44.651]                       }
[17:42:44.651]                       invisible(muffled)
[17:42:44.651]                     }
[17:42:44.651]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.651]                   }
[17:42:44.651]                 }
[17:42:44.651]                 else {
[17:42:44.651]                   if (TRUE) {
[17:42:44.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.651]                     {
[17:42:44.651]                       inherits <- base::inherits
[17:42:44.651]                       invokeRestart <- base::invokeRestart
[17:42:44.651]                       is.null <- base::is.null
[17:42:44.651]                       muffled <- FALSE
[17:42:44.651]                       if (inherits(cond, "message")) {
[17:42:44.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.651]                         if (muffled) 
[17:42:44.651]                           invokeRestart("muffleMessage")
[17:42:44.651]                       }
[17:42:44.651]                       else if (inherits(cond, "warning")) {
[17:42:44.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.651]                         if (muffled) 
[17:42:44.651]                           invokeRestart("muffleWarning")
[17:42:44.651]                       }
[17:42:44.651]                       else if (inherits(cond, "condition")) {
[17:42:44.651]                         if (!is.null(pattern)) {
[17:42:44.651]                           computeRestarts <- base::computeRestarts
[17:42:44.651]                           grepl <- base::grepl
[17:42:44.651]                           restarts <- computeRestarts(cond)
[17:42:44.651]                           for (restart in restarts) {
[17:42:44.651]                             name <- restart$name
[17:42:44.651]                             if (is.null(name)) 
[17:42:44.651]                               next
[17:42:44.651]                             if (!grepl(pattern, name)) 
[17:42:44.651]                               next
[17:42:44.651]                             invokeRestart(restart)
[17:42:44.651]                             muffled <- TRUE
[17:42:44.651]                             break
[17:42:44.651]                           }
[17:42:44.651]                         }
[17:42:44.651]                       }
[17:42:44.651]                       invisible(muffled)
[17:42:44.651]                     }
[17:42:44.651]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.651]                   }
[17:42:44.651]                 }
[17:42:44.651]             }
[17:42:44.651]         }))
[17:42:44.651]     }, error = function(ex) {
[17:42:44.651]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.651]                 ...future.rng), started = ...future.startTime, 
[17:42:44.651]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.651]             version = "1.8"), class = "FutureResult")
[17:42:44.651]     }, finally = {
[17:42:44.651]         if (!identical(...future.workdir, getwd())) 
[17:42:44.651]             setwd(...future.workdir)
[17:42:44.651]         {
[17:42:44.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.651]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.651]             }
[17:42:44.651]             base::options(...future.oldOptions)
[17:42:44.651]             if (.Platform$OS.type == "windows") {
[17:42:44.651]                 old_names <- names(...future.oldEnvVars)
[17:42:44.651]                 envs <- base::Sys.getenv()
[17:42:44.651]                 names <- names(envs)
[17:42:44.651]                 common <- intersect(names, old_names)
[17:42:44.651]                 added <- setdiff(names, old_names)
[17:42:44.651]                 removed <- setdiff(old_names, names)
[17:42:44.651]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.651]                   envs[common]]
[17:42:44.651]                 NAMES <- toupper(changed)
[17:42:44.651]                 args <- list()
[17:42:44.651]                 for (kk in seq_along(NAMES)) {
[17:42:44.651]                   name <- changed[[kk]]
[17:42:44.651]                   NAME <- NAMES[[kk]]
[17:42:44.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.651]                     next
[17:42:44.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.651]                 }
[17:42:44.651]                 NAMES <- toupper(added)
[17:42:44.651]                 for (kk in seq_along(NAMES)) {
[17:42:44.651]                   name <- added[[kk]]
[17:42:44.651]                   NAME <- NAMES[[kk]]
[17:42:44.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.651]                     next
[17:42:44.651]                   args[[name]] <- ""
[17:42:44.651]                 }
[17:42:44.651]                 NAMES <- toupper(removed)
[17:42:44.651]                 for (kk in seq_along(NAMES)) {
[17:42:44.651]                   name <- removed[[kk]]
[17:42:44.651]                   NAME <- NAMES[[kk]]
[17:42:44.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.651]                     next
[17:42:44.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.651]                 }
[17:42:44.651]                 if (length(args) > 0) 
[17:42:44.651]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.651]             }
[17:42:44.651]             else {
[17:42:44.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.651]             }
[17:42:44.651]             {
[17:42:44.651]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.651]                   0L) {
[17:42:44.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.651]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.651]                   base::options(opts)
[17:42:44.651]                 }
[17:42:44.651]                 {
[17:42:44.651]                   {
[17:42:44.651]                     NULL
[17:42:44.651]                     RNGkind("Mersenne-Twister")
[17:42:44.651]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.651]                       inherits = FALSE)
[17:42:44.651]                   }
[17:42:44.651]                   options(future.plan = NULL)
[17:42:44.651]                   if (is.na(NA_character_)) 
[17:42:44.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.651]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.651]                   {
[17:42:44.651]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.651]                     if (!future$lazy) 
[17:42:44.651]                       future <- run(future)
[17:42:44.651]                     invisible(future)
[17:42:44.651]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.651]                 }
[17:42:44.651]             }
[17:42:44.651]         }
[17:42:44.651]     })
[17:42:44.651]     if (TRUE) {
[17:42:44.651]         base::sink(type = "output", split = FALSE)
[17:42:44.651]         if (TRUE) {
[17:42:44.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.651]         }
[17:42:44.651]         else {
[17:42:44.651]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.651]         }
[17:42:44.651]         base::close(...future.stdout)
[17:42:44.651]         ...future.stdout <- NULL
[17:42:44.651]     }
[17:42:44.651]     ...future.result$conditions <- ...future.conditions
[17:42:44.651]     ...future.result$finished <- base::Sys.time()
[17:42:44.651]     ...future.result
[17:42:44.651] }
[17:42:44.652] assign_globals() ...
[17:42:44.653] List of 1
[17:42:44.653]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5618196954d8> 
[17:42:44.653]  - attr(*, "where")=List of 1
[17:42:44.653]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.653]  - attr(*, "resolved")= logi TRUE
[17:42:44.653]  - attr(*, "total_size")= num 1595728
[17:42:44.653]  - attr(*, "already-done")= logi TRUE
[17:42:44.655] - copied ‘a’ to environment
[17:42:44.655] assign_globals() ... done
[17:42:44.656] plan(): Setting new future strategy stack:
[17:42:44.656] List of future strategies:
[17:42:44.656] 1. sequential:
[17:42:44.656]    - args: function (..., envir = parent.frame())
[17:42:44.656]    - tweaked: FALSE
[17:42:44.656]    - call: NULL
[17:42:44.656] plan(): nbrOfWorkers() = 1
[17:42:44.657] plan(): Setting new future strategy stack:
[17:42:44.657] List of future strategies:
[17:42:44.657] 1. sequential:
[17:42:44.657]    - args: function (..., envir = parent.frame())
[17:42:44.657]    - tweaked: FALSE
[17:42:44.657]    - call: plan(strategy)
[17:42:44.659] plan(): nbrOfWorkers() = 1
[17:42:44.659] SequentialFuture started (and completed)
[17:42:44.659] - Launch lazy future ... done
[17:42:44.659] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.660] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.660] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.661] 
[17:42:44.661] Searching for globals ... DONE
[17:42:44.661] - globals: [0] <none>
[17:42:44.661] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.661] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.662] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.662] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.662] Searching for globals ... DONE
[17:42:44.662] Resolving globals: TRUE
[17:42:44.663] Resolving any globals that are futures ...
[17:42:44.663] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.663] Resolving any globals that are futures ... DONE
[17:42:44.663] Resolving futures part of globals (recursively) ...
[17:42:44.663] resolve() on list ...
[17:42:44.663]  recursive: 99
[17:42:44.664]  length: 1
[17:42:44.664]  elements: ‘a’
[17:42:44.664] run() for ‘Future’ ...
[17:42:44.664] - state: ‘created’
[17:42:44.664] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.664] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.664] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.664]   - Field: ‘label’
[17:42:44.665]   - Field: ‘local’
[17:42:44.665]   - Field: ‘owner’
[17:42:44.665]   - Field: ‘envir’
[17:42:44.665]   - Field: ‘packages’
[17:42:44.665]   - Field: ‘gc’
[17:42:44.665]   - Field: ‘conditions’
[17:42:44.665]   - Field: ‘expr’
[17:42:44.665]   - Field: ‘uuid’
[17:42:44.665]   - Field: ‘seed’
[17:42:44.665]   - Field: ‘version’
[17:42:44.665]   - Field: ‘result’
[17:42:44.666]   - Field: ‘asynchronous’
[17:42:44.666]   - Field: ‘calls’
[17:42:44.666]   - Field: ‘globals’
[17:42:44.666]   - Field: ‘stdout’
[17:42:44.666]   - Field: ‘earlySignal’
[17:42:44.666]   - Field: ‘lazy’
[17:42:44.666]   - Field: ‘state’
[17:42:44.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.666] - Launch lazy future ...
[17:42:44.666] Packages needed by the future expression (n = 0): <none>
[17:42:44.667] Packages needed by future strategies (n = 0): <none>
[17:42:44.667] {
[17:42:44.667]     {
[17:42:44.667]         {
[17:42:44.667]             ...future.startTime <- base::Sys.time()
[17:42:44.667]             {
[17:42:44.667]                 {
[17:42:44.667]                   {
[17:42:44.667]                     base::local({
[17:42:44.667]                       has_future <- base::requireNamespace("future", 
[17:42:44.667]                         quietly = TRUE)
[17:42:44.667]                       if (has_future) {
[17:42:44.667]                         ns <- base::getNamespace("future")
[17:42:44.667]                         version <- ns[[".package"]][["version"]]
[17:42:44.667]                         if (is.null(version)) 
[17:42:44.667]                           version <- utils::packageVersion("future")
[17:42:44.667]                       }
[17:42:44.667]                       else {
[17:42:44.667]                         version <- NULL
[17:42:44.667]                       }
[17:42:44.667]                       if (!has_future || version < "1.8.0") {
[17:42:44.667]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.667]                           "", base::R.version$version.string), 
[17:42:44.667]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.667]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.667]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.667]                             "release", "version")], collapse = " "), 
[17:42:44.667]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.667]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.667]                           info)
[17:42:44.667]                         info <- base::paste(info, collapse = "; ")
[17:42:44.667]                         if (!has_future) {
[17:42:44.667]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.667]                             info)
[17:42:44.667]                         }
[17:42:44.667]                         else {
[17:42:44.667]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.667]                             info, version)
[17:42:44.667]                         }
[17:42:44.667]                         base::stop(msg)
[17:42:44.667]                       }
[17:42:44.667]                     })
[17:42:44.667]                   }
[17:42:44.667]                   options(future.plan = NULL)
[17:42:44.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.667]                 }
[17:42:44.667]                 ...future.workdir <- getwd()
[17:42:44.667]             }
[17:42:44.667]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.667]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.667]         }
[17:42:44.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.667]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.667]             base::names(...future.oldOptions))
[17:42:44.667]     }
[17:42:44.667]     if (FALSE) {
[17:42:44.667]     }
[17:42:44.667]     else {
[17:42:44.667]         if (TRUE) {
[17:42:44.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.667]                 open = "w")
[17:42:44.667]         }
[17:42:44.667]         else {
[17:42:44.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.667]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.667]         }
[17:42:44.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.667]             base::sink(type = "output", split = FALSE)
[17:42:44.667]             base::close(...future.stdout)
[17:42:44.667]         }, add = TRUE)
[17:42:44.667]     }
[17:42:44.667]     ...future.frame <- base::sys.nframe()
[17:42:44.667]     ...future.conditions <- base::list()
[17:42:44.667]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.667]     if (FALSE) {
[17:42:44.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.667]     }
[17:42:44.667]     ...future.result <- base::tryCatch({
[17:42:44.667]         base::withCallingHandlers({
[17:42:44.667]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.667]             future::FutureResult(value = ...future.value$value, 
[17:42:44.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.667]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.667]                     ...future.globalenv.names))
[17:42:44.667]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.667]         }, condition = base::local({
[17:42:44.667]             c <- base::c
[17:42:44.667]             inherits <- base::inherits
[17:42:44.667]             invokeRestart <- base::invokeRestart
[17:42:44.667]             length <- base::length
[17:42:44.667]             list <- base::list
[17:42:44.667]             seq.int <- base::seq.int
[17:42:44.667]             signalCondition <- base::signalCondition
[17:42:44.667]             sys.calls <- base::sys.calls
[17:42:44.667]             `[[` <- base::`[[`
[17:42:44.667]             `+` <- base::`+`
[17:42:44.667]             `<<-` <- base::`<<-`
[17:42:44.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.667]                   3L)]
[17:42:44.667]             }
[17:42:44.667]             function(cond) {
[17:42:44.667]                 is_error <- inherits(cond, "error")
[17:42:44.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.667]                   NULL)
[17:42:44.667]                 if (is_error) {
[17:42:44.667]                   sessionInformation <- function() {
[17:42:44.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.667]                       search = base::search(), system = base::Sys.info())
[17:42:44.667]                   }
[17:42:44.667]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.667]                     cond$call), session = sessionInformation(), 
[17:42:44.667]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.667]                   signalCondition(cond)
[17:42:44.667]                 }
[17:42:44.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.667]                 "immediateCondition"))) {
[17:42:44.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.667]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.667]                   if (TRUE && !signal) {
[17:42:44.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.667]                     {
[17:42:44.667]                       inherits <- base::inherits
[17:42:44.667]                       invokeRestart <- base::invokeRestart
[17:42:44.667]                       is.null <- base::is.null
[17:42:44.667]                       muffled <- FALSE
[17:42:44.667]                       if (inherits(cond, "message")) {
[17:42:44.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.667]                         if (muffled) 
[17:42:44.667]                           invokeRestart("muffleMessage")
[17:42:44.667]                       }
[17:42:44.667]                       else if (inherits(cond, "warning")) {
[17:42:44.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.667]                         if (muffled) 
[17:42:44.667]                           invokeRestart("muffleWarning")
[17:42:44.667]                       }
[17:42:44.667]                       else if (inherits(cond, "condition")) {
[17:42:44.667]                         if (!is.null(pattern)) {
[17:42:44.667]                           computeRestarts <- base::computeRestarts
[17:42:44.667]                           grepl <- base::grepl
[17:42:44.667]                           restarts <- computeRestarts(cond)
[17:42:44.667]                           for (restart in restarts) {
[17:42:44.667]                             name <- restart$name
[17:42:44.667]                             if (is.null(name)) 
[17:42:44.667]                               next
[17:42:44.667]                             if (!grepl(pattern, name)) 
[17:42:44.667]                               next
[17:42:44.667]                             invokeRestart(restart)
[17:42:44.667]                             muffled <- TRUE
[17:42:44.667]                             break
[17:42:44.667]                           }
[17:42:44.667]                         }
[17:42:44.667]                       }
[17:42:44.667]                       invisible(muffled)
[17:42:44.667]                     }
[17:42:44.667]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.667]                   }
[17:42:44.667]                 }
[17:42:44.667]                 else {
[17:42:44.667]                   if (TRUE) {
[17:42:44.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.667]                     {
[17:42:44.667]                       inherits <- base::inherits
[17:42:44.667]                       invokeRestart <- base::invokeRestart
[17:42:44.667]                       is.null <- base::is.null
[17:42:44.667]                       muffled <- FALSE
[17:42:44.667]                       if (inherits(cond, "message")) {
[17:42:44.667]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.667]                         if (muffled) 
[17:42:44.667]                           invokeRestart("muffleMessage")
[17:42:44.667]                       }
[17:42:44.667]                       else if (inherits(cond, "warning")) {
[17:42:44.667]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.667]                         if (muffled) 
[17:42:44.667]                           invokeRestart("muffleWarning")
[17:42:44.667]                       }
[17:42:44.667]                       else if (inherits(cond, "condition")) {
[17:42:44.667]                         if (!is.null(pattern)) {
[17:42:44.667]                           computeRestarts <- base::computeRestarts
[17:42:44.667]                           grepl <- base::grepl
[17:42:44.667]                           restarts <- computeRestarts(cond)
[17:42:44.667]                           for (restart in restarts) {
[17:42:44.667]                             name <- restart$name
[17:42:44.667]                             if (is.null(name)) 
[17:42:44.667]                               next
[17:42:44.667]                             if (!grepl(pattern, name)) 
[17:42:44.667]                               next
[17:42:44.667]                             invokeRestart(restart)
[17:42:44.667]                             muffled <- TRUE
[17:42:44.667]                             break
[17:42:44.667]                           }
[17:42:44.667]                         }
[17:42:44.667]                       }
[17:42:44.667]                       invisible(muffled)
[17:42:44.667]                     }
[17:42:44.667]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.667]                   }
[17:42:44.667]                 }
[17:42:44.667]             }
[17:42:44.667]         }))
[17:42:44.667]     }, error = function(ex) {
[17:42:44.667]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.667]                 ...future.rng), started = ...future.startTime, 
[17:42:44.667]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.667]             version = "1.8"), class = "FutureResult")
[17:42:44.667]     }, finally = {
[17:42:44.667]         if (!identical(...future.workdir, getwd())) 
[17:42:44.667]             setwd(...future.workdir)
[17:42:44.667]         {
[17:42:44.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.667]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.667]             }
[17:42:44.667]             base::options(...future.oldOptions)
[17:42:44.667]             if (.Platform$OS.type == "windows") {
[17:42:44.667]                 old_names <- names(...future.oldEnvVars)
[17:42:44.667]                 envs <- base::Sys.getenv()
[17:42:44.667]                 names <- names(envs)
[17:42:44.667]                 common <- intersect(names, old_names)
[17:42:44.667]                 added <- setdiff(names, old_names)
[17:42:44.667]                 removed <- setdiff(old_names, names)
[17:42:44.667]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.667]                   envs[common]]
[17:42:44.667]                 NAMES <- toupper(changed)
[17:42:44.667]                 args <- list()
[17:42:44.667]                 for (kk in seq_along(NAMES)) {
[17:42:44.667]                   name <- changed[[kk]]
[17:42:44.667]                   NAME <- NAMES[[kk]]
[17:42:44.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.667]                     next
[17:42:44.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.667]                 }
[17:42:44.667]                 NAMES <- toupper(added)
[17:42:44.667]                 for (kk in seq_along(NAMES)) {
[17:42:44.667]                   name <- added[[kk]]
[17:42:44.667]                   NAME <- NAMES[[kk]]
[17:42:44.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.667]                     next
[17:42:44.667]                   args[[name]] <- ""
[17:42:44.667]                 }
[17:42:44.667]                 NAMES <- toupper(removed)
[17:42:44.667]                 for (kk in seq_along(NAMES)) {
[17:42:44.667]                   name <- removed[[kk]]
[17:42:44.667]                   NAME <- NAMES[[kk]]
[17:42:44.667]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.667]                     next
[17:42:44.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.667]                 }
[17:42:44.667]                 if (length(args) > 0) 
[17:42:44.667]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.667]             }
[17:42:44.667]             else {
[17:42:44.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.667]             }
[17:42:44.667]             {
[17:42:44.667]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.667]                   0L) {
[17:42:44.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.667]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.667]                   base::options(opts)
[17:42:44.667]                 }
[17:42:44.667]                 {
[17:42:44.667]                   {
[17:42:44.667]                     NULL
[17:42:44.667]                     RNGkind("Mersenne-Twister")
[17:42:44.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.667]                       inherits = FALSE)
[17:42:44.667]                   }
[17:42:44.667]                   options(future.plan = NULL)
[17:42:44.667]                   if (is.na(NA_character_)) 
[17:42:44.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.667]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.667]                   {
[17:42:44.667]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.667]                     if (!future$lazy) 
[17:42:44.667]                       future <- run(future)
[17:42:44.667]                     invisible(future)
[17:42:44.667]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.667]                 }
[17:42:44.667]             }
[17:42:44.667]         }
[17:42:44.667]     })
[17:42:44.667]     if (TRUE) {
[17:42:44.667]         base::sink(type = "output", split = FALSE)
[17:42:44.667]         if (TRUE) {
[17:42:44.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.667]         }
[17:42:44.667]         else {
[17:42:44.667]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.667]         }
[17:42:44.667]         base::close(...future.stdout)
[17:42:44.667]         ...future.stdout <- NULL
[17:42:44.667]     }
[17:42:44.667]     ...future.result$conditions <- ...future.conditions
[17:42:44.667]     ...future.result$finished <- base::Sys.time()
[17:42:44.667]     ...future.result
[17:42:44.667] }
[17:42:44.669] plan(): Setting new future strategy stack:
[17:42:44.669] List of future strategies:
[17:42:44.669] 1. sequential:
[17:42:44.669]    - args: function (..., envir = parent.frame())
[17:42:44.669]    - tweaked: FALSE
[17:42:44.669]    - call: NULL
[17:42:44.669] plan(): nbrOfWorkers() = 1
[17:42:44.670] plan(): Setting new future strategy stack:
[17:42:44.670] List of future strategies:
[17:42:44.670] 1. sequential:
[17:42:44.670]    - args: function (..., envir = parent.frame())
[17:42:44.670]    - tweaked: FALSE
[17:42:44.670]    - call: plan(strategy)
[17:42:44.670] plan(): nbrOfWorkers() = 1
[17:42:44.671] SequentialFuture started (and completed)
[17:42:44.671] - Launch lazy future ... done
[17:42:44.671] run() for ‘SequentialFuture’ ... done
[17:42:44.671] resolved() for ‘SequentialFuture’ ...
[17:42:44.671] - state: ‘finished’
[17:42:44.671] - run: TRUE
[17:42:44.671] - result: ‘FutureResult’
[17:42:44.671] resolved() for ‘SequentialFuture’ ... done
[17:42:44.671] Future #1
[17:42:44.672] resolved() for ‘SequentialFuture’ ...
[17:42:44.672] - state: ‘finished’
[17:42:44.672] - run: TRUE
[17:42:44.672] - result: ‘FutureResult’
[17:42:44.672] resolved() for ‘SequentialFuture’ ... done
[17:42:44.672] A SequentialFuture was resolved
[17:42:44.672]  length: 0 (resolved future 1)
[17:42:44.672] resolve() on list ... DONE
[17:42:44.672] - globals: [1] ‘a’
[17:42:44.672] Resolving futures part of globals (recursively) ... DONE
[17:42:44.674] The total size of the 1 globals is 1.52 MiB (1595896 bytes)
[17:42:44.674] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[17:42:44.675] - globals: [1] ‘a’
[17:42:44.675] - packages: [1] ‘future’
[17:42:44.675] getGlobalsAndPackages() ... DONE
[17:42:44.675] run() for ‘Future’ ...
[17:42:44.675] - state: ‘created’
[17:42:44.675] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.676] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.676]   - Field: ‘label’
[17:42:44.676]   - Field: ‘local’
[17:42:44.676]   - Field: ‘owner’
[17:42:44.676]   - Field: ‘envir’
[17:42:44.676]   - Field: ‘packages’
[17:42:44.676]   - Field: ‘gc’
[17:42:44.676]   - Field: ‘conditions’
[17:42:44.676]   - Field: ‘expr’
[17:42:44.677]   - Field: ‘uuid’
[17:42:44.677]   - Field: ‘seed’
[17:42:44.677]   - Field: ‘version’
[17:42:44.677]   - Field: ‘result’
[17:42:44.677]   - Field: ‘asynchronous’
[17:42:44.677]   - Field: ‘calls’
[17:42:44.677]   - Field: ‘globals’
[17:42:44.677]   - Field: ‘stdout’
[17:42:44.677]   - Field: ‘earlySignal’
[17:42:44.677]   - Field: ‘lazy’
[17:42:44.677]   - Field: ‘state’
[17:42:44.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.678] - Launch lazy future ...
[17:42:44.678] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.678] Packages needed by future strategies (n = 0): <none>
[17:42:44.678] {
[17:42:44.678]     {
[17:42:44.678]         {
[17:42:44.678]             ...future.startTime <- base::Sys.time()
[17:42:44.678]             {
[17:42:44.678]                 {
[17:42:44.678]                   {
[17:42:44.678]                     {
[17:42:44.678]                       base::local({
[17:42:44.678]                         has_future <- base::requireNamespace("future", 
[17:42:44.678]                           quietly = TRUE)
[17:42:44.678]                         if (has_future) {
[17:42:44.678]                           ns <- base::getNamespace("future")
[17:42:44.678]                           version <- ns[[".package"]][["version"]]
[17:42:44.678]                           if (is.null(version)) 
[17:42:44.678]                             version <- utils::packageVersion("future")
[17:42:44.678]                         }
[17:42:44.678]                         else {
[17:42:44.678]                           version <- NULL
[17:42:44.678]                         }
[17:42:44.678]                         if (!has_future || version < "1.8.0") {
[17:42:44.678]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.678]                             "", base::R.version$version.string), 
[17:42:44.678]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.678]                               "release", "version")], collapse = " "), 
[17:42:44.678]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.678]                             info)
[17:42:44.678]                           info <- base::paste(info, collapse = "; ")
[17:42:44.678]                           if (!has_future) {
[17:42:44.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.678]                               info)
[17:42:44.678]                           }
[17:42:44.678]                           else {
[17:42:44.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.678]                               info, version)
[17:42:44.678]                           }
[17:42:44.678]                           base::stop(msg)
[17:42:44.678]                         }
[17:42:44.678]                       })
[17:42:44.678]                     }
[17:42:44.678]                     base::local({
[17:42:44.678]                       for (pkg in "future") {
[17:42:44.678]                         base::loadNamespace(pkg)
[17:42:44.678]                         base::library(pkg, character.only = TRUE)
[17:42:44.678]                       }
[17:42:44.678]                     })
[17:42:44.678]                   }
[17:42:44.678]                   options(future.plan = NULL)
[17:42:44.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.678]                 }
[17:42:44.678]                 ...future.workdir <- getwd()
[17:42:44.678]             }
[17:42:44.678]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.678]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.678]         }
[17:42:44.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.678]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.678]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.678]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.678]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.678]             base::names(...future.oldOptions))
[17:42:44.678]     }
[17:42:44.678]     if (FALSE) {
[17:42:44.678]     }
[17:42:44.678]     else {
[17:42:44.678]         if (TRUE) {
[17:42:44.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.678]                 open = "w")
[17:42:44.678]         }
[17:42:44.678]         else {
[17:42:44.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.678]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.678]         }
[17:42:44.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.678]             base::sink(type = "output", split = FALSE)
[17:42:44.678]             base::close(...future.stdout)
[17:42:44.678]         }, add = TRUE)
[17:42:44.678]     }
[17:42:44.678]     ...future.frame <- base::sys.nframe()
[17:42:44.678]     ...future.conditions <- base::list()
[17:42:44.678]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.678]     if (FALSE) {
[17:42:44.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.678]     }
[17:42:44.678]     ...future.result <- base::tryCatch({
[17:42:44.678]         base::withCallingHandlers({
[17:42:44.678]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.678]                 1))
[17:42:44.678]             future::FutureResult(value = ...future.value$value, 
[17:42:44.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.678]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.678]                     ...future.globalenv.names))
[17:42:44.678]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.678]         }, condition = base::local({
[17:42:44.678]             c <- base::c
[17:42:44.678]             inherits <- base::inherits
[17:42:44.678]             invokeRestart <- base::invokeRestart
[17:42:44.678]             length <- base::length
[17:42:44.678]             list <- base::list
[17:42:44.678]             seq.int <- base::seq.int
[17:42:44.678]             signalCondition <- base::signalCondition
[17:42:44.678]             sys.calls <- base::sys.calls
[17:42:44.678]             `[[` <- base::`[[`
[17:42:44.678]             `+` <- base::`+`
[17:42:44.678]             `<<-` <- base::`<<-`
[17:42:44.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.678]                   3L)]
[17:42:44.678]             }
[17:42:44.678]             function(cond) {
[17:42:44.678]                 is_error <- inherits(cond, "error")
[17:42:44.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.678]                   NULL)
[17:42:44.678]                 if (is_error) {
[17:42:44.678]                   sessionInformation <- function() {
[17:42:44.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.678]                       search = base::search(), system = base::Sys.info())
[17:42:44.678]                   }
[17:42:44.678]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.678]                     cond$call), session = sessionInformation(), 
[17:42:44.678]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.678]                   signalCondition(cond)
[17:42:44.678]                 }
[17:42:44.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.678]                 "immediateCondition"))) {
[17:42:44.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.678]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.678]                   if (TRUE && !signal) {
[17:42:44.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.678]                     {
[17:42:44.678]                       inherits <- base::inherits
[17:42:44.678]                       invokeRestart <- base::invokeRestart
[17:42:44.678]                       is.null <- base::is.null
[17:42:44.678]                       muffled <- FALSE
[17:42:44.678]                       if (inherits(cond, "message")) {
[17:42:44.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.678]                         if (muffled) 
[17:42:44.678]                           invokeRestart("muffleMessage")
[17:42:44.678]                       }
[17:42:44.678]                       else if (inherits(cond, "warning")) {
[17:42:44.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.678]                         if (muffled) 
[17:42:44.678]                           invokeRestart("muffleWarning")
[17:42:44.678]                       }
[17:42:44.678]                       else if (inherits(cond, "condition")) {
[17:42:44.678]                         if (!is.null(pattern)) {
[17:42:44.678]                           computeRestarts <- base::computeRestarts
[17:42:44.678]                           grepl <- base::grepl
[17:42:44.678]                           restarts <- computeRestarts(cond)
[17:42:44.678]                           for (restart in restarts) {
[17:42:44.678]                             name <- restart$name
[17:42:44.678]                             if (is.null(name)) 
[17:42:44.678]                               next
[17:42:44.678]                             if (!grepl(pattern, name)) 
[17:42:44.678]                               next
[17:42:44.678]                             invokeRestart(restart)
[17:42:44.678]                             muffled <- TRUE
[17:42:44.678]                             break
[17:42:44.678]                           }
[17:42:44.678]                         }
[17:42:44.678]                       }
[17:42:44.678]                       invisible(muffled)
[17:42:44.678]                     }
[17:42:44.678]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.678]                   }
[17:42:44.678]                 }
[17:42:44.678]                 else {
[17:42:44.678]                   if (TRUE) {
[17:42:44.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.678]                     {
[17:42:44.678]                       inherits <- base::inherits
[17:42:44.678]                       invokeRestart <- base::invokeRestart
[17:42:44.678]                       is.null <- base::is.null
[17:42:44.678]                       muffled <- FALSE
[17:42:44.678]                       if (inherits(cond, "message")) {
[17:42:44.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.678]                         if (muffled) 
[17:42:44.678]                           invokeRestart("muffleMessage")
[17:42:44.678]                       }
[17:42:44.678]                       else if (inherits(cond, "warning")) {
[17:42:44.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.678]                         if (muffled) 
[17:42:44.678]                           invokeRestart("muffleWarning")
[17:42:44.678]                       }
[17:42:44.678]                       else if (inherits(cond, "condition")) {
[17:42:44.678]                         if (!is.null(pattern)) {
[17:42:44.678]                           computeRestarts <- base::computeRestarts
[17:42:44.678]                           grepl <- base::grepl
[17:42:44.678]                           restarts <- computeRestarts(cond)
[17:42:44.678]                           for (restart in restarts) {
[17:42:44.678]                             name <- restart$name
[17:42:44.678]                             if (is.null(name)) 
[17:42:44.678]                               next
[17:42:44.678]                             if (!grepl(pattern, name)) 
[17:42:44.678]                               next
[17:42:44.678]                             invokeRestart(restart)
[17:42:44.678]                             muffled <- TRUE
[17:42:44.678]                             break
[17:42:44.678]                           }
[17:42:44.678]                         }
[17:42:44.678]                       }
[17:42:44.678]                       invisible(muffled)
[17:42:44.678]                     }
[17:42:44.678]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.678]                   }
[17:42:44.678]                 }
[17:42:44.678]             }
[17:42:44.678]         }))
[17:42:44.678]     }, error = function(ex) {
[17:42:44.678]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.678]                 ...future.rng), started = ...future.startTime, 
[17:42:44.678]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.678]             version = "1.8"), class = "FutureResult")
[17:42:44.678]     }, finally = {
[17:42:44.678]         if (!identical(...future.workdir, getwd())) 
[17:42:44.678]             setwd(...future.workdir)
[17:42:44.678]         {
[17:42:44.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.678]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.678]             }
[17:42:44.678]             base::options(...future.oldOptions)
[17:42:44.678]             if (.Platform$OS.type == "windows") {
[17:42:44.678]                 old_names <- names(...future.oldEnvVars)
[17:42:44.678]                 envs <- base::Sys.getenv()
[17:42:44.678]                 names <- names(envs)
[17:42:44.678]                 common <- intersect(names, old_names)
[17:42:44.678]                 added <- setdiff(names, old_names)
[17:42:44.678]                 removed <- setdiff(old_names, names)
[17:42:44.678]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.678]                   envs[common]]
[17:42:44.678]                 NAMES <- toupper(changed)
[17:42:44.678]                 args <- list()
[17:42:44.678]                 for (kk in seq_along(NAMES)) {
[17:42:44.678]                   name <- changed[[kk]]
[17:42:44.678]                   NAME <- NAMES[[kk]]
[17:42:44.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.678]                     next
[17:42:44.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.678]                 }
[17:42:44.678]                 NAMES <- toupper(added)
[17:42:44.678]                 for (kk in seq_along(NAMES)) {
[17:42:44.678]                   name <- added[[kk]]
[17:42:44.678]                   NAME <- NAMES[[kk]]
[17:42:44.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.678]                     next
[17:42:44.678]                   args[[name]] <- ""
[17:42:44.678]                 }
[17:42:44.678]                 NAMES <- toupper(removed)
[17:42:44.678]                 for (kk in seq_along(NAMES)) {
[17:42:44.678]                   name <- removed[[kk]]
[17:42:44.678]                   NAME <- NAMES[[kk]]
[17:42:44.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.678]                     next
[17:42:44.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.678]                 }
[17:42:44.678]                 if (length(args) > 0) 
[17:42:44.678]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.678]             }
[17:42:44.678]             else {
[17:42:44.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.678]             }
[17:42:44.678]             {
[17:42:44.678]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.678]                   0L) {
[17:42:44.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.678]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.678]                   base::options(opts)
[17:42:44.678]                 }
[17:42:44.678]                 {
[17:42:44.678]                   {
[17:42:44.678]                     NULL
[17:42:44.678]                     RNGkind("Mersenne-Twister")
[17:42:44.678]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.678]                       inherits = FALSE)
[17:42:44.678]                   }
[17:42:44.678]                   options(future.plan = NULL)
[17:42:44.678]                   if (is.na(NA_character_)) 
[17:42:44.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.678]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.678]                   {
[17:42:44.678]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.678]                     if (!future$lazy) 
[17:42:44.678]                       future <- run(future)
[17:42:44.678]                     invisible(future)
[17:42:44.678]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.678]                 }
[17:42:44.678]             }
[17:42:44.678]         }
[17:42:44.678]     })
[17:42:44.678]     if (TRUE) {
[17:42:44.678]         base::sink(type = "output", split = FALSE)
[17:42:44.678]         if (TRUE) {
[17:42:44.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.678]         }
[17:42:44.678]         else {
[17:42:44.678]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.678]         }
[17:42:44.678]         base::close(...future.stdout)
[17:42:44.678]         ...future.stdout <- NULL
[17:42:44.678]     }
[17:42:44.678]     ...future.result$conditions <- ...future.conditions
[17:42:44.678]     ...future.result$finished <- base::Sys.time()
[17:42:44.678]     ...future.result
[17:42:44.678] }
[17:42:44.680] assign_globals() ...
[17:42:44.680] List of 1
[17:42:44.680]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x56181b0dfe78> 
[17:42:44.680]  - attr(*, "where")=List of 1
[17:42:44.680]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.680]  - attr(*, "resolved")= logi TRUE
[17:42:44.680]  - attr(*, "total_size")= num 1595896
[17:42:44.680]  - attr(*, "already-done")= logi TRUE
[17:42:44.682] - copied ‘a’ to environment
[17:42:44.683] assign_globals() ... done
[17:42:44.683] plan(): Setting new future strategy stack:
[17:42:44.683] List of future strategies:
[17:42:44.683] 1. sequential:
[17:42:44.683]    - args: function (..., envir = parent.frame())
[17:42:44.683]    - tweaked: FALSE
[17:42:44.683]    - call: NULL
[17:42:44.683] plan(): nbrOfWorkers() = 1
[17:42:44.684] plan(): Setting new future strategy stack:
[17:42:44.684] List of future strategies:
[17:42:44.684] 1. sequential:
[17:42:44.684]    - args: function (..., envir = parent.frame())
[17:42:44.684]    - tweaked: FALSE
[17:42:44.684]    - call: plan(strategy)
[17:42:44.685] plan(): nbrOfWorkers() = 1
[17:42:44.685] SequentialFuture started (and completed)
[17:42:44.685] - Launch lazy future ... done
[17:42:44.685] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.685] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.686] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.686] 
[17:42:44.686] Searching for globals ... DONE
[17:42:44.686] - globals: [0] <none>
[17:42:44.686] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.688] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.688] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.689] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:44.689] Searching for globals ... DONE
[17:42:44.689] Resolving globals: TRUE
[17:42:44.689] Resolving any globals that are futures ...
[17:42:44.689] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:44.689] Resolving any globals that are futures ... DONE
[17:42:44.690] Resolving futures part of globals (recursively) ...
[17:42:44.690] resolve() on list ...
[17:42:44.690]  recursive: 99
[17:42:44.690]  length: 1
[17:42:44.691]  elements: ‘a’
[17:42:44.691] run() for ‘Future’ ...
[17:42:44.691] - state: ‘created’
[17:42:44.691] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.691] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.692]   - Field: ‘label’
[17:42:44.692]   - Field: ‘local’
[17:42:44.692]   - Field: ‘owner’
[17:42:44.692]   - Field: ‘envir’
[17:42:44.692]   - Field: ‘packages’
[17:42:44.692]   - Field: ‘gc’
[17:42:44.692]   - Field: ‘conditions’
[17:42:44.692]   - Field: ‘expr’
[17:42:44.692]   - Field: ‘uuid’
[17:42:44.692]   - Field: ‘seed’
[17:42:44.692]   - Field: ‘version’
[17:42:44.693]   - Field: ‘result’
[17:42:44.693]   - Field: ‘asynchronous’
[17:42:44.693]   - Field: ‘calls’
[17:42:44.693]   - Field: ‘globals’
[17:42:44.693]   - Field: ‘stdout’
[17:42:44.693]   - Field: ‘earlySignal’
[17:42:44.693]   - Field: ‘lazy’
[17:42:44.693]   - Field: ‘state’
[17:42:44.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.693] - Launch lazy future ...
[17:42:44.694] Packages needed by the future expression (n = 0): <none>
[17:42:44.694] Packages needed by future strategies (n = 0): <none>
[17:42:44.694] {
[17:42:44.694]     {
[17:42:44.694]         {
[17:42:44.694]             ...future.startTime <- base::Sys.time()
[17:42:44.694]             {
[17:42:44.694]                 {
[17:42:44.694]                   {
[17:42:44.694]                     base::local({
[17:42:44.694]                       has_future <- base::requireNamespace("future", 
[17:42:44.694]                         quietly = TRUE)
[17:42:44.694]                       if (has_future) {
[17:42:44.694]                         ns <- base::getNamespace("future")
[17:42:44.694]                         version <- ns[[".package"]][["version"]]
[17:42:44.694]                         if (is.null(version)) 
[17:42:44.694]                           version <- utils::packageVersion("future")
[17:42:44.694]                       }
[17:42:44.694]                       else {
[17:42:44.694]                         version <- NULL
[17:42:44.694]                       }
[17:42:44.694]                       if (!has_future || version < "1.8.0") {
[17:42:44.694]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.694]                           "", base::R.version$version.string), 
[17:42:44.694]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.694]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.694]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.694]                             "release", "version")], collapse = " "), 
[17:42:44.694]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.694]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.694]                           info)
[17:42:44.694]                         info <- base::paste(info, collapse = "; ")
[17:42:44.694]                         if (!has_future) {
[17:42:44.694]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.694]                             info)
[17:42:44.694]                         }
[17:42:44.694]                         else {
[17:42:44.694]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.694]                             info, version)
[17:42:44.694]                         }
[17:42:44.694]                         base::stop(msg)
[17:42:44.694]                       }
[17:42:44.694]                     })
[17:42:44.694]                   }
[17:42:44.694]                   options(future.plan = NULL)
[17:42:44.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.694]                 }
[17:42:44.694]                 ...future.workdir <- getwd()
[17:42:44.694]             }
[17:42:44.694]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.694]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.694]         }
[17:42:44.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.694]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.694]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.694]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.694]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.694]             base::names(...future.oldOptions))
[17:42:44.694]     }
[17:42:44.694]     if (FALSE) {
[17:42:44.694]     }
[17:42:44.694]     else {
[17:42:44.694]         if (TRUE) {
[17:42:44.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.694]                 open = "w")
[17:42:44.694]         }
[17:42:44.694]         else {
[17:42:44.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.694]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.694]         }
[17:42:44.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.694]             base::sink(type = "output", split = FALSE)
[17:42:44.694]             base::close(...future.stdout)
[17:42:44.694]         }, add = TRUE)
[17:42:44.694]     }
[17:42:44.694]     ...future.frame <- base::sys.nframe()
[17:42:44.694]     ...future.conditions <- base::list()
[17:42:44.694]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.694]     if (FALSE) {
[17:42:44.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.694]     }
[17:42:44.694]     ...future.result <- base::tryCatch({
[17:42:44.694]         base::withCallingHandlers({
[17:42:44.694]             ...future.value <- base::withVisible(base::local(1))
[17:42:44.694]             future::FutureResult(value = ...future.value$value, 
[17:42:44.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.694]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.694]                     ...future.globalenv.names))
[17:42:44.694]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.694]         }, condition = base::local({
[17:42:44.694]             c <- base::c
[17:42:44.694]             inherits <- base::inherits
[17:42:44.694]             invokeRestart <- base::invokeRestart
[17:42:44.694]             length <- base::length
[17:42:44.694]             list <- base::list
[17:42:44.694]             seq.int <- base::seq.int
[17:42:44.694]             signalCondition <- base::signalCondition
[17:42:44.694]             sys.calls <- base::sys.calls
[17:42:44.694]             `[[` <- base::`[[`
[17:42:44.694]             `+` <- base::`+`
[17:42:44.694]             `<<-` <- base::`<<-`
[17:42:44.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.694]                   3L)]
[17:42:44.694]             }
[17:42:44.694]             function(cond) {
[17:42:44.694]                 is_error <- inherits(cond, "error")
[17:42:44.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.694]                   NULL)
[17:42:44.694]                 if (is_error) {
[17:42:44.694]                   sessionInformation <- function() {
[17:42:44.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.694]                       search = base::search(), system = base::Sys.info())
[17:42:44.694]                   }
[17:42:44.694]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.694]                     cond$call), session = sessionInformation(), 
[17:42:44.694]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.694]                   signalCondition(cond)
[17:42:44.694]                 }
[17:42:44.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.694]                 "immediateCondition"))) {
[17:42:44.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.694]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.694]                   if (TRUE && !signal) {
[17:42:44.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.694]                     {
[17:42:44.694]                       inherits <- base::inherits
[17:42:44.694]                       invokeRestart <- base::invokeRestart
[17:42:44.694]                       is.null <- base::is.null
[17:42:44.694]                       muffled <- FALSE
[17:42:44.694]                       if (inherits(cond, "message")) {
[17:42:44.694]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.694]                         if (muffled) 
[17:42:44.694]                           invokeRestart("muffleMessage")
[17:42:44.694]                       }
[17:42:44.694]                       else if (inherits(cond, "warning")) {
[17:42:44.694]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.694]                         if (muffled) 
[17:42:44.694]                           invokeRestart("muffleWarning")
[17:42:44.694]                       }
[17:42:44.694]                       else if (inherits(cond, "condition")) {
[17:42:44.694]                         if (!is.null(pattern)) {
[17:42:44.694]                           computeRestarts <- base::computeRestarts
[17:42:44.694]                           grepl <- base::grepl
[17:42:44.694]                           restarts <- computeRestarts(cond)
[17:42:44.694]                           for (restart in restarts) {
[17:42:44.694]                             name <- restart$name
[17:42:44.694]                             if (is.null(name)) 
[17:42:44.694]                               next
[17:42:44.694]                             if (!grepl(pattern, name)) 
[17:42:44.694]                               next
[17:42:44.694]                             invokeRestart(restart)
[17:42:44.694]                             muffled <- TRUE
[17:42:44.694]                             break
[17:42:44.694]                           }
[17:42:44.694]                         }
[17:42:44.694]                       }
[17:42:44.694]                       invisible(muffled)
[17:42:44.694]                     }
[17:42:44.694]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.694]                   }
[17:42:44.694]                 }
[17:42:44.694]                 else {
[17:42:44.694]                   if (TRUE) {
[17:42:44.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.694]                     {
[17:42:44.694]                       inherits <- base::inherits
[17:42:44.694]                       invokeRestart <- base::invokeRestart
[17:42:44.694]                       is.null <- base::is.null
[17:42:44.694]                       muffled <- FALSE
[17:42:44.694]                       if (inherits(cond, "message")) {
[17:42:44.694]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.694]                         if (muffled) 
[17:42:44.694]                           invokeRestart("muffleMessage")
[17:42:44.694]                       }
[17:42:44.694]                       else if (inherits(cond, "warning")) {
[17:42:44.694]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.694]                         if (muffled) 
[17:42:44.694]                           invokeRestart("muffleWarning")
[17:42:44.694]                       }
[17:42:44.694]                       else if (inherits(cond, "condition")) {
[17:42:44.694]                         if (!is.null(pattern)) {
[17:42:44.694]                           computeRestarts <- base::computeRestarts
[17:42:44.694]                           grepl <- base::grepl
[17:42:44.694]                           restarts <- computeRestarts(cond)
[17:42:44.694]                           for (restart in restarts) {
[17:42:44.694]                             name <- restart$name
[17:42:44.694]                             if (is.null(name)) 
[17:42:44.694]                               next
[17:42:44.694]                             if (!grepl(pattern, name)) 
[17:42:44.694]                               next
[17:42:44.694]                             invokeRestart(restart)
[17:42:44.694]                             muffled <- TRUE
[17:42:44.694]                             break
[17:42:44.694]                           }
[17:42:44.694]                         }
[17:42:44.694]                       }
[17:42:44.694]                       invisible(muffled)
[17:42:44.694]                     }
[17:42:44.694]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.694]                   }
[17:42:44.694]                 }
[17:42:44.694]             }
[17:42:44.694]         }))
[17:42:44.694]     }, error = function(ex) {
[17:42:44.694]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.694]                 ...future.rng), started = ...future.startTime, 
[17:42:44.694]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.694]             version = "1.8"), class = "FutureResult")
[17:42:44.694]     }, finally = {
[17:42:44.694]         if (!identical(...future.workdir, getwd())) 
[17:42:44.694]             setwd(...future.workdir)
[17:42:44.694]         {
[17:42:44.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.694]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.694]             }
[17:42:44.694]             base::options(...future.oldOptions)
[17:42:44.694]             if (.Platform$OS.type == "windows") {
[17:42:44.694]                 old_names <- names(...future.oldEnvVars)
[17:42:44.694]                 envs <- base::Sys.getenv()
[17:42:44.694]                 names <- names(envs)
[17:42:44.694]                 common <- intersect(names, old_names)
[17:42:44.694]                 added <- setdiff(names, old_names)
[17:42:44.694]                 removed <- setdiff(old_names, names)
[17:42:44.694]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.694]                   envs[common]]
[17:42:44.694]                 NAMES <- toupper(changed)
[17:42:44.694]                 args <- list()
[17:42:44.694]                 for (kk in seq_along(NAMES)) {
[17:42:44.694]                   name <- changed[[kk]]
[17:42:44.694]                   NAME <- NAMES[[kk]]
[17:42:44.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.694]                     next
[17:42:44.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.694]                 }
[17:42:44.694]                 NAMES <- toupper(added)
[17:42:44.694]                 for (kk in seq_along(NAMES)) {
[17:42:44.694]                   name <- added[[kk]]
[17:42:44.694]                   NAME <- NAMES[[kk]]
[17:42:44.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.694]                     next
[17:42:44.694]                   args[[name]] <- ""
[17:42:44.694]                 }
[17:42:44.694]                 NAMES <- toupper(removed)
[17:42:44.694]                 for (kk in seq_along(NAMES)) {
[17:42:44.694]                   name <- removed[[kk]]
[17:42:44.694]                   NAME <- NAMES[[kk]]
[17:42:44.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.694]                     next
[17:42:44.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.694]                 }
[17:42:44.694]                 if (length(args) > 0) 
[17:42:44.694]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.694]             }
[17:42:44.694]             else {
[17:42:44.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.694]             }
[17:42:44.694]             {
[17:42:44.694]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.694]                   0L) {
[17:42:44.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.694]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.694]                   base::options(opts)
[17:42:44.694]                 }
[17:42:44.694]                 {
[17:42:44.694]                   {
[17:42:44.694]                     NULL
[17:42:44.694]                     RNGkind("Mersenne-Twister")
[17:42:44.694]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.694]                       inherits = FALSE)
[17:42:44.694]                   }
[17:42:44.694]                   options(future.plan = NULL)
[17:42:44.694]                   if (is.na(NA_character_)) 
[17:42:44.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.694]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.694]                   {
[17:42:44.694]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.694]                     if (!future$lazy) 
[17:42:44.694]                       future <- run(future)
[17:42:44.694]                     invisible(future)
[17:42:44.694]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.694]                 }
[17:42:44.694]             }
[17:42:44.694]         }
[17:42:44.694]     })
[17:42:44.694]     if (TRUE) {
[17:42:44.694]         base::sink(type = "output", split = FALSE)
[17:42:44.694]         if (TRUE) {
[17:42:44.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.694]         }
[17:42:44.694]         else {
[17:42:44.694]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.694]         }
[17:42:44.694]         base::close(...future.stdout)
[17:42:44.694]         ...future.stdout <- NULL
[17:42:44.694]     }
[17:42:44.694]     ...future.result$conditions <- ...future.conditions
[17:42:44.694]     ...future.result$finished <- base::Sys.time()
[17:42:44.694]     ...future.result
[17:42:44.694] }
[17:42:44.696] plan(): Setting new future strategy stack:
[17:42:44.696] List of future strategies:
[17:42:44.696] 1. sequential:
[17:42:44.696]    - args: function (..., envir = parent.frame())
[17:42:44.696]    - tweaked: FALSE
[17:42:44.696]    - call: NULL
[17:42:44.696] plan(): nbrOfWorkers() = 1
[17:42:44.697] plan(): Setting new future strategy stack:
[17:42:44.697] List of future strategies:
[17:42:44.697] 1. sequential:
[17:42:44.697]    - args: function (..., envir = parent.frame())
[17:42:44.697]    - tweaked: FALSE
[17:42:44.697]    - call: plan(strategy)
[17:42:44.698] plan(): nbrOfWorkers() = 1
[17:42:44.698] SequentialFuture started (and completed)
[17:42:44.698] - Launch lazy future ... done
[17:42:44.698] run() for ‘SequentialFuture’ ... done
[17:42:44.698] resolved() for ‘SequentialFuture’ ...
[17:42:44.698] - state: ‘finished’
[17:42:44.698] - run: TRUE
[17:42:44.698] - result: ‘FutureResult’
[17:42:44.698] resolved() for ‘SequentialFuture’ ... done
[17:42:44.699] Future #1
[17:42:44.699] resolved() for ‘SequentialFuture’ ...
[17:42:44.699] - state: ‘finished’
[17:42:44.699] - run: TRUE
[17:42:44.699] - result: ‘FutureResult’
[17:42:44.699] resolved() for ‘SequentialFuture’ ... done
[17:42:44.699] A SequentialFuture was resolved
[17:42:44.699]  length: 0 (resolved future 1)
[17:42:44.699] resolve() on list ... DONE
[17:42:44.700] - globals: [1] ‘a’
[17:42:44.700] Resolving futures part of globals (recursively) ... DONE
[17:42:44.702] The total size of the 1 globals is 1.52 MiB (1595896 bytes)
[17:42:44.702] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.52 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.52 MiB of class ‘environment’)
[17:42:44.702] - globals: [1] ‘a’
[17:42:44.702] - packages: [1] ‘future’
[17:42:44.702] getGlobalsAndPackages() ... DONE
[17:42:44.703] run() for ‘Future’ ...
[17:42:44.703] - state: ‘created’
[17:42:44.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.703]   - Field: ‘label’
[17:42:44.703]   - Field: ‘local’
[17:42:44.704]   - Field: ‘owner’
[17:42:44.704]   - Field: ‘envir’
[17:42:44.704]   - Field: ‘packages’
[17:42:44.704]   - Field: ‘gc’
[17:42:44.704]   - Field: ‘conditions’
[17:42:44.704]   - Field: ‘expr’
[17:42:44.704]   - Field: ‘uuid’
[17:42:44.704]   - Field: ‘seed’
[17:42:44.704]   - Field: ‘version’
[17:42:44.704]   - Field: ‘result’
[17:42:44.705]   - Field: ‘asynchronous’
[17:42:44.705]   - Field: ‘calls’
[17:42:44.705]   - Field: ‘globals’
[17:42:44.705]   - Field: ‘stdout’
[17:42:44.705]   - Field: ‘earlySignal’
[17:42:44.705]   - Field: ‘lazy’
[17:42:44.705]   - Field: ‘state’
[17:42:44.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.705] - Launch lazy future ...
[17:42:44.706] Packages needed by the future expression (n = 1): ‘future’
[17:42:44.706] Packages needed by future strategies (n = 0): <none>
[17:42:44.706] {
[17:42:44.706]     {
[17:42:44.706]         {
[17:42:44.706]             ...future.startTime <- base::Sys.time()
[17:42:44.706]             {
[17:42:44.706]                 {
[17:42:44.706]                   {
[17:42:44.706]                     {
[17:42:44.706]                       base::local({
[17:42:44.706]                         has_future <- base::requireNamespace("future", 
[17:42:44.706]                           quietly = TRUE)
[17:42:44.706]                         if (has_future) {
[17:42:44.706]                           ns <- base::getNamespace("future")
[17:42:44.706]                           version <- ns[[".package"]][["version"]]
[17:42:44.706]                           if (is.null(version)) 
[17:42:44.706]                             version <- utils::packageVersion("future")
[17:42:44.706]                         }
[17:42:44.706]                         else {
[17:42:44.706]                           version <- NULL
[17:42:44.706]                         }
[17:42:44.706]                         if (!has_future || version < "1.8.0") {
[17:42:44.706]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.706]                             "", base::R.version$version.string), 
[17:42:44.706]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.706]                               "release", "version")], collapse = " "), 
[17:42:44.706]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.706]                             info)
[17:42:44.706]                           info <- base::paste(info, collapse = "; ")
[17:42:44.706]                           if (!has_future) {
[17:42:44.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.706]                               info)
[17:42:44.706]                           }
[17:42:44.706]                           else {
[17:42:44.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.706]                               info, version)
[17:42:44.706]                           }
[17:42:44.706]                           base::stop(msg)
[17:42:44.706]                         }
[17:42:44.706]                       })
[17:42:44.706]                     }
[17:42:44.706]                     base::local({
[17:42:44.706]                       for (pkg in "future") {
[17:42:44.706]                         base::loadNamespace(pkg)
[17:42:44.706]                         base::library(pkg, character.only = TRUE)
[17:42:44.706]                       }
[17:42:44.706]                     })
[17:42:44.706]                   }
[17:42:44.706]                   options(future.plan = NULL)
[17:42:44.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.706]                 }
[17:42:44.706]                 ...future.workdir <- getwd()
[17:42:44.706]             }
[17:42:44.706]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.706]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.706]         }
[17:42:44.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.706]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.706]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.706]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.706]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.706]             base::names(...future.oldOptions))
[17:42:44.706]     }
[17:42:44.706]     if (FALSE) {
[17:42:44.706]     }
[17:42:44.706]     else {
[17:42:44.706]         if (TRUE) {
[17:42:44.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.706]                 open = "w")
[17:42:44.706]         }
[17:42:44.706]         else {
[17:42:44.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.706]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.706]         }
[17:42:44.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.706]             base::sink(type = "output", split = FALSE)
[17:42:44.706]             base::close(...future.stdout)
[17:42:44.706]         }, add = TRUE)
[17:42:44.706]     }
[17:42:44.706]     ...future.frame <- base::sys.nframe()
[17:42:44.706]     ...future.conditions <- base::list()
[17:42:44.706]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.706]     if (FALSE) {
[17:42:44.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.706]     }
[17:42:44.706]     ...future.result <- base::tryCatch({
[17:42:44.706]         base::withCallingHandlers({
[17:42:44.706]             ...future.value <- base::withVisible(base::local(value(a) + 
[17:42:44.706]                 1))
[17:42:44.706]             future::FutureResult(value = ...future.value$value, 
[17:42:44.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.706]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.706]                     ...future.globalenv.names))
[17:42:44.706]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.706]         }, condition = base::local({
[17:42:44.706]             c <- base::c
[17:42:44.706]             inherits <- base::inherits
[17:42:44.706]             invokeRestart <- base::invokeRestart
[17:42:44.706]             length <- base::length
[17:42:44.706]             list <- base::list
[17:42:44.706]             seq.int <- base::seq.int
[17:42:44.706]             signalCondition <- base::signalCondition
[17:42:44.706]             sys.calls <- base::sys.calls
[17:42:44.706]             `[[` <- base::`[[`
[17:42:44.706]             `+` <- base::`+`
[17:42:44.706]             `<<-` <- base::`<<-`
[17:42:44.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.706]                   3L)]
[17:42:44.706]             }
[17:42:44.706]             function(cond) {
[17:42:44.706]                 is_error <- inherits(cond, "error")
[17:42:44.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.706]                   NULL)
[17:42:44.706]                 if (is_error) {
[17:42:44.706]                   sessionInformation <- function() {
[17:42:44.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.706]                       search = base::search(), system = base::Sys.info())
[17:42:44.706]                   }
[17:42:44.706]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.706]                     cond$call), session = sessionInformation(), 
[17:42:44.706]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.706]                   signalCondition(cond)
[17:42:44.706]                 }
[17:42:44.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.706]                 "immediateCondition"))) {
[17:42:44.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.706]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.706]                   if (TRUE && !signal) {
[17:42:44.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.706]                     {
[17:42:44.706]                       inherits <- base::inherits
[17:42:44.706]                       invokeRestart <- base::invokeRestart
[17:42:44.706]                       is.null <- base::is.null
[17:42:44.706]                       muffled <- FALSE
[17:42:44.706]                       if (inherits(cond, "message")) {
[17:42:44.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.706]                         if (muffled) 
[17:42:44.706]                           invokeRestart("muffleMessage")
[17:42:44.706]                       }
[17:42:44.706]                       else if (inherits(cond, "warning")) {
[17:42:44.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.706]                         if (muffled) 
[17:42:44.706]                           invokeRestart("muffleWarning")
[17:42:44.706]                       }
[17:42:44.706]                       else if (inherits(cond, "condition")) {
[17:42:44.706]                         if (!is.null(pattern)) {
[17:42:44.706]                           computeRestarts <- base::computeRestarts
[17:42:44.706]                           grepl <- base::grepl
[17:42:44.706]                           restarts <- computeRestarts(cond)
[17:42:44.706]                           for (restart in restarts) {
[17:42:44.706]                             name <- restart$name
[17:42:44.706]                             if (is.null(name)) 
[17:42:44.706]                               next
[17:42:44.706]                             if (!grepl(pattern, name)) 
[17:42:44.706]                               next
[17:42:44.706]                             invokeRestart(restart)
[17:42:44.706]                             muffled <- TRUE
[17:42:44.706]                             break
[17:42:44.706]                           }
[17:42:44.706]                         }
[17:42:44.706]                       }
[17:42:44.706]                       invisible(muffled)
[17:42:44.706]                     }
[17:42:44.706]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.706]                   }
[17:42:44.706]                 }
[17:42:44.706]                 else {
[17:42:44.706]                   if (TRUE) {
[17:42:44.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.706]                     {
[17:42:44.706]                       inherits <- base::inherits
[17:42:44.706]                       invokeRestart <- base::invokeRestart
[17:42:44.706]                       is.null <- base::is.null
[17:42:44.706]                       muffled <- FALSE
[17:42:44.706]                       if (inherits(cond, "message")) {
[17:42:44.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.706]                         if (muffled) 
[17:42:44.706]                           invokeRestart("muffleMessage")
[17:42:44.706]                       }
[17:42:44.706]                       else if (inherits(cond, "warning")) {
[17:42:44.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.706]                         if (muffled) 
[17:42:44.706]                           invokeRestart("muffleWarning")
[17:42:44.706]                       }
[17:42:44.706]                       else if (inherits(cond, "condition")) {
[17:42:44.706]                         if (!is.null(pattern)) {
[17:42:44.706]                           computeRestarts <- base::computeRestarts
[17:42:44.706]                           grepl <- base::grepl
[17:42:44.706]                           restarts <- computeRestarts(cond)
[17:42:44.706]                           for (restart in restarts) {
[17:42:44.706]                             name <- restart$name
[17:42:44.706]                             if (is.null(name)) 
[17:42:44.706]                               next
[17:42:44.706]                             if (!grepl(pattern, name)) 
[17:42:44.706]                               next
[17:42:44.706]                             invokeRestart(restart)
[17:42:44.706]                             muffled <- TRUE
[17:42:44.706]                             break
[17:42:44.706]                           }
[17:42:44.706]                         }
[17:42:44.706]                       }
[17:42:44.706]                       invisible(muffled)
[17:42:44.706]                     }
[17:42:44.706]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.706]                   }
[17:42:44.706]                 }
[17:42:44.706]             }
[17:42:44.706]         }))
[17:42:44.706]     }, error = function(ex) {
[17:42:44.706]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.706]                 ...future.rng), started = ...future.startTime, 
[17:42:44.706]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.706]             version = "1.8"), class = "FutureResult")
[17:42:44.706]     }, finally = {
[17:42:44.706]         if (!identical(...future.workdir, getwd())) 
[17:42:44.706]             setwd(...future.workdir)
[17:42:44.706]         {
[17:42:44.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.706]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.706]             }
[17:42:44.706]             base::options(...future.oldOptions)
[17:42:44.706]             if (.Platform$OS.type == "windows") {
[17:42:44.706]                 old_names <- names(...future.oldEnvVars)
[17:42:44.706]                 envs <- base::Sys.getenv()
[17:42:44.706]                 names <- names(envs)
[17:42:44.706]                 common <- intersect(names, old_names)
[17:42:44.706]                 added <- setdiff(names, old_names)
[17:42:44.706]                 removed <- setdiff(old_names, names)
[17:42:44.706]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.706]                   envs[common]]
[17:42:44.706]                 NAMES <- toupper(changed)
[17:42:44.706]                 args <- list()
[17:42:44.706]                 for (kk in seq_along(NAMES)) {
[17:42:44.706]                   name <- changed[[kk]]
[17:42:44.706]                   NAME <- NAMES[[kk]]
[17:42:44.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.706]                     next
[17:42:44.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.706]                 }
[17:42:44.706]                 NAMES <- toupper(added)
[17:42:44.706]                 for (kk in seq_along(NAMES)) {
[17:42:44.706]                   name <- added[[kk]]
[17:42:44.706]                   NAME <- NAMES[[kk]]
[17:42:44.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.706]                     next
[17:42:44.706]                   args[[name]] <- ""
[17:42:44.706]                 }
[17:42:44.706]                 NAMES <- toupper(removed)
[17:42:44.706]                 for (kk in seq_along(NAMES)) {
[17:42:44.706]                   name <- removed[[kk]]
[17:42:44.706]                   NAME <- NAMES[[kk]]
[17:42:44.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.706]                     next
[17:42:44.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.706]                 }
[17:42:44.706]                 if (length(args) > 0) 
[17:42:44.706]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.706]             }
[17:42:44.706]             else {
[17:42:44.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.706]             }
[17:42:44.706]             {
[17:42:44.706]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.706]                   0L) {
[17:42:44.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.706]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.706]                   base::options(opts)
[17:42:44.706]                 }
[17:42:44.706]                 {
[17:42:44.706]                   {
[17:42:44.706]                     NULL
[17:42:44.706]                     RNGkind("Mersenne-Twister")
[17:42:44.706]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.706]                       inherits = FALSE)
[17:42:44.706]                   }
[17:42:44.706]                   options(future.plan = NULL)
[17:42:44.706]                   if (is.na(NA_character_)) 
[17:42:44.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.706]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.706]                   {
[17:42:44.706]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.706]                     if (!future$lazy) 
[17:42:44.706]                       future <- run(future)
[17:42:44.706]                     invisible(future)
[17:42:44.706]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.706]                 }
[17:42:44.706]             }
[17:42:44.706]         }
[17:42:44.706]     })
[17:42:44.706]     if (TRUE) {
[17:42:44.706]         base::sink(type = "output", split = FALSE)
[17:42:44.706]         if (TRUE) {
[17:42:44.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.706]         }
[17:42:44.706]         else {
[17:42:44.706]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.706]         }
[17:42:44.706]         base::close(...future.stdout)
[17:42:44.706]         ...future.stdout <- NULL
[17:42:44.706]     }
[17:42:44.706]     ...future.result$conditions <- ...future.conditions
[17:42:44.706]     ...future.result$finished <- base::Sys.time()
[17:42:44.706]     ...future.result
[17:42:44.706] }
[17:42:44.708] assign_globals() ...
[17:42:44.708] List of 1
[17:42:44.708]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x5618197ccf88> 
[17:42:44.708]  - attr(*, "where")=List of 1
[17:42:44.708]   ..$ a:<environment: R_EmptyEnv> 
[17:42:44.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.708]  - attr(*, "resolved")= logi TRUE
[17:42:44.708]  - attr(*, "total_size")= num 1595896
[17:42:44.708]  - attr(*, "already-done")= logi TRUE
[17:42:44.711] - copied ‘a’ to environment
[17:42:44.711] assign_globals() ... done
[17:42:44.711] plan(): Setting new future strategy stack:
[17:42:44.711] List of future strategies:
[17:42:44.711] 1. sequential:
[17:42:44.711]    - args: function (..., envir = parent.frame())
[17:42:44.711]    - tweaked: FALSE
[17:42:44.711]    - call: NULL
[17:42:44.712] plan(): nbrOfWorkers() = 1
[17:42:44.713] plan(): Setting new future strategy stack:
[17:42:44.713] List of future strategies:
[17:42:44.713] 1. sequential:
[17:42:44.713]    - args: function (..., envir = parent.frame())
[17:42:44.713]    - tweaked: FALSE
[17:42:44.713]    - call: plan(strategy)
[17:42:44.713] plan(): nbrOfWorkers() = 1
[17:42:44.713] SequentialFuture started (and completed)
[17:42:44.713] - Launch lazy future ... done
[17:42:44.713] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.714] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.714] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.715] - globals found: [2] ‘{’, ‘pkg’
[17:42:44.715] Searching for globals ... DONE
[17:42:44.715] Resolving globals: TRUE
[17:42:44.715] Resolving any globals that are futures ...
[17:42:44.715] - globals: [2] ‘{’, ‘pkg’
[17:42:44.715] Resolving any globals that are futures ... DONE
[17:42:44.716] Resolving futures part of globals (recursively) ...
[17:42:44.716] resolve() on list ...
[17:42:44.716]  recursive: 99
[17:42:44.716]  length: 1
[17:42:44.716]  elements: ‘pkg’
[17:42:44.716]  length: 0 (resolved future 1)
[17:42:44.716] resolve() on list ... DONE
[17:42:44.718] - globals: [1] ‘pkg’
[17:42:44.719] Resolving futures part of globals (recursively) ... DONE
[17:42:44.719] The total size of the 1 globals is 112 bytes (112 bytes)
[17:42:44.719] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:42:44.720] - globals: [1] ‘pkg’
[17:42:44.720] 
[17:42:44.720] getGlobalsAndPackages() ... DONE
[17:42:44.720] Packages needed by the future expression (n = 0): <none>
[17:42:44.720] Packages needed by future strategies (n = 0): <none>
[17:42:44.721] {
[17:42:44.721]     {
[17:42:44.721]         {
[17:42:44.721]             ...future.startTime <- base::Sys.time()
[17:42:44.721]             {
[17:42:44.721]                 {
[17:42:44.721]                   {
[17:42:44.721]                     base::local({
[17:42:44.721]                       has_future <- base::requireNamespace("future", 
[17:42:44.721]                         quietly = TRUE)
[17:42:44.721]                       if (has_future) {
[17:42:44.721]                         ns <- base::getNamespace("future")
[17:42:44.721]                         version <- ns[[".package"]][["version"]]
[17:42:44.721]                         if (is.null(version)) 
[17:42:44.721]                           version <- utils::packageVersion("future")
[17:42:44.721]                       }
[17:42:44.721]                       else {
[17:42:44.721]                         version <- NULL
[17:42:44.721]                       }
[17:42:44.721]                       if (!has_future || version < "1.8.0") {
[17:42:44.721]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.721]                           "", base::R.version$version.string), 
[17:42:44.721]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.721]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.721]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.721]                             "release", "version")], collapse = " "), 
[17:42:44.721]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.721]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.721]                           info)
[17:42:44.721]                         info <- base::paste(info, collapse = "; ")
[17:42:44.721]                         if (!has_future) {
[17:42:44.721]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.721]                             info)
[17:42:44.721]                         }
[17:42:44.721]                         else {
[17:42:44.721]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.721]                             info, version)
[17:42:44.721]                         }
[17:42:44.721]                         base::stop(msg)
[17:42:44.721]                       }
[17:42:44.721]                     })
[17:42:44.721]                   }
[17:42:44.721]                   options(future.plan = NULL)
[17:42:44.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.721]                 }
[17:42:44.721]                 ...future.workdir <- getwd()
[17:42:44.721]             }
[17:42:44.721]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.721]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.721]         }
[17:42:44.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.721]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.721]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.721]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.721]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.721]             base::names(...future.oldOptions))
[17:42:44.721]     }
[17:42:44.721]     if (FALSE) {
[17:42:44.721]     }
[17:42:44.721]     else {
[17:42:44.721]         if (TRUE) {
[17:42:44.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.721]                 open = "w")
[17:42:44.721]         }
[17:42:44.721]         else {
[17:42:44.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.721]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.721]         }
[17:42:44.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.721]             base::sink(type = "output", split = FALSE)
[17:42:44.721]             base::close(...future.stdout)
[17:42:44.721]         }, add = TRUE)
[17:42:44.721]     }
[17:42:44.721]     ...future.frame <- base::sys.nframe()
[17:42:44.721]     ...future.conditions <- base::list()
[17:42:44.721]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.721]     if (FALSE) {
[17:42:44.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.721]     }
[17:42:44.721]     ...future.result <- base::tryCatch({
[17:42:44.721]         base::withCallingHandlers({
[17:42:44.721]             ...future.value <- base::withVisible(base::local({
[17:42:44.721]                 pkg
[17:42:44.721]             }))
[17:42:44.721]             future::FutureResult(value = ...future.value$value, 
[17:42:44.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.721]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.721]                     ...future.globalenv.names))
[17:42:44.721]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.721]         }, condition = base::local({
[17:42:44.721]             c <- base::c
[17:42:44.721]             inherits <- base::inherits
[17:42:44.721]             invokeRestart <- base::invokeRestart
[17:42:44.721]             length <- base::length
[17:42:44.721]             list <- base::list
[17:42:44.721]             seq.int <- base::seq.int
[17:42:44.721]             signalCondition <- base::signalCondition
[17:42:44.721]             sys.calls <- base::sys.calls
[17:42:44.721]             `[[` <- base::`[[`
[17:42:44.721]             `+` <- base::`+`
[17:42:44.721]             `<<-` <- base::`<<-`
[17:42:44.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.721]                   3L)]
[17:42:44.721]             }
[17:42:44.721]             function(cond) {
[17:42:44.721]                 is_error <- inherits(cond, "error")
[17:42:44.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.721]                   NULL)
[17:42:44.721]                 if (is_error) {
[17:42:44.721]                   sessionInformation <- function() {
[17:42:44.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.721]                       search = base::search(), system = base::Sys.info())
[17:42:44.721]                   }
[17:42:44.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.721]                     cond$call), session = sessionInformation(), 
[17:42:44.721]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.721]                   signalCondition(cond)
[17:42:44.721]                 }
[17:42:44.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.721]                 "immediateCondition"))) {
[17:42:44.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.721]                   if (TRUE && !signal) {
[17:42:44.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.721]                     {
[17:42:44.721]                       inherits <- base::inherits
[17:42:44.721]                       invokeRestart <- base::invokeRestart
[17:42:44.721]                       is.null <- base::is.null
[17:42:44.721]                       muffled <- FALSE
[17:42:44.721]                       if (inherits(cond, "message")) {
[17:42:44.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.721]                         if (muffled) 
[17:42:44.721]                           invokeRestart("muffleMessage")
[17:42:44.721]                       }
[17:42:44.721]                       else if (inherits(cond, "warning")) {
[17:42:44.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.721]                         if (muffled) 
[17:42:44.721]                           invokeRestart("muffleWarning")
[17:42:44.721]                       }
[17:42:44.721]                       else if (inherits(cond, "condition")) {
[17:42:44.721]                         if (!is.null(pattern)) {
[17:42:44.721]                           computeRestarts <- base::computeRestarts
[17:42:44.721]                           grepl <- base::grepl
[17:42:44.721]                           restarts <- computeRestarts(cond)
[17:42:44.721]                           for (restart in restarts) {
[17:42:44.721]                             name <- restart$name
[17:42:44.721]                             if (is.null(name)) 
[17:42:44.721]                               next
[17:42:44.721]                             if (!grepl(pattern, name)) 
[17:42:44.721]                               next
[17:42:44.721]                             invokeRestart(restart)
[17:42:44.721]                             muffled <- TRUE
[17:42:44.721]                             break
[17:42:44.721]                           }
[17:42:44.721]                         }
[17:42:44.721]                       }
[17:42:44.721]                       invisible(muffled)
[17:42:44.721]                     }
[17:42:44.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.721]                   }
[17:42:44.721]                 }
[17:42:44.721]                 else {
[17:42:44.721]                   if (TRUE) {
[17:42:44.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.721]                     {
[17:42:44.721]                       inherits <- base::inherits
[17:42:44.721]                       invokeRestart <- base::invokeRestart
[17:42:44.721]                       is.null <- base::is.null
[17:42:44.721]                       muffled <- FALSE
[17:42:44.721]                       if (inherits(cond, "message")) {
[17:42:44.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.721]                         if (muffled) 
[17:42:44.721]                           invokeRestart("muffleMessage")
[17:42:44.721]                       }
[17:42:44.721]                       else if (inherits(cond, "warning")) {
[17:42:44.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.721]                         if (muffled) 
[17:42:44.721]                           invokeRestart("muffleWarning")
[17:42:44.721]                       }
[17:42:44.721]                       else if (inherits(cond, "condition")) {
[17:42:44.721]                         if (!is.null(pattern)) {
[17:42:44.721]                           computeRestarts <- base::computeRestarts
[17:42:44.721]                           grepl <- base::grepl
[17:42:44.721]                           restarts <- computeRestarts(cond)
[17:42:44.721]                           for (restart in restarts) {
[17:42:44.721]                             name <- restart$name
[17:42:44.721]                             if (is.null(name)) 
[17:42:44.721]                               next
[17:42:44.721]                             if (!grepl(pattern, name)) 
[17:42:44.721]                               next
[17:42:44.721]                             invokeRestart(restart)
[17:42:44.721]                             muffled <- TRUE
[17:42:44.721]                             break
[17:42:44.721]                           }
[17:42:44.721]                         }
[17:42:44.721]                       }
[17:42:44.721]                       invisible(muffled)
[17:42:44.721]                     }
[17:42:44.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.721]                   }
[17:42:44.721]                 }
[17:42:44.721]             }
[17:42:44.721]         }))
[17:42:44.721]     }, error = function(ex) {
[17:42:44.721]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.721]                 ...future.rng), started = ...future.startTime, 
[17:42:44.721]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.721]             version = "1.8"), class = "FutureResult")
[17:42:44.721]     }, finally = {
[17:42:44.721]         if (!identical(...future.workdir, getwd())) 
[17:42:44.721]             setwd(...future.workdir)
[17:42:44.721]         {
[17:42:44.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.721]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.721]             }
[17:42:44.721]             base::options(...future.oldOptions)
[17:42:44.721]             if (.Platform$OS.type == "windows") {
[17:42:44.721]                 old_names <- names(...future.oldEnvVars)
[17:42:44.721]                 envs <- base::Sys.getenv()
[17:42:44.721]                 names <- names(envs)
[17:42:44.721]                 common <- intersect(names, old_names)
[17:42:44.721]                 added <- setdiff(names, old_names)
[17:42:44.721]                 removed <- setdiff(old_names, names)
[17:42:44.721]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.721]                   envs[common]]
[17:42:44.721]                 NAMES <- toupper(changed)
[17:42:44.721]                 args <- list()
[17:42:44.721]                 for (kk in seq_along(NAMES)) {
[17:42:44.721]                   name <- changed[[kk]]
[17:42:44.721]                   NAME <- NAMES[[kk]]
[17:42:44.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.721]                     next
[17:42:44.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.721]                 }
[17:42:44.721]                 NAMES <- toupper(added)
[17:42:44.721]                 for (kk in seq_along(NAMES)) {
[17:42:44.721]                   name <- added[[kk]]
[17:42:44.721]                   NAME <- NAMES[[kk]]
[17:42:44.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.721]                     next
[17:42:44.721]                   args[[name]] <- ""
[17:42:44.721]                 }
[17:42:44.721]                 NAMES <- toupper(removed)
[17:42:44.721]                 for (kk in seq_along(NAMES)) {
[17:42:44.721]                   name <- removed[[kk]]
[17:42:44.721]                   NAME <- NAMES[[kk]]
[17:42:44.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.721]                     next
[17:42:44.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.721]                 }
[17:42:44.721]                 if (length(args) > 0) 
[17:42:44.721]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.721]             }
[17:42:44.721]             else {
[17:42:44.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.721]             }
[17:42:44.721]             {
[17:42:44.721]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.721]                   0L) {
[17:42:44.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.721]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.721]                   base::options(opts)
[17:42:44.721]                 }
[17:42:44.721]                 {
[17:42:44.721]                   {
[17:42:44.721]                     NULL
[17:42:44.721]                     RNGkind("Mersenne-Twister")
[17:42:44.721]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.721]                       inherits = FALSE)
[17:42:44.721]                   }
[17:42:44.721]                   options(future.plan = NULL)
[17:42:44.721]                   if (is.na(NA_character_)) 
[17:42:44.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.721]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.721]                   {
[17:42:44.721]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.721]                     if (!future$lazy) 
[17:42:44.721]                       future <- run(future)
[17:42:44.721]                     invisible(future)
[17:42:44.721]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.721]                 }
[17:42:44.721]             }
[17:42:44.721]         }
[17:42:44.721]     })
[17:42:44.721]     if (TRUE) {
[17:42:44.721]         base::sink(type = "output", split = FALSE)
[17:42:44.721]         if (TRUE) {
[17:42:44.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.721]         }
[17:42:44.721]         else {
[17:42:44.721]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.721]         }
[17:42:44.721]         base::close(...future.stdout)
[17:42:44.721]         ...future.stdout <- NULL
[17:42:44.721]     }
[17:42:44.721]     ...future.result$conditions <- ...future.conditions
[17:42:44.721]     ...future.result$finished <- base::Sys.time()
[17:42:44.721]     ...future.result
[17:42:44.721] }
[17:42:44.723] assign_globals() ...
[17:42:44.723] List of 1
[17:42:44.723]  $ pkg: chr "foo"
[17:42:44.723]  - attr(*, "where")=List of 1
[17:42:44.723]   ..$ pkg:<environment: R_EmptyEnv> 
[17:42:44.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.723]  - attr(*, "resolved")= logi TRUE
[17:42:44.723]  - attr(*, "total_size")= num 112
[17:42:44.726] - copied ‘pkg’ to environment
[17:42:44.726] assign_globals() ... done
[17:42:44.726] plan(): Setting new future strategy stack:
[17:42:44.726] List of future strategies:
[17:42:44.726] 1. sequential:
[17:42:44.726]    - args: function (..., envir = parent.frame())
[17:42:44.726]    - tweaked: FALSE
[17:42:44.726]    - call: NULL
[17:42:44.726] plan(): nbrOfWorkers() = 1
[17:42:44.727] plan(): Setting new future strategy stack:
[17:42:44.727] List of future strategies:
[17:42:44.727] 1. sequential:
[17:42:44.727]    - args: function (..., envir = parent.frame())
[17:42:44.727]    - tweaked: FALSE
[17:42:44.727]    - call: plan(strategy)
[17:42:44.728] plan(): nbrOfWorkers() = 1
[17:42:44.728] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.728] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.728] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.730] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:42:44.730] Searching for globals ... DONE
[17:42:44.731] Resolving globals: TRUE
[17:42:44.731] Resolving any globals that are futures ...
[17:42:44.731] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:42:44.731] Resolving any globals that are futures ... DONE
[17:42:44.731] 
[17:42:44.731] 
[17:42:44.731] getGlobalsAndPackages() ... DONE
[17:42:44.732] run() for ‘Future’ ...
[17:42:44.732] - state: ‘created’
[17:42:44.732] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.732] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.732]   - Field: ‘label’
[17:42:44.732]   - Field: ‘local’
[17:42:44.733]   - Field: ‘owner’
[17:42:44.733]   - Field: ‘envir’
[17:42:44.733]   - Field: ‘packages’
[17:42:44.733]   - Field: ‘gc’
[17:42:44.733]   - Field: ‘conditions’
[17:42:44.733]   - Field: ‘expr’
[17:42:44.733]   - Field: ‘uuid’
[17:42:44.733]   - Field: ‘seed’
[17:42:44.733]   - Field: ‘version’
[17:42:44.733]   - Field: ‘result’
[17:42:44.734]   - Field: ‘asynchronous’
[17:42:44.734]   - Field: ‘calls’
[17:42:44.734]   - Field: ‘globals’
[17:42:44.734]   - Field: ‘stdout’
[17:42:44.734]   - Field: ‘earlySignal’
[17:42:44.734]   - Field: ‘lazy’
[17:42:44.734]   - Field: ‘state’
[17:42:44.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.734] - Launch lazy future ...
[17:42:44.734] Packages needed by the future expression (n = 0): <none>
[17:42:44.735] Packages needed by future strategies (n = 0): <none>
[17:42:44.735] {
[17:42:44.735]     {
[17:42:44.735]         {
[17:42:44.735]             ...future.startTime <- base::Sys.time()
[17:42:44.735]             {
[17:42:44.735]                 {
[17:42:44.735]                   {
[17:42:44.735]                     base::local({
[17:42:44.735]                       has_future <- base::requireNamespace("future", 
[17:42:44.735]                         quietly = TRUE)
[17:42:44.735]                       if (has_future) {
[17:42:44.735]                         ns <- base::getNamespace("future")
[17:42:44.735]                         version <- ns[[".package"]][["version"]]
[17:42:44.735]                         if (is.null(version)) 
[17:42:44.735]                           version <- utils::packageVersion("future")
[17:42:44.735]                       }
[17:42:44.735]                       else {
[17:42:44.735]                         version <- NULL
[17:42:44.735]                       }
[17:42:44.735]                       if (!has_future || version < "1.8.0") {
[17:42:44.735]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.735]                           "", base::R.version$version.string), 
[17:42:44.735]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.735]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.735]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.735]                             "release", "version")], collapse = " "), 
[17:42:44.735]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.735]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.735]                           info)
[17:42:44.735]                         info <- base::paste(info, collapse = "; ")
[17:42:44.735]                         if (!has_future) {
[17:42:44.735]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.735]                             info)
[17:42:44.735]                         }
[17:42:44.735]                         else {
[17:42:44.735]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.735]                             info, version)
[17:42:44.735]                         }
[17:42:44.735]                         base::stop(msg)
[17:42:44.735]                       }
[17:42:44.735]                     })
[17:42:44.735]                   }
[17:42:44.735]                   options(future.plan = NULL)
[17:42:44.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.735]                 }
[17:42:44.735]                 ...future.workdir <- getwd()
[17:42:44.735]             }
[17:42:44.735]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.735]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.735]         }
[17:42:44.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.735]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.735]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.735]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.735]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.735]             base::names(...future.oldOptions))
[17:42:44.735]     }
[17:42:44.735]     if (FALSE) {
[17:42:44.735]     }
[17:42:44.735]     else {
[17:42:44.735]         if (TRUE) {
[17:42:44.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.735]                 open = "w")
[17:42:44.735]         }
[17:42:44.735]         else {
[17:42:44.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.735]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.735]         }
[17:42:44.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.735]             base::sink(type = "output", split = FALSE)
[17:42:44.735]             base::close(...future.stdout)
[17:42:44.735]         }, add = TRUE)
[17:42:44.735]     }
[17:42:44.735]     ...future.frame <- base::sys.nframe()
[17:42:44.735]     ...future.conditions <- base::list()
[17:42:44.735]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.735]     if (FALSE) {
[17:42:44.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.735]     }
[17:42:44.735]     ...future.result <- base::tryCatch({
[17:42:44.735]         base::withCallingHandlers({
[17:42:44.735]             ...future.value <- base::withVisible(base::local({
[17:42:44.735]                 x <- 0
[17:42:44.735]                 x <- x + 1
[17:42:44.735]                 x
[17:42:44.735]             }))
[17:42:44.735]             future::FutureResult(value = ...future.value$value, 
[17:42:44.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.735]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.735]                     ...future.globalenv.names))
[17:42:44.735]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.735]         }, condition = base::local({
[17:42:44.735]             c <- base::c
[17:42:44.735]             inherits <- base::inherits
[17:42:44.735]             invokeRestart <- base::invokeRestart
[17:42:44.735]             length <- base::length
[17:42:44.735]             list <- base::list
[17:42:44.735]             seq.int <- base::seq.int
[17:42:44.735]             signalCondition <- base::signalCondition
[17:42:44.735]             sys.calls <- base::sys.calls
[17:42:44.735]             `[[` <- base::`[[`
[17:42:44.735]             `+` <- base::`+`
[17:42:44.735]             `<<-` <- base::`<<-`
[17:42:44.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.735]                   3L)]
[17:42:44.735]             }
[17:42:44.735]             function(cond) {
[17:42:44.735]                 is_error <- inherits(cond, "error")
[17:42:44.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.735]                   NULL)
[17:42:44.735]                 if (is_error) {
[17:42:44.735]                   sessionInformation <- function() {
[17:42:44.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.735]                       search = base::search(), system = base::Sys.info())
[17:42:44.735]                   }
[17:42:44.735]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.735]                     cond$call), session = sessionInformation(), 
[17:42:44.735]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.735]                   signalCondition(cond)
[17:42:44.735]                 }
[17:42:44.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.735]                 "immediateCondition"))) {
[17:42:44.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.735]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.735]                   if (TRUE && !signal) {
[17:42:44.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.735]                     {
[17:42:44.735]                       inherits <- base::inherits
[17:42:44.735]                       invokeRestart <- base::invokeRestart
[17:42:44.735]                       is.null <- base::is.null
[17:42:44.735]                       muffled <- FALSE
[17:42:44.735]                       if (inherits(cond, "message")) {
[17:42:44.735]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.735]                         if (muffled) 
[17:42:44.735]                           invokeRestart("muffleMessage")
[17:42:44.735]                       }
[17:42:44.735]                       else if (inherits(cond, "warning")) {
[17:42:44.735]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.735]                         if (muffled) 
[17:42:44.735]                           invokeRestart("muffleWarning")
[17:42:44.735]                       }
[17:42:44.735]                       else if (inherits(cond, "condition")) {
[17:42:44.735]                         if (!is.null(pattern)) {
[17:42:44.735]                           computeRestarts <- base::computeRestarts
[17:42:44.735]                           grepl <- base::grepl
[17:42:44.735]                           restarts <- computeRestarts(cond)
[17:42:44.735]                           for (restart in restarts) {
[17:42:44.735]                             name <- restart$name
[17:42:44.735]                             if (is.null(name)) 
[17:42:44.735]                               next
[17:42:44.735]                             if (!grepl(pattern, name)) 
[17:42:44.735]                               next
[17:42:44.735]                             invokeRestart(restart)
[17:42:44.735]                             muffled <- TRUE
[17:42:44.735]                             break
[17:42:44.735]                           }
[17:42:44.735]                         }
[17:42:44.735]                       }
[17:42:44.735]                       invisible(muffled)
[17:42:44.735]                     }
[17:42:44.735]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.735]                   }
[17:42:44.735]                 }
[17:42:44.735]                 else {
[17:42:44.735]                   if (TRUE) {
[17:42:44.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.735]                     {
[17:42:44.735]                       inherits <- base::inherits
[17:42:44.735]                       invokeRestart <- base::invokeRestart
[17:42:44.735]                       is.null <- base::is.null
[17:42:44.735]                       muffled <- FALSE
[17:42:44.735]                       if (inherits(cond, "message")) {
[17:42:44.735]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.735]                         if (muffled) 
[17:42:44.735]                           invokeRestart("muffleMessage")
[17:42:44.735]                       }
[17:42:44.735]                       else if (inherits(cond, "warning")) {
[17:42:44.735]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.735]                         if (muffled) 
[17:42:44.735]                           invokeRestart("muffleWarning")
[17:42:44.735]                       }
[17:42:44.735]                       else if (inherits(cond, "condition")) {
[17:42:44.735]                         if (!is.null(pattern)) {
[17:42:44.735]                           computeRestarts <- base::computeRestarts
[17:42:44.735]                           grepl <- base::grepl
[17:42:44.735]                           restarts <- computeRestarts(cond)
[17:42:44.735]                           for (restart in restarts) {
[17:42:44.735]                             name <- restart$name
[17:42:44.735]                             if (is.null(name)) 
[17:42:44.735]                               next
[17:42:44.735]                             if (!grepl(pattern, name)) 
[17:42:44.735]                               next
[17:42:44.735]                             invokeRestart(restart)
[17:42:44.735]                             muffled <- TRUE
[17:42:44.735]                             break
[17:42:44.735]                           }
[17:42:44.735]                         }
[17:42:44.735]                       }
[17:42:44.735]                       invisible(muffled)
[17:42:44.735]                     }
[17:42:44.735]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.735]                   }
[17:42:44.735]                 }
[17:42:44.735]             }
[17:42:44.735]         }))
[17:42:44.735]     }, error = function(ex) {
[17:42:44.735]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.735]                 ...future.rng), started = ...future.startTime, 
[17:42:44.735]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.735]             version = "1.8"), class = "FutureResult")
[17:42:44.735]     }, finally = {
[17:42:44.735]         if (!identical(...future.workdir, getwd())) 
[17:42:44.735]             setwd(...future.workdir)
[17:42:44.735]         {
[17:42:44.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.735]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.735]             }
[17:42:44.735]             base::options(...future.oldOptions)
[17:42:44.735]             if (.Platform$OS.type == "windows") {
[17:42:44.735]                 old_names <- names(...future.oldEnvVars)
[17:42:44.735]                 envs <- base::Sys.getenv()
[17:42:44.735]                 names <- names(envs)
[17:42:44.735]                 common <- intersect(names, old_names)
[17:42:44.735]                 added <- setdiff(names, old_names)
[17:42:44.735]                 removed <- setdiff(old_names, names)
[17:42:44.735]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.735]                   envs[common]]
[17:42:44.735]                 NAMES <- toupper(changed)
[17:42:44.735]                 args <- list()
[17:42:44.735]                 for (kk in seq_along(NAMES)) {
[17:42:44.735]                   name <- changed[[kk]]
[17:42:44.735]                   NAME <- NAMES[[kk]]
[17:42:44.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.735]                     next
[17:42:44.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.735]                 }
[17:42:44.735]                 NAMES <- toupper(added)
[17:42:44.735]                 for (kk in seq_along(NAMES)) {
[17:42:44.735]                   name <- added[[kk]]
[17:42:44.735]                   NAME <- NAMES[[kk]]
[17:42:44.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.735]                     next
[17:42:44.735]                   args[[name]] <- ""
[17:42:44.735]                 }
[17:42:44.735]                 NAMES <- toupper(removed)
[17:42:44.735]                 for (kk in seq_along(NAMES)) {
[17:42:44.735]                   name <- removed[[kk]]
[17:42:44.735]                   NAME <- NAMES[[kk]]
[17:42:44.735]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.735]                     next
[17:42:44.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.735]                 }
[17:42:44.735]                 if (length(args) > 0) 
[17:42:44.735]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.735]             }
[17:42:44.735]             else {
[17:42:44.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.735]             }
[17:42:44.735]             {
[17:42:44.735]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.735]                   0L) {
[17:42:44.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.735]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.735]                   base::options(opts)
[17:42:44.735]                 }
[17:42:44.735]                 {
[17:42:44.735]                   {
[17:42:44.735]                     NULL
[17:42:44.735]                     RNGkind("Mersenne-Twister")
[17:42:44.735]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.735]                       inherits = FALSE)
[17:42:44.735]                   }
[17:42:44.735]                   options(future.plan = NULL)
[17:42:44.735]                   if (is.na(NA_character_)) 
[17:42:44.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.735]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.735]                   {
[17:42:44.735]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.735]                     if (!future$lazy) 
[17:42:44.735]                       future <- run(future)
[17:42:44.735]                     invisible(future)
[17:42:44.735]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.735]                 }
[17:42:44.735]             }
[17:42:44.735]         }
[17:42:44.735]     })
[17:42:44.735]     if (TRUE) {
[17:42:44.735]         base::sink(type = "output", split = FALSE)
[17:42:44.735]         if (TRUE) {
[17:42:44.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.735]         }
[17:42:44.735]         else {
[17:42:44.735]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.735]         }
[17:42:44.735]         base::close(...future.stdout)
[17:42:44.735]         ...future.stdout <- NULL
[17:42:44.735]     }
[17:42:44.735]     ...future.result$conditions <- ...future.conditions
[17:42:44.735]     ...future.result$finished <- base::Sys.time()
[17:42:44.735]     ...future.result
[17:42:44.735] }
[17:42:44.737] plan(): Setting new future strategy stack:
[17:42:44.737] List of future strategies:
[17:42:44.737] 1. sequential:
[17:42:44.737]    - args: function (..., envir = parent.frame())
[17:42:44.737]    - tweaked: FALSE
[17:42:44.737]    - call: NULL
[17:42:44.738] plan(): nbrOfWorkers() = 1
[17:42:44.738] plan(): Setting new future strategy stack:
[17:42:44.738] List of future strategies:
[17:42:44.738] 1. sequential:
[17:42:44.738]    - args: function (..., envir = parent.frame())
[17:42:44.738]    - tweaked: FALSE
[17:42:44.738]    - call: plan(strategy)
[17:42:44.739] plan(): nbrOfWorkers() = 1
[17:42:44.739] SequentialFuture started (and completed)
[17:42:44.739] - Launch lazy future ... done
[17:42:44.739] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.740] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.740] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.741] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:42:44.741] Searching for globals ... DONE
[17:42:44.742] Resolving globals: TRUE
[17:42:44.742] Resolving any globals that are futures ...
[17:42:44.742] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:42:44.742] Resolving any globals that are futures ... DONE
[17:42:44.742] Resolving futures part of globals (recursively) ...
[17:42:44.742] resolve() on list ...
[17:42:44.743]  recursive: 99
[17:42:44.743]  length: 1
[17:42:44.743]  elements: ‘x’
[17:42:44.743]  length: 0 (resolved future 1)
[17:42:44.743] resolve() on list ... DONE
[17:42:44.743] - globals: [1] ‘x’
[17:42:44.743] Resolving futures part of globals (recursively) ... DONE
[17:42:44.743] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.744] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:42:44.744] - globals: [1] ‘x’
[17:42:44.744] 
[17:42:44.744] getGlobalsAndPackages() ... DONE
[17:42:44.744] run() for ‘Future’ ...
[17:42:44.744] - state: ‘created’
[17:42:44.745] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.745] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.745] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.745]   - Field: ‘label’
[17:42:44.745]   - Field: ‘local’
[17:42:44.745]   - Field: ‘owner’
[17:42:44.745]   - Field: ‘envir’
[17:42:44.745]   - Field: ‘packages’
[17:42:44.746]   - Field: ‘gc’
[17:42:44.746]   - Field: ‘conditions’
[17:42:44.746]   - Field: ‘expr’
[17:42:44.746]   - Field: ‘uuid’
[17:42:44.746]   - Field: ‘seed’
[17:42:44.746]   - Field: ‘version’
[17:42:44.746]   - Field: ‘result’
[17:42:44.746]   - Field: ‘asynchronous’
[17:42:44.746]   - Field: ‘calls’
[17:42:44.746]   - Field: ‘globals’
[17:42:44.747]   - Field: ‘stdout’
[17:42:44.747]   - Field: ‘earlySignal’
[17:42:44.747]   - Field: ‘lazy’
[17:42:44.747]   - Field: ‘state’
[17:42:44.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.747] - Launch lazy future ...
[17:42:44.747] Packages needed by the future expression (n = 0): <none>
[17:42:44.747] Packages needed by future strategies (n = 0): <none>
[17:42:44.748] {
[17:42:44.748]     {
[17:42:44.748]         {
[17:42:44.748]             ...future.startTime <- base::Sys.time()
[17:42:44.748]             {
[17:42:44.748]                 {
[17:42:44.748]                   {
[17:42:44.748]                     base::local({
[17:42:44.748]                       has_future <- base::requireNamespace("future", 
[17:42:44.748]                         quietly = TRUE)
[17:42:44.748]                       if (has_future) {
[17:42:44.748]                         ns <- base::getNamespace("future")
[17:42:44.748]                         version <- ns[[".package"]][["version"]]
[17:42:44.748]                         if (is.null(version)) 
[17:42:44.748]                           version <- utils::packageVersion("future")
[17:42:44.748]                       }
[17:42:44.748]                       else {
[17:42:44.748]                         version <- NULL
[17:42:44.748]                       }
[17:42:44.748]                       if (!has_future || version < "1.8.0") {
[17:42:44.748]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.748]                           "", base::R.version$version.string), 
[17:42:44.748]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.748]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.748]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.748]                             "release", "version")], collapse = " "), 
[17:42:44.748]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.748]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.748]                           info)
[17:42:44.748]                         info <- base::paste(info, collapse = "; ")
[17:42:44.748]                         if (!has_future) {
[17:42:44.748]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.748]                             info)
[17:42:44.748]                         }
[17:42:44.748]                         else {
[17:42:44.748]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.748]                             info, version)
[17:42:44.748]                         }
[17:42:44.748]                         base::stop(msg)
[17:42:44.748]                       }
[17:42:44.748]                     })
[17:42:44.748]                   }
[17:42:44.748]                   options(future.plan = NULL)
[17:42:44.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.748]                 }
[17:42:44.748]                 ...future.workdir <- getwd()
[17:42:44.748]             }
[17:42:44.748]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.748]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.748]         }
[17:42:44.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.748]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.748]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.748]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.748]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.748]             base::names(...future.oldOptions))
[17:42:44.748]     }
[17:42:44.748]     if (FALSE) {
[17:42:44.748]     }
[17:42:44.748]     else {
[17:42:44.748]         if (TRUE) {
[17:42:44.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.748]                 open = "w")
[17:42:44.748]         }
[17:42:44.748]         else {
[17:42:44.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.748]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.748]         }
[17:42:44.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.748]             base::sink(type = "output", split = FALSE)
[17:42:44.748]             base::close(...future.stdout)
[17:42:44.748]         }, add = TRUE)
[17:42:44.748]     }
[17:42:44.748]     ...future.frame <- base::sys.nframe()
[17:42:44.748]     ...future.conditions <- base::list()
[17:42:44.748]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.748]     if (FALSE) {
[17:42:44.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.748]     }
[17:42:44.748]     ...future.result <- base::tryCatch({
[17:42:44.748]         base::withCallingHandlers({
[17:42:44.748]             ...future.value <- base::withVisible(base::local({
[17:42:44.748]                 x <- x + 1
[17:42:44.748]                 x
[17:42:44.748]             }))
[17:42:44.748]             future::FutureResult(value = ...future.value$value, 
[17:42:44.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.748]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.748]                     ...future.globalenv.names))
[17:42:44.748]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.748]         }, condition = base::local({
[17:42:44.748]             c <- base::c
[17:42:44.748]             inherits <- base::inherits
[17:42:44.748]             invokeRestart <- base::invokeRestart
[17:42:44.748]             length <- base::length
[17:42:44.748]             list <- base::list
[17:42:44.748]             seq.int <- base::seq.int
[17:42:44.748]             signalCondition <- base::signalCondition
[17:42:44.748]             sys.calls <- base::sys.calls
[17:42:44.748]             `[[` <- base::`[[`
[17:42:44.748]             `+` <- base::`+`
[17:42:44.748]             `<<-` <- base::`<<-`
[17:42:44.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.748]                   3L)]
[17:42:44.748]             }
[17:42:44.748]             function(cond) {
[17:42:44.748]                 is_error <- inherits(cond, "error")
[17:42:44.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.748]                   NULL)
[17:42:44.748]                 if (is_error) {
[17:42:44.748]                   sessionInformation <- function() {
[17:42:44.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.748]                       search = base::search(), system = base::Sys.info())
[17:42:44.748]                   }
[17:42:44.748]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.748]                     cond$call), session = sessionInformation(), 
[17:42:44.748]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.748]                   signalCondition(cond)
[17:42:44.748]                 }
[17:42:44.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.748]                 "immediateCondition"))) {
[17:42:44.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.748]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.748]                   if (TRUE && !signal) {
[17:42:44.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.748]                     {
[17:42:44.748]                       inherits <- base::inherits
[17:42:44.748]                       invokeRestart <- base::invokeRestart
[17:42:44.748]                       is.null <- base::is.null
[17:42:44.748]                       muffled <- FALSE
[17:42:44.748]                       if (inherits(cond, "message")) {
[17:42:44.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.748]                         if (muffled) 
[17:42:44.748]                           invokeRestart("muffleMessage")
[17:42:44.748]                       }
[17:42:44.748]                       else if (inherits(cond, "warning")) {
[17:42:44.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.748]                         if (muffled) 
[17:42:44.748]                           invokeRestart("muffleWarning")
[17:42:44.748]                       }
[17:42:44.748]                       else if (inherits(cond, "condition")) {
[17:42:44.748]                         if (!is.null(pattern)) {
[17:42:44.748]                           computeRestarts <- base::computeRestarts
[17:42:44.748]                           grepl <- base::grepl
[17:42:44.748]                           restarts <- computeRestarts(cond)
[17:42:44.748]                           for (restart in restarts) {
[17:42:44.748]                             name <- restart$name
[17:42:44.748]                             if (is.null(name)) 
[17:42:44.748]                               next
[17:42:44.748]                             if (!grepl(pattern, name)) 
[17:42:44.748]                               next
[17:42:44.748]                             invokeRestart(restart)
[17:42:44.748]                             muffled <- TRUE
[17:42:44.748]                             break
[17:42:44.748]                           }
[17:42:44.748]                         }
[17:42:44.748]                       }
[17:42:44.748]                       invisible(muffled)
[17:42:44.748]                     }
[17:42:44.748]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.748]                   }
[17:42:44.748]                 }
[17:42:44.748]                 else {
[17:42:44.748]                   if (TRUE) {
[17:42:44.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.748]                     {
[17:42:44.748]                       inherits <- base::inherits
[17:42:44.748]                       invokeRestart <- base::invokeRestart
[17:42:44.748]                       is.null <- base::is.null
[17:42:44.748]                       muffled <- FALSE
[17:42:44.748]                       if (inherits(cond, "message")) {
[17:42:44.748]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.748]                         if (muffled) 
[17:42:44.748]                           invokeRestart("muffleMessage")
[17:42:44.748]                       }
[17:42:44.748]                       else if (inherits(cond, "warning")) {
[17:42:44.748]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.748]                         if (muffled) 
[17:42:44.748]                           invokeRestart("muffleWarning")
[17:42:44.748]                       }
[17:42:44.748]                       else if (inherits(cond, "condition")) {
[17:42:44.748]                         if (!is.null(pattern)) {
[17:42:44.748]                           computeRestarts <- base::computeRestarts
[17:42:44.748]                           grepl <- base::grepl
[17:42:44.748]                           restarts <- computeRestarts(cond)
[17:42:44.748]                           for (restart in restarts) {
[17:42:44.748]                             name <- restart$name
[17:42:44.748]                             if (is.null(name)) 
[17:42:44.748]                               next
[17:42:44.748]                             if (!grepl(pattern, name)) 
[17:42:44.748]                               next
[17:42:44.748]                             invokeRestart(restart)
[17:42:44.748]                             muffled <- TRUE
[17:42:44.748]                             break
[17:42:44.748]                           }
[17:42:44.748]                         }
[17:42:44.748]                       }
[17:42:44.748]                       invisible(muffled)
[17:42:44.748]                     }
[17:42:44.748]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.748]                   }
[17:42:44.748]                 }
[17:42:44.748]             }
[17:42:44.748]         }))
[17:42:44.748]     }, error = function(ex) {
[17:42:44.748]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.748]                 ...future.rng), started = ...future.startTime, 
[17:42:44.748]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.748]             version = "1.8"), class = "FutureResult")
[17:42:44.748]     }, finally = {
[17:42:44.748]         if (!identical(...future.workdir, getwd())) 
[17:42:44.748]             setwd(...future.workdir)
[17:42:44.748]         {
[17:42:44.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.748]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.748]             }
[17:42:44.748]             base::options(...future.oldOptions)
[17:42:44.748]             if (.Platform$OS.type == "windows") {
[17:42:44.748]                 old_names <- names(...future.oldEnvVars)
[17:42:44.748]                 envs <- base::Sys.getenv()
[17:42:44.748]                 names <- names(envs)
[17:42:44.748]                 common <- intersect(names, old_names)
[17:42:44.748]                 added <- setdiff(names, old_names)
[17:42:44.748]                 removed <- setdiff(old_names, names)
[17:42:44.748]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.748]                   envs[common]]
[17:42:44.748]                 NAMES <- toupper(changed)
[17:42:44.748]                 args <- list()
[17:42:44.748]                 for (kk in seq_along(NAMES)) {
[17:42:44.748]                   name <- changed[[kk]]
[17:42:44.748]                   NAME <- NAMES[[kk]]
[17:42:44.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.748]                     next
[17:42:44.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.748]                 }
[17:42:44.748]                 NAMES <- toupper(added)
[17:42:44.748]                 for (kk in seq_along(NAMES)) {
[17:42:44.748]                   name <- added[[kk]]
[17:42:44.748]                   NAME <- NAMES[[kk]]
[17:42:44.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.748]                     next
[17:42:44.748]                   args[[name]] <- ""
[17:42:44.748]                 }
[17:42:44.748]                 NAMES <- toupper(removed)
[17:42:44.748]                 for (kk in seq_along(NAMES)) {
[17:42:44.748]                   name <- removed[[kk]]
[17:42:44.748]                   NAME <- NAMES[[kk]]
[17:42:44.748]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.748]                     next
[17:42:44.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.748]                 }
[17:42:44.748]                 if (length(args) > 0) 
[17:42:44.748]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.748]             }
[17:42:44.748]             else {
[17:42:44.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.748]             }
[17:42:44.748]             {
[17:42:44.748]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.748]                   0L) {
[17:42:44.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.748]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.748]                   base::options(opts)
[17:42:44.748]                 }
[17:42:44.748]                 {
[17:42:44.748]                   {
[17:42:44.748]                     NULL
[17:42:44.748]                     RNGkind("Mersenne-Twister")
[17:42:44.748]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.748]                       inherits = FALSE)
[17:42:44.748]                   }
[17:42:44.748]                   options(future.plan = NULL)
[17:42:44.748]                   if (is.na(NA_character_)) 
[17:42:44.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.748]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.748]                   {
[17:42:44.748]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.748]                     if (!future$lazy) 
[17:42:44.748]                       future <- run(future)
[17:42:44.748]                     invisible(future)
[17:42:44.748]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.748]                 }
[17:42:44.748]             }
[17:42:44.748]         }
[17:42:44.748]     })
[17:42:44.748]     if (TRUE) {
[17:42:44.748]         base::sink(type = "output", split = FALSE)
[17:42:44.748]         if (TRUE) {
[17:42:44.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.748]         }
[17:42:44.748]         else {
[17:42:44.748]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.748]         }
[17:42:44.748]         base::close(...future.stdout)
[17:42:44.748]         ...future.stdout <- NULL
[17:42:44.748]     }
[17:42:44.748]     ...future.result$conditions <- ...future.conditions
[17:42:44.748]     ...future.result$finished <- base::Sys.time()
[17:42:44.748]     ...future.result
[17:42:44.748] }
[17:42:44.749] assign_globals() ...
[17:42:44.751] List of 1
[17:42:44.751]  $ x: num 1
[17:42:44.751]  - attr(*, "where")=List of 1
[17:42:44.751]   ..$ x:<environment: R_EmptyEnv> 
[17:42:44.751]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.751]  - attr(*, "resolved")= logi TRUE
[17:42:44.751]  - attr(*, "total_size")= num 56
[17:42:44.751]  - attr(*, "already-done")= logi TRUE
[17:42:44.754] - copied ‘x’ to environment
[17:42:44.755] assign_globals() ... done
[17:42:44.755] plan(): Setting new future strategy stack:
[17:42:44.755] List of future strategies:
[17:42:44.755] 1. sequential:
[17:42:44.755]    - args: function (..., envir = parent.frame())
[17:42:44.755]    - tweaked: FALSE
[17:42:44.755]    - call: NULL
[17:42:44.755] plan(): nbrOfWorkers() = 1
[17:42:44.756] plan(): Setting new future strategy stack:
[17:42:44.756] List of future strategies:
[17:42:44.756] 1. sequential:
[17:42:44.756]    - args: function (..., envir = parent.frame())
[17:42:44.756]    - tweaked: FALSE
[17:42:44.756]    - call: plan(strategy)
[17:42:44.756] plan(): nbrOfWorkers() = 1
[17:42:44.757] SequentialFuture started (and completed)
[17:42:44.757] - Launch lazy future ... done
[17:42:44.757] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.757] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.757] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:44.759] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:42:44.759] Searching for globals ... DONE
[17:42:44.759] Resolving globals: TRUE
[17:42:44.760] Resolving any globals that are futures ...
[17:42:44.760] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:42:44.760] Resolving any globals that are futures ... DONE
[17:42:44.760] Resolving futures part of globals (recursively) ...
[17:42:44.760] resolve() on list ...
[17:42:44.760]  recursive: 99
[17:42:44.761]  length: 1
[17:42:44.761]  elements: ‘x’
[17:42:44.761]  length: 0 (resolved future 1)
[17:42:44.761] resolve() on list ... DONE
[17:42:44.761] - globals: [1] ‘x’
[17:42:44.761] Resolving futures part of globals (recursively) ... DONE
[17:42:44.761] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:42:44.762] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:42:44.762] - globals: [1] ‘x’
[17:42:44.762] 
[17:42:44.762] getGlobalsAndPackages() ... DONE
[17:42:44.762] run() for ‘Future’ ...
[17:42:44.762] - state: ‘created’
[17:42:44.762] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:44.763] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:44.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:44.763]   - Field: ‘label’
[17:42:44.763]   - Field: ‘local’
[17:42:44.763]   - Field: ‘owner’
[17:42:44.763]   - Field: ‘envir’
[17:42:44.763]   - Field: ‘packages’
[17:42:44.763]   - Field: ‘gc’
[17:42:44.763]   - Field: ‘conditions’
[17:42:44.763]   - Field: ‘expr’
[17:42:44.764]   - Field: ‘uuid’
[17:42:44.764]   - Field: ‘seed’
[17:42:44.764]   - Field: ‘version’
[17:42:44.764]   - Field: ‘result’
[17:42:44.764]   - Field: ‘asynchronous’
[17:42:44.764]   - Field: ‘calls’
[17:42:44.764]   - Field: ‘globals’
[17:42:44.764]   - Field: ‘stdout’
[17:42:44.764]   - Field: ‘earlySignal’
[17:42:44.764]   - Field: ‘lazy’
[17:42:44.764]   - Field: ‘state’
[17:42:44.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:44.765] - Launch lazy future ...
[17:42:44.765] Packages needed by the future expression (n = 0): <none>
[17:42:44.765] Packages needed by future strategies (n = 0): <none>
[17:42:44.765] {
[17:42:44.765]     {
[17:42:44.765]         {
[17:42:44.765]             ...future.startTime <- base::Sys.time()
[17:42:44.765]             {
[17:42:44.765]                 {
[17:42:44.765]                   {
[17:42:44.765]                     base::local({
[17:42:44.765]                       has_future <- base::requireNamespace("future", 
[17:42:44.765]                         quietly = TRUE)
[17:42:44.765]                       if (has_future) {
[17:42:44.765]                         ns <- base::getNamespace("future")
[17:42:44.765]                         version <- ns[[".package"]][["version"]]
[17:42:44.765]                         if (is.null(version)) 
[17:42:44.765]                           version <- utils::packageVersion("future")
[17:42:44.765]                       }
[17:42:44.765]                       else {
[17:42:44.765]                         version <- NULL
[17:42:44.765]                       }
[17:42:44.765]                       if (!has_future || version < "1.8.0") {
[17:42:44.765]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.765]                           "", base::R.version$version.string), 
[17:42:44.765]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:44.765]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.765]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.765]                             "release", "version")], collapse = " "), 
[17:42:44.765]                           hostname = base::Sys.info()[["nodename"]])
[17:42:44.765]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.765]                           info)
[17:42:44.765]                         info <- base::paste(info, collapse = "; ")
[17:42:44.765]                         if (!has_future) {
[17:42:44.765]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.765]                             info)
[17:42:44.765]                         }
[17:42:44.765]                         else {
[17:42:44.765]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.765]                             info, version)
[17:42:44.765]                         }
[17:42:44.765]                         base::stop(msg)
[17:42:44.765]                       }
[17:42:44.765]                     })
[17:42:44.765]                   }
[17:42:44.765]                   options(future.plan = NULL)
[17:42:44.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.765]                 }
[17:42:44.765]                 ...future.workdir <- getwd()
[17:42:44.765]             }
[17:42:44.765]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.765]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.765]         }
[17:42:44.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.765]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:44.765]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.765]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.765]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.765]             base::names(...future.oldOptions))
[17:42:44.765]     }
[17:42:44.765]     if (FALSE) {
[17:42:44.765]     }
[17:42:44.765]     else {
[17:42:44.765]         if (TRUE) {
[17:42:44.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.765]                 open = "w")
[17:42:44.765]         }
[17:42:44.765]         else {
[17:42:44.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.765]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.765]         }
[17:42:44.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.765]             base::sink(type = "output", split = FALSE)
[17:42:44.765]             base::close(...future.stdout)
[17:42:44.765]         }, add = TRUE)
[17:42:44.765]     }
[17:42:44.765]     ...future.frame <- base::sys.nframe()
[17:42:44.765]     ...future.conditions <- base::list()
[17:42:44.765]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.765]     if (FALSE) {
[17:42:44.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.765]     }
[17:42:44.765]     ...future.result <- base::tryCatch({
[17:42:44.765]         base::withCallingHandlers({
[17:42:44.765]             ...future.value <- base::withVisible(base::local({
[17:42:44.765]                 x <- x()
[17:42:44.765]                 x
[17:42:44.765]             }))
[17:42:44.765]             future::FutureResult(value = ...future.value$value, 
[17:42:44.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.765]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.765]                     ...future.globalenv.names))
[17:42:44.765]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.765]         }, condition = base::local({
[17:42:44.765]             c <- base::c
[17:42:44.765]             inherits <- base::inherits
[17:42:44.765]             invokeRestart <- base::invokeRestart
[17:42:44.765]             length <- base::length
[17:42:44.765]             list <- base::list
[17:42:44.765]             seq.int <- base::seq.int
[17:42:44.765]             signalCondition <- base::signalCondition
[17:42:44.765]             sys.calls <- base::sys.calls
[17:42:44.765]             `[[` <- base::`[[`
[17:42:44.765]             `+` <- base::`+`
[17:42:44.765]             `<<-` <- base::`<<-`
[17:42:44.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.765]                   3L)]
[17:42:44.765]             }
[17:42:44.765]             function(cond) {
[17:42:44.765]                 is_error <- inherits(cond, "error")
[17:42:44.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.765]                   NULL)
[17:42:44.765]                 if (is_error) {
[17:42:44.765]                   sessionInformation <- function() {
[17:42:44.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.765]                       search = base::search(), system = base::Sys.info())
[17:42:44.765]                   }
[17:42:44.765]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.765]                     cond$call), session = sessionInformation(), 
[17:42:44.765]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.765]                   signalCondition(cond)
[17:42:44.765]                 }
[17:42:44.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.765]                 "immediateCondition"))) {
[17:42:44.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.765]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.765]                   if (TRUE && !signal) {
[17:42:44.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.765]                     {
[17:42:44.765]                       inherits <- base::inherits
[17:42:44.765]                       invokeRestart <- base::invokeRestart
[17:42:44.765]                       is.null <- base::is.null
[17:42:44.765]                       muffled <- FALSE
[17:42:44.765]                       if (inherits(cond, "message")) {
[17:42:44.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.765]                         if (muffled) 
[17:42:44.765]                           invokeRestart("muffleMessage")
[17:42:44.765]                       }
[17:42:44.765]                       else if (inherits(cond, "warning")) {
[17:42:44.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.765]                         if (muffled) 
[17:42:44.765]                           invokeRestart("muffleWarning")
[17:42:44.765]                       }
[17:42:44.765]                       else if (inherits(cond, "condition")) {
[17:42:44.765]                         if (!is.null(pattern)) {
[17:42:44.765]                           computeRestarts <- base::computeRestarts
[17:42:44.765]                           grepl <- base::grepl
[17:42:44.765]                           restarts <- computeRestarts(cond)
[17:42:44.765]                           for (restart in restarts) {
[17:42:44.765]                             name <- restart$name
[17:42:44.765]                             if (is.null(name)) 
[17:42:44.765]                               next
[17:42:44.765]                             if (!grepl(pattern, name)) 
[17:42:44.765]                               next
[17:42:44.765]                             invokeRestart(restart)
[17:42:44.765]                             muffled <- TRUE
[17:42:44.765]                             break
[17:42:44.765]                           }
[17:42:44.765]                         }
[17:42:44.765]                       }
[17:42:44.765]                       invisible(muffled)
[17:42:44.765]                     }
[17:42:44.765]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.765]                   }
[17:42:44.765]                 }
[17:42:44.765]                 else {
[17:42:44.765]                   if (TRUE) {
[17:42:44.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.765]                     {
[17:42:44.765]                       inherits <- base::inherits
[17:42:44.765]                       invokeRestart <- base::invokeRestart
[17:42:44.765]                       is.null <- base::is.null
[17:42:44.765]                       muffled <- FALSE
[17:42:44.765]                       if (inherits(cond, "message")) {
[17:42:44.765]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.765]                         if (muffled) 
[17:42:44.765]                           invokeRestart("muffleMessage")
[17:42:44.765]                       }
[17:42:44.765]                       else if (inherits(cond, "warning")) {
[17:42:44.765]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.765]                         if (muffled) 
[17:42:44.765]                           invokeRestart("muffleWarning")
[17:42:44.765]                       }
[17:42:44.765]                       else if (inherits(cond, "condition")) {
[17:42:44.765]                         if (!is.null(pattern)) {
[17:42:44.765]                           computeRestarts <- base::computeRestarts
[17:42:44.765]                           grepl <- base::grepl
[17:42:44.765]                           restarts <- computeRestarts(cond)
[17:42:44.765]                           for (restart in restarts) {
[17:42:44.765]                             name <- restart$name
[17:42:44.765]                             if (is.null(name)) 
[17:42:44.765]                               next
[17:42:44.765]                             if (!grepl(pattern, name)) 
[17:42:44.765]                               next
[17:42:44.765]                             invokeRestart(restart)
[17:42:44.765]                             muffled <- TRUE
[17:42:44.765]                             break
[17:42:44.765]                           }
[17:42:44.765]                         }
[17:42:44.765]                       }
[17:42:44.765]                       invisible(muffled)
[17:42:44.765]                     }
[17:42:44.765]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.765]                   }
[17:42:44.765]                 }
[17:42:44.765]             }
[17:42:44.765]         }))
[17:42:44.765]     }, error = function(ex) {
[17:42:44.765]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.765]                 ...future.rng), started = ...future.startTime, 
[17:42:44.765]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.765]             version = "1.8"), class = "FutureResult")
[17:42:44.765]     }, finally = {
[17:42:44.765]         if (!identical(...future.workdir, getwd())) 
[17:42:44.765]             setwd(...future.workdir)
[17:42:44.765]         {
[17:42:44.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.765]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.765]             }
[17:42:44.765]             base::options(...future.oldOptions)
[17:42:44.765]             if (.Platform$OS.type == "windows") {
[17:42:44.765]                 old_names <- names(...future.oldEnvVars)
[17:42:44.765]                 envs <- base::Sys.getenv()
[17:42:44.765]                 names <- names(envs)
[17:42:44.765]                 common <- intersect(names, old_names)
[17:42:44.765]                 added <- setdiff(names, old_names)
[17:42:44.765]                 removed <- setdiff(old_names, names)
[17:42:44.765]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.765]                   envs[common]]
[17:42:44.765]                 NAMES <- toupper(changed)
[17:42:44.765]                 args <- list()
[17:42:44.765]                 for (kk in seq_along(NAMES)) {
[17:42:44.765]                   name <- changed[[kk]]
[17:42:44.765]                   NAME <- NAMES[[kk]]
[17:42:44.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.765]                     next
[17:42:44.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.765]                 }
[17:42:44.765]                 NAMES <- toupper(added)
[17:42:44.765]                 for (kk in seq_along(NAMES)) {
[17:42:44.765]                   name <- added[[kk]]
[17:42:44.765]                   NAME <- NAMES[[kk]]
[17:42:44.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.765]                     next
[17:42:44.765]                   args[[name]] <- ""
[17:42:44.765]                 }
[17:42:44.765]                 NAMES <- toupper(removed)
[17:42:44.765]                 for (kk in seq_along(NAMES)) {
[17:42:44.765]                   name <- removed[[kk]]
[17:42:44.765]                   NAME <- NAMES[[kk]]
[17:42:44.765]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.765]                     next
[17:42:44.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.765]                 }
[17:42:44.765]                 if (length(args) > 0) 
[17:42:44.765]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.765]             }
[17:42:44.765]             else {
[17:42:44.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.765]             }
[17:42:44.765]             {
[17:42:44.765]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.765]                   0L) {
[17:42:44.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.765]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.765]                   base::options(opts)
[17:42:44.765]                 }
[17:42:44.765]                 {
[17:42:44.765]                   {
[17:42:44.765]                     NULL
[17:42:44.765]                     RNGkind("Mersenne-Twister")
[17:42:44.765]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:44.765]                       inherits = FALSE)
[17:42:44.765]                   }
[17:42:44.765]                   options(future.plan = NULL)
[17:42:44.765]                   if (is.na(NA_character_)) 
[17:42:44.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.765]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:44.765]                   {
[17:42:44.765]                     future <- SequentialFuture(..., envir = envir)
[17:42:44.765]                     if (!future$lazy) 
[17:42:44.765]                       future <- run(future)
[17:42:44.765]                     invisible(future)
[17:42:44.765]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.765]                 }
[17:42:44.765]             }
[17:42:44.765]         }
[17:42:44.765]     })
[17:42:44.765]     if (TRUE) {
[17:42:44.765]         base::sink(type = "output", split = FALSE)
[17:42:44.765]         if (TRUE) {
[17:42:44.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.765]         }
[17:42:44.765]         else {
[17:42:44.765]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.765]         }
[17:42:44.765]         base::close(...future.stdout)
[17:42:44.765]         ...future.stdout <- NULL
[17:42:44.765]     }
[17:42:44.765]     ...future.result$conditions <- ...future.conditions
[17:42:44.765]     ...future.result$finished <- base::Sys.time()
[17:42:44.765]     ...future.result
[17:42:44.765] }
[17:42:44.767] assign_globals() ...
[17:42:44.767] List of 1
[17:42:44.767]  $ x:function ()  
[17:42:44.767]  - attr(*, "where")=List of 1
[17:42:44.767]   ..$ x:<environment: R_EmptyEnv> 
[17:42:44.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.767]  - attr(*, "resolved")= logi TRUE
[17:42:44.767]  - attr(*, "total_size")= num 1032
[17:42:44.767]  - attr(*, "already-done")= logi TRUE
[17:42:44.769] - reassign environment for ‘x’
[17:42:44.770] - copied ‘x’ to environment
[17:42:44.770] assign_globals() ... done
[17:42:44.770] plan(): Setting new future strategy stack:
[17:42:44.770] List of future strategies:
[17:42:44.770] 1. sequential:
[17:42:44.770]    - args: function (..., envir = parent.frame())
[17:42:44.770]    - tweaked: FALSE
[17:42:44.770]    - call: NULL
[17:42:44.770] plan(): nbrOfWorkers() = 1
[17:42:44.771] plan(): Setting new future strategy stack:
[17:42:44.771] List of future strategies:
[17:42:44.771] 1. sequential:
[17:42:44.771]    - args: function (..., envir = parent.frame())
[17:42:44.771]    - tweaked: FALSE
[17:42:44.771]    - call: plan(strategy)
[17:42:44.772] plan(): nbrOfWorkers() = 1
[17:42:44.772] SequentialFuture started (and completed)
[17:42:44.772] - Launch lazy future ... done
[17:42:44.772] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[17:42:44.784] plan(): Setting new future strategy stack:
[17:42:44.785] List of future strategies:
[17:42:44.785] 1. multicore:
[17:42:44.785]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:44.785]    - tweaked: FALSE
[17:42:44.785]    - call: plan(strategy)
[17:42:44.789] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.789] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.789] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.791] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.791] Searching for globals ... DONE
[17:42:44.791] Resolving globals: TRUE
[17:42:44.791] Resolving any globals that are futures ...
[17:42:44.791] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.791] Resolving any globals that are futures ... DONE
[17:42:44.791] 
[17:42:44.792] 
[17:42:44.792] getGlobalsAndPackages() ... DONE
[17:42:44.792] run() for ‘Future’ ...
[17:42:44.792] - state: ‘created’
[17:42:44.792] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:44.796] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:44.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:44.796]   - Field: ‘label’
[17:42:44.796]   - Field: ‘local’
[17:42:44.796]   - Field: ‘owner’
[17:42:44.796]   - Field: ‘envir’
[17:42:44.796]   - Field: ‘workers’
[17:42:44.797]   - Field: ‘packages’
[17:42:44.797]   - Field: ‘gc’
[17:42:44.797]   - Field: ‘job’
[17:42:44.797]   - Field: ‘conditions’
[17:42:44.797]   - Field: ‘expr’
[17:42:44.797]   - Field: ‘uuid’
[17:42:44.797]   - Field: ‘seed’
[17:42:44.797]   - Field: ‘version’
[17:42:44.797]   - Field: ‘result’
[17:42:44.797]   - Field: ‘asynchronous’
[17:42:44.797]   - Field: ‘calls’
[17:42:44.798]   - Field: ‘globals’
[17:42:44.798]   - Field: ‘stdout’
[17:42:44.798]   - Field: ‘earlySignal’
[17:42:44.798]   - Field: ‘lazy’
[17:42:44.798]   - Field: ‘state’
[17:42:44.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:44.798] - Launch lazy future ...
[17:42:44.799] Packages needed by the future expression (n = 0): <none>
[17:42:44.799] Packages needed by future strategies (n = 0): <none>
[17:42:44.800] {
[17:42:44.800]     {
[17:42:44.800]         {
[17:42:44.800]             ...future.startTime <- base::Sys.time()
[17:42:44.800]             {
[17:42:44.800]                 {
[17:42:44.800]                   {
[17:42:44.800]                     {
[17:42:44.800]                       base::local({
[17:42:44.800]                         has_future <- base::requireNamespace("future", 
[17:42:44.800]                           quietly = TRUE)
[17:42:44.800]                         if (has_future) {
[17:42:44.800]                           ns <- base::getNamespace("future")
[17:42:44.800]                           version <- ns[[".package"]][["version"]]
[17:42:44.800]                           if (is.null(version)) 
[17:42:44.800]                             version <- utils::packageVersion("future")
[17:42:44.800]                         }
[17:42:44.800]                         else {
[17:42:44.800]                           version <- NULL
[17:42:44.800]                         }
[17:42:44.800]                         if (!has_future || version < "1.8.0") {
[17:42:44.800]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.800]                             "", base::R.version$version.string), 
[17:42:44.800]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.800]                               "release", "version")], collapse = " "), 
[17:42:44.800]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.800]                             info)
[17:42:44.800]                           info <- base::paste(info, collapse = "; ")
[17:42:44.800]                           if (!has_future) {
[17:42:44.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.800]                               info)
[17:42:44.800]                           }
[17:42:44.800]                           else {
[17:42:44.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.800]                               info, version)
[17:42:44.800]                           }
[17:42:44.800]                           base::stop(msg)
[17:42:44.800]                         }
[17:42:44.800]                       })
[17:42:44.800]                     }
[17:42:44.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:44.800]                     base::options(mc.cores = 1L)
[17:42:44.800]                   }
[17:42:44.800]                   options(future.plan = NULL)
[17:42:44.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.800]                 }
[17:42:44.800]                 ...future.workdir <- getwd()
[17:42:44.800]             }
[17:42:44.800]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.800]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.800]         }
[17:42:44.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.800]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.800]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.800]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.800]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.800]             base::names(...future.oldOptions))
[17:42:44.800]     }
[17:42:44.800]     if (FALSE) {
[17:42:44.800]     }
[17:42:44.800]     else {
[17:42:44.800]         if (TRUE) {
[17:42:44.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.800]                 open = "w")
[17:42:44.800]         }
[17:42:44.800]         else {
[17:42:44.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.800]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.800]         }
[17:42:44.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.800]             base::sink(type = "output", split = FALSE)
[17:42:44.800]             base::close(...future.stdout)
[17:42:44.800]         }, add = TRUE)
[17:42:44.800]     }
[17:42:44.800]     ...future.frame <- base::sys.nframe()
[17:42:44.800]     ...future.conditions <- base::list()
[17:42:44.800]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.800]     if (FALSE) {
[17:42:44.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.800]     }
[17:42:44.800]     ...future.result <- base::tryCatch({
[17:42:44.800]         base::withCallingHandlers({
[17:42:44.800]             ...future.value <- base::withVisible(base::local({
[17:42:44.800]                 withCallingHandlers({
[17:42:44.800]                   {
[17:42:44.800]                     b <- a
[17:42:44.800]                     a <- 2
[17:42:44.800]                     a * b
[17:42:44.800]                   }
[17:42:44.800]                 }, immediateCondition = function(cond) {
[17:42:44.800]                   save_rds <- function (object, pathname, ...) 
[17:42:44.800]                   {
[17:42:44.800]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:44.800]                     if (file_test("-f", pathname_tmp)) {
[17:42:44.800]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.800]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:44.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.800]                         fi_tmp[["mtime"]])
[17:42:44.800]                     }
[17:42:44.800]                     tryCatch({
[17:42:44.800]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:44.800]                     }, error = function(ex) {
[17:42:44.800]                       msg <- conditionMessage(ex)
[17:42:44.800]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.800]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:44.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.800]                         fi_tmp[["mtime"]], msg)
[17:42:44.800]                       ex$message <- msg
[17:42:44.800]                       stop(ex)
[17:42:44.800]                     })
[17:42:44.800]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:44.800]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:44.800]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:44.800]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.800]                       fi <- file.info(pathname)
[17:42:44.800]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:44.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.800]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:44.800]                         fi[["size"]], fi[["mtime"]])
[17:42:44.800]                       stop(msg)
[17:42:44.800]                     }
[17:42:44.800]                     invisible(pathname)
[17:42:44.800]                   }
[17:42:44.800]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:44.800]                     rootPath = tempdir()) 
[17:42:44.800]                   {
[17:42:44.800]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:44.800]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:44.800]                       tmpdir = path, fileext = ".rds")
[17:42:44.800]                     save_rds(obj, file)
[17:42:44.800]                   }
[17:42:44.800]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:44.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.800]                   {
[17:42:44.800]                     inherits <- base::inherits
[17:42:44.800]                     invokeRestart <- base::invokeRestart
[17:42:44.800]                     is.null <- base::is.null
[17:42:44.800]                     muffled <- FALSE
[17:42:44.800]                     if (inherits(cond, "message")) {
[17:42:44.800]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:44.800]                       if (muffled) 
[17:42:44.800]                         invokeRestart("muffleMessage")
[17:42:44.800]                     }
[17:42:44.800]                     else if (inherits(cond, "warning")) {
[17:42:44.800]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:44.800]                       if (muffled) 
[17:42:44.800]                         invokeRestart("muffleWarning")
[17:42:44.800]                     }
[17:42:44.800]                     else if (inherits(cond, "condition")) {
[17:42:44.800]                       if (!is.null(pattern)) {
[17:42:44.800]                         computeRestarts <- base::computeRestarts
[17:42:44.800]                         grepl <- base::grepl
[17:42:44.800]                         restarts <- computeRestarts(cond)
[17:42:44.800]                         for (restart in restarts) {
[17:42:44.800]                           name <- restart$name
[17:42:44.800]                           if (is.null(name)) 
[17:42:44.800]                             next
[17:42:44.800]                           if (!grepl(pattern, name)) 
[17:42:44.800]                             next
[17:42:44.800]                           invokeRestart(restart)
[17:42:44.800]                           muffled <- TRUE
[17:42:44.800]                           break
[17:42:44.800]                         }
[17:42:44.800]                       }
[17:42:44.800]                     }
[17:42:44.800]                     invisible(muffled)
[17:42:44.800]                   }
[17:42:44.800]                   muffleCondition(cond)
[17:42:44.800]                 })
[17:42:44.800]             }))
[17:42:44.800]             future::FutureResult(value = ...future.value$value, 
[17:42:44.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.800]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.800]                     ...future.globalenv.names))
[17:42:44.800]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.800]         }, condition = base::local({
[17:42:44.800]             c <- base::c
[17:42:44.800]             inherits <- base::inherits
[17:42:44.800]             invokeRestart <- base::invokeRestart
[17:42:44.800]             length <- base::length
[17:42:44.800]             list <- base::list
[17:42:44.800]             seq.int <- base::seq.int
[17:42:44.800]             signalCondition <- base::signalCondition
[17:42:44.800]             sys.calls <- base::sys.calls
[17:42:44.800]             `[[` <- base::`[[`
[17:42:44.800]             `+` <- base::`+`
[17:42:44.800]             `<<-` <- base::`<<-`
[17:42:44.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.800]                   3L)]
[17:42:44.800]             }
[17:42:44.800]             function(cond) {
[17:42:44.800]                 is_error <- inherits(cond, "error")
[17:42:44.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.800]                   NULL)
[17:42:44.800]                 if (is_error) {
[17:42:44.800]                   sessionInformation <- function() {
[17:42:44.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.800]                       search = base::search(), system = base::Sys.info())
[17:42:44.800]                   }
[17:42:44.800]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.800]                     cond$call), session = sessionInformation(), 
[17:42:44.800]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.800]                   signalCondition(cond)
[17:42:44.800]                 }
[17:42:44.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.800]                 "immediateCondition"))) {
[17:42:44.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.800]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.800]                   if (TRUE && !signal) {
[17:42:44.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.800]                     {
[17:42:44.800]                       inherits <- base::inherits
[17:42:44.800]                       invokeRestart <- base::invokeRestart
[17:42:44.800]                       is.null <- base::is.null
[17:42:44.800]                       muffled <- FALSE
[17:42:44.800]                       if (inherits(cond, "message")) {
[17:42:44.800]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.800]                         if (muffled) 
[17:42:44.800]                           invokeRestart("muffleMessage")
[17:42:44.800]                       }
[17:42:44.800]                       else if (inherits(cond, "warning")) {
[17:42:44.800]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.800]                         if (muffled) 
[17:42:44.800]                           invokeRestart("muffleWarning")
[17:42:44.800]                       }
[17:42:44.800]                       else if (inherits(cond, "condition")) {
[17:42:44.800]                         if (!is.null(pattern)) {
[17:42:44.800]                           computeRestarts <- base::computeRestarts
[17:42:44.800]                           grepl <- base::grepl
[17:42:44.800]                           restarts <- computeRestarts(cond)
[17:42:44.800]                           for (restart in restarts) {
[17:42:44.800]                             name <- restart$name
[17:42:44.800]                             if (is.null(name)) 
[17:42:44.800]                               next
[17:42:44.800]                             if (!grepl(pattern, name)) 
[17:42:44.800]                               next
[17:42:44.800]                             invokeRestart(restart)
[17:42:44.800]                             muffled <- TRUE
[17:42:44.800]                             break
[17:42:44.800]                           }
[17:42:44.800]                         }
[17:42:44.800]                       }
[17:42:44.800]                       invisible(muffled)
[17:42:44.800]                     }
[17:42:44.800]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.800]                   }
[17:42:44.800]                 }
[17:42:44.800]                 else {
[17:42:44.800]                   if (TRUE) {
[17:42:44.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.800]                     {
[17:42:44.800]                       inherits <- base::inherits
[17:42:44.800]                       invokeRestart <- base::invokeRestart
[17:42:44.800]                       is.null <- base::is.null
[17:42:44.800]                       muffled <- FALSE
[17:42:44.800]                       if (inherits(cond, "message")) {
[17:42:44.800]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.800]                         if (muffled) 
[17:42:44.800]                           invokeRestart("muffleMessage")
[17:42:44.800]                       }
[17:42:44.800]                       else if (inherits(cond, "warning")) {
[17:42:44.800]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.800]                         if (muffled) 
[17:42:44.800]                           invokeRestart("muffleWarning")
[17:42:44.800]                       }
[17:42:44.800]                       else if (inherits(cond, "condition")) {
[17:42:44.800]                         if (!is.null(pattern)) {
[17:42:44.800]                           computeRestarts <- base::computeRestarts
[17:42:44.800]                           grepl <- base::grepl
[17:42:44.800]                           restarts <- computeRestarts(cond)
[17:42:44.800]                           for (restart in restarts) {
[17:42:44.800]                             name <- restart$name
[17:42:44.800]                             if (is.null(name)) 
[17:42:44.800]                               next
[17:42:44.800]                             if (!grepl(pattern, name)) 
[17:42:44.800]                               next
[17:42:44.800]                             invokeRestart(restart)
[17:42:44.800]                             muffled <- TRUE
[17:42:44.800]                             break
[17:42:44.800]                           }
[17:42:44.800]                         }
[17:42:44.800]                       }
[17:42:44.800]                       invisible(muffled)
[17:42:44.800]                     }
[17:42:44.800]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.800]                   }
[17:42:44.800]                 }
[17:42:44.800]             }
[17:42:44.800]         }))
[17:42:44.800]     }, error = function(ex) {
[17:42:44.800]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.800]                 ...future.rng), started = ...future.startTime, 
[17:42:44.800]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.800]             version = "1.8"), class = "FutureResult")
[17:42:44.800]     }, finally = {
[17:42:44.800]         if (!identical(...future.workdir, getwd())) 
[17:42:44.800]             setwd(...future.workdir)
[17:42:44.800]         {
[17:42:44.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.800]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.800]             }
[17:42:44.800]             base::options(...future.oldOptions)
[17:42:44.800]             if (.Platform$OS.type == "windows") {
[17:42:44.800]                 old_names <- names(...future.oldEnvVars)
[17:42:44.800]                 envs <- base::Sys.getenv()
[17:42:44.800]                 names <- names(envs)
[17:42:44.800]                 common <- intersect(names, old_names)
[17:42:44.800]                 added <- setdiff(names, old_names)
[17:42:44.800]                 removed <- setdiff(old_names, names)
[17:42:44.800]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.800]                   envs[common]]
[17:42:44.800]                 NAMES <- toupper(changed)
[17:42:44.800]                 args <- list()
[17:42:44.800]                 for (kk in seq_along(NAMES)) {
[17:42:44.800]                   name <- changed[[kk]]
[17:42:44.800]                   NAME <- NAMES[[kk]]
[17:42:44.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.800]                     next
[17:42:44.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.800]                 }
[17:42:44.800]                 NAMES <- toupper(added)
[17:42:44.800]                 for (kk in seq_along(NAMES)) {
[17:42:44.800]                   name <- added[[kk]]
[17:42:44.800]                   NAME <- NAMES[[kk]]
[17:42:44.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.800]                     next
[17:42:44.800]                   args[[name]] <- ""
[17:42:44.800]                 }
[17:42:44.800]                 NAMES <- toupper(removed)
[17:42:44.800]                 for (kk in seq_along(NAMES)) {
[17:42:44.800]                   name <- removed[[kk]]
[17:42:44.800]                   NAME <- NAMES[[kk]]
[17:42:44.800]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.800]                     next
[17:42:44.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.800]                 }
[17:42:44.800]                 if (length(args) > 0) 
[17:42:44.800]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.800]             }
[17:42:44.800]             else {
[17:42:44.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.800]             }
[17:42:44.800]             {
[17:42:44.800]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.800]                   0L) {
[17:42:44.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.800]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.800]                   base::options(opts)
[17:42:44.800]                 }
[17:42:44.800]                 {
[17:42:44.800]                   {
[17:42:44.800]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:44.800]                     NULL
[17:42:44.800]                   }
[17:42:44.800]                   options(future.plan = NULL)
[17:42:44.800]                   if (is.na(NA_character_)) 
[17:42:44.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.800]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:44.800]                     envir = parent.frame()) 
[17:42:44.800]                   {
[17:42:44.800]                     default_workers <- missing(workers)
[17:42:44.800]                     if (is.function(workers)) 
[17:42:44.800]                       workers <- workers()
[17:42:44.800]                     workers <- structure(as.integer(workers), 
[17:42:44.800]                       class = class(workers))
[17:42:44.800]                     stop_if_not(is.finite(workers), workers >= 
[17:42:44.800]                       1L)
[17:42:44.800]                     if ((workers == 1L && !inherits(workers, 
[17:42:44.800]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:44.800]                       if (default_workers) 
[17:42:44.800]                         supportsMulticore(warn = TRUE)
[17:42:44.800]                       return(sequential(..., envir = envir))
[17:42:44.800]                     }
[17:42:44.800]                     oopts <- options(mc.cores = workers)
[17:42:44.800]                     on.exit(options(oopts))
[17:42:44.800]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:44.800]                       envir = envir)
[17:42:44.800]                     if (!future$lazy) 
[17:42:44.800]                       future <- run(future)
[17:42:44.800]                     invisible(future)
[17:42:44.800]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.800]                 }
[17:42:44.800]             }
[17:42:44.800]         }
[17:42:44.800]     })
[17:42:44.800]     if (TRUE) {
[17:42:44.800]         base::sink(type = "output", split = FALSE)
[17:42:44.800]         if (TRUE) {
[17:42:44.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.800]         }
[17:42:44.800]         else {
[17:42:44.800]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.800]         }
[17:42:44.800]         base::close(...future.stdout)
[17:42:44.800]         ...future.stdout <- NULL
[17:42:44.800]     }
[17:42:44.800]     ...future.result$conditions <- ...future.conditions
[17:42:44.800]     ...future.result$finished <- base::Sys.time()
[17:42:44.800]     ...future.result
[17:42:44.800] }
[17:42:44.802] requestCore(): workers = 2
[17:42:44.805] MulticoreFuture started
[17:42:44.806] - Launch lazy future ... done
[17:42:44.806] plan(): Setting new future strategy stack:
[17:42:44.806] run() for ‘MulticoreFuture’ ... done
[17:42:44.806] List of future strategies:
[17:42:44.806] 1. sequential:
[17:42:44.806]    - args: function (..., envir = parent.frame())
[17:42:44.806]    - tweaked: FALSE
[17:42:44.806]    - call: NULL
[17:42:44.808] plan(): nbrOfWorkers() = 1
[17:42:44.810] plan(): Setting new future strategy stack:
[17:42:44.810] List of future strategies:
[17:42:44.810] 1. multicore:
[17:42:44.810]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:44.810]    - tweaked: FALSE
[17:42:44.810]    - call: plan(strategy)
[17:42:44.815] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.821] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.821] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.823] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.823] Searching for globals ... DONE
[17:42:44.824] Resolving globals: TRUE
[17:42:44.824] Resolving any globals that are futures ...
[17:42:44.824] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:42:44.824] Resolving any globals that are futures ... DONE
[17:42:44.824] 
[17:42:44.824] 
[17:42:44.825] getGlobalsAndPackages() ... DONE
[17:42:44.825] run() for ‘Future’ ...
[17:42:44.825] - state: ‘created’
[17:42:44.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:44.829] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:44.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:44.830]   - Field: ‘label’
[17:42:44.830]   - Field: ‘local’
[17:42:44.830]   - Field: ‘owner’
[17:42:44.830]   - Field: ‘envir’
[17:42:44.830]   - Field: ‘workers’
[17:42:44.830]   - Field: ‘packages’
[17:42:44.830]   - Field: ‘gc’
[17:42:44.830]   - Field: ‘job’
[17:42:44.831]   - Field: ‘conditions’
[17:42:44.831]   - Field: ‘expr’
[17:42:44.833]   - Field: ‘uuid’
[17:42:44.834]   - Field: ‘seed’
[17:42:44.834]   - Field: ‘version’
[17:42:44.834]   - Field: ‘result’
[17:42:44.834]   - Field: ‘asynchronous’
[17:42:44.834]   - Field: ‘calls’
[17:42:44.835]   - Field: ‘globals’
[17:42:44.835]   - Field: ‘stdout’
[17:42:44.835]   - Field: ‘earlySignal’
[17:42:44.835]   - Field: ‘lazy’
[17:42:44.835]   - Field: ‘state’
[17:42:44.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:44.836] - Launch lazy future ...
[17:42:44.836] Packages needed by the future expression (n = 0): <none>
[17:42:44.836] Packages needed by future strategies (n = 0): <none>
[17:42:44.837] {
[17:42:44.837]     {
[17:42:44.837]         {
[17:42:44.837]             ...future.startTime <- base::Sys.time()
[17:42:44.837]             {
[17:42:44.837]                 {
[17:42:44.837]                   {
[17:42:44.837]                     {
[17:42:44.837]                       base::local({
[17:42:44.837]                         has_future <- base::requireNamespace("future", 
[17:42:44.837]                           quietly = TRUE)
[17:42:44.837]                         if (has_future) {
[17:42:44.837]                           ns <- base::getNamespace("future")
[17:42:44.837]                           version <- ns[[".package"]][["version"]]
[17:42:44.837]                           if (is.null(version)) 
[17:42:44.837]                             version <- utils::packageVersion("future")
[17:42:44.837]                         }
[17:42:44.837]                         else {
[17:42:44.837]                           version <- NULL
[17:42:44.837]                         }
[17:42:44.837]                         if (!has_future || version < "1.8.0") {
[17:42:44.837]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.837]                             "", base::R.version$version.string), 
[17:42:44.837]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.837]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.837]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.837]                               "release", "version")], collapse = " "), 
[17:42:44.837]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.837]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.837]                             info)
[17:42:44.837]                           info <- base::paste(info, collapse = "; ")
[17:42:44.837]                           if (!has_future) {
[17:42:44.837]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.837]                               info)
[17:42:44.837]                           }
[17:42:44.837]                           else {
[17:42:44.837]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.837]                               info, version)
[17:42:44.837]                           }
[17:42:44.837]                           base::stop(msg)
[17:42:44.837]                         }
[17:42:44.837]                       })
[17:42:44.837]                     }
[17:42:44.837]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:44.837]                     base::options(mc.cores = 1L)
[17:42:44.837]                   }
[17:42:44.837]                   options(future.plan = NULL)
[17:42:44.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.837]                 }
[17:42:44.837]                 ...future.workdir <- getwd()
[17:42:44.837]             }
[17:42:44.837]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.837]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.837]         }
[17:42:44.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.837]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.837]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.837]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.837]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.837]             base::names(...future.oldOptions))
[17:42:44.837]     }
[17:42:44.837]     if (FALSE) {
[17:42:44.837]     }
[17:42:44.837]     else {
[17:42:44.837]         if (TRUE) {
[17:42:44.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.837]                 open = "w")
[17:42:44.837]         }
[17:42:44.837]         else {
[17:42:44.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.837]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.837]         }
[17:42:44.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.837]             base::sink(type = "output", split = FALSE)
[17:42:44.837]             base::close(...future.stdout)
[17:42:44.837]         }, add = TRUE)
[17:42:44.837]     }
[17:42:44.837]     ...future.frame <- base::sys.nframe()
[17:42:44.837]     ...future.conditions <- base::list()
[17:42:44.837]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.837]     if (FALSE) {
[17:42:44.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.837]     }
[17:42:44.837]     ...future.result <- base::tryCatch({
[17:42:44.837]         base::withCallingHandlers({
[17:42:44.837]             ...future.value <- base::withVisible(base::local({
[17:42:44.837]                 withCallingHandlers({
[17:42:44.837]                   {
[17:42:44.837]                     b <- a
[17:42:44.837]                     a <- 2
[17:42:44.837]                     a * b
[17:42:44.837]                   }
[17:42:44.837]                 }, immediateCondition = function(cond) {
[17:42:44.837]                   save_rds <- function (object, pathname, ...) 
[17:42:44.837]                   {
[17:42:44.837]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:44.837]                     if (file_test("-f", pathname_tmp)) {
[17:42:44.837]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.837]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:44.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.837]                         fi_tmp[["mtime"]])
[17:42:44.837]                     }
[17:42:44.837]                     tryCatch({
[17:42:44.837]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:44.837]                     }, error = function(ex) {
[17:42:44.837]                       msg <- conditionMessage(ex)
[17:42:44.837]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.837]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:44.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.837]                         fi_tmp[["mtime"]], msg)
[17:42:44.837]                       ex$message <- msg
[17:42:44.837]                       stop(ex)
[17:42:44.837]                     })
[17:42:44.837]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:44.837]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:44.837]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:44.837]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.837]                       fi <- file.info(pathname)
[17:42:44.837]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:44.837]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.837]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:44.837]                         fi[["size"]], fi[["mtime"]])
[17:42:44.837]                       stop(msg)
[17:42:44.837]                     }
[17:42:44.837]                     invisible(pathname)
[17:42:44.837]                   }
[17:42:44.837]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:44.837]                     rootPath = tempdir()) 
[17:42:44.837]                   {
[17:42:44.837]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:44.837]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:44.837]                       tmpdir = path, fileext = ".rds")
[17:42:44.837]                     save_rds(obj, file)
[17:42:44.837]                   }
[17:42:44.837]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:44.837]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.837]                   {
[17:42:44.837]                     inherits <- base::inherits
[17:42:44.837]                     invokeRestart <- base::invokeRestart
[17:42:44.837]                     is.null <- base::is.null
[17:42:44.837]                     muffled <- FALSE
[17:42:44.837]                     if (inherits(cond, "message")) {
[17:42:44.837]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:44.837]                       if (muffled) 
[17:42:44.837]                         invokeRestart("muffleMessage")
[17:42:44.837]                     }
[17:42:44.837]                     else if (inherits(cond, "warning")) {
[17:42:44.837]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:44.837]                       if (muffled) 
[17:42:44.837]                         invokeRestart("muffleWarning")
[17:42:44.837]                     }
[17:42:44.837]                     else if (inherits(cond, "condition")) {
[17:42:44.837]                       if (!is.null(pattern)) {
[17:42:44.837]                         computeRestarts <- base::computeRestarts
[17:42:44.837]                         grepl <- base::grepl
[17:42:44.837]                         restarts <- computeRestarts(cond)
[17:42:44.837]                         for (restart in restarts) {
[17:42:44.837]                           name <- restart$name
[17:42:44.837]                           if (is.null(name)) 
[17:42:44.837]                             next
[17:42:44.837]                           if (!grepl(pattern, name)) 
[17:42:44.837]                             next
[17:42:44.837]                           invokeRestart(restart)
[17:42:44.837]                           muffled <- TRUE
[17:42:44.837]                           break
[17:42:44.837]                         }
[17:42:44.837]                       }
[17:42:44.837]                     }
[17:42:44.837]                     invisible(muffled)
[17:42:44.837]                   }
[17:42:44.837]                   muffleCondition(cond)
[17:42:44.837]                 })
[17:42:44.837]             }))
[17:42:44.837]             future::FutureResult(value = ...future.value$value, 
[17:42:44.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.837]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.837]                     ...future.globalenv.names))
[17:42:44.837]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.837]         }, condition = base::local({
[17:42:44.837]             c <- base::c
[17:42:44.837]             inherits <- base::inherits
[17:42:44.837]             invokeRestart <- base::invokeRestart
[17:42:44.837]             length <- base::length
[17:42:44.837]             list <- base::list
[17:42:44.837]             seq.int <- base::seq.int
[17:42:44.837]             signalCondition <- base::signalCondition
[17:42:44.837]             sys.calls <- base::sys.calls
[17:42:44.837]             `[[` <- base::`[[`
[17:42:44.837]             `+` <- base::`+`
[17:42:44.837]             `<<-` <- base::`<<-`
[17:42:44.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.837]                   3L)]
[17:42:44.837]             }
[17:42:44.837]             function(cond) {
[17:42:44.837]                 is_error <- inherits(cond, "error")
[17:42:44.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.837]                   NULL)
[17:42:44.837]                 if (is_error) {
[17:42:44.837]                   sessionInformation <- function() {
[17:42:44.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.837]                       search = base::search(), system = base::Sys.info())
[17:42:44.837]                   }
[17:42:44.837]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.837]                     cond$call), session = sessionInformation(), 
[17:42:44.837]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.837]                   signalCondition(cond)
[17:42:44.837]                 }
[17:42:44.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.837]                 "immediateCondition"))) {
[17:42:44.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.837]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.837]                   if (TRUE && !signal) {
[17:42:44.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.837]                     {
[17:42:44.837]                       inherits <- base::inherits
[17:42:44.837]                       invokeRestart <- base::invokeRestart
[17:42:44.837]                       is.null <- base::is.null
[17:42:44.837]                       muffled <- FALSE
[17:42:44.837]                       if (inherits(cond, "message")) {
[17:42:44.837]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.837]                         if (muffled) 
[17:42:44.837]                           invokeRestart("muffleMessage")
[17:42:44.837]                       }
[17:42:44.837]                       else if (inherits(cond, "warning")) {
[17:42:44.837]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.837]                         if (muffled) 
[17:42:44.837]                           invokeRestart("muffleWarning")
[17:42:44.837]                       }
[17:42:44.837]                       else if (inherits(cond, "condition")) {
[17:42:44.837]                         if (!is.null(pattern)) {
[17:42:44.837]                           computeRestarts <- base::computeRestarts
[17:42:44.837]                           grepl <- base::grepl
[17:42:44.837]                           restarts <- computeRestarts(cond)
[17:42:44.837]                           for (restart in restarts) {
[17:42:44.837]                             name <- restart$name
[17:42:44.837]                             if (is.null(name)) 
[17:42:44.837]                               next
[17:42:44.837]                             if (!grepl(pattern, name)) 
[17:42:44.837]                               next
[17:42:44.837]                             invokeRestart(restart)
[17:42:44.837]                             muffled <- TRUE
[17:42:44.837]                             break
[17:42:44.837]                           }
[17:42:44.837]                         }
[17:42:44.837]                       }
[17:42:44.837]                       invisible(muffled)
[17:42:44.837]                     }
[17:42:44.837]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.837]                   }
[17:42:44.837]                 }
[17:42:44.837]                 else {
[17:42:44.837]                   if (TRUE) {
[17:42:44.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.837]                     {
[17:42:44.837]                       inherits <- base::inherits
[17:42:44.837]                       invokeRestart <- base::invokeRestart
[17:42:44.837]                       is.null <- base::is.null
[17:42:44.837]                       muffled <- FALSE
[17:42:44.837]                       if (inherits(cond, "message")) {
[17:42:44.837]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.837]                         if (muffled) 
[17:42:44.837]                           invokeRestart("muffleMessage")
[17:42:44.837]                       }
[17:42:44.837]                       else if (inherits(cond, "warning")) {
[17:42:44.837]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.837]                         if (muffled) 
[17:42:44.837]                           invokeRestart("muffleWarning")
[17:42:44.837]                       }
[17:42:44.837]                       else if (inherits(cond, "condition")) {
[17:42:44.837]                         if (!is.null(pattern)) {
[17:42:44.837]                           computeRestarts <- base::computeRestarts
[17:42:44.837]                           grepl <- base::grepl
[17:42:44.837]                           restarts <- computeRestarts(cond)
[17:42:44.837]                           for (restart in restarts) {
[17:42:44.837]                             name <- restart$name
[17:42:44.837]                             if (is.null(name)) 
[17:42:44.837]                               next
[17:42:44.837]                             if (!grepl(pattern, name)) 
[17:42:44.837]                               next
[17:42:44.837]                             invokeRestart(restart)
[17:42:44.837]                             muffled <- TRUE
[17:42:44.837]                             break
[17:42:44.837]                           }
[17:42:44.837]                         }
[17:42:44.837]                       }
[17:42:44.837]                       invisible(muffled)
[17:42:44.837]                     }
[17:42:44.837]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.837]                   }
[17:42:44.837]                 }
[17:42:44.837]             }
[17:42:44.837]         }))
[17:42:44.837]     }, error = function(ex) {
[17:42:44.837]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.837]                 ...future.rng), started = ...future.startTime, 
[17:42:44.837]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.837]             version = "1.8"), class = "FutureResult")
[17:42:44.837]     }, finally = {
[17:42:44.837]         if (!identical(...future.workdir, getwd())) 
[17:42:44.837]             setwd(...future.workdir)
[17:42:44.837]         {
[17:42:44.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.837]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.837]             }
[17:42:44.837]             base::options(...future.oldOptions)
[17:42:44.837]             if (.Platform$OS.type == "windows") {
[17:42:44.837]                 old_names <- names(...future.oldEnvVars)
[17:42:44.837]                 envs <- base::Sys.getenv()
[17:42:44.837]                 names <- names(envs)
[17:42:44.837]                 common <- intersect(names, old_names)
[17:42:44.837]                 added <- setdiff(names, old_names)
[17:42:44.837]                 removed <- setdiff(old_names, names)
[17:42:44.837]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.837]                   envs[common]]
[17:42:44.837]                 NAMES <- toupper(changed)
[17:42:44.837]                 args <- list()
[17:42:44.837]                 for (kk in seq_along(NAMES)) {
[17:42:44.837]                   name <- changed[[kk]]
[17:42:44.837]                   NAME <- NAMES[[kk]]
[17:42:44.837]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.837]                     next
[17:42:44.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.837]                 }
[17:42:44.837]                 NAMES <- toupper(added)
[17:42:44.837]                 for (kk in seq_along(NAMES)) {
[17:42:44.837]                   name <- added[[kk]]
[17:42:44.837]                   NAME <- NAMES[[kk]]
[17:42:44.837]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.837]                     next
[17:42:44.837]                   args[[name]] <- ""
[17:42:44.837]                 }
[17:42:44.837]                 NAMES <- toupper(removed)
[17:42:44.837]                 for (kk in seq_along(NAMES)) {
[17:42:44.837]                   name <- removed[[kk]]
[17:42:44.837]                   NAME <- NAMES[[kk]]
[17:42:44.837]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.837]                     next
[17:42:44.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.837]                 }
[17:42:44.837]                 if (length(args) > 0) 
[17:42:44.837]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.837]             }
[17:42:44.837]             else {
[17:42:44.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.837]             }
[17:42:44.837]             {
[17:42:44.837]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.837]                   0L) {
[17:42:44.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.837]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.837]                   base::options(opts)
[17:42:44.837]                 }
[17:42:44.837]                 {
[17:42:44.837]                   {
[17:42:44.837]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:44.837]                     NULL
[17:42:44.837]                   }
[17:42:44.837]                   options(future.plan = NULL)
[17:42:44.837]                   if (is.na(NA_character_)) 
[17:42:44.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.837]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:44.837]                     envir = parent.frame()) 
[17:42:44.837]                   {
[17:42:44.837]                     default_workers <- missing(workers)
[17:42:44.837]                     if (is.function(workers)) 
[17:42:44.837]                       workers <- workers()
[17:42:44.837]                     workers <- structure(as.integer(workers), 
[17:42:44.837]                       class = class(workers))
[17:42:44.837]                     stop_if_not(is.finite(workers), workers >= 
[17:42:44.837]                       1L)
[17:42:44.837]                     if ((workers == 1L && !inherits(workers, 
[17:42:44.837]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:44.837]                       if (default_workers) 
[17:42:44.837]                         supportsMulticore(warn = TRUE)
[17:42:44.837]                       return(sequential(..., envir = envir))
[17:42:44.837]                     }
[17:42:44.837]                     oopts <- options(mc.cores = workers)
[17:42:44.837]                     on.exit(options(oopts))
[17:42:44.837]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:44.837]                       envir = envir)
[17:42:44.837]                     if (!future$lazy) 
[17:42:44.837]                       future <- run(future)
[17:42:44.837]                     invisible(future)
[17:42:44.837]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.837]                 }
[17:42:44.837]             }
[17:42:44.837]         }
[17:42:44.837]     })
[17:42:44.837]     if (TRUE) {
[17:42:44.837]         base::sink(type = "output", split = FALSE)
[17:42:44.837]         if (TRUE) {
[17:42:44.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.837]         }
[17:42:44.837]         else {
[17:42:44.837]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.837]         }
[17:42:44.837]         base::close(...future.stdout)
[17:42:44.837]         ...future.stdout <- NULL
[17:42:44.837]     }
[17:42:44.837]     ...future.result$conditions <- ...future.conditions
[17:42:44.837]     ...future.result$finished <- base::Sys.time()
[17:42:44.837]     ...future.result
[17:42:44.837] }
[17:42:44.840] requestCore(): workers = 2
[17:42:44.842] MulticoreFuture started
[17:42:44.842] - Launch lazy future ... done
[17:42:44.843] run() for ‘MulticoreFuture’ ... done
[17:42:44.843] plan(): Setting new future strategy stack:
[17:42:44.843] List of future strategies:
[17:42:44.843] 1. sequential:
[17:42:44.843]    - args: function (..., envir = parent.frame())
[17:42:44.843]    - tweaked: FALSE
[17:42:44.843]    - call: NULL
[17:42:44.845] plan(): nbrOfWorkers() = 1
[17:42:44.847] plan(): Setting new future strategy stack:
[17:42:44.847] List of future strategies:
[17:42:44.847] 1. multicore:
[17:42:44.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:44.847]    - tweaked: FALSE
[17:42:44.847]    - call: plan(strategy)
[17:42:44.853] plan(): nbrOfWorkers() = 2
[17:42:44.860] signalConditions() ...
[17:42:44.861]  - include = ‘immediateCondition’
[17:42:44.861]  - exclude = 
[17:42:44.861]  - resignal = FALSE
[17:42:44.861]  - Number of conditions: 1
[17:42:44.861] signalConditions() ... done
[17:42:44.862] signalConditions() ...
[17:42:44.862]  - include = ‘immediateCondition’
[17:42:44.862]  - exclude = 
[17:42:44.862]  - resignal = FALSE
[17:42:44.862]  - Number of conditions: 1
[17:42:44.863] signalConditions() ... done
[17:42:44.863] Future state: ‘finished’
[17:42:44.863] signalConditions() ...
[17:42:44.863]  - include = ‘condition’
[17:42:44.863]  - exclude = ‘immediateCondition’
[17:42:44.864]  - resignal = TRUE
[17:42:44.864]  - Number of conditions: 1
[17:42:44.864]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:44.864] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:44"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.893] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.893] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.894] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.894] Searching for globals ... DONE
[17:42:44.894] Resolving globals: TRUE
[17:42:44.895] Resolving any globals that are futures ...
[17:42:44.895] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.895] Resolving any globals that are futures ... DONE
[17:42:44.895] Resolving futures part of globals (recursively) ...
[17:42:44.895] resolve() on list ...
[17:42:44.895]  recursive: 99
[17:42:44.896]  length: 1
[17:42:44.896]  elements: ‘ii’
[17:42:44.896]  length: 0 (resolved future 1)
[17:42:44.896] resolve() on list ... DONE
[17:42:44.896] - globals: [1] ‘ii’
[17:42:44.896] Resolving futures part of globals (recursively) ... DONE
[17:42:44.896] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.897] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.897] - globals: [1] ‘ii’
[17:42:44.897] 
[17:42:44.897] getGlobalsAndPackages() ... DONE
[17:42:44.897] run() for ‘Future’ ...
[17:42:44.897] - state: ‘created’
[17:42:44.897] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:44.901] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:44.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:44.901]   - Field: ‘label’
[17:42:44.901]   - Field: ‘local’
[17:42:44.902]   - Field: ‘owner’
[17:42:44.902]   - Field: ‘envir’
[17:42:44.902]   - Field: ‘workers’
[17:42:44.902]   - Field: ‘packages’
[17:42:44.902]   - Field: ‘gc’
[17:42:44.902]   - Field: ‘job’
[17:42:44.902]   - Field: ‘conditions’
[17:42:44.902]   - Field: ‘expr’
[17:42:44.902]   - Field: ‘uuid’
[17:42:44.902]   - Field: ‘seed’
[17:42:44.903]   - Field: ‘version’
[17:42:44.903]   - Field: ‘result’
[17:42:44.903]   - Field: ‘asynchronous’
[17:42:44.903]   - Field: ‘calls’
[17:42:44.903]   - Field: ‘globals’
[17:42:44.903]   - Field: ‘stdout’
[17:42:44.903]   - Field: ‘earlySignal’
[17:42:44.903]   - Field: ‘lazy’
[17:42:44.903]   - Field: ‘state’
[17:42:44.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:44.904] - Launch lazy future ...
[17:42:44.904] Packages needed by the future expression (n = 0): <none>
[17:42:44.904] Packages needed by future strategies (n = 0): <none>
[17:42:44.904] {
[17:42:44.904]     {
[17:42:44.904]         {
[17:42:44.904]             ...future.startTime <- base::Sys.time()
[17:42:44.904]             {
[17:42:44.904]                 {
[17:42:44.904]                   {
[17:42:44.904]                     {
[17:42:44.904]                       base::local({
[17:42:44.904]                         has_future <- base::requireNamespace("future", 
[17:42:44.904]                           quietly = TRUE)
[17:42:44.904]                         if (has_future) {
[17:42:44.904]                           ns <- base::getNamespace("future")
[17:42:44.904]                           version <- ns[[".package"]][["version"]]
[17:42:44.904]                           if (is.null(version)) 
[17:42:44.904]                             version <- utils::packageVersion("future")
[17:42:44.904]                         }
[17:42:44.904]                         else {
[17:42:44.904]                           version <- NULL
[17:42:44.904]                         }
[17:42:44.904]                         if (!has_future || version < "1.8.0") {
[17:42:44.904]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.904]                             "", base::R.version$version.string), 
[17:42:44.904]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.904]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.904]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.904]                               "release", "version")], collapse = " "), 
[17:42:44.904]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.904]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.904]                             info)
[17:42:44.904]                           info <- base::paste(info, collapse = "; ")
[17:42:44.904]                           if (!has_future) {
[17:42:44.904]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.904]                               info)
[17:42:44.904]                           }
[17:42:44.904]                           else {
[17:42:44.904]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.904]                               info, version)
[17:42:44.904]                           }
[17:42:44.904]                           base::stop(msg)
[17:42:44.904]                         }
[17:42:44.904]                       })
[17:42:44.904]                     }
[17:42:44.904]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:44.904]                     base::options(mc.cores = 1L)
[17:42:44.904]                   }
[17:42:44.904]                   options(future.plan = NULL)
[17:42:44.904]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.904]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.904]                 }
[17:42:44.904]                 ...future.workdir <- getwd()
[17:42:44.904]             }
[17:42:44.904]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.904]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.904]         }
[17:42:44.904]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.904]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.904]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.904]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.904]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.904]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.904]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.904]             base::names(...future.oldOptions))
[17:42:44.904]     }
[17:42:44.904]     if (FALSE) {
[17:42:44.904]     }
[17:42:44.904]     else {
[17:42:44.904]         if (TRUE) {
[17:42:44.904]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.904]                 open = "w")
[17:42:44.904]         }
[17:42:44.904]         else {
[17:42:44.904]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.904]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.904]         }
[17:42:44.904]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.904]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.904]             base::sink(type = "output", split = FALSE)
[17:42:44.904]             base::close(...future.stdout)
[17:42:44.904]         }, add = TRUE)
[17:42:44.904]     }
[17:42:44.904]     ...future.frame <- base::sys.nframe()
[17:42:44.904]     ...future.conditions <- base::list()
[17:42:44.904]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.904]     if (FALSE) {
[17:42:44.904]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.904]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.904]     }
[17:42:44.904]     ...future.result <- base::tryCatch({
[17:42:44.904]         base::withCallingHandlers({
[17:42:44.904]             ...future.value <- base::withVisible(base::local({
[17:42:44.904]                 withCallingHandlers({
[17:42:44.904]                   {
[17:42:44.904]                     b <- a * ii
[17:42:44.904]                     a <- 0
[17:42:44.904]                     b
[17:42:44.904]                   }
[17:42:44.904]                 }, immediateCondition = function(cond) {
[17:42:44.904]                   save_rds <- function (object, pathname, ...) 
[17:42:44.904]                   {
[17:42:44.904]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:44.904]                     if (file_test("-f", pathname_tmp)) {
[17:42:44.904]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.904]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:44.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.904]                         fi_tmp[["mtime"]])
[17:42:44.904]                     }
[17:42:44.904]                     tryCatch({
[17:42:44.904]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:44.904]                     }, error = function(ex) {
[17:42:44.904]                       msg <- conditionMessage(ex)
[17:42:44.904]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.904]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:44.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.904]                         fi_tmp[["mtime"]], msg)
[17:42:44.904]                       ex$message <- msg
[17:42:44.904]                       stop(ex)
[17:42:44.904]                     })
[17:42:44.904]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:44.904]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:44.904]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:44.904]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.904]                       fi <- file.info(pathname)
[17:42:44.904]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:44.904]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.904]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:44.904]                         fi[["size"]], fi[["mtime"]])
[17:42:44.904]                       stop(msg)
[17:42:44.904]                     }
[17:42:44.904]                     invisible(pathname)
[17:42:44.904]                   }
[17:42:44.904]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:44.904]                     rootPath = tempdir()) 
[17:42:44.904]                   {
[17:42:44.904]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:44.904]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:44.904]                       tmpdir = path, fileext = ".rds")
[17:42:44.904]                     save_rds(obj, file)
[17:42:44.904]                   }
[17:42:44.904]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:44.904]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.904]                   {
[17:42:44.904]                     inherits <- base::inherits
[17:42:44.904]                     invokeRestart <- base::invokeRestart
[17:42:44.904]                     is.null <- base::is.null
[17:42:44.904]                     muffled <- FALSE
[17:42:44.904]                     if (inherits(cond, "message")) {
[17:42:44.904]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:44.904]                       if (muffled) 
[17:42:44.904]                         invokeRestart("muffleMessage")
[17:42:44.904]                     }
[17:42:44.904]                     else if (inherits(cond, "warning")) {
[17:42:44.904]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:44.904]                       if (muffled) 
[17:42:44.904]                         invokeRestart("muffleWarning")
[17:42:44.904]                     }
[17:42:44.904]                     else if (inherits(cond, "condition")) {
[17:42:44.904]                       if (!is.null(pattern)) {
[17:42:44.904]                         computeRestarts <- base::computeRestarts
[17:42:44.904]                         grepl <- base::grepl
[17:42:44.904]                         restarts <- computeRestarts(cond)
[17:42:44.904]                         for (restart in restarts) {
[17:42:44.904]                           name <- restart$name
[17:42:44.904]                           if (is.null(name)) 
[17:42:44.904]                             next
[17:42:44.904]                           if (!grepl(pattern, name)) 
[17:42:44.904]                             next
[17:42:44.904]                           invokeRestart(restart)
[17:42:44.904]                           muffled <- TRUE
[17:42:44.904]                           break
[17:42:44.904]                         }
[17:42:44.904]                       }
[17:42:44.904]                     }
[17:42:44.904]                     invisible(muffled)
[17:42:44.904]                   }
[17:42:44.904]                   muffleCondition(cond)
[17:42:44.904]                 })
[17:42:44.904]             }))
[17:42:44.904]             future::FutureResult(value = ...future.value$value, 
[17:42:44.904]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.904]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.904]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.904]                     ...future.globalenv.names))
[17:42:44.904]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.904]         }, condition = base::local({
[17:42:44.904]             c <- base::c
[17:42:44.904]             inherits <- base::inherits
[17:42:44.904]             invokeRestart <- base::invokeRestart
[17:42:44.904]             length <- base::length
[17:42:44.904]             list <- base::list
[17:42:44.904]             seq.int <- base::seq.int
[17:42:44.904]             signalCondition <- base::signalCondition
[17:42:44.904]             sys.calls <- base::sys.calls
[17:42:44.904]             `[[` <- base::`[[`
[17:42:44.904]             `+` <- base::`+`
[17:42:44.904]             `<<-` <- base::`<<-`
[17:42:44.904]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.904]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.904]                   3L)]
[17:42:44.904]             }
[17:42:44.904]             function(cond) {
[17:42:44.904]                 is_error <- inherits(cond, "error")
[17:42:44.904]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.904]                   NULL)
[17:42:44.904]                 if (is_error) {
[17:42:44.904]                   sessionInformation <- function() {
[17:42:44.904]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.904]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.904]                       search = base::search(), system = base::Sys.info())
[17:42:44.904]                   }
[17:42:44.904]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.904]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.904]                     cond$call), session = sessionInformation(), 
[17:42:44.904]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.904]                   signalCondition(cond)
[17:42:44.904]                 }
[17:42:44.904]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.904]                 "immediateCondition"))) {
[17:42:44.904]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.904]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.904]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.904]                   if (TRUE && !signal) {
[17:42:44.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.904]                     {
[17:42:44.904]                       inherits <- base::inherits
[17:42:44.904]                       invokeRestart <- base::invokeRestart
[17:42:44.904]                       is.null <- base::is.null
[17:42:44.904]                       muffled <- FALSE
[17:42:44.904]                       if (inherits(cond, "message")) {
[17:42:44.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.904]                         if (muffled) 
[17:42:44.904]                           invokeRestart("muffleMessage")
[17:42:44.904]                       }
[17:42:44.904]                       else if (inherits(cond, "warning")) {
[17:42:44.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.904]                         if (muffled) 
[17:42:44.904]                           invokeRestart("muffleWarning")
[17:42:44.904]                       }
[17:42:44.904]                       else if (inherits(cond, "condition")) {
[17:42:44.904]                         if (!is.null(pattern)) {
[17:42:44.904]                           computeRestarts <- base::computeRestarts
[17:42:44.904]                           grepl <- base::grepl
[17:42:44.904]                           restarts <- computeRestarts(cond)
[17:42:44.904]                           for (restart in restarts) {
[17:42:44.904]                             name <- restart$name
[17:42:44.904]                             if (is.null(name)) 
[17:42:44.904]                               next
[17:42:44.904]                             if (!grepl(pattern, name)) 
[17:42:44.904]                               next
[17:42:44.904]                             invokeRestart(restart)
[17:42:44.904]                             muffled <- TRUE
[17:42:44.904]                             break
[17:42:44.904]                           }
[17:42:44.904]                         }
[17:42:44.904]                       }
[17:42:44.904]                       invisible(muffled)
[17:42:44.904]                     }
[17:42:44.904]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.904]                   }
[17:42:44.904]                 }
[17:42:44.904]                 else {
[17:42:44.904]                   if (TRUE) {
[17:42:44.904]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.904]                     {
[17:42:44.904]                       inherits <- base::inherits
[17:42:44.904]                       invokeRestart <- base::invokeRestart
[17:42:44.904]                       is.null <- base::is.null
[17:42:44.904]                       muffled <- FALSE
[17:42:44.904]                       if (inherits(cond, "message")) {
[17:42:44.904]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.904]                         if (muffled) 
[17:42:44.904]                           invokeRestart("muffleMessage")
[17:42:44.904]                       }
[17:42:44.904]                       else if (inherits(cond, "warning")) {
[17:42:44.904]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.904]                         if (muffled) 
[17:42:44.904]                           invokeRestart("muffleWarning")
[17:42:44.904]                       }
[17:42:44.904]                       else if (inherits(cond, "condition")) {
[17:42:44.904]                         if (!is.null(pattern)) {
[17:42:44.904]                           computeRestarts <- base::computeRestarts
[17:42:44.904]                           grepl <- base::grepl
[17:42:44.904]                           restarts <- computeRestarts(cond)
[17:42:44.904]                           for (restart in restarts) {
[17:42:44.904]                             name <- restart$name
[17:42:44.904]                             if (is.null(name)) 
[17:42:44.904]                               next
[17:42:44.904]                             if (!grepl(pattern, name)) 
[17:42:44.904]                               next
[17:42:44.904]                             invokeRestart(restart)
[17:42:44.904]                             muffled <- TRUE
[17:42:44.904]                             break
[17:42:44.904]                           }
[17:42:44.904]                         }
[17:42:44.904]                       }
[17:42:44.904]                       invisible(muffled)
[17:42:44.904]                     }
[17:42:44.904]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.904]                   }
[17:42:44.904]                 }
[17:42:44.904]             }
[17:42:44.904]         }))
[17:42:44.904]     }, error = function(ex) {
[17:42:44.904]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.904]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.904]                 ...future.rng), started = ...future.startTime, 
[17:42:44.904]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.904]             version = "1.8"), class = "FutureResult")
[17:42:44.904]     }, finally = {
[17:42:44.904]         if (!identical(...future.workdir, getwd())) 
[17:42:44.904]             setwd(...future.workdir)
[17:42:44.904]         {
[17:42:44.904]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.904]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.904]             }
[17:42:44.904]             base::options(...future.oldOptions)
[17:42:44.904]             if (.Platform$OS.type == "windows") {
[17:42:44.904]                 old_names <- names(...future.oldEnvVars)
[17:42:44.904]                 envs <- base::Sys.getenv()
[17:42:44.904]                 names <- names(envs)
[17:42:44.904]                 common <- intersect(names, old_names)
[17:42:44.904]                 added <- setdiff(names, old_names)
[17:42:44.904]                 removed <- setdiff(old_names, names)
[17:42:44.904]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.904]                   envs[common]]
[17:42:44.904]                 NAMES <- toupper(changed)
[17:42:44.904]                 args <- list()
[17:42:44.904]                 for (kk in seq_along(NAMES)) {
[17:42:44.904]                   name <- changed[[kk]]
[17:42:44.904]                   NAME <- NAMES[[kk]]
[17:42:44.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.904]                     next
[17:42:44.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.904]                 }
[17:42:44.904]                 NAMES <- toupper(added)
[17:42:44.904]                 for (kk in seq_along(NAMES)) {
[17:42:44.904]                   name <- added[[kk]]
[17:42:44.904]                   NAME <- NAMES[[kk]]
[17:42:44.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.904]                     next
[17:42:44.904]                   args[[name]] <- ""
[17:42:44.904]                 }
[17:42:44.904]                 NAMES <- toupper(removed)
[17:42:44.904]                 for (kk in seq_along(NAMES)) {
[17:42:44.904]                   name <- removed[[kk]]
[17:42:44.904]                   NAME <- NAMES[[kk]]
[17:42:44.904]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.904]                     next
[17:42:44.904]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.904]                 }
[17:42:44.904]                 if (length(args) > 0) 
[17:42:44.904]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.904]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.904]             }
[17:42:44.904]             else {
[17:42:44.904]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.904]             }
[17:42:44.904]             {
[17:42:44.904]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.904]                   0L) {
[17:42:44.904]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.904]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.904]                   base::options(opts)
[17:42:44.904]                 }
[17:42:44.904]                 {
[17:42:44.904]                   {
[17:42:44.904]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:44.904]                     NULL
[17:42:44.904]                   }
[17:42:44.904]                   options(future.plan = NULL)
[17:42:44.904]                   if (is.na(NA_character_)) 
[17:42:44.904]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.904]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.904]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:44.904]                     envir = parent.frame()) 
[17:42:44.904]                   {
[17:42:44.904]                     default_workers <- missing(workers)
[17:42:44.904]                     if (is.function(workers)) 
[17:42:44.904]                       workers <- workers()
[17:42:44.904]                     workers <- structure(as.integer(workers), 
[17:42:44.904]                       class = class(workers))
[17:42:44.904]                     stop_if_not(is.finite(workers), workers >= 
[17:42:44.904]                       1L)
[17:42:44.904]                     if ((workers == 1L && !inherits(workers, 
[17:42:44.904]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:44.904]                       if (default_workers) 
[17:42:44.904]                         supportsMulticore(warn = TRUE)
[17:42:44.904]                       return(sequential(..., envir = envir))
[17:42:44.904]                     }
[17:42:44.904]                     oopts <- options(mc.cores = workers)
[17:42:44.904]                     on.exit(options(oopts))
[17:42:44.904]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:44.904]                       envir = envir)
[17:42:44.904]                     if (!future$lazy) 
[17:42:44.904]                       future <- run(future)
[17:42:44.904]                     invisible(future)
[17:42:44.904]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.904]                 }
[17:42:44.904]             }
[17:42:44.904]         }
[17:42:44.904]     })
[17:42:44.904]     if (TRUE) {
[17:42:44.904]         base::sink(type = "output", split = FALSE)
[17:42:44.904]         if (TRUE) {
[17:42:44.904]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.904]         }
[17:42:44.904]         else {
[17:42:44.904]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.904]         }
[17:42:44.904]         base::close(...future.stdout)
[17:42:44.904]         ...future.stdout <- NULL
[17:42:44.904]     }
[17:42:44.904]     ...future.result$conditions <- ...future.conditions
[17:42:44.904]     ...future.result$finished <- base::Sys.time()
[17:42:44.904]     ...future.result
[17:42:44.904] }
[17:42:44.907] assign_globals() ...
[17:42:44.907] List of 1
[17:42:44.907]  $ ii: int 1
[17:42:44.907]  - attr(*, "where")=List of 1
[17:42:44.907]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.907]  - attr(*, "resolved")= logi TRUE
[17:42:44.907]  - attr(*, "total_size")= num 56
[17:42:44.907]  - attr(*, "already-done")= logi TRUE
[17:42:44.909] - copied ‘ii’ to environment
[17:42:44.910] assign_globals() ... done
[17:42:44.910] requestCore(): workers = 2
[17:42:44.912] MulticoreFuture started
[17:42:44.912] - Launch lazy future ... done
[17:42:44.913] plan(): Setting new future strategy stack:
[17:42:44.912] run() for ‘MulticoreFuture’ ... done
[17:42:44.913] List of future strategies:
[17:42:44.913] 1. sequential:
[17:42:44.913]    - args: function (..., envir = parent.frame())
[17:42:44.913]    - tweaked: FALSE
[17:42:44.913]    - call: NULL
[17:42:44.918] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.918] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.919] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.920] plan(): Setting new future strategy stack:
[17:42:44.920] List of future strategies:
[17:42:44.920] 1. multicore:
[17:42:44.920]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:44.920]    - tweaked: FALSE
[17:42:44.920]    - call: plan(strategy)
[17:42:44.923] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.924] Searching for globals ... DONE
[17:42:44.924] Resolving globals: TRUE
[17:42:44.924] Resolving any globals that are futures ...
[17:42:44.924] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.925] Resolving any globals that are futures ... DONE
[17:42:44.925] plan(): nbrOfWorkers() = 2
[17:42:44.925] Resolving futures part of globals (recursively) ...
[17:42:44.926] resolve() on list ...
[17:42:44.926]  recursive: 99
[17:42:44.926]  length: 1
[17:42:44.927]  elements: ‘ii’
[17:42:44.927]  length: 0 (resolved future 1)
[17:42:44.927] resolve() on list ... DONE
[17:42:44.927] - globals: [1] ‘ii’
[17:42:44.927] Resolving futures part of globals (recursively) ... DONE
[17:42:44.928] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.928] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.928] - globals: [1] ‘ii’
[17:42:44.929] 
[17:42:44.929] getGlobalsAndPackages() ... DONE
[17:42:44.929] run() for ‘Future’ ...
[17:42:44.929] - state: ‘created’
[17:42:44.929] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:44.934] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:44.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:44.935]   - Field: ‘label’
[17:42:44.935]   - Field: ‘local’
[17:42:44.935]   - Field: ‘owner’
[17:42:44.935]   - Field: ‘envir’
[17:42:44.935]   - Field: ‘workers’
[17:42:44.935]   - Field: ‘packages’
[17:42:44.935]   - Field: ‘gc’
[17:42:44.936]   - Field: ‘job’
[17:42:44.936]   - Field: ‘conditions’
[17:42:44.936]   - Field: ‘expr’
[17:42:44.936]   - Field: ‘uuid’
[17:42:44.936]   - Field: ‘seed’
[17:42:44.936]   - Field: ‘version’
[17:42:44.937]   - Field: ‘result’
[17:42:44.937]   - Field: ‘asynchronous’
[17:42:44.937]   - Field: ‘calls’
[17:42:44.937]   - Field: ‘globals’
[17:42:44.937]   - Field: ‘stdout’
[17:42:44.937]   - Field: ‘earlySignal’
[17:42:44.937]   - Field: ‘lazy’
[17:42:44.938]   - Field: ‘state’
[17:42:44.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:44.938] - Launch lazy future ...
[17:42:44.938] Packages needed by the future expression (n = 0): <none>
[17:42:44.939] Packages needed by future strategies (n = 0): <none>
[17:42:44.939] {
[17:42:44.939]     {
[17:42:44.939]         {
[17:42:44.939]             ...future.startTime <- base::Sys.time()
[17:42:44.939]             {
[17:42:44.939]                 {
[17:42:44.939]                   {
[17:42:44.939]                     {
[17:42:44.939]                       base::local({
[17:42:44.939]                         has_future <- base::requireNamespace("future", 
[17:42:44.939]                           quietly = TRUE)
[17:42:44.939]                         if (has_future) {
[17:42:44.939]                           ns <- base::getNamespace("future")
[17:42:44.939]                           version <- ns[[".package"]][["version"]]
[17:42:44.939]                           if (is.null(version)) 
[17:42:44.939]                             version <- utils::packageVersion("future")
[17:42:44.939]                         }
[17:42:44.939]                         else {
[17:42:44.939]                           version <- NULL
[17:42:44.939]                         }
[17:42:44.939]                         if (!has_future || version < "1.8.0") {
[17:42:44.939]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.939]                             "", base::R.version$version.string), 
[17:42:44.939]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.939]                               "release", "version")], collapse = " "), 
[17:42:44.939]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.939]                             info)
[17:42:44.939]                           info <- base::paste(info, collapse = "; ")
[17:42:44.939]                           if (!has_future) {
[17:42:44.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.939]                               info)
[17:42:44.939]                           }
[17:42:44.939]                           else {
[17:42:44.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.939]                               info, version)
[17:42:44.939]                           }
[17:42:44.939]                           base::stop(msg)
[17:42:44.939]                         }
[17:42:44.939]                       })
[17:42:44.939]                     }
[17:42:44.939]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:44.939]                     base::options(mc.cores = 1L)
[17:42:44.939]                   }
[17:42:44.939]                   options(future.plan = NULL)
[17:42:44.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.939]                 }
[17:42:44.939]                 ...future.workdir <- getwd()
[17:42:44.939]             }
[17:42:44.939]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.939]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.939]         }
[17:42:44.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.939]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.939]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.939]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.939]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.939]             base::names(...future.oldOptions))
[17:42:44.939]     }
[17:42:44.939]     if (FALSE) {
[17:42:44.939]     }
[17:42:44.939]     else {
[17:42:44.939]         if (TRUE) {
[17:42:44.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.939]                 open = "w")
[17:42:44.939]         }
[17:42:44.939]         else {
[17:42:44.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.939]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.939]         }
[17:42:44.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.939]             base::sink(type = "output", split = FALSE)
[17:42:44.939]             base::close(...future.stdout)
[17:42:44.939]         }, add = TRUE)
[17:42:44.939]     }
[17:42:44.939]     ...future.frame <- base::sys.nframe()
[17:42:44.939]     ...future.conditions <- base::list()
[17:42:44.939]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.939]     if (FALSE) {
[17:42:44.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.939]     }
[17:42:44.939]     ...future.result <- base::tryCatch({
[17:42:44.939]         base::withCallingHandlers({
[17:42:44.939]             ...future.value <- base::withVisible(base::local({
[17:42:44.939]                 withCallingHandlers({
[17:42:44.939]                   {
[17:42:44.939]                     b <- a * ii
[17:42:44.939]                     a <- 0
[17:42:44.939]                     b
[17:42:44.939]                   }
[17:42:44.939]                 }, immediateCondition = function(cond) {
[17:42:44.939]                   save_rds <- function (object, pathname, ...) 
[17:42:44.939]                   {
[17:42:44.939]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:44.939]                     if (file_test("-f", pathname_tmp)) {
[17:42:44.939]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.939]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:44.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.939]                         fi_tmp[["mtime"]])
[17:42:44.939]                     }
[17:42:44.939]                     tryCatch({
[17:42:44.939]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:44.939]                     }, error = function(ex) {
[17:42:44.939]                       msg <- conditionMessage(ex)
[17:42:44.939]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.939]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:44.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.939]                         fi_tmp[["mtime"]], msg)
[17:42:44.939]                       ex$message <- msg
[17:42:44.939]                       stop(ex)
[17:42:44.939]                     })
[17:42:44.939]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:44.939]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:44.939]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:44.939]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.939]                       fi <- file.info(pathname)
[17:42:44.939]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:44.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.939]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:44.939]                         fi[["size"]], fi[["mtime"]])
[17:42:44.939]                       stop(msg)
[17:42:44.939]                     }
[17:42:44.939]                     invisible(pathname)
[17:42:44.939]                   }
[17:42:44.939]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:44.939]                     rootPath = tempdir()) 
[17:42:44.939]                   {
[17:42:44.939]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:44.939]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:44.939]                       tmpdir = path, fileext = ".rds")
[17:42:44.939]                     save_rds(obj, file)
[17:42:44.939]                   }
[17:42:44.939]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:44.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.939]                   {
[17:42:44.939]                     inherits <- base::inherits
[17:42:44.939]                     invokeRestart <- base::invokeRestart
[17:42:44.939]                     is.null <- base::is.null
[17:42:44.939]                     muffled <- FALSE
[17:42:44.939]                     if (inherits(cond, "message")) {
[17:42:44.939]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:44.939]                       if (muffled) 
[17:42:44.939]                         invokeRestart("muffleMessage")
[17:42:44.939]                     }
[17:42:44.939]                     else if (inherits(cond, "warning")) {
[17:42:44.939]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:44.939]                       if (muffled) 
[17:42:44.939]                         invokeRestart("muffleWarning")
[17:42:44.939]                     }
[17:42:44.939]                     else if (inherits(cond, "condition")) {
[17:42:44.939]                       if (!is.null(pattern)) {
[17:42:44.939]                         computeRestarts <- base::computeRestarts
[17:42:44.939]                         grepl <- base::grepl
[17:42:44.939]                         restarts <- computeRestarts(cond)
[17:42:44.939]                         for (restart in restarts) {
[17:42:44.939]                           name <- restart$name
[17:42:44.939]                           if (is.null(name)) 
[17:42:44.939]                             next
[17:42:44.939]                           if (!grepl(pattern, name)) 
[17:42:44.939]                             next
[17:42:44.939]                           invokeRestart(restart)
[17:42:44.939]                           muffled <- TRUE
[17:42:44.939]                           break
[17:42:44.939]                         }
[17:42:44.939]                       }
[17:42:44.939]                     }
[17:42:44.939]                     invisible(muffled)
[17:42:44.939]                   }
[17:42:44.939]                   muffleCondition(cond)
[17:42:44.939]                 })
[17:42:44.939]             }))
[17:42:44.939]             future::FutureResult(value = ...future.value$value, 
[17:42:44.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.939]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.939]                     ...future.globalenv.names))
[17:42:44.939]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.939]         }, condition = base::local({
[17:42:44.939]             c <- base::c
[17:42:44.939]             inherits <- base::inherits
[17:42:44.939]             invokeRestart <- base::invokeRestart
[17:42:44.939]             length <- base::length
[17:42:44.939]             list <- base::list
[17:42:44.939]             seq.int <- base::seq.int
[17:42:44.939]             signalCondition <- base::signalCondition
[17:42:44.939]             sys.calls <- base::sys.calls
[17:42:44.939]             `[[` <- base::`[[`
[17:42:44.939]             `+` <- base::`+`
[17:42:44.939]             `<<-` <- base::`<<-`
[17:42:44.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.939]                   3L)]
[17:42:44.939]             }
[17:42:44.939]             function(cond) {
[17:42:44.939]                 is_error <- inherits(cond, "error")
[17:42:44.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.939]                   NULL)
[17:42:44.939]                 if (is_error) {
[17:42:44.939]                   sessionInformation <- function() {
[17:42:44.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.939]                       search = base::search(), system = base::Sys.info())
[17:42:44.939]                   }
[17:42:44.939]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.939]                     cond$call), session = sessionInformation(), 
[17:42:44.939]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.939]                   signalCondition(cond)
[17:42:44.939]                 }
[17:42:44.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.939]                 "immediateCondition"))) {
[17:42:44.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.939]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.939]                   if (TRUE && !signal) {
[17:42:44.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.939]                     {
[17:42:44.939]                       inherits <- base::inherits
[17:42:44.939]                       invokeRestart <- base::invokeRestart
[17:42:44.939]                       is.null <- base::is.null
[17:42:44.939]                       muffled <- FALSE
[17:42:44.939]                       if (inherits(cond, "message")) {
[17:42:44.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.939]                         if (muffled) 
[17:42:44.939]                           invokeRestart("muffleMessage")
[17:42:44.939]                       }
[17:42:44.939]                       else if (inherits(cond, "warning")) {
[17:42:44.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.939]                         if (muffled) 
[17:42:44.939]                           invokeRestart("muffleWarning")
[17:42:44.939]                       }
[17:42:44.939]                       else if (inherits(cond, "condition")) {
[17:42:44.939]                         if (!is.null(pattern)) {
[17:42:44.939]                           computeRestarts <- base::computeRestarts
[17:42:44.939]                           grepl <- base::grepl
[17:42:44.939]                           restarts <- computeRestarts(cond)
[17:42:44.939]                           for (restart in restarts) {
[17:42:44.939]                             name <- restart$name
[17:42:44.939]                             if (is.null(name)) 
[17:42:44.939]                               next
[17:42:44.939]                             if (!grepl(pattern, name)) 
[17:42:44.939]                               next
[17:42:44.939]                             invokeRestart(restart)
[17:42:44.939]                             muffled <- TRUE
[17:42:44.939]                             break
[17:42:44.939]                           }
[17:42:44.939]                         }
[17:42:44.939]                       }
[17:42:44.939]                       invisible(muffled)
[17:42:44.939]                     }
[17:42:44.939]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.939]                   }
[17:42:44.939]                 }
[17:42:44.939]                 else {
[17:42:44.939]                   if (TRUE) {
[17:42:44.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.939]                     {
[17:42:44.939]                       inherits <- base::inherits
[17:42:44.939]                       invokeRestart <- base::invokeRestart
[17:42:44.939]                       is.null <- base::is.null
[17:42:44.939]                       muffled <- FALSE
[17:42:44.939]                       if (inherits(cond, "message")) {
[17:42:44.939]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.939]                         if (muffled) 
[17:42:44.939]                           invokeRestart("muffleMessage")
[17:42:44.939]                       }
[17:42:44.939]                       else if (inherits(cond, "warning")) {
[17:42:44.939]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.939]                         if (muffled) 
[17:42:44.939]                           invokeRestart("muffleWarning")
[17:42:44.939]                       }
[17:42:44.939]                       else if (inherits(cond, "condition")) {
[17:42:44.939]                         if (!is.null(pattern)) {
[17:42:44.939]                           computeRestarts <- base::computeRestarts
[17:42:44.939]                           grepl <- base::grepl
[17:42:44.939]                           restarts <- computeRestarts(cond)
[17:42:44.939]                           for (restart in restarts) {
[17:42:44.939]                             name <- restart$name
[17:42:44.939]                             if (is.null(name)) 
[17:42:44.939]                               next
[17:42:44.939]                             if (!grepl(pattern, name)) 
[17:42:44.939]                               next
[17:42:44.939]                             invokeRestart(restart)
[17:42:44.939]                             muffled <- TRUE
[17:42:44.939]                             break
[17:42:44.939]                           }
[17:42:44.939]                         }
[17:42:44.939]                       }
[17:42:44.939]                       invisible(muffled)
[17:42:44.939]                     }
[17:42:44.939]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.939]                   }
[17:42:44.939]                 }
[17:42:44.939]             }
[17:42:44.939]         }))
[17:42:44.939]     }, error = function(ex) {
[17:42:44.939]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.939]                 ...future.rng), started = ...future.startTime, 
[17:42:44.939]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.939]             version = "1.8"), class = "FutureResult")
[17:42:44.939]     }, finally = {
[17:42:44.939]         if (!identical(...future.workdir, getwd())) 
[17:42:44.939]             setwd(...future.workdir)
[17:42:44.939]         {
[17:42:44.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.939]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.939]             }
[17:42:44.939]             base::options(...future.oldOptions)
[17:42:44.939]             if (.Platform$OS.type == "windows") {
[17:42:44.939]                 old_names <- names(...future.oldEnvVars)
[17:42:44.939]                 envs <- base::Sys.getenv()
[17:42:44.939]                 names <- names(envs)
[17:42:44.939]                 common <- intersect(names, old_names)
[17:42:44.939]                 added <- setdiff(names, old_names)
[17:42:44.939]                 removed <- setdiff(old_names, names)
[17:42:44.939]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.939]                   envs[common]]
[17:42:44.939]                 NAMES <- toupper(changed)
[17:42:44.939]                 args <- list()
[17:42:44.939]                 for (kk in seq_along(NAMES)) {
[17:42:44.939]                   name <- changed[[kk]]
[17:42:44.939]                   NAME <- NAMES[[kk]]
[17:42:44.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.939]                     next
[17:42:44.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.939]                 }
[17:42:44.939]                 NAMES <- toupper(added)
[17:42:44.939]                 for (kk in seq_along(NAMES)) {
[17:42:44.939]                   name <- added[[kk]]
[17:42:44.939]                   NAME <- NAMES[[kk]]
[17:42:44.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.939]                     next
[17:42:44.939]                   args[[name]] <- ""
[17:42:44.939]                 }
[17:42:44.939]                 NAMES <- toupper(removed)
[17:42:44.939]                 for (kk in seq_along(NAMES)) {
[17:42:44.939]                   name <- removed[[kk]]
[17:42:44.939]                   NAME <- NAMES[[kk]]
[17:42:44.939]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.939]                     next
[17:42:44.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.939]                 }
[17:42:44.939]                 if (length(args) > 0) 
[17:42:44.939]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.939]             }
[17:42:44.939]             else {
[17:42:44.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.939]             }
[17:42:44.939]             {
[17:42:44.939]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.939]                   0L) {
[17:42:44.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.939]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.939]                   base::options(opts)
[17:42:44.939]                 }
[17:42:44.939]                 {
[17:42:44.939]                   {
[17:42:44.939]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:44.939]                     NULL
[17:42:44.939]                   }
[17:42:44.939]                   options(future.plan = NULL)
[17:42:44.939]                   if (is.na(NA_character_)) 
[17:42:44.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.939]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:44.939]                     envir = parent.frame()) 
[17:42:44.939]                   {
[17:42:44.939]                     default_workers <- missing(workers)
[17:42:44.939]                     if (is.function(workers)) 
[17:42:44.939]                       workers <- workers()
[17:42:44.939]                     workers <- structure(as.integer(workers), 
[17:42:44.939]                       class = class(workers))
[17:42:44.939]                     stop_if_not(is.finite(workers), workers >= 
[17:42:44.939]                       1L)
[17:42:44.939]                     if ((workers == 1L && !inherits(workers, 
[17:42:44.939]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:44.939]                       if (default_workers) 
[17:42:44.939]                         supportsMulticore(warn = TRUE)
[17:42:44.939]                       return(sequential(..., envir = envir))
[17:42:44.939]                     }
[17:42:44.939]                     oopts <- options(mc.cores = workers)
[17:42:44.939]                     on.exit(options(oopts))
[17:42:44.939]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:44.939]                       envir = envir)
[17:42:44.939]                     if (!future$lazy) 
[17:42:44.939]                       future <- run(future)
[17:42:44.939]                     invisible(future)
[17:42:44.939]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.939]                 }
[17:42:44.939]             }
[17:42:44.939]         }
[17:42:44.939]     })
[17:42:44.939]     if (TRUE) {
[17:42:44.939]         base::sink(type = "output", split = FALSE)
[17:42:44.939]         if (TRUE) {
[17:42:44.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.939]         }
[17:42:44.939]         else {
[17:42:44.939]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.939]         }
[17:42:44.939]         base::close(...future.stdout)
[17:42:44.939]         ...future.stdout <- NULL
[17:42:44.939]     }
[17:42:44.939]     ...future.result$conditions <- ...future.conditions
[17:42:44.939]     ...future.result$finished <- base::Sys.time()
[17:42:44.939]     ...future.result
[17:42:44.939] }
[17:42:44.943] assign_globals() ...
[17:42:44.943] List of 1
[17:42:44.943]  $ ii: int 2
[17:42:44.943]  - attr(*, "where")=List of 1
[17:42:44.943]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.943]  - attr(*, "resolved")= logi TRUE
[17:42:44.943]  - attr(*, "total_size")= num 56
[17:42:44.943]  - attr(*, "already-done")= logi TRUE
[17:42:44.946] - copied ‘ii’ to environment
[17:42:44.946] assign_globals() ... done
[17:42:44.946] requestCore(): workers = 2
[17:42:44.949] MulticoreFuture started
[17:42:44.949] - Launch lazy future ... done
[17:42:44.949] run() for ‘MulticoreFuture’ ... done
[17:42:44.950] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:44.951] getGlobalsAndPackages() ...
[17:42:44.950] List of future strategies:
[17:42:44.950] 1. sequential:
[17:42:44.950]    - args: function (..., envir = parent.frame())
[17:42:44.950]    - tweaked: FALSE
[17:42:44.950]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:44.951] Searching for globals...
[17:42:44.951] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:44.953] plan(): Setting new future strategy stack:
[17:42:44.953] List of future strategies:
[17:42:44.953] 1. multicore:
[17:42:44.953]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:44.953]    - tweaked: FALSE
[17:42:44.953]    - call: plan(strategy)
[17:42:44.954] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.954] Searching for globals ... DONE
[17:42:44.954] Resolving globals: TRUE
[17:42:44.954] Resolving any globals that are futures ...
[17:42:44.954] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:44.954] Resolving any globals that are futures ... DONE
[17:42:44.955] Resolving futures part of globals (recursively) ...
[17:42:44.956] resolve() on list ...
[17:42:44.956]  recursive: 99
[17:42:44.956]  length: 1
[17:42:44.956]  elements: ‘ii’
[17:42:44.956]  length: 0 (resolved future 1)
[17:42:44.956] resolve() on list ... DONE
[17:42:44.957] - globals: [1] ‘ii’
[17:42:44.957] Resolving futures part of globals (recursively) ... DONE
[17:42:44.957] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:44.958] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:44.958] - globals: [1] ‘ii’
[17:42:44.958] 
[17:42:44.958] plan(): nbrOfWorkers() = 2
[17:42:44.958] getGlobalsAndPackages() ... DONE
[17:42:44.959] run() for ‘Future’ ...
[17:42:44.959] - state: ‘created’
[17:42:44.959] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:44.964] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:44.964] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:44.964]   - Field: ‘label’
[17:42:44.964]   - Field: ‘local’
[17:42:44.964]   - Field: ‘owner’
[17:42:44.965]   - Field: ‘envir’
[17:42:44.968]   - Field: ‘workers’
[17:42:44.969]   - Field: ‘packages’
[17:42:44.969]   - Field: ‘gc’
[17:42:44.969]   - Field: ‘job’
[17:42:44.970]   - Field: ‘conditions’
[17:42:44.970]   - Field: ‘expr’
[17:42:44.970]   - Field: ‘uuid’
[17:42:44.970]   - Field: ‘seed’
[17:42:44.970]   - Field: ‘version’
[17:42:44.971]   - Field: ‘result’
[17:42:44.971]   - Field: ‘asynchronous’
[17:42:44.971]   - Field: ‘calls’
[17:42:44.972]   - Field: ‘globals’
[17:42:44.972]   - Field: ‘stdout’
[17:42:44.972]   - Field: ‘earlySignal’
[17:42:44.972]   - Field: ‘lazy’
[17:42:44.972]   - Field: ‘state’
[17:42:44.973] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:44.973] - Launch lazy future ...
[17:42:44.973] Packages needed by the future expression (n = 0): <none>
[17:42:44.974] Packages needed by future strategies (n = 0): <none>
[17:42:44.974] {
[17:42:44.974]     {
[17:42:44.974]         {
[17:42:44.974]             ...future.startTime <- base::Sys.time()
[17:42:44.974]             {
[17:42:44.974]                 {
[17:42:44.974]                   {
[17:42:44.974]                     {
[17:42:44.974]                       base::local({
[17:42:44.974]                         has_future <- base::requireNamespace("future", 
[17:42:44.974]                           quietly = TRUE)
[17:42:44.974]                         if (has_future) {
[17:42:44.974]                           ns <- base::getNamespace("future")
[17:42:44.974]                           version <- ns[[".package"]][["version"]]
[17:42:44.974]                           if (is.null(version)) 
[17:42:44.974]                             version <- utils::packageVersion("future")
[17:42:44.974]                         }
[17:42:44.974]                         else {
[17:42:44.974]                           version <- NULL
[17:42:44.974]                         }
[17:42:44.974]                         if (!has_future || version < "1.8.0") {
[17:42:44.974]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:44.974]                             "", base::R.version$version.string), 
[17:42:44.974]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:44.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:44.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:44.974]                               "release", "version")], collapse = " "), 
[17:42:44.974]                             hostname = base::Sys.info()[["nodename"]])
[17:42:44.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:44.974]                             info)
[17:42:44.974]                           info <- base::paste(info, collapse = "; ")
[17:42:44.974]                           if (!has_future) {
[17:42:44.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:44.974]                               info)
[17:42:44.974]                           }
[17:42:44.974]                           else {
[17:42:44.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:44.974]                               info, version)
[17:42:44.974]                           }
[17:42:44.974]                           base::stop(msg)
[17:42:44.974]                         }
[17:42:44.974]                       })
[17:42:44.974]                     }
[17:42:44.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:44.974]                     base::options(mc.cores = 1L)
[17:42:44.974]                   }
[17:42:44.974]                   options(future.plan = NULL)
[17:42:44.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:44.974]                 }
[17:42:44.974]                 ...future.workdir <- getwd()
[17:42:44.974]             }
[17:42:44.974]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:44.974]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:44.974]         }
[17:42:44.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:44.974]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:44.974]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:44.974]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:44.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:44.974]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:44.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:44.974]             base::names(...future.oldOptions))
[17:42:44.974]     }
[17:42:44.974]     if (FALSE) {
[17:42:44.974]     }
[17:42:44.974]     else {
[17:42:44.974]         if (TRUE) {
[17:42:44.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:44.974]                 open = "w")
[17:42:44.974]         }
[17:42:44.974]         else {
[17:42:44.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:44.974]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:44.974]         }
[17:42:44.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:44.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:44.974]             base::sink(type = "output", split = FALSE)
[17:42:44.974]             base::close(...future.stdout)
[17:42:44.974]         }, add = TRUE)
[17:42:44.974]     }
[17:42:44.974]     ...future.frame <- base::sys.nframe()
[17:42:44.974]     ...future.conditions <- base::list()
[17:42:44.974]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:44.974]     if (FALSE) {
[17:42:44.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:44.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:44.974]     }
[17:42:44.974]     ...future.result <- base::tryCatch({
[17:42:44.974]         base::withCallingHandlers({
[17:42:44.974]             ...future.value <- base::withVisible(base::local({
[17:42:44.974]                 withCallingHandlers({
[17:42:44.974]                   {
[17:42:44.974]                     b <- a * ii
[17:42:44.974]                     a <- 0
[17:42:44.974]                     b
[17:42:44.974]                   }
[17:42:44.974]                 }, immediateCondition = function(cond) {
[17:42:44.974]                   save_rds <- function (object, pathname, ...) 
[17:42:44.974]                   {
[17:42:44.974]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:44.974]                     if (file_test("-f", pathname_tmp)) {
[17:42:44.974]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.974]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:44.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.974]                         fi_tmp[["mtime"]])
[17:42:44.974]                     }
[17:42:44.974]                     tryCatch({
[17:42:44.974]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:44.974]                     }, error = function(ex) {
[17:42:44.974]                       msg <- conditionMessage(ex)
[17:42:44.974]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.974]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:44.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.974]                         fi_tmp[["mtime"]], msg)
[17:42:44.974]                       ex$message <- msg
[17:42:44.974]                       stop(ex)
[17:42:44.974]                     })
[17:42:44.974]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:44.974]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:44.974]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:44.974]                       fi_tmp <- file.info(pathname_tmp)
[17:42:44.974]                       fi <- file.info(pathname)
[17:42:44.974]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:44.974]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:44.974]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:44.974]                         fi[["size"]], fi[["mtime"]])
[17:42:44.974]                       stop(msg)
[17:42:44.974]                     }
[17:42:44.974]                     invisible(pathname)
[17:42:44.974]                   }
[17:42:44.974]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:44.974]                     rootPath = tempdir()) 
[17:42:44.974]                   {
[17:42:44.974]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:44.974]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:44.974]                       tmpdir = path, fileext = ".rds")
[17:42:44.974]                     save_rds(obj, file)
[17:42:44.974]                   }
[17:42:44.974]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:44.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.974]                   {
[17:42:44.974]                     inherits <- base::inherits
[17:42:44.974]                     invokeRestart <- base::invokeRestart
[17:42:44.974]                     is.null <- base::is.null
[17:42:44.974]                     muffled <- FALSE
[17:42:44.974]                     if (inherits(cond, "message")) {
[17:42:44.974]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:44.974]                       if (muffled) 
[17:42:44.974]                         invokeRestart("muffleMessage")
[17:42:44.974]                     }
[17:42:44.974]                     else if (inherits(cond, "warning")) {
[17:42:44.974]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:44.974]                       if (muffled) 
[17:42:44.974]                         invokeRestart("muffleWarning")
[17:42:44.974]                     }
[17:42:44.974]                     else if (inherits(cond, "condition")) {
[17:42:44.974]                       if (!is.null(pattern)) {
[17:42:44.974]                         computeRestarts <- base::computeRestarts
[17:42:44.974]                         grepl <- base::grepl
[17:42:44.974]                         restarts <- computeRestarts(cond)
[17:42:44.974]                         for (restart in restarts) {
[17:42:44.974]                           name <- restart$name
[17:42:44.974]                           if (is.null(name)) 
[17:42:44.974]                             next
[17:42:44.974]                           if (!grepl(pattern, name)) 
[17:42:44.974]                             next
[17:42:44.974]                           invokeRestart(restart)
[17:42:44.974]                           muffled <- TRUE
[17:42:44.974]                           break
[17:42:44.974]                         }
[17:42:44.974]                       }
[17:42:44.974]                     }
[17:42:44.974]                     invisible(muffled)
[17:42:44.974]                   }
[17:42:44.974]                   muffleCondition(cond)
[17:42:44.974]                 })
[17:42:44.974]             }))
[17:42:44.974]             future::FutureResult(value = ...future.value$value, 
[17:42:44.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.974]                   ...future.rng), globalenv = if (FALSE) 
[17:42:44.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:44.974]                     ...future.globalenv.names))
[17:42:44.974]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:44.974]         }, condition = base::local({
[17:42:44.974]             c <- base::c
[17:42:44.974]             inherits <- base::inherits
[17:42:44.974]             invokeRestart <- base::invokeRestart
[17:42:44.974]             length <- base::length
[17:42:44.974]             list <- base::list
[17:42:44.974]             seq.int <- base::seq.int
[17:42:44.974]             signalCondition <- base::signalCondition
[17:42:44.974]             sys.calls <- base::sys.calls
[17:42:44.974]             `[[` <- base::`[[`
[17:42:44.974]             `+` <- base::`+`
[17:42:44.974]             `<<-` <- base::`<<-`
[17:42:44.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:44.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:44.974]                   3L)]
[17:42:44.974]             }
[17:42:44.974]             function(cond) {
[17:42:44.974]                 is_error <- inherits(cond, "error")
[17:42:44.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:44.974]                   NULL)
[17:42:44.974]                 if (is_error) {
[17:42:44.974]                   sessionInformation <- function() {
[17:42:44.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:44.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:44.974]                       search = base::search(), system = base::Sys.info())
[17:42:44.974]                   }
[17:42:44.974]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:44.974]                     cond$call), session = sessionInformation(), 
[17:42:44.974]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:44.974]                   signalCondition(cond)
[17:42:44.974]                 }
[17:42:44.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:44.974]                 "immediateCondition"))) {
[17:42:44.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:44.974]                   ...future.conditions[[length(...future.conditions) + 
[17:42:44.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:44.974]                   if (TRUE && !signal) {
[17:42:44.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.974]                     {
[17:42:44.974]                       inherits <- base::inherits
[17:42:44.974]                       invokeRestart <- base::invokeRestart
[17:42:44.974]                       is.null <- base::is.null
[17:42:44.974]                       muffled <- FALSE
[17:42:44.974]                       if (inherits(cond, "message")) {
[17:42:44.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.974]                         if (muffled) 
[17:42:44.974]                           invokeRestart("muffleMessage")
[17:42:44.974]                       }
[17:42:44.974]                       else if (inherits(cond, "warning")) {
[17:42:44.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.974]                         if (muffled) 
[17:42:44.974]                           invokeRestart("muffleWarning")
[17:42:44.974]                       }
[17:42:44.974]                       else if (inherits(cond, "condition")) {
[17:42:44.974]                         if (!is.null(pattern)) {
[17:42:44.974]                           computeRestarts <- base::computeRestarts
[17:42:44.974]                           grepl <- base::grepl
[17:42:44.974]                           restarts <- computeRestarts(cond)
[17:42:44.974]                           for (restart in restarts) {
[17:42:44.974]                             name <- restart$name
[17:42:44.974]                             if (is.null(name)) 
[17:42:44.974]                               next
[17:42:44.974]                             if (!grepl(pattern, name)) 
[17:42:44.974]                               next
[17:42:44.974]                             invokeRestart(restart)
[17:42:44.974]                             muffled <- TRUE
[17:42:44.974]                             break
[17:42:44.974]                           }
[17:42:44.974]                         }
[17:42:44.974]                       }
[17:42:44.974]                       invisible(muffled)
[17:42:44.974]                     }
[17:42:44.974]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.974]                   }
[17:42:44.974]                 }
[17:42:44.974]                 else {
[17:42:44.974]                   if (TRUE) {
[17:42:44.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:44.974]                     {
[17:42:44.974]                       inherits <- base::inherits
[17:42:44.974]                       invokeRestart <- base::invokeRestart
[17:42:44.974]                       is.null <- base::is.null
[17:42:44.974]                       muffled <- FALSE
[17:42:44.974]                       if (inherits(cond, "message")) {
[17:42:44.974]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:44.974]                         if (muffled) 
[17:42:44.974]                           invokeRestart("muffleMessage")
[17:42:44.974]                       }
[17:42:44.974]                       else if (inherits(cond, "warning")) {
[17:42:44.974]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:44.974]                         if (muffled) 
[17:42:44.974]                           invokeRestart("muffleWarning")
[17:42:44.974]                       }
[17:42:44.974]                       else if (inherits(cond, "condition")) {
[17:42:44.974]                         if (!is.null(pattern)) {
[17:42:44.974]                           computeRestarts <- base::computeRestarts
[17:42:44.974]                           grepl <- base::grepl
[17:42:44.974]                           restarts <- computeRestarts(cond)
[17:42:44.974]                           for (restart in restarts) {
[17:42:44.974]                             name <- restart$name
[17:42:44.974]                             if (is.null(name)) 
[17:42:44.974]                               next
[17:42:44.974]                             if (!grepl(pattern, name)) 
[17:42:44.974]                               next
[17:42:44.974]                             invokeRestart(restart)
[17:42:44.974]                             muffled <- TRUE
[17:42:44.974]                             break
[17:42:44.974]                           }
[17:42:44.974]                         }
[17:42:44.974]                       }
[17:42:44.974]                       invisible(muffled)
[17:42:44.974]                     }
[17:42:44.974]                     muffleCondition(cond, pattern = "^muffle")
[17:42:44.974]                   }
[17:42:44.974]                 }
[17:42:44.974]             }
[17:42:44.974]         }))
[17:42:44.974]     }, error = function(ex) {
[17:42:44.974]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:44.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:44.974]                 ...future.rng), started = ...future.startTime, 
[17:42:44.974]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:44.974]             version = "1.8"), class = "FutureResult")
[17:42:44.974]     }, finally = {
[17:42:44.974]         if (!identical(...future.workdir, getwd())) 
[17:42:44.974]             setwd(...future.workdir)
[17:42:44.974]         {
[17:42:44.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:44.974]                 ...future.oldOptions$nwarnings <- NULL
[17:42:44.974]             }
[17:42:44.974]             base::options(...future.oldOptions)
[17:42:44.974]             if (.Platform$OS.type == "windows") {
[17:42:44.974]                 old_names <- names(...future.oldEnvVars)
[17:42:44.974]                 envs <- base::Sys.getenv()
[17:42:44.974]                 names <- names(envs)
[17:42:44.974]                 common <- intersect(names, old_names)
[17:42:44.974]                 added <- setdiff(names, old_names)
[17:42:44.974]                 removed <- setdiff(old_names, names)
[17:42:44.974]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:44.974]                   envs[common]]
[17:42:44.974]                 NAMES <- toupper(changed)
[17:42:44.974]                 args <- list()
[17:42:44.974]                 for (kk in seq_along(NAMES)) {
[17:42:44.974]                   name <- changed[[kk]]
[17:42:44.974]                   NAME <- NAMES[[kk]]
[17:42:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.974]                     next
[17:42:44.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.974]                 }
[17:42:44.974]                 NAMES <- toupper(added)
[17:42:44.974]                 for (kk in seq_along(NAMES)) {
[17:42:44.974]                   name <- added[[kk]]
[17:42:44.974]                   NAME <- NAMES[[kk]]
[17:42:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.974]                     next
[17:42:44.974]                   args[[name]] <- ""
[17:42:44.974]                 }
[17:42:44.974]                 NAMES <- toupper(removed)
[17:42:44.974]                 for (kk in seq_along(NAMES)) {
[17:42:44.974]                   name <- removed[[kk]]
[17:42:44.974]                   NAME <- NAMES[[kk]]
[17:42:44.974]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:44.974]                     next
[17:42:44.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:44.974]                 }
[17:42:44.974]                 if (length(args) > 0) 
[17:42:44.974]                   base::do.call(base::Sys.setenv, args = args)
[17:42:44.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:44.974]             }
[17:42:44.974]             else {
[17:42:44.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:44.974]             }
[17:42:44.974]             {
[17:42:44.974]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:44.974]                   0L) {
[17:42:44.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:44.974]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:44.974]                   base::options(opts)
[17:42:44.974]                 }
[17:42:44.974]                 {
[17:42:44.974]                   {
[17:42:44.974]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:44.974]                     NULL
[17:42:44.974]                   }
[17:42:44.974]                   options(future.plan = NULL)
[17:42:44.974]                   if (is.na(NA_character_)) 
[17:42:44.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:44.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:44.974]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:44.974]                     envir = parent.frame()) 
[17:42:44.974]                   {
[17:42:44.974]                     default_workers <- missing(workers)
[17:42:44.974]                     if (is.function(workers)) 
[17:42:44.974]                       workers <- workers()
[17:42:44.974]                     workers <- structure(as.integer(workers), 
[17:42:44.974]                       class = class(workers))
[17:42:44.974]                     stop_if_not(is.finite(workers), workers >= 
[17:42:44.974]                       1L)
[17:42:44.974]                     if ((workers == 1L && !inherits(workers, 
[17:42:44.974]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:44.974]                       if (default_workers) 
[17:42:44.974]                         supportsMulticore(warn = TRUE)
[17:42:44.974]                       return(sequential(..., envir = envir))
[17:42:44.974]                     }
[17:42:44.974]                     oopts <- options(mc.cores = workers)
[17:42:44.974]                     on.exit(options(oopts))
[17:42:44.974]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:44.974]                       envir = envir)
[17:42:44.974]                     if (!future$lazy) 
[17:42:44.974]                       future <- run(future)
[17:42:44.974]                     invisible(future)
[17:42:44.974]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:44.974]                 }
[17:42:44.974]             }
[17:42:44.974]         }
[17:42:44.974]     })
[17:42:44.974]     if (TRUE) {
[17:42:44.974]         base::sink(type = "output", split = FALSE)
[17:42:44.974]         if (TRUE) {
[17:42:44.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:44.974]         }
[17:42:44.974]         else {
[17:42:44.974]             ...future.result["stdout"] <- base::list(NULL)
[17:42:44.974]         }
[17:42:44.974]         base::close(...future.stdout)
[17:42:44.974]         ...future.stdout <- NULL
[17:42:44.974]     }
[17:42:44.974]     ...future.result$conditions <- ...future.conditions
[17:42:44.974]     ...future.result$finished <- base::Sys.time()
[17:42:44.974]     ...future.result
[17:42:44.974] }
[17:42:44.977] assign_globals() ...
[17:42:44.977] List of 1
[17:42:44.977]  $ ii: int 3
[17:42:44.977]  - attr(*, "where")=List of 1
[17:42:44.977]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:44.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:44.977]  - attr(*, "resolved")= logi TRUE
[17:42:44.977]  - attr(*, "total_size")= num 56
[17:42:44.977]  - attr(*, "already-done")= logi TRUE
[17:42:44.981] - copied ‘ii’ to environment
[17:42:44.982] assign_globals() ... done
[17:42:44.982] requestCore(): workers = 2
[17:42:44.982] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:44.997] MulticoreFuture started
[17:42:44.997] - Launch lazy future ... done
[17:42:44.997] run() for ‘MulticoreFuture’ ... done
[17:42:44.998] plan(): Setting new future strategy stack:
[17:42:44.998] List of future strategies:
[17:42:44.998] 1. sequential:
[17:42:44.998]    - args: function (..., envir = parent.frame())
[17:42:44.998]    - tweaked: FALSE
[17:42:44.998]    - call: NULL
[17:42:45.000] plan(): nbrOfWorkers() = 1
[17:42:45.002] plan(): Setting new future strategy stack:
[17:42:45.002] List of future strategies:
[17:42:45.002] 1. multicore:
[17:42:45.002]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.002]    - tweaked: FALSE
[17:42:45.002]    - call: plan(strategy)
[17:42:45.007] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.010] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.010] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.012] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:45.012] Searching for globals ... DONE
[17:42:45.012] Resolving globals: TRUE
[17:42:45.013] Resolving any globals that are futures ...
[17:42:45.013] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:45.013] Resolving any globals that are futures ... DONE
[17:42:45.013] Resolving futures part of globals (recursively) ...
[17:42:45.014] resolve() on list ...
[17:42:45.014]  recursive: 99
[17:42:45.014]  length: 1
[17:42:45.014]  elements: ‘ii’
[17:42:45.014]  length: 0 (resolved future 1)
[17:42:45.014] resolve() on list ... DONE
[17:42:45.014] - globals: [1] ‘ii’
[17:42:45.014] Resolving futures part of globals (recursively) ... DONE
[17:42:45.015] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:45.015] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.015] - globals: [1] ‘ii’
[17:42:45.015] 
[17:42:45.016] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.016] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.017] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.018] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:45.018] Searching for globals ... DONE
[17:42:45.018] Resolving globals: TRUE
[17:42:45.018] Resolving any globals that are futures ...
[17:42:45.019] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:45.019] Resolving any globals that are futures ... DONE
[17:42:45.019] Resolving futures part of globals (recursively) ...
[17:42:45.019] resolve() on list ...
[17:42:45.019]  recursive: 99
[17:42:45.020]  length: 1
[17:42:45.020]  elements: ‘ii’
[17:42:45.020]  length: 0 (resolved future 1)
[17:42:45.020] resolve() on list ... DONE
[17:42:45.020] - globals: [1] ‘ii’
[17:42:45.020] Resolving futures part of globals (recursively) ... DONE
[17:42:45.020] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:45.021] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.021] - globals: [1] ‘ii’
[17:42:45.021] 
[17:42:45.021] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.022] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.022] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.026] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:45.026] Searching for globals ... DONE
[17:42:45.026] Resolving globals: TRUE
[17:42:45.026] Resolving any globals that are futures ...
[17:42:45.026] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:45.027] Resolving any globals that are futures ... DONE
[17:42:45.027] Resolving futures part of globals (recursively) ...
[17:42:45.027] resolve() on list ...
[17:42:45.028]  recursive: 99
[17:42:45.028]  length: 1
[17:42:45.028]  elements: ‘ii’
[17:42:45.028]  length: 0 (resolved future 1)
[17:42:45.028] resolve() on list ... DONE
[17:42:45.028] - globals: [1] ‘ii’
[17:42:45.028] Resolving futures part of globals (recursively) ... DONE
[17:42:45.029] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:45.029] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.029] - globals: [1] ‘ii’
[17:42:45.029] 
[17:42:45.029] getGlobalsAndPackages() ... DONE
[17:42:45.030] run() for ‘Future’ ...
[17:42:45.030] - state: ‘created’
[17:42:45.030] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.034] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.034] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.035]   - Field: ‘label’
[17:42:45.035]   - Field: ‘local’
[17:42:45.035]   - Field: ‘owner’
[17:42:45.035]   - Field: ‘envir’
[17:42:45.035]   - Field: ‘workers’
[17:42:45.035]   - Field: ‘packages’
[17:42:45.035]   - Field: ‘gc’
[17:42:45.035]   - Field: ‘job’
[17:42:45.036]   - Field: ‘conditions’
[17:42:45.036]   - Field: ‘expr’
[17:42:45.036]   - Field: ‘uuid’
[17:42:45.036]   - Field: ‘seed’
[17:42:45.036]   - Field: ‘version’
[17:42:45.036]   - Field: ‘result’
[17:42:45.036]   - Field: ‘asynchronous’
[17:42:45.036]   - Field: ‘calls’
[17:42:45.036]   - Field: ‘globals’
[17:42:45.037]   - Field: ‘stdout’
[17:42:45.037]   - Field: ‘earlySignal’
[17:42:45.037]   - Field: ‘lazy’
[17:42:45.037]   - Field: ‘state’
[17:42:45.037] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.037] - Launch lazy future ...
[17:42:45.037] Packages needed by the future expression (n = 0): <none>
[17:42:45.038] Packages needed by future strategies (n = 0): <none>
[17:42:45.038] {
[17:42:45.038]     {
[17:42:45.038]         {
[17:42:45.038]             ...future.startTime <- base::Sys.time()
[17:42:45.038]             {
[17:42:45.038]                 {
[17:42:45.038]                   {
[17:42:45.038]                     {
[17:42:45.038]                       base::local({
[17:42:45.038]                         has_future <- base::requireNamespace("future", 
[17:42:45.038]                           quietly = TRUE)
[17:42:45.038]                         if (has_future) {
[17:42:45.038]                           ns <- base::getNamespace("future")
[17:42:45.038]                           version <- ns[[".package"]][["version"]]
[17:42:45.038]                           if (is.null(version)) 
[17:42:45.038]                             version <- utils::packageVersion("future")
[17:42:45.038]                         }
[17:42:45.038]                         else {
[17:42:45.038]                           version <- NULL
[17:42:45.038]                         }
[17:42:45.038]                         if (!has_future || version < "1.8.0") {
[17:42:45.038]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.038]                             "", base::R.version$version.string), 
[17:42:45.038]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.038]                               "release", "version")], collapse = " "), 
[17:42:45.038]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.038]                             info)
[17:42:45.038]                           info <- base::paste(info, collapse = "; ")
[17:42:45.038]                           if (!has_future) {
[17:42:45.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.038]                               info)
[17:42:45.038]                           }
[17:42:45.038]                           else {
[17:42:45.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.038]                               info, version)
[17:42:45.038]                           }
[17:42:45.038]                           base::stop(msg)
[17:42:45.038]                         }
[17:42:45.038]                       })
[17:42:45.038]                     }
[17:42:45.038]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.038]                     base::options(mc.cores = 1L)
[17:42:45.038]                   }
[17:42:45.038]                   options(future.plan = NULL)
[17:42:45.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.038]                 }
[17:42:45.038]                 ...future.workdir <- getwd()
[17:42:45.038]             }
[17:42:45.038]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.038]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.038]         }
[17:42:45.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.038]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.038]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.038]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.038]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.038]             base::names(...future.oldOptions))
[17:42:45.038]     }
[17:42:45.038]     if (FALSE) {
[17:42:45.038]     }
[17:42:45.038]     else {
[17:42:45.038]         if (TRUE) {
[17:42:45.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.038]                 open = "w")
[17:42:45.038]         }
[17:42:45.038]         else {
[17:42:45.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.038]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.038]         }
[17:42:45.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.038]             base::sink(type = "output", split = FALSE)
[17:42:45.038]             base::close(...future.stdout)
[17:42:45.038]         }, add = TRUE)
[17:42:45.038]     }
[17:42:45.038]     ...future.frame <- base::sys.nframe()
[17:42:45.038]     ...future.conditions <- base::list()
[17:42:45.038]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.038]     if (FALSE) {
[17:42:45.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.038]     }
[17:42:45.038]     ...future.result <- base::tryCatch({
[17:42:45.038]         base::withCallingHandlers({
[17:42:45.038]             ...future.value <- base::withVisible(base::local({
[17:42:45.038]                 withCallingHandlers({
[17:42:45.038]                   {
[17:42:45.038]                     b <- a * ii
[17:42:45.038]                     a <- 0
[17:42:45.038]                     b
[17:42:45.038]                   }
[17:42:45.038]                 }, immediateCondition = function(cond) {
[17:42:45.038]                   save_rds <- function (object, pathname, ...) 
[17:42:45.038]                   {
[17:42:45.038]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.038]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.038]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.038]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.038]                         fi_tmp[["mtime"]])
[17:42:45.038]                     }
[17:42:45.038]                     tryCatch({
[17:42:45.038]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.038]                     }, error = function(ex) {
[17:42:45.038]                       msg <- conditionMessage(ex)
[17:42:45.038]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.038]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.038]                         fi_tmp[["mtime"]], msg)
[17:42:45.038]                       ex$message <- msg
[17:42:45.038]                       stop(ex)
[17:42:45.038]                     })
[17:42:45.038]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.038]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.038]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.038]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.038]                       fi <- file.info(pathname)
[17:42:45.038]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.038]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.038]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.038]                         fi[["size"]], fi[["mtime"]])
[17:42:45.038]                       stop(msg)
[17:42:45.038]                     }
[17:42:45.038]                     invisible(pathname)
[17:42:45.038]                   }
[17:42:45.038]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.038]                     rootPath = tempdir()) 
[17:42:45.038]                   {
[17:42:45.038]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.038]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.038]                       tmpdir = path, fileext = ".rds")
[17:42:45.038]                     save_rds(obj, file)
[17:42:45.038]                   }
[17:42:45.038]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.038]                   {
[17:42:45.038]                     inherits <- base::inherits
[17:42:45.038]                     invokeRestart <- base::invokeRestart
[17:42:45.038]                     is.null <- base::is.null
[17:42:45.038]                     muffled <- FALSE
[17:42:45.038]                     if (inherits(cond, "message")) {
[17:42:45.038]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.038]                       if (muffled) 
[17:42:45.038]                         invokeRestart("muffleMessage")
[17:42:45.038]                     }
[17:42:45.038]                     else if (inherits(cond, "warning")) {
[17:42:45.038]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.038]                       if (muffled) 
[17:42:45.038]                         invokeRestart("muffleWarning")
[17:42:45.038]                     }
[17:42:45.038]                     else if (inherits(cond, "condition")) {
[17:42:45.038]                       if (!is.null(pattern)) {
[17:42:45.038]                         computeRestarts <- base::computeRestarts
[17:42:45.038]                         grepl <- base::grepl
[17:42:45.038]                         restarts <- computeRestarts(cond)
[17:42:45.038]                         for (restart in restarts) {
[17:42:45.038]                           name <- restart$name
[17:42:45.038]                           if (is.null(name)) 
[17:42:45.038]                             next
[17:42:45.038]                           if (!grepl(pattern, name)) 
[17:42:45.038]                             next
[17:42:45.038]                           invokeRestart(restart)
[17:42:45.038]                           muffled <- TRUE
[17:42:45.038]                           break
[17:42:45.038]                         }
[17:42:45.038]                       }
[17:42:45.038]                     }
[17:42:45.038]                     invisible(muffled)
[17:42:45.038]                   }
[17:42:45.038]                   muffleCondition(cond)
[17:42:45.038]                 })
[17:42:45.038]             }))
[17:42:45.038]             future::FutureResult(value = ...future.value$value, 
[17:42:45.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.038]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.038]                     ...future.globalenv.names))
[17:42:45.038]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.038]         }, condition = base::local({
[17:42:45.038]             c <- base::c
[17:42:45.038]             inherits <- base::inherits
[17:42:45.038]             invokeRestart <- base::invokeRestart
[17:42:45.038]             length <- base::length
[17:42:45.038]             list <- base::list
[17:42:45.038]             seq.int <- base::seq.int
[17:42:45.038]             signalCondition <- base::signalCondition
[17:42:45.038]             sys.calls <- base::sys.calls
[17:42:45.038]             `[[` <- base::`[[`
[17:42:45.038]             `+` <- base::`+`
[17:42:45.038]             `<<-` <- base::`<<-`
[17:42:45.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.038]                   3L)]
[17:42:45.038]             }
[17:42:45.038]             function(cond) {
[17:42:45.038]                 is_error <- inherits(cond, "error")
[17:42:45.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.038]                   NULL)
[17:42:45.038]                 if (is_error) {
[17:42:45.038]                   sessionInformation <- function() {
[17:42:45.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.038]                       search = base::search(), system = base::Sys.info())
[17:42:45.038]                   }
[17:42:45.038]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.038]                     cond$call), session = sessionInformation(), 
[17:42:45.038]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.038]                   signalCondition(cond)
[17:42:45.038]                 }
[17:42:45.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.038]                 "immediateCondition"))) {
[17:42:45.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.038]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.038]                   if (TRUE && !signal) {
[17:42:45.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.038]                     {
[17:42:45.038]                       inherits <- base::inherits
[17:42:45.038]                       invokeRestart <- base::invokeRestart
[17:42:45.038]                       is.null <- base::is.null
[17:42:45.038]                       muffled <- FALSE
[17:42:45.038]                       if (inherits(cond, "message")) {
[17:42:45.038]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.038]                         if (muffled) 
[17:42:45.038]                           invokeRestart("muffleMessage")
[17:42:45.038]                       }
[17:42:45.038]                       else if (inherits(cond, "warning")) {
[17:42:45.038]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.038]                         if (muffled) 
[17:42:45.038]                           invokeRestart("muffleWarning")
[17:42:45.038]                       }
[17:42:45.038]                       else if (inherits(cond, "condition")) {
[17:42:45.038]                         if (!is.null(pattern)) {
[17:42:45.038]                           computeRestarts <- base::computeRestarts
[17:42:45.038]                           grepl <- base::grepl
[17:42:45.038]                           restarts <- computeRestarts(cond)
[17:42:45.038]                           for (restart in restarts) {
[17:42:45.038]                             name <- restart$name
[17:42:45.038]                             if (is.null(name)) 
[17:42:45.038]                               next
[17:42:45.038]                             if (!grepl(pattern, name)) 
[17:42:45.038]                               next
[17:42:45.038]                             invokeRestart(restart)
[17:42:45.038]                             muffled <- TRUE
[17:42:45.038]                             break
[17:42:45.038]                           }
[17:42:45.038]                         }
[17:42:45.038]                       }
[17:42:45.038]                       invisible(muffled)
[17:42:45.038]                     }
[17:42:45.038]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.038]                   }
[17:42:45.038]                 }
[17:42:45.038]                 else {
[17:42:45.038]                   if (TRUE) {
[17:42:45.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.038]                     {
[17:42:45.038]                       inherits <- base::inherits
[17:42:45.038]                       invokeRestart <- base::invokeRestart
[17:42:45.038]                       is.null <- base::is.null
[17:42:45.038]                       muffled <- FALSE
[17:42:45.038]                       if (inherits(cond, "message")) {
[17:42:45.038]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.038]                         if (muffled) 
[17:42:45.038]                           invokeRestart("muffleMessage")
[17:42:45.038]                       }
[17:42:45.038]                       else if (inherits(cond, "warning")) {
[17:42:45.038]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.038]                         if (muffled) 
[17:42:45.038]                           invokeRestart("muffleWarning")
[17:42:45.038]                       }
[17:42:45.038]                       else if (inherits(cond, "condition")) {
[17:42:45.038]                         if (!is.null(pattern)) {
[17:42:45.038]                           computeRestarts <- base::computeRestarts
[17:42:45.038]                           grepl <- base::grepl
[17:42:45.038]                           restarts <- computeRestarts(cond)
[17:42:45.038]                           for (restart in restarts) {
[17:42:45.038]                             name <- restart$name
[17:42:45.038]                             if (is.null(name)) 
[17:42:45.038]                               next
[17:42:45.038]                             if (!grepl(pattern, name)) 
[17:42:45.038]                               next
[17:42:45.038]                             invokeRestart(restart)
[17:42:45.038]                             muffled <- TRUE
[17:42:45.038]                             break
[17:42:45.038]                           }
[17:42:45.038]                         }
[17:42:45.038]                       }
[17:42:45.038]                       invisible(muffled)
[17:42:45.038]                     }
[17:42:45.038]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.038]                   }
[17:42:45.038]                 }
[17:42:45.038]             }
[17:42:45.038]         }))
[17:42:45.038]     }, error = function(ex) {
[17:42:45.038]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.038]                 ...future.rng), started = ...future.startTime, 
[17:42:45.038]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.038]             version = "1.8"), class = "FutureResult")
[17:42:45.038]     }, finally = {
[17:42:45.038]         if (!identical(...future.workdir, getwd())) 
[17:42:45.038]             setwd(...future.workdir)
[17:42:45.038]         {
[17:42:45.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.038]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.038]             }
[17:42:45.038]             base::options(...future.oldOptions)
[17:42:45.038]             if (.Platform$OS.type == "windows") {
[17:42:45.038]                 old_names <- names(...future.oldEnvVars)
[17:42:45.038]                 envs <- base::Sys.getenv()
[17:42:45.038]                 names <- names(envs)
[17:42:45.038]                 common <- intersect(names, old_names)
[17:42:45.038]                 added <- setdiff(names, old_names)
[17:42:45.038]                 removed <- setdiff(old_names, names)
[17:42:45.038]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.038]                   envs[common]]
[17:42:45.038]                 NAMES <- toupper(changed)
[17:42:45.038]                 args <- list()
[17:42:45.038]                 for (kk in seq_along(NAMES)) {
[17:42:45.038]                   name <- changed[[kk]]
[17:42:45.038]                   NAME <- NAMES[[kk]]
[17:42:45.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.038]                     next
[17:42:45.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.038]                 }
[17:42:45.038]                 NAMES <- toupper(added)
[17:42:45.038]                 for (kk in seq_along(NAMES)) {
[17:42:45.038]                   name <- added[[kk]]
[17:42:45.038]                   NAME <- NAMES[[kk]]
[17:42:45.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.038]                     next
[17:42:45.038]                   args[[name]] <- ""
[17:42:45.038]                 }
[17:42:45.038]                 NAMES <- toupper(removed)
[17:42:45.038]                 for (kk in seq_along(NAMES)) {
[17:42:45.038]                   name <- removed[[kk]]
[17:42:45.038]                   NAME <- NAMES[[kk]]
[17:42:45.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.038]                     next
[17:42:45.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.038]                 }
[17:42:45.038]                 if (length(args) > 0) 
[17:42:45.038]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.038]             }
[17:42:45.038]             else {
[17:42:45.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.038]             }
[17:42:45.038]             {
[17:42:45.038]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.038]                   0L) {
[17:42:45.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.038]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.038]                   base::options(opts)
[17:42:45.038]                 }
[17:42:45.038]                 {
[17:42:45.038]                   {
[17:42:45.038]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.038]                     NULL
[17:42:45.038]                   }
[17:42:45.038]                   options(future.plan = NULL)
[17:42:45.038]                   if (is.na(NA_character_)) 
[17:42:45.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.038]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.038]                     envir = parent.frame()) 
[17:42:45.038]                   {
[17:42:45.038]                     default_workers <- missing(workers)
[17:42:45.038]                     if (is.function(workers)) 
[17:42:45.038]                       workers <- workers()
[17:42:45.038]                     workers <- structure(as.integer(workers), 
[17:42:45.038]                       class = class(workers))
[17:42:45.038]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.038]                       1L)
[17:42:45.038]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.038]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.038]                       if (default_workers) 
[17:42:45.038]                         supportsMulticore(warn = TRUE)
[17:42:45.038]                       return(sequential(..., envir = envir))
[17:42:45.038]                     }
[17:42:45.038]                     oopts <- options(mc.cores = workers)
[17:42:45.038]                     on.exit(options(oopts))
[17:42:45.038]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.038]                       envir = envir)
[17:42:45.038]                     if (!future$lazy) 
[17:42:45.038]                       future <- run(future)
[17:42:45.038]                     invisible(future)
[17:42:45.038]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.038]                 }
[17:42:45.038]             }
[17:42:45.038]         }
[17:42:45.038]     })
[17:42:45.038]     if (TRUE) {
[17:42:45.038]         base::sink(type = "output", split = FALSE)
[17:42:45.038]         if (TRUE) {
[17:42:45.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.038]         }
[17:42:45.038]         else {
[17:42:45.038]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.038]         }
[17:42:45.038]         base::close(...future.stdout)
[17:42:45.038]         ...future.stdout <- NULL
[17:42:45.038]     }
[17:42:45.038]     ...future.result$conditions <- ...future.conditions
[17:42:45.038]     ...future.result$finished <- base::Sys.time()
[17:42:45.038]     ...future.result
[17:42:45.038] }
[17:42:45.041] assign_globals() ...
[17:42:45.041] List of 1
[17:42:45.041]  $ ii: int 1
[17:42:45.041]  - attr(*, "where")=List of 1
[17:42:45.041]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.041]  - attr(*, "resolved")= logi TRUE
[17:42:45.041]  - attr(*, "total_size")= num 56
[17:42:45.041]  - attr(*, "already-done")= logi TRUE
[17:42:45.043] - copied ‘ii’ to environment
[17:42:45.044] assign_globals() ... done
[17:42:45.044] requestCore(): workers = 2
[17:42:45.046] MulticoreFuture started
[17:42:45.046] - Launch lazy future ... done
[17:42:45.046] run() for ‘MulticoreFuture’ ... done
[17:42:45.047] plan(): Setting new future strategy stack:
[17:42:45.047] List of future strategies:
[17:42:45.047] 1. sequential:
[17:42:45.047]    - args: function (..., envir = parent.frame())
[17:42:45.047]    - tweaked: FALSE
[17:42:45.047]    - call: NULL
[17:42:45.048] plan(): nbrOfWorkers() = 1
[17:42:45.050] plan(): Setting new future strategy stack:
[17:42:45.051] List of future strategies:
[17:42:45.051] 1. multicore:
[17:42:45.051]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.051]    - tweaked: FALSE
[17:42:45.051]    - call: plan(strategy)
[17:42:45.056] plan(): nbrOfWorkers() = 2
[17:42:45.063] signalConditions() ...
[17:42:45.063]  - include = ‘immediateCondition’
[17:42:45.063]  - exclude = 
[17:42:45.063]  - resignal = FALSE
[17:42:45.063]  - Number of conditions: 1
[17:42:45.063] signalConditions() ... done
[17:42:45.063] signalConditions() ...
[17:42:45.064]  - include = ‘immediateCondition’
[17:42:45.064]  - exclude = 
[17:42:45.064]  - resignal = FALSE
[17:42:45.064]  - Number of conditions: 1
[17:42:45.064] signalConditions() ... done
[17:42:45.064] Future state: ‘finished’
[17:42:45.064] signalConditions() ...
[17:42:45.064]  - include = ‘condition’
[17:42:45.065]  - exclude = ‘immediateCondition’
[17:42:45.065]  - resignal = TRUE
[17:42:45.065]  - Number of conditions: 1
[17:42:45.065]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:45.065] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:45"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.099] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.099] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.099] 
[17:42:45.100] Searching for globals ... DONE
[17:42:45.100] - globals: [0] <none>
[17:42:45.100] getGlobalsAndPackages() ... DONE
[17:42:45.100] run() for ‘Future’ ...
[17:42:45.100] - state: ‘created’
[17:42:45.100] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.104] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.105] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.105]   - Field: ‘label’
[17:42:45.105]   - Field: ‘local’
[17:42:45.105]   - Field: ‘owner’
[17:42:45.105]   - Field: ‘envir’
[17:42:45.105]   - Field: ‘workers’
[17:42:45.105]   - Field: ‘packages’
[17:42:45.105]   - Field: ‘gc’
[17:42:45.105]   - Field: ‘job’
[17:42:45.105]   - Field: ‘conditions’
[17:42:45.106]   - Field: ‘expr’
[17:42:45.106]   - Field: ‘uuid’
[17:42:45.106]   - Field: ‘seed’
[17:42:45.106]   - Field: ‘version’
[17:42:45.106]   - Field: ‘result’
[17:42:45.106]   - Field: ‘asynchronous’
[17:42:45.106]   - Field: ‘calls’
[17:42:45.106]   - Field: ‘globals’
[17:42:45.106]   - Field: ‘stdout’
[17:42:45.106]   - Field: ‘earlySignal’
[17:42:45.107]   - Field: ‘lazy’
[17:42:45.107]   - Field: ‘state’
[17:42:45.107] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.107] - Launch lazy future ...
[17:42:45.107] Packages needed by the future expression (n = 0): <none>
[17:42:45.107] Packages needed by future strategies (n = 0): <none>
[17:42:45.108] {
[17:42:45.108]     {
[17:42:45.108]         {
[17:42:45.108]             ...future.startTime <- base::Sys.time()
[17:42:45.108]             {
[17:42:45.108]                 {
[17:42:45.108]                   {
[17:42:45.108]                     {
[17:42:45.108]                       base::local({
[17:42:45.108]                         has_future <- base::requireNamespace("future", 
[17:42:45.108]                           quietly = TRUE)
[17:42:45.108]                         if (has_future) {
[17:42:45.108]                           ns <- base::getNamespace("future")
[17:42:45.108]                           version <- ns[[".package"]][["version"]]
[17:42:45.108]                           if (is.null(version)) 
[17:42:45.108]                             version <- utils::packageVersion("future")
[17:42:45.108]                         }
[17:42:45.108]                         else {
[17:42:45.108]                           version <- NULL
[17:42:45.108]                         }
[17:42:45.108]                         if (!has_future || version < "1.8.0") {
[17:42:45.108]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.108]                             "", base::R.version$version.string), 
[17:42:45.108]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.108]                               "release", "version")], collapse = " "), 
[17:42:45.108]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.108]                             info)
[17:42:45.108]                           info <- base::paste(info, collapse = "; ")
[17:42:45.108]                           if (!has_future) {
[17:42:45.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.108]                               info)
[17:42:45.108]                           }
[17:42:45.108]                           else {
[17:42:45.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.108]                               info, version)
[17:42:45.108]                           }
[17:42:45.108]                           base::stop(msg)
[17:42:45.108]                         }
[17:42:45.108]                       })
[17:42:45.108]                     }
[17:42:45.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.108]                     base::options(mc.cores = 1L)
[17:42:45.108]                   }
[17:42:45.108]                   options(future.plan = NULL)
[17:42:45.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.108]                 }
[17:42:45.108]                 ...future.workdir <- getwd()
[17:42:45.108]             }
[17:42:45.108]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.108]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.108]         }
[17:42:45.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.108]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.108]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.108]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.108]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.108]             base::names(...future.oldOptions))
[17:42:45.108]     }
[17:42:45.108]     if (FALSE) {
[17:42:45.108]     }
[17:42:45.108]     else {
[17:42:45.108]         if (TRUE) {
[17:42:45.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.108]                 open = "w")
[17:42:45.108]         }
[17:42:45.108]         else {
[17:42:45.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.108]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.108]         }
[17:42:45.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.108]             base::sink(type = "output", split = FALSE)
[17:42:45.108]             base::close(...future.stdout)
[17:42:45.108]         }, add = TRUE)
[17:42:45.108]     }
[17:42:45.108]     ...future.frame <- base::sys.nframe()
[17:42:45.108]     ...future.conditions <- base::list()
[17:42:45.108]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.108]     if (FALSE) {
[17:42:45.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.108]     }
[17:42:45.108]     ...future.result <- base::tryCatch({
[17:42:45.108]         base::withCallingHandlers({
[17:42:45.108]             ...future.value <- base::withVisible(base::local({
[17:42:45.108]                 withCallingHandlers({
[17:42:45.108]                   1
[17:42:45.108]                 }, immediateCondition = function(cond) {
[17:42:45.108]                   save_rds <- function (object, pathname, ...) 
[17:42:45.108]                   {
[17:42:45.108]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.108]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.108]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.108]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.108]                         fi_tmp[["mtime"]])
[17:42:45.108]                     }
[17:42:45.108]                     tryCatch({
[17:42:45.108]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.108]                     }, error = function(ex) {
[17:42:45.108]                       msg <- conditionMessage(ex)
[17:42:45.108]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.108]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.108]                         fi_tmp[["mtime"]], msg)
[17:42:45.108]                       ex$message <- msg
[17:42:45.108]                       stop(ex)
[17:42:45.108]                     })
[17:42:45.108]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.108]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.108]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.108]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.108]                       fi <- file.info(pathname)
[17:42:45.108]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.108]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.108]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.108]                         fi[["size"]], fi[["mtime"]])
[17:42:45.108]                       stop(msg)
[17:42:45.108]                     }
[17:42:45.108]                     invisible(pathname)
[17:42:45.108]                   }
[17:42:45.108]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.108]                     rootPath = tempdir()) 
[17:42:45.108]                   {
[17:42:45.108]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.108]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.108]                       tmpdir = path, fileext = ".rds")
[17:42:45.108]                     save_rds(obj, file)
[17:42:45.108]                   }
[17:42:45.108]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.108]                   {
[17:42:45.108]                     inherits <- base::inherits
[17:42:45.108]                     invokeRestart <- base::invokeRestart
[17:42:45.108]                     is.null <- base::is.null
[17:42:45.108]                     muffled <- FALSE
[17:42:45.108]                     if (inherits(cond, "message")) {
[17:42:45.108]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.108]                       if (muffled) 
[17:42:45.108]                         invokeRestart("muffleMessage")
[17:42:45.108]                     }
[17:42:45.108]                     else if (inherits(cond, "warning")) {
[17:42:45.108]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.108]                       if (muffled) 
[17:42:45.108]                         invokeRestart("muffleWarning")
[17:42:45.108]                     }
[17:42:45.108]                     else if (inherits(cond, "condition")) {
[17:42:45.108]                       if (!is.null(pattern)) {
[17:42:45.108]                         computeRestarts <- base::computeRestarts
[17:42:45.108]                         grepl <- base::grepl
[17:42:45.108]                         restarts <- computeRestarts(cond)
[17:42:45.108]                         for (restart in restarts) {
[17:42:45.108]                           name <- restart$name
[17:42:45.108]                           if (is.null(name)) 
[17:42:45.108]                             next
[17:42:45.108]                           if (!grepl(pattern, name)) 
[17:42:45.108]                             next
[17:42:45.108]                           invokeRestart(restart)
[17:42:45.108]                           muffled <- TRUE
[17:42:45.108]                           break
[17:42:45.108]                         }
[17:42:45.108]                       }
[17:42:45.108]                     }
[17:42:45.108]                     invisible(muffled)
[17:42:45.108]                   }
[17:42:45.108]                   muffleCondition(cond)
[17:42:45.108]                 })
[17:42:45.108]             }))
[17:42:45.108]             future::FutureResult(value = ...future.value$value, 
[17:42:45.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.108]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.108]                     ...future.globalenv.names))
[17:42:45.108]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.108]         }, condition = base::local({
[17:42:45.108]             c <- base::c
[17:42:45.108]             inherits <- base::inherits
[17:42:45.108]             invokeRestart <- base::invokeRestart
[17:42:45.108]             length <- base::length
[17:42:45.108]             list <- base::list
[17:42:45.108]             seq.int <- base::seq.int
[17:42:45.108]             signalCondition <- base::signalCondition
[17:42:45.108]             sys.calls <- base::sys.calls
[17:42:45.108]             `[[` <- base::`[[`
[17:42:45.108]             `+` <- base::`+`
[17:42:45.108]             `<<-` <- base::`<<-`
[17:42:45.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.108]                   3L)]
[17:42:45.108]             }
[17:42:45.108]             function(cond) {
[17:42:45.108]                 is_error <- inherits(cond, "error")
[17:42:45.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.108]                   NULL)
[17:42:45.108]                 if (is_error) {
[17:42:45.108]                   sessionInformation <- function() {
[17:42:45.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.108]                       search = base::search(), system = base::Sys.info())
[17:42:45.108]                   }
[17:42:45.108]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.108]                     cond$call), session = sessionInformation(), 
[17:42:45.108]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.108]                   signalCondition(cond)
[17:42:45.108]                 }
[17:42:45.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.108]                 "immediateCondition"))) {
[17:42:45.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.108]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.108]                   if (TRUE && !signal) {
[17:42:45.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.108]                     {
[17:42:45.108]                       inherits <- base::inherits
[17:42:45.108]                       invokeRestart <- base::invokeRestart
[17:42:45.108]                       is.null <- base::is.null
[17:42:45.108]                       muffled <- FALSE
[17:42:45.108]                       if (inherits(cond, "message")) {
[17:42:45.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.108]                         if (muffled) 
[17:42:45.108]                           invokeRestart("muffleMessage")
[17:42:45.108]                       }
[17:42:45.108]                       else if (inherits(cond, "warning")) {
[17:42:45.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.108]                         if (muffled) 
[17:42:45.108]                           invokeRestart("muffleWarning")
[17:42:45.108]                       }
[17:42:45.108]                       else if (inherits(cond, "condition")) {
[17:42:45.108]                         if (!is.null(pattern)) {
[17:42:45.108]                           computeRestarts <- base::computeRestarts
[17:42:45.108]                           grepl <- base::grepl
[17:42:45.108]                           restarts <- computeRestarts(cond)
[17:42:45.108]                           for (restart in restarts) {
[17:42:45.108]                             name <- restart$name
[17:42:45.108]                             if (is.null(name)) 
[17:42:45.108]                               next
[17:42:45.108]                             if (!grepl(pattern, name)) 
[17:42:45.108]                               next
[17:42:45.108]                             invokeRestart(restart)
[17:42:45.108]                             muffled <- TRUE
[17:42:45.108]                             break
[17:42:45.108]                           }
[17:42:45.108]                         }
[17:42:45.108]                       }
[17:42:45.108]                       invisible(muffled)
[17:42:45.108]                     }
[17:42:45.108]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.108]                   }
[17:42:45.108]                 }
[17:42:45.108]                 else {
[17:42:45.108]                   if (TRUE) {
[17:42:45.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.108]                     {
[17:42:45.108]                       inherits <- base::inherits
[17:42:45.108]                       invokeRestart <- base::invokeRestart
[17:42:45.108]                       is.null <- base::is.null
[17:42:45.108]                       muffled <- FALSE
[17:42:45.108]                       if (inherits(cond, "message")) {
[17:42:45.108]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.108]                         if (muffled) 
[17:42:45.108]                           invokeRestart("muffleMessage")
[17:42:45.108]                       }
[17:42:45.108]                       else if (inherits(cond, "warning")) {
[17:42:45.108]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.108]                         if (muffled) 
[17:42:45.108]                           invokeRestart("muffleWarning")
[17:42:45.108]                       }
[17:42:45.108]                       else if (inherits(cond, "condition")) {
[17:42:45.108]                         if (!is.null(pattern)) {
[17:42:45.108]                           computeRestarts <- base::computeRestarts
[17:42:45.108]                           grepl <- base::grepl
[17:42:45.108]                           restarts <- computeRestarts(cond)
[17:42:45.108]                           for (restart in restarts) {
[17:42:45.108]                             name <- restart$name
[17:42:45.108]                             if (is.null(name)) 
[17:42:45.108]                               next
[17:42:45.108]                             if (!grepl(pattern, name)) 
[17:42:45.108]                               next
[17:42:45.108]                             invokeRestart(restart)
[17:42:45.108]                             muffled <- TRUE
[17:42:45.108]                             break
[17:42:45.108]                           }
[17:42:45.108]                         }
[17:42:45.108]                       }
[17:42:45.108]                       invisible(muffled)
[17:42:45.108]                     }
[17:42:45.108]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.108]                   }
[17:42:45.108]                 }
[17:42:45.108]             }
[17:42:45.108]         }))
[17:42:45.108]     }, error = function(ex) {
[17:42:45.108]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.108]                 ...future.rng), started = ...future.startTime, 
[17:42:45.108]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.108]             version = "1.8"), class = "FutureResult")
[17:42:45.108]     }, finally = {
[17:42:45.108]         if (!identical(...future.workdir, getwd())) 
[17:42:45.108]             setwd(...future.workdir)
[17:42:45.108]         {
[17:42:45.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.108]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.108]             }
[17:42:45.108]             base::options(...future.oldOptions)
[17:42:45.108]             if (.Platform$OS.type == "windows") {
[17:42:45.108]                 old_names <- names(...future.oldEnvVars)
[17:42:45.108]                 envs <- base::Sys.getenv()
[17:42:45.108]                 names <- names(envs)
[17:42:45.108]                 common <- intersect(names, old_names)
[17:42:45.108]                 added <- setdiff(names, old_names)
[17:42:45.108]                 removed <- setdiff(old_names, names)
[17:42:45.108]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.108]                   envs[common]]
[17:42:45.108]                 NAMES <- toupper(changed)
[17:42:45.108]                 args <- list()
[17:42:45.108]                 for (kk in seq_along(NAMES)) {
[17:42:45.108]                   name <- changed[[kk]]
[17:42:45.108]                   NAME <- NAMES[[kk]]
[17:42:45.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.108]                     next
[17:42:45.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.108]                 }
[17:42:45.108]                 NAMES <- toupper(added)
[17:42:45.108]                 for (kk in seq_along(NAMES)) {
[17:42:45.108]                   name <- added[[kk]]
[17:42:45.108]                   NAME <- NAMES[[kk]]
[17:42:45.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.108]                     next
[17:42:45.108]                   args[[name]] <- ""
[17:42:45.108]                 }
[17:42:45.108]                 NAMES <- toupper(removed)
[17:42:45.108]                 for (kk in seq_along(NAMES)) {
[17:42:45.108]                   name <- removed[[kk]]
[17:42:45.108]                   NAME <- NAMES[[kk]]
[17:42:45.108]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.108]                     next
[17:42:45.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.108]                 }
[17:42:45.108]                 if (length(args) > 0) 
[17:42:45.108]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.108]             }
[17:42:45.108]             else {
[17:42:45.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.108]             }
[17:42:45.108]             {
[17:42:45.108]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.108]                   0L) {
[17:42:45.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.108]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.108]                   base::options(opts)
[17:42:45.108]                 }
[17:42:45.108]                 {
[17:42:45.108]                   {
[17:42:45.108]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.108]                     NULL
[17:42:45.108]                   }
[17:42:45.108]                   options(future.plan = NULL)
[17:42:45.108]                   if (is.na(NA_character_)) 
[17:42:45.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.108]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.108]                     envir = parent.frame()) 
[17:42:45.108]                   {
[17:42:45.108]                     default_workers <- missing(workers)
[17:42:45.108]                     if (is.function(workers)) 
[17:42:45.108]                       workers <- workers()
[17:42:45.108]                     workers <- structure(as.integer(workers), 
[17:42:45.108]                       class = class(workers))
[17:42:45.108]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.108]                       1L)
[17:42:45.108]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.108]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.108]                       if (default_workers) 
[17:42:45.108]                         supportsMulticore(warn = TRUE)
[17:42:45.108]                       return(sequential(..., envir = envir))
[17:42:45.108]                     }
[17:42:45.108]                     oopts <- options(mc.cores = workers)
[17:42:45.108]                     on.exit(options(oopts))
[17:42:45.108]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.108]                       envir = envir)
[17:42:45.108]                     if (!future$lazy) 
[17:42:45.108]                       future <- run(future)
[17:42:45.108]                     invisible(future)
[17:42:45.108]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.108]                 }
[17:42:45.108]             }
[17:42:45.108]         }
[17:42:45.108]     })
[17:42:45.108]     if (TRUE) {
[17:42:45.108]         base::sink(type = "output", split = FALSE)
[17:42:45.108]         if (TRUE) {
[17:42:45.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.108]         }
[17:42:45.108]         else {
[17:42:45.108]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.108]         }
[17:42:45.108]         base::close(...future.stdout)
[17:42:45.108]         ...future.stdout <- NULL
[17:42:45.108]     }
[17:42:45.108]     ...future.result$conditions <- ...future.conditions
[17:42:45.108]     ...future.result$finished <- base::Sys.time()
[17:42:45.108]     ...future.result
[17:42:45.108] }
[17:42:45.110] requestCore(): workers = 2
[17:42:45.112] MulticoreFuture started
[17:42:45.113] - Launch lazy future ... done
[17:42:45.113] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.113] plan(): Setting new future strategy stack:
[17:42:45.114] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.114] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.114] List of future strategies:
[17:42:45.114] 1. sequential:
[17:42:45.114]    - args: function (..., envir = parent.frame())
[17:42:45.114]    - tweaked: FALSE
[17:42:45.114]    - call: NULL
[17:42:45.115] plan(): nbrOfWorkers() = 1
[17:42:45.116] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.116] Searching for globals ... DONE
[17:42:45.117] Resolving globals: TRUE
[17:42:45.117] plan(): Setting new future strategy stack:
[17:42:45.117] Resolving any globals that are futures ...
[17:42:45.117] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.117] Resolving any globals that are futures ... DONE
[17:42:45.117] List of future strategies:
[17:42:45.117] 1. multicore:
[17:42:45.117]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.117]    - tweaked: FALSE
[17:42:45.117]    - call: plan(strategy)
[17:42:45.118] Resolving futures part of globals (recursively) ...
[17:42:45.118] resolve() on list ...
[17:42:45.118]  recursive: 99
[17:42:45.119]  length: 1
[17:42:45.119]  elements: ‘a’
[17:42:45.121] plan(): nbrOfWorkers() = 2
[17:42:45.122] Future #1
[17:42:45.123] A MulticoreFuture was resolved
[17:42:45.123]  length: 0 (resolved future 1)
[17:42:45.123] resolve() on list ... DONE
[17:42:45.124] - globals: [1] ‘a’
[17:42:45.124] Resolving futures part of globals (recursively) ... DONE
[17:42:45.125] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:42:45.126] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:42:45.126] - globals: [1] ‘a’
[17:42:45.126] - packages: [1] ‘future’
[17:42:45.126] getGlobalsAndPackages() ... DONE
[17:42:45.126] run() for ‘Future’ ...
[17:42:45.126] - state: ‘created’
[17:42:45.127] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.131] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.131] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.131]   - Field: ‘label’
[17:42:45.131]   - Field: ‘local’
[17:42:45.131]   - Field: ‘owner’
[17:42:45.132]   - Field: ‘envir’
[17:42:45.132]   - Field: ‘workers’
[17:42:45.132]   - Field: ‘packages’
[17:42:45.134]   - Field: ‘gc’
[17:42:45.134]   - Field: ‘job’
[17:42:45.135]   - Field: ‘conditions’
[17:42:45.135]   - Field: ‘expr’
[17:42:45.135]   - Field: ‘uuid’
[17:42:45.135]   - Field: ‘seed’
[17:42:45.135]   - Field: ‘version’
[17:42:45.136]   - Field: ‘result’
[17:42:45.136]   - Field: ‘asynchronous’
[17:42:45.136]   - Field: ‘calls’
[17:42:45.136]   - Field: ‘globals’
[17:42:45.136]   - Field: ‘stdout’
[17:42:45.136]   - Field: ‘earlySignal’
[17:42:45.137]   - Field: ‘lazy’
[17:42:45.137]   - Field: ‘state’
[17:42:45.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.137] - Launch lazy future ...
[17:42:45.137] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.138] Packages needed by future strategies (n = 0): <none>
[17:42:45.138] {
[17:42:45.138]     {
[17:42:45.138]         {
[17:42:45.138]             ...future.startTime <- base::Sys.time()
[17:42:45.138]             {
[17:42:45.138]                 {
[17:42:45.138]                   {
[17:42:45.138]                     {
[17:42:45.138]                       {
[17:42:45.138]                         base::local({
[17:42:45.138]                           has_future <- base::requireNamespace("future", 
[17:42:45.138]                             quietly = TRUE)
[17:42:45.138]                           if (has_future) {
[17:42:45.138]                             ns <- base::getNamespace("future")
[17:42:45.138]                             version <- ns[[".package"]][["version"]]
[17:42:45.138]                             if (is.null(version)) 
[17:42:45.138]                               version <- utils::packageVersion("future")
[17:42:45.138]                           }
[17:42:45.138]                           else {
[17:42:45.138]                             version <- NULL
[17:42:45.138]                           }
[17:42:45.138]                           if (!has_future || version < "1.8.0") {
[17:42:45.138]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.138]                               "", base::R.version$version.string), 
[17:42:45.138]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.138]                                 base::R.version$platform, 8 * 
[17:42:45.138]                                   base::.Machine$sizeof.pointer), 
[17:42:45.138]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.138]                                 "release", "version")], collapse = " "), 
[17:42:45.138]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.138]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.138]                               info)
[17:42:45.138]                             info <- base::paste(info, collapse = "; ")
[17:42:45.138]                             if (!has_future) {
[17:42:45.138]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.138]                                 info)
[17:42:45.138]                             }
[17:42:45.138]                             else {
[17:42:45.138]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.138]                                 info, version)
[17:42:45.138]                             }
[17:42:45.138]                             base::stop(msg)
[17:42:45.138]                           }
[17:42:45.138]                         })
[17:42:45.138]                       }
[17:42:45.138]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.138]                       base::options(mc.cores = 1L)
[17:42:45.138]                     }
[17:42:45.138]                     base::local({
[17:42:45.138]                       for (pkg in "future") {
[17:42:45.138]                         base::loadNamespace(pkg)
[17:42:45.138]                         base::library(pkg, character.only = TRUE)
[17:42:45.138]                       }
[17:42:45.138]                     })
[17:42:45.138]                   }
[17:42:45.138]                   options(future.plan = NULL)
[17:42:45.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.138]                 }
[17:42:45.138]                 ...future.workdir <- getwd()
[17:42:45.138]             }
[17:42:45.138]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.138]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.138]         }
[17:42:45.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.138]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.138]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.138]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.138]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.138]             base::names(...future.oldOptions))
[17:42:45.138]     }
[17:42:45.138]     if (FALSE) {
[17:42:45.138]     }
[17:42:45.138]     else {
[17:42:45.138]         if (TRUE) {
[17:42:45.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.138]                 open = "w")
[17:42:45.138]         }
[17:42:45.138]         else {
[17:42:45.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.138]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.138]         }
[17:42:45.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.138]             base::sink(type = "output", split = FALSE)
[17:42:45.138]             base::close(...future.stdout)
[17:42:45.138]         }, add = TRUE)
[17:42:45.138]     }
[17:42:45.138]     ...future.frame <- base::sys.nframe()
[17:42:45.138]     ...future.conditions <- base::list()
[17:42:45.138]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.138]     if (FALSE) {
[17:42:45.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.138]     }
[17:42:45.138]     ...future.result <- base::tryCatch({
[17:42:45.138]         base::withCallingHandlers({
[17:42:45.138]             ...future.value <- base::withVisible(base::local({
[17:42:45.138]                 withCallingHandlers({
[17:42:45.138]                   value(a) + 1
[17:42:45.138]                 }, immediateCondition = function(cond) {
[17:42:45.138]                   save_rds <- function (object, pathname, ...) 
[17:42:45.138]                   {
[17:42:45.138]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.138]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.138]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.138]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.138]                         fi_tmp[["mtime"]])
[17:42:45.138]                     }
[17:42:45.138]                     tryCatch({
[17:42:45.138]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.138]                     }, error = function(ex) {
[17:42:45.138]                       msg <- conditionMessage(ex)
[17:42:45.138]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.138]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.138]                         fi_tmp[["mtime"]], msg)
[17:42:45.138]                       ex$message <- msg
[17:42:45.138]                       stop(ex)
[17:42:45.138]                     })
[17:42:45.138]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.138]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.138]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.138]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.138]                       fi <- file.info(pathname)
[17:42:45.138]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.138]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.138]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.138]                         fi[["size"]], fi[["mtime"]])
[17:42:45.138]                       stop(msg)
[17:42:45.138]                     }
[17:42:45.138]                     invisible(pathname)
[17:42:45.138]                   }
[17:42:45.138]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.138]                     rootPath = tempdir()) 
[17:42:45.138]                   {
[17:42:45.138]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.138]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.138]                       tmpdir = path, fileext = ".rds")
[17:42:45.138]                     save_rds(obj, file)
[17:42:45.138]                   }
[17:42:45.138]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.138]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.138]                   {
[17:42:45.138]                     inherits <- base::inherits
[17:42:45.138]                     invokeRestart <- base::invokeRestart
[17:42:45.138]                     is.null <- base::is.null
[17:42:45.138]                     muffled <- FALSE
[17:42:45.138]                     if (inherits(cond, "message")) {
[17:42:45.138]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.138]                       if (muffled) 
[17:42:45.138]                         invokeRestart("muffleMessage")
[17:42:45.138]                     }
[17:42:45.138]                     else if (inherits(cond, "warning")) {
[17:42:45.138]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.138]                       if (muffled) 
[17:42:45.138]                         invokeRestart("muffleWarning")
[17:42:45.138]                     }
[17:42:45.138]                     else if (inherits(cond, "condition")) {
[17:42:45.138]                       if (!is.null(pattern)) {
[17:42:45.138]                         computeRestarts <- base::computeRestarts
[17:42:45.138]                         grepl <- base::grepl
[17:42:45.138]                         restarts <- computeRestarts(cond)
[17:42:45.138]                         for (restart in restarts) {
[17:42:45.138]                           name <- restart$name
[17:42:45.138]                           if (is.null(name)) 
[17:42:45.138]                             next
[17:42:45.138]                           if (!grepl(pattern, name)) 
[17:42:45.138]                             next
[17:42:45.138]                           invokeRestart(restart)
[17:42:45.138]                           muffled <- TRUE
[17:42:45.138]                           break
[17:42:45.138]                         }
[17:42:45.138]                       }
[17:42:45.138]                     }
[17:42:45.138]                     invisible(muffled)
[17:42:45.138]                   }
[17:42:45.138]                   muffleCondition(cond)
[17:42:45.138]                 })
[17:42:45.138]             }))
[17:42:45.138]             future::FutureResult(value = ...future.value$value, 
[17:42:45.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.138]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.138]                     ...future.globalenv.names))
[17:42:45.138]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.138]         }, condition = base::local({
[17:42:45.138]             c <- base::c
[17:42:45.138]             inherits <- base::inherits
[17:42:45.138]             invokeRestart <- base::invokeRestart
[17:42:45.138]             length <- base::length
[17:42:45.138]             list <- base::list
[17:42:45.138]             seq.int <- base::seq.int
[17:42:45.138]             signalCondition <- base::signalCondition
[17:42:45.138]             sys.calls <- base::sys.calls
[17:42:45.138]             `[[` <- base::`[[`
[17:42:45.138]             `+` <- base::`+`
[17:42:45.138]             `<<-` <- base::`<<-`
[17:42:45.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.138]                   3L)]
[17:42:45.138]             }
[17:42:45.138]             function(cond) {
[17:42:45.138]                 is_error <- inherits(cond, "error")
[17:42:45.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.138]                   NULL)
[17:42:45.138]                 if (is_error) {
[17:42:45.138]                   sessionInformation <- function() {
[17:42:45.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.138]                       search = base::search(), system = base::Sys.info())
[17:42:45.138]                   }
[17:42:45.138]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.138]                     cond$call), session = sessionInformation(), 
[17:42:45.138]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.138]                   signalCondition(cond)
[17:42:45.138]                 }
[17:42:45.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.138]                 "immediateCondition"))) {
[17:42:45.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.138]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.138]                   if (TRUE && !signal) {
[17:42:45.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.138]                     {
[17:42:45.138]                       inherits <- base::inherits
[17:42:45.138]                       invokeRestart <- base::invokeRestart
[17:42:45.138]                       is.null <- base::is.null
[17:42:45.138]                       muffled <- FALSE
[17:42:45.138]                       if (inherits(cond, "message")) {
[17:42:45.138]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.138]                         if (muffled) 
[17:42:45.138]                           invokeRestart("muffleMessage")
[17:42:45.138]                       }
[17:42:45.138]                       else if (inherits(cond, "warning")) {
[17:42:45.138]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.138]                         if (muffled) 
[17:42:45.138]                           invokeRestart("muffleWarning")
[17:42:45.138]                       }
[17:42:45.138]                       else if (inherits(cond, "condition")) {
[17:42:45.138]                         if (!is.null(pattern)) {
[17:42:45.138]                           computeRestarts <- base::computeRestarts
[17:42:45.138]                           grepl <- base::grepl
[17:42:45.138]                           restarts <- computeRestarts(cond)
[17:42:45.138]                           for (restart in restarts) {
[17:42:45.138]                             name <- restart$name
[17:42:45.138]                             if (is.null(name)) 
[17:42:45.138]                               next
[17:42:45.138]                             if (!grepl(pattern, name)) 
[17:42:45.138]                               next
[17:42:45.138]                             invokeRestart(restart)
[17:42:45.138]                             muffled <- TRUE
[17:42:45.138]                             break
[17:42:45.138]                           }
[17:42:45.138]                         }
[17:42:45.138]                       }
[17:42:45.138]                       invisible(muffled)
[17:42:45.138]                     }
[17:42:45.138]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.138]                   }
[17:42:45.138]                 }
[17:42:45.138]                 else {
[17:42:45.138]                   if (TRUE) {
[17:42:45.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.138]                     {
[17:42:45.138]                       inherits <- base::inherits
[17:42:45.138]                       invokeRestart <- base::invokeRestart
[17:42:45.138]                       is.null <- base::is.null
[17:42:45.138]                       muffled <- FALSE
[17:42:45.138]                       if (inherits(cond, "message")) {
[17:42:45.138]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.138]                         if (muffled) 
[17:42:45.138]                           invokeRestart("muffleMessage")
[17:42:45.138]                       }
[17:42:45.138]                       else if (inherits(cond, "warning")) {
[17:42:45.138]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.138]                         if (muffled) 
[17:42:45.138]                           invokeRestart("muffleWarning")
[17:42:45.138]                       }
[17:42:45.138]                       else if (inherits(cond, "condition")) {
[17:42:45.138]                         if (!is.null(pattern)) {
[17:42:45.138]                           computeRestarts <- base::computeRestarts
[17:42:45.138]                           grepl <- base::grepl
[17:42:45.138]                           restarts <- computeRestarts(cond)
[17:42:45.138]                           for (restart in restarts) {
[17:42:45.138]                             name <- restart$name
[17:42:45.138]                             if (is.null(name)) 
[17:42:45.138]                               next
[17:42:45.138]                             if (!grepl(pattern, name)) 
[17:42:45.138]                               next
[17:42:45.138]                             invokeRestart(restart)
[17:42:45.138]                             muffled <- TRUE
[17:42:45.138]                             break
[17:42:45.138]                           }
[17:42:45.138]                         }
[17:42:45.138]                       }
[17:42:45.138]                       invisible(muffled)
[17:42:45.138]                     }
[17:42:45.138]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.138]                   }
[17:42:45.138]                 }
[17:42:45.138]             }
[17:42:45.138]         }))
[17:42:45.138]     }, error = function(ex) {
[17:42:45.138]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.138]                 ...future.rng), started = ...future.startTime, 
[17:42:45.138]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.138]             version = "1.8"), class = "FutureResult")
[17:42:45.138]     }, finally = {
[17:42:45.138]         if (!identical(...future.workdir, getwd())) 
[17:42:45.138]             setwd(...future.workdir)
[17:42:45.138]         {
[17:42:45.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.138]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.138]             }
[17:42:45.138]             base::options(...future.oldOptions)
[17:42:45.138]             if (.Platform$OS.type == "windows") {
[17:42:45.138]                 old_names <- names(...future.oldEnvVars)
[17:42:45.138]                 envs <- base::Sys.getenv()
[17:42:45.138]                 names <- names(envs)
[17:42:45.138]                 common <- intersect(names, old_names)
[17:42:45.138]                 added <- setdiff(names, old_names)
[17:42:45.138]                 removed <- setdiff(old_names, names)
[17:42:45.138]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.138]                   envs[common]]
[17:42:45.138]                 NAMES <- toupper(changed)
[17:42:45.138]                 args <- list()
[17:42:45.138]                 for (kk in seq_along(NAMES)) {
[17:42:45.138]                   name <- changed[[kk]]
[17:42:45.138]                   NAME <- NAMES[[kk]]
[17:42:45.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.138]                     next
[17:42:45.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.138]                 }
[17:42:45.138]                 NAMES <- toupper(added)
[17:42:45.138]                 for (kk in seq_along(NAMES)) {
[17:42:45.138]                   name <- added[[kk]]
[17:42:45.138]                   NAME <- NAMES[[kk]]
[17:42:45.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.138]                     next
[17:42:45.138]                   args[[name]] <- ""
[17:42:45.138]                 }
[17:42:45.138]                 NAMES <- toupper(removed)
[17:42:45.138]                 for (kk in seq_along(NAMES)) {
[17:42:45.138]                   name <- removed[[kk]]
[17:42:45.138]                   NAME <- NAMES[[kk]]
[17:42:45.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.138]                     next
[17:42:45.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.138]                 }
[17:42:45.138]                 if (length(args) > 0) 
[17:42:45.138]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.138]             }
[17:42:45.138]             else {
[17:42:45.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.138]             }
[17:42:45.138]             {
[17:42:45.138]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.138]                   0L) {
[17:42:45.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.138]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.138]                   base::options(opts)
[17:42:45.138]                 }
[17:42:45.138]                 {
[17:42:45.138]                   {
[17:42:45.138]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.138]                     NULL
[17:42:45.138]                   }
[17:42:45.138]                   options(future.plan = NULL)
[17:42:45.138]                   if (is.na(NA_character_)) 
[17:42:45.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.138]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.138]                     envir = parent.frame()) 
[17:42:45.138]                   {
[17:42:45.138]                     default_workers <- missing(workers)
[17:42:45.138]                     if (is.function(workers)) 
[17:42:45.138]                       workers <- workers()
[17:42:45.138]                     workers <- structure(as.integer(workers), 
[17:42:45.138]                       class = class(workers))
[17:42:45.138]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.138]                       1L)
[17:42:45.138]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.138]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.138]                       if (default_workers) 
[17:42:45.138]                         supportsMulticore(warn = TRUE)
[17:42:45.138]                       return(sequential(..., envir = envir))
[17:42:45.138]                     }
[17:42:45.138]                     oopts <- options(mc.cores = workers)
[17:42:45.138]                     on.exit(options(oopts))
[17:42:45.138]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.138]                       envir = envir)
[17:42:45.138]                     if (!future$lazy) 
[17:42:45.138]                       future <- run(future)
[17:42:45.138]                     invisible(future)
[17:42:45.138]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.138]                 }
[17:42:45.138]             }
[17:42:45.138]         }
[17:42:45.138]     })
[17:42:45.138]     if (TRUE) {
[17:42:45.138]         base::sink(type = "output", split = FALSE)
[17:42:45.138]         if (TRUE) {
[17:42:45.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.138]         }
[17:42:45.138]         else {
[17:42:45.138]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.138]         }
[17:42:45.138]         base::close(...future.stdout)
[17:42:45.138]         ...future.stdout <- NULL
[17:42:45.138]     }
[17:42:45.138]     ...future.result$conditions <- ...future.conditions
[17:42:45.138]     ...future.result$finished <- base::Sys.time()
[17:42:45.138]     ...future.result
[17:42:45.138] }
[17:42:45.141] assign_globals() ...
[17:42:45.141] List of 1
[17:42:45.141]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561818e47270> 
[17:42:45.141]  - attr(*, "where")=List of 1
[17:42:45.141]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.141]  - attr(*, "resolved")= logi TRUE
[17:42:45.141]  - attr(*, "total_size")= num 10816
[17:42:45.141]  - attr(*, "already-done")= logi TRUE
[17:42:45.145] - copied ‘a’ to environment
[17:42:45.145] assign_globals() ... done
[17:42:45.145] requestCore(): workers = 2
[17:42:45.148] MulticoreFuture started
[17:42:45.148] - Launch lazy future ... done
[17:42:45.148] run() for ‘MulticoreFuture’ ... done
[17:42:45.149] plan(): Setting new future strategy stack:
[17:42:45.149] List of future strategies:
[17:42:45.149] 1. sequential:
[17:42:45.149]    - args: function (..., envir = parent.frame())
[17:42:45.149]    - tweaked: FALSE
[17:42:45.149]    - call: NULL
[17:42:45.150] plan(): nbrOfWorkers() = 1
[17:42:45.153] plan(): Setting new future strategy stack:
[17:42:45.153] List of future strategies:
[17:42:45.153] 1. multicore:
[17:42:45.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.153]    - tweaked: FALSE
[17:42:45.153]    - call: plan(strategy)
[17:42:45.158] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.160] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.160] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.161] 
[17:42:45.162] Searching for globals ... DONE
[17:42:45.162] - globals: [0] <none>
[17:42:45.162] getGlobalsAndPackages() ... DONE
[17:42:45.162] run() for ‘Future’ ...
[17:42:45.162] - state: ‘created’
[17:42:45.163] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.167] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.167]   - Field: ‘label’
[17:42:45.167]   - Field: ‘local’
[17:42:45.167]   - Field: ‘owner’
[17:42:45.167]   - Field: ‘envir’
[17:42:45.167]   - Field: ‘workers’
[17:42:45.168]   - Field: ‘packages’
[17:42:45.168]   - Field: ‘gc’
[17:42:45.168]   - Field: ‘job’
[17:42:45.168]   - Field: ‘conditions’
[17:42:45.168]   - Field: ‘expr’
[17:42:45.168]   - Field: ‘uuid’
[17:42:45.168]   - Field: ‘seed’
[17:42:45.168]   - Field: ‘version’
[17:42:45.169]   - Field: ‘result’
[17:42:45.169]   - Field: ‘asynchronous’
[17:42:45.169]   - Field: ‘calls’
[17:42:45.169]   - Field: ‘globals’
[17:42:45.169]   - Field: ‘stdout’
[17:42:45.169]   - Field: ‘earlySignal’
[17:42:45.169]   - Field: ‘lazy’
[17:42:45.169]   - Field: ‘state’
[17:42:45.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.170] - Launch lazy future ...
[17:42:45.170] Packages needed by the future expression (n = 0): <none>
[17:42:45.170] Packages needed by future strategies (n = 0): <none>
[17:42:45.171] {
[17:42:45.171]     {
[17:42:45.171]         {
[17:42:45.171]             ...future.startTime <- base::Sys.time()
[17:42:45.171]             {
[17:42:45.171]                 {
[17:42:45.171]                   {
[17:42:45.171]                     {
[17:42:45.171]                       base::local({
[17:42:45.171]                         has_future <- base::requireNamespace("future", 
[17:42:45.171]                           quietly = TRUE)
[17:42:45.171]                         if (has_future) {
[17:42:45.171]                           ns <- base::getNamespace("future")
[17:42:45.171]                           version <- ns[[".package"]][["version"]]
[17:42:45.171]                           if (is.null(version)) 
[17:42:45.171]                             version <- utils::packageVersion("future")
[17:42:45.171]                         }
[17:42:45.171]                         else {
[17:42:45.171]                           version <- NULL
[17:42:45.171]                         }
[17:42:45.171]                         if (!has_future || version < "1.8.0") {
[17:42:45.171]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.171]                             "", base::R.version$version.string), 
[17:42:45.171]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.171]                               "release", "version")], collapse = " "), 
[17:42:45.171]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.171]                             info)
[17:42:45.171]                           info <- base::paste(info, collapse = "; ")
[17:42:45.171]                           if (!has_future) {
[17:42:45.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.171]                               info)
[17:42:45.171]                           }
[17:42:45.171]                           else {
[17:42:45.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.171]                               info, version)
[17:42:45.171]                           }
[17:42:45.171]                           base::stop(msg)
[17:42:45.171]                         }
[17:42:45.171]                       })
[17:42:45.171]                     }
[17:42:45.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.171]                     base::options(mc.cores = 1L)
[17:42:45.171]                   }
[17:42:45.171]                   options(future.plan = NULL)
[17:42:45.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.171]                 }
[17:42:45.171]                 ...future.workdir <- getwd()
[17:42:45.171]             }
[17:42:45.171]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.171]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.171]         }
[17:42:45.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.171]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.171]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.171]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.171]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.171]             base::names(...future.oldOptions))
[17:42:45.171]     }
[17:42:45.171]     if (FALSE) {
[17:42:45.171]     }
[17:42:45.171]     else {
[17:42:45.171]         if (TRUE) {
[17:42:45.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.171]                 open = "w")
[17:42:45.171]         }
[17:42:45.171]         else {
[17:42:45.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.171]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.171]         }
[17:42:45.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.171]             base::sink(type = "output", split = FALSE)
[17:42:45.171]             base::close(...future.stdout)
[17:42:45.171]         }, add = TRUE)
[17:42:45.171]     }
[17:42:45.171]     ...future.frame <- base::sys.nframe()
[17:42:45.171]     ...future.conditions <- base::list()
[17:42:45.171]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.171]     if (FALSE) {
[17:42:45.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.171]     }
[17:42:45.171]     ...future.result <- base::tryCatch({
[17:42:45.171]         base::withCallingHandlers({
[17:42:45.171]             ...future.value <- base::withVisible(base::local({
[17:42:45.171]                 withCallingHandlers({
[17:42:45.171]                   1
[17:42:45.171]                 }, immediateCondition = function(cond) {
[17:42:45.171]                   save_rds <- function (object, pathname, ...) 
[17:42:45.171]                   {
[17:42:45.171]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.171]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.171]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.171]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.171]                         fi_tmp[["mtime"]])
[17:42:45.171]                     }
[17:42:45.171]                     tryCatch({
[17:42:45.171]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.171]                     }, error = function(ex) {
[17:42:45.171]                       msg <- conditionMessage(ex)
[17:42:45.171]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.171]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.171]                         fi_tmp[["mtime"]], msg)
[17:42:45.171]                       ex$message <- msg
[17:42:45.171]                       stop(ex)
[17:42:45.171]                     })
[17:42:45.171]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.171]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.171]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.171]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.171]                       fi <- file.info(pathname)
[17:42:45.171]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.171]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.171]                         fi[["size"]], fi[["mtime"]])
[17:42:45.171]                       stop(msg)
[17:42:45.171]                     }
[17:42:45.171]                     invisible(pathname)
[17:42:45.171]                   }
[17:42:45.171]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.171]                     rootPath = tempdir()) 
[17:42:45.171]                   {
[17:42:45.171]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.171]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.171]                       tmpdir = path, fileext = ".rds")
[17:42:45.171]                     save_rds(obj, file)
[17:42:45.171]                   }
[17:42:45.171]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.171]                   {
[17:42:45.171]                     inherits <- base::inherits
[17:42:45.171]                     invokeRestart <- base::invokeRestart
[17:42:45.171]                     is.null <- base::is.null
[17:42:45.171]                     muffled <- FALSE
[17:42:45.171]                     if (inherits(cond, "message")) {
[17:42:45.171]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.171]                       if (muffled) 
[17:42:45.171]                         invokeRestart("muffleMessage")
[17:42:45.171]                     }
[17:42:45.171]                     else if (inherits(cond, "warning")) {
[17:42:45.171]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.171]                       if (muffled) 
[17:42:45.171]                         invokeRestart("muffleWarning")
[17:42:45.171]                     }
[17:42:45.171]                     else if (inherits(cond, "condition")) {
[17:42:45.171]                       if (!is.null(pattern)) {
[17:42:45.171]                         computeRestarts <- base::computeRestarts
[17:42:45.171]                         grepl <- base::grepl
[17:42:45.171]                         restarts <- computeRestarts(cond)
[17:42:45.171]                         for (restart in restarts) {
[17:42:45.171]                           name <- restart$name
[17:42:45.171]                           if (is.null(name)) 
[17:42:45.171]                             next
[17:42:45.171]                           if (!grepl(pattern, name)) 
[17:42:45.171]                             next
[17:42:45.171]                           invokeRestart(restart)
[17:42:45.171]                           muffled <- TRUE
[17:42:45.171]                           break
[17:42:45.171]                         }
[17:42:45.171]                       }
[17:42:45.171]                     }
[17:42:45.171]                     invisible(muffled)
[17:42:45.171]                   }
[17:42:45.171]                   muffleCondition(cond)
[17:42:45.171]                 })
[17:42:45.171]             }))
[17:42:45.171]             future::FutureResult(value = ...future.value$value, 
[17:42:45.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.171]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.171]                     ...future.globalenv.names))
[17:42:45.171]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.171]         }, condition = base::local({
[17:42:45.171]             c <- base::c
[17:42:45.171]             inherits <- base::inherits
[17:42:45.171]             invokeRestart <- base::invokeRestart
[17:42:45.171]             length <- base::length
[17:42:45.171]             list <- base::list
[17:42:45.171]             seq.int <- base::seq.int
[17:42:45.171]             signalCondition <- base::signalCondition
[17:42:45.171]             sys.calls <- base::sys.calls
[17:42:45.171]             `[[` <- base::`[[`
[17:42:45.171]             `+` <- base::`+`
[17:42:45.171]             `<<-` <- base::`<<-`
[17:42:45.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.171]                   3L)]
[17:42:45.171]             }
[17:42:45.171]             function(cond) {
[17:42:45.171]                 is_error <- inherits(cond, "error")
[17:42:45.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.171]                   NULL)
[17:42:45.171]                 if (is_error) {
[17:42:45.171]                   sessionInformation <- function() {
[17:42:45.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.171]                       search = base::search(), system = base::Sys.info())
[17:42:45.171]                   }
[17:42:45.171]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.171]                     cond$call), session = sessionInformation(), 
[17:42:45.171]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.171]                   signalCondition(cond)
[17:42:45.171]                 }
[17:42:45.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.171]                 "immediateCondition"))) {
[17:42:45.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.171]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.171]                   if (TRUE && !signal) {
[17:42:45.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.171]                     {
[17:42:45.171]                       inherits <- base::inherits
[17:42:45.171]                       invokeRestart <- base::invokeRestart
[17:42:45.171]                       is.null <- base::is.null
[17:42:45.171]                       muffled <- FALSE
[17:42:45.171]                       if (inherits(cond, "message")) {
[17:42:45.171]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.171]                         if (muffled) 
[17:42:45.171]                           invokeRestart("muffleMessage")
[17:42:45.171]                       }
[17:42:45.171]                       else if (inherits(cond, "warning")) {
[17:42:45.171]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.171]                         if (muffled) 
[17:42:45.171]                           invokeRestart("muffleWarning")
[17:42:45.171]                       }
[17:42:45.171]                       else if (inherits(cond, "condition")) {
[17:42:45.171]                         if (!is.null(pattern)) {
[17:42:45.171]                           computeRestarts <- base::computeRestarts
[17:42:45.171]                           grepl <- base::grepl
[17:42:45.171]                           restarts <- computeRestarts(cond)
[17:42:45.171]                           for (restart in restarts) {
[17:42:45.171]                             name <- restart$name
[17:42:45.171]                             if (is.null(name)) 
[17:42:45.171]                               next
[17:42:45.171]                             if (!grepl(pattern, name)) 
[17:42:45.171]                               next
[17:42:45.171]                             invokeRestart(restart)
[17:42:45.171]                             muffled <- TRUE
[17:42:45.171]                             break
[17:42:45.171]                           }
[17:42:45.171]                         }
[17:42:45.171]                       }
[17:42:45.171]                       invisible(muffled)
[17:42:45.171]                     }
[17:42:45.171]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.171]                   }
[17:42:45.171]                 }
[17:42:45.171]                 else {
[17:42:45.171]                   if (TRUE) {
[17:42:45.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.171]                     {
[17:42:45.171]                       inherits <- base::inherits
[17:42:45.171]                       invokeRestart <- base::invokeRestart
[17:42:45.171]                       is.null <- base::is.null
[17:42:45.171]                       muffled <- FALSE
[17:42:45.171]                       if (inherits(cond, "message")) {
[17:42:45.171]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.171]                         if (muffled) 
[17:42:45.171]                           invokeRestart("muffleMessage")
[17:42:45.171]                       }
[17:42:45.171]                       else if (inherits(cond, "warning")) {
[17:42:45.171]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.171]                         if (muffled) 
[17:42:45.171]                           invokeRestart("muffleWarning")
[17:42:45.171]                       }
[17:42:45.171]                       else if (inherits(cond, "condition")) {
[17:42:45.171]                         if (!is.null(pattern)) {
[17:42:45.171]                           computeRestarts <- base::computeRestarts
[17:42:45.171]                           grepl <- base::grepl
[17:42:45.171]                           restarts <- computeRestarts(cond)
[17:42:45.171]                           for (restart in restarts) {
[17:42:45.171]                             name <- restart$name
[17:42:45.171]                             if (is.null(name)) 
[17:42:45.171]                               next
[17:42:45.171]                             if (!grepl(pattern, name)) 
[17:42:45.171]                               next
[17:42:45.171]                             invokeRestart(restart)
[17:42:45.171]                             muffled <- TRUE
[17:42:45.171]                             break
[17:42:45.171]                           }
[17:42:45.171]                         }
[17:42:45.171]                       }
[17:42:45.171]                       invisible(muffled)
[17:42:45.171]                     }
[17:42:45.171]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.171]                   }
[17:42:45.171]                 }
[17:42:45.171]             }
[17:42:45.171]         }))
[17:42:45.171]     }, error = function(ex) {
[17:42:45.171]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.171]                 ...future.rng), started = ...future.startTime, 
[17:42:45.171]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.171]             version = "1.8"), class = "FutureResult")
[17:42:45.171]     }, finally = {
[17:42:45.171]         if (!identical(...future.workdir, getwd())) 
[17:42:45.171]             setwd(...future.workdir)
[17:42:45.171]         {
[17:42:45.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.171]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.171]             }
[17:42:45.171]             base::options(...future.oldOptions)
[17:42:45.171]             if (.Platform$OS.type == "windows") {
[17:42:45.171]                 old_names <- names(...future.oldEnvVars)
[17:42:45.171]                 envs <- base::Sys.getenv()
[17:42:45.171]                 names <- names(envs)
[17:42:45.171]                 common <- intersect(names, old_names)
[17:42:45.171]                 added <- setdiff(names, old_names)
[17:42:45.171]                 removed <- setdiff(old_names, names)
[17:42:45.171]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.171]                   envs[common]]
[17:42:45.171]                 NAMES <- toupper(changed)
[17:42:45.171]                 args <- list()
[17:42:45.171]                 for (kk in seq_along(NAMES)) {
[17:42:45.171]                   name <- changed[[kk]]
[17:42:45.171]                   NAME <- NAMES[[kk]]
[17:42:45.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.171]                     next
[17:42:45.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.171]                 }
[17:42:45.171]                 NAMES <- toupper(added)
[17:42:45.171]                 for (kk in seq_along(NAMES)) {
[17:42:45.171]                   name <- added[[kk]]
[17:42:45.171]                   NAME <- NAMES[[kk]]
[17:42:45.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.171]                     next
[17:42:45.171]                   args[[name]] <- ""
[17:42:45.171]                 }
[17:42:45.171]                 NAMES <- toupper(removed)
[17:42:45.171]                 for (kk in seq_along(NAMES)) {
[17:42:45.171]                   name <- removed[[kk]]
[17:42:45.171]                   NAME <- NAMES[[kk]]
[17:42:45.171]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.171]                     next
[17:42:45.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.171]                 }
[17:42:45.171]                 if (length(args) > 0) 
[17:42:45.171]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.171]             }
[17:42:45.171]             else {
[17:42:45.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.171]             }
[17:42:45.171]             {
[17:42:45.171]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.171]                   0L) {
[17:42:45.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.171]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.171]                   base::options(opts)
[17:42:45.171]                 }
[17:42:45.171]                 {
[17:42:45.171]                   {
[17:42:45.171]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.171]                     NULL
[17:42:45.171]                   }
[17:42:45.171]                   options(future.plan = NULL)
[17:42:45.171]                   if (is.na(NA_character_)) 
[17:42:45.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.171]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.171]                     envir = parent.frame()) 
[17:42:45.171]                   {
[17:42:45.171]                     default_workers <- missing(workers)
[17:42:45.171]                     if (is.function(workers)) 
[17:42:45.171]                       workers <- workers()
[17:42:45.171]                     workers <- structure(as.integer(workers), 
[17:42:45.171]                       class = class(workers))
[17:42:45.171]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.171]                       1L)
[17:42:45.171]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.171]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.171]                       if (default_workers) 
[17:42:45.171]                         supportsMulticore(warn = TRUE)
[17:42:45.171]                       return(sequential(..., envir = envir))
[17:42:45.171]                     }
[17:42:45.171]                     oopts <- options(mc.cores = workers)
[17:42:45.171]                     on.exit(options(oopts))
[17:42:45.171]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.171]                       envir = envir)
[17:42:45.171]                     if (!future$lazy) 
[17:42:45.171]                       future <- run(future)
[17:42:45.171]                     invisible(future)
[17:42:45.171]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.171]                 }
[17:42:45.171]             }
[17:42:45.171]         }
[17:42:45.171]     })
[17:42:45.171]     if (TRUE) {
[17:42:45.171]         base::sink(type = "output", split = FALSE)
[17:42:45.171]         if (TRUE) {
[17:42:45.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.171]         }
[17:42:45.171]         else {
[17:42:45.171]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.171]         }
[17:42:45.171]         base::close(...future.stdout)
[17:42:45.171]         ...future.stdout <- NULL
[17:42:45.171]     }
[17:42:45.171]     ...future.result$conditions <- ...future.conditions
[17:42:45.171]     ...future.result$finished <- base::Sys.time()
[17:42:45.171]     ...future.result
[17:42:45.171] }
[17:42:45.174] requestCore(): workers = 2
[17:42:45.176] MulticoreFuture started
[17:42:45.177] - Launch lazy future ... done
[17:42:45.177] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.177] plan(): Setting new future strategy stack:
[17:42:45.177] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.178] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.177] List of future strategies:
[17:42:45.177] 1. sequential:
[17:42:45.177]    - args: function (..., envir = parent.frame())
[17:42:45.177]    - tweaked: FALSE
[17:42:45.177]    - call: NULL
[17:42:45.178] plan(): nbrOfWorkers() = 1
[17:42:45.180] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.180] Searching for globals ... DONE
[17:42:45.180] Resolving globals: TRUE
[17:42:45.180] Resolving any globals that are futures ...
[17:42:45.180] plan(): Setting new future strategy stack:
[17:42:45.180] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.180] Resolving any globals that are futures ... DONE
[17:42:45.180] List of future strategies:
[17:42:45.180] 1. multicore:
[17:42:45.180]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.180]    - tweaked: FALSE
[17:42:45.180]    - call: plan(strategy)
[17:42:45.181] Resolving futures part of globals (recursively) ...
[17:42:45.182] resolve() on list ...
[17:42:45.182]  recursive: 99
[17:42:45.182]  length: 1
[17:42:45.182]  elements: ‘a’
[17:42:45.185] plan(): nbrOfWorkers() = 2
[17:42:45.185] Future #1
[17:42:45.187] A MulticoreFuture was resolved
[17:42:45.187]  length: 0 (resolved future 1)
[17:42:45.187] resolve() on list ... DONE
[17:42:45.187] - globals: [1] ‘a’
[17:42:45.187] Resolving futures part of globals (recursively) ... DONE
[17:42:45.192] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[17:42:45.193] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[17:42:45.193] - globals: [1] ‘a’
[17:42:45.193] - packages: [1] ‘future’
[17:42:45.193] getGlobalsAndPackages() ... DONE
[17:42:45.194] run() for ‘Future’ ...
[17:42:45.194] - state: ‘created’
[17:42:45.194] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.198] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.199] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.199]   - Field: ‘label’
[17:42:45.199]   - Field: ‘local’
[17:42:45.199]   - Field: ‘owner’
[17:42:45.199]   - Field: ‘envir’
[17:42:45.199]   - Field: ‘workers’
[17:42:45.199]   - Field: ‘packages’
[17:42:45.200]   - Field: ‘gc’
[17:42:45.200]   - Field: ‘job’
[17:42:45.200]   - Field: ‘conditions’
[17:42:45.200]   - Field: ‘expr’
[17:42:45.200]   - Field: ‘uuid’
[17:42:45.200]   - Field: ‘seed’
[17:42:45.200]   - Field: ‘version’
[17:42:45.200]   - Field: ‘result’
[17:42:45.200]   - Field: ‘asynchronous’
[17:42:45.201]   - Field: ‘calls’
[17:42:45.201]   - Field: ‘globals’
[17:42:45.201]   - Field: ‘stdout’
[17:42:45.201]   - Field: ‘earlySignal’
[17:42:45.201]   - Field: ‘lazy’
[17:42:45.201]   - Field: ‘state’
[17:42:45.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.201] - Launch lazy future ...
[17:42:45.202] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.202] Packages needed by future strategies (n = 0): <none>
[17:42:45.203] {
[17:42:45.203]     {
[17:42:45.203]         {
[17:42:45.203]             ...future.startTime <- base::Sys.time()
[17:42:45.203]             {
[17:42:45.203]                 {
[17:42:45.203]                   {
[17:42:45.203]                     {
[17:42:45.203]                       {
[17:42:45.203]                         base::local({
[17:42:45.203]                           has_future <- base::requireNamespace("future", 
[17:42:45.203]                             quietly = TRUE)
[17:42:45.203]                           if (has_future) {
[17:42:45.203]                             ns <- base::getNamespace("future")
[17:42:45.203]                             version <- ns[[".package"]][["version"]]
[17:42:45.203]                             if (is.null(version)) 
[17:42:45.203]                               version <- utils::packageVersion("future")
[17:42:45.203]                           }
[17:42:45.203]                           else {
[17:42:45.203]                             version <- NULL
[17:42:45.203]                           }
[17:42:45.203]                           if (!has_future || version < "1.8.0") {
[17:42:45.203]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.203]                               "", base::R.version$version.string), 
[17:42:45.203]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.203]                                 base::R.version$platform, 8 * 
[17:42:45.203]                                   base::.Machine$sizeof.pointer), 
[17:42:45.203]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.203]                                 "release", "version")], collapse = " "), 
[17:42:45.203]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.203]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.203]                               info)
[17:42:45.203]                             info <- base::paste(info, collapse = "; ")
[17:42:45.203]                             if (!has_future) {
[17:42:45.203]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.203]                                 info)
[17:42:45.203]                             }
[17:42:45.203]                             else {
[17:42:45.203]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.203]                                 info, version)
[17:42:45.203]                             }
[17:42:45.203]                             base::stop(msg)
[17:42:45.203]                           }
[17:42:45.203]                         })
[17:42:45.203]                       }
[17:42:45.203]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.203]                       base::options(mc.cores = 1L)
[17:42:45.203]                     }
[17:42:45.203]                     base::local({
[17:42:45.203]                       for (pkg in "future") {
[17:42:45.203]                         base::loadNamespace(pkg)
[17:42:45.203]                         base::library(pkg, character.only = TRUE)
[17:42:45.203]                       }
[17:42:45.203]                     })
[17:42:45.203]                   }
[17:42:45.203]                   options(future.plan = NULL)
[17:42:45.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.203]                 }
[17:42:45.203]                 ...future.workdir <- getwd()
[17:42:45.203]             }
[17:42:45.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.203]         }
[17:42:45.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.203]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.203]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.203]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.203]             base::names(...future.oldOptions))
[17:42:45.203]     }
[17:42:45.203]     if (FALSE) {
[17:42:45.203]     }
[17:42:45.203]     else {
[17:42:45.203]         if (TRUE) {
[17:42:45.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.203]                 open = "w")
[17:42:45.203]         }
[17:42:45.203]         else {
[17:42:45.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.203]         }
[17:42:45.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.203]             base::sink(type = "output", split = FALSE)
[17:42:45.203]             base::close(...future.stdout)
[17:42:45.203]         }, add = TRUE)
[17:42:45.203]     }
[17:42:45.203]     ...future.frame <- base::sys.nframe()
[17:42:45.203]     ...future.conditions <- base::list()
[17:42:45.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.203]     if (FALSE) {
[17:42:45.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.203]     }
[17:42:45.203]     ...future.result <- base::tryCatch({
[17:42:45.203]         base::withCallingHandlers({
[17:42:45.203]             ...future.value <- base::withVisible(base::local({
[17:42:45.203]                 withCallingHandlers({
[17:42:45.203]                   value(a) + 1
[17:42:45.203]                 }, immediateCondition = function(cond) {
[17:42:45.203]                   save_rds <- function (object, pathname, ...) 
[17:42:45.203]                   {
[17:42:45.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.203]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.203]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.203]                         fi_tmp[["mtime"]])
[17:42:45.203]                     }
[17:42:45.203]                     tryCatch({
[17:42:45.203]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.203]                     }, error = function(ex) {
[17:42:45.203]                       msg <- conditionMessage(ex)
[17:42:45.203]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.203]                         fi_tmp[["mtime"]], msg)
[17:42:45.203]                       ex$message <- msg
[17:42:45.203]                       stop(ex)
[17:42:45.203]                     })
[17:42:45.203]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.203]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.203]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.203]                       fi <- file.info(pathname)
[17:42:45.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.203]                         fi[["size"]], fi[["mtime"]])
[17:42:45.203]                       stop(msg)
[17:42:45.203]                     }
[17:42:45.203]                     invisible(pathname)
[17:42:45.203]                   }
[17:42:45.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.203]                     rootPath = tempdir()) 
[17:42:45.203]                   {
[17:42:45.203]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.203]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.203]                       tmpdir = path, fileext = ".rds")
[17:42:45.203]                     save_rds(obj, file)
[17:42:45.203]                   }
[17:42:45.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.203]                   {
[17:42:45.203]                     inherits <- base::inherits
[17:42:45.203]                     invokeRestart <- base::invokeRestart
[17:42:45.203]                     is.null <- base::is.null
[17:42:45.203]                     muffled <- FALSE
[17:42:45.203]                     if (inherits(cond, "message")) {
[17:42:45.203]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.203]                       if (muffled) 
[17:42:45.203]                         invokeRestart("muffleMessage")
[17:42:45.203]                     }
[17:42:45.203]                     else if (inherits(cond, "warning")) {
[17:42:45.203]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.203]                       if (muffled) 
[17:42:45.203]                         invokeRestart("muffleWarning")
[17:42:45.203]                     }
[17:42:45.203]                     else if (inherits(cond, "condition")) {
[17:42:45.203]                       if (!is.null(pattern)) {
[17:42:45.203]                         computeRestarts <- base::computeRestarts
[17:42:45.203]                         grepl <- base::grepl
[17:42:45.203]                         restarts <- computeRestarts(cond)
[17:42:45.203]                         for (restart in restarts) {
[17:42:45.203]                           name <- restart$name
[17:42:45.203]                           if (is.null(name)) 
[17:42:45.203]                             next
[17:42:45.203]                           if (!grepl(pattern, name)) 
[17:42:45.203]                             next
[17:42:45.203]                           invokeRestart(restart)
[17:42:45.203]                           muffled <- TRUE
[17:42:45.203]                           break
[17:42:45.203]                         }
[17:42:45.203]                       }
[17:42:45.203]                     }
[17:42:45.203]                     invisible(muffled)
[17:42:45.203]                   }
[17:42:45.203]                   muffleCondition(cond)
[17:42:45.203]                 })
[17:42:45.203]             }))
[17:42:45.203]             future::FutureResult(value = ...future.value$value, 
[17:42:45.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.203]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.203]                     ...future.globalenv.names))
[17:42:45.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.203]         }, condition = base::local({
[17:42:45.203]             c <- base::c
[17:42:45.203]             inherits <- base::inherits
[17:42:45.203]             invokeRestart <- base::invokeRestart
[17:42:45.203]             length <- base::length
[17:42:45.203]             list <- base::list
[17:42:45.203]             seq.int <- base::seq.int
[17:42:45.203]             signalCondition <- base::signalCondition
[17:42:45.203]             sys.calls <- base::sys.calls
[17:42:45.203]             `[[` <- base::`[[`
[17:42:45.203]             `+` <- base::`+`
[17:42:45.203]             `<<-` <- base::`<<-`
[17:42:45.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.203]                   3L)]
[17:42:45.203]             }
[17:42:45.203]             function(cond) {
[17:42:45.203]                 is_error <- inherits(cond, "error")
[17:42:45.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.203]                   NULL)
[17:42:45.203]                 if (is_error) {
[17:42:45.203]                   sessionInformation <- function() {
[17:42:45.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.203]                       search = base::search(), system = base::Sys.info())
[17:42:45.203]                   }
[17:42:45.203]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.203]                     cond$call), session = sessionInformation(), 
[17:42:45.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.203]                   signalCondition(cond)
[17:42:45.203]                 }
[17:42:45.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.203]                 "immediateCondition"))) {
[17:42:45.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.203]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.203]                   if (TRUE && !signal) {
[17:42:45.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.203]                     {
[17:42:45.203]                       inherits <- base::inherits
[17:42:45.203]                       invokeRestart <- base::invokeRestart
[17:42:45.203]                       is.null <- base::is.null
[17:42:45.203]                       muffled <- FALSE
[17:42:45.203]                       if (inherits(cond, "message")) {
[17:42:45.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.203]                         if (muffled) 
[17:42:45.203]                           invokeRestart("muffleMessage")
[17:42:45.203]                       }
[17:42:45.203]                       else if (inherits(cond, "warning")) {
[17:42:45.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.203]                         if (muffled) 
[17:42:45.203]                           invokeRestart("muffleWarning")
[17:42:45.203]                       }
[17:42:45.203]                       else if (inherits(cond, "condition")) {
[17:42:45.203]                         if (!is.null(pattern)) {
[17:42:45.203]                           computeRestarts <- base::computeRestarts
[17:42:45.203]                           grepl <- base::grepl
[17:42:45.203]                           restarts <- computeRestarts(cond)
[17:42:45.203]                           for (restart in restarts) {
[17:42:45.203]                             name <- restart$name
[17:42:45.203]                             if (is.null(name)) 
[17:42:45.203]                               next
[17:42:45.203]                             if (!grepl(pattern, name)) 
[17:42:45.203]                               next
[17:42:45.203]                             invokeRestart(restart)
[17:42:45.203]                             muffled <- TRUE
[17:42:45.203]                             break
[17:42:45.203]                           }
[17:42:45.203]                         }
[17:42:45.203]                       }
[17:42:45.203]                       invisible(muffled)
[17:42:45.203]                     }
[17:42:45.203]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.203]                   }
[17:42:45.203]                 }
[17:42:45.203]                 else {
[17:42:45.203]                   if (TRUE) {
[17:42:45.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.203]                     {
[17:42:45.203]                       inherits <- base::inherits
[17:42:45.203]                       invokeRestart <- base::invokeRestart
[17:42:45.203]                       is.null <- base::is.null
[17:42:45.203]                       muffled <- FALSE
[17:42:45.203]                       if (inherits(cond, "message")) {
[17:42:45.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.203]                         if (muffled) 
[17:42:45.203]                           invokeRestart("muffleMessage")
[17:42:45.203]                       }
[17:42:45.203]                       else if (inherits(cond, "warning")) {
[17:42:45.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.203]                         if (muffled) 
[17:42:45.203]                           invokeRestart("muffleWarning")
[17:42:45.203]                       }
[17:42:45.203]                       else if (inherits(cond, "condition")) {
[17:42:45.203]                         if (!is.null(pattern)) {
[17:42:45.203]                           computeRestarts <- base::computeRestarts
[17:42:45.203]                           grepl <- base::grepl
[17:42:45.203]                           restarts <- computeRestarts(cond)
[17:42:45.203]                           for (restart in restarts) {
[17:42:45.203]                             name <- restart$name
[17:42:45.203]                             if (is.null(name)) 
[17:42:45.203]                               next
[17:42:45.203]                             if (!grepl(pattern, name)) 
[17:42:45.203]                               next
[17:42:45.203]                             invokeRestart(restart)
[17:42:45.203]                             muffled <- TRUE
[17:42:45.203]                             break
[17:42:45.203]                           }
[17:42:45.203]                         }
[17:42:45.203]                       }
[17:42:45.203]                       invisible(muffled)
[17:42:45.203]                     }
[17:42:45.203]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.203]                   }
[17:42:45.203]                 }
[17:42:45.203]             }
[17:42:45.203]         }))
[17:42:45.203]     }, error = function(ex) {
[17:42:45.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.203]                 ...future.rng), started = ...future.startTime, 
[17:42:45.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.203]             version = "1.8"), class = "FutureResult")
[17:42:45.203]     }, finally = {
[17:42:45.203]         if (!identical(...future.workdir, getwd())) 
[17:42:45.203]             setwd(...future.workdir)
[17:42:45.203]         {
[17:42:45.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.203]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.203]             }
[17:42:45.203]             base::options(...future.oldOptions)
[17:42:45.203]             if (.Platform$OS.type == "windows") {
[17:42:45.203]                 old_names <- names(...future.oldEnvVars)
[17:42:45.203]                 envs <- base::Sys.getenv()
[17:42:45.203]                 names <- names(envs)
[17:42:45.203]                 common <- intersect(names, old_names)
[17:42:45.203]                 added <- setdiff(names, old_names)
[17:42:45.203]                 removed <- setdiff(old_names, names)
[17:42:45.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.203]                   envs[common]]
[17:42:45.203]                 NAMES <- toupper(changed)
[17:42:45.203]                 args <- list()
[17:42:45.203]                 for (kk in seq_along(NAMES)) {
[17:42:45.203]                   name <- changed[[kk]]
[17:42:45.203]                   NAME <- NAMES[[kk]]
[17:42:45.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.203]                     next
[17:42:45.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.203]                 }
[17:42:45.203]                 NAMES <- toupper(added)
[17:42:45.203]                 for (kk in seq_along(NAMES)) {
[17:42:45.203]                   name <- added[[kk]]
[17:42:45.203]                   NAME <- NAMES[[kk]]
[17:42:45.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.203]                     next
[17:42:45.203]                   args[[name]] <- ""
[17:42:45.203]                 }
[17:42:45.203]                 NAMES <- toupper(removed)
[17:42:45.203]                 for (kk in seq_along(NAMES)) {
[17:42:45.203]                   name <- removed[[kk]]
[17:42:45.203]                   NAME <- NAMES[[kk]]
[17:42:45.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.203]                     next
[17:42:45.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.203]                 }
[17:42:45.203]                 if (length(args) > 0) 
[17:42:45.203]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.203]             }
[17:42:45.203]             else {
[17:42:45.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.203]             }
[17:42:45.203]             {
[17:42:45.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.203]                   0L) {
[17:42:45.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.203]                   base::options(opts)
[17:42:45.203]                 }
[17:42:45.203]                 {
[17:42:45.203]                   {
[17:42:45.203]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.203]                     NULL
[17:42:45.203]                   }
[17:42:45.203]                   options(future.plan = NULL)
[17:42:45.203]                   if (is.na(NA_character_)) 
[17:42:45.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.203]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.203]                     envir = parent.frame()) 
[17:42:45.203]                   {
[17:42:45.203]                     default_workers <- missing(workers)
[17:42:45.203]                     if (is.function(workers)) 
[17:42:45.203]                       workers <- workers()
[17:42:45.203]                     workers <- structure(as.integer(workers), 
[17:42:45.203]                       class = class(workers))
[17:42:45.203]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.203]                       1L)
[17:42:45.203]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.203]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.203]                       if (default_workers) 
[17:42:45.203]                         supportsMulticore(warn = TRUE)
[17:42:45.203]                       return(sequential(..., envir = envir))
[17:42:45.203]                     }
[17:42:45.203]                     oopts <- options(mc.cores = workers)
[17:42:45.203]                     on.exit(options(oopts))
[17:42:45.203]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.203]                       envir = envir)
[17:42:45.203]                     if (!future$lazy) 
[17:42:45.203]                       future <- run(future)
[17:42:45.203]                     invisible(future)
[17:42:45.203]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.203]                 }
[17:42:45.203]             }
[17:42:45.203]         }
[17:42:45.203]     })
[17:42:45.203]     if (TRUE) {
[17:42:45.203]         base::sink(type = "output", split = FALSE)
[17:42:45.203]         if (TRUE) {
[17:42:45.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.203]         }
[17:42:45.203]         else {
[17:42:45.203]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.203]         }
[17:42:45.203]         base::close(...future.stdout)
[17:42:45.203]         ...future.stdout <- NULL
[17:42:45.203]     }
[17:42:45.203]     ...future.result$conditions <- ...future.conditions
[17:42:45.203]     ...future.result$finished <- base::Sys.time()
[17:42:45.203]     ...future.result
[17:42:45.203] }
[17:42:45.205] assign_globals() ...
[17:42:45.205] List of 1
[17:42:45.205]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56181a557bf0> 
[17:42:45.205]  - attr(*, "where")=List of 1
[17:42:45.205]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.205]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.205]  - attr(*, "resolved")= logi TRUE
[17:42:45.205]  - attr(*, "total_size")= num 10816
[17:42:45.205]  - attr(*, "already-done")= logi TRUE
[17:42:45.208] - copied ‘a’ to environment
[17:42:45.209] assign_globals() ... done
[17:42:45.209] requestCore(): workers = 2
[17:42:45.211] MulticoreFuture started
[17:42:45.211] - Launch lazy future ... done
[17:42:45.211] run() for ‘MulticoreFuture’ ... done
[17:42:45.213] plan(): Setting new future strategy stack:
[17:42:45.213] List of future strategies:
[17:42:45.213] 1. sequential:
[17:42:45.213]    - args: function (..., envir = parent.frame())
[17:42:45.213]    - tweaked: FALSE
[17:42:45.213]    - call: NULL
[17:42:45.214] plan(): nbrOfWorkers() = 1
[17:42:45.216] plan(): Setting new future strategy stack:
[17:42:45.216] List of future strategies:
[17:42:45.216] 1. multicore:
[17:42:45.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.216]    - tweaked: FALSE
[17:42:45.216]    - call: plan(strategy)
[17:42:45.221] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.223] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.223] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.224] 
[17:42:45.224] Searching for globals ... DONE
[17:42:45.224] - globals: [0] <none>
[17:42:45.225] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.225] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.225] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.226] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.227] Searching for globals ... DONE
[17:42:45.227] Resolving globals: TRUE
[17:42:45.227] Resolving any globals that are futures ...
[17:42:45.227] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.227] Resolving any globals that are futures ... DONE
[17:42:45.228] Resolving futures part of globals (recursively) ...
[17:42:45.228] resolve() on list ...
[17:42:45.228]  recursive: 99
[17:42:45.228]  length: 1
[17:42:45.228]  elements: ‘a’
[17:42:45.228] run() for ‘Future’ ...
[17:42:45.228] - state: ‘created’
[17:42:45.229] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.233] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.233]   - Field: ‘label’
[17:42:45.233]   - Field: ‘local’
[17:42:45.233]   - Field: ‘owner’
[17:42:45.233]   - Field: ‘envir’
[17:42:45.234]   - Field: ‘workers’
[17:42:45.234]   - Field: ‘packages’
[17:42:45.234]   - Field: ‘gc’
[17:42:45.234]   - Field: ‘job’
[17:42:45.234]   - Field: ‘conditions’
[17:42:45.236]   - Field: ‘expr’
[17:42:45.237]   - Field: ‘uuid’
[17:42:45.237]   - Field: ‘seed’
[17:42:45.237]   - Field: ‘version’
[17:42:45.237]   - Field: ‘result’
[17:42:45.237]   - Field: ‘asynchronous’
[17:42:45.237]   - Field: ‘calls’
[17:42:45.238]   - Field: ‘globals’
[17:42:45.238]   - Field: ‘stdout’
[17:42:45.238]   - Field: ‘earlySignal’
[17:42:45.238]   - Field: ‘lazy’
[17:42:45.238]   - Field: ‘state’
[17:42:45.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.239] - Launch lazy future ...
[17:42:45.239] Packages needed by the future expression (n = 0): <none>
[17:42:45.239] Packages needed by future strategies (n = 0): <none>
[17:42:45.240] {
[17:42:45.240]     {
[17:42:45.240]         {
[17:42:45.240]             ...future.startTime <- base::Sys.time()
[17:42:45.240]             {
[17:42:45.240]                 {
[17:42:45.240]                   {
[17:42:45.240]                     {
[17:42:45.240]                       base::local({
[17:42:45.240]                         has_future <- base::requireNamespace("future", 
[17:42:45.240]                           quietly = TRUE)
[17:42:45.240]                         if (has_future) {
[17:42:45.240]                           ns <- base::getNamespace("future")
[17:42:45.240]                           version <- ns[[".package"]][["version"]]
[17:42:45.240]                           if (is.null(version)) 
[17:42:45.240]                             version <- utils::packageVersion("future")
[17:42:45.240]                         }
[17:42:45.240]                         else {
[17:42:45.240]                           version <- NULL
[17:42:45.240]                         }
[17:42:45.240]                         if (!has_future || version < "1.8.0") {
[17:42:45.240]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.240]                             "", base::R.version$version.string), 
[17:42:45.240]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.240]                               "release", "version")], collapse = " "), 
[17:42:45.240]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.240]                             info)
[17:42:45.240]                           info <- base::paste(info, collapse = "; ")
[17:42:45.240]                           if (!has_future) {
[17:42:45.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.240]                               info)
[17:42:45.240]                           }
[17:42:45.240]                           else {
[17:42:45.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.240]                               info, version)
[17:42:45.240]                           }
[17:42:45.240]                           base::stop(msg)
[17:42:45.240]                         }
[17:42:45.240]                       })
[17:42:45.240]                     }
[17:42:45.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.240]                     base::options(mc.cores = 1L)
[17:42:45.240]                   }
[17:42:45.240]                   options(future.plan = NULL)
[17:42:45.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.240]                 }
[17:42:45.240]                 ...future.workdir <- getwd()
[17:42:45.240]             }
[17:42:45.240]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.240]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.240]         }
[17:42:45.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.240]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.240]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.240]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.240]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.240]             base::names(...future.oldOptions))
[17:42:45.240]     }
[17:42:45.240]     if (FALSE) {
[17:42:45.240]     }
[17:42:45.240]     else {
[17:42:45.240]         if (TRUE) {
[17:42:45.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.240]                 open = "w")
[17:42:45.240]         }
[17:42:45.240]         else {
[17:42:45.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.240]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.240]         }
[17:42:45.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.240]             base::sink(type = "output", split = FALSE)
[17:42:45.240]             base::close(...future.stdout)
[17:42:45.240]         }, add = TRUE)
[17:42:45.240]     }
[17:42:45.240]     ...future.frame <- base::sys.nframe()
[17:42:45.240]     ...future.conditions <- base::list()
[17:42:45.240]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.240]     if (FALSE) {
[17:42:45.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.240]     }
[17:42:45.240]     ...future.result <- base::tryCatch({
[17:42:45.240]         base::withCallingHandlers({
[17:42:45.240]             ...future.value <- base::withVisible(base::local({
[17:42:45.240]                 withCallingHandlers({
[17:42:45.240]                   1
[17:42:45.240]                 }, immediateCondition = function(cond) {
[17:42:45.240]                   save_rds <- function (object, pathname, ...) 
[17:42:45.240]                   {
[17:42:45.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.240]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.240]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.240]                         fi_tmp[["mtime"]])
[17:42:45.240]                     }
[17:42:45.240]                     tryCatch({
[17:42:45.240]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.240]                     }, error = function(ex) {
[17:42:45.240]                       msg <- conditionMessage(ex)
[17:42:45.240]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.240]                         fi_tmp[["mtime"]], msg)
[17:42:45.240]                       ex$message <- msg
[17:42:45.240]                       stop(ex)
[17:42:45.240]                     })
[17:42:45.240]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.240]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.240]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.240]                       fi <- file.info(pathname)
[17:42:45.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.240]                         fi[["size"]], fi[["mtime"]])
[17:42:45.240]                       stop(msg)
[17:42:45.240]                     }
[17:42:45.240]                     invisible(pathname)
[17:42:45.240]                   }
[17:42:45.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.240]                     rootPath = tempdir()) 
[17:42:45.240]                   {
[17:42:45.240]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.240]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.240]                       tmpdir = path, fileext = ".rds")
[17:42:45.240]                     save_rds(obj, file)
[17:42:45.240]                   }
[17:42:45.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.240]                   {
[17:42:45.240]                     inherits <- base::inherits
[17:42:45.240]                     invokeRestart <- base::invokeRestart
[17:42:45.240]                     is.null <- base::is.null
[17:42:45.240]                     muffled <- FALSE
[17:42:45.240]                     if (inherits(cond, "message")) {
[17:42:45.240]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.240]                       if (muffled) 
[17:42:45.240]                         invokeRestart("muffleMessage")
[17:42:45.240]                     }
[17:42:45.240]                     else if (inherits(cond, "warning")) {
[17:42:45.240]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.240]                       if (muffled) 
[17:42:45.240]                         invokeRestart("muffleWarning")
[17:42:45.240]                     }
[17:42:45.240]                     else if (inherits(cond, "condition")) {
[17:42:45.240]                       if (!is.null(pattern)) {
[17:42:45.240]                         computeRestarts <- base::computeRestarts
[17:42:45.240]                         grepl <- base::grepl
[17:42:45.240]                         restarts <- computeRestarts(cond)
[17:42:45.240]                         for (restart in restarts) {
[17:42:45.240]                           name <- restart$name
[17:42:45.240]                           if (is.null(name)) 
[17:42:45.240]                             next
[17:42:45.240]                           if (!grepl(pattern, name)) 
[17:42:45.240]                             next
[17:42:45.240]                           invokeRestart(restart)
[17:42:45.240]                           muffled <- TRUE
[17:42:45.240]                           break
[17:42:45.240]                         }
[17:42:45.240]                       }
[17:42:45.240]                     }
[17:42:45.240]                     invisible(muffled)
[17:42:45.240]                   }
[17:42:45.240]                   muffleCondition(cond)
[17:42:45.240]                 })
[17:42:45.240]             }))
[17:42:45.240]             future::FutureResult(value = ...future.value$value, 
[17:42:45.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.240]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.240]                     ...future.globalenv.names))
[17:42:45.240]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.240]         }, condition = base::local({
[17:42:45.240]             c <- base::c
[17:42:45.240]             inherits <- base::inherits
[17:42:45.240]             invokeRestart <- base::invokeRestart
[17:42:45.240]             length <- base::length
[17:42:45.240]             list <- base::list
[17:42:45.240]             seq.int <- base::seq.int
[17:42:45.240]             signalCondition <- base::signalCondition
[17:42:45.240]             sys.calls <- base::sys.calls
[17:42:45.240]             `[[` <- base::`[[`
[17:42:45.240]             `+` <- base::`+`
[17:42:45.240]             `<<-` <- base::`<<-`
[17:42:45.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.240]                   3L)]
[17:42:45.240]             }
[17:42:45.240]             function(cond) {
[17:42:45.240]                 is_error <- inherits(cond, "error")
[17:42:45.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.240]                   NULL)
[17:42:45.240]                 if (is_error) {
[17:42:45.240]                   sessionInformation <- function() {
[17:42:45.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.240]                       search = base::search(), system = base::Sys.info())
[17:42:45.240]                   }
[17:42:45.240]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.240]                     cond$call), session = sessionInformation(), 
[17:42:45.240]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.240]                   signalCondition(cond)
[17:42:45.240]                 }
[17:42:45.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.240]                 "immediateCondition"))) {
[17:42:45.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.240]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.240]                   if (TRUE && !signal) {
[17:42:45.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.240]                     {
[17:42:45.240]                       inherits <- base::inherits
[17:42:45.240]                       invokeRestart <- base::invokeRestart
[17:42:45.240]                       is.null <- base::is.null
[17:42:45.240]                       muffled <- FALSE
[17:42:45.240]                       if (inherits(cond, "message")) {
[17:42:45.240]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.240]                         if (muffled) 
[17:42:45.240]                           invokeRestart("muffleMessage")
[17:42:45.240]                       }
[17:42:45.240]                       else if (inherits(cond, "warning")) {
[17:42:45.240]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.240]                         if (muffled) 
[17:42:45.240]                           invokeRestart("muffleWarning")
[17:42:45.240]                       }
[17:42:45.240]                       else if (inherits(cond, "condition")) {
[17:42:45.240]                         if (!is.null(pattern)) {
[17:42:45.240]                           computeRestarts <- base::computeRestarts
[17:42:45.240]                           grepl <- base::grepl
[17:42:45.240]                           restarts <- computeRestarts(cond)
[17:42:45.240]                           for (restart in restarts) {
[17:42:45.240]                             name <- restart$name
[17:42:45.240]                             if (is.null(name)) 
[17:42:45.240]                               next
[17:42:45.240]                             if (!grepl(pattern, name)) 
[17:42:45.240]                               next
[17:42:45.240]                             invokeRestart(restart)
[17:42:45.240]                             muffled <- TRUE
[17:42:45.240]                             break
[17:42:45.240]                           }
[17:42:45.240]                         }
[17:42:45.240]                       }
[17:42:45.240]                       invisible(muffled)
[17:42:45.240]                     }
[17:42:45.240]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.240]                   }
[17:42:45.240]                 }
[17:42:45.240]                 else {
[17:42:45.240]                   if (TRUE) {
[17:42:45.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.240]                     {
[17:42:45.240]                       inherits <- base::inherits
[17:42:45.240]                       invokeRestart <- base::invokeRestart
[17:42:45.240]                       is.null <- base::is.null
[17:42:45.240]                       muffled <- FALSE
[17:42:45.240]                       if (inherits(cond, "message")) {
[17:42:45.240]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.240]                         if (muffled) 
[17:42:45.240]                           invokeRestart("muffleMessage")
[17:42:45.240]                       }
[17:42:45.240]                       else if (inherits(cond, "warning")) {
[17:42:45.240]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.240]                         if (muffled) 
[17:42:45.240]                           invokeRestart("muffleWarning")
[17:42:45.240]                       }
[17:42:45.240]                       else if (inherits(cond, "condition")) {
[17:42:45.240]                         if (!is.null(pattern)) {
[17:42:45.240]                           computeRestarts <- base::computeRestarts
[17:42:45.240]                           grepl <- base::grepl
[17:42:45.240]                           restarts <- computeRestarts(cond)
[17:42:45.240]                           for (restart in restarts) {
[17:42:45.240]                             name <- restart$name
[17:42:45.240]                             if (is.null(name)) 
[17:42:45.240]                               next
[17:42:45.240]                             if (!grepl(pattern, name)) 
[17:42:45.240]                               next
[17:42:45.240]                             invokeRestart(restart)
[17:42:45.240]                             muffled <- TRUE
[17:42:45.240]                             break
[17:42:45.240]                           }
[17:42:45.240]                         }
[17:42:45.240]                       }
[17:42:45.240]                       invisible(muffled)
[17:42:45.240]                     }
[17:42:45.240]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.240]                   }
[17:42:45.240]                 }
[17:42:45.240]             }
[17:42:45.240]         }))
[17:42:45.240]     }, error = function(ex) {
[17:42:45.240]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.240]                 ...future.rng), started = ...future.startTime, 
[17:42:45.240]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.240]             version = "1.8"), class = "FutureResult")
[17:42:45.240]     }, finally = {
[17:42:45.240]         if (!identical(...future.workdir, getwd())) 
[17:42:45.240]             setwd(...future.workdir)
[17:42:45.240]         {
[17:42:45.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.240]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.240]             }
[17:42:45.240]             base::options(...future.oldOptions)
[17:42:45.240]             if (.Platform$OS.type == "windows") {
[17:42:45.240]                 old_names <- names(...future.oldEnvVars)
[17:42:45.240]                 envs <- base::Sys.getenv()
[17:42:45.240]                 names <- names(envs)
[17:42:45.240]                 common <- intersect(names, old_names)
[17:42:45.240]                 added <- setdiff(names, old_names)
[17:42:45.240]                 removed <- setdiff(old_names, names)
[17:42:45.240]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.240]                   envs[common]]
[17:42:45.240]                 NAMES <- toupper(changed)
[17:42:45.240]                 args <- list()
[17:42:45.240]                 for (kk in seq_along(NAMES)) {
[17:42:45.240]                   name <- changed[[kk]]
[17:42:45.240]                   NAME <- NAMES[[kk]]
[17:42:45.240]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.240]                     next
[17:42:45.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.240]                 }
[17:42:45.240]                 NAMES <- toupper(added)
[17:42:45.240]                 for (kk in seq_along(NAMES)) {
[17:42:45.240]                   name <- added[[kk]]
[17:42:45.240]                   NAME <- NAMES[[kk]]
[17:42:45.240]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.240]                     next
[17:42:45.240]                   args[[name]] <- ""
[17:42:45.240]                 }
[17:42:45.240]                 NAMES <- toupper(removed)
[17:42:45.240]                 for (kk in seq_along(NAMES)) {
[17:42:45.240]                   name <- removed[[kk]]
[17:42:45.240]                   NAME <- NAMES[[kk]]
[17:42:45.240]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.240]                     next
[17:42:45.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.240]                 }
[17:42:45.240]                 if (length(args) > 0) 
[17:42:45.240]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.240]             }
[17:42:45.240]             else {
[17:42:45.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.240]             }
[17:42:45.240]             {
[17:42:45.240]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.240]                   0L) {
[17:42:45.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.240]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.240]                   base::options(opts)
[17:42:45.240]                 }
[17:42:45.240]                 {
[17:42:45.240]                   {
[17:42:45.240]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.240]                     NULL
[17:42:45.240]                   }
[17:42:45.240]                   options(future.plan = NULL)
[17:42:45.240]                   if (is.na(NA_character_)) 
[17:42:45.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.240]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.240]                     envir = parent.frame()) 
[17:42:45.240]                   {
[17:42:45.240]                     default_workers <- missing(workers)
[17:42:45.240]                     if (is.function(workers)) 
[17:42:45.240]                       workers <- workers()
[17:42:45.240]                     workers <- structure(as.integer(workers), 
[17:42:45.240]                       class = class(workers))
[17:42:45.240]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.240]                       1L)
[17:42:45.240]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.240]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.240]                       if (default_workers) 
[17:42:45.240]                         supportsMulticore(warn = TRUE)
[17:42:45.240]                       return(sequential(..., envir = envir))
[17:42:45.240]                     }
[17:42:45.240]                     oopts <- options(mc.cores = workers)
[17:42:45.240]                     on.exit(options(oopts))
[17:42:45.240]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.240]                       envir = envir)
[17:42:45.240]                     if (!future$lazy) 
[17:42:45.240]                       future <- run(future)
[17:42:45.240]                     invisible(future)
[17:42:45.240]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.240]                 }
[17:42:45.240]             }
[17:42:45.240]         }
[17:42:45.240]     })
[17:42:45.240]     if (TRUE) {
[17:42:45.240]         base::sink(type = "output", split = FALSE)
[17:42:45.240]         if (TRUE) {
[17:42:45.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.240]         }
[17:42:45.240]         else {
[17:42:45.240]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.240]         }
[17:42:45.240]         base::close(...future.stdout)
[17:42:45.240]         ...future.stdout <- NULL
[17:42:45.240]     }
[17:42:45.240]     ...future.result$conditions <- ...future.conditions
[17:42:45.240]     ...future.result$finished <- base::Sys.time()
[17:42:45.240]     ...future.result
[17:42:45.240] }
[17:42:45.242] requestCore(): workers = 2
[17:42:45.245] MulticoreFuture started
[17:42:45.245] - Launch lazy future ... done
[17:42:45.246] run() for ‘MulticoreFuture’ ... done
[17:42:45.246] plan(): Setting new future strategy stack:
[17:42:45.246] List of future strategies:
[17:42:45.246] 1. sequential:
[17:42:45.246]    - args: function (..., envir = parent.frame())
[17:42:45.246]    - tweaked: FALSE
[17:42:45.246]    - call: NULL
[17:42:45.247] plan(): nbrOfWorkers() = 1
[17:42:45.250] plan(): Setting new future strategy stack:
[17:42:45.250] List of future strategies:
[17:42:45.250] 1. multicore:
[17:42:45.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.250]    - tweaked: FALSE
[17:42:45.250]    - call: plan(strategy)
[17:42:45.256] plan(): nbrOfWorkers() = 2
[17:42:45.256] Future #1
[17:42:45.258] A MulticoreFuture was resolved
[17:42:45.258]  length: 0 (resolved future 1)
[17:42:45.258] resolve() on list ... DONE
[17:42:45.258] - globals: [1] ‘a’
[17:42:45.258] Resolving futures part of globals (recursively) ... DONE
[17:42:45.260] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:42:45.260] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:42:45.260] - globals: [1] ‘a’
[17:42:45.261] - packages: [1] ‘future’
[17:42:45.261] getGlobalsAndPackages() ... DONE
[17:42:45.261] run() for ‘Future’ ...
[17:42:45.261] - state: ‘created’
[17:42:45.261] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.266]   - Field: ‘label’
[17:42:45.266]   - Field: ‘local’
[17:42:45.266]   - Field: ‘owner’
[17:42:45.266]   - Field: ‘envir’
[17:42:45.266]   - Field: ‘workers’
[17:42:45.266]   - Field: ‘packages’
[17:42:45.266]   - Field: ‘gc’
[17:42:45.267]   - Field: ‘job’
[17:42:45.267]   - Field: ‘conditions’
[17:42:45.267]   - Field: ‘expr’
[17:42:45.267]   - Field: ‘uuid’
[17:42:45.267]   - Field: ‘seed’
[17:42:45.267]   - Field: ‘version’
[17:42:45.267]   - Field: ‘result’
[17:42:45.267]   - Field: ‘asynchronous’
[17:42:45.268]   - Field: ‘calls’
[17:42:45.268]   - Field: ‘globals’
[17:42:45.268]   - Field: ‘stdout’
[17:42:45.268]   - Field: ‘earlySignal’
[17:42:45.268]   - Field: ‘lazy’
[17:42:45.268]   - Field: ‘state’
[17:42:45.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.268] - Launch lazy future ...
[17:42:45.269] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.269] Packages needed by future strategies (n = 0): <none>
[17:42:45.270] {
[17:42:45.270]     {
[17:42:45.270]         {
[17:42:45.270]             ...future.startTime <- base::Sys.time()
[17:42:45.270]             {
[17:42:45.270]                 {
[17:42:45.270]                   {
[17:42:45.270]                     {
[17:42:45.270]                       {
[17:42:45.270]                         base::local({
[17:42:45.270]                           has_future <- base::requireNamespace("future", 
[17:42:45.270]                             quietly = TRUE)
[17:42:45.270]                           if (has_future) {
[17:42:45.270]                             ns <- base::getNamespace("future")
[17:42:45.270]                             version <- ns[[".package"]][["version"]]
[17:42:45.270]                             if (is.null(version)) 
[17:42:45.270]                               version <- utils::packageVersion("future")
[17:42:45.270]                           }
[17:42:45.270]                           else {
[17:42:45.270]                             version <- NULL
[17:42:45.270]                           }
[17:42:45.270]                           if (!has_future || version < "1.8.0") {
[17:42:45.270]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.270]                               "", base::R.version$version.string), 
[17:42:45.270]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.270]                                 base::R.version$platform, 8 * 
[17:42:45.270]                                   base::.Machine$sizeof.pointer), 
[17:42:45.270]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.270]                                 "release", "version")], collapse = " "), 
[17:42:45.270]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.270]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.270]                               info)
[17:42:45.270]                             info <- base::paste(info, collapse = "; ")
[17:42:45.270]                             if (!has_future) {
[17:42:45.270]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.270]                                 info)
[17:42:45.270]                             }
[17:42:45.270]                             else {
[17:42:45.270]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.270]                                 info, version)
[17:42:45.270]                             }
[17:42:45.270]                             base::stop(msg)
[17:42:45.270]                           }
[17:42:45.270]                         })
[17:42:45.270]                       }
[17:42:45.270]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.270]                       base::options(mc.cores = 1L)
[17:42:45.270]                     }
[17:42:45.270]                     base::local({
[17:42:45.270]                       for (pkg in "future") {
[17:42:45.270]                         base::loadNamespace(pkg)
[17:42:45.270]                         base::library(pkg, character.only = TRUE)
[17:42:45.270]                       }
[17:42:45.270]                     })
[17:42:45.270]                   }
[17:42:45.270]                   options(future.plan = NULL)
[17:42:45.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.270]                 }
[17:42:45.270]                 ...future.workdir <- getwd()
[17:42:45.270]             }
[17:42:45.270]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.270]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.270]         }
[17:42:45.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.270]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.270]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.270]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.270]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.270]             base::names(...future.oldOptions))
[17:42:45.270]     }
[17:42:45.270]     if (FALSE) {
[17:42:45.270]     }
[17:42:45.270]     else {
[17:42:45.270]         if (TRUE) {
[17:42:45.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.270]                 open = "w")
[17:42:45.270]         }
[17:42:45.270]         else {
[17:42:45.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.270]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.270]         }
[17:42:45.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.270]             base::sink(type = "output", split = FALSE)
[17:42:45.270]             base::close(...future.stdout)
[17:42:45.270]         }, add = TRUE)
[17:42:45.270]     }
[17:42:45.270]     ...future.frame <- base::sys.nframe()
[17:42:45.270]     ...future.conditions <- base::list()
[17:42:45.270]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.270]     if (FALSE) {
[17:42:45.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.270]     }
[17:42:45.270]     ...future.result <- base::tryCatch({
[17:42:45.270]         base::withCallingHandlers({
[17:42:45.270]             ...future.value <- base::withVisible(base::local({
[17:42:45.270]                 withCallingHandlers({
[17:42:45.270]                   value(a) + 1
[17:42:45.270]                 }, immediateCondition = function(cond) {
[17:42:45.270]                   save_rds <- function (object, pathname, ...) 
[17:42:45.270]                   {
[17:42:45.270]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.270]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.270]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.270]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.270]                         fi_tmp[["mtime"]])
[17:42:45.270]                     }
[17:42:45.270]                     tryCatch({
[17:42:45.270]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.270]                     }, error = function(ex) {
[17:42:45.270]                       msg <- conditionMessage(ex)
[17:42:45.270]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.270]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.270]                         fi_tmp[["mtime"]], msg)
[17:42:45.270]                       ex$message <- msg
[17:42:45.270]                       stop(ex)
[17:42:45.270]                     })
[17:42:45.270]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.270]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.270]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.270]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.270]                       fi <- file.info(pathname)
[17:42:45.270]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.270]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.270]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.270]                         fi[["size"]], fi[["mtime"]])
[17:42:45.270]                       stop(msg)
[17:42:45.270]                     }
[17:42:45.270]                     invisible(pathname)
[17:42:45.270]                   }
[17:42:45.270]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.270]                     rootPath = tempdir()) 
[17:42:45.270]                   {
[17:42:45.270]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.270]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.270]                       tmpdir = path, fileext = ".rds")
[17:42:45.270]                     save_rds(obj, file)
[17:42:45.270]                   }
[17:42:45.270]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.270]                   {
[17:42:45.270]                     inherits <- base::inherits
[17:42:45.270]                     invokeRestart <- base::invokeRestart
[17:42:45.270]                     is.null <- base::is.null
[17:42:45.270]                     muffled <- FALSE
[17:42:45.270]                     if (inherits(cond, "message")) {
[17:42:45.270]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.270]                       if (muffled) 
[17:42:45.270]                         invokeRestart("muffleMessage")
[17:42:45.270]                     }
[17:42:45.270]                     else if (inherits(cond, "warning")) {
[17:42:45.270]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.270]                       if (muffled) 
[17:42:45.270]                         invokeRestart("muffleWarning")
[17:42:45.270]                     }
[17:42:45.270]                     else if (inherits(cond, "condition")) {
[17:42:45.270]                       if (!is.null(pattern)) {
[17:42:45.270]                         computeRestarts <- base::computeRestarts
[17:42:45.270]                         grepl <- base::grepl
[17:42:45.270]                         restarts <- computeRestarts(cond)
[17:42:45.270]                         for (restart in restarts) {
[17:42:45.270]                           name <- restart$name
[17:42:45.270]                           if (is.null(name)) 
[17:42:45.270]                             next
[17:42:45.270]                           if (!grepl(pattern, name)) 
[17:42:45.270]                             next
[17:42:45.270]                           invokeRestart(restart)
[17:42:45.270]                           muffled <- TRUE
[17:42:45.270]                           break
[17:42:45.270]                         }
[17:42:45.270]                       }
[17:42:45.270]                     }
[17:42:45.270]                     invisible(muffled)
[17:42:45.270]                   }
[17:42:45.270]                   muffleCondition(cond)
[17:42:45.270]                 })
[17:42:45.270]             }))
[17:42:45.270]             future::FutureResult(value = ...future.value$value, 
[17:42:45.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.270]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.270]                     ...future.globalenv.names))
[17:42:45.270]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.270]         }, condition = base::local({
[17:42:45.270]             c <- base::c
[17:42:45.270]             inherits <- base::inherits
[17:42:45.270]             invokeRestart <- base::invokeRestart
[17:42:45.270]             length <- base::length
[17:42:45.270]             list <- base::list
[17:42:45.270]             seq.int <- base::seq.int
[17:42:45.270]             signalCondition <- base::signalCondition
[17:42:45.270]             sys.calls <- base::sys.calls
[17:42:45.270]             `[[` <- base::`[[`
[17:42:45.270]             `+` <- base::`+`
[17:42:45.270]             `<<-` <- base::`<<-`
[17:42:45.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.270]                   3L)]
[17:42:45.270]             }
[17:42:45.270]             function(cond) {
[17:42:45.270]                 is_error <- inherits(cond, "error")
[17:42:45.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.270]                   NULL)
[17:42:45.270]                 if (is_error) {
[17:42:45.270]                   sessionInformation <- function() {
[17:42:45.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.270]                       search = base::search(), system = base::Sys.info())
[17:42:45.270]                   }
[17:42:45.270]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.270]                     cond$call), session = sessionInformation(), 
[17:42:45.270]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.270]                   signalCondition(cond)
[17:42:45.270]                 }
[17:42:45.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.270]                 "immediateCondition"))) {
[17:42:45.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.270]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.270]                   if (TRUE && !signal) {
[17:42:45.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.270]                     {
[17:42:45.270]                       inherits <- base::inherits
[17:42:45.270]                       invokeRestart <- base::invokeRestart
[17:42:45.270]                       is.null <- base::is.null
[17:42:45.270]                       muffled <- FALSE
[17:42:45.270]                       if (inherits(cond, "message")) {
[17:42:45.270]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.270]                         if (muffled) 
[17:42:45.270]                           invokeRestart("muffleMessage")
[17:42:45.270]                       }
[17:42:45.270]                       else if (inherits(cond, "warning")) {
[17:42:45.270]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.270]                         if (muffled) 
[17:42:45.270]                           invokeRestart("muffleWarning")
[17:42:45.270]                       }
[17:42:45.270]                       else if (inherits(cond, "condition")) {
[17:42:45.270]                         if (!is.null(pattern)) {
[17:42:45.270]                           computeRestarts <- base::computeRestarts
[17:42:45.270]                           grepl <- base::grepl
[17:42:45.270]                           restarts <- computeRestarts(cond)
[17:42:45.270]                           for (restart in restarts) {
[17:42:45.270]                             name <- restart$name
[17:42:45.270]                             if (is.null(name)) 
[17:42:45.270]                               next
[17:42:45.270]                             if (!grepl(pattern, name)) 
[17:42:45.270]                               next
[17:42:45.270]                             invokeRestart(restart)
[17:42:45.270]                             muffled <- TRUE
[17:42:45.270]                             break
[17:42:45.270]                           }
[17:42:45.270]                         }
[17:42:45.270]                       }
[17:42:45.270]                       invisible(muffled)
[17:42:45.270]                     }
[17:42:45.270]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.270]                   }
[17:42:45.270]                 }
[17:42:45.270]                 else {
[17:42:45.270]                   if (TRUE) {
[17:42:45.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.270]                     {
[17:42:45.270]                       inherits <- base::inherits
[17:42:45.270]                       invokeRestart <- base::invokeRestart
[17:42:45.270]                       is.null <- base::is.null
[17:42:45.270]                       muffled <- FALSE
[17:42:45.270]                       if (inherits(cond, "message")) {
[17:42:45.270]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.270]                         if (muffled) 
[17:42:45.270]                           invokeRestart("muffleMessage")
[17:42:45.270]                       }
[17:42:45.270]                       else if (inherits(cond, "warning")) {
[17:42:45.270]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.270]                         if (muffled) 
[17:42:45.270]                           invokeRestart("muffleWarning")
[17:42:45.270]                       }
[17:42:45.270]                       else if (inherits(cond, "condition")) {
[17:42:45.270]                         if (!is.null(pattern)) {
[17:42:45.270]                           computeRestarts <- base::computeRestarts
[17:42:45.270]                           grepl <- base::grepl
[17:42:45.270]                           restarts <- computeRestarts(cond)
[17:42:45.270]                           for (restart in restarts) {
[17:42:45.270]                             name <- restart$name
[17:42:45.270]                             if (is.null(name)) 
[17:42:45.270]                               next
[17:42:45.270]                             if (!grepl(pattern, name)) 
[17:42:45.270]                               next
[17:42:45.270]                             invokeRestart(restart)
[17:42:45.270]                             muffled <- TRUE
[17:42:45.270]                             break
[17:42:45.270]                           }
[17:42:45.270]                         }
[17:42:45.270]                       }
[17:42:45.270]                       invisible(muffled)
[17:42:45.270]                     }
[17:42:45.270]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.270]                   }
[17:42:45.270]                 }
[17:42:45.270]             }
[17:42:45.270]         }))
[17:42:45.270]     }, error = function(ex) {
[17:42:45.270]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.270]                 ...future.rng), started = ...future.startTime, 
[17:42:45.270]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.270]             version = "1.8"), class = "FutureResult")
[17:42:45.270]     }, finally = {
[17:42:45.270]         if (!identical(...future.workdir, getwd())) 
[17:42:45.270]             setwd(...future.workdir)
[17:42:45.270]         {
[17:42:45.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.270]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.270]             }
[17:42:45.270]             base::options(...future.oldOptions)
[17:42:45.270]             if (.Platform$OS.type == "windows") {
[17:42:45.270]                 old_names <- names(...future.oldEnvVars)
[17:42:45.270]                 envs <- base::Sys.getenv()
[17:42:45.270]                 names <- names(envs)
[17:42:45.270]                 common <- intersect(names, old_names)
[17:42:45.270]                 added <- setdiff(names, old_names)
[17:42:45.270]                 removed <- setdiff(old_names, names)
[17:42:45.270]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.270]                   envs[common]]
[17:42:45.270]                 NAMES <- toupper(changed)
[17:42:45.270]                 args <- list()
[17:42:45.270]                 for (kk in seq_along(NAMES)) {
[17:42:45.270]                   name <- changed[[kk]]
[17:42:45.270]                   NAME <- NAMES[[kk]]
[17:42:45.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.270]                     next
[17:42:45.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.270]                 }
[17:42:45.270]                 NAMES <- toupper(added)
[17:42:45.270]                 for (kk in seq_along(NAMES)) {
[17:42:45.270]                   name <- added[[kk]]
[17:42:45.270]                   NAME <- NAMES[[kk]]
[17:42:45.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.270]                     next
[17:42:45.270]                   args[[name]] <- ""
[17:42:45.270]                 }
[17:42:45.270]                 NAMES <- toupper(removed)
[17:42:45.270]                 for (kk in seq_along(NAMES)) {
[17:42:45.270]                   name <- removed[[kk]]
[17:42:45.270]                   NAME <- NAMES[[kk]]
[17:42:45.270]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.270]                     next
[17:42:45.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.270]                 }
[17:42:45.270]                 if (length(args) > 0) 
[17:42:45.270]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.270]             }
[17:42:45.270]             else {
[17:42:45.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.270]             }
[17:42:45.270]             {
[17:42:45.270]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.270]                   0L) {
[17:42:45.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.270]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.270]                   base::options(opts)
[17:42:45.270]                 }
[17:42:45.270]                 {
[17:42:45.270]                   {
[17:42:45.270]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.270]                     NULL
[17:42:45.270]                   }
[17:42:45.270]                   options(future.plan = NULL)
[17:42:45.270]                   if (is.na(NA_character_)) 
[17:42:45.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.270]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.270]                     envir = parent.frame()) 
[17:42:45.270]                   {
[17:42:45.270]                     default_workers <- missing(workers)
[17:42:45.270]                     if (is.function(workers)) 
[17:42:45.270]                       workers <- workers()
[17:42:45.270]                     workers <- structure(as.integer(workers), 
[17:42:45.270]                       class = class(workers))
[17:42:45.270]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.270]                       1L)
[17:42:45.270]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.270]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.270]                       if (default_workers) 
[17:42:45.270]                         supportsMulticore(warn = TRUE)
[17:42:45.270]                       return(sequential(..., envir = envir))
[17:42:45.270]                     }
[17:42:45.270]                     oopts <- options(mc.cores = workers)
[17:42:45.270]                     on.exit(options(oopts))
[17:42:45.270]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.270]                       envir = envir)
[17:42:45.270]                     if (!future$lazy) 
[17:42:45.270]                       future <- run(future)
[17:42:45.270]                     invisible(future)
[17:42:45.270]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.270]                 }
[17:42:45.270]             }
[17:42:45.270]         }
[17:42:45.270]     })
[17:42:45.270]     if (TRUE) {
[17:42:45.270]         base::sink(type = "output", split = FALSE)
[17:42:45.270]         if (TRUE) {
[17:42:45.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.270]         }
[17:42:45.270]         else {
[17:42:45.270]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.270]         }
[17:42:45.270]         base::close(...future.stdout)
[17:42:45.270]         ...future.stdout <- NULL
[17:42:45.270]     }
[17:42:45.270]     ...future.result$conditions <- ...future.conditions
[17:42:45.270]     ...future.result$finished <- base::Sys.time()
[17:42:45.270]     ...future.result
[17:42:45.270] }
[17:42:45.273] assign_globals() ...
[17:42:45.273] List of 1
[17:42:45.273]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56181aaadd68> 
[17:42:45.273]  - attr(*, "where")=List of 1
[17:42:45.273]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.273]  - attr(*, "resolved")= logi TRUE
[17:42:45.273]  - attr(*, "total_size")= num 10984
[17:42:45.273]  - attr(*, "already-done")= logi TRUE
[17:42:45.276] - copied ‘a’ to environment
[17:42:45.276] assign_globals() ... done
[17:42:45.276] requestCore(): workers = 2
[17:42:45.279] MulticoreFuture started
[17:42:45.279] - Launch lazy future ... done
[17:42:45.280] run() for ‘MulticoreFuture’ ... done
[17:42:45.280] plan(): Setting new future strategy stack:
[17:42:45.281] List of future strategies:
[17:42:45.281] 1. sequential:
[17:42:45.281]    - args: function (..., envir = parent.frame())
[17:42:45.281]    - tweaked: FALSE
[17:42:45.281]    - call: NULL
[17:42:45.282] plan(): nbrOfWorkers() = 1
[17:42:45.284] plan(): Setting new future strategy stack:
[17:42:45.284] List of future strategies:
[17:42:45.284] 1. multicore:
[17:42:45.284]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.284]    - tweaked: FALSE
[17:42:45.284]    - call: plan(strategy)
[17:42:45.289] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.290] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.291] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.292] 
[17:42:45.292] Searching for globals ... DONE
[17:42:45.292] - globals: [0] <none>
[17:42:45.292] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.292] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.293] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.297] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.297] Searching for globals ... DONE
[17:42:45.297] Resolving globals: TRUE
[17:42:45.297] Resolving any globals that are futures ...
[17:42:45.297] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.298] Resolving any globals that are futures ... DONE
[17:42:45.298] Resolving futures part of globals (recursively) ...
[17:42:45.299] resolve() on list ...
[17:42:45.299]  recursive: 99
[17:42:45.299]  length: 1
[17:42:45.299]  elements: ‘a’
[17:42:45.299] run() for ‘Future’ ...
[17:42:45.300] - state: ‘created’
[17:42:45.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.305]   - Field: ‘label’
[17:42:45.305]   - Field: ‘local’
[17:42:45.305]   - Field: ‘owner’
[17:42:45.305]   - Field: ‘envir’
[17:42:45.305]   - Field: ‘workers’
[17:42:45.305]   - Field: ‘packages’
[17:42:45.305]   - Field: ‘gc’
[17:42:45.306]   - Field: ‘job’
[17:42:45.306]   - Field: ‘conditions’
[17:42:45.306]   - Field: ‘expr’
[17:42:45.306]   - Field: ‘uuid’
[17:42:45.306]   - Field: ‘seed’
[17:42:45.306]   - Field: ‘version’
[17:42:45.306]   - Field: ‘result’
[17:42:45.306]   - Field: ‘asynchronous’
[17:42:45.307]   - Field: ‘calls’
[17:42:45.307]   - Field: ‘globals’
[17:42:45.307]   - Field: ‘stdout’
[17:42:45.307]   - Field: ‘earlySignal’
[17:42:45.307]   - Field: ‘lazy’
[17:42:45.307]   - Field: ‘state’
[17:42:45.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.307] - Launch lazy future ...
[17:42:45.308] Packages needed by the future expression (n = 0): <none>
[17:42:45.308] Packages needed by future strategies (n = 0): <none>
[17:42:45.308] {
[17:42:45.308]     {
[17:42:45.308]         {
[17:42:45.308]             ...future.startTime <- base::Sys.time()
[17:42:45.308]             {
[17:42:45.308]                 {
[17:42:45.308]                   {
[17:42:45.308]                     {
[17:42:45.308]                       base::local({
[17:42:45.308]                         has_future <- base::requireNamespace("future", 
[17:42:45.308]                           quietly = TRUE)
[17:42:45.308]                         if (has_future) {
[17:42:45.308]                           ns <- base::getNamespace("future")
[17:42:45.308]                           version <- ns[[".package"]][["version"]]
[17:42:45.308]                           if (is.null(version)) 
[17:42:45.308]                             version <- utils::packageVersion("future")
[17:42:45.308]                         }
[17:42:45.308]                         else {
[17:42:45.308]                           version <- NULL
[17:42:45.308]                         }
[17:42:45.308]                         if (!has_future || version < "1.8.0") {
[17:42:45.308]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.308]                             "", base::R.version$version.string), 
[17:42:45.308]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.308]                               "release", "version")], collapse = " "), 
[17:42:45.308]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.308]                             info)
[17:42:45.308]                           info <- base::paste(info, collapse = "; ")
[17:42:45.308]                           if (!has_future) {
[17:42:45.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.308]                               info)
[17:42:45.308]                           }
[17:42:45.308]                           else {
[17:42:45.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.308]                               info, version)
[17:42:45.308]                           }
[17:42:45.308]                           base::stop(msg)
[17:42:45.308]                         }
[17:42:45.308]                       })
[17:42:45.308]                     }
[17:42:45.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.308]                     base::options(mc.cores = 1L)
[17:42:45.308]                   }
[17:42:45.308]                   options(future.plan = NULL)
[17:42:45.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.308]                 }
[17:42:45.308]                 ...future.workdir <- getwd()
[17:42:45.308]             }
[17:42:45.308]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.308]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.308]         }
[17:42:45.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.308]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.308]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.308]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.308]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.308]             base::names(...future.oldOptions))
[17:42:45.308]     }
[17:42:45.308]     if (FALSE) {
[17:42:45.308]     }
[17:42:45.308]     else {
[17:42:45.308]         if (TRUE) {
[17:42:45.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.308]                 open = "w")
[17:42:45.308]         }
[17:42:45.308]         else {
[17:42:45.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.308]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.308]         }
[17:42:45.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.308]             base::sink(type = "output", split = FALSE)
[17:42:45.308]             base::close(...future.stdout)
[17:42:45.308]         }, add = TRUE)
[17:42:45.308]     }
[17:42:45.308]     ...future.frame <- base::sys.nframe()
[17:42:45.308]     ...future.conditions <- base::list()
[17:42:45.308]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.308]     if (FALSE) {
[17:42:45.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.308]     }
[17:42:45.308]     ...future.result <- base::tryCatch({
[17:42:45.308]         base::withCallingHandlers({
[17:42:45.308]             ...future.value <- base::withVisible(base::local({
[17:42:45.308]                 withCallingHandlers({
[17:42:45.308]                   1
[17:42:45.308]                 }, immediateCondition = function(cond) {
[17:42:45.308]                   save_rds <- function (object, pathname, ...) 
[17:42:45.308]                   {
[17:42:45.308]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.308]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.308]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.308]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.308]                         fi_tmp[["mtime"]])
[17:42:45.308]                     }
[17:42:45.308]                     tryCatch({
[17:42:45.308]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.308]                     }, error = function(ex) {
[17:42:45.308]                       msg <- conditionMessage(ex)
[17:42:45.308]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.308]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.308]                         fi_tmp[["mtime"]], msg)
[17:42:45.308]                       ex$message <- msg
[17:42:45.308]                       stop(ex)
[17:42:45.308]                     })
[17:42:45.308]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.308]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.308]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.308]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.308]                       fi <- file.info(pathname)
[17:42:45.308]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.308]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.308]                         fi[["size"]], fi[["mtime"]])
[17:42:45.308]                       stop(msg)
[17:42:45.308]                     }
[17:42:45.308]                     invisible(pathname)
[17:42:45.308]                   }
[17:42:45.308]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.308]                     rootPath = tempdir()) 
[17:42:45.308]                   {
[17:42:45.308]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.308]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.308]                       tmpdir = path, fileext = ".rds")
[17:42:45.308]                     save_rds(obj, file)
[17:42:45.308]                   }
[17:42:45.308]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.308]                   {
[17:42:45.308]                     inherits <- base::inherits
[17:42:45.308]                     invokeRestart <- base::invokeRestart
[17:42:45.308]                     is.null <- base::is.null
[17:42:45.308]                     muffled <- FALSE
[17:42:45.308]                     if (inherits(cond, "message")) {
[17:42:45.308]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.308]                       if (muffled) 
[17:42:45.308]                         invokeRestart("muffleMessage")
[17:42:45.308]                     }
[17:42:45.308]                     else if (inherits(cond, "warning")) {
[17:42:45.308]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.308]                       if (muffled) 
[17:42:45.308]                         invokeRestart("muffleWarning")
[17:42:45.308]                     }
[17:42:45.308]                     else if (inherits(cond, "condition")) {
[17:42:45.308]                       if (!is.null(pattern)) {
[17:42:45.308]                         computeRestarts <- base::computeRestarts
[17:42:45.308]                         grepl <- base::grepl
[17:42:45.308]                         restarts <- computeRestarts(cond)
[17:42:45.308]                         for (restart in restarts) {
[17:42:45.308]                           name <- restart$name
[17:42:45.308]                           if (is.null(name)) 
[17:42:45.308]                             next
[17:42:45.308]                           if (!grepl(pattern, name)) 
[17:42:45.308]                             next
[17:42:45.308]                           invokeRestart(restart)
[17:42:45.308]                           muffled <- TRUE
[17:42:45.308]                           break
[17:42:45.308]                         }
[17:42:45.308]                       }
[17:42:45.308]                     }
[17:42:45.308]                     invisible(muffled)
[17:42:45.308]                   }
[17:42:45.308]                   muffleCondition(cond)
[17:42:45.308]                 })
[17:42:45.308]             }))
[17:42:45.308]             future::FutureResult(value = ...future.value$value, 
[17:42:45.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.308]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.308]                     ...future.globalenv.names))
[17:42:45.308]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.308]         }, condition = base::local({
[17:42:45.308]             c <- base::c
[17:42:45.308]             inherits <- base::inherits
[17:42:45.308]             invokeRestart <- base::invokeRestart
[17:42:45.308]             length <- base::length
[17:42:45.308]             list <- base::list
[17:42:45.308]             seq.int <- base::seq.int
[17:42:45.308]             signalCondition <- base::signalCondition
[17:42:45.308]             sys.calls <- base::sys.calls
[17:42:45.308]             `[[` <- base::`[[`
[17:42:45.308]             `+` <- base::`+`
[17:42:45.308]             `<<-` <- base::`<<-`
[17:42:45.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.308]                   3L)]
[17:42:45.308]             }
[17:42:45.308]             function(cond) {
[17:42:45.308]                 is_error <- inherits(cond, "error")
[17:42:45.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.308]                   NULL)
[17:42:45.308]                 if (is_error) {
[17:42:45.308]                   sessionInformation <- function() {
[17:42:45.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.308]                       search = base::search(), system = base::Sys.info())
[17:42:45.308]                   }
[17:42:45.308]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.308]                     cond$call), session = sessionInformation(), 
[17:42:45.308]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.308]                   signalCondition(cond)
[17:42:45.308]                 }
[17:42:45.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.308]                 "immediateCondition"))) {
[17:42:45.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.308]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.308]                   if (TRUE && !signal) {
[17:42:45.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.308]                     {
[17:42:45.308]                       inherits <- base::inherits
[17:42:45.308]                       invokeRestart <- base::invokeRestart
[17:42:45.308]                       is.null <- base::is.null
[17:42:45.308]                       muffled <- FALSE
[17:42:45.308]                       if (inherits(cond, "message")) {
[17:42:45.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.308]                         if (muffled) 
[17:42:45.308]                           invokeRestart("muffleMessage")
[17:42:45.308]                       }
[17:42:45.308]                       else if (inherits(cond, "warning")) {
[17:42:45.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.308]                         if (muffled) 
[17:42:45.308]                           invokeRestart("muffleWarning")
[17:42:45.308]                       }
[17:42:45.308]                       else if (inherits(cond, "condition")) {
[17:42:45.308]                         if (!is.null(pattern)) {
[17:42:45.308]                           computeRestarts <- base::computeRestarts
[17:42:45.308]                           grepl <- base::grepl
[17:42:45.308]                           restarts <- computeRestarts(cond)
[17:42:45.308]                           for (restart in restarts) {
[17:42:45.308]                             name <- restart$name
[17:42:45.308]                             if (is.null(name)) 
[17:42:45.308]                               next
[17:42:45.308]                             if (!grepl(pattern, name)) 
[17:42:45.308]                               next
[17:42:45.308]                             invokeRestart(restart)
[17:42:45.308]                             muffled <- TRUE
[17:42:45.308]                             break
[17:42:45.308]                           }
[17:42:45.308]                         }
[17:42:45.308]                       }
[17:42:45.308]                       invisible(muffled)
[17:42:45.308]                     }
[17:42:45.308]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.308]                   }
[17:42:45.308]                 }
[17:42:45.308]                 else {
[17:42:45.308]                   if (TRUE) {
[17:42:45.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.308]                     {
[17:42:45.308]                       inherits <- base::inherits
[17:42:45.308]                       invokeRestart <- base::invokeRestart
[17:42:45.308]                       is.null <- base::is.null
[17:42:45.308]                       muffled <- FALSE
[17:42:45.308]                       if (inherits(cond, "message")) {
[17:42:45.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.308]                         if (muffled) 
[17:42:45.308]                           invokeRestart("muffleMessage")
[17:42:45.308]                       }
[17:42:45.308]                       else if (inherits(cond, "warning")) {
[17:42:45.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.308]                         if (muffled) 
[17:42:45.308]                           invokeRestart("muffleWarning")
[17:42:45.308]                       }
[17:42:45.308]                       else if (inherits(cond, "condition")) {
[17:42:45.308]                         if (!is.null(pattern)) {
[17:42:45.308]                           computeRestarts <- base::computeRestarts
[17:42:45.308]                           grepl <- base::grepl
[17:42:45.308]                           restarts <- computeRestarts(cond)
[17:42:45.308]                           for (restart in restarts) {
[17:42:45.308]                             name <- restart$name
[17:42:45.308]                             if (is.null(name)) 
[17:42:45.308]                               next
[17:42:45.308]                             if (!grepl(pattern, name)) 
[17:42:45.308]                               next
[17:42:45.308]                             invokeRestart(restart)
[17:42:45.308]                             muffled <- TRUE
[17:42:45.308]                             break
[17:42:45.308]                           }
[17:42:45.308]                         }
[17:42:45.308]                       }
[17:42:45.308]                       invisible(muffled)
[17:42:45.308]                     }
[17:42:45.308]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.308]                   }
[17:42:45.308]                 }
[17:42:45.308]             }
[17:42:45.308]         }))
[17:42:45.308]     }, error = function(ex) {
[17:42:45.308]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.308]                 ...future.rng), started = ...future.startTime, 
[17:42:45.308]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.308]             version = "1.8"), class = "FutureResult")
[17:42:45.308]     }, finally = {
[17:42:45.308]         if (!identical(...future.workdir, getwd())) 
[17:42:45.308]             setwd(...future.workdir)
[17:42:45.308]         {
[17:42:45.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.308]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.308]             }
[17:42:45.308]             base::options(...future.oldOptions)
[17:42:45.308]             if (.Platform$OS.type == "windows") {
[17:42:45.308]                 old_names <- names(...future.oldEnvVars)
[17:42:45.308]                 envs <- base::Sys.getenv()
[17:42:45.308]                 names <- names(envs)
[17:42:45.308]                 common <- intersect(names, old_names)
[17:42:45.308]                 added <- setdiff(names, old_names)
[17:42:45.308]                 removed <- setdiff(old_names, names)
[17:42:45.308]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.308]                   envs[common]]
[17:42:45.308]                 NAMES <- toupper(changed)
[17:42:45.308]                 args <- list()
[17:42:45.308]                 for (kk in seq_along(NAMES)) {
[17:42:45.308]                   name <- changed[[kk]]
[17:42:45.308]                   NAME <- NAMES[[kk]]
[17:42:45.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.308]                     next
[17:42:45.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.308]                 }
[17:42:45.308]                 NAMES <- toupper(added)
[17:42:45.308]                 for (kk in seq_along(NAMES)) {
[17:42:45.308]                   name <- added[[kk]]
[17:42:45.308]                   NAME <- NAMES[[kk]]
[17:42:45.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.308]                     next
[17:42:45.308]                   args[[name]] <- ""
[17:42:45.308]                 }
[17:42:45.308]                 NAMES <- toupper(removed)
[17:42:45.308]                 for (kk in seq_along(NAMES)) {
[17:42:45.308]                   name <- removed[[kk]]
[17:42:45.308]                   NAME <- NAMES[[kk]]
[17:42:45.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.308]                     next
[17:42:45.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.308]                 }
[17:42:45.308]                 if (length(args) > 0) 
[17:42:45.308]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.308]             }
[17:42:45.308]             else {
[17:42:45.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.308]             }
[17:42:45.308]             {
[17:42:45.308]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.308]                   0L) {
[17:42:45.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.308]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.308]                   base::options(opts)
[17:42:45.308]                 }
[17:42:45.308]                 {
[17:42:45.308]                   {
[17:42:45.308]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.308]                     NULL
[17:42:45.308]                   }
[17:42:45.308]                   options(future.plan = NULL)
[17:42:45.308]                   if (is.na(NA_character_)) 
[17:42:45.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.308]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.308]                     envir = parent.frame()) 
[17:42:45.308]                   {
[17:42:45.308]                     default_workers <- missing(workers)
[17:42:45.308]                     if (is.function(workers)) 
[17:42:45.308]                       workers <- workers()
[17:42:45.308]                     workers <- structure(as.integer(workers), 
[17:42:45.308]                       class = class(workers))
[17:42:45.308]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.308]                       1L)
[17:42:45.308]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.308]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.308]                       if (default_workers) 
[17:42:45.308]                         supportsMulticore(warn = TRUE)
[17:42:45.308]                       return(sequential(..., envir = envir))
[17:42:45.308]                     }
[17:42:45.308]                     oopts <- options(mc.cores = workers)
[17:42:45.308]                     on.exit(options(oopts))
[17:42:45.308]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.308]                       envir = envir)
[17:42:45.308]                     if (!future$lazy) 
[17:42:45.308]                       future <- run(future)
[17:42:45.308]                     invisible(future)
[17:42:45.308]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.308]                 }
[17:42:45.308]             }
[17:42:45.308]         }
[17:42:45.308]     })
[17:42:45.308]     if (TRUE) {
[17:42:45.308]         base::sink(type = "output", split = FALSE)
[17:42:45.308]         if (TRUE) {
[17:42:45.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.308]         }
[17:42:45.308]         else {
[17:42:45.308]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.308]         }
[17:42:45.308]         base::close(...future.stdout)
[17:42:45.308]         ...future.stdout <- NULL
[17:42:45.308]     }
[17:42:45.308]     ...future.result$conditions <- ...future.conditions
[17:42:45.308]     ...future.result$finished <- base::Sys.time()
[17:42:45.308]     ...future.result
[17:42:45.308] }
[17:42:45.311] requestCore(): workers = 2
[17:42:45.313] MulticoreFuture started
[17:42:45.314] - Launch lazy future ... done
[17:42:45.314] run() for ‘MulticoreFuture’ ... done
[17:42:45.314] plan(): Setting new future strategy stack:
[17:42:45.315] List of future strategies:
[17:42:45.315] 1. sequential:
[17:42:45.315]    - args: function (..., envir = parent.frame())
[17:42:45.315]    - tweaked: FALSE
[17:42:45.315]    - call: NULL
[17:42:45.316] plan(): nbrOfWorkers() = 1
[17:42:45.318] plan(): Setting new future strategy stack:
[17:42:45.318] List of future strategies:
[17:42:45.318] 1. multicore:
[17:42:45.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.318]    - tweaked: FALSE
[17:42:45.318]    - call: plan(strategy)
[17:42:45.323] plan(): nbrOfWorkers() = 2
[17:42:45.324] Future #1
[17:42:45.325] A MulticoreFuture was resolved
[17:42:45.325]  length: 0 (resolved future 1)
[17:42:45.325] resolve() on list ... DONE
[17:42:45.325] - globals: [1] ‘a’
[17:42:45.325] Resolving futures part of globals (recursively) ... DONE
[17:42:45.327] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[17:42:45.327] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[17:42:45.328] - globals: [1] ‘a’
[17:42:45.328] - packages: [1] ‘future’
[17:42:45.328] getGlobalsAndPackages() ... DONE
[17:42:45.328] run() for ‘Future’ ...
[17:42:45.328] - state: ‘created’
[17:42:45.329] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.333] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.333]   - Field: ‘label’
[17:42:45.333]   - Field: ‘local’
[17:42:45.333]   - Field: ‘owner’
[17:42:45.333]   - Field: ‘envir’
[17:42:45.333]   - Field: ‘workers’
[17:42:45.333]   - Field: ‘packages’
[17:42:45.334]   - Field: ‘gc’
[17:42:45.334]   - Field: ‘job’
[17:42:45.334]   - Field: ‘conditions’
[17:42:45.334]   - Field: ‘expr’
[17:42:45.334]   - Field: ‘uuid’
[17:42:45.334]   - Field: ‘seed’
[17:42:45.335]   - Field: ‘version’
[17:42:45.335]   - Field: ‘result’
[17:42:45.335]   - Field: ‘asynchronous’
[17:42:45.335]   - Field: ‘calls’
[17:42:45.335]   - Field: ‘globals’
[17:42:45.335]   - Field: ‘stdout’
[17:42:45.335]   - Field: ‘earlySignal’
[17:42:45.336]   - Field: ‘lazy’
[17:42:45.336]   - Field: ‘state’
[17:42:45.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.336] - Launch lazy future ...
[17:42:45.336] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.336] Packages needed by future strategies (n = 0): <none>
[17:42:45.337] {
[17:42:45.337]     {
[17:42:45.337]         {
[17:42:45.337]             ...future.startTime <- base::Sys.time()
[17:42:45.337]             {
[17:42:45.337]                 {
[17:42:45.337]                   {
[17:42:45.337]                     {
[17:42:45.337]                       {
[17:42:45.337]                         base::local({
[17:42:45.337]                           has_future <- base::requireNamespace("future", 
[17:42:45.337]                             quietly = TRUE)
[17:42:45.337]                           if (has_future) {
[17:42:45.337]                             ns <- base::getNamespace("future")
[17:42:45.337]                             version <- ns[[".package"]][["version"]]
[17:42:45.337]                             if (is.null(version)) 
[17:42:45.337]                               version <- utils::packageVersion("future")
[17:42:45.337]                           }
[17:42:45.337]                           else {
[17:42:45.337]                             version <- NULL
[17:42:45.337]                           }
[17:42:45.337]                           if (!has_future || version < "1.8.0") {
[17:42:45.337]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.337]                               "", base::R.version$version.string), 
[17:42:45.337]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.337]                                 base::R.version$platform, 8 * 
[17:42:45.337]                                   base::.Machine$sizeof.pointer), 
[17:42:45.337]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.337]                                 "release", "version")], collapse = " "), 
[17:42:45.337]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.337]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.337]                               info)
[17:42:45.337]                             info <- base::paste(info, collapse = "; ")
[17:42:45.337]                             if (!has_future) {
[17:42:45.337]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.337]                                 info)
[17:42:45.337]                             }
[17:42:45.337]                             else {
[17:42:45.337]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.337]                                 info, version)
[17:42:45.337]                             }
[17:42:45.337]                             base::stop(msg)
[17:42:45.337]                           }
[17:42:45.337]                         })
[17:42:45.337]                       }
[17:42:45.337]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.337]                       base::options(mc.cores = 1L)
[17:42:45.337]                     }
[17:42:45.337]                     base::local({
[17:42:45.337]                       for (pkg in "future") {
[17:42:45.337]                         base::loadNamespace(pkg)
[17:42:45.337]                         base::library(pkg, character.only = TRUE)
[17:42:45.337]                       }
[17:42:45.337]                     })
[17:42:45.337]                   }
[17:42:45.337]                   options(future.plan = NULL)
[17:42:45.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.337]                 }
[17:42:45.337]                 ...future.workdir <- getwd()
[17:42:45.337]             }
[17:42:45.337]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.337]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.337]         }
[17:42:45.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.337]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.337]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.337]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.337]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.337]             base::names(...future.oldOptions))
[17:42:45.337]     }
[17:42:45.337]     if (FALSE) {
[17:42:45.337]     }
[17:42:45.337]     else {
[17:42:45.337]         if (TRUE) {
[17:42:45.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.337]                 open = "w")
[17:42:45.337]         }
[17:42:45.337]         else {
[17:42:45.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.337]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.337]         }
[17:42:45.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.337]             base::sink(type = "output", split = FALSE)
[17:42:45.337]             base::close(...future.stdout)
[17:42:45.337]         }, add = TRUE)
[17:42:45.337]     }
[17:42:45.337]     ...future.frame <- base::sys.nframe()
[17:42:45.337]     ...future.conditions <- base::list()
[17:42:45.337]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.337]     if (FALSE) {
[17:42:45.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.337]     }
[17:42:45.337]     ...future.result <- base::tryCatch({
[17:42:45.337]         base::withCallingHandlers({
[17:42:45.337]             ...future.value <- base::withVisible(base::local({
[17:42:45.337]                 withCallingHandlers({
[17:42:45.337]                   value(a) + 1
[17:42:45.337]                 }, immediateCondition = function(cond) {
[17:42:45.337]                   save_rds <- function (object, pathname, ...) 
[17:42:45.337]                   {
[17:42:45.337]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.337]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.337]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.337]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.337]                         fi_tmp[["mtime"]])
[17:42:45.337]                     }
[17:42:45.337]                     tryCatch({
[17:42:45.337]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.337]                     }, error = function(ex) {
[17:42:45.337]                       msg <- conditionMessage(ex)
[17:42:45.337]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.337]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.337]                         fi_tmp[["mtime"]], msg)
[17:42:45.337]                       ex$message <- msg
[17:42:45.337]                       stop(ex)
[17:42:45.337]                     })
[17:42:45.337]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.337]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.337]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.337]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.337]                       fi <- file.info(pathname)
[17:42:45.337]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.337]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.337]                         fi[["size"]], fi[["mtime"]])
[17:42:45.337]                       stop(msg)
[17:42:45.337]                     }
[17:42:45.337]                     invisible(pathname)
[17:42:45.337]                   }
[17:42:45.337]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.337]                     rootPath = tempdir()) 
[17:42:45.337]                   {
[17:42:45.337]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.337]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.337]                       tmpdir = path, fileext = ".rds")
[17:42:45.337]                     save_rds(obj, file)
[17:42:45.337]                   }
[17:42:45.337]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.337]                   {
[17:42:45.337]                     inherits <- base::inherits
[17:42:45.337]                     invokeRestart <- base::invokeRestart
[17:42:45.337]                     is.null <- base::is.null
[17:42:45.337]                     muffled <- FALSE
[17:42:45.337]                     if (inherits(cond, "message")) {
[17:42:45.337]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.337]                       if (muffled) 
[17:42:45.337]                         invokeRestart("muffleMessage")
[17:42:45.337]                     }
[17:42:45.337]                     else if (inherits(cond, "warning")) {
[17:42:45.337]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.337]                       if (muffled) 
[17:42:45.337]                         invokeRestart("muffleWarning")
[17:42:45.337]                     }
[17:42:45.337]                     else if (inherits(cond, "condition")) {
[17:42:45.337]                       if (!is.null(pattern)) {
[17:42:45.337]                         computeRestarts <- base::computeRestarts
[17:42:45.337]                         grepl <- base::grepl
[17:42:45.337]                         restarts <- computeRestarts(cond)
[17:42:45.337]                         for (restart in restarts) {
[17:42:45.337]                           name <- restart$name
[17:42:45.337]                           if (is.null(name)) 
[17:42:45.337]                             next
[17:42:45.337]                           if (!grepl(pattern, name)) 
[17:42:45.337]                             next
[17:42:45.337]                           invokeRestart(restart)
[17:42:45.337]                           muffled <- TRUE
[17:42:45.337]                           break
[17:42:45.337]                         }
[17:42:45.337]                       }
[17:42:45.337]                     }
[17:42:45.337]                     invisible(muffled)
[17:42:45.337]                   }
[17:42:45.337]                   muffleCondition(cond)
[17:42:45.337]                 })
[17:42:45.337]             }))
[17:42:45.337]             future::FutureResult(value = ...future.value$value, 
[17:42:45.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.337]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.337]                     ...future.globalenv.names))
[17:42:45.337]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.337]         }, condition = base::local({
[17:42:45.337]             c <- base::c
[17:42:45.337]             inherits <- base::inherits
[17:42:45.337]             invokeRestart <- base::invokeRestart
[17:42:45.337]             length <- base::length
[17:42:45.337]             list <- base::list
[17:42:45.337]             seq.int <- base::seq.int
[17:42:45.337]             signalCondition <- base::signalCondition
[17:42:45.337]             sys.calls <- base::sys.calls
[17:42:45.337]             `[[` <- base::`[[`
[17:42:45.337]             `+` <- base::`+`
[17:42:45.337]             `<<-` <- base::`<<-`
[17:42:45.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.337]                   3L)]
[17:42:45.337]             }
[17:42:45.337]             function(cond) {
[17:42:45.337]                 is_error <- inherits(cond, "error")
[17:42:45.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.337]                   NULL)
[17:42:45.337]                 if (is_error) {
[17:42:45.337]                   sessionInformation <- function() {
[17:42:45.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.337]                       search = base::search(), system = base::Sys.info())
[17:42:45.337]                   }
[17:42:45.337]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.337]                     cond$call), session = sessionInformation(), 
[17:42:45.337]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.337]                   signalCondition(cond)
[17:42:45.337]                 }
[17:42:45.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.337]                 "immediateCondition"))) {
[17:42:45.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.337]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.337]                   if (TRUE && !signal) {
[17:42:45.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.337]                     {
[17:42:45.337]                       inherits <- base::inherits
[17:42:45.337]                       invokeRestart <- base::invokeRestart
[17:42:45.337]                       is.null <- base::is.null
[17:42:45.337]                       muffled <- FALSE
[17:42:45.337]                       if (inherits(cond, "message")) {
[17:42:45.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.337]                         if (muffled) 
[17:42:45.337]                           invokeRestart("muffleMessage")
[17:42:45.337]                       }
[17:42:45.337]                       else if (inherits(cond, "warning")) {
[17:42:45.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.337]                         if (muffled) 
[17:42:45.337]                           invokeRestart("muffleWarning")
[17:42:45.337]                       }
[17:42:45.337]                       else if (inherits(cond, "condition")) {
[17:42:45.337]                         if (!is.null(pattern)) {
[17:42:45.337]                           computeRestarts <- base::computeRestarts
[17:42:45.337]                           grepl <- base::grepl
[17:42:45.337]                           restarts <- computeRestarts(cond)
[17:42:45.337]                           for (restart in restarts) {
[17:42:45.337]                             name <- restart$name
[17:42:45.337]                             if (is.null(name)) 
[17:42:45.337]                               next
[17:42:45.337]                             if (!grepl(pattern, name)) 
[17:42:45.337]                               next
[17:42:45.337]                             invokeRestart(restart)
[17:42:45.337]                             muffled <- TRUE
[17:42:45.337]                             break
[17:42:45.337]                           }
[17:42:45.337]                         }
[17:42:45.337]                       }
[17:42:45.337]                       invisible(muffled)
[17:42:45.337]                     }
[17:42:45.337]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.337]                   }
[17:42:45.337]                 }
[17:42:45.337]                 else {
[17:42:45.337]                   if (TRUE) {
[17:42:45.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.337]                     {
[17:42:45.337]                       inherits <- base::inherits
[17:42:45.337]                       invokeRestart <- base::invokeRestart
[17:42:45.337]                       is.null <- base::is.null
[17:42:45.337]                       muffled <- FALSE
[17:42:45.337]                       if (inherits(cond, "message")) {
[17:42:45.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.337]                         if (muffled) 
[17:42:45.337]                           invokeRestart("muffleMessage")
[17:42:45.337]                       }
[17:42:45.337]                       else if (inherits(cond, "warning")) {
[17:42:45.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.337]                         if (muffled) 
[17:42:45.337]                           invokeRestart("muffleWarning")
[17:42:45.337]                       }
[17:42:45.337]                       else if (inherits(cond, "condition")) {
[17:42:45.337]                         if (!is.null(pattern)) {
[17:42:45.337]                           computeRestarts <- base::computeRestarts
[17:42:45.337]                           grepl <- base::grepl
[17:42:45.337]                           restarts <- computeRestarts(cond)
[17:42:45.337]                           for (restart in restarts) {
[17:42:45.337]                             name <- restart$name
[17:42:45.337]                             if (is.null(name)) 
[17:42:45.337]                               next
[17:42:45.337]                             if (!grepl(pattern, name)) 
[17:42:45.337]                               next
[17:42:45.337]                             invokeRestart(restart)
[17:42:45.337]                             muffled <- TRUE
[17:42:45.337]                             break
[17:42:45.337]                           }
[17:42:45.337]                         }
[17:42:45.337]                       }
[17:42:45.337]                       invisible(muffled)
[17:42:45.337]                     }
[17:42:45.337]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.337]                   }
[17:42:45.337]                 }
[17:42:45.337]             }
[17:42:45.337]         }))
[17:42:45.337]     }, error = function(ex) {
[17:42:45.337]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.337]                 ...future.rng), started = ...future.startTime, 
[17:42:45.337]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.337]             version = "1.8"), class = "FutureResult")
[17:42:45.337]     }, finally = {
[17:42:45.337]         if (!identical(...future.workdir, getwd())) 
[17:42:45.337]             setwd(...future.workdir)
[17:42:45.337]         {
[17:42:45.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.337]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.337]             }
[17:42:45.337]             base::options(...future.oldOptions)
[17:42:45.337]             if (.Platform$OS.type == "windows") {
[17:42:45.337]                 old_names <- names(...future.oldEnvVars)
[17:42:45.337]                 envs <- base::Sys.getenv()
[17:42:45.337]                 names <- names(envs)
[17:42:45.337]                 common <- intersect(names, old_names)
[17:42:45.337]                 added <- setdiff(names, old_names)
[17:42:45.337]                 removed <- setdiff(old_names, names)
[17:42:45.337]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.337]                   envs[common]]
[17:42:45.337]                 NAMES <- toupper(changed)
[17:42:45.337]                 args <- list()
[17:42:45.337]                 for (kk in seq_along(NAMES)) {
[17:42:45.337]                   name <- changed[[kk]]
[17:42:45.337]                   NAME <- NAMES[[kk]]
[17:42:45.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.337]                     next
[17:42:45.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.337]                 }
[17:42:45.337]                 NAMES <- toupper(added)
[17:42:45.337]                 for (kk in seq_along(NAMES)) {
[17:42:45.337]                   name <- added[[kk]]
[17:42:45.337]                   NAME <- NAMES[[kk]]
[17:42:45.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.337]                     next
[17:42:45.337]                   args[[name]] <- ""
[17:42:45.337]                 }
[17:42:45.337]                 NAMES <- toupper(removed)
[17:42:45.337]                 for (kk in seq_along(NAMES)) {
[17:42:45.337]                   name <- removed[[kk]]
[17:42:45.337]                   NAME <- NAMES[[kk]]
[17:42:45.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.337]                     next
[17:42:45.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.337]                 }
[17:42:45.337]                 if (length(args) > 0) 
[17:42:45.337]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.337]             }
[17:42:45.337]             else {
[17:42:45.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.337]             }
[17:42:45.337]             {
[17:42:45.337]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.337]                   0L) {
[17:42:45.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.337]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.337]                   base::options(opts)
[17:42:45.337]                 }
[17:42:45.337]                 {
[17:42:45.337]                   {
[17:42:45.337]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.337]                     NULL
[17:42:45.337]                   }
[17:42:45.337]                   options(future.plan = NULL)
[17:42:45.337]                   if (is.na(NA_character_)) 
[17:42:45.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.337]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.337]                     envir = parent.frame()) 
[17:42:45.337]                   {
[17:42:45.337]                     default_workers <- missing(workers)
[17:42:45.337]                     if (is.function(workers)) 
[17:42:45.337]                       workers <- workers()
[17:42:45.337]                     workers <- structure(as.integer(workers), 
[17:42:45.337]                       class = class(workers))
[17:42:45.337]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.337]                       1L)
[17:42:45.337]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.337]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.337]                       if (default_workers) 
[17:42:45.337]                         supportsMulticore(warn = TRUE)
[17:42:45.337]                       return(sequential(..., envir = envir))
[17:42:45.337]                     }
[17:42:45.337]                     oopts <- options(mc.cores = workers)
[17:42:45.337]                     on.exit(options(oopts))
[17:42:45.337]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.337]                       envir = envir)
[17:42:45.337]                     if (!future$lazy) 
[17:42:45.337]                       future <- run(future)
[17:42:45.337]                     invisible(future)
[17:42:45.337]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.337]                 }
[17:42:45.337]             }
[17:42:45.337]         }
[17:42:45.337]     })
[17:42:45.337]     if (TRUE) {
[17:42:45.337]         base::sink(type = "output", split = FALSE)
[17:42:45.337]         if (TRUE) {
[17:42:45.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.337]         }
[17:42:45.337]         else {
[17:42:45.337]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.337]         }
[17:42:45.337]         base::close(...future.stdout)
[17:42:45.337]         ...future.stdout <- NULL
[17:42:45.337]     }
[17:42:45.337]     ...future.result$conditions <- ...future.conditions
[17:42:45.337]     ...future.result$finished <- base::Sys.time()
[17:42:45.337]     ...future.result
[17:42:45.337] }
[17:42:45.340] assign_globals() ...
[17:42:45.340] List of 1
[17:42:45.340]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56181ae96ee0> 
[17:42:45.340]  - attr(*, "where")=List of 1
[17:42:45.340]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.340]  - attr(*, "resolved")= logi TRUE
[17:42:45.340]  - attr(*, "total_size")= num 10984
[17:42:45.340]  - attr(*, "already-done")= logi TRUE
[17:42:45.346] - copied ‘a’ to environment
[17:42:45.346] assign_globals() ... done
[17:42:45.347] requestCore(): workers = 2
[17:42:45.349] MulticoreFuture started
[17:42:45.350] - Launch lazy future ... done
[17:42:45.350] run() for ‘MulticoreFuture’ ... done
[17:42:45.351] plan(): Setting new future strategy stack:
[17:42:45.352] List of future strategies:
[17:42:45.352] 1. sequential:
[17:42:45.352]    - args: function (..., envir = parent.frame())
[17:42:45.352]    - tweaked: FALSE
[17:42:45.352]    - call: NULL
[17:42:45.353] plan(): nbrOfWorkers() = 1
[17:42:45.356] plan(): Setting new future strategy stack:
[17:42:45.356] List of future strategies:
[17:42:45.356] 1. multicore:
[17:42:45.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.356]    - tweaked: FALSE
[17:42:45.356]    - call: plan(strategy)
[17:42:45.362] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.363] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.364] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:45.365] - globals found: [2] ‘{’, ‘pkg’
[17:42:45.365] Searching for globals ... DONE
[17:42:45.366] Resolving globals: TRUE
[17:42:45.366] Resolving any globals that are futures ...
[17:42:45.366] - globals: [2] ‘{’, ‘pkg’
[17:42:45.366] Resolving any globals that are futures ... DONE
[17:42:45.366] Resolving futures part of globals (recursively) ...
[17:42:45.367] resolve() on list ...
[17:42:45.367]  recursive: 99
[17:42:45.367]  length: 1
[17:42:45.367]  elements: ‘pkg’
[17:42:45.367]  length: 0 (resolved future 1)
[17:42:45.368] resolve() on list ... DONE
[17:42:45.368] - globals: [1] ‘pkg’
[17:42:45.368] Resolving futures part of globals (recursively) ... DONE
[17:42:45.368] The total size of the 1 globals is 112 bytes (112 bytes)
[17:42:45.369] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:42:45.369] - globals: [1] ‘pkg’
[17:42:45.369] 
[17:42:45.369] getGlobalsAndPackages() ... DONE
[17:42:45.370] Packages needed by the future expression (n = 0): <none>
[17:42:45.370] Packages needed by future strategies (n = 0): <none>
[17:42:45.371] {
[17:42:45.371]     {
[17:42:45.371]         {
[17:42:45.371]             ...future.startTime <- base::Sys.time()
[17:42:45.371]             {
[17:42:45.371]                 {
[17:42:45.371]                   {
[17:42:45.371]                     base::local({
[17:42:45.371]                       has_future <- base::requireNamespace("future", 
[17:42:45.371]                         quietly = TRUE)
[17:42:45.371]                       if (has_future) {
[17:42:45.371]                         ns <- base::getNamespace("future")
[17:42:45.371]                         version <- ns[[".package"]][["version"]]
[17:42:45.371]                         if (is.null(version)) 
[17:42:45.371]                           version <- utils::packageVersion("future")
[17:42:45.371]                       }
[17:42:45.371]                       else {
[17:42:45.371]                         version <- NULL
[17:42:45.371]                       }
[17:42:45.371]                       if (!has_future || version < "1.8.0") {
[17:42:45.371]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.371]                           "", base::R.version$version.string), 
[17:42:45.371]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:45.371]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.371]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.371]                             "release", "version")], collapse = " "), 
[17:42:45.371]                           hostname = base::Sys.info()[["nodename"]])
[17:42:45.371]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.371]                           info)
[17:42:45.371]                         info <- base::paste(info, collapse = "; ")
[17:42:45.371]                         if (!has_future) {
[17:42:45.371]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.371]                             info)
[17:42:45.371]                         }
[17:42:45.371]                         else {
[17:42:45.371]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.371]                             info, version)
[17:42:45.371]                         }
[17:42:45.371]                         base::stop(msg)
[17:42:45.371]                       }
[17:42:45.371]                     })
[17:42:45.371]                   }
[17:42:45.371]                   options(future.plan = NULL)
[17:42:45.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.371]                 }
[17:42:45.371]                 ...future.workdir <- getwd()
[17:42:45.371]             }
[17:42:45.371]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.371]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.371]         }
[17:42:45.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.371]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:45.371]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.371]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.371]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.371]             base::names(...future.oldOptions))
[17:42:45.371]     }
[17:42:45.371]     if (FALSE) {
[17:42:45.371]     }
[17:42:45.371]     else {
[17:42:45.371]         if (TRUE) {
[17:42:45.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.371]                 open = "w")
[17:42:45.371]         }
[17:42:45.371]         else {
[17:42:45.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.371]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.371]         }
[17:42:45.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.371]             base::sink(type = "output", split = FALSE)
[17:42:45.371]             base::close(...future.stdout)
[17:42:45.371]         }, add = TRUE)
[17:42:45.371]     }
[17:42:45.371]     ...future.frame <- base::sys.nframe()
[17:42:45.371]     ...future.conditions <- base::list()
[17:42:45.371]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.371]     if (FALSE) {
[17:42:45.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.371]     }
[17:42:45.371]     ...future.result <- base::tryCatch({
[17:42:45.371]         base::withCallingHandlers({
[17:42:45.371]             ...future.value <- base::withVisible(base::local({
[17:42:45.371]                 pkg
[17:42:45.371]             }))
[17:42:45.371]             future::FutureResult(value = ...future.value$value, 
[17:42:45.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.371]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.371]                     ...future.globalenv.names))
[17:42:45.371]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.371]         }, condition = base::local({
[17:42:45.371]             c <- base::c
[17:42:45.371]             inherits <- base::inherits
[17:42:45.371]             invokeRestart <- base::invokeRestart
[17:42:45.371]             length <- base::length
[17:42:45.371]             list <- base::list
[17:42:45.371]             seq.int <- base::seq.int
[17:42:45.371]             signalCondition <- base::signalCondition
[17:42:45.371]             sys.calls <- base::sys.calls
[17:42:45.371]             `[[` <- base::`[[`
[17:42:45.371]             `+` <- base::`+`
[17:42:45.371]             `<<-` <- base::`<<-`
[17:42:45.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.371]                   3L)]
[17:42:45.371]             }
[17:42:45.371]             function(cond) {
[17:42:45.371]                 is_error <- inherits(cond, "error")
[17:42:45.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.371]                   NULL)
[17:42:45.371]                 if (is_error) {
[17:42:45.371]                   sessionInformation <- function() {
[17:42:45.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.371]                       search = base::search(), system = base::Sys.info())
[17:42:45.371]                   }
[17:42:45.371]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.371]                     cond$call), session = sessionInformation(), 
[17:42:45.371]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.371]                   signalCondition(cond)
[17:42:45.371]                 }
[17:42:45.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.371]                 "immediateCondition"))) {
[17:42:45.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.371]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.371]                   if (TRUE && !signal) {
[17:42:45.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.371]                     {
[17:42:45.371]                       inherits <- base::inherits
[17:42:45.371]                       invokeRestart <- base::invokeRestart
[17:42:45.371]                       is.null <- base::is.null
[17:42:45.371]                       muffled <- FALSE
[17:42:45.371]                       if (inherits(cond, "message")) {
[17:42:45.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.371]                         if (muffled) 
[17:42:45.371]                           invokeRestart("muffleMessage")
[17:42:45.371]                       }
[17:42:45.371]                       else if (inherits(cond, "warning")) {
[17:42:45.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.371]                         if (muffled) 
[17:42:45.371]                           invokeRestart("muffleWarning")
[17:42:45.371]                       }
[17:42:45.371]                       else if (inherits(cond, "condition")) {
[17:42:45.371]                         if (!is.null(pattern)) {
[17:42:45.371]                           computeRestarts <- base::computeRestarts
[17:42:45.371]                           grepl <- base::grepl
[17:42:45.371]                           restarts <- computeRestarts(cond)
[17:42:45.371]                           for (restart in restarts) {
[17:42:45.371]                             name <- restart$name
[17:42:45.371]                             if (is.null(name)) 
[17:42:45.371]                               next
[17:42:45.371]                             if (!grepl(pattern, name)) 
[17:42:45.371]                               next
[17:42:45.371]                             invokeRestart(restart)
[17:42:45.371]                             muffled <- TRUE
[17:42:45.371]                             break
[17:42:45.371]                           }
[17:42:45.371]                         }
[17:42:45.371]                       }
[17:42:45.371]                       invisible(muffled)
[17:42:45.371]                     }
[17:42:45.371]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.371]                   }
[17:42:45.371]                 }
[17:42:45.371]                 else {
[17:42:45.371]                   if (TRUE) {
[17:42:45.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.371]                     {
[17:42:45.371]                       inherits <- base::inherits
[17:42:45.371]                       invokeRestart <- base::invokeRestart
[17:42:45.371]                       is.null <- base::is.null
[17:42:45.371]                       muffled <- FALSE
[17:42:45.371]                       if (inherits(cond, "message")) {
[17:42:45.371]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.371]                         if (muffled) 
[17:42:45.371]                           invokeRestart("muffleMessage")
[17:42:45.371]                       }
[17:42:45.371]                       else if (inherits(cond, "warning")) {
[17:42:45.371]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.371]                         if (muffled) 
[17:42:45.371]                           invokeRestart("muffleWarning")
[17:42:45.371]                       }
[17:42:45.371]                       else if (inherits(cond, "condition")) {
[17:42:45.371]                         if (!is.null(pattern)) {
[17:42:45.371]                           computeRestarts <- base::computeRestarts
[17:42:45.371]                           grepl <- base::grepl
[17:42:45.371]                           restarts <- computeRestarts(cond)
[17:42:45.371]                           for (restart in restarts) {
[17:42:45.371]                             name <- restart$name
[17:42:45.371]                             if (is.null(name)) 
[17:42:45.371]                               next
[17:42:45.371]                             if (!grepl(pattern, name)) 
[17:42:45.371]                               next
[17:42:45.371]                             invokeRestart(restart)
[17:42:45.371]                             muffled <- TRUE
[17:42:45.371]                             break
[17:42:45.371]                           }
[17:42:45.371]                         }
[17:42:45.371]                       }
[17:42:45.371]                       invisible(muffled)
[17:42:45.371]                     }
[17:42:45.371]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.371]                   }
[17:42:45.371]                 }
[17:42:45.371]             }
[17:42:45.371]         }))
[17:42:45.371]     }, error = function(ex) {
[17:42:45.371]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.371]                 ...future.rng), started = ...future.startTime, 
[17:42:45.371]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.371]             version = "1.8"), class = "FutureResult")
[17:42:45.371]     }, finally = {
[17:42:45.371]         if (!identical(...future.workdir, getwd())) 
[17:42:45.371]             setwd(...future.workdir)
[17:42:45.371]         {
[17:42:45.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.371]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.371]             }
[17:42:45.371]             base::options(...future.oldOptions)
[17:42:45.371]             if (.Platform$OS.type == "windows") {
[17:42:45.371]                 old_names <- names(...future.oldEnvVars)
[17:42:45.371]                 envs <- base::Sys.getenv()
[17:42:45.371]                 names <- names(envs)
[17:42:45.371]                 common <- intersect(names, old_names)
[17:42:45.371]                 added <- setdiff(names, old_names)
[17:42:45.371]                 removed <- setdiff(old_names, names)
[17:42:45.371]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.371]                   envs[common]]
[17:42:45.371]                 NAMES <- toupper(changed)
[17:42:45.371]                 args <- list()
[17:42:45.371]                 for (kk in seq_along(NAMES)) {
[17:42:45.371]                   name <- changed[[kk]]
[17:42:45.371]                   NAME <- NAMES[[kk]]
[17:42:45.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.371]                     next
[17:42:45.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.371]                 }
[17:42:45.371]                 NAMES <- toupper(added)
[17:42:45.371]                 for (kk in seq_along(NAMES)) {
[17:42:45.371]                   name <- added[[kk]]
[17:42:45.371]                   NAME <- NAMES[[kk]]
[17:42:45.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.371]                     next
[17:42:45.371]                   args[[name]] <- ""
[17:42:45.371]                 }
[17:42:45.371]                 NAMES <- toupper(removed)
[17:42:45.371]                 for (kk in seq_along(NAMES)) {
[17:42:45.371]                   name <- removed[[kk]]
[17:42:45.371]                   NAME <- NAMES[[kk]]
[17:42:45.371]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.371]                     next
[17:42:45.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.371]                 }
[17:42:45.371]                 if (length(args) > 0) 
[17:42:45.371]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.371]             }
[17:42:45.371]             else {
[17:42:45.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.371]             }
[17:42:45.371]             {
[17:42:45.371]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.371]                   0L) {
[17:42:45.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.371]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.371]                   base::options(opts)
[17:42:45.371]                 }
[17:42:45.371]                 {
[17:42:45.371]                   {
[17:42:45.371]                     NULL
[17:42:45.371]                     RNGkind("Mersenne-Twister")
[17:42:45.371]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:45.371]                       inherits = FALSE)
[17:42:45.371]                   }
[17:42:45.371]                   options(future.plan = NULL)
[17:42:45.371]                   if (is.na(NA_character_)) 
[17:42:45.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.371]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.371]                     envir = parent.frame()) 
[17:42:45.371]                   {
[17:42:45.371]                     default_workers <- missing(workers)
[17:42:45.371]                     if (is.function(workers)) 
[17:42:45.371]                       workers <- workers()
[17:42:45.371]                     workers <- structure(as.integer(workers), 
[17:42:45.371]                       class = class(workers))
[17:42:45.371]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.371]                       1L)
[17:42:45.371]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.371]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.371]                       if (default_workers) 
[17:42:45.371]                         supportsMulticore(warn = TRUE)
[17:42:45.371]                       return(sequential(..., envir = envir))
[17:42:45.371]                     }
[17:42:45.371]                     oopts <- options(mc.cores = workers)
[17:42:45.371]                     on.exit(options(oopts))
[17:42:45.371]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.371]                       envir = envir)
[17:42:45.371]                     if (!future$lazy) 
[17:42:45.371]                       future <- run(future)
[17:42:45.371]                     invisible(future)
[17:42:45.371]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.371]                 }
[17:42:45.371]             }
[17:42:45.371]         }
[17:42:45.371]     })
[17:42:45.371]     if (TRUE) {
[17:42:45.371]         base::sink(type = "output", split = FALSE)
[17:42:45.371]         if (TRUE) {
[17:42:45.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.371]         }
[17:42:45.371]         else {
[17:42:45.371]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.371]         }
[17:42:45.371]         base::close(...future.stdout)
[17:42:45.371]         ...future.stdout <- NULL
[17:42:45.371]     }
[17:42:45.371]     ...future.result$conditions <- ...future.conditions
[17:42:45.371]     ...future.result$finished <- base::Sys.time()
[17:42:45.371]     ...future.result
[17:42:45.371] }
[17:42:45.373] assign_globals() ...
[17:42:45.373] List of 1
[17:42:45.373]  $ pkg: chr "foo"
[17:42:45.373]  - attr(*, "where")=List of 1
[17:42:45.373]   ..$ pkg:<environment: R_EmptyEnv> 
[17:42:45.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.373]  - attr(*, "resolved")= logi TRUE
[17:42:45.373]  - attr(*, "total_size")= num 112
[17:42:45.376] - copied ‘pkg’ to environment
[17:42:45.376] assign_globals() ... done
[17:42:45.376] plan(): Setting new future strategy stack:
[17:42:45.376] List of future strategies:
[17:42:45.376] 1. sequential:
[17:42:45.376]    - args: function (..., envir = parent.frame())
[17:42:45.376]    - tweaked: FALSE
[17:42:45.376]    - call: NULL
[17:42:45.377] plan(): nbrOfWorkers() = 1
[17:42:45.378] plan(): Setting new future strategy stack:
[17:42:45.378] List of future strategies:
[17:42:45.378] 1. multicore:
[17:42:45.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.378]    - tweaked: FALSE
[17:42:45.378]    - call: plan(strategy)
[17:42:45.382] plan(): nbrOfWorkers() = 2
[17:42:45.382] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.383] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.383] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.386] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:45.386] Searching for globals ... DONE
[17:42:45.386] Resolving globals: TRUE
[17:42:45.386] Resolving any globals that are futures ...
[17:42:45.386] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:45.386] Resolving any globals that are futures ... DONE
[17:42:45.387] Resolving futures part of globals (recursively) ...
[17:42:45.387] resolve() on list ...
[17:42:45.387]  recursive: 99
[17:42:45.387]  length: 1
[17:42:45.387]  elements: ‘a’
[17:42:45.387]  length: 0 (resolved future 1)
[17:42:45.387] resolve() on list ... DONE
[17:42:45.388] - globals: [1] ‘a’
[17:42:45.388] Resolving futures part of globals (recursively) ... DONE
[17:42:45.388] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:45.394] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:45.395] - globals: [1] ‘a’
[17:42:45.395] 
[17:42:45.395] getGlobalsAndPackages() ... DONE
[17:42:45.395] run() for ‘Future’ ...
[17:42:45.395] - state: ‘created’
[17:42:45.395] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.399] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.399] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.399]   - Field: ‘label’
[17:42:45.399]   - Field: ‘local’
[17:42:45.399]   - Field: ‘owner’
[17:42:45.400]   - Field: ‘envir’
[17:42:45.400]   - Field: ‘workers’
[17:42:45.400]   - Field: ‘packages’
[17:42:45.400]   - Field: ‘gc’
[17:42:45.400]   - Field: ‘job’
[17:42:45.400]   - Field: ‘conditions’
[17:42:45.400]   - Field: ‘expr’
[17:42:45.401]   - Field: ‘uuid’
[17:42:45.401]   - Field: ‘seed’
[17:42:45.401]   - Field: ‘version’
[17:42:45.401]   - Field: ‘result’
[17:42:45.401]   - Field: ‘asynchronous’
[17:42:45.401]   - Field: ‘calls’
[17:42:45.401]   - Field: ‘globals’
[17:42:45.401]   - Field: ‘stdout’
[17:42:45.401]   - Field: ‘earlySignal’
[17:42:45.402]   - Field: ‘lazy’
[17:42:45.402]   - Field: ‘state’
[17:42:45.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.402] - Launch lazy future ...
[17:42:45.402] Packages needed by the future expression (n = 0): <none>
[17:42:45.402] Packages needed by future strategies (n = 0): <none>
[17:42:45.403] {
[17:42:45.403]     {
[17:42:45.403]         {
[17:42:45.403]             ...future.startTime <- base::Sys.time()
[17:42:45.403]             {
[17:42:45.403]                 {
[17:42:45.403]                   {
[17:42:45.403]                     {
[17:42:45.403]                       base::local({
[17:42:45.403]                         has_future <- base::requireNamespace("future", 
[17:42:45.403]                           quietly = TRUE)
[17:42:45.403]                         if (has_future) {
[17:42:45.403]                           ns <- base::getNamespace("future")
[17:42:45.403]                           version <- ns[[".package"]][["version"]]
[17:42:45.403]                           if (is.null(version)) 
[17:42:45.403]                             version <- utils::packageVersion("future")
[17:42:45.403]                         }
[17:42:45.403]                         else {
[17:42:45.403]                           version <- NULL
[17:42:45.403]                         }
[17:42:45.403]                         if (!has_future || version < "1.8.0") {
[17:42:45.403]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.403]                             "", base::R.version$version.string), 
[17:42:45.403]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.403]                               "release", "version")], collapse = " "), 
[17:42:45.403]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.403]                             info)
[17:42:45.403]                           info <- base::paste(info, collapse = "; ")
[17:42:45.403]                           if (!has_future) {
[17:42:45.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.403]                               info)
[17:42:45.403]                           }
[17:42:45.403]                           else {
[17:42:45.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.403]                               info, version)
[17:42:45.403]                           }
[17:42:45.403]                           base::stop(msg)
[17:42:45.403]                         }
[17:42:45.403]                       })
[17:42:45.403]                     }
[17:42:45.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.403]                     base::options(mc.cores = 1L)
[17:42:45.403]                   }
[17:42:45.403]                   options(future.plan = NULL)
[17:42:45.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.403]                 }
[17:42:45.403]                 ...future.workdir <- getwd()
[17:42:45.403]             }
[17:42:45.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.403]         }
[17:42:45.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.403]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.403]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.403]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.403]             base::names(...future.oldOptions))
[17:42:45.403]     }
[17:42:45.403]     if (FALSE) {
[17:42:45.403]     }
[17:42:45.403]     else {
[17:42:45.403]         if (TRUE) {
[17:42:45.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.403]                 open = "w")
[17:42:45.403]         }
[17:42:45.403]         else {
[17:42:45.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.403]         }
[17:42:45.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.403]             base::sink(type = "output", split = FALSE)
[17:42:45.403]             base::close(...future.stdout)
[17:42:45.403]         }, add = TRUE)
[17:42:45.403]     }
[17:42:45.403]     ...future.frame <- base::sys.nframe()
[17:42:45.403]     ...future.conditions <- base::list()
[17:42:45.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.403]     if (FALSE) {
[17:42:45.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.403]     }
[17:42:45.403]     ...future.result <- base::tryCatch({
[17:42:45.403]         base::withCallingHandlers({
[17:42:45.403]             ...future.value <- base::withVisible(base::local({
[17:42:45.403]                 withCallingHandlers({
[17:42:45.403]                   {
[17:42:45.403]                     b <- a
[17:42:45.403]                     a <- 2
[17:42:45.403]                     a * b
[17:42:45.403]                   }
[17:42:45.403]                 }, immediateCondition = function(cond) {
[17:42:45.403]                   save_rds <- function (object, pathname, ...) 
[17:42:45.403]                   {
[17:42:45.403]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.403]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.403]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.403]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.403]                         fi_tmp[["mtime"]])
[17:42:45.403]                     }
[17:42:45.403]                     tryCatch({
[17:42:45.403]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.403]                     }, error = function(ex) {
[17:42:45.403]                       msg <- conditionMessage(ex)
[17:42:45.403]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.403]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.403]                         fi_tmp[["mtime"]], msg)
[17:42:45.403]                       ex$message <- msg
[17:42:45.403]                       stop(ex)
[17:42:45.403]                     })
[17:42:45.403]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.403]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.403]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.403]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.403]                       fi <- file.info(pathname)
[17:42:45.403]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.403]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.403]                         fi[["size"]], fi[["mtime"]])
[17:42:45.403]                       stop(msg)
[17:42:45.403]                     }
[17:42:45.403]                     invisible(pathname)
[17:42:45.403]                   }
[17:42:45.403]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.403]                     rootPath = tempdir()) 
[17:42:45.403]                   {
[17:42:45.403]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.403]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.403]                       tmpdir = path, fileext = ".rds")
[17:42:45.403]                     save_rds(obj, file)
[17:42:45.403]                   }
[17:42:45.403]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.403]                   {
[17:42:45.403]                     inherits <- base::inherits
[17:42:45.403]                     invokeRestart <- base::invokeRestart
[17:42:45.403]                     is.null <- base::is.null
[17:42:45.403]                     muffled <- FALSE
[17:42:45.403]                     if (inherits(cond, "message")) {
[17:42:45.403]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.403]                       if (muffled) 
[17:42:45.403]                         invokeRestart("muffleMessage")
[17:42:45.403]                     }
[17:42:45.403]                     else if (inherits(cond, "warning")) {
[17:42:45.403]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.403]                       if (muffled) 
[17:42:45.403]                         invokeRestart("muffleWarning")
[17:42:45.403]                     }
[17:42:45.403]                     else if (inherits(cond, "condition")) {
[17:42:45.403]                       if (!is.null(pattern)) {
[17:42:45.403]                         computeRestarts <- base::computeRestarts
[17:42:45.403]                         grepl <- base::grepl
[17:42:45.403]                         restarts <- computeRestarts(cond)
[17:42:45.403]                         for (restart in restarts) {
[17:42:45.403]                           name <- restart$name
[17:42:45.403]                           if (is.null(name)) 
[17:42:45.403]                             next
[17:42:45.403]                           if (!grepl(pattern, name)) 
[17:42:45.403]                             next
[17:42:45.403]                           invokeRestart(restart)
[17:42:45.403]                           muffled <- TRUE
[17:42:45.403]                           break
[17:42:45.403]                         }
[17:42:45.403]                       }
[17:42:45.403]                     }
[17:42:45.403]                     invisible(muffled)
[17:42:45.403]                   }
[17:42:45.403]                   muffleCondition(cond)
[17:42:45.403]                 })
[17:42:45.403]             }))
[17:42:45.403]             future::FutureResult(value = ...future.value$value, 
[17:42:45.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.403]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.403]                     ...future.globalenv.names))
[17:42:45.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.403]         }, condition = base::local({
[17:42:45.403]             c <- base::c
[17:42:45.403]             inherits <- base::inherits
[17:42:45.403]             invokeRestart <- base::invokeRestart
[17:42:45.403]             length <- base::length
[17:42:45.403]             list <- base::list
[17:42:45.403]             seq.int <- base::seq.int
[17:42:45.403]             signalCondition <- base::signalCondition
[17:42:45.403]             sys.calls <- base::sys.calls
[17:42:45.403]             `[[` <- base::`[[`
[17:42:45.403]             `+` <- base::`+`
[17:42:45.403]             `<<-` <- base::`<<-`
[17:42:45.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.403]                   3L)]
[17:42:45.403]             }
[17:42:45.403]             function(cond) {
[17:42:45.403]                 is_error <- inherits(cond, "error")
[17:42:45.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.403]                   NULL)
[17:42:45.403]                 if (is_error) {
[17:42:45.403]                   sessionInformation <- function() {
[17:42:45.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.403]                       search = base::search(), system = base::Sys.info())
[17:42:45.403]                   }
[17:42:45.403]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.403]                     cond$call), session = sessionInformation(), 
[17:42:45.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.403]                   signalCondition(cond)
[17:42:45.403]                 }
[17:42:45.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.403]                 "immediateCondition"))) {
[17:42:45.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.403]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.403]                   if (TRUE && !signal) {
[17:42:45.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.403]                     {
[17:42:45.403]                       inherits <- base::inherits
[17:42:45.403]                       invokeRestart <- base::invokeRestart
[17:42:45.403]                       is.null <- base::is.null
[17:42:45.403]                       muffled <- FALSE
[17:42:45.403]                       if (inherits(cond, "message")) {
[17:42:45.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.403]                         if (muffled) 
[17:42:45.403]                           invokeRestart("muffleMessage")
[17:42:45.403]                       }
[17:42:45.403]                       else if (inherits(cond, "warning")) {
[17:42:45.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.403]                         if (muffled) 
[17:42:45.403]                           invokeRestart("muffleWarning")
[17:42:45.403]                       }
[17:42:45.403]                       else if (inherits(cond, "condition")) {
[17:42:45.403]                         if (!is.null(pattern)) {
[17:42:45.403]                           computeRestarts <- base::computeRestarts
[17:42:45.403]                           grepl <- base::grepl
[17:42:45.403]                           restarts <- computeRestarts(cond)
[17:42:45.403]                           for (restart in restarts) {
[17:42:45.403]                             name <- restart$name
[17:42:45.403]                             if (is.null(name)) 
[17:42:45.403]                               next
[17:42:45.403]                             if (!grepl(pattern, name)) 
[17:42:45.403]                               next
[17:42:45.403]                             invokeRestart(restart)
[17:42:45.403]                             muffled <- TRUE
[17:42:45.403]                             break
[17:42:45.403]                           }
[17:42:45.403]                         }
[17:42:45.403]                       }
[17:42:45.403]                       invisible(muffled)
[17:42:45.403]                     }
[17:42:45.403]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.403]                   }
[17:42:45.403]                 }
[17:42:45.403]                 else {
[17:42:45.403]                   if (TRUE) {
[17:42:45.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.403]                     {
[17:42:45.403]                       inherits <- base::inherits
[17:42:45.403]                       invokeRestart <- base::invokeRestart
[17:42:45.403]                       is.null <- base::is.null
[17:42:45.403]                       muffled <- FALSE
[17:42:45.403]                       if (inherits(cond, "message")) {
[17:42:45.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.403]                         if (muffled) 
[17:42:45.403]                           invokeRestart("muffleMessage")
[17:42:45.403]                       }
[17:42:45.403]                       else if (inherits(cond, "warning")) {
[17:42:45.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.403]                         if (muffled) 
[17:42:45.403]                           invokeRestart("muffleWarning")
[17:42:45.403]                       }
[17:42:45.403]                       else if (inherits(cond, "condition")) {
[17:42:45.403]                         if (!is.null(pattern)) {
[17:42:45.403]                           computeRestarts <- base::computeRestarts
[17:42:45.403]                           grepl <- base::grepl
[17:42:45.403]                           restarts <- computeRestarts(cond)
[17:42:45.403]                           for (restart in restarts) {
[17:42:45.403]                             name <- restart$name
[17:42:45.403]                             if (is.null(name)) 
[17:42:45.403]                               next
[17:42:45.403]                             if (!grepl(pattern, name)) 
[17:42:45.403]                               next
[17:42:45.403]                             invokeRestart(restart)
[17:42:45.403]                             muffled <- TRUE
[17:42:45.403]                             break
[17:42:45.403]                           }
[17:42:45.403]                         }
[17:42:45.403]                       }
[17:42:45.403]                       invisible(muffled)
[17:42:45.403]                     }
[17:42:45.403]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.403]                   }
[17:42:45.403]                 }
[17:42:45.403]             }
[17:42:45.403]         }))
[17:42:45.403]     }, error = function(ex) {
[17:42:45.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.403]                 ...future.rng), started = ...future.startTime, 
[17:42:45.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.403]             version = "1.8"), class = "FutureResult")
[17:42:45.403]     }, finally = {
[17:42:45.403]         if (!identical(...future.workdir, getwd())) 
[17:42:45.403]             setwd(...future.workdir)
[17:42:45.403]         {
[17:42:45.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.403]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.403]             }
[17:42:45.403]             base::options(...future.oldOptions)
[17:42:45.403]             if (.Platform$OS.type == "windows") {
[17:42:45.403]                 old_names <- names(...future.oldEnvVars)
[17:42:45.403]                 envs <- base::Sys.getenv()
[17:42:45.403]                 names <- names(envs)
[17:42:45.403]                 common <- intersect(names, old_names)
[17:42:45.403]                 added <- setdiff(names, old_names)
[17:42:45.403]                 removed <- setdiff(old_names, names)
[17:42:45.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.403]                   envs[common]]
[17:42:45.403]                 NAMES <- toupper(changed)
[17:42:45.403]                 args <- list()
[17:42:45.403]                 for (kk in seq_along(NAMES)) {
[17:42:45.403]                   name <- changed[[kk]]
[17:42:45.403]                   NAME <- NAMES[[kk]]
[17:42:45.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.403]                     next
[17:42:45.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.403]                 }
[17:42:45.403]                 NAMES <- toupper(added)
[17:42:45.403]                 for (kk in seq_along(NAMES)) {
[17:42:45.403]                   name <- added[[kk]]
[17:42:45.403]                   NAME <- NAMES[[kk]]
[17:42:45.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.403]                     next
[17:42:45.403]                   args[[name]] <- ""
[17:42:45.403]                 }
[17:42:45.403]                 NAMES <- toupper(removed)
[17:42:45.403]                 for (kk in seq_along(NAMES)) {
[17:42:45.403]                   name <- removed[[kk]]
[17:42:45.403]                   NAME <- NAMES[[kk]]
[17:42:45.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.403]                     next
[17:42:45.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.403]                 }
[17:42:45.403]                 if (length(args) > 0) 
[17:42:45.403]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.403]             }
[17:42:45.403]             else {
[17:42:45.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.403]             }
[17:42:45.403]             {
[17:42:45.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.403]                   0L) {
[17:42:45.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.403]                   base::options(opts)
[17:42:45.403]                 }
[17:42:45.403]                 {
[17:42:45.403]                   {
[17:42:45.403]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.403]                     NULL
[17:42:45.403]                   }
[17:42:45.403]                   options(future.plan = NULL)
[17:42:45.403]                   if (is.na(NA_character_)) 
[17:42:45.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.403]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.403]                     envir = parent.frame()) 
[17:42:45.403]                   {
[17:42:45.403]                     default_workers <- missing(workers)
[17:42:45.403]                     if (is.function(workers)) 
[17:42:45.403]                       workers <- workers()
[17:42:45.403]                     workers <- structure(as.integer(workers), 
[17:42:45.403]                       class = class(workers))
[17:42:45.403]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.403]                       1L)
[17:42:45.403]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.403]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.403]                       if (default_workers) 
[17:42:45.403]                         supportsMulticore(warn = TRUE)
[17:42:45.403]                       return(sequential(..., envir = envir))
[17:42:45.403]                     }
[17:42:45.403]                     oopts <- options(mc.cores = workers)
[17:42:45.403]                     on.exit(options(oopts))
[17:42:45.403]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.403]                       envir = envir)
[17:42:45.403]                     if (!future$lazy) 
[17:42:45.403]                       future <- run(future)
[17:42:45.403]                     invisible(future)
[17:42:45.403]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.403]                 }
[17:42:45.403]             }
[17:42:45.403]         }
[17:42:45.403]     })
[17:42:45.403]     if (TRUE) {
[17:42:45.403]         base::sink(type = "output", split = FALSE)
[17:42:45.403]         if (TRUE) {
[17:42:45.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.403]         }
[17:42:45.403]         else {
[17:42:45.403]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.403]         }
[17:42:45.403]         base::close(...future.stdout)
[17:42:45.403]         ...future.stdout <- NULL
[17:42:45.403]     }
[17:42:45.403]     ...future.result$conditions <- ...future.conditions
[17:42:45.403]     ...future.result$finished <- base::Sys.time()
[17:42:45.403]     ...future.result
[17:42:45.403] }
[17:42:45.405] assign_globals() ...
[17:42:45.405] List of 1
[17:42:45.405]  $ a: num 3
[17:42:45.405]  - attr(*, "where")=List of 1
[17:42:45.405]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.405]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.405]  - attr(*, "resolved")= logi TRUE
[17:42:45.405]  - attr(*, "total_size")= num 56
[17:42:45.405]  - attr(*, "already-done")= logi TRUE
[17:42:45.408] - copied ‘a’ to environment
[17:42:45.408] assign_globals() ... done
[17:42:45.408] requestCore(): workers = 2
[17:42:45.411] MulticoreFuture started
[17:42:45.411] - Launch lazy future ... done
[17:42:45.411] run() for ‘MulticoreFuture’ ... done
[17:42:45.412] plan(): Setting new future strategy stack:
[17:42:45.412] List of future strategies:
[17:42:45.412] 1. sequential:
[17:42:45.412]    - args: function (..., envir = parent.frame())
[17:42:45.412]    - tweaked: FALSE
[17:42:45.412]    - call: NULL
[17:42:45.413] plan(): nbrOfWorkers() = 1
[17:42:45.415] plan(): Setting new future strategy stack:
[17:42:45.416] List of future strategies:
[17:42:45.416] 1. multicore:
[17:42:45.416]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.416]    - tweaked: FALSE
[17:42:45.416]    - call: plan(strategy)
[17:42:45.421] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.423] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.423] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.426] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:45.426] Searching for globals ... DONE
[17:42:45.426] Resolving globals: TRUE
[17:42:45.426] Resolving any globals that are futures ...
[17:42:45.426] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:45.427] Resolving any globals that are futures ... DONE
[17:42:45.427] Resolving futures part of globals (recursively) ...
[17:42:45.428] resolve() on list ...
[17:42:45.428]  recursive: 99
[17:42:45.428]  length: 1
[17:42:45.428]  elements: ‘a’
[17:42:45.428]  length: 0 (resolved future 1)
[17:42:45.428] resolve() on list ... DONE
[17:42:45.428] - globals: [1] ‘a’
[17:42:45.428] Resolving futures part of globals (recursively) ... DONE
[17:42:45.429] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:45.429] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:45.429] - globals: [1] ‘a’
[17:42:45.429] 
[17:42:45.429] getGlobalsAndPackages() ... DONE
[17:42:45.430] run() for ‘Future’ ...
[17:42:45.430] - state: ‘created’
[17:42:45.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.434] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.435]   - Field: ‘label’
[17:42:45.435]   - Field: ‘local’
[17:42:45.435]   - Field: ‘owner’
[17:42:45.435]   - Field: ‘envir’
[17:42:45.435]   - Field: ‘workers’
[17:42:45.435]   - Field: ‘packages’
[17:42:45.435]   - Field: ‘gc’
[17:42:45.436]   - Field: ‘job’
[17:42:45.436]   - Field: ‘conditions’
[17:42:45.436]   - Field: ‘expr’
[17:42:45.436]   - Field: ‘uuid’
[17:42:45.436]   - Field: ‘seed’
[17:42:45.436]   - Field: ‘version’
[17:42:45.436]   - Field: ‘result’
[17:42:45.436]   - Field: ‘asynchronous’
[17:42:45.437]   - Field: ‘calls’
[17:42:45.437]   - Field: ‘globals’
[17:42:45.437]   - Field: ‘stdout’
[17:42:45.437]   - Field: ‘earlySignal’
[17:42:45.437]   - Field: ‘lazy’
[17:42:45.437]   - Field: ‘state’
[17:42:45.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.437] - Launch lazy future ...
[17:42:45.438] Packages needed by the future expression (n = 0): <none>
[17:42:45.438] Packages needed by future strategies (n = 0): <none>
[17:42:45.441] {
[17:42:45.441]     {
[17:42:45.441]         {
[17:42:45.441]             ...future.startTime <- base::Sys.time()
[17:42:45.441]             {
[17:42:45.441]                 {
[17:42:45.441]                   {
[17:42:45.441]                     {
[17:42:45.441]                       base::local({
[17:42:45.441]                         has_future <- base::requireNamespace("future", 
[17:42:45.441]                           quietly = TRUE)
[17:42:45.441]                         if (has_future) {
[17:42:45.441]                           ns <- base::getNamespace("future")
[17:42:45.441]                           version <- ns[[".package"]][["version"]]
[17:42:45.441]                           if (is.null(version)) 
[17:42:45.441]                             version <- utils::packageVersion("future")
[17:42:45.441]                         }
[17:42:45.441]                         else {
[17:42:45.441]                           version <- NULL
[17:42:45.441]                         }
[17:42:45.441]                         if (!has_future || version < "1.8.0") {
[17:42:45.441]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.441]                             "", base::R.version$version.string), 
[17:42:45.441]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.441]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.441]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.441]                               "release", "version")], collapse = " "), 
[17:42:45.441]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.441]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.441]                             info)
[17:42:45.441]                           info <- base::paste(info, collapse = "; ")
[17:42:45.441]                           if (!has_future) {
[17:42:45.441]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.441]                               info)
[17:42:45.441]                           }
[17:42:45.441]                           else {
[17:42:45.441]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.441]                               info, version)
[17:42:45.441]                           }
[17:42:45.441]                           base::stop(msg)
[17:42:45.441]                         }
[17:42:45.441]                       })
[17:42:45.441]                     }
[17:42:45.441]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.441]                     base::options(mc.cores = 1L)
[17:42:45.441]                   }
[17:42:45.441]                   options(future.plan = NULL)
[17:42:45.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.441]                 }
[17:42:45.441]                 ...future.workdir <- getwd()
[17:42:45.441]             }
[17:42:45.441]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.441]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.441]         }
[17:42:45.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.441]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.441]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.441]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.441]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.441]             base::names(...future.oldOptions))
[17:42:45.441]     }
[17:42:45.441]     if (FALSE) {
[17:42:45.441]     }
[17:42:45.441]     else {
[17:42:45.441]         if (TRUE) {
[17:42:45.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.441]                 open = "w")
[17:42:45.441]         }
[17:42:45.441]         else {
[17:42:45.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.441]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.441]         }
[17:42:45.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.441]             base::sink(type = "output", split = FALSE)
[17:42:45.441]             base::close(...future.stdout)
[17:42:45.441]         }, add = TRUE)
[17:42:45.441]     }
[17:42:45.441]     ...future.frame <- base::sys.nframe()
[17:42:45.441]     ...future.conditions <- base::list()
[17:42:45.441]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.441]     if (FALSE) {
[17:42:45.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.441]     }
[17:42:45.441]     ...future.result <- base::tryCatch({
[17:42:45.441]         base::withCallingHandlers({
[17:42:45.441]             ...future.value <- base::withVisible(base::local({
[17:42:45.441]                 withCallingHandlers({
[17:42:45.441]                   {
[17:42:45.441]                     b <- a
[17:42:45.441]                     a <- 2
[17:42:45.441]                     a * b
[17:42:45.441]                   }
[17:42:45.441]                 }, immediateCondition = function(cond) {
[17:42:45.441]                   save_rds <- function (object, pathname, ...) 
[17:42:45.441]                   {
[17:42:45.441]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.441]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.441]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.441]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.441]                         fi_tmp[["mtime"]])
[17:42:45.441]                     }
[17:42:45.441]                     tryCatch({
[17:42:45.441]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.441]                     }, error = function(ex) {
[17:42:45.441]                       msg <- conditionMessage(ex)
[17:42:45.441]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.441]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.441]                         fi_tmp[["mtime"]], msg)
[17:42:45.441]                       ex$message <- msg
[17:42:45.441]                       stop(ex)
[17:42:45.441]                     })
[17:42:45.441]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.441]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.441]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.441]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.441]                       fi <- file.info(pathname)
[17:42:45.441]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.441]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.441]                         fi[["size"]], fi[["mtime"]])
[17:42:45.441]                       stop(msg)
[17:42:45.441]                     }
[17:42:45.441]                     invisible(pathname)
[17:42:45.441]                   }
[17:42:45.441]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.441]                     rootPath = tempdir()) 
[17:42:45.441]                   {
[17:42:45.441]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.441]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.441]                       tmpdir = path, fileext = ".rds")
[17:42:45.441]                     save_rds(obj, file)
[17:42:45.441]                   }
[17:42:45.441]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.441]                   {
[17:42:45.441]                     inherits <- base::inherits
[17:42:45.441]                     invokeRestart <- base::invokeRestart
[17:42:45.441]                     is.null <- base::is.null
[17:42:45.441]                     muffled <- FALSE
[17:42:45.441]                     if (inherits(cond, "message")) {
[17:42:45.441]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.441]                       if (muffled) 
[17:42:45.441]                         invokeRestart("muffleMessage")
[17:42:45.441]                     }
[17:42:45.441]                     else if (inherits(cond, "warning")) {
[17:42:45.441]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.441]                       if (muffled) 
[17:42:45.441]                         invokeRestart("muffleWarning")
[17:42:45.441]                     }
[17:42:45.441]                     else if (inherits(cond, "condition")) {
[17:42:45.441]                       if (!is.null(pattern)) {
[17:42:45.441]                         computeRestarts <- base::computeRestarts
[17:42:45.441]                         grepl <- base::grepl
[17:42:45.441]                         restarts <- computeRestarts(cond)
[17:42:45.441]                         for (restart in restarts) {
[17:42:45.441]                           name <- restart$name
[17:42:45.441]                           if (is.null(name)) 
[17:42:45.441]                             next
[17:42:45.441]                           if (!grepl(pattern, name)) 
[17:42:45.441]                             next
[17:42:45.441]                           invokeRestart(restart)
[17:42:45.441]                           muffled <- TRUE
[17:42:45.441]                           break
[17:42:45.441]                         }
[17:42:45.441]                       }
[17:42:45.441]                     }
[17:42:45.441]                     invisible(muffled)
[17:42:45.441]                   }
[17:42:45.441]                   muffleCondition(cond)
[17:42:45.441]                 })
[17:42:45.441]             }))
[17:42:45.441]             future::FutureResult(value = ...future.value$value, 
[17:42:45.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.441]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.441]                     ...future.globalenv.names))
[17:42:45.441]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.441]         }, condition = base::local({
[17:42:45.441]             c <- base::c
[17:42:45.441]             inherits <- base::inherits
[17:42:45.441]             invokeRestart <- base::invokeRestart
[17:42:45.441]             length <- base::length
[17:42:45.441]             list <- base::list
[17:42:45.441]             seq.int <- base::seq.int
[17:42:45.441]             signalCondition <- base::signalCondition
[17:42:45.441]             sys.calls <- base::sys.calls
[17:42:45.441]             `[[` <- base::`[[`
[17:42:45.441]             `+` <- base::`+`
[17:42:45.441]             `<<-` <- base::`<<-`
[17:42:45.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.441]                   3L)]
[17:42:45.441]             }
[17:42:45.441]             function(cond) {
[17:42:45.441]                 is_error <- inherits(cond, "error")
[17:42:45.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.441]                   NULL)
[17:42:45.441]                 if (is_error) {
[17:42:45.441]                   sessionInformation <- function() {
[17:42:45.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.441]                       search = base::search(), system = base::Sys.info())
[17:42:45.441]                   }
[17:42:45.441]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.441]                     cond$call), session = sessionInformation(), 
[17:42:45.441]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.441]                   signalCondition(cond)
[17:42:45.441]                 }
[17:42:45.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.441]                 "immediateCondition"))) {
[17:42:45.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.441]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.441]                   if (TRUE && !signal) {
[17:42:45.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.441]                     {
[17:42:45.441]                       inherits <- base::inherits
[17:42:45.441]                       invokeRestart <- base::invokeRestart
[17:42:45.441]                       is.null <- base::is.null
[17:42:45.441]                       muffled <- FALSE
[17:42:45.441]                       if (inherits(cond, "message")) {
[17:42:45.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.441]                         if (muffled) 
[17:42:45.441]                           invokeRestart("muffleMessage")
[17:42:45.441]                       }
[17:42:45.441]                       else if (inherits(cond, "warning")) {
[17:42:45.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.441]                         if (muffled) 
[17:42:45.441]                           invokeRestart("muffleWarning")
[17:42:45.441]                       }
[17:42:45.441]                       else if (inherits(cond, "condition")) {
[17:42:45.441]                         if (!is.null(pattern)) {
[17:42:45.441]                           computeRestarts <- base::computeRestarts
[17:42:45.441]                           grepl <- base::grepl
[17:42:45.441]                           restarts <- computeRestarts(cond)
[17:42:45.441]                           for (restart in restarts) {
[17:42:45.441]                             name <- restart$name
[17:42:45.441]                             if (is.null(name)) 
[17:42:45.441]                               next
[17:42:45.441]                             if (!grepl(pattern, name)) 
[17:42:45.441]                               next
[17:42:45.441]                             invokeRestart(restart)
[17:42:45.441]                             muffled <- TRUE
[17:42:45.441]                             break
[17:42:45.441]                           }
[17:42:45.441]                         }
[17:42:45.441]                       }
[17:42:45.441]                       invisible(muffled)
[17:42:45.441]                     }
[17:42:45.441]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.441]                   }
[17:42:45.441]                 }
[17:42:45.441]                 else {
[17:42:45.441]                   if (TRUE) {
[17:42:45.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.441]                     {
[17:42:45.441]                       inherits <- base::inherits
[17:42:45.441]                       invokeRestart <- base::invokeRestart
[17:42:45.441]                       is.null <- base::is.null
[17:42:45.441]                       muffled <- FALSE
[17:42:45.441]                       if (inherits(cond, "message")) {
[17:42:45.441]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.441]                         if (muffled) 
[17:42:45.441]                           invokeRestart("muffleMessage")
[17:42:45.441]                       }
[17:42:45.441]                       else if (inherits(cond, "warning")) {
[17:42:45.441]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.441]                         if (muffled) 
[17:42:45.441]                           invokeRestart("muffleWarning")
[17:42:45.441]                       }
[17:42:45.441]                       else if (inherits(cond, "condition")) {
[17:42:45.441]                         if (!is.null(pattern)) {
[17:42:45.441]                           computeRestarts <- base::computeRestarts
[17:42:45.441]                           grepl <- base::grepl
[17:42:45.441]                           restarts <- computeRestarts(cond)
[17:42:45.441]                           for (restart in restarts) {
[17:42:45.441]                             name <- restart$name
[17:42:45.441]                             if (is.null(name)) 
[17:42:45.441]                               next
[17:42:45.441]                             if (!grepl(pattern, name)) 
[17:42:45.441]                               next
[17:42:45.441]                             invokeRestart(restart)
[17:42:45.441]                             muffled <- TRUE
[17:42:45.441]                             break
[17:42:45.441]                           }
[17:42:45.441]                         }
[17:42:45.441]                       }
[17:42:45.441]                       invisible(muffled)
[17:42:45.441]                     }
[17:42:45.441]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.441]                   }
[17:42:45.441]                 }
[17:42:45.441]             }
[17:42:45.441]         }))
[17:42:45.441]     }, error = function(ex) {
[17:42:45.441]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.441]                 ...future.rng), started = ...future.startTime, 
[17:42:45.441]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.441]             version = "1.8"), class = "FutureResult")
[17:42:45.441]     }, finally = {
[17:42:45.441]         if (!identical(...future.workdir, getwd())) 
[17:42:45.441]             setwd(...future.workdir)
[17:42:45.441]         {
[17:42:45.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.441]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.441]             }
[17:42:45.441]             base::options(...future.oldOptions)
[17:42:45.441]             if (.Platform$OS.type == "windows") {
[17:42:45.441]                 old_names <- names(...future.oldEnvVars)
[17:42:45.441]                 envs <- base::Sys.getenv()
[17:42:45.441]                 names <- names(envs)
[17:42:45.441]                 common <- intersect(names, old_names)
[17:42:45.441]                 added <- setdiff(names, old_names)
[17:42:45.441]                 removed <- setdiff(old_names, names)
[17:42:45.441]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.441]                   envs[common]]
[17:42:45.441]                 NAMES <- toupper(changed)
[17:42:45.441]                 args <- list()
[17:42:45.441]                 for (kk in seq_along(NAMES)) {
[17:42:45.441]                   name <- changed[[kk]]
[17:42:45.441]                   NAME <- NAMES[[kk]]
[17:42:45.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.441]                     next
[17:42:45.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.441]                 }
[17:42:45.441]                 NAMES <- toupper(added)
[17:42:45.441]                 for (kk in seq_along(NAMES)) {
[17:42:45.441]                   name <- added[[kk]]
[17:42:45.441]                   NAME <- NAMES[[kk]]
[17:42:45.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.441]                     next
[17:42:45.441]                   args[[name]] <- ""
[17:42:45.441]                 }
[17:42:45.441]                 NAMES <- toupper(removed)
[17:42:45.441]                 for (kk in seq_along(NAMES)) {
[17:42:45.441]                   name <- removed[[kk]]
[17:42:45.441]                   NAME <- NAMES[[kk]]
[17:42:45.441]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.441]                     next
[17:42:45.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.441]                 }
[17:42:45.441]                 if (length(args) > 0) 
[17:42:45.441]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.441]             }
[17:42:45.441]             else {
[17:42:45.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.441]             }
[17:42:45.441]             {
[17:42:45.441]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.441]                   0L) {
[17:42:45.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.441]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.441]                   base::options(opts)
[17:42:45.441]                 }
[17:42:45.441]                 {
[17:42:45.441]                   {
[17:42:45.441]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.441]                     NULL
[17:42:45.441]                   }
[17:42:45.441]                   options(future.plan = NULL)
[17:42:45.441]                   if (is.na(NA_character_)) 
[17:42:45.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.441]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.441]                     envir = parent.frame()) 
[17:42:45.441]                   {
[17:42:45.441]                     default_workers <- missing(workers)
[17:42:45.441]                     if (is.function(workers)) 
[17:42:45.441]                       workers <- workers()
[17:42:45.441]                     workers <- structure(as.integer(workers), 
[17:42:45.441]                       class = class(workers))
[17:42:45.441]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.441]                       1L)
[17:42:45.441]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.441]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.441]                       if (default_workers) 
[17:42:45.441]                         supportsMulticore(warn = TRUE)
[17:42:45.441]                       return(sequential(..., envir = envir))
[17:42:45.441]                     }
[17:42:45.441]                     oopts <- options(mc.cores = workers)
[17:42:45.441]                     on.exit(options(oopts))
[17:42:45.441]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.441]                       envir = envir)
[17:42:45.441]                     if (!future$lazy) 
[17:42:45.441]                       future <- run(future)
[17:42:45.441]                     invisible(future)
[17:42:45.441]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.441]                 }
[17:42:45.441]             }
[17:42:45.441]         }
[17:42:45.441]     })
[17:42:45.441]     if (TRUE) {
[17:42:45.441]         base::sink(type = "output", split = FALSE)
[17:42:45.441]         if (TRUE) {
[17:42:45.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.441]         }
[17:42:45.441]         else {
[17:42:45.441]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.441]         }
[17:42:45.441]         base::close(...future.stdout)
[17:42:45.441]         ...future.stdout <- NULL
[17:42:45.441]     }
[17:42:45.441]     ...future.result$conditions <- ...future.conditions
[17:42:45.441]     ...future.result$finished <- base::Sys.time()
[17:42:45.441]     ...future.result
[17:42:45.441] }
[17:42:45.444] assign_globals() ...
[17:42:45.444] List of 1
[17:42:45.444]  $ a: num 3
[17:42:45.444]  - attr(*, "where")=List of 1
[17:42:45.444]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.444]  - attr(*, "resolved")= logi TRUE
[17:42:45.444]  - attr(*, "total_size")= num 56
[17:42:45.444]  - attr(*, "already-done")= logi TRUE
[17:42:45.448] - copied ‘a’ to environment
[17:42:45.448] assign_globals() ... done
[17:42:45.448] requestCore(): workers = 2
[17:42:45.450] MulticoreFuture started
[17:42:45.451] - Launch lazy future ... done
[17:42:45.451] run() for ‘MulticoreFuture’ ... done
[17:42:45.452] plan(): Setting new future strategy stack:
[17:42:45.452] List of future strategies:
[17:42:45.452] 1. sequential:
[17:42:45.452]    - args: function (..., envir = parent.frame())
[17:42:45.452]    - tweaked: FALSE
[17:42:45.452]    - call: NULL
[17:42:45.453] plan(): nbrOfWorkers() = 1
[17:42:45.457] plan(): Setting new future strategy stack:
[17:42:45.457] List of future strategies:
[17:42:45.457] 1. multicore:
[17:42:45.457]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.457]    - tweaked: FALSE
[17:42:45.457]    - call: plan(strategy)
[17:42:45.463] plan(): nbrOfWorkers() = 2
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.466] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.466] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.469] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.469] Searching for globals ... DONE
[17:42:45.469] Resolving globals: TRUE
[17:42:45.469] Resolving any globals that are futures ...
[17:42:45.469] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.470] Resolving any globals that are futures ... DONE
[17:42:45.470] Resolving futures part of globals (recursively) ...
[17:42:45.470] resolve() on list ...
[17:42:45.471]  recursive: 99
[17:42:45.471]  length: 2
[17:42:45.471]  elements: ‘a’, ‘ii’
[17:42:45.471]  length: 1 (resolved future 1)
[17:42:45.471]  length: 0 (resolved future 2)
[17:42:45.471] resolve() on list ... DONE
[17:42:45.471] - globals: [2] ‘a’, ‘ii’
[17:42:45.472] Resolving futures part of globals (recursively) ... DONE
[17:42:45.472] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:45.472] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.472] - globals: [2] ‘a’, ‘ii’
[17:42:45.473] 
[17:42:45.473] getGlobalsAndPackages() ... DONE
[17:42:45.473] run() for ‘Future’ ...
[17:42:45.473] - state: ‘created’
[17:42:45.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.478]   - Field: ‘label’
[17:42:45.478]   - Field: ‘local’
[17:42:45.478]   - Field: ‘owner’
[17:42:45.478]   - Field: ‘envir’
[17:42:45.478]   - Field: ‘workers’
[17:42:45.478]   - Field: ‘packages’
[17:42:45.478]   - Field: ‘gc’
[17:42:45.478]   - Field: ‘job’
[17:42:45.479]   - Field: ‘conditions’
[17:42:45.479]   - Field: ‘expr’
[17:42:45.479]   - Field: ‘uuid’
[17:42:45.479]   - Field: ‘seed’
[17:42:45.479]   - Field: ‘version’
[17:42:45.479]   - Field: ‘result’
[17:42:45.479]   - Field: ‘asynchronous’
[17:42:45.479]   - Field: ‘calls’
[17:42:45.480]   - Field: ‘globals’
[17:42:45.480]   - Field: ‘stdout’
[17:42:45.480]   - Field: ‘earlySignal’
[17:42:45.480]   - Field: ‘lazy’
[17:42:45.480]   - Field: ‘state’
[17:42:45.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.480] - Launch lazy future ...
[17:42:45.481] Packages needed by the future expression (n = 0): <none>
[17:42:45.481] Packages needed by future strategies (n = 0): <none>
[17:42:45.481] {
[17:42:45.481]     {
[17:42:45.481]         {
[17:42:45.481]             ...future.startTime <- base::Sys.time()
[17:42:45.481]             {
[17:42:45.481]                 {
[17:42:45.481]                   {
[17:42:45.481]                     {
[17:42:45.481]                       base::local({
[17:42:45.481]                         has_future <- base::requireNamespace("future", 
[17:42:45.481]                           quietly = TRUE)
[17:42:45.481]                         if (has_future) {
[17:42:45.481]                           ns <- base::getNamespace("future")
[17:42:45.481]                           version <- ns[[".package"]][["version"]]
[17:42:45.481]                           if (is.null(version)) 
[17:42:45.481]                             version <- utils::packageVersion("future")
[17:42:45.481]                         }
[17:42:45.481]                         else {
[17:42:45.481]                           version <- NULL
[17:42:45.481]                         }
[17:42:45.481]                         if (!has_future || version < "1.8.0") {
[17:42:45.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.481]                             "", base::R.version$version.string), 
[17:42:45.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.481]                               "release", "version")], collapse = " "), 
[17:42:45.481]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.481]                             info)
[17:42:45.481]                           info <- base::paste(info, collapse = "; ")
[17:42:45.481]                           if (!has_future) {
[17:42:45.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.481]                               info)
[17:42:45.481]                           }
[17:42:45.481]                           else {
[17:42:45.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.481]                               info, version)
[17:42:45.481]                           }
[17:42:45.481]                           base::stop(msg)
[17:42:45.481]                         }
[17:42:45.481]                       })
[17:42:45.481]                     }
[17:42:45.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.481]                     base::options(mc.cores = 1L)
[17:42:45.481]                   }
[17:42:45.481]                   options(future.plan = NULL)
[17:42:45.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.481]                 }
[17:42:45.481]                 ...future.workdir <- getwd()
[17:42:45.481]             }
[17:42:45.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.481]         }
[17:42:45.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.481]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.481]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.481]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.481]             base::names(...future.oldOptions))
[17:42:45.481]     }
[17:42:45.481]     if (FALSE) {
[17:42:45.481]     }
[17:42:45.481]     else {
[17:42:45.481]         if (TRUE) {
[17:42:45.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.481]                 open = "w")
[17:42:45.481]         }
[17:42:45.481]         else {
[17:42:45.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.481]         }
[17:42:45.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.481]             base::sink(type = "output", split = FALSE)
[17:42:45.481]             base::close(...future.stdout)
[17:42:45.481]         }, add = TRUE)
[17:42:45.481]     }
[17:42:45.481]     ...future.frame <- base::sys.nframe()
[17:42:45.481]     ...future.conditions <- base::list()
[17:42:45.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.481]     if (FALSE) {
[17:42:45.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.481]     }
[17:42:45.481]     ...future.result <- base::tryCatch({
[17:42:45.481]         base::withCallingHandlers({
[17:42:45.481]             ...future.value <- base::withVisible(base::local({
[17:42:45.481]                 withCallingHandlers({
[17:42:45.481]                   {
[17:42:45.481]                     b <- a * ii
[17:42:45.481]                     a <- 0
[17:42:45.481]                     b
[17:42:45.481]                   }
[17:42:45.481]                 }, immediateCondition = function(cond) {
[17:42:45.481]                   save_rds <- function (object, pathname, ...) 
[17:42:45.481]                   {
[17:42:45.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.481]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.481]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.481]                         fi_tmp[["mtime"]])
[17:42:45.481]                     }
[17:42:45.481]                     tryCatch({
[17:42:45.481]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.481]                     }, error = function(ex) {
[17:42:45.481]                       msg <- conditionMessage(ex)
[17:42:45.481]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.481]                         fi_tmp[["mtime"]], msg)
[17:42:45.481]                       ex$message <- msg
[17:42:45.481]                       stop(ex)
[17:42:45.481]                     })
[17:42:45.481]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.481]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.481]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.481]                       fi <- file.info(pathname)
[17:42:45.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.481]                         fi[["size"]], fi[["mtime"]])
[17:42:45.481]                       stop(msg)
[17:42:45.481]                     }
[17:42:45.481]                     invisible(pathname)
[17:42:45.481]                   }
[17:42:45.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.481]                     rootPath = tempdir()) 
[17:42:45.481]                   {
[17:42:45.481]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.481]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.481]                       tmpdir = path, fileext = ".rds")
[17:42:45.481]                     save_rds(obj, file)
[17:42:45.481]                   }
[17:42:45.481]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.481]                   {
[17:42:45.481]                     inherits <- base::inherits
[17:42:45.481]                     invokeRestart <- base::invokeRestart
[17:42:45.481]                     is.null <- base::is.null
[17:42:45.481]                     muffled <- FALSE
[17:42:45.481]                     if (inherits(cond, "message")) {
[17:42:45.481]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.481]                       if (muffled) 
[17:42:45.481]                         invokeRestart("muffleMessage")
[17:42:45.481]                     }
[17:42:45.481]                     else if (inherits(cond, "warning")) {
[17:42:45.481]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.481]                       if (muffled) 
[17:42:45.481]                         invokeRestart("muffleWarning")
[17:42:45.481]                     }
[17:42:45.481]                     else if (inherits(cond, "condition")) {
[17:42:45.481]                       if (!is.null(pattern)) {
[17:42:45.481]                         computeRestarts <- base::computeRestarts
[17:42:45.481]                         grepl <- base::grepl
[17:42:45.481]                         restarts <- computeRestarts(cond)
[17:42:45.481]                         for (restart in restarts) {
[17:42:45.481]                           name <- restart$name
[17:42:45.481]                           if (is.null(name)) 
[17:42:45.481]                             next
[17:42:45.481]                           if (!grepl(pattern, name)) 
[17:42:45.481]                             next
[17:42:45.481]                           invokeRestart(restart)
[17:42:45.481]                           muffled <- TRUE
[17:42:45.481]                           break
[17:42:45.481]                         }
[17:42:45.481]                       }
[17:42:45.481]                     }
[17:42:45.481]                     invisible(muffled)
[17:42:45.481]                   }
[17:42:45.481]                   muffleCondition(cond)
[17:42:45.481]                 })
[17:42:45.481]             }))
[17:42:45.481]             future::FutureResult(value = ...future.value$value, 
[17:42:45.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.481]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.481]                     ...future.globalenv.names))
[17:42:45.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.481]         }, condition = base::local({
[17:42:45.481]             c <- base::c
[17:42:45.481]             inherits <- base::inherits
[17:42:45.481]             invokeRestart <- base::invokeRestart
[17:42:45.481]             length <- base::length
[17:42:45.481]             list <- base::list
[17:42:45.481]             seq.int <- base::seq.int
[17:42:45.481]             signalCondition <- base::signalCondition
[17:42:45.481]             sys.calls <- base::sys.calls
[17:42:45.481]             `[[` <- base::`[[`
[17:42:45.481]             `+` <- base::`+`
[17:42:45.481]             `<<-` <- base::`<<-`
[17:42:45.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.481]                   3L)]
[17:42:45.481]             }
[17:42:45.481]             function(cond) {
[17:42:45.481]                 is_error <- inherits(cond, "error")
[17:42:45.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.481]                   NULL)
[17:42:45.481]                 if (is_error) {
[17:42:45.481]                   sessionInformation <- function() {
[17:42:45.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.481]                       search = base::search(), system = base::Sys.info())
[17:42:45.481]                   }
[17:42:45.481]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.481]                     cond$call), session = sessionInformation(), 
[17:42:45.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.481]                   signalCondition(cond)
[17:42:45.481]                 }
[17:42:45.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.481]                 "immediateCondition"))) {
[17:42:45.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.481]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.481]                   if (TRUE && !signal) {
[17:42:45.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.481]                     {
[17:42:45.481]                       inherits <- base::inherits
[17:42:45.481]                       invokeRestart <- base::invokeRestart
[17:42:45.481]                       is.null <- base::is.null
[17:42:45.481]                       muffled <- FALSE
[17:42:45.481]                       if (inherits(cond, "message")) {
[17:42:45.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.481]                         if (muffled) 
[17:42:45.481]                           invokeRestart("muffleMessage")
[17:42:45.481]                       }
[17:42:45.481]                       else if (inherits(cond, "warning")) {
[17:42:45.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.481]                         if (muffled) 
[17:42:45.481]                           invokeRestart("muffleWarning")
[17:42:45.481]                       }
[17:42:45.481]                       else if (inherits(cond, "condition")) {
[17:42:45.481]                         if (!is.null(pattern)) {
[17:42:45.481]                           computeRestarts <- base::computeRestarts
[17:42:45.481]                           grepl <- base::grepl
[17:42:45.481]                           restarts <- computeRestarts(cond)
[17:42:45.481]                           for (restart in restarts) {
[17:42:45.481]                             name <- restart$name
[17:42:45.481]                             if (is.null(name)) 
[17:42:45.481]                               next
[17:42:45.481]                             if (!grepl(pattern, name)) 
[17:42:45.481]                               next
[17:42:45.481]                             invokeRestart(restart)
[17:42:45.481]                             muffled <- TRUE
[17:42:45.481]                             break
[17:42:45.481]                           }
[17:42:45.481]                         }
[17:42:45.481]                       }
[17:42:45.481]                       invisible(muffled)
[17:42:45.481]                     }
[17:42:45.481]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.481]                   }
[17:42:45.481]                 }
[17:42:45.481]                 else {
[17:42:45.481]                   if (TRUE) {
[17:42:45.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.481]                     {
[17:42:45.481]                       inherits <- base::inherits
[17:42:45.481]                       invokeRestart <- base::invokeRestart
[17:42:45.481]                       is.null <- base::is.null
[17:42:45.481]                       muffled <- FALSE
[17:42:45.481]                       if (inherits(cond, "message")) {
[17:42:45.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.481]                         if (muffled) 
[17:42:45.481]                           invokeRestart("muffleMessage")
[17:42:45.481]                       }
[17:42:45.481]                       else if (inherits(cond, "warning")) {
[17:42:45.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.481]                         if (muffled) 
[17:42:45.481]                           invokeRestart("muffleWarning")
[17:42:45.481]                       }
[17:42:45.481]                       else if (inherits(cond, "condition")) {
[17:42:45.481]                         if (!is.null(pattern)) {
[17:42:45.481]                           computeRestarts <- base::computeRestarts
[17:42:45.481]                           grepl <- base::grepl
[17:42:45.481]                           restarts <- computeRestarts(cond)
[17:42:45.481]                           for (restart in restarts) {
[17:42:45.481]                             name <- restart$name
[17:42:45.481]                             if (is.null(name)) 
[17:42:45.481]                               next
[17:42:45.481]                             if (!grepl(pattern, name)) 
[17:42:45.481]                               next
[17:42:45.481]                             invokeRestart(restart)
[17:42:45.481]                             muffled <- TRUE
[17:42:45.481]                             break
[17:42:45.481]                           }
[17:42:45.481]                         }
[17:42:45.481]                       }
[17:42:45.481]                       invisible(muffled)
[17:42:45.481]                     }
[17:42:45.481]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.481]                   }
[17:42:45.481]                 }
[17:42:45.481]             }
[17:42:45.481]         }))
[17:42:45.481]     }, error = function(ex) {
[17:42:45.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.481]                 ...future.rng), started = ...future.startTime, 
[17:42:45.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.481]             version = "1.8"), class = "FutureResult")
[17:42:45.481]     }, finally = {
[17:42:45.481]         if (!identical(...future.workdir, getwd())) 
[17:42:45.481]             setwd(...future.workdir)
[17:42:45.481]         {
[17:42:45.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.481]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.481]             }
[17:42:45.481]             base::options(...future.oldOptions)
[17:42:45.481]             if (.Platform$OS.type == "windows") {
[17:42:45.481]                 old_names <- names(...future.oldEnvVars)
[17:42:45.481]                 envs <- base::Sys.getenv()
[17:42:45.481]                 names <- names(envs)
[17:42:45.481]                 common <- intersect(names, old_names)
[17:42:45.481]                 added <- setdiff(names, old_names)
[17:42:45.481]                 removed <- setdiff(old_names, names)
[17:42:45.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.481]                   envs[common]]
[17:42:45.481]                 NAMES <- toupper(changed)
[17:42:45.481]                 args <- list()
[17:42:45.481]                 for (kk in seq_along(NAMES)) {
[17:42:45.481]                   name <- changed[[kk]]
[17:42:45.481]                   NAME <- NAMES[[kk]]
[17:42:45.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.481]                     next
[17:42:45.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.481]                 }
[17:42:45.481]                 NAMES <- toupper(added)
[17:42:45.481]                 for (kk in seq_along(NAMES)) {
[17:42:45.481]                   name <- added[[kk]]
[17:42:45.481]                   NAME <- NAMES[[kk]]
[17:42:45.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.481]                     next
[17:42:45.481]                   args[[name]] <- ""
[17:42:45.481]                 }
[17:42:45.481]                 NAMES <- toupper(removed)
[17:42:45.481]                 for (kk in seq_along(NAMES)) {
[17:42:45.481]                   name <- removed[[kk]]
[17:42:45.481]                   NAME <- NAMES[[kk]]
[17:42:45.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.481]                     next
[17:42:45.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.481]                 }
[17:42:45.481]                 if (length(args) > 0) 
[17:42:45.481]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.481]             }
[17:42:45.481]             else {
[17:42:45.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.481]             }
[17:42:45.481]             {
[17:42:45.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.481]                   0L) {
[17:42:45.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.481]                   base::options(opts)
[17:42:45.481]                 }
[17:42:45.481]                 {
[17:42:45.481]                   {
[17:42:45.481]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.481]                     NULL
[17:42:45.481]                   }
[17:42:45.481]                   options(future.plan = NULL)
[17:42:45.481]                   if (is.na(NA_character_)) 
[17:42:45.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.481]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.481]                     envir = parent.frame()) 
[17:42:45.481]                   {
[17:42:45.481]                     default_workers <- missing(workers)
[17:42:45.481]                     if (is.function(workers)) 
[17:42:45.481]                       workers <- workers()
[17:42:45.481]                     workers <- structure(as.integer(workers), 
[17:42:45.481]                       class = class(workers))
[17:42:45.481]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.481]                       1L)
[17:42:45.481]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.481]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.481]                       if (default_workers) 
[17:42:45.481]                         supportsMulticore(warn = TRUE)
[17:42:45.481]                       return(sequential(..., envir = envir))
[17:42:45.481]                     }
[17:42:45.481]                     oopts <- options(mc.cores = workers)
[17:42:45.481]                     on.exit(options(oopts))
[17:42:45.481]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.481]                       envir = envir)
[17:42:45.481]                     if (!future$lazy) 
[17:42:45.481]                       future <- run(future)
[17:42:45.481]                     invisible(future)
[17:42:45.481]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.481]                 }
[17:42:45.481]             }
[17:42:45.481]         }
[17:42:45.481]     })
[17:42:45.481]     if (TRUE) {
[17:42:45.481]         base::sink(type = "output", split = FALSE)
[17:42:45.481]         if (TRUE) {
[17:42:45.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.481]         }
[17:42:45.481]         else {
[17:42:45.481]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.481]         }
[17:42:45.481]         base::close(...future.stdout)
[17:42:45.481]         ...future.stdout <- NULL
[17:42:45.481]     }
[17:42:45.481]     ...future.result$conditions <- ...future.conditions
[17:42:45.481]     ...future.result$finished <- base::Sys.time()
[17:42:45.481]     ...future.result
[17:42:45.481] }
[17:42:45.484] assign_globals() ...
[17:42:45.484] List of 2
[17:42:45.484]  $ a : num 1
[17:42:45.484]  $ ii: int 1
[17:42:45.484]  - attr(*, "where")=List of 2
[17:42:45.484]   ..$ a :<environment: R_EmptyEnv> 
[17:42:45.484]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.484]  - attr(*, "resolved")= logi TRUE
[17:42:45.484]  - attr(*, "total_size")= num 112
[17:42:45.484]  - attr(*, "already-done")= logi TRUE
[17:42:45.488] - copied ‘a’ to environment
[17:42:45.488] - copied ‘ii’ to environment
[17:42:45.488] assign_globals() ... done
[17:42:45.488] requestCore(): workers = 2
[17:42:45.491] MulticoreFuture started
[17:42:45.497] - Launch lazy future ... done
[17:42:45.497] plan(): Setting new future strategy stack:
[17:42:45.497] run() for ‘MulticoreFuture’ ... done
[17:42:45.497] List of future strategies:
[17:42:45.497] 1. sequential:
[17:42:45.497]    - args: function (..., envir = parent.frame())
[17:42:45.497]    - tweaked: FALSE
[17:42:45.497]    - call: NULL
[17:42:45.499] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.499] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.500] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.501] plan(): Setting new future strategy stack:
[17:42:45.501] List of future strategies:
[17:42:45.501] 1. multicore:
[17:42:45.501]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.501]    - tweaked: FALSE
[17:42:45.501]    - call: plan(strategy)
[17:42:45.506] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.506] plan(): nbrOfWorkers() = 2
[17:42:45.506] Searching for globals ... DONE
[17:42:45.507] Resolving globals: TRUE
[17:42:45.507] Resolving any globals that are futures ...
[17:42:45.507] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.507] Resolving any globals that are futures ... DONE
[17:42:45.508] Resolving futures part of globals (recursively) ...
[17:42:45.509] resolve() on list ...
[17:42:45.509]  recursive: 99
[17:42:45.509]  length: 2
[17:42:45.509]  elements: ‘a’, ‘ii’
[17:42:45.510]  length: 1 (resolved future 1)
[17:42:45.510]  length: 0 (resolved future 2)
[17:42:45.510] resolve() on list ... DONE
[17:42:45.510] - globals: [2] ‘a’, ‘ii’
[17:42:45.510] Resolving futures part of globals (recursively) ... DONE
[17:42:45.511] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:45.511] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.511] - globals: [2] ‘a’, ‘ii’
[17:42:45.512] 
[17:42:45.512] getGlobalsAndPackages() ... DONE
[17:42:45.512] run() for ‘Future’ ...
[17:42:45.512] - state: ‘created’
[17:42:45.513] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.517]   - Field: ‘label’
[17:42:45.517]   - Field: ‘local’
[17:42:45.518]   - Field: ‘owner’
[17:42:45.518]   - Field: ‘envir’
[17:42:45.518]   - Field: ‘workers’
[17:42:45.518]   - Field: ‘packages’
[17:42:45.518]   - Field: ‘gc’
[17:42:45.518]   - Field: ‘job’
[17:42:45.518]   - Field: ‘conditions’
[17:42:45.518]   - Field: ‘expr’
[17:42:45.519]   - Field: ‘uuid’
[17:42:45.519]   - Field: ‘seed’
[17:42:45.519]   - Field: ‘version’
[17:42:45.519]   - Field: ‘result’
[17:42:45.519]   - Field: ‘asynchronous’
[17:42:45.519]   - Field: ‘calls’
[17:42:45.519]   - Field: ‘globals’
[17:42:45.519]   - Field: ‘stdout’
[17:42:45.520]   - Field: ‘earlySignal’
[17:42:45.520]   - Field: ‘lazy’
[17:42:45.520]   - Field: ‘state’
[17:42:45.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.520] - Launch lazy future ...
[17:42:45.521] Packages needed by the future expression (n = 0): <none>
[17:42:45.521] Packages needed by future strategies (n = 0): <none>
[17:42:45.521] {
[17:42:45.521]     {
[17:42:45.521]         {
[17:42:45.521]             ...future.startTime <- base::Sys.time()
[17:42:45.521]             {
[17:42:45.521]                 {
[17:42:45.521]                   {
[17:42:45.521]                     {
[17:42:45.521]                       base::local({
[17:42:45.521]                         has_future <- base::requireNamespace("future", 
[17:42:45.521]                           quietly = TRUE)
[17:42:45.521]                         if (has_future) {
[17:42:45.521]                           ns <- base::getNamespace("future")
[17:42:45.521]                           version <- ns[[".package"]][["version"]]
[17:42:45.521]                           if (is.null(version)) 
[17:42:45.521]                             version <- utils::packageVersion("future")
[17:42:45.521]                         }
[17:42:45.521]                         else {
[17:42:45.521]                           version <- NULL
[17:42:45.521]                         }
[17:42:45.521]                         if (!has_future || version < "1.8.0") {
[17:42:45.521]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.521]                             "", base::R.version$version.string), 
[17:42:45.521]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.521]                               "release", "version")], collapse = " "), 
[17:42:45.521]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.521]                             info)
[17:42:45.521]                           info <- base::paste(info, collapse = "; ")
[17:42:45.521]                           if (!has_future) {
[17:42:45.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.521]                               info)
[17:42:45.521]                           }
[17:42:45.521]                           else {
[17:42:45.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.521]                               info, version)
[17:42:45.521]                           }
[17:42:45.521]                           base::stop(msg)
[17:42:45.521]                         }
[17:42:45.521]                       })
[17:42:45.521]                     }
[17:42:45.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.521]                     base::options(mc.cores = 1L)
[17:42:45.521]                   }
[17:42:45.521]                   options(future.plan = NULL)
[17:42:45.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.521]                 }
[17:42:45.521]                 ...future.workdir <- getwd()
[17:42:45.521]             }
[17:42:45.521]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.521]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.521]         }
[17:42:45.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.521]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.521]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.521]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.521]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.521]             base::names(...future.oldOptions))
[17:42:45.521]     }
[17:42:45.521]     if (FALSE) {
[17:42:45.521]     }
[17:42:45.521]     else {
[17:42:45.521]         if (TRUE) {
[17:42:45.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.521]                 open = "w")
[17:42:45.521]         }
[17:42:45.521]         else {
[17:42:45.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.521]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.521]         }
[17:42:45.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.521]             base::sink(type = "output", split = FALSE)
[17:42:45.521]             base::close(...future.stdout)
[17:42:45.521]         }, add = TRUE)
[17:42:45.521]     }
[17:42:45.521]     ...future.frame <- base::sys.nframe()
[17:42:45.521]     ...future.conditions <- base::list()
[17:42:45.521]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.521]     if (FALSE) {
[17:42:45.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.521]     }
[17:42:45.521]     ...future.result <- base::tryCatch({
[17:42:45.521]         base::withCallingHandlers({
[17:42:45.521]             ...future.value <- base::withVisible(base::local({
[17:42:45.521]                 withCallingHandlers({
[17:42:45.521]                   {
[17:42:45.521]                     b <- a * ii
[17:42:45.521]                     a <- 0
[17:42:45.521]                     b
[17:42:45.521]                   }
[17:42:45.521]                 }, immediateCondition = function(cond) {
[17:42:45.521]                   save_rds <- function (object, pathname, ...) 
[17:42:45.521]                   {
[17:42:45.521]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.521]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.521]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.521]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.521]                         fi_tmp[["mtime"]])
[17:42:45.521]                     }
[17:42:45.521]                     tryCatch({
[17:42:45.521]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.521]                     }, error = function(ex) {
[17:42:45.521]                       msg <- conditionMessage(ex)
[17:42:45.521]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.521]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.521]                         fi_tmp[["mtime"]], msg)
[17:42:45.521]                       ex$message <- msg
[17:42:45.521]                       stop(ex)
[17:42:45.521]                     })
[17:42:45.521]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.521]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.521]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.521]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.521]                       fi <- file.info(pathname)
[17:42:45.521]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.521]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.521]                         fi[["size"]], fi[["mtime"]])
[17:42:45.521]                       stop(msg)
[17:42:45.521]                     }
[17:42:45.521]                     invisible(pathname)
[17:42:45.521]                   }
[17:42:45.521]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.521]                     rootPath = tempdir()) 
[17:42:45.521]                   {
[17:42:45.521]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.521]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.521]                       tmpdir = path, fileext = ".rds")
[17:42:45.521]                     save_rds(obj, file)
[17:42:45.521]                   }
[17:42:45.521]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.521]                   {
[17:42:45.521]                     inherits <- base::inherits
[17:42:45.521]                     invokeRestart <- base::invokeRestart
[17:42:45.521]                     is.null <- base::is.null
[17:42:45.521]                     muffled <- FALSE
[17:42:45.521]                     if (inherits(cond, "message")) {
[17:42:45.521]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.521]                       if (muffled) 
[17:42:45.521]                         invokeRestart("muffleMessage")
[17:42:45.521]                     }
[17:42:45.521]                     else if (inherits(cond, "warning")) {
[17:42:45.521]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.521]                       if (muffled) 
[17:42:45.521]                         invokeRestart("muffleWarning")
[17:42:45.521]                     }
[17:42:45.521]                     else if (inherits(cond, "condition")) {
[17:42:45.521]                       if (!is.null(pattern)) {
[17:42:45.521]                         computeRestarts <- base::computeRestarts
[17:42:45.521]                         grepl <- base::grepl
[17:42:45.521]                         restarts <- computeRestarts(cond)
[17:42:45.521]                         for (restart in restarts) {
[17:42:45.521]                           name <- restart$name
[17:42:45.521]                           if (is.null(name)) 
[17:42:45.521]                             next
[17:42:45.521]                           if (!grepl(pattern, name)) 
[17:42:45.521]                             next
[17:42:45.521]                           invokeRestart(restart)
[17:42:45.521]                           muffled <- TRUE
[17:42:45.521]                           break
[17:42:45.521]                         }
[17:42:45.521]                       }
[17:42:45.521]                     }
[17:42:45.521]                     invisible(muffled)
[17:42:45.521]                   }
[17:42:45.521]                   muffleCondition(cond)
[17:42:45.521]                 })
[17:42:45.521]             }))
[17:42:45.521]             future::FutureResult(value = ...future.value$value, 
[17:42:45.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.521]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.521]                     ...future.globalenv.names))
[17:42:45.521]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.521]         }, condition = base::local({
[17:42:45.521]             c <- base::c
[17:42:45.521]             inherits <- base::inherits
[17:42:45.521]             invokeRestart <- base::invokeRestart
[17:42:45.521]             length <- base::length
[17:42:45.521]             list <- base::list
[17:42:45.521]             seq.int <- base::seq.int
[17:42:45.521]             signalCondition <- base::signalCondition
[17:42:45.521]             sys.calls <- base::sys.calls
[17:42:45.521]             `[[` <- base::`[[`
[17:42:45.521]             `+` <- base::`+`
[17:42:45.521]             `<<-` <- base::`<<-`
[17:42:45.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.521]                   3L)]
[17:42:45.521]             }
[17:42:45.521]             function(cond) {
[17:42:45.521]                 is_error <- inherits(cond, "error")
[17:42:45.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.521]                   NULL)
[17:42:45.521]                 if (is_error) {
[17:42:45.521]                   sessionInformation <- function() {
[17:42:45.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.521]                       search = base::search(), system = base::Sys.info())
[17:42:45.521]                   }
[17:42:45.521]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.521]                     cond$call), session = sessionInformation(), 
[17:42:45.521]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.521]                   signalCondition(cond)
[17:42:45.521]                 }
[17:42:45.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.521]                 "immediateCondition"))) {
[17:42:45.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.521]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.521]                   if (TRUE && !signal) {
[17:42:45.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.521]                     {
[17:42:45.521]                       inherits <- base::inherits
[17:42:45.521]                       invokeRestart <- base::invokeRestart
[17:42:45.521]                       is.null <- base::is.null
[17:42:45.521]                       muffled <- FALSE
[17:42:45.521]                       if (inherits(cond, "message")) {
[17:42:45.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.521]                         if (muffled) 
[17:42:45.521]                           invokeRestart("muffleMessage")
[17:42:45.521]                       }
[17:42:45.521]                       else if (inherits(cond, "warning")) {
[17:42:45.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.521]                         if (muffled) 
[17:42:45.521]                           invokeRestart("muffleWarning")
[17:42:45.521]                       }
[17:42:45.521]                       else if (inherits(cond, "condition")) {
[17:42:45.521]                         if (!is.null(pattern)) {
[17:42:45.521]                           computeRestarts <- base::computeRestarts
[17:42:45.521]                           grepl <- base::grepl
[17:42:45.521]                           restarts <- computeRestarts(cond)
[17:42:45.521]                           for (restart in restarts) {
[17:42:45.521]                             name <- restart$name
[17:42:45.521]                             if (is.null(name)) 
[17:42:45.521]                               next
[17:42:45.521]                             if (!grepl(pattern, name)) 
[17:42:45.521]                               next
[17:42:45.521]                             invokeRestart(restart)
[17:42:45.521]                             muffled <- TRUE
[17:42:45.521]                             break
[17:42:45.521]                           }
[17:42:45.521]                         }
[17:42:45.521]                       }
[17:42:45.521]                       invisible(muffled)
[17:42:45.521]                     }
[17:42:45.521]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.521]                   }
[17:42:45.521]                 }
[17:42:45.521]                 else {
[17:42:45.521]                   if (TRUE) {
[17:42:45.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.521]                     {
[17:42:45.521]                       inherits <- base::inherits
[17:42:45.521]                       invokeRestart <- base::invokeRestart
[17:42:45.521]                       is.null <- base::is.null
[17:42:45.521]                       muffled <- FALSE
[17:42:45.521]                       if (inherits(cond, "message")) {
[17:42:45.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.521]                         if (muffled) 
[17:42:45.521]                           invokeRestart("muffleMessage")
[17:42:45.521]                       }
[17:42:45.521]                       else if (inherits(cond, "warning")) {
[17:42:45.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.521]                         if (muffled) 
[17:42:45.521]                           invokeRestart("muffleWarning")
[17:42:45.521]                       }
[17:42:45.521]                       else if (inherits(cond, "condition")) {
[17:42:45.521]                         if (!is.null(pattern)) {
[17:42:45.521]                           computeRestarts <- base::computeRestarts
[17:42:45.521]                           grepl <- base::grepl
[17:42:45.521]                           restarts <- computeRestarts(cond)
[17:42:45.521]                           for (restart in restarts) {
[17:42:45.521]                             name <- restart$name
[17:42:45.521]                             if (is.null(name)) 
[17:42:45.521]                               next
[17:42:45.521]                             if (!grepl(pattern, name)) 
[17:42:45.521]                               next
[17:42:45.521]                             invokeRestart(restart)
[17:42:45.521]                             muffled <- TRUE
[17:42:45.521]                             break
[17:42:45.521]                           }
[17:42:45.521]                         }
[17:42:45.521]                       }
[17:42:45.521]                       invisible(muffled)
[17:42:45.521]                     }
[17:42:45.521]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.521]                   }
[17:42:45.521]                 }
[17:42:45.521]             }
[17:42:45.521]         }))
[17:42:45.521]     }, error = function(ex) {
[17:42:45.521]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.521]                 ...future.rng), started = ...future.startTime, 
[17:42:45.521]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.521]             version = "1.8"), class = "FutureResult")
[17:42:45.521]     }, finally = {
[17:42:45.521]         if (!identical(...future.workdir, getwd())) 
[17:42:45.521]             setwd(...future.workdir)
[17:42:45.521]         {
[17:42:45.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.521]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.521]             }
[17:42:45.521]             base::options(...future.oldOptions)
[17:42:45.521]             if (.Platform$OS.type == "windows") {
[17:42:45.521]                 old_names <- names(...future.oldEnvVars)
[17:42:45.521]                 envs <- base::Sys.getenv()
[17:42:45.521]                 names <- names(envs)
[17:42:45.521]                 common <- intersect(names, old_names)
[17:42:45.521]                 added <- setdiff(names, old_names)
[17:42:45.521]                 removed <- setdiff(old_names, names)
[17:42:45.521]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.521]                   envs[common]]
[17:42:45.521]                 NAMES <- toupper(changed)
[17:42:45.521]                 args <- list()
[17:42:45.521]                 for (kk in seq_along(NAMES)) {
[17:42:45.521]                   name <- changed[[kk]]
[17:42:45.521]                   NAME <- NAMES[[kk]]
[17:42:45.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.521]                     next
[17:42:45.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.521]                 }
[17:42:45.521]                 NAMES <- toupper(added)
[17:42:45.521]                 for (kk in seq_along(NAMES)) {
[17:42:45.521]                   name <- added[[kk]]
[17:42:45.521]                   NAME <- NAMES[[kk]]
[17:42:45.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.521]                     next
[17:42:45.521]                   args[[name]] <- ""
[17:42:45.521]                 }
[17:42:45.521]                 NAMES <- toupper(removed)
[17:42:45.521]                 for (kk in seq_along(NAMES)) {
[17:42:45.521]                   name <- removed[[kk]]
[17:42:45.521]                   NAME <- NAMES[[kk]]
[17:42:45.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.521]                     next
[17:42:45.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.521]                 }
[17:42:45.521]                 if (length(args) > 0) 
[17:42:45.521]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.521]             }
[17:42:45.521]             else {
[17:42:45.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.521]             }
[17:42:45.521]             {
[17:42:45.521]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.521]                   0L) {
[17:42:45.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.521]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.521]                   base::options(opts)
[17:42:45.521]                 }
[17:42:45.521]                 {
[17:42:45.521]                   {
[17:42:45.521]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.521]                     NULL
[17:42:45.521]                   }
[17:42:45.521]                   options(future.plan = NULL)
[17:42:45.521]                   if (is.na(NA_character_)) 
[17:42:45.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.521]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.521]                     envir = parent.frame()) 
[17:42:45.521]                   {
[17:42:45.521]                     default_workers <- missing(workers)
[17:42:45.521]                     if (is.function(workers)) 
[17:42:45.521]                       workers <- workers()
[17:42:45.521]                     workers <- structure(as.integer(workers), 
[17:42:45.521]                       class = class(workers))
[17:42:45.521]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.521]                       1L)
[17:42:45.521]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.521]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.521]                       if (default_workers) 
[17:42:45.521]                         supportsMulticore(warn = TRUE)
[17:42:45.521]                       return(sequential(..., envir = envir))
[17:42:45.521]                     }
[17:42:45.521]                     oopts <- options(mc.cores = workers)
[17:42:45.521]                     on.exit(options(oopts))
[17:42:45.521]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.521]                       envir = envir)
[17:42:45.521]                     if (!future$lazy) 
[17:42:45.521]                       future <- run(future)
[17:42:45.521]                     invisible(future)
[17:42:45.521]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.521]                 }
[17:42:45.521]             }
[17:42:45.521]         }
[17:42:45.521]     })
[17:42:45.521]     if (TRUE) {
[17:42:45.521]         base::sink(type = "output", split = FALSE)
[17:42:45.521]         if (TRUE) {
[17:42:45.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.521]         }
[17:42:45.521]         else {
[17:42:45.521]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.521]         }
[17:42:45.521]         base::close(...future.stdout)
[17:42:45.521]         ...future.stdout <- NULL
[17:42:45.521]     }
[17:42:45.521]     ...future.result$conditions <- ...future.conditions
[17:42:45.521]     ...future.result$finished <- base::Sys.time()
[17:42:45.521]     ...future.result
[17:42:45.521] }
[17:42:45.524] assign_globals() ...
[17:42:45.524] List of 2
[17:42:45.524]  $ a : num 1
[17:42:45.524]  $ ii: int 2
[17:42:45.524]  - attr(*, "where")=List of 2
[17:42:45.524]   ..$ a :<environment: R_EmptyEnv> 
[17:42:45.524]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.524]  - attr(*, "resolved")= logi TRUE
[17:42:45.524]  - attr(*, "total_size")= num 112
[17:42:45.524]  - attr(*, "already-done")= logi TRUE
[17:42:45.529] - copied ‘a’ to environment
[17:42:45.529] - copied ‘ii’ to environment
[17:42:45.529] assign_globals() ... done
[17:42:45.529] requestCore(): workers = 2
[17:42:45.531] MulticoreFuture started
[17:42:45.532] - Launch lazy future ... done
[17:42:45.532] run() for ‘MulticoreFuture’ ... done
[17:42:45.532] plan(): Setting new future strategy stack:
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.533] getGlobalsAndPackages() ...
[17:42:45.533] List of future strategies:
[17:42:45.533] 1. sequential:
[17:42:45.533]    - args: function (..., envir = parent.frame())
[17:42:45.533]    - tweaked: FALSE
[17:42:45.533]    - call: NULL
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.533] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.533] plan(): nbrOfWorkers() = 1
[17:42:45.536] plan(): Setting new future strategy stack:
[17:42:45.536] List of future strategies:
[17:42:45.536] 1. multicore:
[17:42:45.536]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.536]    - tweaked: FALSE
[17:42:45.536]    - call: plan(strategy)
[17:42:45.537] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.537] Searching for globals ... DONE
[17:42:45.537] Resolving globals: TRUE
[17:42:45.538] Resolving any globals that are futures ...
[17:42:45.538] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.538] Resolving any globals that are futures ... DONE
[17:42:45.541] plan(): nbrOfWorkers() = 2
[17:42:45.542] Resolving futures part of globals (recursively) ...
[17:42:45.544] resolve() on list ...
[17:42:45.544]  recursive: 99
[17:42:45.544]  length: 2
[17:42:45.545]  elements: ‘a’, ‘ii’
[17:42:45.545]  length: 1 (resolved future 1)
[17:42:45.545]  length: 0 (resolved future 2)
[17:42:45.545] resolve() on list ... DONE
[17:42:45.545] - globals: [2] ‘a’, ‘ii’
[17:42:45.546] Resolving futures part of globals (recursively) ... DONE
[17:42:45.546] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:45.547] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.547] - globals: [2] ‘a’, ‘ii’
[17:42:45.547] 
[17:42:45.547] getGlobalsAndPackages() ... DONE
[17:42:45.548] run() for ‘Future’ ...
[17:42:45.548] - state: ‘created’
[17:42:45.549] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.554] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.554]   - Field: ‘label’
[17:42:45.555]   - Field: ‘local’
[17:42:45.555]   - Field: ‘owner’
[17:42:45.555]   - Field: ‘envir’
[17:42:45.555]   - Field: ‘workers’
[17:42:45.555]   - Field: ‘packages’
[17:42:45.556]   - Field: ‘gc’
[17:42:45.556]   - Field: ‘job’
[17:42:45.556]   - Field: ‘conditions’
[17:42:45.556]   - Field: ‘expr’
[17:42:45.556]   - Field: ‘uuid’
[17:42:45.557]   - Field: ‘seed’
[17:42:45.557]   - Field: ‘version’
[17:42:45.557]   - Field: ‘result’
[17:42:45.557]   - Field: ‘asynchronous’
[17:42:45.557]   - Field: ‘calls’
[17:42:45.557]   - Field: ‘globals’
[17:42:45.557]   - Field: ‘stdout’
[17:42:45.558]   - Field: ‘earlySignal’
[17:42:45.558]   - Field: ‘lazy’
[17:42:45.558]   - Field: ‘state’
[17:42:45.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.558] - Launch lazy future ...
[17:42:45.559] Packages needed by the future expression (n = 0): <none>
[17:42:45.559] Packages needed by future strategies (n = 0): <none>
[17:42:45.560] {
[17:42:45.560]     {
[17:42:45.560]         {
[17:42:45.560]             ...future.startTime <- base::Sys.time()
[17:42:45.560]             {
[17:42:45.560]                 {
[17:42:45.560]                   {
[17:42:45.560]                     {
[17:42:45.560]                       base::local({
[17:42:45.560]                         has_future <- base::requireNamespace("future", 
[17:42:45.560]                           quietly = TRUE)
[17:42:45.560]                         if (has_future) {
[17:42:45.560]                           ns <- base::getNamespace("future")
[17:42:45.560]                           version <- ns[[".package"]][["version"]]
[17:42:45.560]                           if (is.null(version)) 
[17:42:45.560]                             version <- utils::packageVersion("future")
[17:42:45.560]                         }
[17:42:45.560]                         else {
[17:42:45.560]                           version <- NULL
[17:42:45.560]                         }
[17:42:45.560]                         if (!has_future || version < "1.8.0") {
[17:42:45.560]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.560]                             "", base::R.version$version.string), 
[17:42:45.560]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.560]                               "release", "version")], collapse = " "), 
[17:42:45.560]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.560]                             info)
[17:42:45.560]                           info <- base::paste(info, collapse = "; ")
[17:42:45.560]                           if (!has_future) {
[17:42:45.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.560]                               info)
[17:42:45.560]                           }
[17:42:45.560]                           else {
[17:42:45.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.560]                               info, version)
[17:42:45.560]                           }
[17:42:45.560]                           base::stop(msg)
[17:42:45.560]                         }
[17:42:45.560]                       })
[17:42:45.560]                     }
[17:42:45.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.560]                     base::options(mc.cores = 1L)
[17:42:45.560]                   }
[17:42:45.560]                   options(future.plan = NULL)
[17:42:45.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.560]                 }
[17:42:45.560]                 ...future.workdir <- getwd()
[17:42:45.560]             }
[17:42:45.560]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.560]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.560]         }
[17:42:45.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.560]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.560]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.560]             base::names(...future.oldOptions))
[17:42:45.560]     }
[17:42:45.560]     if (FALSE) {
[17:42:45.560]     }
[17:42:45.560]     else {
[17:42:45.560]         if (TRUE) {
[17:42:45.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.560]                 open = "w")
[17:42:45.560]         }
[17:42:45.560]         else {
[17:42:45.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.560]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.560]         }
[17:42:45.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.560]             base::sink(type = "output", split = FALSE)
[17:42:45.560]             base::close(...future.stdout)
[17:42:45.560]         }, add = TRUE)
[17:42:45.560]     }
[17:42:45.560]     ...future.frame <- base::sys.nframe()
[17:42:45.560]     ...future.conditions <- base::list()
[17:42:45.560]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.560]     if (FALSE) {
[17:42:45.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.560]     }
[17:42:45.560]     ...future.result <- base::tryCatch({
[17:42:45.560]         base::withCallingHandlers({
[17:42:45.560]             ...future.value <- base::withVisible(base::local({
[17:42:45.560]                 withCallingHandlers({
[17:42:45.560]                   {
[17:42:45.560]                     b <- a * ii
[17:42:45.560]                     a <- 0
[17:42:45.560]                     b
[17:42:45.560]                   }
[17:42:45.560]                 }, immediateCondition = function(cond) {
[17:42:45.560]                   save_rds <- function (object, pathname, ...) 
[17:42:45.560]                   {
[17:42:45.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.560]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.560]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.560]                         fi_tmp[["mtime"]])
[17:42:45.560]                     }
[17:42:45.560]                     tryCatch({
[17:42:45.560]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.560]                     }, error = function(ex) {
[17:42:45.560]                       msg <- conditionMessage(ex)
[17:42:45.560]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.560]                         fi_tmp[["mtime"]], msg)
[17:42:45.560]                       ex$message <- msg
[17:42:45.560]                       stop(ex)
[17:42:45.560]                     })
[17:42:45.560]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.560]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.560]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.560]                       fi <- file.info(pathname)
[17:42:45.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.560]                         fi[["size"]], fi[["mtime"]])
[17:42:45.560]                       stop(msg)
[17:42:45.560]                     }
[17:42:45.560]                     invisible(pathname)
[17:42:45.560]                   }
[17:42:45.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.560]                     rootPath = tempdir()) 
[17:42:45.560]                   {
[17:42:45.560]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.560]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.560]                       tmpdir = path, fileext = ".rds")
[17:42:45.560]                     save_rds(obj, file)
[17:42:45.560]                   }
[17:42:45.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.560]                   {
[17:42:45.560]                     inherits <- base::inherits
[17:42:45.560]                     invokeRestart <- base::invokeRestart
[17:42:45.560]                     is.null <- base::is.null
[17:42:45.560]                     muffled <- FALSE
[17:42:45.560]                     if (inherits(cond, "message")) {
[17:42:45.560]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.560]                       if (muffled) 
[17:42:45.560]                         invokeRestart("muffleMessage")
[17:42:45.560]                     }
[17:42:45.560]                     else if (inherits(cond, "warning")) {
[17:42:45.560]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.560]                       if (muffled) 
[17:42:45.560]                         invokeRestart("muffleWarning")
[17:42:45.560]                     }
[17:42:45.560]                     else if (inherits(cond, "condition")) {
[17:42:45.560]                       if (!is.null(pattern)) {
[17:42:45.560]                         computeRestarts <- base::computeRestarts
[17:42:45.560]                         grepl <- base::grepl
[17:42:45.560]                         restarts <- computeRestarts(cond)
[17:42:45.560]                         for (restart in restarts) {
[17:42:45.560]                           name <- restart$name
[17:42:45.560]                           if (is.null(name)) 
[17:42:45.560]                             next
[17:42:45.560]                           if (!grepl(pattern, name)) 
[17:42:45.560]                             next
[17:42:45.560]                           invokeRestart(restart)
[17:42:45.560]                           muffled <- TRUE
[17:42:45.560]                           break
[17:42:45.560]                         }
[17:42:45.560]                       }
[17:42:45.560]                     }
[17:42:45.560]                     invisible(muffled)
[17:42:45.560]                   }
[17:42:45.560]                   muffleCondition(cond)
[17:42:45.560]                 })
[17:42:45.560]             }))
[17:42:45.560]             future::FutureResult(value = ...future.value$value, 
[17:42:45.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.560]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.560]                     ...future.globalenv.names))
[17:42:45.560]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.560]         }, condition = base::local({
[17:42:45.560]             c <- base::c
[17:42:45.560]             inherits <- base::inherits
[17:42:45.560]             invokeRestart <- base::invokeRestart
[17:42:45.560]             length <- base::length
[17:42:45.560]             list <- base::list
[17:42:45.560]             seq.int <- base::seq.int
[17:42:45.560]             signalCondition <- base::signalCondition
[17:42:45.560]             sys.calls <- base::sys.calls
[17:42:45.560]             `[[` <- base::`[[`
[17:42:45.560]             `+` <- base::`+`
[17:42:45.560]             `<<-` <- base::`<<-`
[17:42:45.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.560]                   3L)]
[17:42:45.560]             }
[17:42:45.560]             function(cond) {
[17:42:45.560]                 is_error <- inherits(cond, "error")
[17:42:45.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.560]                   NULL)
[17:42:45.560]                 if (is_error) {
[17:42:45.560]                   sessionInformation <- function() {
[17:42:45.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.560]                       search = base::search(), system = base::Sys.info())
[17:42:45.560]                   }
[17:42:45.560]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.560]                     cond$call), session = sessionInformation(), 
[17:42:45.560]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.560]                   signalCondition(cond)
[17:42:45.560]                 }
[17:42:45.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.560]                 "immediateCondition"))) {
[17:42:45.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.560]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.560]                   if (TRUE && !signal) {
[17:42:45.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.560]                     {
[17:42:45.560]                       inherits <- base::inherits
[17:42:45.560]                       invokeRestart <- base::invokeRestart
[17:42:45.560]                       is.null <- base::is.null
[17:42:45.560]                       muffled <- FALSE
[17:42:45.560]                       if (inherits(cond, "message")) {
[17:42:45.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.560]                         if (muffled) 
[17:42:45.560]                           invokeRestart("muffleMessage")
[17:42:45.560]                       }
[17:42:45.560]                       else if (inherits(cond, "warning")) {
[17:42:45.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.560]                         if (muffled) 
[17:42:45.560]                           invokeRestart("muffleWarning")
[17:42:45.560]                       }
[17:42:45.560]                       else if (inherits(cond, "condition")) {
[17:42:45.560]                         if (!is.null(pattern)) {
[17:42:45.560]                           computeRestarts <- base::computeRestarts
[17:42:45.560]                           grepl <- base::grepl
[17:42:45.560]                           restarts <- computeRestarts(cond)
[17:42:45.560]                           for (restart in restarts) {
[17:42:45.560]                             name <- restart$name
[17:42:45.560]                             if (is.null(name)) 
[17:42:45.560]                               next
[17:42:45.560]                             if (!grepl(pattern, name)) 
[17:42:45.560]                               next
[17:42:45.560]                             invokeRestart(restart)
[17:42:45.560]                             muffled <- TRUE
[17:42:45.560]                             break
[17:42:45.560]                           }
[17:42:45.560]                         }
[17:42:45.560]                       }
[17:42:45.560]                       invisible(muffled)
[17:42:45.560]                     }
[17:42:45.560]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.560]                   }
[17:42:45.560]                 }
[17:42:45.560]                 else {
[17:42:45.560]                   if (TRUE) {
[17:42:45.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.560]                     {
[17:42:45.560]                       inherits <- base::inherits
[17:42:45.560]                       invokeRestart <- base::invokeRestart
[17:42:45.560]                       is.null <- base::is.null
[17:42:45.560]                       muffled <- FALSE
[17:42:45.560]                       if (inherits(cond, "message")) {
[17:42:45.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.560]                         if (muffled) 
[17:42:45.560]                           invokeRestart("muffleMessage")
[17:42:45.560]                       }
[17:42:45.560]                       else if (inherits(cond, "warning")) {
[17:42:45.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.560]                         if (muffled) 
[17:42:45.560]                           invokeRestart("muffleWarning")
[17:42:45.560]                       }
[17:42:45.560]                       else if (inherits(cond, "condition")) {
[17:42:45.560]                         if (!is.null(pattern)) {
[17:42:45.560]                           computeRestarts <- base::computeRestarts
[17:42:45.560]                           grepl <- base::grepl
[17:42:45.560]                           restarts <- computeRestarts(cond)
[17:42:45.560]                           for (restart in restarts) {
[17:42:45.560]                             name <- restart$name
[17:42:45.560]                             if (is.null(name)) 
[17:42:45.560]                               next
[17:42:45.560]                             if (!grepl(pattern, name)) 
[17:42:45.560]                               next
[17:42:45.560]                             invokeRestart(restart)
[17:42:45.560]                             muffled <- TRUE
[17:42:45.560]                             break
[17:42:45.560]                           }
[17:42:45.560]                         }
[17:42:45.560]                       }
[17:42:45.560]                       invisible(muffled)
[17:42:45.560]                     }
[17:42:45.560]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.560]                   }
[17:42:45.560]                 }
[17:42:45.560]             }
[17:42:45.560]         }))
[17:42:45.560]     }, error = function(ex) {
[17:42:45.560]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.560]                 ...future.rng), started = ...future.startTime, 
[17:42:45.560]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.560]             version = "1.8"), class = "FutureResult")
[17:42:45.560]     }, finally = {
[17:42:45.560]         if (!identical(...future.workdir, getwd())) 
[17:42:45.560]             setwd(...future.workdir)
[17:42:45.560]         {
[17:42:45.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.560]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.560]             }
[17:42:45.560]             base::options(...future.oldOptions)
[17:42:45.560]             if (.Platform$OS.type == "windows") {
[17:42:45.560]                 old_names <- names(...future.oldEnvVars)
[17:42:45.560]                 envs <- base::Sys.getenv()
[17:42:45.560]                 names <- names(envs)
[17:42:45.560]                 common <- intersect(names, old_names)
[17:42:45.560]                 added <- setdiff(names, old_names)
[17:42:45.560]                 removed <- setdiff(old_names, names)
[17:42:45.560]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.560]                   envs[common]]
[17:42:45.560]                 NAMES <- toupper(changed)
[17:42:45.560]                 args <- list()
[17:42:45.560]                 for (kk in seq_along(NAMES)) {
[17:42:45.560]                   name <- changed[[kk]]
[17:42:45.560]                   NAME <- NAMES[[kk]]
[17:42:45.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.560]                     next
[17:42:45.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.560]                 }
[17:42:45.560]                 NAMES <- toupper(added)
[17:42:45.560]                 for (kk in seq_along(NAMES)) {
[17:42:45.560]                   name <- added[[kk]]
[17:42:45.560]                   NAME <- NAMES[[kk]]
[17:42:45.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.560]                     next
[17:42:45.560]                   args[[name]] <- ""
[17:42:45.560]                 }
[17:42:45.560]                 NAMES <- toupper(removed)
[17:42:45.560]                 for (kk in seq_along(NAMES)) {
[17:42:45.560]                   name <- removed[[kk]]
[17:42:45.560]                   NAME <- NAMES[[kk]]
[17:42:45.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.560]                     next
[17:42:45.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.560]                 }
[17:42:45.560]                 if (length(args) > 0) 
[17:42:45.560]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.560]             }
[17:42:45.560]             else {
[17:42:45.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.560]             }
[17:42:45.560]             {
[17:42:45.560]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.560]                   0L) {
[17:42:45.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.560]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.560]                   base::options(opts)
[17:42:45.560]                 }
[17:42:45.560]                 {
[17:42:45.560]                   {
[17:42:45.560]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.560]                     NULL
[17:42:45.560]                   }
[17:42:45.560]                   options(future.plan = NULL)
[17:42:45.560]                   if (is.na(NA_character_)) 
[17:42:45.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.560]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.560]                     envir = parent.frame()) 
[17:42:45.560]                   {
[17:42:45.560]                     default_workers <- missing(workers)
[17:42:45.560]                     if (is.function(workers)) 
[17:42:45.560]                       workers <- workers()
[17:42:45.560]                     workers <- structure(as.integer(workers), 
[17:42:45.560]                       class = class(workers))
[17:42:45.560]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.560]                       1L)
[17:42:45.560]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.560]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.560]                       if (default_workers) 
[17:42:45.560]                         supportsMulticore(warn = TRUE)
[17:42:45.560]                       return(sequential(..., envir = envir))
[17:42:45.560]                     }
[17:42:45.560]                     oopts <- options(mc.cores = workers)
[17:42:45.560]                     on.exit(options(oopts))
[17:42:45.560]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.560]                       envir = envir)
[17:42:45.560]                     if (!future$lazy) 
[17:42:45.560]                       future <- run(future)
[17:42:45.560]                     invisible(future)
[17:42:45.560]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.560]                 }
[17:42:45.560]             }
[17:42:45.560]         }
[17:42:45.560]     })
[17:42:45.560]     if (TRUE) {
[17:42:45.560]         base::sink(type = "output", split = FALSE)
[17:42:45.560]         if (TRUE) {
[17:42:45.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.560]         }
[17:42:45.560]         else {
[17:42:45.560]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.560]         }
[17:42:45.560]         base::close(...future.stdout)
[17:42:45.560]         ...future.stdout <- NULL
[17:42:45.560]     }
[17:42:45.560]     ...future.result$conditions <- ...future.conditions
[17:42:45.560]     ...future.result$finished <- base::Sys.time()
[17:42:45.560]     ...future.result
[17:42:45.560] }
[17:42:45.563] assign_globals() ...
[17:42:45.563] List of 2
[17:42:45.563]  $ a : num 1
[17:42:45.563]  $ ii: int 3
[17:42:45.563]  - attr(*, "where")=List of 2
[17:42:45.563]   ..$ a :<environment: R_EmptyEnv> 
[17:42:45.563]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.563]  - attr(*, "resolved")= logi TRUE
[17:42:45.563]  - attr(*, "total_size")= num 112
[17:42:45.563]  - attr(*, "already-done")= logi TRUE
[17:42:45.567] - copied ‘a’ to environment
[17:42:45.567] - copied ‘ii’ to environment
[17:42:45.567] assign_globals() ... done
[17:42:45.567] requestCore(): workers = 2
[17:42:45.568] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:45.595] MulticoreFuture started
[17:42:45.596] - Launch lazy future ... done
[17:42:45.596] plan(): Setting new future strategy stack:
[17:42:45.596] run() for ‘MulticoreFuture’ ... done
[17:42:45.597] List of future strategies:
[17:42:45.597] 1. sequential:
[17:42:45.597]    - args: function (..., envir = parent.frame())
[17:42:45.597]    - tweaked: FALSE
[17:42:45.597]    - call: NULL
[17:42:45.599] plan(): nbrOfWorkers() = 1
[17:42:45.602] plan(): Setting new future strategy stack:
[17:42:45.602] List of future strategies:
[17:42:45.602] 1. multicore:
[17:42:45.602]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.602]    - tweaked: FALSE
[17:42:45.602]    - call: plan(strategy)
[17:42:45.609] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.612] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.612] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.615] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.615] Searching for globals ... DONE
[17:42:45.616] Resolving globals: TRUE
[17:42:45.616] Resolving any globals that are futures ...
[17:42:45.616] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.616] Resolving any globals that are futures ... DONE
[17:42:45.616] Resolving futures part of globals (recursively) ...
[17:42:45.617] resolve() on list ...
[17:42:45.617]  recursive: 99
[17:42:45.617]  length: 2
[17:42:45.617]  elements: ‘a’, ‘ii’
[17:42:45.617]  length: 1 (resolved future 1)
[17:42:45.617]  length: 0 (resolved future 2)
[17:42:45.618] resolve() on list ... DONE
[17:42:45.618] - globals: [2] ‘a’, ‘ii’
[17:42:45.618] Resolving futures part of globals (recursively) ... DONE
[17:42:45.618] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:45.619] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.619] - globals: [2] ‘a’, ‘ii’
[17:42:45.619] 
[17:42:45.619] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.620] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.620] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.622] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.622] Searching for globals ... DONE
[17:42:45.622] Resolving globals: TRUE
[17:42:45.622] Resolving any globals that are futures ...
[17:42:45.623] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.623] Resolving any globals that are futures ... DONE
[17:42:45.623] Resolving futures part of globals (recursively) ...
[17:42:45.623] resolve() on list ...
[17:42:45.623]  recursive: 99
[17:42:45.624]  length: 2
[17:42:45.624]  elements: ‘a’, ‘ii’
[17:42:45.624]  length: 1 (resolved future 1)
[17:42:45.624]  length: 0 (resolved future 2)
[17:42:45.624] resolve() on list ... DONE
[17:42:45.624] - globals: [2] ‘a’, ‘ii’
[17:42:45.624] Resolving futures part of globals (recursively) ... DONE
[17:42:45.624] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:45.625] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.625] - globals: [2] ‘a’, ‘ii’
[17:42:45.625] 
[17:42:45.625] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.626] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.626] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.631] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.631] Searching for globals ... DONE
[17:42:45.632] Resolving globals: TRUE
[17:42:45.632] Resolving any globals that are futures ...
[17:42:45.632] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:45.632] Resolving any globals that are futures ... DONE
[17:42:45.633] Resolving futures part of globals (recursively) ...
[17:42:45.633] resolve() on list ...
[17:42:45.633]  recursive: 99
[17:42:45.633]  length: 2
[17:42:45.633]  elements: ‘a’, ‘ii’
[17:42:45.634]  length: 1 (resolved future 1)
[17:42:45.634]  length: 0 (resolved future 2)
[17:42:45.634] resolve() on list ... DONE
[17:42:45.634] - globals: [2] ‘a’, ‘ii’
[17:42:45.634] Resolving futures part of globals (recursively) ... DONE
[17:42:45.634] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:45.635] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:45.635] - globals: [2] ‘a’, ‘ii’
[17:42:45.635] 
[17:42:45.635] getGlobalsAndPackages() ... DONE
[17:42:45.635] run() for ‘Future’ ...
[17:42:45.636] - state: ‘created’
[17:42:45.636] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.640] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.640]   - Field: ‘label’
[17:42:45.640]   - Field: ‘local’
[17:42:45.640]   - Field: ‘owner’
[17:42:45.641]   - Field: ‘envir’
[17:42:45.641]   - Field: ‘workers’
[17:42:45.641]   - Field: ‘packages’
[17:42:45.641]   - Field: ‘gc’
[17:42:45.641]   - Field: ‘job’
[17:42:45.642]   - Field: ‘conditions’
[17:42:45.642]   - Field: ‘expr’
[17:42:45.642]   - Field: ‘uuid’
[17:42:45.642]   - Field: ‘seed’
[17:42:45.642]   - Field: ‘version’
[17:42:45.642]   - Field: ‘result’
[17:42:45.642]   - Field: ‘asynchronous’
[17:42:45.642]   - Field: ‘calls’
[17:42:45.643]   - Field: ‘globals’
[17:42:45.643]   - Field: ‘stdout’
[17:42:45.643]   - Field: ‘earlySignal’
[17:42:45.643]   - Field: ‘lazy’
[17:42:45.643]   - Field: ‘state’
[17:42:45.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.643] - Launch lazy future ...
[17:42:45.644] Packages needed by the future expression (n = 0): <none>
[17:42:45.644] Packages needed by future strategies (n = 0): <none>
[17:42:45.645] {
[17:42:45.645]     {
[17:42:45.645]         {
[17:42:45.645]             ...future.startTime <- base::Sys.time()
[17:42:45.645]             {
[17:42:45.645]                 {
[17:42:45.645]                   {
[17:42:45.645]                     {
[17:42:45.645]                       base::local({
[17:42:45.645]                         has_future <- base::requireNamespace("future", 
[17:42:45.645]                           quietly = TRUE)
[17:42:45.645]                         if (has_future) {
[17:42:45.645]                           ns <- base::getNamespace("future")
[17:42:45.645]                           version <- ns[[".package"]][["version"]]
[17:42:45.645]                           if (is.null(version)) 
[17:42:45.645]                             version <- utils::packageVersion("future")
[17:42:45.645]                         }
[17:42:45.645]                         else {
[17:42:45.645]                           version <- NULL
[17:42:45.645]                         }
[17:42:45.645]                         if (!has_future || version < "1.8.0") {
[17:42:45.645]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.645]                             "", base::R.version$version.string), 
[17:42:45.645]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.645]                               "release", "version")], collapse = " "), 
[17:42:45.645]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.645]                             info)
[17:42:45.645]                           info <- base::paste(info, collapse = "; ")
[17:42:45.645]                           if (!has_future) {
[17:42:45.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.645]                               info)
[17:42:45.645]                           }
[17:42:45.645]                           else {
[17:42:45.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.645]                               info, version)
[17:42:45.645]                           }
[17:42:45.645]                           base::stop(msg)
[17:42:45.645]                         }
[17:42:45.645]                       })
[17:42:45.645]                     }
[17:42:45.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.645]                     base::options(mc.cores = 1L)
[17:42:45.645]                   }
[17:42:45.645]                   options(future.plan = NULL)
[17:42:45.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.645]                 }
[17:42:45.645]                 ...future.workdir <- getwd()
[17:42:45.645]             }
[17:42:45.645]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.645]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.645]         }
[17:42:45.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.645]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.645]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.645]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.645]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.645]             base::names(...future.oldOptions))
[17:42:45.645]     }
[17:42:45.645]     if (FALSE) {
[17:42:45.645]     }
[17:42:45.645]     else {
[17:42:45.645]         if (TRUE) {
[17:42:45.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.645]                 open = "w")
[17:42:45.645]         }
[17:42:45.645]         else {
[17:42:45.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.645]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.645]         }
[17:42:45.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.645]             base::sink(type = "output", split = FALSE)
[17:42:45.645]             base::close(...future.stdout)
[17:42:45.645]         }, add = TRUE)
[17:42:45.645]     }
[17:42:45.645]     ...future.frame <- base::sys.nframe()
[17:42:45.645]     ...future.conditions <- base::list()
[17:42:45.645]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.645]     if (FALSE) {
[17:42:45.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.645]     }
[17:42:45.645]     ...future.result <- base::tryCatch({
[17:42:45.645]         base::withCallingHandlers({
[17:42:45.645]             ...future.value <- base::withVisible(base::local({
[17:42:45.645]                 withCallingHandlers({
[17:42:45.645]                   {
[17:42:45.645]                     b <- a * ii
[17:42:45.645]                     a <- 0
[17:42:45.645]                     b
[17:42:45.645]                   }
[17:42:45.645]                 }, immediateCondition = function(cond) {
[17:42:45.645]                   save_rds <- function (object, pathname, ...) 
[17:42:45.645]                   {
[17:42:45.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.645]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.645]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.645]                         fi_tmp[["mtime"]])
[17:42:45.645]                     }
[17:42:45.645]                     tryCatch({
[17:42:45.645]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.645]                     }, error = function(ex) {
[17:42:45.645]                       msg <- conditionMessage(ex)
[17:42:45.645]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.645]                         fi_tmp[["mtime"]], msg)
[17:42:45.645]                       ex$message <- msg
[17:42:45.645]                       stop(ex)
[17:42:45.645]                     })
[17:42:45.645]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.645]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.645]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.645]                       fi <- file.info(pathname)
[17:42:45.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.645]                         fi[["size"]], fi[["mtime"]])
[17:42:45.645]                       stop(msg)
[17:42:45.645]                     }
[17:42:45.645]                     invisible(pathname)
[17:42:45.645]                   }
[17:42:45.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.645]                     rootPath = tempdir()) 
[17:42:45.645]                   {
[17:42:45.645]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.645]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.645]                       tmpdir = path, fileext = ".rds")
[17:42:45.645]                     save_rds(obj, file)
[17:42:45.645]                   }
[17:42:45.645]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.645]                   {
[17:42:45.645]                     inherits <- base::inherits
[17:42:45.645]                     invokeRestart <- base::invokeRestart
[17:42:45.645]                     is.null <- base::is.null
[17:42:45.645]                     muffled <- FALSE
[17:42:45.645]                     if (inherits(cond, "message")) {
[17:42:45.645]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.645]                       if (muffled) 
[17:42:45.645]                         invokeRestart("muffleMessage")
[17:42:45.645]                     }
[17:42:45.645]                     else if (inherits(cond, "warning")) {
[17:42:45.645]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.645]                       if (muffled) 
[17:42:45.645]                         invokeRestart("muffleWarning")
[17:42:45.645]                     }
[17:42:45.645]                     else if (inherits(cond, "condition")) {
[17:42:45.645]                       if (!is.null(pattern)) {
[17:42:45.645]                         computeRestarts <- base::computeRestarts
[17:42:45.645]                         grepl <- base::grepl
[17:42:45.645]                         restarts <- computeRestarts(cond)
[17:42:45.645]                         for (restart in restarts) {
[17:42:45.645]                           name <- restart$name
[17:42:45.645]                           if (is.null(name)) 
[17:42:45.645]                             next
[17:42:45.645]                           if (!grepl(pattern, name)) 
[17:42:45.645]                             next
[17:42:45.645]                           invokeRestart(restart)
[17:42:45.645]                           muffled <- TRUE
[17:42:45.645]                           break
[17:42:45.645]                         }
[17:42:45.645]                       }
[17:42:45.645]                     }
[17:42:45.645]                     invisible(muffled)
[17:42:45.645]                   }
[17:42:45.645]                   muffleCondition(cond)
[17:42:45.645]                 })
[17:42:45.645]             }))
[17:42:45.645]             future::FutureResult(value = ...future.value$value, 
[17:42:45.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.645]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.645]                     ...future.globalenv.names))
[17:42:45.645]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.645]         }, condition = base::local({
[17:42:45.645]             c <- base::c
[17:42:45.645]             inherits <- base::inherits
[17:42:45.645]             invokeRestart <- base::invokeRestart
[17:42:45.645]             length <- base::length
[17:42:45.645]             list <- base::list
[17:42:45.645]             seq.int <- base::seq.int
[17:42:45.645]             signalCondition <- base::signalCondition
[17:42:45.645]             sys.calls <- base::sys.calls
[17:42:45.645]             `[[` <- base::`[[`
[17:42:45.645]             `+` <- base::`+`
[17:42:45.645]             `<<-` <- base::`<<-`
[17:42:45.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.645]                   3L)]
[17:42:45.645]             }
[17:42:45.645]             function(cond) {
[17:42:45.645]                 is_error <- inherits(cond, "error")
[17:42:45.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.645]                   NULL)
[17:42:45.645]                 if (is_error) {
[17:42:45.645]                   sessionInformation <- function() {
[17:42:45.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.645]                       search = base::search(), system = base::Sys.info())
[17:42:45.645]                   }
[17:42:45.645]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.645]                     cond$call), session = sessionInformation(), 
[17:42:45.645]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.645]                   signalCondition(cond)
[17:42:45.645]                 }
[17:42:45.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.645]                 "immediateCondition"))) {
[17:42:45.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.645]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.645]                   if (TRUE && !signal) {
[17:42:45.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.645]                     {
[17:42:45.645]                       inherits <- base::inherits
[17:42:45.645]                       invokeRestart <- base::invokeRestart
[17:42:45.645]                       is.null <- base::is.null
[17:42:45.645]                       muffled <- FALSE
[17:42:45.645]                       if (inherits(cond, "message")) {
[17:42:45.645]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.645]                         if (muffled) 
[17:42:45.645]                           invokeRestart("muffleMessage")
[17:42:45.645]                       }
[17:42:45.645]                       else if (inherits(cond, "warning")) {
[17:42:45.645]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.645]                         if (muffled) 
[17:42:45.645]                           invokeRestart("muffleWarning")
[17:42:45.645]                       }
[17:42:45.645]                       else if (inherits(cond, "condition")) {
[17:42:45.645]                         if (!is.null(pattern)) {
[17:42:45.645]                           computeRestarts <- base::computeRestarts
[17:42:45.645]                           grepl <- base::grepl
[17:42:45.645]                           restarts <- computeRestarts(cond)
[17:42:45.645]                           for (restart in restarts) {
[17:42:45.645]                             name <- restart$name
[17:42:45.645]                             if (is.null(name)) 
[17:42:45.645]                               next
[17:42:45.645]                             if (!grepl(pattern, name)) 
[17:42:45.645]                               next
[17:42:45.645]                             invokeRestart(restart)
[17:42:45.645]                             muffled <- TRUE
[17:42:45.645]                             break
[17:42:45.645]                           }
[17:42:45.645]                         }
[17:42:45.645]                       }
[17:42:45.645]                       invisible(muffled)
[17:42:45.645]                     }
[17:42:45.645]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.645]                   }
[17:42:45.645]                 }
[17:42:45.645]                 else {
[17:42:45.645]                   if (TRUE) {
[17:42:45.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.645]                     {
[17:42:45.645]                       inherits <- base::inherits
[17:42:45.645]                       invokeRestart <- base::invokeRestart
[17:42:45.645]                       is.null <- base::is.null
[17:42:45.645]                       muffled <- FALSE
[17:42:45.645]                       if (inherits(cond, "message")) {
[17:42:45.645]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.645]                         if (muffled) 
[17:42:45.645]                           invokeRestart("muffleMessage")
[17:42:45.645]                       }
[17:42:45.645]                       else if (inherits(cond, "warning")) {
[17:42:45.645]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.645]                         if (muffled) 
[17:42:45.645]                           invokeRestart("muffleWarning")
[17:42:45.645]                       }
[17:42:45.645]                       else if (inherits(cond, "condition")) {
[17:42:45.645]                         if (!is.null(pattern)) {
[17:42:45.645]                           computeRestarts <- base::computeRestarts
[17:42:45.645]                           grepl <- base::grepl
[17:42:45.645]                           restarts <- computeRestarts(cond)
[17:42:45.645]                           for (restart in restarts) {
[17:42:45.645]                             name <- restart$name
[17:42:45.645]                             if (is.null(name)) 
[17:42:45.645]                               next
[17:42:45.645]                             if (!grepl(pattern, name)) 
[17:42:45.645]                               next
[17:42:45.645]                             invokeRestart(restart)
[17:42:45.645]                             muffled <- TRUE
[17:42:45.645]                             break
[17:42:45.645]                           }
[17:42:45.645]                         }
[17:42:45.645]                       }
[17:42:45.645]                       invisible(muffled)
[17:42:45.645]                     }
[17:42:45.645]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.645]                   }
[17:42:45.645]                 }
[17:42:45.645]             }
[17:42:45.645]         }))
[17:42:45.645]     }, error = function(ex) {
[17:42:45.645]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.645]                 ...future.rng), started = ...future.startTime, 
[17:42:45.645]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.645]             version = "1.8"), class = "FutureResult")
[17:42:45.645]     }, finally = {
[17:42:45.645]         if (!identical(...future.workdir, getwd())) 
[17:42:45.645]             setwd(...future.workdir)
[17:42:45.645]         {
[17:42:45.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.645]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.645]             }
[17:42:45.645]             base::options(...future.oldOptions)
[17:42:45.645]             if (.Platform$OS.type == "windows") {
[17:42:45.645]                 old_names <- names(...future.oldEnvVars)
[17:42:45.645]                 envs <- base::Sys.getenv()
[17:42:45.645]                 names <- names(envs)
[17:42:45.645]                 common <- intersect(names, old_names)
[17:42:45.645]                 added <- setdiff(names, old_names)
[17:42:45.645]                 removed <- setdiff(old_names, names)
[17:42:45.645]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.645]                   envs[common]]
[17:42:45.645]                 NAMES <- toupper(changed)
[17:42:45.645]                 args <- list()
[17:42:45.645]                 for (kk in seq_along(NAMES)) {
[17:42:45.645]                   name <- changed[[kk]]
[17:42:45.645]                   NAME <- NAMES[[kk]]
[17:42:45.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.645]                     next
[17:42:45.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.645]                 }
[17:42:45.645]                 NAMES <- toupper(added)
[17:42:45.645]                 for (kk in seq_along(NAMES)) {
[17:42:45.645]                   name <- added[[kk]]
[17:42:45.645]                   NAME <- NAMES[[kk]]
[17:42:45.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.645]                     next
[17:42:45.645]                   args[[name]] <- ""
[17:42:45.645]                 }
[17:42:45.645]                 NAMES <- toupper(removed)
[17:42:45.645]                 for (kk in seq_along(NAMES)) {
[17:42:45.645]                   name <- removed[[kk]]
[17:42:45.645]                   NAME <- NAMES[[kk]]
[17:42:45.645]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.645]                     next
[17:42:45.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.645]                 }
[17:42:45.645]                 if (length(args) > 0) 
[17:42:45.645]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.645]             }
[17:42:45.645]             else {
[17:42:45.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.645]             }
[17:42:45.645]             {
[17:42:45.645]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.645]                   0L) {
[17:42:45.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.645]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.645]                   base::options(opts)
[17:42:45.645]                 }
[17:42:45.645]                 {
[17:42:45.645]                   {
[17:42:45.645]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.645]                     NULL
[17:42:45.645]                   }
[17:42:45.645]                   options(future.plan = NULL)
[17:42:45.645]                   if (is.na(NA_character_)) 
[17:42:45.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.645]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.645]                     envir = parent.frame()) 
[17:42:45.645]                   {
[17:42:45.645]                     default_workers <- missing(workers)
[17:42:45.645]                     if (is.function(workers)) 
[17:42:45.645]                       workers <- workers()
[17:42:45.645]                     workers <- structure(as.integer(workers), 
[17:42:45.645]                       class = class(workers))
[17:42:45.645]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.645]                       1L)
[17:42:45.645]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.645]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.645]                       if (default_workers) 
[17:42:45.645]                         supportsMulticore(warn = TRUE)
[17:42:45.645]                       return(sequential(..., envir = envir))
[17:42:45.645]                     }
[17:42:45.645]                     oopts <- options(mc.cores = workers)
[17:42:45.645]                     on.exit(options(oopts))
[17:42:45.645]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.645]                       envir = envir)
[17:42:45.645]                     if (!future$lazy) 
[17:42:45.645]                       future <- run(future)
[17:42:45.645]                     invisible(future)
[17:42:45.645]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.645]                 }
[17:42:45.645]             }
[17:42:45.645]         }
[17:42:45.645]     })
[17:42:45.645]     if (TRUE) {
[17:42:45.645]         base::sink(type = "output", split = FALSE)
[17:42:45.645]         if (TRUE) {
[17:42:45.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.645]         }
[17:42:45.645]         else {
[17:42:45.645]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.645]         }
[17:42:45.645]         base::close(...future.stdout)
[17:42:45.645]         ...future.stdout <- NULL
[17:42:45.645]     }
[17:42:45.645]     ...future.result$conditions <- ...future.conditions
[17:42:45.645]     ...future.result$finished <- base::Sys.time()
[17:42:45.645]     ...future.result
[17:42:45.645] }
[17:42:45.648] assign_globals() ...
[17:42:45.648] List of 2
[17:42:45.648]  $ a : num 1
[17:42:45.648]  $ ii: int 1
[17:42:45.648]  - attr(*, "where")=List of 2
[17:42:45.648]   ..$ a :<environment: R_EmptyEnv> 
[17:42:45.648]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.648]  - attr(*, "resolved")= logi TRUE
[17:42:45.648]  - attr(*, "total_size")= num 112
[17:42:45.648]  - attr(*, "already-done")= logi TRUE
[17:42:45.651] - copied ‘a’ to environment
[17:42:45.652] - copied ‘ii’ to environment
[17:42:45.652] assign_globals() ... done
[17:42:45.652] requestCore(): workers = 2
[17:42:45.654] MulticoreFuture started
[17:42:45.655] - Launch lazy future ... done
[17:42:45.655] run() for ‘MulticoreFuture’ ... done
[17:42:45.655] plan(): Setting new future strategy stack:
[17:42:45.656] List of future strategies:
[17:42:45.656] 1. sequential:
[17:42:45.656]    - args: function (..., envir = parent.frame())
[17:42:45.656]    - tweaked: FALSE
[17:42:45.656]    - call: NULL
[17:42:45.657] plan(): nbrOfWorkers() = 1
[17:42:45.659] plan(): Setting new future strategy stack:
[17:42:45.659] List of future strategies:
[17:42:45.659] 1. multicore:
[17:42:45.659]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.659]    - tweaked: FALSE
[17:42:45.659]    - call: plan(strategy)
[17:42:45.664] plan(): nbrOfWorkers() = 2
[17:42:45.665] run() for ‘Future’ ...
[17:42:45.666] - state: ‘created’
[17:42:45.666] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.671] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.671]   - Field: ‘label’
[17:42:45.672]   - Field: ‘local’
[17:42:45.672]   - Field: ‘owner’
[17:42:45.672]   - Field: ‘envir’
[17:42:45.672]   - Field: ‘workers’
[17:42:45.672]   - Field: ‘packages’
[17:42:45.673]   - Field: ‘gc’
[17:42:45.673]   - Field: ‘job’
[17:42:45.673]   - Field: ‘conditions’
[17:42:45.673]   - Field: ‘expr’
[17:42:45.673]   - Field: ‘uuid’
[17:42:45.673]   - Field: ‘seed’
[17:42:45.674]   - Field: ‘version’
[17:42:45.674]   - Field: ‘result’
[17:42:45.674]   - Field: ‘asynchronous’
[17:42:45.674]   - Field: ‘calls’
[17:42:45.674]   - Field: ‘globals’
[17:42:45.675]   - Field: ‘stdout’
[17:42:45.675]   - Field: ‘earlySignal’
[17:42:45.675]   - Field: ‘lazy’
[17:42:45.675]   - Field: ‘state’
[17:42:45.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.676] - Launch lazy future ...
[17:42:45.676] Packages needed by the future expression (n = 0): <none>
[17:42:45.676] Packages needed by future strategies (n = 0): <none>
[17:42:45.677] {
[17:42:45.677]     {
[17:42:45.677]         {
[17:42:45.677]             ...future.startTime <- base::Sys.time()
[17:42:45.677]             {
[17:42:45.677]                 {
[17:42:45.677]                   {
[17:42:45.677]                     {
[17:42:45.677]                       base::local({
[17:42:45.677]                         has_future <- base::requireNamespace("future", 
[17:42:45.677]                           quietly = TRUE)
[17:42:45.677]                         if (has_future) {
[17:42:45.677]                           ns <- base::getNamespace("future")
[17:42:45.677]                           version <- ns[[".package"]][["version"]]
[17:42:45.677]                           if (is.null(version)) 
[17:42:45.677]                             version <- utils::packageVersion("future")
[17:42:45.677]                         }
[17:42:45.677]                         else {
[17:42:45.677]                           version <- NULL
[17:42:45.677]                         }
[17:42:45.677]                         if (!has_future || version < "1.8.0") {
[17:42:45.677]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.677]                             "", base::R.version$version.string), 
[17:42:45.677]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.677]                               "release", "version")], collapse = " "), 
[17:42:45.677]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.677]                             info)
[17:42:45.677]                           info <- base::paste(info, collapse = "; ")
[17:42:45.677]                           if (!has_future) {
[17:42:45.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.677]                               info)
[17:42:45.677]                           }
[17:42:45.677]                           else {
[17:42:45.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.677]                               info, version)
[17:42:45.677]                           }
[17:42:45.677]                           base::stop(msg)
[17:42:45.677]                         }
[17:42:45.677]                       })
[17:42:45.677]                     }
[17:42:45.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.677]                     base::options(mc.cores = 1L)
[17:42:45.677]                   }
[17:42:45.677]                   options(future.plan = NULL)
[17:42:45.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.677]                 }
[17:42:45.677]                 ...future.workdir <- getwd()
[17:42:45.677]             }
[17:42:45.677]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.677]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.677]         }
[17:42:45.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.677]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.677]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.677]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.677]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.677]             base::names(...future.oldOptions))
[17:42:45.677]     }
[17:42:45.677]     if (FALSE) {
[17:42:45.677]     }
[17:42:45.677]     else {
[17:42:45.677]         if (TRUE) {
[17:42:45.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.677]                 open = "w")
[17:42:45.677]         }
[17:42:45.677]         else {
[17:42:45.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.677]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.677]         }
[17:42:45.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.677]             base::sink(type = "output", split = FALSE)
[17:42:45.677]             base::close(...future.stdout)
[17:42:45.677]         }, add = TRUE)
[17:42:45.677]     }
[17:42:45.677]     ...future.frame <- base::sys.nframe()
[17:42:45.677]     ...future.conditions <- base::list()
[17:42:45.677]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.677]     if (FALSE) {
[17:42:45.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.677]     }
[17:42:45.677]     ...future.result <- base::tryCatch({
[17:42:45.677]         base::withCallingHandlers({
[17:42:45.677]             ...future.value <- base::withVisible(base::local({
[17:42:45.677]                 withCallingHandlers({
[17:42:45.677]                   {
[17:42:45.677]                     b <- a * ii
[17:42:45.677]                     a <- 0
[17:42:45.677]                     b
[17:42:45.677]                   }
[17:42:45.677]                 }, immediateCondition = function(cond) {
[17:42:45.677]                   save_rds <- function (object, pathname, ...) 
[17:42:45.677]                   {
[17:42:45.677]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.677]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.677]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.677]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.677]                         fi_tmp[["mtime"]])
[17:42:45.677]                     }
[17:42:45.677]                     tryCatch({
[17:42:45.677]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.677]                     }, error = function(ex) {
[17:42:45.677]                       msg <- conditionMessage(ex)
[17:42:45.677]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.677]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.677]                         fi_tmp[["mtime"]], msg)
[17:42:45.677]                       ex$message <- msg
[17:42:45.677]                       stop(ex)
[17:42:45.677]                     })
[17:42:45.677]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.677]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.677]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.677]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.677]                       fi <- file.info(pathname)
[17:42:45.677]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.677]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.677]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.677]                         fi[["size"]], fi[["mtime"]])
[17:42:45.677]                       stop(msg)
[17:42:45.677]                     }
[17:42:45.677]                     invisible(pathname)
[17:42:45.677]                   }
[17:42:45.677]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.677]                     rootPath = tempdir()) 
[17:42:45.677]                   {
[17:42:45.677]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.677]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.677]                       tmpdir = path, fileext = ".rds")
[17:42:45.677]                     save_rds(obj, file)
[17:42:45.677]                   }
[17:42:45.677]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.677]                   {
[17:42:45.677]                     inherits <- base::inherits
[17:42:45.677]                     invokeRestart <- base::invokeRestart
[17:42:45.677]                     is.null <- base::is.null
[17:42:45.677]                     muffled <- FALSE
[17:42:45.677]                     if (inherits(cond, "message")) {
[17:42:45.677]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.677]                       if (muffled) 
[17:42:45.677]                         invokeRestart("muffleMessage")
[17:42:45.677]                     }
[17:42:45.677]                     else if (inherits(cond, "warning")) {
[17:42:45.677]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.677]                       if (muffled) 
[17:42:45.677]                         invokeRestart("muffleWarning")
[17:42:45.677]                     }
[17:42:45.677]                     else if (inherits(cond, "condition")) {
[17:42:45.677]                       if (!is.null(pattern)) {
[17:42:45.677]                         computeRestarts <- base::computeRestarts
[17:42:45.677]                         grepl <- base::grepl
[17:42:45.677]                         restarts <- computeRestarts(cond)
[17:42:45.677]                         for (restart in restarts) {
[17:42:45.677]                           name <- restart$name
[17:42:45.677]                           if (is.null(name)) 
[17:42:45.677]                             next
[17:42:45.677]                           if (!grepl(pattern, name)) 
[17:42:45.677]                             next
[17:42:45.677]                           invokeRestart(restart)
[17:42:45.677]                           muffled <- TRUE
[17:42:45.677]                           break
[17:42:45.677]                         }
[17:42:45.677]                       }
[17:42:45.677]                     }
[17:42:45.677]                     invisible(muffled)
[17:42:45.677]                   }
[17:42:45.677]                   muffleCondition(cond)
[17:42:45.677]                 })
[17:42:45.677]             }))
[17:42:45.677]             future::FutureResult(value = ...future.value$value, 
[17:42:45.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.677]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.677]                     ...future.globalenv.names))
[17:42:45.677]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.677]         }, condition = base::local({
[17:42:45.677]             c <- base::c
[17:42:45.677]             inherits <- base::inherits
[17:42:45.677]             invokeRestart <- base::invokeRestart
[17:42:45.677]             length <- base::length
[17:42:45.677]             list <- base::list
[17:42:45.677]             seq.int <- base::seq.int
[17:42:45.677]             signalCondition <- base::signalCondition
[17:42:45.677]             sys.calls <- base::sys.calls
[17:42:45.677]             `[[` <- base::`[[`
[17:42:45.677]             `+` <- base::`+`
[17:42:45.677]             `<<-` <- base::`<<-`
[17:42:45.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.677]                   3L)]
[17:42:45.677]             }
[17:42:45.677]             function(cond) {
[17:42:45.677]                 is_error <- inherits(cond, "error")
[17:42:45.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.677]                   NULL)
[17:42:45.677]                 if (is_error) {
[17:42:45.677]                   sessionInformation <- function() {
[17:42:45.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.677]                       search = base::search(), system = base::Sys.info())
[17:42:45.677]                   }
[17:42:45.677]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.677]                     cond$call), session = sessionInformation(), 
[17:42:45.677]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.677]                   signalCondition(cond)
[17:42:45.677]                 }
[17:42:45.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.677]                 "immediateCondition"))) {
[17:42:45.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.677]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.677]                   if (TRUE && !signal) {
[17:42:45.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.677]                     {
[17:42:45.677]                       inherits <- base::inherits
[17:42:45.677]                       invokeRestart <- base::invokeRestart
[17:42:45.677]                       is.null <- base::is.null
[17:42:45.677]                       muffled <- FALSE
[17:42:45.677]                       if (inherits(cond, "message")) {
[17:42:45.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.677]                         if (muffled) 
[17:42:45.677]                           invokeRestart("muffleMessage")
[17:42:45.677]                       }
[17:42:45.677]                       else if (inherits(cond, "warning")) {
[17:42:45.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.677]                         if (muffled) 
[17:42:45.677]                           invokeRestart("muffleWarning")
[17:42:45.677]                       }
[17:42:45.677]                       else if (inherits(cond, "condition")) {
[17:42:45.677]                         if (!is.null(pattern)) {
[17:42:45.677]                           computeRestarts <- base::computeRestarts
[17:42:45.677]                           grepl <- base::grepl
[17:42:45.677]                           restarts <- computeRestarts(cond)
[17:42:45.677]                           for (restart in restarts) {
[17:42:45.677]                             name <- restart$name
[17:42:45.677]                             if (is.null(name)) 
[17:42:45.677]                               next
[17:42:45.677]                             if (!grepl(pattern, name)) 
[17:42:45.677]                               next
[17:42:45.677]                             invokeRestart(restart)
[17:42:45.677]                             muffled <- TRUE
[17:42:45.677]                             break
[17:42:45.677]                           }
[17:42:45.677]                         }
[17:42:45.677]                       }
[17:42:45.677]                       invisible(muffled)
[17:42:45.677]                     }
[17:42:45.677]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.677]                   }
[17:42:45.677]                 }
[17:42:45.677]                 else {
[17:42:45.677]                   if (TRUE) {
[17:42:45.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.677]                     {
[17:42:45.677]                       inherits <- base::inherits
[17:42:45.677]                       invokeRestart <- base::invokeRestart
[17:42:45.677]                       is.null <- base::is.null
[17:42:45.677]                       muffled <- FALSE
[17:42:45.677]                       if (inherits(cond, "message")) {
[17:42:45.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.677]                         if (muffled) 
[17:42:45.677]                           invokeRestart("muffleMessage")
[17:42:45.677]                       }
[17:42:45.677]                       else if (inherits(cond, "warning")) {
[17:42:45.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.677]                         if (muffled) 
[17:42:45.677]                           invokeRestart("muffleWarning")
[17:42:45.677]                       }
[17:42:45.677]                       else if (inherits(cond, "condition")) {
[17:42:45.677]                         if (!is.null(pattern)) {
[17:42:45.677]                           computeRestarts <- base::computeRestarts
[17:42:45.677]                           grepl <- base::grepl
[17:42:45.677]                           restarts <- computeRestarts(cond)
[17:42:45.677]                           for (restart in restarts) {
[17:42:45.677]                             name <- restart$name
[17:42:45.677]                             if (is.null(name)) 
[17:42:45.677]                               next
[17:42:45.677]                             if (!grepl(pattern, name)) 
[17:42:45.677]                               next
[17:42:45.677]                             invokeRestart(restart)
[17:42:45.677]                             muffled <- TRUE
[17:42:45.677]                             break
[17:42:45.677]                           }
[17:42:45.677]                         }
[17:42:45.677]                       }
[17:42:45.677]                       invisible(muffled)
[17:42:45.677]                     }
[17:42:45.677]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.677]                   }
[17:42:45.677]                 }
[17:42:45.677]             }
[17:42:45.677]         }))
[17:42:45.677]     }, error = function(ex) {
[17:42:45.677]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.677]                 ...future.rng), started = ...future.startTime, 
[17:42:45.677]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.677]             version = "1.8"), class = "FutureResult")
[17:42:45.677]     }, finally = {
[17:42:45.677]         if (!identical(...future.workdir, getwd())) 
[17:42:45.677]             setwd(...future.workdir)
[17:42:45.677]         {
[17:42:45.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.677]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.677]             }
[17:42:45.677]             base::options(...future.oldOptions)
[17:42:45.677]             if (.Platform$OS.type == "windows") {
[17:42:45.677]                 old_names <- names(...future.oldEnvVars)
[17:42:45.677]                 envs <- base::Sys.getenv()
[17:42:45.677]                 names <- names(envs)
[17:42:45.677]                 common <- intersect(names, old_names)
[17:42:45.677]                 added <- setdiff(names, old_names)
[17:42:45.677]                 removed <- setdiff(old_names, names)
[17:42:45.677]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.677]                   envs[common]]
[17:42:45.677]                 NAMES <- toupper(changed)
[17:42:45.677]                 args <- list()
[17:42:45.677]                 for (kk in seq_along(NAMES)) {
[17:42:45.677]                   name <- changed[[kk]]
[17:42:45.677]                   NAME <- NAMES[[kk]]
[17:42:45.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.677]                     next
[17:42:45.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.677]                 }
[17:42:45.677]                 NAMES <- toupper(added)
[17:42:45.677]                 for (kk in seq_along(NAMES)) {
[17:42:45.677]                   name <- added[[kk]]
[17:42:45.677]                   NAME <- NAMES[[kk]]
[17:42:45.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.677]                     next
[17:42:45.677]                   args[[name]] <- ""
[17:42:45.677]                 }
[17:42:45.677]                 NAMES <- toupper(removed)
[17:42:45.677]                 for (kk in seq_along(NAMES)) {
[17:42:45.677]                   name <- removed[[kk]]
[17:42:45.677]                   NAME <- NAMES[[kk]]
[17:42:45.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.677]                     next
[17:42:45.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.677]                 }
[17:42:45.677]                 if (length(args) > 0) 
[17:42:45.677]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.677]             }
[17:42:45.677]             else {
[17:42:45.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.677]             }
[17:42:45.677]             {
[17:42:45.677]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.677]                   0L) {
[17:42:45.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.677]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.677]                   base::options(opts)
[17:42:45.677]                 }
[17:42:45.677]                 {
[17:42:45.677]                   {
[17:42:45.677]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.677]                     NULL
[17:42:45.677]                   }
[17:42:45.677]                   options(future.plan = NULL)
[17:42:45.677]                   if (is.na(NA_character_)) 
[17:42:45.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.677]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.677]                     envir = parent.frame()) 
[17:42:45.677]                   {
[17:42:45.677]                     default_workers <- missing(workers)
[17:42:45.677]                     if (is.function(workers)) 
[17:42:45.677]                       workers <- workers()
[17:42:45.677]                     workers <- structure(as.integer(workers), 
[17:42:45.677]                       class = class(workers))
[17:42:45.677]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.677]                       1L)
[17:42:45.677]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.677]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.677]                       if (default_workers) 
[17:42:45.677]                         supportsMulticore(warn = TRUE)
[17:42:45.677]                       return(sequential(..., envir = envir))
[17:42:45.677]                     }
[17:42:45.677]                     oopts <- options(mc.cores = workers)
[17:42:45.677]                     on.exit(options(oopts))
[17:42:45.677]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.677]                       envir = envir)
[17:42:45.677]                     if (!future$lazy) 
[17:42:45.677]                       future <- run(future)
[17:42:45.677]                     invisible(future)
[17:42:45.677]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.677]                 }
[17:42:45.677]             }
[17:42:45.677]         }
[17:42:45.677]     })
[17:42:45.677]     if (TRUE) {
[17:42:45.677]         base::sink(type = "output", split = FALSE)
[17:42:45.677]         if (TRUE) {
[17:42:45.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.677]         }
[17:42:45.677]         else {
[17:42:45.677]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.677]         }
[17:42:45.677]         base::close(...future.stdout)
[17:42:45.677]         ...future.stdout <- NULL
[17:42:45.677]     }
[17:42:45.677]     ...future.result$conditions <- ...future.conditions
[17:42:45.677]     ...future.result$finished <- base::Sys.time()
[17:42:45.677]     ...future.result
[17:42:45.677] }
[17:42:45.681] assign_globals() ...
[17:42:45.681] List of 2
[17:42:45.681]  $ a : num 1
[17:42:45.681]  $ ii: int 2
[17:42:45.681]  - attr(*, "where")=List of 2
[17:42:45.681]   ..$ a :<environment: R_EmptyEnv> 
[17:42:45.681]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.681]  - attr(*, "resolved")= logi TRUE
[17:42:45.681]  - attr(*, "total_size")= num 112
[17:42:45.681]  - attr(*, "already-done")= logi TRUE
[17:42:45.690] - copied ‘a’ to environment
[17:42:45.690] - copied ‘ii’ to environment
[17:42:45.690] assign_globals() ... done
[17:42:45.691] requestCore(): workers = 2
[17:42:45.693] MulticoreFuture started
[17:42:45.694] - Launch lazy future ... done
[17:42:45.695] plan(): Setting new future strategy stack:
[17:42:45.695] run() for ‘MulticoreFuture’ ... done
[17:42:45.695] List of future strategies:
[17:42:45.695] 1. sequential:
[17:42:45.695]    - args: function (..., envir = parent.frame())
[17:42:45.695]    - tweaked: FALSE
[17:42:45.695]    - call: NULL
[17:42:45.697] plan(): nbrOfWorkers() = 1
[17:42:45.701] plan(): Setting new future strategy stack:
[17:42:45.701] List of future strategies:
[17:42:45.701] 1. multicore:
[17:42:45.701]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.701]    - tweaked: FALSE
[17:42:45.701]    - call: plan(strategy)
[17:42:45.708] plan(): nbrOfWorkers() = 2
[17:42:45.710] run() for ‘Future’ ...
[17:42:45.710] - state: ‘created’
[17:42:45.710] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.717]   - Field: ‘label’
[17:42:45.717]   - Field: ‘local’
[17:42:45.717]   - Field: ‘owner’
[17:42:45.717]   - Field: ‘envir’
[17:42:45.717]   - Field: ‘workers’
[17:42:45.717]   - Field: ‘packages’
[17:42:45.717]   - Field: ‘gc’
[17:42:45.718]   - Field: ‘job’
[17:42:45.718]   - Field: ‘conditions’
[17:42:45.718]   - Field: ‘expr’
[17:42:45.718]   - Field: ‘uuid’
[17:42:45.718]   - Field: ‘seed’
[17:42:45.718]   - Field: ‘version’
[17:42:45.718]   - Field: ‘result’
[17:42:45.718]   - Field: ‘asynchronous’
[17:42:45.719]   - Field: ‘calls’
[17:42:45.719]   - Field: ‘globals’
[17:42:45.719]   - Field: ‘stdout’
[17:42:45.719]   - Field: ‘earlySignal’
[17:42:45.719]   - Field: ‘lazy’
[17:42:45.719]   - Field: ‘state’
[17:42:45.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.720] - Launch lazy future ...
[17:42:45.720] Packages needed by the future expression (n = 0): <none>
[17:42:45.720] Packages needed by future strategies (n = 0): <none>
[17:42:45.721] {
[17:42:45.721]     {
[17:42:45.721]         {
[17:42:45.721]             ...future.startTime <- base::Sys.time()
[17:42:45.721]             {
[17:42:45.721]                 {
[17:42:45.721]                   {
[17:42:45.721]                     {
[17:42:45.721]                       base::local({
[17:42:45.721]                         has_future <- base::requireNamespace("future", 
[17:42:45.721]                           quietly = TRUE)
[17:42:45.721]                         if (has_future) {
[17:42:45.721]                           ns <- base::getNamespace("future")
[17:42:45.721]                           version <- ns[[".package"]][["version"]]
[17:42:45.721]                           if (is.null(version)) 
[17:42:45.721]                             version <- utils::packageVersion("future")
[17:42:45.721]                         }
[17:42:45.721]                         else {
[17:42:45.721]                           version <- NULL
[17:42:45.721]                         }
[17:42:45.721]                         if (!has_future || version < "1.8.0") {
[17:42:45.721]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.721]                             "", base::R.version$version.string), 
[17:42:45.721]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.721]                               "release", "version")], collapse = " "), 
[17:42:45.721]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.721]                             info)
[17:42:45.721]                           info <- base::paste(info, collapse = "; ")
[17:42:45.721]                           if (!has_future) {
[17:42:45.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.721]                               info)
[17:42:45.721]                           }
[17:42:45.721]                           else {
[17:42:45.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.721]                               info, version)
[17:42:45.721]                           }
[17:42:45.721]                           base::stop(msg)
[17:42:45.721]                         }
[17:42:45.721]                       })
[17:42:45.721]                     }
[17:42:45.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.721]                     base::options(mc.cores = 1L)
[17:42:45.721]                   }
[17:42:45.721]                   options(future.plan = NULL)
[17:42:45.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.721]                 }
[17:42:45.721]                 ...future.workdir <- getwd()
[17:42:45.721]             }
[17:42:45.721]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.721]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.721]         }
[17:42:45.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.721]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.721]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.721]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.721]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.721]             base::names(...future.oldOptions))
[17:42:45.721]     }
[17:42:45.721]     if (FALSE) {
[17:42:45.721]     }
[17:42:45.721]     else {
[17:42:45.721]         if (TRUE) {
[17:42:45.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.721]                 open = "w")
[17:42:45.721]         }
[17:42:45.721]         else {
[17:42:45.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.721]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.721]         }
[17:42:45.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.721]             base::sink(type = "output", split = FALSE)
[17:42:45.721]             base::close(...future.stdout)
[17:42:45.721]         }, add = TRUE)
[17:42:45.721]     }
[17:42:45.721]     ...future.frame <- base::sys.nframe()
[17:42:45.721]     ...future.conditions <- base::list()
[17:42:45.721]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.721]     if (FALSE) {
[17:42:45.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.721]     }
[17:42:45.721]     ...future.result <- base::tryCatch({
[17:42:45.721]         base::withCallingHandlers({
[17:42:45.721]             ...future.value <- base::withVisible(base::local({
[17:42:45.721]                 withCallingHandlers({
[17:42:45.721]                   {
[17:42:45.721]                     b <- a * ii
[17:42:45.721]                     a <- 0
[17:42:45.721]                     b
[17:42:45.721]                   }
[17:42:45.721]                 }, immediateCondition = function(cond) {
[17:42:45.721]                   save_rds <- function (object, pathname, ...) 
[17:42:45.721]                   {
[17:42:45.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.721]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.721]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.721]                         fi_tmp[["mtime"]])
[17:42:45.721]                     }
[17:42:45.721]                     tryCatch({
[17:42:45.721]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.721]                     }, error = function(ex) {
[17:42:45.721]                       msg <- conditionMessage(ex)
[17:42:45.721]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.721]                         fi_tmp[["mtime"]], msg)
[17:42:45.721]                       ex$message <- msg
[17:42:45.721]                       stop(ex)
[17:42:45.721]                     })
[17:42:45.721]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.721]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.721]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.721]                       fi <- file.info(pathname)
[17:42:45.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.721]                         fi[["size"]], fi[["mtime"]])
[17:42:45.721]                       stop(msg)
[17:42:45.721]                     }
[17:42:45.721]                     invisible(pathname)
[17:42:45.721]                   }
[17:42:45.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.721]                     rootPath = tempdir()) 
[17:42:45.721]                   {
[17:42:45.721]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.721]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.721]                       tmpdir = path, fileext = ".rds")
[17:42:45.721]                     save_rds(obj, file)
[17:42:45.721]                   }
[17:42:45.721]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.721]                   {
[17:42:45.721]                     inherits <- base::inherits
[17:42:45.721]                     invokeRestart <- base::invokeRestart
[17:42:45.721]                     is.null <- base::is.null
[17:42:45.721]                     muffled <- FALSE
[17:42:45.721]                     if (inherits(cond, "message")) {
[17:42:45.721]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.721]                       if (muffled) 
[17:42:45.721]                         invokeRestart("muffleMessage")
[17:42:45.721]                     }
[17:42:45.721]                     else if (inherits(cond, "warning")) {
[17:42:45.721]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.721]                       if (muffled) 
[17:42:45.721]                         invokeRestart("muffleWarning")
[17:42:45.721]                     }
[17:42:45.721]                     else if (inherits(cond, "condition")) {
[17:42:45.721]                       if (!is.null(pattern)) {
[17:42:45.721]                         computeRestarts <- base::computeRestarts
[17:42:45.721]                         grepl <- base::grepl
[17:42:45.721]                         restarts <- computeRestarts(cond)
[17:42:45.721]                         for (restart in restarts) {
[17:42:45.721]                           name <- restart$name
[17:42:45.721]                           if (is.null(name)) 
[17:42:45.721]                             next
[17:42:45.721]                           if (!grepl(pattern, name)) 
[17:42:45.721]                             next
[17:42:45.721]                           invokeRestart(restart)
[17:42:45.721]                           muffled <- TRUE
[17:42:45.721]                           break
[17:42:45.721]                         }
[17:42:45.721]                       }
[17:42:45.721]                     }
[17:42:45.721]                     invisible(muffled)
[17:42:45.721]                   }
[17:42:45.721]                   muffleCondition(cond)
[17:42:45.721]                 })
[17:42:45.721]             }))
[17:42:45.721]             future::FutureResult(value = ...future.value$value, 
[17:42:45.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.721]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.721]                     ...future.globalenv.names))
[17:42:45.721]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.721]         }, condition = base::local({
[17:42:45.721]             c <- base::c
[17:42:45.721]             inherits <- base::inherits
[17:42:45.721]             invokeRestart <- base::invokeRestart
[17:42:45.721]             length <- base::length
[17:42:45.721]             list <- base::list
[17:42:45.721]             seq.int <- base::seq.int
[17:42:45.721]             signalCondition <- base::signalCondition
[17:42:45.721]             sys.calls <- base::sys.calls
[17:42:45.721]             `[[` <- base::`[[`
[17:42:45.721]             `+` <- base::`+`
[17:42:45.721]             `<<-` <- base::`<<-`
[17:42:45.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.721]                   3L)]
[17:42:45.721]             }
[17:42:45.721]             function(cond) {
[17:42:45.721]                 is_error <- inherits(cond, "error")
[17:42:45.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.721]                   NULL)
[17:42:45.721]                 if (is_error) {
[17:42:45.721]                   sessionInformation <- function() {
[17:42:45.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.721]                       search = base::search(), system = base::Sys.info())
[17:42:45.721]                   }
[17:42:45.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.721]                     cond$call), session = sessionInformation(), 
[17:42:45.721]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.721]                   signalCondition(cond)
[17:42:45.721]                 }
[17:42:45.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.721]                 "immediateCondition"))) {
[17:42:45.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.721]                   if (TRUE && !signal) {
[17:42:45.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.721]                     {
[17:42:45.721]                       inherits <- base::inherits
[17:42:45.721]                       invokeRestart <- base::invokeRestart
[17:42:45.721]                       is.null <- base::is.null
[17:42:45.721]                       muffled <- FALSE
[17:42:45.721]                       if (inherits(cond, "message")) {
[17:42:45.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.721]                         if (muffled) 
[17:42:45.721]                           invokeRestart("muffleMessage")
[17:42:45.721]                       }
[17:42:45.721]                       else if (inherits(cond, "warning")) {
[17:42:45.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.721]                         if (muffled) 
[17:42:45.721]                           invokeRestart("muffleWarning")
[17:42:45.721]                       }
[17:42:45.721]                       else if (inherits(cond, "condition")) {
[17:42:45.721]                         if (!is.null(pattern)) {
[17:42:45.721]                           computeRestarts <- base::computeRestarts
[17:42:45.721]                           grepl <- base::grepl
[17:42:45.721]                           restarts <- computeRestarts(cond)
[17:42:45.721]                           for (restart in restarts) {
[17:42:45.721]                             name <- restart$name
[17:42:45.721]                             if (is.null(name)) 
[17:42:45.721]                               next
[17:42:45.721]                             if (!grepl(pattern, name)) 
[17:42:45.721]                               next
[17:42:45.721]                             invokeRestart(restart)
[17:42:45.721]                             muffled <- TRUE
[17:42:45.721]                             break
[17:42:45.721]                           }
[17:42:45.721]                         }
[17:42:45.721]                       }
[17:42:45.721]                       invisible(muffled)
[17:42:45.721]                     }
[17:42:45.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.721]                   }
[17:42:45.721]                 }
[17:42:45.721]                 else {
[17:42:45.721]                   if (TRUE) {
[17:42:45.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.721]                     {
[17:42:45.721]                       inherits <- base::inherits
[17:42:45.721]                       invokeRestart <- base::invokeRestart
[17:42:45.721]                       is.null <- base::is.null
[17:42:45.721]                       muffled <- FALSE
[17:42:45.721]                       if (inherits(cond, "message")) {
[17:42:45.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.721]                         if (muffled) 
[17:42:45.721]                           invokeRestart("muffleMessage")
[17:42:45.721]                       }
[17:42:45.721]                       else if (inherits(cond, "warning")) {
[17:42:45.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.721]                         if (muffled) 
[17:42:45.721]                           invokeRestart("muffleWarning")
[17:42:45.721]                       }
[17:42:45.721]                       else if (inherits(cond, "condition")) {
[17:42:45.721]                         if (!is.null(pattern)) {
[17:42:45.721]                           computeRestarts <- base::computeRestarts
[17:42:45.721]                           grepl <- base::grepl
[17:42:45.721]                           restarts <- computeRestarts(cond)
[17:42:45.721]                           for (restart in restarts) {
[17:42:45.721]                             name <- restart$name
[17:42:45.721]                             if (is.null(name)) 
[17:42:45.721]                               next
[17:42:45.721]                             if (!grepl(pattern, name)) 
[17:42:45.721]                               next
[17:42:45.721]                             invokeRestart(restart)
[17:42:45.721]                             muffled <- TRUE
[17:42:45.721]                             break
[17:42:45.721]                           }
[17:42:45.721]                         }
[17:42:45.721]                       }
[17:42:45.721]                       invisible(muffled)
[17:42:45.721]                     }
[17:42:45.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.721]                   }
[17:42:45.721]                 }
[17:42:45.721]             }
[17:42:45.721]         }))
[17:42:45.721]     }, error = function(ex) {
[17:42:45.721]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.721]                 ...future.rng), started = ...future.startTime, 
[17:42:45.721]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.721]             version = "1.8"), class = "FutureResult")
[17:42:45.721]     }, finally = {
[17:42:45.721]         if (!identical(...future.workdir, getwd())) 
[17:42:45.721]             setwd(...future.workdir)
[17:42:45.721]         {
[17:42:45.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.721]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.721]             }
[17:42:45.721]             base::options(...future.oldOptions)
[17:42:45.721]             if (.Platform$OS.type == "windows") {
[17:42:45.721]                 old_names <- names(...future.oldEnvVars)
[17:42:45.721]                 envs <- base::Sys.getenv()
[17:42:45.721]                 names <- names(envs)
[17:42:45.721]                 common <- intersect(names, old_names)
[17:42:45.721]                 added <- setdiff(names, old_names)
[17:42:45.721]                 removed <- setdiff(old_names, names)
[17:42:45.721]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.721]                   envs[common]]
[17:42:45.721]                 NAMES <- toupper(changed)
[17:42:45.721]                 args <- list()
[17:42:45.721]                 for (kk in seq_along(NAMES)) {
[17:42:45.721]                   name <- changed[[kk]]
[17:42:45.721]                   NAME <- NAMES[[kk]]
[17:42:45.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.721]                     next
[17:42:45.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.721]                 }
[17:42:45.721]                 NAMES <- toupper(added)
[17:42:45.721]                 for (kk in seq_along(NAMES)) {
[17:42:45.721]                   name <- added[[kk]]
[17:42:45.721]                   NAME <- NAMES[[kk]]
[17:42:45.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.721]                     next
[17:42:45.721]                   args[[name]] <- ""
[17:42:45.721]                 }
[17:42:45.721]                 NAMES <- toupper(removed)
[17:42:45.721]                 for (kk in seq_along(NAMES)) {
[17:42:45.721]                   name <- removed[[kk]]
[17:42:45.721]                   NAME <- NAMES[[kk]]
[17:42:45.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.721]                     next
[17:42:45.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.721]                 }
[17:42:45.721]                 if (length(args) > 0) 
[17:42:45.721]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.721]             }
[17:42:45.721]             else {
[17:42:45.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.721]             }
[17:42:45.721]             {
[17:42:45.721]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.721]                   0L) {
[17:42:45.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.721]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.721]                   base::options(opts)
[17:42:45.721]                 }
[17:42:45.721]                 {
[17:42:45.721]                   {
[17:42:45.721]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.721]                     NULL
[17:42:45.721]                   }
[17:42:45.721]                   options(future.plan = NULL)
[17:42:45.721]                   if (is.na(NA_character_)) 
[17:42:45.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.721]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.721]                     envir = parent.frame()) 
[17:42:45.721]                   {
[17:42:45.721]                     default_workers <- missing(workers)
[17:42:45.721]                     if (is.function(workers)) 
[17:42:45.721]                       workers <- workers()
[17:42:45.721]                     workers <- structure(as.integer(workers), 
[17:42:45.721]                       class = class(workers))
[17:42:45.721]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.721]                       1L)
[17:42:45.721]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.721]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.721]                       if (default_workers) 
[17:42:45.721]                         supportsMulticore(warn = TRUE)
[17:42:45.721]                       return(sequential(..., envir = envir))
[17:42:45.721]                     }
[17:42:45.721]                     oopts <- options(mc.cores = workers)
[17:42:45.721]                     on.exit(options(oopts))
[17:42:45.721]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.721]                       envir = envir)
[17:42:45.721]                     if (!future$lazy) 
[17:42:45.721]                       future <- run(future)
[17:42:45.721]                     invisible(future)
[17:42:45.721]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.721]                 }
[17:42:45.721]             }
[17:42:45.721]         }
[17:42:45.721]     })
[17:42:45.721]     if (TRUE) {
[17:42:45.721]         base::sink(type = "output", split = FALSE)
[17:42:45.721]         if (TRUE) {
[17:42:45.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.721]         }
[17:42:45.721]         else {
[17:42:45.721]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.721]         }
[17:42:45.721]         base::close(...future.stdout)
[17:42:45.721]         ...future.stdout <- NULL
[17:42:45.721]     }
[17:42:45.721]     ...future.result$conditions <- ...future.conditions
[17:42:45.721]     ...future.result$finished <- base::Sys.time()
[17:42:45.721]     ...future.result
[17:42:45.721] }
[17:42:45.724] assign_globals() ...
[17:42:45.724] List of 2
[17:42:45.724]  $ a : num 1
[17:42:45.724]  $ ii: int 3
[17:42:45.724]  - attr(*, "where")=List of 2
[17:42:45.724]   ..$ a :<environment: R_EmptyEnv> 
[17:42:45.724]   ..$ ii:<environment: R_EmptyEnv> 
[17:42:45.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.724]  - attr(*, "resolved")= logi TRUE
[17:42:45.724]  - attr(*, "total_size")= num 112
[17:42:45.724]  - attr(*, "already-done")= logi TRUE
[17:42:45.728] - copied ‘a’ to environment
[17:42:45.728] - copied ‘ii’ to environment
[17:42:45.728] assign_globals() ... done
[17:42:45.728] requestCore(): workers = 2
[17:42:45.730] MulticoreFuture started
[17:42:45.730] - Launch lazy future ... done
[17:42:45.731] run() for ‘MulticoreFuture’ ... done
[17:42:45.731] plan(): Setting new future strategy stack:
[17:42:45.732] List of future strategies:
[17:42:45.732] 1. sequential:
[17:42:45.732]    - args: function (..., envir = parent.frame())
[17:42:45.732]    - tweaked: FALSE
[17:42:45.732]    - call: NULL
[17:42:45.732] plan(): nbrOfWorkers() = 1
[17:42:45.735] plan(): Setting new future strategy stack:
[17:42:45.735] List of future strategies:
[17:42:45.735] 1. multicore:
[17:42:45.735]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.735]    - tweaked: FALSE
[17:42:45.735]    - call: plan(strategy)
[17:42:45.740] plan(): nbrOfWorkers() = 2
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.742] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.742] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.743] 
[17:42:45.743] Searching for globals ... DONE
[17:42:45.743] - globals: [0] <none>
[17:42:45.743] getGlobalsAndPackages() ... DONE
[17:42:45.744] run() for ‘Future’ ...
[17:42:45.744] - state: ‘created’
[17:42:45.744] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.748] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.749]   - Field: ‘label’
[17:42:45.749]   - Field: ‘local’
[17:42:45.749]   - Field: ‘owner’
[17:42:45.749]   - Field: ‘envir’
[17:42:45.749]   - Field: ‘workers’
[17:42:45.749]   - Field: ‘packages’
[17:42:45.749]   - Field: ‘gc’
[17:42:45.749]   - Field: ‘job’
[17:42:45.749]   - Field: ‘conditions’
[17:42:45.750]   - Field: ‘expr’
[17:42:45.750]   - Field: ‘uuid’
[17:42:45.750]   - Field: ‘seed’
[17:42:45.750]   - Field: ‘version’
[17:42:45.750]   - Field: ‘result’
[17:42:45.750]   - Field: ‘asynchronous’
[17:42:45.750]   - Field: ‘calls’
[17:42:45.750]   - Field: ‘globals’
[17:42:45.751]   - Field: ‘stdout’
[17:42:45.751]   - Field: ‘earlySignal’
[17:42:45.751]   - Field: ‘lazy’
[17:42:45.751]   - Field: ‘state’
[17:42:45.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.751] - Launch lazy future ...
[17:42:45.752] Packages needed by the future expression (n = 0): <none>
[17:42:45.752] Packages needed by future strategies (n = 0): <none>
[17:42:45.755] {
[17:42:45.755]     {
[17:42:45.755]         {
[17:42:45.755]             ...future.startTime <- base::Sys.time()
[17:42:45.755]             {
[17:42:45.755]                 {
[17:42:45.755]                   {
[17:42:45.755]                     {
[17:42:45.755]                       base::local({
[17:42:45.755]                         has_future <- base::requireNamespace("future", 
[17:42:45.755]                           quietly = TRUE)
[17:42:45.755]                         if (has_future) {
[17:42:45.755]                           ns <- base::getNamespace("future")
[17:42:45.755]                           version <- ns[[".package"]][["version"]]
[17:42:45.755]                           if (is.null(version)) 
[17:42:45.755]                             version <- utils::packageVersion("future")
[17:42:45.755]                         }
[17:42:45.755]                         else {
[17:42:45.755]                           version <- NULL
[17:42:45.755]                         }
[17:42:45.755]                         if (!has_future || version < "1.8.0") {
[17:42:45.755]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.755]                             "", base::R.version$version.string), 
[17:42:45.755]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.755]                               "release", "version")], collapse = " "), 
[17:42:45.755]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.755]                             info)
[17:42:45.755]                           info <- base::paste(info, collapse = "; ")
[17:42:45.755]                           if (!has_future) {
[17:42:45.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.755]                               info)
[17:42:45.755]                           }
[17:42:45.755]                           else {
[17:42:45.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.755]                               info, version)
[17:42:45.755]                           }
[17:42:45.755]                           base::stop(msg)
[17:42:45.755]                         }
[17:42:45.755]                       })
[17:42:45.755]                     }
[17:42:45.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.755]                     base::options(mc.cores = 1L)
[17:42:45.755]                   }
[17:42:45.755]                   options(future.plan = NULL)
[17:42:45.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.755]                 }
[17:42:45.755]                 ...future.workdir <- getwd()
[17:42:45.755]             }
[17:42:45.755]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.755]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.755]         }
[17:42:45.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.755]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.755]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.755]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.755]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.755]             base::names(...future.oldOptions))
[17:42:45.755]     }
[17:42:45.755]     if (FALSE) {
[17:42:45.755]     }
[17:42:45.755]     else {
[17:42:45.755]         if (TRUE) {
[17:42:45.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.755]                 open = "w")
[17:42:45.755]         }
[17:42:45.755]         else {
[17:42:45.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.755]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.755]         }
[17:42:45.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.755]             base::sink(type = "output", split = FALSE)
[17:42:45.755]             base::close(...future.stdout)
[17:42:45.755]         }, add = TRUE)
[17:42:45.755]     }
[17:42:45.755]     ...future.frame <- base::sys.nframe()
[17:42:45.755]     ...future.conditions <- base::list()
[17:42:45.755]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.755]     if (FALSE) {
[17:42:45.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.755]     }
[17:42:45.755]     ...future.result <- base::tryCatch({
[17:42:45.755]         base::withCallingHandlers({
[17:42:45.755]             ...future.value <- base::withVisible(base::local({
[17:42:45.755]                 withCallingHandlers({
[17:42:45.755]                   1
[17:42:45.755]                 }, immediateCondition = function(cond) {
[17:42:45.755]                   save_rds <- function (object, pathname, ...) 
[17:42:45.755]                   {
[17:42:45.755]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.755]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.755]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.755]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.755]                         fi_tmp[["mtime"]])
[17:42:45.755]                     }
[17:42:45.755]                     tryCatch({
[17:42:45.755]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.755]                     }, error = function(ex) {
[17:42:45.755]                       msg <- conditionMessage(ex)
[17:42:45.755]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.755]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.755]                         fi_tmp[["mtime"]], msg)
[17:42:45.755]                       ex$message <- msg
[17:42:45.755]                       stop(ex)
[17:42:45.755]                     })
[17:42:45.755]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.755]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.755]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.755]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.755]                       fi <- file.info(pathname)
[17:42:45.755]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.755]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.755]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.755]                         fi[["size"]], fi[["mtime"]])
[17:42:45.755]                       stop(msg)
[17:42:45.755]                     }
[17:42:45.755]                     invisible(pathname)
[17:42:45.755]                   }
[17:42:45.755]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.755]                     rootPath = tempdir()) 
[17:42:45.755]                   {
[17:42:45.755]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.755]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.755]                       tmpdir = path, fileext = ".rds")
[17:42:45.755]                     save_rds(obj, file)
[17:42:45.755]                   }
[17:42:45.755]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.755]                   {
[17:42:45.755]                     inherits <- base::inherits
[17:42:45.755]                     invokeRestart <- base::invokeRestart
[17:42:45.755]                     is.null <- base::is.null
[17:42:45.755]                     muffled <- FALSE
[17:42:45.755]                     if (inherits(cond, "message")) {
[17:42:45.755]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.755]                       if (muffled) 
[17:42:45.755]                         invokeRestart("muffleMessage")
[17:42:45.755]                     }
[17:42:45.755]                     else if (inherits(cond, "warning")) {
[17:42:45.755]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.755]                       if (muffled) 
[17:42:45.755]                         invokeRestart("muffleWarning")
[17:42:45.755]                     }
[17:42:45.755]                     else if (inherits(cond, "condition")) {
[17:42:45.755]                       if (!is.null(pattern)) {
[17:42:45.755]                         computeRestarts <- base::computeRestarts
[17:42:45.755]                         grepl <- base::grepl
[17:42:45.755]                         restarts <- computeRestarts(cond)
[17:42:45.755]                         for (restart in restarts) {
[17:42:45.755]                           name <- restart$name
[17:42:45.755]                           if (is.null(name)) 
[17:42:45.755]                             next
[17:42:45.755]                           if (!grepl(pattern, name)) 
[17:42:45.755]                             next
[17:42:45.755]                           invokeRestart(restart)
[17:42:45.755]                           muffled <- TRUE
[17:42:45.755]                           break
[17:42:45.755]                         }
[17:42:45.755]                       }
[17:42:45.755]                     }
[17:42:45.755]                     invisible(muffled)
[17:42:45.755]                   }
[17:42:45.755]                   muffleCondition(cond)
[17:42:45.755]                 })
[17:42:45.755]             }))
[17:42:45.755]             future::FutureResult(value = ...future.value$value, 
[17:42:45.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.755]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.755]                     ...future.globalenv.names))
[17:42:45.755]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.755]         }, condition = base::local({
[17:42:45.755]             c <- base::c
[17:42:45.755]             inherits <- base::inherits
[17:42:45.755]             invokeRestart <- base::invokeRestart
[17:42:45.755]             length <- base::length
[17:42:45.755]             list <- base::list
[17:42:45.755]             seq.int <- base::seq.int
[17:42:45.755]             signalCondition <- base::signalCondition
[17:42:45.755]             sys.calls <- base::sys.calls
[17:42:45.755]             `[[` <- base::`[[`
[17:42:45.755]             `+` <- base::`+`
[17:42:45.755]             `<<-` <- base::`<<-`
[17:42:45.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.755]                   3L)]
[17:42:45.755]             }
[17:42:45.755]             function(cond) {
[17:42:45.755]                 is_error <- inherits(cond, "error")
[17:42:45.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.755]                   NULL)
[17:42:45.755]                 if (is_error) {
[17:42:45.755]                   sessionInformation <- function() {
[17:42:45.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.755]                       search = base::search(), system = base::Sys.info())
[17:42:45.755]                   }
[17:42:45.755]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.755]                     cond$call), session = sessionInformation(), 
[17:42:45.755]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.755]                   signalCondition(cond)
[17:42:45.755]                 }
[17:42:45.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.755]                 "immediateCondition"))) {
[17:42:45.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.755]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.755]                   if (TRUE && !signal) {
[17:42:45.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.755]                     {
[17:42:45.755]                       inherits <- base::inherits
[17:42:45.755]                       invokeRestart <- base::invokeRestart
[17:42:45.755]                       is.null <- base::is.null
[17:42:45.755]                       muffled <- FALSE
[17:42:45.755]                       if (inherits(cond, "message")) {
[17:42:45.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.755]                         if (muffled) 
[17:42:45.755]                           invokeRestart("muffleMessage")
[17:42:45.755]                       }
[17:42:45.755]                       else if (inherits(cond, "warning")) {
[17:42:45.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.755]                         if (muffled) 
[17:42:45.755]                           invokeRestart("muffleWarning")
[17:42:45.755]                       }
[17:42:45.755]                       else if (inherits(cond, "condition")) {
[17:42:45.755]                         if (!is.null(pattern)) {
[17:42:45.755]                           computeRestarts <- base::computeRestarts
[17:42:45.755]                           grepl <- base::grepl
[17:42:45.755]                           restarts <- computeRestarts(cond)
[17:42:45.755]                           for (restart in restarts) {
[17:42:45.755]                             name <- restart$name
[17:42:45.755]                             if (is.null(name)) 
[17:42:45.755]                               next
[17:42:45.755]                             if (!grepl(pattern, name)) 
[17:42:45.755]                               next
[17:42:45.755]                             invokeRestart(restart)
[17:42:45.755]                             muffled <- TRUE
[17:42:45.755]                             break
[17:42:45.755]                           }
[17:42:45.755]                         }
[17:42:45.755]                       }
[17:42:45.755]                       invisible(muffled)
[17:42:45.755]                     }
[17:42:45.755]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.755]                   }
[17:42:45.755]                 }
[17:42:45.755]                 else {
[17:42:45.755]                   if (TRUE) {
[17:42:45.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.755]                     {
[17:42:45.755]                       inherits <- base::inherits
[17:42:45.755]                       invokeRestart <- base::invokeRestart
[17:42:45.755]                       is.null <- base::is.null
[17:42:45.755]                       muffled <- FALSE
[17:42:45.755]                       if (inherits(cond, "message")) {
[17:42:45.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.755]                         if (muffled) 
[17:42:45.755]                           invokeRestart("muffleMessage")
[17:42:45.755]                       }
[17:42:45.755]                       else if (inherits(cond, "warning")) {
[17:42:45.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.755]                         if (muffled) 
[17:42:45.755]                           invokeRestart("muffleWarning")
[17:42:45.755]                       }
[17:42:45.755]                       else if (inherits(cond, "condition")) {
[17:42:45.755]                         if (!is.null(pattern)) {
[17:42:45.755]                           computeRestarts <- base::computeRestarts
[17:42:45.755]                           grepl <- base::grepl
[17:42:45.755]                           restarts <- computeRestarts(cond)
[17:42:45.755]                           for (restart in restarts) {
[17:42:45.755]                             name <- restart$name
[17:42:45.755]                             if (is.null(name)) 
[17:42:45.755]                               next
[17:42:45.755]                             if (!grepl(pattern, name)) 
[17:42:45.755]                               next
[17:42:45.755]                             invokeRestart(restart)
[17:42:45.755]                             muffled <- TRUE
[17:42:45.755]                             break
[17:42:45.755]                           }
[17:42:45.755]                         }
[17:42:45.755]                       }
[17:42:45.755]                       invisible(muffled)
[17:42:45.755]                     }
[17:42:45.755]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.755]                   }
[17:42:45.755]                 }
[17:42:45.755]             }
[17:42:45.755]         }))
[17:42:45.755]     }, error = function(ex) {
[17:42:45.755]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.755]                 ...future.rng), started = ...future.startTime, 
[17:42:45.755]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.755]             version = "1.8"), class = "FutureResult")
[17:42:45.755]     }, finally = {
[17:42:45.755]         if (!identical(...future.workdir, getwd())) 
[17:42:45.755]             setwd(...future.workdir)
[17:42:45.755]         {
[17:42:45.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.755]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.755]             }
[17:42:45.755]             base::options(...future.oldOptions)
[17:42:45.755]             if (.Platform$OS.type == "windows") {
[17:42:45.755]                 old_names <- names(...future.oldEnvVars)
[17:42:45.755]                 envs <- base::Sys.getenv()
[17:42:45.755]                 names <- names(envs)
[17:42:45.755]                 common <- intersect(names, old_names)
[17:42:45.755]                 added <- setdiff(names, old_names)
[17:42:45.755]                 removed <- setdiff(old_names, names)
[17:42:45.755]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.755]                   envs[common]]
[17:42:45.755]                 NAMES <- toupper(changed)
[17:42:45.755]                 args <- list()
[17:42:45.755]                 for (kk in seq_along(NAMES)) {
[17:42:45.755]                   name <- changed[[kk]]
[17:42:45.755]                   NAME <- NAMES[[kk]]
[17:42:45.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.755]                     next
[17:42:45.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.755]                 }
[17:42:45.755]                 NAMES <- toupper(added)
[17:42:45.755]                 for (kk in seq_along(NAMES)) {
[17:42:45.755]                   name <- added[[kk]]
[17:42:45.755]                   NAME <- NAMES[[kk]]
[17:42:45.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.755]                     next
[17:42:45.755]                   args[[name]] <- ""
[17:42:45.755]                 }
[17:42:45.755]                 NAMES <- toupper(removed)
[17:42:45.755]                 for (kk in seq_along(NAMES)) {
[17:42:45.755]                   name <- removed[[kk]]
[17:42:45.755]                   NAME <- NAMES[[kk]]
[17:42:45.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.755]                     next
[17:42:45.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.755]                 }
[17:42:45.755]                 if (length(args) > 0) 
[17:42:45.755]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.755]             }
[17:42:45.755]             else {
[17:42:45.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.755]             }
[17:42:45.755]             {
[17:42:45.755]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.755]                   0L) {
[17:42:45.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.755]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.755]                   base::options(opts)
[17:42:45.755]                 }
[17:42:45.755]                 {
[17:42:45.755]                   {
[17:42:45.755]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.755]                     NULL
[17:42:45.755]                   }
[17:42:45.755]                   options(future.plan = NULL)
[17:42:45.755]                   if (is.na(NA_character_)) 
[17:42:45.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.755]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.755]                     envir = parent.frame()) 
[17:42:45.755]                   {
[17:42:45.755]                     default_workers <- missing(workers)
[17:42:45.755]                     if (is.function(workers)) 
[17:42:45.755]                       workers <- workers()
[17:42:45.755]                     workers <- structure(as.integer(workers), 
[17:42:45.755]                       class = class(workers))
[17:42:45.755]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.755]                       1L)
[17:42:45.755]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.755]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.755]                       if (default_workers) 
[17:42:45.755]                         supportsMulticore(warn = TRUE)
[17:42:45.755]                       return(sequential(..., envir = envir))
[17:42:45.755]                     }
[17:42:45.755]                     oopts <- options(mc.cores = workers)
[17:42:45.755]                     on.exit(options(oopts))
[17:42:45.755]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.755]                       envir = envir)
[17:42:45.755]                     if (!future$lazy) 
[17:42:45.755]                       future <- run(future)
[17:42:45.755]                     invisible(future)
[17:42:45.755]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.755]                 }
[17:42:45.755]             }
[17:42:45.755]         }
[17:42:45.755]     })
[17:42:45.755]     if (TRUE) {
[17:42:45.755]         base::sink(type = "output", split = FALSE)
[17:42:45.755]         if (TRUE) {
[17:42:45.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.755]         }
[17:42:45.755]         else {
[17:42:45.755]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.755]         }
[17:42:45.755]         base::close(...future.stdout)
[17:42:45.755]         ...future.stdout <- NULL
[17:42:45.755]     }
[17:42:45.755]     ...future.result$conditions <- ...future.conditions
[17:42:45.755]     ...future.result$finished <- base::Sys.time()
[17:42:45.755]     ...future.result
[17:42:45.755] }
[17:42:45.758] requestCore(): workers = 2
[17:42:45.761] MulticoreFuture started
[17:42:45.761] - Launch lazy future ... done
[17:42:45.762] plan(): Setting new future strategy stack:
[17:42:45.762] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.763] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.763] List of future strategies:
[17:42:45.763] 1. sequential:
[17:42:45.763]    - args: function (..., envir = parent.frame())
[17:42:45.763]    - tweaked: FALSE
[17:42:45.763]    - call: NULL
[17:42:45.764] Searching for globals...
[17:42:45.764] plan(): nbrOfWorkers() = 1
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.767] plan(): Setting new future strategy stack:
[17:42:45.767] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.768] Searching for globals ... DONE
[17:42:45.768] Resolving globals: TRUE
[17:42:45.767] List of future strategies:
[17:42:45.767] 1. multicore:
[17:42:45.767]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.767]    - tweaked: FALSE
[17:42:45.767]    - call: plan(strategy)
[17:42:45.768] Resolving any globals that are futures ...
[17:42:45.768] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.769] Resolving any globals that are futures ... DONE
[17:42:45.770] Resolving futures part of globals (recursively) ...
[17:42:45.772] resolve() on list ...
[17:42:45.772]  recursive: 99
[17:42:45.772]  length: 1
[17:42:45.773]  elements: ‘a’
[17:42:45.774] plan(): nbrOfWorkers() = 2
[17:42:45.775] Future #1
[17:42:45.776] A MulticoreFuture was resolved
[17:42:45.777]  length: 0 (resolved future 1)
[17:42:45.777] resolve() on list ... DONE
[17:42:45.777] - globals: [1] ‘a’
[17:42:45.777] Resolving futures part of globals (recursively) ... DONE
[17:42:45.781] The total size of the 1 globals is 1.55 MiB (1629456 bytes)
[17:42:45.781] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:45.782] - globals: [1] ‘a’
[17:42:45.782] - packages: [1] ‘future’
[17:42:45.782] getGlobalsAndPackages() ... DONE
[17:42:45.782] run() for ‘Future’ ...
[17:42:45.782] - state: ‘created’
[17:42:45.782] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.786] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.787]   - Field: ‘label’
[17:42:45.787]   - Field: ‘local’
[17:42:45.787]   - Field: ‘owner’
[17:42:45.787]   - Field: ‘envir’
[17:42:45.787]   - Field: ‘workers’
[17:42:45.787]   - Field: ‘packages’
[17:42:45.787]   - Field: ‘gc’
[17:42:45.787]   - Field: ‘job’
[17:42:45.788]   - Field: ‘conditions’
[17:42:45.788]   - Field: ‘expr’
[17:42:45.788]   - Field: ‘uuid’
[17:42:45.788]   - Field: ‘seed’
[17:42:45.788]   - Field: ‘version’
[17:42:45.788]   - Field: ‘result’
[17:42:45.788]   - Field: ‘asynchronous’
[17:42:45.788]   - Field: ‘calls’
[17:42:45.788]   - Field: ‘globals’
[17:42:45.789]   - Field: ‘stdout’
[17:42:45.789]   - Field: ‘earlySignal’
[17:42:45.789]   - Field: ‘lazy’
[17:42:45.789]   - Field: ‘state’
[17:42:45.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.789] - Launch lazy future ...
[17:42:45.789] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.790] Packages needed by future strategies (n = 0): <none>
[17:42:45.790] {
[17:42:45.790]     {
[17:42:45.790]         {
[17:42:45.790]             ...future.startTime <- base::Sys.time()
[17:42:45.790]             {
[17:42:45.790]                 {
[17:42:45.790]                   {
[17:42:45.790]                     {
[17:42:45.790]                       {
[17:42:45.790]                         base::local({
[17:42:45.790]                           has_future <- base::requireNamespace("future", 
[17:42:45.790]                             quietly = TRUE)
[17:42:45.790]                           if (has_future) {
[17:42:45.790]                             ns <- base::getNamespace("future")
[17:42:45.790]                             version <- ns[[".package"]][["version"]]
[17:42:45.790]                             if (is.null(version)) 
[17:42:45.790]                               version <- utils::packageVersion("future")
[17:42:45.790]                           }
[17:42:45.790]                           else {
[17:42:45.790]                             version <- NULL
[17:42:45.790]                           }
[17:42:45.790]                           if (!has_future || version < "1.8.0") {
[17:42:45.790]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.790]                               "", base::R.version$version.string), 
[17:42:45.790]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.790]                                 base::R.version$platform, 8 * 
[17:42:45.790]                                   base::.Machine$sizeof.pointer), 
[17:42:45.790]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.790]                                 "release", "version")], collapse = " "), 
[17:42:45.790]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.790]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.790]                               info)
[17:42:45.790]                             info <- base::paste(info, collapse = "; ")
[17:42:45.790]                             if (!has_future) {
[17:42:45.790]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.790]                                 info)
[17:42:45.790]                             }
[17:42:45.790]                             else {
[17:42:45.790]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.790]                                 info, version)
[17:42:45.790]                             }
[17:42:45.790]                             base::stop(msg)
[17:42:45.790]                           }
[17:42:45.790]                         })
[17:42:45.790]                       }
[17:42:45.790]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.790]                       base::options(mc.cores = 1L)
[17:42:45.790]                     }
[17:42:45.790]                     base::local({
[17:42:45.790]                       for (pkg in "future") {
[17:42:45.790]                         base::loadNamespace(pkg)
[17:42:45.790]                         base::library(pkg, character.only = TRUE)
[17:42:45.790]                       }
[17:42:45.790]                     })
[17:42:45.790]                   }
[17:42:45.790]                   options(future.plan = NULL)
[17:42:45.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.790]                 }
[17:42:45.790]                 ...future.workdir <- getwd()
[17:42:45.790]             }
[17:42:45.790]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.790]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.790]         }
[17:42:45.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.790]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.790]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.790]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.790]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.790]             base::names(...future.oldOptions))
[17:42:45.790]     }
[17:42:45.790]     if (FALSE) {
[17:42:45.790]     }
[17:42:45.790]     else {
[17:42:45.790]         if (TRUE) {
[17:42:45.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.790]                 open = "w")
[17:42:45.790]         }
[17:42:45.790]         else {
[17:42:45.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.790]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.790]         }
[17:42:45.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.790]             base::sink(type = "output", split = FALSE)
[17:42:45.790]             base::close(...future.stdout)
[17:42:45.790]         }, add = TRUE)
[17:42:45.790]     }
[17:42:45.790]     ...future.frame <- base::sys.nframe()
[17:42:45.790]     ...future.conditions <- base::list()
[17:42:45.790]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.790]     if (FALSE) {
[17:42:45.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.790]     }
[17:42:45.790]     ...future.result <- base::tryCatch({
[17:42:45.790]         base::withCallingHandlers({
[17:42:45.790]             ...future.value <- base::withVisible(base::local({
[17:42:45.790]                 withCallingHandlers({
[17:42:45.790]                   value(a) + 1
[17:42:45.790]                 }, immediateCondition = function(cond) {
[17:42:45.790]                   save_rds <- function (object, pathname, ...) 
[17:42:45.790]                   {
[17:42:45.790]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.790]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.790]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.790]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.790]                         fi_tmp[["mtime"]])
[17:42:45.790]                     }
[17:42:45.790]                     tryCatch({
[17:42:45.790]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.790]                     }, error = function(ex) {
[17:42:45.790]                       msg <- conditionMessage(ex)
[17:42:45.790]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.790]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.790]                         fi_tmp[["mtime"]], msg)
[17:42:45.790]                       ex$message <- msg
[17:42:45.790]                       stop(ex)
[17:42:45.790]                     })
[17:42:45.790]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.790]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.790]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.790]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.790]                       fi <- file.info(pathname)
[17:42:45.790]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.790]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.790]                         fi[["size"]], fi[["mtime"]])
[17:42:45.790]                       stop(msg)
[17:42:45.790]                     }
[17:42:45.790]                     invisible(pathname)
[17:42:45.790]                   }
[17:42:45.790]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.790]                     rootPath = tempdir()) 
[17:42:45.790]                   {
[17:42:45.790]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.790]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.790]                       tmpdir = path, fileext = ".rds")
[17:42:45.790]                     save_rds(obj, file)
[17:42:45.790]                   }
[17:42:45.790]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.790]                   {
[17:42:45.790]                     inherits <- base::inherits
[17:42:45.790]                     invokeRestart <- base::invokeRestart
[17:42:45.790]                     is.null <- base::is.null
[17:42:45.790]                     muffled <- FALSE
[17:42:45.790]                     if (inherits(cond, "message")) {
[17:42:45.790]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.790]                       if (muffled) 
[17:42:45.790]                         invokeRestart("muffleMessage")
[17:42:45.790]                     }
[17:42:45.790]                     else if (inherits(cond, "warning")) {
[17:42:45.790]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.790]                       if (muffled) 
[17:42:45.790]                         invokeRestart("muffleWarning")
[17:42:45.790]                     }
[17:42:45.790]                     else if (inherits(cond, "condition")) {
[17:42:45.790]                       if (!is.null(pattern)) {
[17:42:45.790]                         computeRestarts <- base::computeRestarts
[17:42:45.790]                         grepl <- base::grepl
[17:42:45.790]                         restarts <- computeRestarts(cond)
[17:42:45.790]                         for (restart in restarts) {
[17:42:45.790]                           name <- restart$name
[17:42:45.790]                           if (is.null(name)) 
[17:42:45.790]                             next
[17:42:45.790]                           if (!grepl(pattern, name)) 
[17:42:45.790]                             next
[17:42:45.790]                           invokeRestart(restart)
[17:42:45.790]                           muffled <- TRUE
[17:42:45.790]                           break
[17:42:45.790]                         }
[17:42:45.790]                       }
[17:42:45.790]                     }
[17:42:45.790]                     invisible(muffled)
[17:42:45.790]                   }
[17:42:45.790]                   muffleCondition(cond)
[17:42:45.790]                 })
[17:42:45.790]             }))
[17:42:45.790]             future::FutureResult(value = ...future.value$value, 
[17:42:45.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.790]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.790]                     ...future.globalenv.names))
[17:42:45.790]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.790]         }, condition = base::local({
[17:42:45.790]             c <- base::c
[17:42:45.790]             inherits <- base::inherits
[17:42:45.790]             invokeRestart <- base::invokeRestart
[17:42:45.790]             length <- base::length
[17:42:45.790]             list <- base::list
[17:42:45.790]             seq.int <- base::seq.int
[17:42:45.790]             signalCondition <- base::signalCondition
[17:42:45.790]             sys.calls <- base::sys.calls
[17:42:45.790]             `[[` <- base::`[[`
[17:42:45.790]             `+` <- base::`+`
[17:42:45.790]             `<<-` <- base::`<<-`
[17:42:45.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.790]                   3L)]
[17:42:45.790]             }
[17:42:45.790]             function(cond) {
[17:42:45.790]                 is_error <- inherits(cond, "error")
[17:42:45.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.790]                   NULL)
[17:42:45.790]                 if (is_error) {
[17:42:45.790]                   sessionInformation <- function() {
[17:42:45.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.790]                       search = base::search(), system = base::Sys.info())
[17:42:45.790]                   }
[17:42:45.790]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.790]                     cond$call), session = sessionInformation(), 
[17:42:45.790]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.790]                   signalCondition(cond)
[17:42:45.790]                 }
[17:42:45.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.790]                 "immediateCondition"))) {
[17:42:45.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.790]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.790]                   if (TRUE && !signal) {
[17:42:45.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.790]                     {
[17:42:45.790]                       inherits <- base::inherits
[17:42:45.790]                       invokeRestart <- base::invokeRestart
[17:42:45.790]                       is.null <- base::is.null
[17:42:45.790]                       muffled <- FALSE
[17:42:45.790]                       if (inherits(cond, "message")) {
[17:42:45.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.790]                         if (muffled) 
[17:42:45.790]                           invokeRestart("muffleMessage")
[17:42:45.790]                       }
[17:42:45.790]                       else if (inherits(cond, "warning")) {
[17:42:45.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.790]                         if (muffled) 
[17:42:45.790]                           invokeRestart("muffleWarning")
[17:42:45.790]                       }
[17:42:45.790]                       else if (inherits(cond, "condition")) {
[17:42:45.790]                         if (!is.null(pattern)) {
[17:42:45.790]                           computeRestarts <- base::computeRestarts
[17:42:45.790]                           grepl <- base::grepl
[17:42:45.790]                           restarts <- computeRestarts(cond)
[17:42:45.790]                           for (restart in restarts) {
[17:42:45.790]                             name <- restart$name
[17:42:45.790]                             if (is.null(name)) 
[17:42:45.790]                               next
[17:42:45.790]                             if (!grepl(pattern, name)) 
[17:42:45.790]                               next
[17:42:45.790]                             invokeRestart(restart)
[17:42:45.790]                             muffled <- TRUE
[17:42:45.790]                             break
[17:42:45.790]                           }
[17:42:45.790]                         }
[17:42:45.790]                       }
[17:42:45.790]                       invisible(muffled)
[17:42:45.790]                     }
[17:42:45.790]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.790]                   }
[17:42:45.790]                 }
[17:42:45.790]                 else {
[17:42:45.790]                   if (TRUE) {
[17:42:45.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.790]                     {
[17:42:45.790]                       inherits <- base::inherits
[17:42:45.790]                       invokeRestart <- base::invokeRestart
[17:42:45.790]                       is.null <- base::is.null
[17:42:45.790]                       muffled <- FALSE
[17:42:45.790]                       if (inherits(cond, "message")) {
[17:42:45.790]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.790]                         if (muffled) 
[17:42:45.790]                           invokeRestart("muffleMessage")
[17:42:45.790]                       }
[17:42:45.790]                       else if (inherits(cond, "warning")) {
[17:42:45.790]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.790]                         if (muffled) 
[17:42:45.790]                           invokeRestart("muffleWarning")
[17:42:45.790]                       }
[17:42:45.790]                       else if (inherits(cond, "condition")) {
[17:42:45.790]                         if (!is.null(pattern)) {
[17:42:45.790]                           computeRestarts <- base::computeRestarts
[17:42:45.790]                           grepl <- base::grepl
[17:42:45.790]                           restarts <- computeRestarts(cond)
[17:42:45.790]                           for (restart in restarts) {
[17:42:45.790]                             name <- restart$name
[17:42:45.790]                             if (is.null(name)) 
[17:42:45.790]                               next
[17:42:45.790]                             if (!grepl(pattern, name)) 
[17:42:45.790]                               next
[17:42:45.790]                             invokeRestart(restart)
[17:42:45.790]                             muffled <- TRUE
[17:42:45.790]                             break
[17:42:45.790]                           }
[17:42:45.790]                         }
[17:42:45.790]                       }
[17:42:45.790]                       invisible(muffled)
[17:42:45.790]                     }
[17:42:45.790]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.790]                   }
[17:42:45.790]                 }
[17:42:45.790]             }
[17:42:45.790]         }))
[17:42:45.790]     }, error = function(ex) {
[17:42:45.790]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.790]                 ...future.rng), started = ...future.startTime, 
[17:42:45.790]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.790]             version = "1.8"), class = "FutureResult")
[17:42:45.790]     }, finally = {
[17:42:45.790]         if (!identical(...future.workdir, getwd())) 
[17:42:45.790]             setwd(...future.workdir)
[17:42:45.790]         {
[17:42:45.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.790]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.790]             }
[17:42:45.790]             base::options(...future.oldOptions)
[17:42:45.790]             if (.Platform$OS.type == "windows") {
[17:42:45.790]                 old_names <- names(...future.oldEnvVars)
[17:42:45.790]                 envs <- base::Sys.getenv()
[17:42:45.790]                 names <- names(envs)
[17:42:45.790]                 common <- intersect(names, old_names)
[17:42:45.790]                 added <- setdiff(names, old_names)
[17:42:45.790]                 removed <- setdiff(old_names, names)
[17:42:45.790]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.790]                   envs[common]]
[17:42:45.790]                 NAMES <- toupper(changed)
[17:42:45.790]                 args <- list()
[17:42:45.790]                 for (kk in seq_along(NAMES)) {
[17:42:45.790]                   name <- changed[[kk]]
[17:42:45.790]                   NAME <- NAMES[[kk]]
[17:42:45.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.790]                     next
[17:42:45.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.790]                 }
[17:42:45.790]                 NAMES <- toupper(added)
[17:42:45.790]                 for (kk in seq_along(NAMES)) {
[17:42:45.790]                   name <- added[[kk]]
[17:42:45.790]                   NAME <- NAMES[[kk]]
[17:42:45.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.790]                     next
[17:42:45.790]                   args[[name]] <- ""
[17:42:45.790]                 }
[17:42:45.790]                 NAMES <- toupper(removed)
[17:42:45.790]                 for (kk in seq_along(NAMES)) {
[17:42:45.790]                   name <- removed[[kk]]
[17:42:45.790]                   NAME <- NAMES[[kk]]
[17:42:45.790]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.790]                     next
[17:42:45.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.790]                 }
[17:42:45.790]                 if (length(args) > 0) 
[17:42:45.790]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.790]             }
[17:42:45.790]             else {
[17:42:45.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.790]             }
[17:42:45.790]             {
[17:42:45.790]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.790]                   0L) {
[17:42:45.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.790]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.790]                   base::options(opts)
[17:42:45.790]                 }
[17:42:45.790]                 {
[17:42:45.790]                   {
[17:42:45.790]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.790]                     NULL
[17:42:45.790]                   }
[17:42:45.790]                   options(future.plan = NULL)
[17:42:45.790]                   if (is.na(NA_character_)) 
[17:42:45.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.790]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.790]                     envir = parent.frame()) 
[17:42:45.790]                   {
[17:42:45.790]                     default_workers <- missing(workers)
[17:42:45.790]                     if (is.function(workers)) 
[17:42:45.790]                       workers <- workers()
[17:42:45.790]                     workers <- structure(as.integer(workers), 
[17:42:45.790]                       class = class(workers))
[17:42:45.790]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.790]                       1L)
[17:42:45.790]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.790]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.790]                       if (default_workers) 
[17:42:45.790]                         supportsMulticore(warn = TRUE)
[17:42:45.790]                       return(sequential(..., envir = envir))
[17:42:45.790]                     }
[17:42:45.790]                     oopts <- options(mc.cores = workers)
[17:42:45.790]                     on.exit(options(oopts))
[17:42:45.790]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.790]                       envir = envir)
[17:42:45.790]                     if (!future$lazy) 
[17:42:45.790]                       future <- run(future)
[17:42:45.790]                     invisible(future)
[17:42:45.790]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.790]                 }
[17:42:45.790]             }
[17:42:45.790]         }
[17:42:45.790]     })
[17:42:45.790]     if (TRUE) {
[17:42:45.790]         base::sink(type = "output", split = FALSE)
[17:42:45.790]         if (TRUE) {
[17:42:45.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.790]         }
[17:42:45.790]         else {
[17:42:45.790]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.790]         }
[17:42:45.790]         base::close(...future.stdout)
[17:42:45.790]         ...future.stdout <- NULL
[17:42:45.790]     }
[17:42:45.790]     ...future.result$conditions <- ...future.conditions
[17:42:45.790]     ...future.result$finished <- base::Sys.time()
[17:42:45.790]     ...future.result
[17:42:45.790] }
[17:42:45.793] assign_globals() ...
[17:42:45.793] List of 1
[17:42:45.793]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56181aa079b8> 
[17:42:45.793]  - attr(*, "where")=List of 1
[17:42:45.793]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.793]  - attr(*, "resolved")= logi TRUE
[17:42:45.793]  - attr(*, "total_size")= num 1629456
[17:42:45.793]  - attr(*, "already-done")= logi TRUE
[17:42:45.796] - copied ‘a’ to environment
[17:42:45.796] assign_globals() ... done
[17:42:45.796] requestCore(): workers = 2
[17:42:45.798] MulticoreFuture started
[17:42:45.799] - Launch lazy future ... done
[17:42:45.799] run() for ‘MulticoreFuture’ ... done
[17:42:45.800] plan(): Setting new future strategy stack:
[17:42:45.800] List of future strategies:
[17:42:45.800] 1. sequential:
[17:42:45.800]    - args: function (..., envir = parent.frame())
[17:42:45.800]    - tweaked: FALSE
[17:42:45.800]    - call: NULL
[17:42:45.801] plan(): nbrOfWorkers() = 1
[17:42:45.803] plan(): Setting new future strategy stack:
[17:42:45.803] List of future strategies:
[17:42:45.803] 1. multicore:
[17:42:45.803]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.803]    - tweaked: FALSE
[17:42:45.803]    - call: plan(strategy)
[17:42:45.814] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.816] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.816] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.817] 
[17:42:45.817] Searching for globals ... DONE
[17:42:45.817] - globals: [0] <none>
[17:42:45.817] getGlobalsAndPackages() ... DONE
[17:42:45.817] run() for ‘Future’ ...
[17:42:45.818] - state: ‘created’
[17:42:45.818] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.826] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.826] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.826]   - Field: ‘label’
[17:42:45.826]   - Field: ‘local’
[17:42:45.827]   - Field: ‘owner’
[17:42:45.827]   - Field: ‘envir’
[17:42:45.827]   - Field: ‘workers’
[17:42:45.827]   - Field: ‘packages’
[17:42:45.827]   - Field: ‘gc’
[17:42:45.827]   - Field: ‘job’
[17:42:45.828]   - Field: ‘conditions’
[17:42:45.828]   - Field: ‘expr’
[17:42:45.828]   - Field: ‘uuid’
[17:42:45.828]   - Field: ‘seed’
[17:42:45.828]   - Field: ‘version’
[17:42:45.828]   - Field: ‘result’
[17:42:45.828]   - Field: ‘asynchronous’
[17:42:45.829]   - Field: ‘calls’
[17:42:45.829]   - Field: ‘globals’
[17:42:45.829]   - Field: ‘stdout’
[17:42:45.829]   - Field: ‘earlySignal’
[17:42:45.829]   - Field: ‘lazy’
[17:42:45.830]   - Field: ‘state’
[17:42:45.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.830] - Launch lazy future ...
[17:42:45.830] Packages needed by the future expression (n = 0): <none>
[17:42:45.831] Packages needed by future strategies (n = 0): <none>
[17:42:45.831] {
[17:42:45.831]     {
[17:42:45.831]         {
[17:42:45.831]             ...future.startTime <- base::Sys.time()
[17:42:45.831]             {
[17:42:45.831]                 {
[17:42:45.831]                   {
[17:42:45.831]                     {
[17:42:45.831]                       base::local({
[17:42:45.831]                         has_future <- base::requireNamespace("future", 
[17:42:45.831]                           quietly = TRUE)
[17:42:45.831]                         if (has_future) {
[17:42:45.831]                           ns <- base::getNamespace("future")
[17:42:45.831]                           version <- ns[[".package"]][["version"]]
[17:42:45.831]                           if (is.null(version)) 
[17:42:45.831]                             version <- utils::packageVersion("future")
[17:42:45.831]                         }
[17:42:45.831]                         else {
[17:42:45.831]                           version <- NULL
[17:42:45.831]                         }
[17:42:45.831]                         if (!has_future || version < "1.8.0") {
[17:42:45.831]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.831]                             "", base::R.version$version.string), 
[17:42:45.831]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.831]                               "release", "version")], collapse = " "), 
[17:42:45.831]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.831]                             info)
[17:42:45.831]                           info <- base::paste(info, collapse = "; ")
[17:42:45.831]                           if (!has_future) {
[17:42:45.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.831]                               info)
[17:42:45.831]                           }
[17:42:45.831]                           else {
[17:42:45.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.831]                               info, version)
[17:42:45.831]                           }
[17:42:45.831]                           base::stop(msg)
[17:42:45.831]                         }
[17:42:45.831]                       })
[17:42:45.831]                     }
[17:42:45.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.831]                     base::options(mc.cores = 1L)
[17:42:45.831]                   }
[17:42:45.831]                   options(future.plan = NULL)
[17:42:45.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.831]                 }
[17:42:45.831]                 ...future.workdir <- getwd()
[17:42:45.831]             }
[17:42:45.831]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.831]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.831]         }
[17:42:45.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.831]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.831]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.831]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.831]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.831]             base::names(...future.oldOptions))
[17:42:45.831]     }
[17:42:45.831]     if (FALSE) {
[17:42:45.831]     }
[17:42:45.831]     else {
[17:42:45.831]         if (TRUE) {
[17:42:45.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.831]                 open = "w")
[17:42:45.831]         }
[17:42:45.831]         else {
[17:42:45.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.831]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.831]         }
[17:42:45.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.831]             base::sink(type = "output", split = FALSE)
[17:42:45.831]             base::close(...future.stdout)
[17:42:45.831]         }, add = TRUE)
[17:42:45.831]     }
[17:42:45.831]     ...future.frame <- base::sys.nframe()
[17:42:45.831]     ...future.conditions <- base::list()
[17:42:45.831]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.831]     if (FALSE) {
[17:42:45.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.831]     }
[17:42:45.831]     ...future.result <- base::tryCatch({
[17:42:45.831]         base::withCallingHandlers({
[17:42:45.831]             ...future.value <- base::withVisible(base::local({
[17:42:45.831]                 withCallingHandlers({
[17:42:45.831]                   1
[17:42:45.831]                 }, immediateCondition = function(cond) {
[17:42:45.831]                   save_rds <- function (object, pathname, ...) 
[17:42:45.831]                   {
[17:42:45.831]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.831]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.831]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.831]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.831]                         fi_tmp[["mtime"]])
[17:42:45.831]                     }
[17:42:45.831]                     tryCatch({
[17:42:45.831]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.831]                     }, error = function(ex) {
[17:42:45.831]                       msg <- conditionMessage(ex)
[17:42:45.831]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.831]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.831]                         fi_tmp[["mtime"]], msg)
[17:42:45.831]                       ex$message <- msg
[17:42:45.831]                       stop(ex)
[17:42:45.831]                     })
[17:42:45.831]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.831]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.831]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.831]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.831]                       fi <- file.info(pathname)
[17:42:45.831]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.831]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.831]                         fi[["size"]], fi[["mtime"]])
[17:42:45.831]                       stop(msg)
[17:42:45.831]                     }
[17:42:45.831]                     invisible(pathname)
[17:42:45.831]                   }
[17:42:45.831]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.831]                     rootPath = tempdir()) 
[17:42:45.831]                   {
[17:42:45.831]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.831]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.831]                       tmpdir = path, fileext = ".rds")
[17:42:45.831]                     save_rds(obj, file)
[17:42:45.831]                   }
[17:42:45.831]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.831]                   {
[17:42:45.831]                     inherits <- base::inherits
[17:42:45.831]                     invokeRestart <- base::invokeRestart
[17:42:45.831]                     is.null <- base::is.null
[17:42:45.831]                     muffled <- FALSE
[17:42:45.831]                     if (inherits(cond, "message")) {
[17:42:45.831]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.831]                       if (muffled) 
[17:42:45.831]                         invokeRestart("muffleMessage")
[17:42:45.831]                     }
[17:42:45.831]                     else if (inherits(cond, "warning")) {
[17:42:45.831]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.831]                       if (muffled) 
[17:42:45.831]                         invokeRestart("muffleWarning")
[17:42:45.831]                     }
[17:42:45.831]                     else if (inherits(cond, "condition")) {
[17:42:45.831]                       if (!is.null(pattern)) {
[17:42:45.831]                         computeRestarts <- base::computeRestarts
[17:42:45.831]                         grepl <- base::grepl
[17:42:45.831]                         restarts <- computeRestarts(cond)
[17:42:45.831]                         for (restart in restarts) {
[17:42:45.831]                           name <- restart$name
[17:42:45.831]                           if (is.null(name)) 
[17:42:45.831]                             next
[17:42:45.831]                           if (!grepl(pattern, name)) 
[17:42:45.831]                             next
[17:42:45.831]                           invokeRestart(restart)
[17:42:45.831]                           muffled <- TRUE
[17:42:45.831]                           break
[17:42:45.831]                         }
[17:42:45.831]                       }
[17:42:45.831]                     }
[17:42:45.831]                     invisible(muffled)
[17:42:45.831]                   }
[17:42:45.831]                   muffleCondition(cond)
[17:42:45.831]                 })
[17:42:45.831]             }))
[17:42:45.831]             future::FutureResult(value = ...future.value$value, 
[17:42:45.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.831]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.831]                     ...future.globalenv.names))
[17:42:45.831]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.831]         }, condition = base::local({
[17:42:45.831]             c <- base::c
[17:42:45.831]             inherits <- base::inherits
[17:42:45.831]             invokeRestart <- base::invokeRestart
[17:42:45.831]             length <- base::length
[17:42:45.831]             list <- base::list
[17:42:45.831]             seq.int <- base::seq.int
[17:42:45.831]             signalCondition <- base::signalCondition
[17:42:45.831]             sys.calls <- base::sys.calls
[17:42:45.831]             `[[` <- base::`[[`
[17:42:45.831]             `+` <- base::`+`
[17:42:45.831]             `<<-` <- base::`<<-`
[17:42:45.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.831]                   3L)]
[17:42:45.831]             }
[17:42:45.831]             function(cond) {
[17:42:45.831]                 is_error <- inherits(cond, "error")
[17:42:45.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.831]                   NULL)
[17:42:45.831]                 if (is_error) {
[17:42:45.831]                   sessionInformation <- function() {
[17:42:45.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.831]                       search = base::search(), system = base::Sys.info())
[17:42:45.831]                   }
[17:42:45.831]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.831]                     cond$call), session = sessionInformation(), 
[17:42:45.831]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.831]                   signalCondition(cond)
[17:42:45.831]                 }
[17:42:45.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.831]                 "immediateCondition"))) {
[17:42:45.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.831]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.831]                   if (TRUE && !signal) {
[17:42:45.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.831]                     {
[17:42:45.831]                       inherits <- base::inherits
[17:42:45.831]                       invokeRestart <- base::invokeRestart
[17:42:45.831]                       is.null <- base::is.null
[17:42:45.831]                       muffled <- FALSE
[17:42:45.831]                       if (inherits(cond, "message")) {
[17:42:45.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.831]                         if (muffled) 
[17:42:45.831]                           invokeRestart("muffleMessage")
[17:42:45.831]                       }
[17:42:45.831]                       else if (inherits(cond, "warning")) {
[17:42:45.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.831]                         if (muffled) 
[17:42:45.831]                           invokeRestart("muffleWarning")
[17:42:45.831]                       }
[17:42:45.831]                       else if (inherits(cond, "condition")) {
[17:42:45.831]                         if (!is.null(pattern)) {
[17:42:45.831]                           computeRestarts <- base::computeRestarts
[17:42:45.831]                           grepl <- base::grepl
[17:42:45.831]                           restarts <- computeRestarts(cond)
[17:42:45.831]                           for (restart in restarts) {
[17:42:45.831]                             name <- restart$name
[17:42:45.831]                             if (is.null(name)) 
[17:42:45.831]                               next
[17:42:45.831]                             if (!grepl(pattern, name)) 
[17:42:45.831]                               next
[17:42:45.831]                             invokeRestart(restart)
[17:42:45.831]                             muffled <- TRUE
[17:42:45.831]                             break
[17:42:45.831]                           }
[17:42:45.831]                         }
[17:42:45.831]                       }
[17:42:45.831]                       invisible(muffled)
[17:42:45.831]                     }
[17:42:45.831]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.831]                   }
[17:42:45.831]                 }
[17:42:45.831]                 else {
[17:42:45.831]                   if (TRUE) {
[17:42:45.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.831]                     {
[17:42:45.831]                       inherits <- base::inherits
[17:42:45.831]                       invokeRestart <- base::invokeRestart
[17:42:45.831]                       is.null <- base::is.null
[17:42:45.831]                       muffled <- FALSE
[17:42:45.831]                       if (inherits(cond, "message")) {
[17:42:45.831]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.831]                         if (muffled) 
[17:42:45.831]                           invokeRestart("muffleMessage")
[17:42:45.831]                       }
[17:42:45.831]                       else if (inherits(cond, "warning")) {
[17:42:45.831]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.831]                         if (muffled) 
[17:42:45.831]                           invokeRestart("muffleWarning")
[17:42:45.831]                       }
[17:42:45.831]                       else if (inherits(cond, "condition")) {
[17:42:45.831]                         if (!is.null(pattern)) {
[17:42:45.831]                           computeRestarts <- base::computeRestarts
[17:42:45.831]                           grepl <- base::grepl
[17:42:45.831]                           restarts <- computeRestarts(cond)
[17:42:45.831]                           for (restart in restarts) {
[17:42:45.831]                             name <- restart$name
[17:42:45.831]                             if (is.null(name)) 
[17:42:45.831]                               next
[17:42:45.831]                             if (!grepl(pattern, name)) 
[17:42:45.831]                               next
[17:42:45.831]                             invokeRestart(restart)
[17:42:45.831]                             muffled <- TRUE
[17:42:45.831]                             break
[17:42:45.831]                           }
[17:42:45.831]                         }
[17:42:45.831]                       }
[17:42:45.831]                       invisible(muffled)
[17:42:45.831]                     }
[17:42:45.831]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.831]                   }
[17:42:45.831]                 }
[17:42:45.831]             }
[17:42:45.831]         }))
[17:42:45.831]     }, error = function(ex) {
[17:42:45.831]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.831]                 ...future.rng), started = ...future.startTime, 
[17:42:45.831]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.831]             version = "1.8"), class = "FutureResult")
[17:42:45.831]     }, finally = {
[17:42:45.831]         if (!identical(...future.workdir, getwd())) 
[17:42:45.831]             setwd(...future.workdir)
[17:42:45.831]         {
[17:42:45.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.831]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.831]             }
[17:42:45.831]             base::options(...future.oldOptions)
[17:42:45.831]             if (.Platform$OS.type == "windows") {
[17:42:45.831]                 old_names <- names(...future.oldEnvVars)
[17:42:45.831]                 envs <- base::Sys.getenv()
[17:42:45.831]                 names <- names(envs)
[17:42:45.831]                 common <- intersect(names, old_names)
[17:42:45.831]                 added <- setdiff(names, old_names)
[17:42:45.831]                 removed <- setdiff(old_names, names)
[17:42:45.831]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.831]                   envs[common]]
[17:42:45.831]                 NAMES <- toupper(changed)
[17:42:45.831]                 args <- list()
[17:42:45.831]                 for (kk in seq_along(NAMES)) {
[17:42:45.831]                   name <- changed[[kk]]
[17:42:45.831]                   NAME <- NAMES[[kk]]
[17:42:45.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.831]                     next
[17:42:45.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.831]                 }
[17:42:45.831]                 NAMES <- toupper(added)
[17:42:45.831]                 for (kk in seq_along(NAMES)) {
[17:42:45.831]                   name <- added[[kk]]
[17:42:45.831]                   NAME <- NAMES[[kk]]
[17:42:45.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.831]                     next
[17:42:45.831]                   args[[name]] <- ""
[17:42:45.831]                 }
[17:42:45.831]                 NAMES <- toupper(removed)
[17:42:45.831]                 for (kk in seq_along(NAMES)) {
[17:42:45.831]                   name <- removed[[kk]]
[17:42:45.831]                   NAME <- NAMES[[kk]]
[17:42:45.831]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.831]                     next
[17:42:45.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.831]                 }
[17:42:45.831]                 if (length(args) > 0) 
[17:42:45.831]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.831]             }
[17:42:45.831]             else {
[17:42:45.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.831]             }
[17:42:45.831]             {
[17:42:45.831]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.831]                   0L) {
[17:42:45.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.831]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.831]                   base::options(opts)
[17:42:45.831]                 }
[17:42:45.831]                 {
[17:42:45.831]                   {
[17:42:45.831]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.831]                     NULL
[17:42:45.831]                   }
[17:42:45.831]                   options(future.plan = NULL)
[17:42:45.831]                   if (is.na(NA_character_)) 
[17:42:45.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.831]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.831]                     envir = parent.frame()) 
[17:42:45.831]                   {
[17:42:45.831]                     default_workers <- missing(workers)
[17:42:45.831]                     if (is.function(workers)) 
[17:42:45.831]                       workers <- workers()
[17:42:45.831]                     workers <- structure(as.integer(workers), 
[17:42:45.831]                       class = class(workers))
[17:42:45.831]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.831]                       1L)
[17:42:45.831]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.831]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.831]                       if (default_workers) 
[17:42:45.831]                         supportsMulticore(warn = TRUE)
[17:42:45.831]                       return(sequential(..., envir = envir))
[17:42:45.831]                     }
[17:42:45.831]                     oopts <- options(mc.cores = workers)
[17:42:45.831]                     on.exit(options(oopts))
[17:42:45.831]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.831]                       envir = envir)
[17:42:45.831]                     if (!future$lazy) 
[17:42:45.831]                       future <- run(future)
[17:42:45.831]                     invisible(future)
[17:42:45.831]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.831]                 }
[17:42:45.831]             }
[17:42:45.831]         }
[17:42:45.831]     })
[17:42:45.831]     if (TRUE) {
[17:42:45.831]         base::sink(type = "output", split = FALSE)
[17:42:45.831]         if (TRUE) {
[17:42:45.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.831]         }
[17:42:45.831]         else {
[17:42:45.831]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.831]         }
[17:42:45.831]         base::close(...future.stdout)
[17:42:45.831]         ...future.stdout <- NULL
[17:42:45.831]     }
[17:42:45.831]     ...future.result$conditions <- ...future.conditions
[17:42:45.831]     ...future.result$finished <- base::Sys.time()
[17:42:45.831]     ...future.result
[17:42:45.831] }
[17:42:45.834] requestCore(): workers = 2
[17:42:45.837] MulticoreFuture started
[17:42:45.837] - Launch lazy future ... done
[17:42:45.838] plan(): Setting new future strategy stack:
[17:42:45.838] run() for ‘MulticoreFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.839] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.839] List of future strategies:
[17:42:45.839] 1. sequential:
[17:42:45.839]    - args: function (..., envir = parent.frame())
[17:42:45.839]    - tweaked: FALSE
[17:42:45.839]    - call: NULL
[17:42:45.840] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.840] plan(): nbrOfWorkers() = 1
[17:42:45.842] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.842] Searching for globals ... DONE
[17:42:45.842] Resolving globals: TRUE
[17:42:45.843] plan(): Setting new future strategy stack:
[17:42:45.843] Resolving any globals that are futures ...
[17:42:45.843] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.843] Resolving any globals that are futures ... DONE
[17:42:45.843] List of future strategies:
[17:42:45.843] 1. multicore:
[17:42:45.843]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.843]    - tweaked: FALSE
[17:42:45.843]    - call: plan(strategy)
[17:42:45.844] Resolving futures part of globals (recursively) ...
[17:42:45.844] resolve() on list ...
[17:42:45.844]  recursive: 99
[17:42:45.845]  length: 1
[17:42:45.845]  elements: ‘a’
[17:42:45.848] plan(): nbrOfWorkers() = 2
[17:42:45.848] Future #1
[17:42:45.849] A MulticoreFuture was resolved
[17:42:45.850]  length: 0 (resolved future 1)
[17:42:45.850] resolve() on list ... DONE
[17:42:45.850] - globals: [1] ‘a’
[17:42:45.850] Resolving futures part of globals (recursively) ... DONE
[17:42:45.854] The total size of the 1 globals is 1.55 MiB (1629456 bytes)
[17:42:45.854] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:45.854] - globals: [1] ‘a’
[17:42:45.855] - packages: [1] ‘future’
[17:42:45.855] getGlobalsAndPackages() ... DONE
[17:42:45.855] run() for ‘Future’ ...
[17:42:45.855] - state: ‘created’
[17:42:45.855] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.859] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.860] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.860]   - Field: ‘label’
[17:42:45.860]   - Field: ‘local’
[17:42:45.860]   - Field: ‘owner’
[17:42:45.860]   - Field: ‘envir’
[17:42:45.860]   - Field: ‘workers’
[17:42:45.860]   - Field: ‘packages’
[17:42:45.860]   - Field: ‘gc’
[17:42:45.861]   - Field: ‘job’
[17:42:45.861]   - Field: ‘conditions’
[17:42:45.861]   - Field: ‘expr’
[17:42:45.861]   - Field: ‘uuid’
[17:42:45.861]   - Field: ‘seed’
[17:42:45.861]   - Field: ‘version’
[17:42:45.861]   - Field: ‘result’
[17:42:45.861]   - Field: ‘asynchronous’
[17:42:45.861]   - Field: ‘calls’
[17:42:45.862]   - Field: ‘globals’
[17:42:45.862]   - Field: ‘stdout’
[17:42:45.862]   - Field: ‘earlySignal’
[17:42:45.862]   - Field: ‘lazy’
[17:42:45.862]   - Field: ‘state’
[17:42:45.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.862] - Launch lazy future ...
[17:42:45.863] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.863] Packages needed by future strategies (n = 0): <none>
[17:42:45.863] {
[17:42:45.863]     {
[17:42:45.863]         {
[17:42:45.863]             ...future.startTime <- base::Sys.time()
[17:42:45.863]             {
[17:42:45.863]                 {
[17:42:45.863]                   {
[17:42:45.863]                     {
[17:42:45.863]                       {
[17:42:45.863]                         base::local({
[17:42:45.863]                           has_future <- base::requireNamespace("future", 
[17:42:45.863]                             quietly = TRUE)
[17:42:45.863]                           if (has_future) {
[17:42:45.863]                             ns <- base::getNamespace("future")
[17:42:45.863]                             version <- ns[[".package"]][["version"]]
[17:42:45.863]                             if (is.null(version)) 
[17:42:45.863]                               version <- utils::packageVersion("future")
[17:42:45.863]                           }
[17:42:45.863]                           else {
[17:42:45.863]                             version <- NULL
[17:42:45.863]                           }
[17:42:45.863]                           if (!has_future || version < "1.8.0") {
[17:42:45.863]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.863]                               "", base::R.version$version.string), 
[17:42:45.863]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.863]                                 base::R.version$platform, 8 * 
[17:42:45.863]                                   base::.Machine$sizeof.pointer), 
[17:42:45.863]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.863]                                 "release", "version")], collapse = " "), 
[17:42:45.863]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.863]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.863]                               info)
[17:42:45.863]                             info <- base::paste(info, collapse = "; ")
[17:42:45.863]                             if (!has_future) {
[17:42:45.863]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.863]                                 info)
[17:42:45.863]                             }
[17:42:45.863]                             else {
[17:42:45.863]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.863]                                 info, version)
[17:42:45.863]                             }
[17:42:45.863]                             base::stop(msg)
[17:42:45.863]                           }
[17:42:45.863]                         })
[17:42:45.863]                       }
[17:42:45.863]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.863]                       base::options(mc.cores = 1L)
[17:42:45.863]                     }
[17:42:45.863]                     base::local({
[17:42:45.863]                       for (pkg in "future") {
[17:42:45.863]                         base::loadNamespace(pkg)
[17:42:45.863]                         base::library(pkg, character.only = TRUE)
[17:42:45.863]                       }
[17:42:45.863]                     })
[17:42:45.863]                   }
[17:42:45.863]                   options(future.plan = NULL)
[17:42:45.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.863]                 }
[17:42:45.863]                 ...future.workdir <- getwd()
[17:42:45.863]             }
[17:42:45.863]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.863]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.863]         }
[17:42:45.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.863]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.863]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.863]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.863]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.863]             base::names(...future.oldOptions))
[17:42:45.863]     }
[17:42:45.863]     if (FALSE) {
[17:42:45.863]     }
[17:42:45.863]     else {
[17:42:45.863]         if (TRUE) {
[17:42:45.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.863]                 open = "w")
[17:42:45.863]         }
[17:42:45.863]         else {
[17:42:45.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.863]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.863]         }
[17:42:45.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.863]             base::sink(type = "output", split = FALSE)
[17:42:45.863]             base::close(...future.stdout)
[17:42:45.863]         }, add = TRUE)
[17:42:45.863]     }
[17:42:45.863]     ...future.frame <- base::sys.nframe()
[17:42:45.863]     ...future.conditions <- base::list()
[17:42:45.863]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.863]     if (FALSE) {
[17:42:45.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.863]     }
[17:42:45.863]     ...future.result <- base::tryCatch({
[17:42:45.863]         base::withCallingHandlers({
[17:42:45.863]             ...future.value <- base::withVisible(base::local({
[17:42:45.863]                 withCallingHandlers({
[17:42:45.863]                   value(a) + 1
[17:42:45.863]                 }, immediateCondition = function(cond) {
[17:42:45.863]                   save_rds <- function (object, pathname, ...) 
[17:42:45.863]                   {
[17:42:45.863]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.863]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.863]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.863]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.863]                         fi_tmp[["mtime"]])
[17:42:45.863]                     }
[17:42:45.863]                     tryCatch({
[17:42:45.863]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.863]                     }, error = function(ex) {
[17:42:45.863]                       msg <- conditionMessage(ex)
[17:42:45.863]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.863]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.863]                         fi_tmp[["mtime"]], msg)
[17:42:45.863]                       ex$message <- msg
[17:42:45.863]                       stop(ex)
[17:42:45.863]                     })
[17:42:45.863]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.863]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.863]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.863]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.863]                       fi <- file.info(pathname)
[17:42:45.863]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.863]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.863]                         fi[["size"]], fi[["mtime"]])
[17:42:45.863]                       stop(msg)
[17:42:45.863]                     }
[17:42:45.863]                     invisible(pathname)
[17:42:45.863]                   }
[17:42:45.863]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.863]                     rootPath = tempdir()) 
[17:42:45.863]                   {
[17:42:45.863]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.863]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.863]                       tmpdir = path, fileext = ".rds")
[17:42:45.863]                     save_rds(obj, file)
[17:42:45.863]                   }
[17:42:45.863]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.863]                   {
[17:42:45.863]                     inherits <- base::inherits
[17:42:45.863]                     invokeRestart <- base::invokeRestart
[17:42:45.863]                     is.null <- base::is.null
[17:42:45.863]                     muffled <- FALSE
[17:42:45.863]                     if (inherits(cond, "message")) {
[17:42:45.863]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.863]                       if (muffled) 
[17:42:45.863]                         invokeRestart("muffleMessage")
[17:42:45.863]                     }
[17:42:45.863]                     else if (inherits(cond, "warning")) {
[17:42:45.863]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.863]                       if (muffled) 
[17:42:45.863]                         invokeRestart("muffleWarning")
[17:42:45.863]                     }
[17:42:45.863]                     else if (inherits(cond, "condition")) {
[17:42:45.863]                       if (!is.null(pattern)) {
[17:42:45.863]                         computeRestarts <- base::computeRestarts
[17:42:45.863]                         grepl <- base::grepl
[17:42:45.863]                         restarts <- computeRestarts(cond)
[17:42:45.863]                         for (restart in restarts) {
[17:42:45.863]                           name <- restart$name
[17:42:45.863]                           if (is.null(name)) 
[17:42:45.863]                             next
[17:42:45.863]                           if (!grepl(pattern, name)) 
[17:42:45.863]                             next
[17:42:45.863]                           invokeRestart(restart)
[17:42:45.863]                           muffled <- TRUE
[17:42:45.863]                           break
[17:42:45.863]                         }
[17:42:45.863]                       }
[17:42:45.863]                     }
[17:42:45.863]                     invisible(muffled)
[17:42:45.863]                   }
[17:42:45.863]                   muffleCondition(cond)
[17:42:45.863]                 })
[17:42:45.863]             }))
[17:42:45.863]             future::FutureResult(value = ...future.value$value, 
[17:42:45.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.863]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.863]                     ...future.globalenv.names))
[17:42:45.863]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.863]         }, condition = base::local({
[17:42:45.863]             c <- base::c
[17:42:45.863]             inherits <- base::inherits
[17:42:45.863]             invokeRestart <- base::invokeRestart
[17:42:45.863]             length <- base::length
[17:42:45.863]             list <- base::list
[17:42:45.863]             seq.int <- base::seq.int
[17:42:45.863]             signalCondition <- base::signalCondition
[17:42:45.863]             sys.calls <- base::sys.calls
[17:42:45.863]             `[[` <- base::`[[`
[17:42:45.863]             `+` <- base::`+`
[17:42:45.863]             `<<-` <- base::`<<-`
[17:42:45.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.863]                   3L)]
[17:42:45.863]             }
[17:42:45.863]             function(cond) {
[17:42:45.863]                 is_error <- inherits(cond, "error")
[17:42:45.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.863]                   NULL)
[17:42:45.863]                 if (is_error) {
[17:42:45.863]                   sessionInformation <- function() {
[17:42:45.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.863]                       search = base::search(), system = base::Sys.info())
[17:42:45.863]                   }
[17:42:45.863]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.863]                     cond$call), session = sessionInformation(), 
[17:42:45.863]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.863]                   signalCondition(cond)
[17:42:45.863]                 }
[17:42:45.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.863]                 "immediateCondition"))) {
[17:42:45.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.863]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.863]                   if (TRUE && !signal) {
[17:42:45.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.863]                     {
[17:42:45.863]                       inherits <- base::inherits
[17:42:45.863]                       invokeRestart <- base::invokeRestart
[17:42:45.863]                       is.null <- base::is.null
[17:42:45.863]                       muffled <- FALSE
[17:42:45.863]                       if (inherits(cond, "message")) {
[17:42:45.863]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.863]                         if (muffled) 
[17:42:45.863]                           invokeRestart("muffleMessage")
[17:42:45.863]                       }
[17:42:45.863]                       else if (inherits(cond, "warning")) {
[17:42:45.863]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.863]                         if (muffled) 
[17:42:45.863]                           invokeRestart("muffleWarning")
[17:42:45.863]                       }
[17:42:45.863]                       else if (inherits(cond, "condition")) {
[17:42:45.863]                         if (!is.null(pattern)) {
[17:42:45.863]                           computeRestarts <- base::computeRestarts
[17:42:45.863]                           grepl <- base::grepl
[17:42:45.863]                           restarts <- computeRestarts(cond)
[17:42:45.863]                           for (restart in restarts) {
[17:42:45.863]                             name <- restart$name
[17:42:45.863]                             if (is.null(name)) 
[17:42:45.863]                               next
[17:42:45.863]                             if (!grepl(pattern, name)) 
[17:42:45.863]                               next
[17:42:45.863]                             invokeRestart(restart)
[17:42:45.863]                             muffled <- TRUE
[17:42:45.863]                             break
[17:42:45.863]                           }
[17:42:45.863]                         }
[17:42:45.863]                       }
[17:42:45.863]                       invisible(muffled)
[17:42:45.863]                     }
[17:42:45.863]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.863]                   }
[17:42:45.863]                 }
[17:42:45.863]                 else {
[17:42:45.863]                   if (TRUE) {
[17:42:45.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.863]                     {
[17:42:45.863]                       inherits <- base::inherits
[17:42:45.863]                       invokeRestart <- base::invokeRestart
[17:42:45.863]                       is.null <- base::is.null
[17:42:45.863]                       muffled <- FALSE
[17:42:45.863]                       if (inherits(cond, "message")) {
[17:42:45.863]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.863]                         if (muffled) 
[17:42:45.863]                           invokeRestart("muffleMessage")
[17:42:45.863]                       }
[17:42:45.863]                       else if (inherits(cond, "warning")) {
[17:42:45.863]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.863]                         if (muffled) 
[17:42:45.863]                           invokeRestart("muffleWarning")
[17:42:45.863]                       }
[17:42:45.863]                       else if (inherits(cond, "condition")) {
[17:42:45.863]                         if (!is.null(pattern)) {
[17:42:45.863]                           computeRestarts <- base::computeRestarts
[17:42:45.863]                           grepl <- base::grepl
[17:42:45.863]                           restarts <- computeRestarts(cond)
[17:42:45.863]                           for (restart in restarts) {
[17:42:45.863]                             name <- restart$name
[17:42:45.863]                             if (is.null(name)) 
[17:42:45.863]                               next
[17:42:45.863]                             if (!grepl(pattern, name)) 
[17:42:45.863]                               next
[17:42:45.863]                             invokeRestart(restart)
[17:42:45.863]                             muffled <- TRUE
[17:42:45.863]                             break
[17:42:45.863]                           }
[17:42:45.863]                         }
[17:42:45.863]                       }
[17:42:45.863]                       invisible(muffled)
[17:42:45.863]                     }
[17:42:45.863]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.863]                   }
[17:42:45.863]                 }
[17:42:45.863]             }
[17:42:45.863]         }))
[17:42:45.863]     }, error = function(ex) {
[17:42:45.863]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.863]                 ...future.rng), started = ...future.startTime, 
[17:42:45.863]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.863]             version = "1.8"), class = "FutureResult")
[17:42:45.863]     }, finally = {
[17:42:45.863]         if (!identical(...future.workdir, getwd())) 
[17:42:45.863]             setwd(...future.workdir)
[17:42:45.863]         {
[17:42:45.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.863]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.863]             }
[17:42:45.863]             base::options(...future.oldOptions)
[17:42:45.863]             if (.Platform$OS.type == "windows") {
[17:42:45.863]                 old_names <- names(...future.oldEnvVars)
[17:42:45.863]                 envs <- base::Sys.getenv()
[17:42:45.863]                 names <- names(envs)
[17:42:45.863]                 common <- intersect(names, old_names)
[17:42:45.863]                 added <- setdiff(names, old_names)
[17:42:45.863]                 removed <- setdiff(old_names, names)
[17:42:45.863]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.863]                   envs[common]]
[17:42:45.863]                 NAMES <- toupper(changed)
[17:42:45.863]                 args <- list()
[17:42:45.863]                 for (kk in seq_along(NAMES)) {
[17:42:45.863]                   name <- changed[[kk]]
[17:42:45.863]                   NAME <- NAMES[[kk]]
[17:42:45.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.863]                     next
[17:42:45.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.863]                 }
[17:42:45.863]                 NAMES <- toupper(added)
[17:42:45.863]                 for (kk in seq_along(NAMES)) {
[17:42:45.863]                   name <- added[[kk]]
[17:42:45.863]                   NAME <- NAMES[[kk]]
[17:42:45.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.863]                     next
[17:42:45.863]                   args[[name]] <- ""
[17:42:45.863]                 }
[17:42:45.863]                 NAMES <- toupper(removed)
[17:42:45.863]                 for (kk in seq_along(NAMES)) {
[17:42:45.863]                   name <- removed[[kk]]
[17:42:45.863]                   NAME <- NAMES[[kk]]
[17:42:45.863]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.863]                     next
[17:42:45.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.863]                 }
[17:42:45.863]                 if (length(args) > 0) 
[17:42:45.863]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.863]             }
[17:42:45.863]             else {
[17:42:45.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.863]             }
[17:42:45.863]             {
[17:42:45.863]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.863]                   0L) {
[17:42:45.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.863]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.863]                   base::options(opts)
[17:42:45.863]                 }
[17:42:45.863]                 {
[17:42:45.863]                   {
[17:42:45.863]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.863]                     NULL
[17:42:45.863]                   }
[17:42:45.863]                   options(future.plan = NULL)
[17:42:45.863]                   if (is.na(NA_character_)) 
[17:42:45.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.863]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.863]                     envir = parent.frame()) 
[17:42:45.863]                   {
[17:42:45.863]                     default_workers <- missing(workers)
[17:42:45.863]                     if (is.function(workers)) 
[17:42:45.863]                       workers <- workers()
[17:42:45.863]                     workers <- structure(as.integer(workers), 
[17:42:45.863]                       class = class(workers))
[17:42:45.863]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.863]                       1L)
[17:42:45.863]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.863]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.863]                       if (default_workers) 
[17:42:45.863]                         supportsMulticore(warn = TRUE)
[17:42:45.863]                       return(sequential(..., envir = envir))
[17:42:45.863]                     }
[17:42:45.863]                     oopts <- options(mc.cores = workers)
[17:42:45.863]                     on.exit(options(oopts))
[17:42:45.863]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.863]                       envir = envir)
[17:42:45.863]                     if (!future$lazy) 
[17:42:45.863]                       future <- run(future)
[17:42:45.863]                     invisible(future)
[17:42:45.863]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.863]                 }
[17:42:45.863]             }
[17:42:45.863]         }
[17:42:45.863]     })
[17:42:45.863]     if (TRUE) {
[17:42:45.863]         base::sink(type = "output", split = FALSE)
[17:42:45.863]         if (TRUE) {
[17:42:45.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.863]         }
[17:42:45.863]         else {
[17:42:45.863]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.863]         }
[17:42:45.863]         base::close(...future.stdout)
[17:42:45.863]         ...future.stdout <- NULL
[17:42:45.863]     }
[17:42:45.863]     ...future.result$conditions <- ...future.conditions
[17:42:45.863]     ...future.result$finished <- base::Sys.time()
[17:42:45.863]     ...future.result
[17:42:45.863] }
[17:42:45.866] assign_globals() ...
[17:42:45.866] List of 1
[17:42:45.866]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56181ae33328> 
[17:42:45.866]  - attr(*, "where")=List of 1
[17:42:45.866]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.866]  - attr(*, "resolved")= logi TRUE
[17:42:45.866]  - attr(*, "total_size")= num 1629456
[17:42:45.866]  - attr(*, "already-done")= logi TRUE
[17:42:45.872] - copied ‘a’ to environment
[17:42:45.872] assign_globals() ... done
[17:42:45.873] requestCore(): workers = 2
[17:42:45.875] MulticoreFuture started
[17:42:45.875] - Launch lazy future ... done
[17:42:45.875] run() for ‘MulticoreFuture’ ... done
[17:42:45.876] plan(): Setting new future strategy stack:
[17:42:45.877] List of future strategies:
[17:42:45.877] 1. sequential:
[17:42:45.877]    - args: function (..., envir = parent.frame())
[17:42:45.877]    - tweaked: FALSE
[17:42:45.877]    - call: NULL
[17:42:45.879] plan(): nbrOfWorkers() = 1
[17:42:45.882] plan(): Setting new future strategy stack:
[17:42:45.882] List of future strategies:
[17:42:45.882] 1. multicore:
[17:42:45.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.882]    - tweaked: FALSE
[17:42:45.882]    - call: plan(strategy)
[17:42:45.890] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.892] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.893] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.894] 
[17:42:45.894] Searching for globals ... DONE
[17:42:45.894] - globals: [0] <none>
[17:42:45.894] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.895] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.895] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.896] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.897] Searching for globals ... DONE
[17:42:45.897] Resolving globals: TRUE
[17:42:45.897] Resolving any globals that are futures ...
[17:42:45.897] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.897] Resolving any globals that are futures ... DONE
[17:42:45.897] Resolving futures part of globals (recursively) ...
[17:42:45.898] resolve() on list ...
[17:42:45.898]  recursive: 99
[17:42:45.898]  length: 1
[17:42:45.898]  elements: ‘a’
[17:42:45.898] run() for ‘Future’ ...
[17:42:45.898] - state: ‘created’
[17:42:45.899] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.903] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.903] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.903]   - Field: ‘label’
[17:42:45.904]   - Field: ‘local’
[17:42:45.904]   - Field: ‘owner’
[17:42:45.904]   - Field: ‘envir’
[17:42:45.904]   - Field: ‘workers’
[17:42:45.904]   - Field: ‘packages’
[17:42:45.904]   - Field: ‘gc’
[17:42:45.904]   - Field: ‘job’
[17:42:45.904]   - Field: ‘conditions’
[17:42:45.904]   - Field: ‘expr’
[17:42:45.905]   - Field: ‘uuid’
[17:42:45.905]   - Field: ‘seed’
[17:42:45.905]   - Field: ‘version’
[17:42:45.905]   - Field: ‘result’
[17:42:45.905]   - Field: ‘asynchronous’
[17:42:45.905]   - Field: ‘calls’
[17:42:45.905]   - Field: ‘globals’
[17:42:45.905]   - Field: ‘stdout’
[17:42:45.905]   - Field: ‘earlySignal’
[17:42:45.906]   - Field: ‘lazy’
[17:42:45.906]   - Field: ‘state’
[17:42:45.906] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.906] - Launch lazy future ...
[17:42:45.906] Packages needed by the future expression (n = 0): <none>
[17:42:45.907] Packages needed by future strategies (n = 0): <none>
[17:42:45.907] {
[17:42:45.907]     {
[17:42:45.907]         {
[17:42:45.907]             ...future.startTime <- base::Sys.time()
[17:42:45.907]             {
[17:42:45.907]                 {
[17:42:45.907]                   {
[17:42:45.907]                     {
[17:42:45.907]                       base::local({
[17:42:45.907]                         has_future <- base::requireNamespace("future", 
[17:42:45.907]                           quietly = TRUE)
[17:42:45.907]                         if (has_future) {
[17:42:45.907]                           ns <- base::getNamespace("future")
[17:42:45.907]                           version <- ns[[".package"]][["version"]]
[17:42:45.907]                           if (is.null(version)) 
[17:42:45.907]                             version <- utils::packageVersion("future")
[17:42:45.907]                         }
[17:42:45.907]                         else {
[17:42:45.907]                           version <- NULL
[17:42:45.907]                         }
[17:42:45.907]                         if (!has_future || version < "1.8.0") {
[17:42:45.907]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.907]                             "", base::R.version$version.string), 
[17:42:45.907]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.907]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.907]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.907]                               "release", "version")], collapse = " "), 
[17:42:45.907]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.907]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.907]                             info)
[17:42:45.907]                           info <- base::paste(info, collapse = "; ")
[17:42:45.907]                           if (!has_future) {
[17:42:45.907]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.907]                               info)
[17:42:45.907]                           }
[17:42:45.907]                           else {
[17:42:45.907]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.907]                               info, version)
[17:42:45.907]                           }
[17:42:45.907]                           base::stop(msg)
[17:42:45.907]                         }
[17:42:45.907]                       })
[17:42:45.907]                     }
[17:42:45.907]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.907]                     base::options(mc.cores = 1L)
[17:42:45.907]                   }
[17:42:45.907]                   options(future.plan = NULL)
[17:42:45.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.907]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.907]                 }
[17:42:45.907]                 ...future.workdir <- getwd()
[17:42:45.907]             }
[17:42:45.907]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.907]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.907]         }
[17:42:45.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.907]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.907]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.907]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.907]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.907]             base::names(...future.oldOptions))
[17:42:45.907]     }
[17:42:45.907]     if (FALSE) {
[17:42:45.907]     }
[17:42:45.907]     else {
[17:42:45.907]         if (TRUE) {
[17:42:45.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.907]                 open = "w")
[17:42:45.907]         }
[17:42:45.907]         else {
[17:42:45.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.907]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.907]         }
[17:42:45.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.907]             base::sink(type = "output", split = FALSE)
[17:42:45.907]             base::close(...future.stdout)
[17:42:45.907]         }, add = TRUE)
[17:42:45.907]     }
[17:42:45.907]     ...future.frame <- base::sys.nframe()
[17:42:45.907]     ...future.conditions <- base::list()
[17:42:45.907]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.907]     if (FALSE) {
[17:42:45.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.907]     }
[17:42:45.907]     ...future.result <- base::tryCatch({
[17:42:45.907]         base::withCallingHandlers({
[17:42:45.907]             ...future.value <- base::withVisible(base::local({
[17:42:45.907]                 withCallingHandlers({
[17:42:45.907]                   1
[17:42:45.907]                 }, immediateCondition = function(cond) {
[17:42:45.907]                   save_rds <- function (object, pathname, ...) 
[17:42:45.907]                   {
[17:42:45.907]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.907]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.907]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.907]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.907]                         fi_tmp[["mtime"]])
[17:42:45.907]                     }
[17:42:45.907]                     tryCatch({
[17:42:45.907]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.907]                     }, error = function(ex) {
[17:42:45.907]                       msg <- conditionMessage(ex)
[17:42:45.907]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.907]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.907]                         fi_tmp[["mtime"]], msg)
[17:42:45.907]                       ex$message <- msg
[17:42:45.907]                       stop(ex)
[17:42:45.907]                     })
[17:42:45.907]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.907]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.907]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.907]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.907]                       fi <- file.info(pathname)
[17:42:45.907]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.907]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.907]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.907]                         fi[["size"]], fi[["mtime"]])
[17:42:45.907]                       stop(msg)
[17:42:45.907]                     }
[17:42:45.907]                     invisible(pathname)
[17:42:45.907]                   }
[17:42:45.907]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.907]                     rootPath = tempdir()) 
[17:42:45.907]                   {
[17:42:45.907]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.907]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.907]                       tmpdir = path, fileext = ".rds")
[17:42:45.907]                     save_rds(obj, file)
[17:42:45.907]                   }
[17:42:45.907]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.907]                   {
[17:42:45.907]                     inherits <- base::inherits
[17:42:45.907]                     invokeRestart <- base::invokeRestart
[17:42:45.907]                     is.null <- base::is.null
[17:42:45.907]                     muffled <- FALSE
[17:42:45.907]                     if (inherits(cond, "message")) {
[17:42:45.907]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.907]                       if (muffled) 
[17:42:45.907]                         invokeRestart("muffleMessage")
[17:42:45.907]                     }
[17:42:45.907]                     else if (inherits(cond, "warning")) {
[17:42:45.907]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.907]                       if (muffled) 
[17:42:45.907]                         invokeRestart("muffleWarning")
[17:42:45.907]                     }
[17:42:45.907]                     else if (inherits(cond, "condition")) {
[17:42:45.907]                       if (!is.null(pattern)) {
[17:42:45.907]                         computeRestarts <- base::computeRestarts
[17:42:45.907]                         grepl <- base::grepl
[17:42:45.907]                         restarts <- computeRestarts(cond)
[17:42:45.907]                         for (restart in restarts) {
[17:42:45.907]                           name <- restart$name
[17:42:45.907]                           if (is.null(name)) 
[17:42:45.907]                             next
[17:42:45.907]                           if (!grepl(pattern, name)) 
[17:42:45.907]                             next
[17:42:45.907]                           invokeRestart(restart)
[17:42:45.907]                           muffled <- TRUE
[17:42:45.907]                           break
[17:42:45.907]                         }
[17:42:45.907]                       }
[17:42:45.907]                     }
[17:42:45.907]                     invisible(muffled)
[17:42:45.907]                   }
[17:42:45.907]                   muffleCondition(cond)
[17:42:45.907]                 })
[17:42:45.907]             }))
[17:42:45.907]             future::FutureResult(value = ...future.value$value, 
[17:42:45.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.907]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.907]                     ...future.globalenv.names))
[17:42:45.907]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.907]         }, condition = base::local({
[17:42:45.907]             c <- base::c
[17:42:45.907]             inherits <- base::inherits
[17:42:45.907]             invokeRestart <- base::invokeRestart
[17:42:45.907]             length <- base::length
[17:42:45.907]             list <- base::list
[17:42:45.907]             seq.int <- base::seq.int
[17:42:45.907]             signalCondition <- base::signalCondition
[17:42:45.907]             sys.calls <- base::sys.calls
[17:42:45.907]             `[[` <- base::`[[`
[17:42:45.907]             `+` <- base::`+`
[17:42:45.907]             `<<-` <- base::`<<-`
[17:42:45.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.907]                   3L)]
[17:42:45.907]             }
[17:42:45.907]             function(cond) {
[17:42:45.907]                 is_error <- inherits(cond, "error")
[17:42:45.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.907]                   NULL)
[17:42:45.907]                 if (is_error) {
[17:42:45.907]                   sessionInformation <- function() {
[17:42:45.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.907]                       search = base::search(), system = base::Sys.info())
[17:42:45.907]                   }
[17:42:45.907]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.907]                     cond$call), session = sessionInformation(), 
[17:42:45.907]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.907]                   signalCondition(cond)
[17:42:45.907]                 }
[17:42:45.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.907]                 "immediateCondition"))) {
[17:42:45.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.907]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.907]                   if (TRUE && !signal) {
[17:42:45.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.907]                     {
[17:42:45.907]                       inherits <- base::inherits
[17:42:45.907]                       invokeRestart <- base::invokeRestart
[17:42:45.907]                       is.null <- base::is.null
[17:42:45.907]                       muffled <- FALSE
[17:42:45.907]                       if (inherits(cond, "message")) {
[17:42:45.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.907]                         if (muffled) 
[17:42:45.907]                           invokeRestart("muffleMessage")
[17:42:45.907]                       }
[17:42:45.907]                       else if (inherits(cond, "warning")) {
[17:42:45.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.907]                         if (muffled) 
[17:42:45.907]                           invokeRestart("muffleWarning")
[17:42:45.907]                       }
[17:42:45.907]                       else if (inherits(cond, "condition")) {
[17:42:45.907]                         if (!is.null(pattern)) {
[17:42:45.907]                           computeRestarts <- base::computeRestarts
[17:42:45.907]                           grepl <- base::grepl
[17:42:45.907]                           restarts <- computeRestarts(cond)
[17:42:45.907]                           for (restart in restarts) {
[17:42:45.907]                             name <- restart$name
[17:42:45.907]                             if (is.null(name)) 
[17:42:45.907]                               next
[17:42:45.907]                             if (!grepl(pattern, name)) 
[17:42:45.907]                               next
[17:42:45.907]                             invokeRestart(restart)
[17:42:45.907]                             muffled <- TRUE
[17:42:45.907]                             break
[17:42:45.907]                           }
[17:42:45.907]                         }
[17:42:45.907]                       }
[17:42:45.907]                       invisible(muffled)
[17:42:45.907]                     }
[17:42:45.907]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.907]                   }
[17:42:45.907]                 }
[17:42:45.907]                 else {
[17:42:45.907]                   if (TRUE) {
[17:42:45.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.907]                     {
[17:42:45.907]                       inherits <- base::inherits
[17:42:45.907]                       invokeRestart <- base::invokeRestart
[17:42:45.907]                       is.null <- base::is.null
[17:42:45.907]                       muffled <- FALSE
[17:42:45.907]                       if (inherits(cond, "message")) {
[17:42:45.907]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.907]                         if (muffled) 
[17:42:45.907]                           invokeRestart("muffleMessage")
[17:42:45.907]                       }
[17:42:45.907]                       else if (inherits(cond, "warning")) {
[17:42:45.907]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.907]                         if (muffled) 
[17:42:45.907]                           invokeRestart("muffleWarning")
[17:42:45.907]                       }
[17:42:45.907]                       else if (inherits(cond, "condition")) {
[17:42:45.907]                         if (!is.null(pattern)) {
[17:42:45.907]                           computeRestarts <- base::computeRestarts
[17:42:45.907]                           grepl <- base::grepl
[17:42:45.907]                           restarts <- computeRestarts(cond)
[17:42:45.907]                           for (restart in restarts) {
[17:42:45.907]                             name <- restart$name
[17:42:45.907]                             if (is.null(name)) 
[17:42:45.907]                               next
[17:42:45.907]                             if (!grepl(pattern, name)) 
[17:42:45.907]                               next
[17:42:45.907]                             invokeRestart(restart)
[17:42:45.907]                             muffled <- TRUE
[17:42:45.907]                             break
[17:42:45.907]                           }
[17:42:45.907]                         }
[17:42:45.907]                       }
[17:42:45.907]                       invisible(muffled)
[17:42:45.907]                     }
[17:42:45.907]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.907]                   }
[17:42:45.907]                 }
[17:42:45.907]             }
[17:42:45.907]         }))
[17:42:45.907]     }, error = function(ex) {
[17:42:45.907]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.907]                 ...future.rng), started = ...future.startTime, 
[17:42:45.907]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.907]             version = "1.8"), class = "FutureResult")
[17:42:45.907]     }, finally = {
[17:42:45.907]         if (!identical(...future.workdir, getwd())) 
[17:42:45.907]             setwd(...future.workdir)
[17:42:45.907]         {
[17:42:45.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.907]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.907]             }
[17:42:45.907]             base::options(...future.oldOptions)
[17:42:45.907]             if (.Platform$OS.type == "windows") {
[17:42:45.907]                 old_names <- names(...future.oldEnvVars)
[17:42:45.907]                 envs <- base::Sys.getenv()
[17:42:45.907]                 names <- names(envs)
[17:42:45.907]                 common <- intersect(names, old_names)
[17:42:45.907]                 added <- setdiff(names, old_names)
[17:42:45.907]                 removed <- setdiff(old_names, names)
[17:42:45.907]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.907]                   envs[common]]
[17:42:45.907]                 NAMES <- toupper(changed)
[17:42:45.907]                 args <- list()
[17:42:45.907]                 for (kk in seq_along(NAMES)) {
[17:42:45.907]                   name <- changed[[kk]]
[17:42:45.907]                   NAME <- NAMES[[kk]]
[17:42:45.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.907]                     next
[17:42:45.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.907]                 }
[17:42:45.907]                 NAMES <- toupper(added)
[17:42:45.907]                 for (kk in seq_along(NAMES)) {
[17:42:45.907]                   name <- added[[kk]]
[17:42:45.907]                   NAME <- NAMES[[kk]]
[17:42:45.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.907]                     next
[17:42:45.907]                   args[[name]] <- ""
[17:42:45.907]                 }
[17:42:45.907]                 NAMES <- toupper(removed)
[17:42:45.907]                 for (kk in seq_along(NAMES)) {
[17:42:45.907]                   name <- removed[[kk]]
[17:42:45.907]                   NAME <- NAMES[[kk]]
[17:42:45.907]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.907]                     next
[17:42:45.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.907]                 }
[17:42:45.907]                 if (length(args) > 0) 
[17:42:45.907]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.907]             }
[17:42:45.907]             else {
[17:42:45.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.907]             }
[17:42:45.907]             {
[17:42:45.907]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.907]                   0L) {
[17:42:45.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.907]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.907]                   base::options(opts)
[17:42:45.907]                 }
[17:42:45.907]                 {
[17:42:45.907]                   {
[17:42:45.907]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.907]                     NULL
[17:42:45.907]                   }
[17:42:45.907]                   options(future.plan = NULL)
[17:42:45.907]                   if (is.na(NA_character_)) 
[17:42:45.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.907]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.907]                     envir = parent.frame()) 
[17:42:45.907]                   {
[17:42:45.907]                     default_workers <- missing(workers)
[17:42:45.907]                     if (is.function(workers)) 
[17:42:45.907]                       workers <- workers()
[17:42:45.907]                     workers <- structure(as.integer(workers), 
[17:42:45.907]                       class = class(workers))
[17:42:45.907]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.907]                       1L)
[17:42:45.907]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.907]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.907]                       if (default_workers) 
[17:42:45.907]                         supportsMulticore(warn = TRUE)
[17:42:45.907]                       return(sequential(..., envir = envir))
[17:42:45.907]                     }
[17:42:45.907]                     oopts <- options(mc.cores = workers)
[17:42:45.907]                     on.exit(options(oopts))
[17:42:45.907]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.907]                       envir = envir)
[17:42:45.907]                     if (!future$lazy) 
[17:42:45.907]                       future <- run(future)
[17:42:45.907]                     invisible(future)
[17:42:45.907]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.907]                 }
[17:42:45.907]             }
[17:42:45.907]         }
[17:42:45.907]     })
[17:42:45.907]     if (TRUE) {
[17:42:45.907]         base::sink(type = "output", split = FALSE)
[17:42:45.907]         if (TRUE) {
[17:42:45.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.907]         }
[17:42:45.907]         else {
[17:42:45.907]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.907]         }
[17:42:45.907]         base::close(...future.stdout)
[17:42:45.907]         ...future.stdout <- NULL
[17:42:45.907]     }
[17:42:45.907]     ...future.result$conditions <- ...future.conditions
[17:42:45.907]     ...future.result$finished <- base::Sys.time()
[17:42:45.907]     ...future.result
[17:42:45.907] }
[17:42:45.910] requestCore(): workers = 2
[17:42:45.912] MulticoreFuture started
[17:42:45.913] - Launch lazy future ... done
[17:42:45.913] run() for ‘MulticoreFuture’ ... done
[17:42:45.913] plan(): Setting new future strategy stack:
[17:42:45.914] List of future strategies:
[17:42:45.914] 1. sequential:
[17:42:45.914]    - args: function (..., envir = parent.frame())
[17:42:45.914]    - tweaked: FALSE
[17:42:45.914]    - call: NULL
[17:42:45.915] plan(): nbrOfWorkers() = 1
[17:42:45.917] plan(): Setting new future strategy stack:
[17:42:45.917] List of future strategies:
[17:42:45.917] 1. multicore:
[17:42:45.917]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.917]    - tweaked: FALSE
[17:42:45.917]    - call: plan(strategy)
[17:42:45.923] plan(): nbrOfWorkers() = 2
[17:42:45.924] Future #1
[17:42:45.925] A MulticoreFuture was resolved
[17:42:45.925]  length: 0 (resolved future 1)
[17:42:45.925] resolve() on list ... DONE
[17:42:45.925] - globals: [1] ‘a’
[17:42:45.926] Resolving futures part of globals (recursively) ... DONE
[17:42:45.928] The total size of the 1 globals is 1.55 MiB (1629624 bytes)
[17:42:45.929] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:45.929] - globals: [1] ‘a’
[17:42:45.929] - packages: [1] ‘future’
[17:42:45.929] getGlobalsAndPackages() ... DONE
[17:42:45.930] run() for ‘Future’ ...
[17:42:45.930] - state: ‘created’
[17:42:45.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.934] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.937]   - Field: ‘label’
[17:42:45.938]   - Field: ‘local’
[17:42:45.938]   - Field: ‘owner’
[17:42:45.938]   - Field: ‘envir’
[17:42:45.938]   - Field: ‘workers’
[17:42:45.938]   - Field: ‘packages’
[17:42:45.939]   - Field: ‘gc’
[17:42:45.939]   - Field: ‘job’
[17:42:45.939]   - Field: ‘conditions’
[17:42:45.939]   - Field: ‘expr’
[17:42:45.939]   - Field: ‘uuid’
[17:42:45.939]   - Field: ‘seed’
[17:42:45.940]   - Field: ‘version’
[17:42:45.940]   - Field: ‘result’
[17:42:45.940]   - Field: ‘asynchronous’
[17:42:45.940]   - Field: ‘calls’
[17:42:45.940]   - Field: ‘globals’
[17:42:45.940]   - Field: ‘stdout’
[17:42:45.940]   - Field: ‘earlySignal’
[17:42:45.941]   - Field: ‘lazy’
[17:42:45.941]   - Field: ‘state’
[17:42:45.941] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.941] - Launch lazy future ...
[17:42:45.941] Packages needed by the future expression (n = 1): ‘future’
[17:42:45.942] Packages needed by future strategies (n = 0): <none>
[17:42:45.943] {
[17:42:45.943]     {
[17:42:45.943]         {
[17:42:45.943]             ...future.startTime <- base::Sys.time()
[17:42:45.943]             {
[17:42:45.943]                 {
[17:42:45.943]                   {
[17:42:45.943]                     {
[17:42:45.943]                       {
[17:42:45.943]                         base::local({
[17:42:45.943]                           has_future <- base::requireNamespace("future", 
[17:42:45.943]                             quietly = TRUE)
[17:42:45.943]                           if (has_future) {
[17:42:45.943]                             ns <- base::getNamespace("future")
[17:42:45.943]                             version <- ns[[".package"]][["version"]]
[17:42:45.943]                             if (is.null(version)) 
[17:42:45.943]                               version <- utils::packageVersion("future")
[17:42:45.943]                           }
[17:42:45.943]                           else {
[17:42:45.943]                             version <- NULL
[17:42:45.943]                           }
[17:42:45.943]                           if (!has_future || version < "1.8.0") {
[17:42:45.943]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.943]                               "", base::R.version$version.string), 
[17:42:45.943]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:45.943]                                 base::R.version$platform, 8 * 
[17:42:45.943]                                   base::.Machine$sizeof.pointer), 
[17:42:45.943]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.943]                                 "release", "version")], collapse = " "), 
[17:42:45.943]                               hostname = base::Sys.info()[["nodename"]])
[17:42:45.943]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.943]                               info)
[17:42:45.943]                             info <- base::paste(info, collapse = "; ")
[17:42:45.943]                             if (!has_future) {
[17:42:45.943]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.943]                                 info)
[17:42:45.943]                             }
[17:42:45.943]                             else {
[17:42:45.943]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.943]                                 info, version)
[17:42:45.943]                             }
[17:42:45.943]                             base::stop(msg)
[17:42:45.943]                           }
[17:42:45.943]                         })
[17:42:45.943]                       }
[17:42:45.943]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.943]                       base::options(mc.cores = 1L)
[17:42:45.943]                     }
[17:42:45.943]                     base::local({
[17:42:45.943]                       for (pkg in "future") {
[17:42:45.943]                         base::loadNamespace(pkg)
[17:42:45.943]                         base::library(pkg, character.only = TRUE)
[17:42:45.943]                       }
[17:42:45.943]                     })
[17:42:45.943]                   }
[17:42:45.943]                   options(future.plan = NULL)
[17:42:45.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.943]                 }
[17:42:45.943]                 ...future.workdir <- getwd()
[17:42:45.943]             }
[17:42:45.943]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.943]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.943]         }
[17:42:45.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.943]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.943]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.943]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.943]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.943]             base::names(...future.oldOptions))
[17:42:45.943]     }
[17:42:45.943]     if (FALSE) {
[17:42:45.943]     }
[17:42:45.943]     else {
[17:42:45.943]         if (TRUE) {
[17:42:45.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.943]                 open = "w")
[17:42:45.943]         }
[17:42:45.943]         else {
[17:42:45.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.943]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.943]         }
[17:42:45.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.943]             base::sink(type = "output", split = FALSE)
[17:42:45.943]             base::close(...future.stdout)
[17:42:45.943]         }, add = TRUE)
[17:42:45.943]     }
[17:42:45.943]     ...future.frame <- base::sys.nframe()
[17:42:45.943]     ...future.conditions <- base::list()
[17:42:45.943]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.943]     if (FALSE) {
[17:42:45.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.943]     }
[17:42:45.943]     ...future.result <- base::tryCatch({
[17:42:45.943]         base::withCallingHandlers({
[17:42:45.943]             ...future.value <- base::withVisible(base::local({
[17:42:45.943]                 withCallingHandlers({
[17:42:45.943]                   value(a) + 1
[17:42:45.943]                 }, immediateCondition = function(cond) {
[17:42:45.943]                   save_rds <- function (object, pathname, ...) 
[17:42:45.943]                   {
[17:42:45.943]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.943]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.943]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.943]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.943]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.943]                         fi_tmp[["mtime"]])
[17:42:45.943]                     }
[17:42:45.943]                     tryCatch({
[17:42:45.943]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.943]                     }, error = function(ex) {
[17:42:45.943]                       msg <- conditionMessage(ex)
[17:42:45.943]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.943]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.943]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.943]                         fi_tmp[["mtime"]], msg)
[17:42:45.943]                       ex$message <- msg
[17:42:45.943]                       stop(ex)
[17:42:45.943]                     })
[17:42:45.943]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.943]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.943]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.943]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.943]                       fi <- file.info(pathname)
[17:42:45.943]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.943]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.943]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.943]                         fi[["size"]], fi[["mtime"]])
[17:42:45.943]                       stop(msg)
[17:42:45.943]                     }
[17:42:45.943]                     invisible(pathname)
[17:42:45.943]                   }
[17:42:45.943]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.943]                     rootPath = tempdir()) 
[17:42:45.943]                   {
[17:42:45.943]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.943]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.943]                       tmpdir = path, fileext = ".rds")
[17:42:45.943]                     save_rds(obj, file)
[17:42:45.943]                   }
[17:42:45.943]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.943]                   {
[17:42:45.943]                     inherits <- base::inherits
[17:42:45.943]                     invokeRestart <- base::invokeRestart
[17:42:45.943]                     is.null <- base::is.null
[17:42:45.943]                     muffled <- FALSE
[17:42:45.943]                     if (inherits(cond, "message")) {
[17:42:45.943]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.943]                       if (muffled) 
[17:42:45.943]                         invokeRestart("muffleMessage")
[17:42:45.943]                     }
[17:42:45.943]                     else if (inherits(cond, "warning")) {
[17:42:45.943]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.943]                       if (muffled) 
[17:42:45.943]                         invokeRestart("muffleWarning")
[17:42:45.943]                     }
[17:42:45.943]                     else if (inherits(cond, "condition")) {
[17:42:45.943]                       if (!is.null(pattern)) {
[17:42:45.943]                         computeRestarts <- base::computeRestarts
[17:42:45.943]                         grepl <- base::grepl
[17:42:45.943]                         restarts <- computeRestarts(cond)
[17:42:45.943]                         for (restart in restarts) {
[17:42:45.943]                           name <- restart$name
[17:42:45.943]                           if (is.null(name)) 
[17:42:45.943]                             next
[17:42:45.943]                           if (!grepl(pattern, name)) 
[17:42:45.943]                             next
[17:42:45.943]                           invokeRestart(restart)
[17:42:45.943]                           muffled <- TRUE
[17:42:45.943]                           break
[17:42:45.943]                         }
[17:42:45.943]                       }
[17:42:45.943]                     }
[17:42:45.943]                     invisible(muffled)
[17:42:45.943]                   }
[17:42:45.943]                   muffleCondition(cond)
[17:42:45.943]                 })
[17:42:45.943]             }))
[17:42:45.943]             future::FutureResult(value = ...future.value$value, 
[17:42:45.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.943]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.943]                     ...future.globalenv.names))
[17:42:45.943]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.943]         }, condition = base::local({
[17:42:45.943]             c <- base::c
[17:42:45.943]             inherits <- base::inherits
[17:42:45.943]             invokeRestart <- base::invokeRestart
[17:42:45.943]             length <- base::length
[17:42:45.943]             list <- base::list
[17:42:45.943]             seq.int <- base::seq.int
[17:42:45.943]             signalCondition <- base::signalCondition
[17:42:45.943]             sys.calls <- base::sys.calls
[17:42:45.943]             `[[` <- base::`[[`
[17:42:45.943]             `+` <- base::`+`
[17:42:45.943]             `<<-` <- base::`<<-`
[17:42:45.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.943]                   3L)]
[17:42:45.943]             }
[17:42:45.943]             function(cond) {
[17:42:45.943]                 is_error <- inherits(cond, "error")
[17:42:45.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.943]                   NULL)
[17:42:45.943]                 if (is_error) {
[17:42:45.943]                   sessionInformation <- function() {
[17:42:45.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.943]                       search = base::search(), system = base::Sys.info())
[17:42:45.943]                   }
[17:42:45.943]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.943]                     cond$call), session = sessionInformation(), 
[17:42:45.943]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.943]                   signalCondition(cond)
[17:42:45.943]                 }
[17:42:45.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.943]                 "immediateCondition"))) {
[17:42:45.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.943]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.943]                   if (TRUE && !signal) {
[17:42:45.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.943]                     {
[17:42:45.943]                       inherits <- base::inherits
[17:42:45.943]                       invokeRestart <- base::invokeRestart
[17:42:45.943]                       is.null <- base::is.null
[17:42:45.943]                       muffled <- FALSE
[17:42:45.943]                       if (inherits(cond, "message")) {
[17:42:45.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.943]                         if (muffled) 
[17:42:45.943]                           invokeRestart("muffleMessage")
[17:42:45.943]                       }
[17:42:45.943]                       else if (inherits(cond, "warning")) {
[17:42:45.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.943]                         if (muffled) 
[17:42:45.943]                           invokeRestart("muffleWarning")
[17:42:45.943]                       }
[17:42:45.943]                       else if (inherits(cond, "condition")) {
[17:42:45.943]                         if (!is.null(pattern)) {
[17:42:45.943]                           computeRestarts <- base::computeRestarts
[17:42:45.943]                           grepl <- base::grepl
[17:42:45.943]                           restarts <- computeRestarts(cond)
[17:42:45.943]                           for (restart in restarts) {
[17:42:45.943]                             name <- restart$name
[17:42:45.943]                             if (is.null(name)) 
[17:42:45.943]                               next
[17:42:45.943]                             if (!grepl(pattern, name)) 
[17:42:45.943]                               next
[17:42:45.943]                             invokeRestart(restart)
[17:42:45.943]                             muffled <- TRUE
[17:42:45.943]                             break
[17:42:45.943]                           }
[17:42:45.943]                         }
[17:42:45.943]                       }
[17:42:45.943]                       invisible(muffled)
[17:42:45.943]                     }
[17:42:45.943]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.943]                   }
[17:42:45.943]                 }
[17:42:45.943]                 else {
[17:42:45.943]                   if (TRUE) {
[17:42:45.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.943]                     {
[17:42:45.943]                       inherits <- base::inherits
[17:42:45.943]                       invokeRestart <- base::invokeRestart
[17:42:45.943]                       is.null <- base::is.null
[17:42:45.943]                       muffled <- FALSE
[17:42:45.943]                       if (inherits(cond, "message")) {
[17:42:45.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.943]                         if (muffled) 
[17:42:45.943]                           invokeRestart("muffleMessage")
[17:42:45.943]                       }
[17:42:45.943]                       else if (inherits(cond, "warning")) {
[17:42:45.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.943]                         if (muffled) 
[17:42:45.943]                           invokeRestart("muffleWarning")
[17:42:45.943]                       }
[17:42:45.943]                       else if (inherits(cond, "condition")) {
[17:42:45.943]                         if (!is.null(pattern)) {
[17:42:45.943]                           computeRestarts <- base::computeRestarts
[17:42:45.943]                           grepl <- base::grepl
[17:42:45.943]                           restarts <- computeRestarts(cond)
[17:42:45.943]                           for (restart in restarts) {
[17:42:45.943]                             name <- restart$name
[17:42:45.943]                             if (is.null(name)) 
[17:42:45.943]                               next
[17:42:45.943]                             if (!grepl(pattern, name)) 
[17:42:45.943]                               next
[17:42:45.943]                             invokeRestart(restart)
[17:42:45.943]                             muffled <- TRUE
[17:42:45.943]                             break
[17:42:45.943]                           }
[17:42:45.943]                         }
[17:42:45.943]                       }
[17:42:45.943]                       invisible(muffled)
[17:42:45.943]                     }
[17:42:45.943]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.943]                   }
[17:42:45.943]                 }
[17:42:45.943]             }
[17:42:45.943]         }))
[17:42:45.943]     }, error = function(ex) {
[17:42:45.943]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.943]                 ...future.rng), started = ...future.startTime, 
[17:42:45.943]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.943]             version = "1.8"), class = "FutureResult")
[17:42:45.943]     }, finally = {
[17:42:45.943]         if (!identical(...future.workdir, getwd())) 
[17:42:45.943]             setwd(...future.workdir)
[17:42:45.943]         {
[17:42:45.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.943]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.943]             }
[17:42:45.943]             base::options(...future.oldOptions)
[17:42:45.943]             if (.Platform$OS.type == "windows") {
[17:42:45.943]                 old_names <- names(...future.oldEnvVars)
[17:42:45.943]                 envs <- base::Sys.getenv()
[17:42:45.943]                 names <- names(envs)
[17:42:45.943]                 common <- intersect(names, old_names)
[17:42:45.943]                 added <- setdiff(names, old_names)
[17:42:45.943]                 removed <- setdiff(old_names, names)
[17:42:45.943]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.943]                   envs[common]]
[17:42:45.943]                 NAMES <- toupper(changed)
[17:42:45.943]                 args <- list()
[17:42:45.943]                 for (kk in seq_along(NAMES)) {
[17:42:45.943]                   name <- changed[[kk]]
[17:42:45.943]                   NAME <- NAMES[[kk]]
[17:42:45.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.943]                     next
[17:42:45.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.943]                 }
[17:42:45.943]                 NAMES <- toupper(added)
[17:42:45.943]                 for (kk in seq_along(NAMES)) {
[17:42:45.943]                   name <- added[[kk]]
[17:42:45.943]                   NAME <- NAMES[[kk]]
[17:42:45.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.943]                     next
[17:42:45.943]                   args[[name]] <- ""
[17:42:45.943]                 }
[17:42:45.943]                 NAMES <- toupper(removed)
[17:42:45.943]                 for (kk in seq_along(NAMES)) {
[17:42:45.943]                   name <- removed[[kk]]
[17:42:45.943]                   NAME <- NAMES[[kk]]
[17:42:45.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.943]                     next
[17:42:45.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.943]                 }
[17:42:45.943]                 if (length(args) > 0) 
[17:42:45.943]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.943]             }
[17:42:45.943]             else {
[17:42:45.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.943]             }
[17:42:45.943]             {
[17:42:45.943]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.943]                   0L) {
[17:42:45.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.943]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.943]                   base::options(opts)
[17:42:45.943]                 }
[17:42:45.943]                 {
[17:42:45.943]                   {
[17:42:45.943]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.943]                     NULL
[17:42:45.943]                   }
[17:42:45.943]                   options(future.plan = NULL)
[17:42:45.943]                   if (is.na(NA_character_)) 
[17:42:45.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.943]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.943]                     envir = parent.frame()) 
[17:42:45.943]                   {
[17:42:45.943]                     default_workers <- missing(workers)
[17:42:45.943]                     if (is.function(workers)) 
[17:42:45.943]                       workers <- workers()
[17:42:45.943]                     workers <- structure(as.integer(workers), 
[17:42:45.943]                       class = class(workers))
[17:42:45.943]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.943]                       1L)
[17:42:45.943]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.943]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.943]                       if (default_workers) 
[17:42:45.943]                         supportsMulticore(warn = TRUE)
[17:42:45.943]                       return(sequential(..., envir = envir))
[17:42:45.943]                     }
[17:42:45.943]                     oopts <- options(mc.cores = workers)
[17:42:45.943]                     on.exit(options(oopts))
[17:42:45.943]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.943]                       envir = envir)
[17:42:45.943]                     if (!future$lazy) 
[17:42:45.943]                       future <- run(future)
[17:42:45.943]                     invisible(future)
[17:42:45.943]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.943]                 }
[17:42:45.943]             }
[17:42:45.943]         }
[17:42:45.943]     })
[17:42:45.943]     if (TRUE) {
[17:42:45.943]         base::sink(type = "output", split = FALSE)
[17:42:45.943]         if (TRUE) {
[17:42:45.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.943]         }
[17:42:45.943]         else {
[17:42:45.943]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.943]         }
[17:42:45.943]         base::close(...future.stdout)
[17:42:45.943]         ...future.stdout <- NULL
[17:42:45.943]     }
[17:42:45.943]     ...future.result$conditions <- ...future.conditions
[17:42:45.943]     ...future.result$finished <- base::Sys.time()
[17:42:45.943]     ...future.result
[17:42:45.943] }
[17:42:45.945] assign_globals() ...
[17:42:45.945] List of 1
[17:42:45.945]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x56181b039b00> 
[17:42:45.945]  - attr(*, "where")=List of 1
[17:42:45.945]   ..$ a:<environment: R_EmptyEnv> 
[17:42:45.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:45.945]  - attr(*, "resolved")= logi TRUE
[17:42:45.945]  - attr(*, "total_size")= num 1629624
[17:42:45.945]  - attr(*, "already-done")= logi TRUE
[17:42:45.949] - copied ‘a’ to environment
[17:42:45.949] assign_globals() ... done
[17:42:45.949] requestCore(): workers = 2
[17:42:45.951] MulticoreFuture started
[17:42:45.952] - Launch lazy future ... done
[17:42:45.952] run() for ‘MulticoreFuture’ ... done
[17:42:45.953] plan(): Setting new future strategy stack:
[17:42:45.954] List of future strategies:
[17:42:45.954] 1. sequential:
[17:42:45.954]    - args: function (..., envir = parent.frame())
[17:42:45.954]    - tweaked: FALSE
[17:42:45.954]    - call: NULL
[17:42:45.955] plan(): nbrOfWorkers() = 1
[17:42:45.957] plan(): Setting new future strategy stack:
[17:42:45.957] List of future strategies:
[17:42:45.957] 1. multicore:
[17:42:45.957]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.957]    - tweaked: FALSE
[17:42:45.957]    - call: plan(strategy)
[17:42:45.963] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.964] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.965] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.965] 
[17:42:45.965] Searching for globals ... DONE
[17:42:45.966] - globals: [0] <none>
[17:42:45.966] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:45.966] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:45.966] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:45.968] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:45.968] Searching for globals ... DONE
[17:42:45.968] Resolving globals: TRUE
[17:42:45.968] Resolving any globals that are futures ...
[17:42:45.968] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:45.968] Resolving any globals that are futures ... DONE
[17:42:45.969] Resolving futures part of globals (recursively) ...
[17:42:45.969] resolve() on list ...
[17:42:45.969]  recursive: 99
[17:42:45.969]  length: 1
[17:42:45.970]  elements: ‘a’
[17:42:45.970] run() for ‘Future’ ...
[17:42:45.970] - state: ‘created’
[17:42:45.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:45.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:45.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:45.975]   - Field: ‘label’
[17:42:45.975]   - Field: ‘local’
[17:42:45.975]   - Field: ‘owner’
[17:42:45.975]   - Field: ‘envir’
[17:42:45.975]   - Field: ‘workers’
[17:42:45.975]   - Field: ‘packages’
[17:42:45.976]   - Field: ‘gc’
[17:42:45.976]   - Field: ‘job’
[17:42:45.976]   - Field: ‘conditions’
[17:42:45.976]   - Field: ‘expr’
[17:42:45.976]   - Field: ‘uuid’
[17:42:45.976]   - Field: ‘seed’
[17:42:45.976]   - Field: ‘version’
[17:42:45.976]   - Field: ‘result’
[17:42:45.977]   - Field: ‘asynchronous’
[17:42:45.977]   - Field: ‘calls’
[17:42:45.977]   - Field: ‘globals’
[17:42:45.977]   - Field: ‘stdout’
[17:42:45.977]   - Field: ‘earlySignal’
[17:42:45.977]   - Field: ‘lazy’
[17:42:45.977]   - Field: ‘state’
[17:42:45.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:45.977] - Launch lazy future ...
[17:42:45.978] Packages needed by the future expression (n = 0): <none>
[17:42:45.978] Packages needed by future strategies (n = 0): <none>
[17:42:45.979] {
[17:42:45.979]     {
[17:42:45.979]         {
[17:42:45.979]             ...future.startTime <- base::Sys.time()
[17:42:45.979]             {
[17:42:45.979]                 {
[17:42:45.979]                   {
[17:42:45.979]                     {
[17:42:45.979]                       base::local({
[17:42:45.979]                         has_future <- base::requireNamespace("future", 
[17:42:45.979]                           quietly = TRUE)
[17:42:45.979]                         if (has_future) {
[17:42:45.979]                           ns <- base::getNamespace("future")
[17:42:45.979]                           version <- ns[[".package"]][["version"]]
[17:42:45.979]                           if (is.null(version)) 
[17:42:45.979]                             version <- utils::packageVersion("future")
[17:42:45.979]                         }
[17:42:45.979]                         else {
[17:42:45.979]                           version <- NULL
[17:42:45.979]                         }
[17:42:45.979]                         if (!has_future || version < "1.8.0") {
[17:42:45.979]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:45.979]                             "", base::R.version$version.string), 
[17:42:45.979]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:45.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:45.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:45.979]                               "release", "version")], collapse = " "), 
[17:42:45.979]                             hostname = base::Sys.info()[["nodename"]])
[17:42:45.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:45.979]                             info)
[17:42:45.979]                           info <- base::paste(info, collapse = "; ")
[17:42:45.979]                           if (!has_future) {
[17:42:45.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:45.979]                               info)
[17:42:45.979]                           }
[17:42:45.979]                           else {
[17:42:45.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:45.979]                               info, version)
[17:42:45.979]                           }
[17:42:45.979]                           base::stop(msg)
[17:42:45.979]                         }
[17:42:45.979]                       })
[17:42:45.979]                     }
[17:42:45.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:45.979]                     base::options(mc.cores = 1L)
[17:42:45.979]                   }
[17:42:45.979]                   options(future.plan = NULL)
[17:42:45.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:45.979]                 }
[17:42:45.979]                 ...future.workdir <- getwd()
[17:42:45.979]             }
[17:42:45.979]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:45.979]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:45.979]         }
[17:42:45.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:45.979]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:45.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:45.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:45.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:45.979]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:45.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:45.979]             base::names(...future.oldOptions))
[17:42:45.979]     }
[17:42:45.979]     if (FALSE) {
[17:42:45.979]     }
[17:42:45.979]     else {
[17:42:45.979]         if (TRUE) {
[17:42:45.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:45.979]                 open = "w")
[17:42:45.979]         }
[17:42:45.979]         else {
[17:42:45.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:45.979]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:45.979]         }
[17:42:45.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:45.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:45.979]             base::sink(type = "output", split = FALSE)
[17:42:45.979]             base::close(...future.stdout)
[17:42:45.979]         }, add = TRUE)
[17:42:45.979]     }
[17:42:45.979]     ...future.frame <- base::sys.nframe()
[17:42:45.979]     ...future.conditions <- base::list()
[17:42:45.979]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:45.979]     if (FALSE) {
[17:42:45.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:45.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:45.979]     }
[17:42:45.979]     ...future.result <- base::tryCatch({
[17:42:45.979]         base::withCallingHandlers({
[17:42:45.979]             ...future.value <- base::withVisible(base::local({
[17:42:45.979]                 withCallingHandlers({
[17:42:45.979]                   1
[17:42:45.979]                 }, immediateCondition = function(cond) {
[17:42:45.979]                   save_rds <- function (object, pathname, ...) 
[17:42:45.979]                   {
[17:42:45.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:45.979]                     if (file_test("-f", pathname_tmp)) {
[17:42:45.979]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:45.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.979]                         fi_tmp[["mtime"]])
[17:42:45.979]                     }
[17:42:45.979]                     tryCatch({
[17:42:45.979]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:45.979]                     }, error = function(ex) {
[17:42:45.979]                       msg <- conditionMessage(ex)
[17:42:45.979]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:45.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.979]                         fi_tmp[["mtime"]], msg)
[17:42:45.979]                       ex$message <- msg
[17:42:45.979]                       stop(ex)
[17:42:45.979]                     })
[17:42:45.979]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:45.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:45.979]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:45.979]                       fi_tmp <- file.info(pathname_tmp)
[17:42:45.979]                       fi <- file.info(pathname)
[17:42:45.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:45.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:45.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:45.979]                         fi[["size"]], fi[["mtime"]])
[17:42:45.979]                       stop(msg)
[17:42:45.979]                     }
[17:42:45.979]                     invisible(pathname)
[17:42:45.979]                   }
[17:42:45.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:45.979]                     rootPath = tempdir()) 
[17:42:45.979]                   {
[17:42:45.979]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:45.979]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:45.979]                       tmpdir = path, fileext = ".rds")
[17:42:45.979]                     save_rds(obj, file)
[17:42:45.979]                   }
[17:42:45.979]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:45.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.979]                   {
[17:42:45.979]                     inherits <- base::inherits
[17:42:45.979]                     invokeRestart <- base::invokeRestart
[17:42:45.979]                     is.null <- base::is.null
[17:42:45.979]                     muffled <- FALSE
[17:42:45.979]                     if (inherits(cond, "message")) {
[17:42:45.979]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:45.979]                       if (muffled) 
[17:42:45.979]                         invokeRestart("muffleMessage")
[17:42:45.979]                     }
[17:42:45.979]                     else if (inherits(cond, "warning")) {
[17:42:45.979]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:45.979]                       if (muffled) 
[17:42:45.979]                         invokeRestart("muffleWarning")
[17:42:45.979]                     }
[17:42:45.979]                     else if (inherits(cond, "condition")) {
[17:42:45.979]                       if (!is.null(pattern)) {
[17:42:45.979]                         computeRestarts <- base::computeRestarts
[17:42:45.979]                         grepl <- base::grepl
[17:42:45.979]                         restarts <- computeRestarts(cond)
[17:42:45.979]                         for (restart in restarts) {
[17:42:45.979]                           name <- restart$name
[17:42:45.979]                           if (is.null(name)) 
[17:42:45.979]                             next
[17:42:45.979]                           if (!grepl(pattern, name)) 
[17:42:45.979]                             next
[17:42:45.979]                           invokeRestart(restart)
[17:42:45.979]                           muffled <- TRUE
[17:42:45.979]                           break
[17:42:45.979]                         }
[17:42:45.979]                       }
[17:42:45.979]                     }
[17:42:45.979]                     invisible(muffled)
[17:42:45.979]                   }
[17:42:45.979]                   muffleCondition(cond)
[17:42:45.979]                 })
[17:42:45.979]             }))
[17:42:45.979]             future::FutureResult(value = ...future.value$value, 
[17:42:45.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.979]                   ...future.rng), globalenv = if (FALSE) 
[17:42:45.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:45.979]                     ...future.globalenv.names))
[17:42:45.979]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:45.979]         }, condition = base::local({
[17:42:45.979]             c <- base::c
[17:42:45.979]             inherits <- base::inherits
[17:42:45.979]             invokeRestart <- base::invokeRestart
[17:42:45.979]             length <- base::length
[17:42:45.979]             list <- base::list
[17:42:45.979]             seq.int <- base::seq.int
[17:42:45.979]             signalCondition <- base::signalCondition
[17:42:45.979]             sys.calls <- base::sys.calls
[17:42:45.979]             `[[` <- base::`[[`
[17:42:45.979]             `+` <- base::`+`
[17:42:45.979]             `<<-` <- base::`<<-`
[17:42:45.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:45.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:45.979]                   3L)]
[17:42:45.979]             }
[17:42:45.979]             function(cond) {
[17:42:45.979]                 is_error <- inherits(cond, "error")
[17:42:45.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:45.979]                   NULL)
[17:42:45.979]                 if (is_error) {
[17:42:45.979]                   sessionInformation <- function() {
[17:42:45.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:45.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:45.979]                       search = base::search(), system = base::Sys.info())
[17:42:45.979]                   }
[17:42:45.979]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:45.979]                     cond$call), session = sessionInformation(), 
[17:42:45.979]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:45.979]                   signalCondition(cond)
[17:42:45.979]                 }
[17:42:45.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:45.979]                 "immediateCondition"))) {
[17:42:45.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:45.979]                   ...future.conditions[[length(...future.conditions) + 
[17:42:45.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:45.979]                   if (TRUE && !signal) {
[17:42:45.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.979]                     {
[17:42:45.979]                       inherits <- base::inherits
[17:42:45.979]                       invokeRestart <- base::invokeRestart
[17:42:45.979]                       is.null <- base::is.null
[17:42:45.979]                       muffled <- FALSE
[17:42:45.979]                       if (inherits(cond, "message")) {
[17:42:45.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.979]                         if (muffled) 
[17:42:45.979]                           invokeRestart("muffleMessage")
[17:42:45.979]                       }
[17:42:45.979]                       else if (inherits(cond, "warning")) {
[17:42:45.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.979]                         if (muffled) 
[17:42:45.979]                           invokeRestart("muffleWarning")
[17:42:45.979]                       }
[17:42:45.979]                       else if (inherits(cond, "condition")) {
[17:42:45.979]                         if (!is.null(pattern)) {
[17:42:45.979]                           computeRestarts <- base::computeRestarts
[17:42:45.979]                           grepl <- base::grepl
[17:42:45.979]                           restarts <- computeRestarts(cond)
[17:42:45.979]                           for (restart in restarts) {
[17:42:45.979]                             name <- restart$name
[17:42:45.979]                             if (is.null(name)) 
[17:42:45.979]                               next
[17:42:45.979]                             if (!grepl(pattern, name)) 
[17:42:45.979]                               next
[17:42:45.979]                             invokeRestart(restart)
[17:42:45.979]                             muffled <- TRUE
[17:42:45.979]                             break
[17:42:45.979]                           }
[17:42:45.979]                         }
[17:42:45.979]                       }
[17:42:45.979]                       invisible(muffled)
[17:42:45.979]                     }
[17:42:45.979]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.979]                   }
[17:42:45.979]                 }
[17:42:45.979]                 else {
[17:42:45.979]                   if (TRUE) {
[17:42:45.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:45.979]                     {
[17:42:45.979]                       inherits <- base::inherits
[17:42:45.979]                       invokeRestart <- base::invokeRestart
[17:42:45.979]                       is.null <- base::is.null
[17:42:45.979]                       muffled <- FALSE
[17:42:45.979]                       if (inherits(cond, "message")) {
[17:42:45.979]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:45.979]                         if (muffled) 
[17:42:45.979]                           invokeRestart("muffleMessage")
[17:42:45.979]                       }
[17:42:45.979]                       else if (inherits(cond, "warning")) {
[17:42:45.979]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:45.979]                         if (muffled) 
[17:42:45.979]                           invokeRestart("muffleWarning")
[17:42:45.979]                       }
[17:42:45.979]                       else if (inherits(cond, "condition")) {
[17:42:45.979]                         if (!is.null(pattern)) {
[17:42:45.979]                           computeRestarts <- base::computeRestarts
[17:42:45.979]                           grepl <- base::grepl
[17:42:45.979]                           restarts <- computeRestarts(cond)
[17:42:45.979]                           for (restart in restarts) {
[17:42:45.979]                             name <- restart$name
[17:42:45.979]                             if (is.null(name)) 
[17:42:45.979]                               next
[17:42:45.979]                             if (!grepl(pattern, name)) 
[17:42:45.979]                               next
[17:42:45.979]                             invokeRestart(restart)
[17:42:45.979]                             muffled <- TRUE
[17:42:45.979]                             break
[17:42:45.979]                           }
[17:42:45.979]                         }
[17:42:45.979]                       }
[17:42:45.979]                       invisible(muffled)
[17:42:45.979]                     }
[17:42:45.979]                     muffleCondition(cond, pattern = "^muffle")
[17:42:45.979]                   }
[17:42:45.979]                 }
[17:42:45.979]             }
[17:42:45.979]         }))
[17:42:45.979]     }, error = function(ex) {
[17:42:45.979]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:45.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:45.979]                 ...future.rng), started = ...future.startTime, 
[17:42:45.979]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:45.979]             version = "1.8"), class = "FutureResult")
[17:42:45.979]     }, finally = {
[17:42:45.979]         if (!identical(...future.workdir, getwd())) 
[17:42:45.979]             setwd(...future.workdir)
[17:42:45.979]         {
[17:42:45.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:45.979]                 ...future.oldOptions$nwarnings <- NULL
[17:42:45.979]             }
[17:42:45.979]             base::options(...future.oldOptions)
[17:42:45.979]             if (.Platform$OS.type == "windows") {
[17:42:45.979]                 old_names <- names(...future.oldEnvVars)
[17:42:45.979]                 envs <- base::Sys.getenv()
[17:42:45.979]                 names <- names(envs)
[17:42:45.979]                 common <- intersect(names, old_names)
[17:42:45.979]                 added <- setdiff(names, old_names)
[17:42:45.979]                 removed <- setdiff(old_names, names)
[17:42:45.979]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:45.979]                   envs[common]]
[17:42:45.979]                 NAMES <- toupper(changed)
[17:42:45.979]                 args <- list()
[17:42:45.979]                 for (kk in seq_along(NAMES)) {
[17:42:45.979]                   name <- changed[[kk]]
[17:42:45.979]                   NAME <- NAMES[[kk]]
[17:42:45.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.979]                     next
[17:42:45.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.979]                 }
[17:42:45.979]                 NAMES <- toupper(added)
[17:42:45.979]                 for (kk in seq_along(NAMES)) {
[17:42:45.979]                   name <- added[[kk]]
[17:42:45.979]                   NAME <- NAMES[[kk]]
[17:42:45.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.979]                     next
[17:42:45.979]                   args[[name]] <- ""
[17:42:45.979]                 }
[17:42:45.979]                 NAMES <- toupper(removed)
[17:42:45.979]                 for (kk in seq_along(NAMES)) {
[17:42:45.979]                   name <- removed[[kk]]
[17:42:45.979]                   NAME <- NAMES[[kk]]
[17:42:45.979]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:45.979]                     next
[17:42:45.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:45.979]                 }
[17:42:45.979]                 if (length(args) > 0) 
[17:42:45.979]                   base::do.call(base::Sys.setenv, args = args)
[17:42:45.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:45.979]             }
[17:42:45.979]             else {
[17:42:45.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:45.979]             }
[17:42:45.979]             {
[17:42:45.979]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:45.979]                   0L) {
[17:42:45.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:45.979]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:45.979]                   base::options(opts)
[17:42:45.979]                 }
[17:42:45.979]                 {
[17:42:45.979]                   {
[17:42:45.979]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:45.979]                     NULL
[17:42:45.979]                   }
[17:42:45.979]                   options(future.plan = NULL)
[17:42:45.979]                   if (is.na(NA_character_)) 
[17:42:45.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:45.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:45.979]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:45.979]                     envir = parent.frame()) 
[17:42:45.979]                   {
[17:42:45.979]                     default_workers <- missing(workers)
[17:42:45.979]                     if (is.function(workers)) 
[17:42:45.979]                       workers <- workers()
[17:42:45.979]                     workers <- structure(as.integer(workers), 
[17:42:45.979]                       class = class(workers))
[17:42:45.979]                     stop_if_not(is.finite(workers), workers >= 
[17:42:45.979]                       1L)
[17:42:45.979]                     if ((workers == 1L && !inherits(workers, 
[17:42:45.979]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:45.979]                       if (default_workers) 
[17:42:45.979]                         supportsMulticore(warn = TRUE)
[17:42:45.979]                       return(sequential(..., envir = envir))
[17:42:45.979]                     }
[17:42:45.979]                     oopts <- options(mc.cores = workers)
[17:42:45.979]                     on.exit(options(oopts))
[17:42:45.979]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:45.979]                       envir = envir)
[17:42:45.979]                     if (!future$lazy) 
[17:42:45.979]                       future <- run(future)
[17:42:45.979]                     invisible(future)
[17:42:45.979]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:45.979]                 }
[17:42:45.979]             }
[17:42:45.979]         }
[17:42:45.979]     })
[17:42:45.979]     if (TRUE) {
[17:42:45.979]         base::sink(type = "output", split = FALSE)
[17:42:45.979]         if (TRUE) {
[17:42:45.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:45.979]         }
[17:42:45.979]         else {
[17:42:45.979]             ...future.result["stdout"] <- base::list(NULL)
[17:42:45.979]         }
[17:42:45.979]         base::close(...future.stdout)
[17:42:45.979]         ...future.stdout <- NULL
[17:42:45.979]     }
[17:42:45.979]     ...future.result$conditions <- ...future.conditions
[17:42:45.979]     ...future.result$finished <- base::Sys.time()
[17:42:45.979]     ...future.result
[17:42:45.979] }
[17:42:45.982] requestCore(): workers = 2
[17:42:45.984] MulticoreFuture started
[17:42:45.984] - Launch lazy future ... done
[17:42:45.984] run() for ‘MulticoreFuture’ ... done
[17:42:45.985] plan(): Setting new future strategy stack:
[17:42:45.985] List of future strategies:
[17:42:45.985] 1. sequential:
[17:42:45.985]    - args: function (..., envir = parent.frame())
[17:42:45.985]    - tweaked: FALSE
[17:42:45.985]    - call: NULL
[17:42:45.986] plan(): nbrOfWorkers() = 1
[17:42:45.988] plan(): Setting new future strategy stack:
[17:42:45.989] List of future strategies:
[17:42:45.989] 1. multicore:
[17:42:45.989]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:45.989]    - tweaked: FALSE
[17:42:45.989]    - call: plan(strategy)
[17:42:46.000] plan(): nbrOfWorkers() = 2
[17:42:46.005] Future #1
[17:42:46.007] A MulticoreFuture was resolved
[17:42:46.007]  length: 0 (resolved future 1)
[17:42:46.007] resolve() on list ... DONE
[17:42:46.007] - globals: [1] ‘a’
[17:42:46.008] Resolving futures part of globals (recursively) ... DONE
[17:42:46.015] The total size of the 1 globals is 1.55 MiB (1629624 bytes)
[17:42:46.015] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:46.015] - globals: [1] ‘a’
[17:42:46.016] - packages: [1] ‘future’
[17:42:46.016] getGlobalsAndPackages() ... DONE
[17:42:46.016] run() for ‘Future’ ...
[17:42:46.017] - state: ‘created’
[17:42:46.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:46.022] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:46.022] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:46.022]   - Field: ‘label’
[17:42:46.022]   - Field: ‘local’
[17:42:46.022]   - Field: ‘owner’
[17:42:46.022]   - Field: ‘envir’
[17:42:46.022]   - Field: ‘workers’
[17:42:46.023]   - Field: ‘packages’
[17:42:46.023]   - Field: ‘gc’
[17:42:46.023]   - Field: ‘job’
[17:42:46.023]   - Field: ‘conditions’
[17:42:46.023]   - Field: ‘expr’
[17:42:46.023]   - Field: ‘uuid’
[17:42:46.023]   - Field: ‘seed’
[17:42:46.023]   - Field: ‘version’
[17:42:46.024]   - Field: ‘result’
[17:42:46.024]   - Field: ‘asynchronous’
[17:42:46.024]   - Field: ‘calls’
[17:42:46.024]   - Field: ‘globals’
[17:42:46.024]   - Field: ‘stdout’
[17:42:46.024]   - Field: ‘earlySignal’
[17:42:46.024]   - Field: ‘lazy’
[17:42:46.024]   - Field: ‘state’
[17:42:46.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:46.025] - Launch lazy future ...
[17:42:46.025] Packages needed by the future expression (n = 1): ‘future’
[17:42:46.025] Packages needed by future strategies (n = 0): <none>
[17:42:46.026] {
[17:42:46.026]     {
[17:42:46.026]         {
[17:42:46.026]             ...future.startTime <- base::Sys.time()
[17:42:46.026]             {
[17:42:46.026]                 {
[17:42:46.026]                   {
[17:42:46.026]                     {
[17:42:46.026]                       {
[17:42:46.026]                         base::local({
[17:42:46.026]                           has_future <- base::requireNamespace("future", 
[17:42:46.026]                             quietly = TRUE)
[17:42:46.026]                           if (has_future) {
[17:42:46.026]                             ns <- base::getNamespace("future")
[17:42:46.026]                             version <- ns[[".package"]][["version"]]
[17:42:46.026]                             if (is.null(version)) 
[17:42:46.026]                               version <- utils::packageVersion("future")
[17:42:46.026]                           }
[17:42:46.026]                           else {
[17:42:46.026]                             version <- NULL
[17:42:46.026]                           }
[17:42:46.026]                           if (!has_future || version < "1.8.0") {
[17:42:46.026]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.026]                               "", base::R.version$version.string), 
[17:42:46.026]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:46.026]                                 base::R.version$platform, 8 * 
[17:42:46.026]                                   base::.Machine$sizeof.pointer), 
[17:42:46.026]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.026]                                 "release", "version")], collapse = " "), 
[17:42:46.026]                               hostname = base::Sys.info()[["nodename"]])
[17:42:46.026]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.026]                               info)
[17:42:46.026]                             info <- base::paste(info, collapse = "; ")
[17:42:46.026]                             if (!has_future) {
[17:42:46.026]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.026]                                 info)
[17:42:46.026]                             }
[17:42:46.026]                             else {
[17:42:46.026]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.026]                                 info, version)
[17:42:46.026]                             }
[17:42:46.026]                             base::stop(msg)
[17:42:46.026]                           }
[17:42:46.026]                         })
[17:42:46.026]                       }
[17:42:46.026]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.026]                       base::options(mc.cores = 1L)
[17:42:46.026]                     }
[17:42:46.026]                     base::local({
[17:42:46.026]                       for (pkg in "future") {
[17:42:46.026]                         base::loadNamespace(pkg)
[17:42:46.026]                         base::library(pkg, character.only = TRUE)
[17:42:46.026]                       }
[17:42:46.026]                     })
[17:42:46.026]                   }
[17:42:46.026]                   options(future.plan = NULL)
[17:42:46.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.026]                 }
[17:42:46.026]                 ...future.workdir <- getwd()
[17:42:46.026]             }
[17:42:46.026]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.026]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.026]         }
[17:42:46.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.026]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:46.026]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.026]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.026]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.026]             base::names(...future.oldOptions))
[17:42:46.026]     }
[17:42:46.026]     if (FALSE) {
[17:42:46.026]     }
[17:42:46.026]     else {
[17:42:46.026]         if (TRUE) {
[17:42:46.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.026]                 open = "w")
[17:42:46.026]         }
[17:42:46.026]         else {
[17:42:46.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.026]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.026]         }
[17:42:46.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.026]             base::sink(type = "output", split = FALSE)
[17:42:46.026]             base::close(...future.stdout)
[17:42:46.026]         }, add = TRUE)
[17:42:46.026]     }
[17:42:46.026]     ...future.frame <- base::sys.nframe()
[17:42:46.026]     ...future.conditions <- base::list()
[17:42:46.026]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.026]     if (FALSE) {
[17:42:46.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.026]     }
[17:42:46.026]     ...future.result <- base::tryCatch({
[17:42:46.026]         base::withCallingHandlers({
[17:42:46.026]             ...future.value <- base::withVisible(base::local({
[17:42:46.026]                 withCallingHandlers({
[17:42:46.026]                   value(a) + 1
[17:42:46.026]                 }, immediateCondition = function(cond) {
[17:42:46.026]                   save_rds <- function (object, pathname, ...) 
[17:42:46.026]                   {
[17:42:46.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:46.026]                     if (file_test("-f", pathname_tmp)) {
[17:42:46.026]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:46.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.026]                         fi_tmp[["mtime"]])
[17:42:46.026]                     }
[17:42:46.026]                     tryCatch({
[17:42:46.026]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:46.026]                     }, error = function(ex) {
[17:42:46.026]                       msg <- conditionMessage(ex)
[17:42:46.026]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:46.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.026]                         fi_tmp[["mtime"]], msg)
[17:42:46.026]                       ex$message <- msg
[17:42:46.026]                       stop(ex)
[17:42:46.026]                     })
[17:42:46.026]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:46.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:46.026]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:46.026]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.026]                       fi <- file.info(pathname)
[17:42:46.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:46.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:46.026]                         fi[["size"]], fi[["mtime"]])
[17:42:46.026]                       stop(msg)
[17:42:46.026]                     }
[17:42:46.026]                     invisible(pathname)
[17:42:46.026]                   }
[17:42:46.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:46.026]                     rootPath = tempdir()) 
[17:42:46.026]                   {
[17:42:46.026]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:46.026]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:46.026]                       tmpdir = path, fileext = ".rds")
[17:42:46.026]                     save_rds(obj, file)
[17:42:46.026]                   }
[17:42:46.026]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:46.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.026]                   {
[17:42:46.026]                     inherits <- base::inherits
[17:42:46.026]                     invokeRestart <- base::invokeRestart
[17:42:46.026]                     is.null <- base::is.null
[17:42:46.026]                     muffled <- FALSE
[17:42:46.026]                     if (inherits(cond, "message")) {
[17:42:46.026]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.026]                       if (muffled) 
[17:42:46.026]                         invokeRestart("muffleMessage")
[17:42:46.026]                     }
[17:42:46.026]                     else if (inherits(cond, "warning")) {
[17:42:46.026]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.026]                       if (muffled) 
[17:42:46.026]                         invokeRestart("muffleWarning")
[17:42:46.026]                     }
[17:42:46.026]                     else if (inherits(cond, "condition")) {
[17:42:46.026]                       if (!is.null(pattern)) {
[17:42:46.026]                         computeRestarts <- base::computeRestarts
[17:42:46.026]                         grepl <- base::grepl
[17:42:46.026]                         restarts <- computeRestarts(cond)
[17:42:46.026]                         for (restart in restarts) {
[17:42:46.026]                           name <- restart$name
[17:42:46.026]                           if (is.null(name)) 
[17:42:46.026]                             next
[17:42:46.026]                           if (!grepl(pattern, name)) 
[17:42:46.026]                             next
[17:42:46.026]                           invokeRestart(restart)
[17:42:46.026]                           muffled <- TRUE
[17:42:46.026]                           break
[17:42:46.026]                         }
[17:42:46.026]                       }
[17:42:46.026]                     }
[17:42:46.026]                     invisible(muffled)
[17:42:46.026]                   }
[17:42:46.026]                   muffleCondition(cond)
[17:42:46.026]                 })
[17:42:46.026]             }))
[17:42:46.026]             future::FutureResult(value = ...future.value$value, 
[17:42:46.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.026]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.026]                     ...future.globalenv.names))
[17:42:46.026]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.026]         }, condition = base::local({
[17:42:46.026]             c <- base::c
[17:42:46.026]             inherits <- base::inherits
[17:42:46.026]             invokeRestart <- base::invokeRestart
[17:42:46.026]             length <- base::length
[17:42:46.026]             list <- base::list
[17:42:46.026]             seq.int <- base::seq.int
[17:42:46.026]             signalCondition <- base::signalCondition
[17:42:46.026]             sys.calls <- base::sys.calls
[17:42:46.026]             `[[` <- base::`[[`
[17:42:46.026]             `+` <- base::`+`
[17:42:46.026]             `<<-` <- base::`<<-`
[17:42:46.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.026]                   3L)]
[17:42:46.026]             }
[17:42:46.026]             function(cond) {
[17:42:46.026]                 is_error <- inherits(cond, "error")
[17:42:46.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.026]                   NULL)
[17:42:46.026]                 if (is_error) {
[17:42:46.026]                   sessionInformation <- function() {
[17:42:46.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.026]                       search = base::search(), system = base::Sys.info())
[17:42:46.026]                   }
[17:42:46.026]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.026]                     cond$call), session = sessionInformation(), 
[17:42:46.026]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.026]                   signalCondition(cond)
[17:42:46.026]                 }
[17:42:46.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.026]                 "immediateCondition"))) {
[17:42:46.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.026]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.026]                   if (TRUE && !signal) {
[17:42:46.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.026]                     {
[17:42:46.026]                       inherits <- base::inherits
[17:42:46.026]                       invokeRestart <- base::invokeRestart
[17:42:46.026]                       is.null <- base::is.null
[17:42:46.026]                       muffled <- FALSE
[17:42:46.026]                       if (inherits(cond, "message")) {
[17:42:46.026]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.026]                         if (muffled) 
[17:42:46.026]                           invokeRestart("muffleMessage")
[17:42:46.026]                       }
[17:42:46.026]                       else if (inherits(cond, "warning")) {
[17:42:46.026]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.026]                         if (muffled) 
[17:42:46.026]                           invokeRestart("muffleWarning")
[17:42:46.026]                       }
[17:42:46.026]                       else if (inherits(cond, "condition")) {
[17:42:46.026]                         if (!is.null(pattern)) {
[17:42:46.026]                           computeRestarts <- base::computeRestarts
[17:42:46.026]                           grepl <- base::grepl
[17:42:46.026]                           restarts <- computeRestarts(cond)
[17:42:46.026]                           for (restart in restarts) {
[17:42:46.026]                             name <- restart$name
[17:42:46.026]                             if (is.null(name)) 
[17:42:46.026]                               next
[17:42:46.026]                             if (!grepl(pattern, name)) 
[17:42:46.026]                               next
[17:42:46.026]                             invokeRestart(restart)
[17:42:46.026]                             muffled <- TRUE
[17:42:46.026]                             break
[17:42:46.026]                           }
[17:42:46.026]                         }
[17:42:46.026]                       }
[17:42:46.026]                       invisible(muffled)
[17:42:46.026]                     }
[17:42:46.026]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.026]                   }
[17:42:46.026]                 }
[17:42:46.026]                 else {
[17:42:46.026]                   if (TRUE) {
[17:42:46.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.026]                     {
[17:42:46.026]                       inherits <- base::inherits
[17:42:46.026]                       invokeRestart <- base::invokeRestart
[17:42:46.026]                       is.null <- base::is.null
[17:42:46.026]                       muffled <- FALSE
[17:42:46.026]                       if (inherits(cond, "message")) {
[17:42:46.026]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.026]                         if (muffled) 
[17:42:46.026]                           invokeRestart("muffleMessage")
[17:42:46.026]                       }
[17:42:46.026]                       else if (inherits(cond, "warning")) {
[17:42:46.026]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.026]                         if (muffled) 
[17:42:46.026]                           invokeRestart("muffleWarning")
[17:42:46.026]                       }
[17:42:46.026]                       else if (inherits(cond, "condition")) {
[17:42:46.026]                         if (!is.null(pattern)) {
[17:42:46.026]                           computeRestarts <- base::computeRestarts
[17:42:46.026]                           grepl <- base::grepl
[17:42:46.026]                           restarts <- computeRestarts(cond)
[17:42:46.026]                           for (restart in restarts) {
[17:42:46.026]                             name <- restart$name
[17:42:46.026]                             if (is.null(name)) 
[17:42:46.026]                               next
[17:42:46.026]                             if (!grepl(pattern, name)) 
[17:42:46.026]                               next
[17:42:46.026]                             invokeRestart(restart)
[17:42:46.026]                             muffled <- TRUE
[17:42:46.026]                             break
[17:42:46.026]                           }
[17:42:46.026]                         }
[17:42:46.026]                       }
[17:42:46.026]                       invisible(muffled)
[17:42:46.026]                     }
[17:42:46.026]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.026]                   }
[17:42:46.026]                 }
[17:42:46.026]             }
[17:42:46.026]         }))
[17:42:46.026]     }, error = function(ex) {
[17:42:46.026]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.026]                 ...future.rng), started = ...future.startTime, 
[17:42:46.026]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.026]             version = "1.8"), class = "FutureResult")
[17:42:46.026]     }, finally = {
[17:42:46.026]         if (!identical(...future.workdir, getwd())) 
[17:42:46.026]             setwd(...future.workdir)
[17:42:46.026]         {
[17:42:46.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.026]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.026]             }
[17:42:46.026]             base::options(...future.oldOptions)
[17:42:46.026]             if (.Platform$OS.type == "windows") {
[17:42:46.026]                 old_names <- names(...future.oldEnvVars)
[17:42:46.026]                 envs <- base::Sys.getenv()
[17:42:46.026]                 names <- names(envs)
[17:42:46.026]                 common <- intersect(names, old_names)
[17:42:46.026]                 added <- setdiff(names, old_names)
[17:42:46.026]                 removed <- setdiff(old_names, names)
[17:42:46.026]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.026]                   envs[common]]
[17:42:46.026]                 NAMES <- toupper(changed)
[17:42:46.026]                 args <- list()
[17:42:46.026]                 for (kk in seq_along(NAMES)) {
[17:42:46.026]                   name <- changed[[kk]]
[17:42:46.026]                   NAME <- NAMES[[kk]]
[17:42:46.026]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.026]                     next
[17:42:46.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.026]                 }
[17:42:46.026]                 NAMES <- toupper(added)
[17:42:46.026]                 for (kk in seq_along(NAMES)) {
[17:42:46.026]                   name <- added[[kk]]
[17:42:46.026]                   NAME <- NAMES[[kk]]
[17:42:46.026]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.026]                     next
[17:42:46.026]                   args[[name]] <- ""
[17:42:46.026]                 }
[17:42:46.026]                 NAMES <- toupper(removed)
[17:42:46.026]                 for (kk in seq_along(NAMES)) {
[17:42:46.026]                   name <- removed[[kk]]
[17:42:46.026]                   NAME <- NAMES[[kk]]
[17:42:46.026]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.026]                     next
[17:42:46.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.026]                 }
[17:42:46.026]                 if (length(args) > 0) 
[17:42:46.026]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.026]             }
[17:42:46.026]             else {
[17:42:46.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.026]             }
[17:42:46.026]             {
[17:42:46.026]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.026]                   0L) {
[17:42:46.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.026]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.026]                   base::options(opts)
[17:42:46.026]                 }
[17:42:46.026]                 {
[17:42:46.026]                   {
[17:42:46.026]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.026]                     NULL
[17:42:46.026]                   }
[17:42:46.026]                   options(future.plan = NULL)
[17:42:46.026]                   if (is.na(NA_character_)) 
[17:42:46.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.026]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:46.026]                     envir = parent.frame()) 
[17:42:46.026]                   {
[17:42:46.026]                     default_workers <- missing(workers)
[17:42:46.026]                     if (is.function(workers)) 
[17:42:46.026]                       workers <- workers()
[17:42:46.026]                     workers <- structure(as.integer(workers), 
[17:42:46.026]                       class = class(workers))
[17:42:46.026]                     stop_if_not(is.finite(workers), workers >= 
[17:42:46.026]                       1L)
[17:42:46.026]                     if ((workers == 1L && !inherits(workers, 
[17:42:46.026]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:46.026]                       if (default_workers) 
[17:42:46.026]                         supportsMulticore(warn = TRUE)
[17:42:46.026]                       return(sequential(..., envir = envir))
[17:42:46.026]                     }
[17:42:46.026]                     oopts <- options(mc.cores = workers)
[17:42:46.026]                     on.exit(options(oopts))
[17:42:46.026]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:46.026]                       envir = envir)
[17:42:46.026]                     if (!future$lazy) 
[17:42:46.026]                       future <- run(future)
[17:42:46.026]                     invisible(future)
[17:42:46.026]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.026]                 }
[17:42:46.026]             }
[17:42:46.026]         }
[17:42:46.026]     })
[17:42:46.026]     if (TRUE) {
[17:42:46.026]         base::sink(type = "output", split = FALSE)
[17:42:46.026]         if (TRUE) {
[17:42:46.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.026]         }
[17:42:46.026]         else {
[17:42:46.026]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.026]         }
[17:42:46.026]         base::close(...future.stdout)
[17:42:46.026]         ...future.stdout <- NULL
[17:42:46.026]     }
[17:42:46.026]     ...future.result$conditions <- ...future.conditions
[17:42:46.026]     ...future.result$finished <- base::Sys.time()
[17:42:46.026]     ...future.result
[17:42:46.026] }
[17:42:46.028] assign_globals() ...
[17:42:46.028] List of 1
[17:42:46.028]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x561818b728a8> 
[17:42:46.028]  - attr(*, "where")=List of 1
[17:42:46.028]   ..$ a:<environment: R_EmptyEnv> 
[17:42:46.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:46.028]  - attr(*, "resolved")= logi TRUE
[17:42:46.028]  - attr(*, "total_size")= num 1629624
[17:42:46.028]  - attr(*, "already-done")= logi TRUE
[17:42:46.031] - copied ‘a’ to environment
[17:42:46.031] assign_globals() ... done
[17:42:46.032] requestCore(): workers = 2
[17:42:46.034] MulticoreFuture started
[17:42:46.034] - Launch lazy future ... done
[17:42:46.034] run() for ‘MulticoreFuture’ ... done
[17:42:46.035] plan(): Setting new future strategy stack:
[17:42:46.036] List of future strategies:
[17:42:46.036] 1. sequential:
[17:42:46.036]    - args: function (..., envir = parent.frame())
[17:42:46.036]    - tweaked: FALSE
[17:42:46.036]    - call: NULL
[17:42:46.037] plan(): nbrOfWorkers() = 1
[17:42:46.039] plan(): Setting new future strategy stack:
[17:42:46.039] List of future strategies:
[17:42:46.039] 1. multicore:
[17:42:46.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:46.039]    - tweaked: FALSE
[17:42:46.039]    - call: plan(strategy)
[17:42:46.045] plan(): nbrOfWorkers() = 2
value(b) = 2
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.046] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.047] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:46.048] - globals found: [2] ‘{’, ‘pkg’
[17:42:46.048] Searching for globals ... DONE
[17:42:46.048] Resolving globals: TRUE
[17:42:46.049] Resolving any globals that are futures ...
[17:42:46.049] - globals: [2] ‘{’, ‘pkg’
[17:42:46.049] Resolving any globals that are futures ... DONE
[17:42:46.049] Resolving futures part of globals (recursively) ...
[17:42:46.050] resolve() on list ...
[17:42:46.050]  recursive: 99
[17:42:46.050]  length: 1
[17:42:46.050]  elements: ‘pkg’
[17:42:46.050]  length: 0 (resolved future 1)
[17:42:46.050] resolve() on list ... DONE
[17:42:46.050] - globals: [1] ‘pkg’
[17:42:46.050] Resolving futures part of globals (recursively) ... DONE
[17:42:46.051] The total size of the 1 globals is 112 bytes (112 bytes)
[17:42:46.051] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:42:46.051] - globals: [1] ‘pkg’
[17:42:46.051] 
[17:42:46.052] getGlobalsAndPackages() ... DONE
[17:42:46.052] Packages needed by the future expression (n = 0): <none>
[17:42:46.052] Packages needed by future strategies (n = 0): <none>
[17:42:46.053] {
[17:42:46.053]     {
[17:42:46.053]         {
[17:42:46.053]             ...future.startTime <- base::Sys.time()
[17:42:46.053]             {
[17:42:46.053]                 {
[17:42:46.053]                   {
[17:42:46.053]                     base::local({
[17:42:46.053]                       has_future <- base::requireNamespace("future", 
[17:42:46.053]                         quietly = TRUE)
[17:42:46.053]                       if (has_future) {
[17:42:46.053]                         ns <- base::getNamespace("future")
[17:42:46.053]                         version <- ns[[".package"]][["version"]]
[17:42:46.053]                         if (is.null(version)) 
[17:42:46.053]                           version <- utils::packageVersion("future")
[17:42:46.053]                       }
[17:42:46.053]                       else {
[17:42:46.053]                         version <- NULL
[17:42:46.053]                       }
[17:42:46.053]                       if (!has_future || version < "1.8.0") {
[17:42:46.053]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.053]                           "", base::R.version$version.string), 
[17:42:46.053]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:46.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.053]                             "release", "version")], collapse = " "), 
[17:42:46.053]                           hostname = base::Sys.info()[["nodename"]])
[17:42:46.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.053]                           info)
[17:42:46.053]                         info <- base::paste(info, collapse = "; ")
[17:42:46.053]                         if (!has_future) {
[17:42:46.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.053]                             info)
[17:42:46.053]                         }
[17:42:46.053]                         else {
[17:42:46.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.053]                             info, version)
[17:42:46.053]                         }
[17:42:46.053]                         base::stop(msg)
[17:42:46.053]                       }
[17:42:46.053]                     })
[17:42:46.053]                   }
[17:42:46.053]                   options(future.plan = NULL)
[17:42:46.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.053]                 }
[17:42:46.053]                 ...future.workdir <- getwd()
[17:42:46.053]             }
[17:42:46.053]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.053]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.053]         }
[17:42:46.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.053]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:46.053]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.053]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.053]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.053]             base::names(...future.oldOptions))
[17:42:46.053]     }
[17:42:46.053]     if (FALSE) {
[17:42:46.053]     }
[17:42:46.053]     else {
[17:42:46.053]         if (TRUE) {
[17:42:46.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.053]                 open = "w")
[17:42:46.053]         }
[17:42:46.053]         else {
[17:42:46.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.053]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.053]         }
[17:42:46.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.053]             base::sink(type = "output", split = FALSE)
[17:42:46.053]             base::close(...future.stdout)
[17:42:46.053]         }, add = TRUE)
[17:42:46.053]     }
[17:42:46.053]     ...future.frame <- base::sys.nframe()
[17:42:46.053]     ...future.conditions <- base::list()
[17:42:46.053]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.053]     if (FALSE) {
[17:42:46.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.053]     }
[17:42:46.053]     ...future.result <- base::tryCatch({
[17:42:46.053]         base::withCallingHandlers({
[17:42:46.053]             ...future.value <- base::withVisible(base::local({
[17:42:46.053]                 pkg
[17:42:46.053]             }))
[17:42:46.053]             future::FutureResult(value = ...future.value$value, 
[17:42:46.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.053]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.053]                     ...future.globalenv.names))
[17:42:46.053]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.053]         }, condition = base::local({
[17:42:46.053]             c <- base::c
[17:42:46.053]             inherits <- base::inherits
[17:42:46.053]             invokeRestart <- base::invokeRestart
[17:42:46.053]             length <- base::length
[17:42:46.053]             list <- base::list
[17:42:46.053]             seq.int <- base::seq.int
[17:42:46.053]             signalCondition <- base::signalCondition
[17:42:46.053]             sys.calls <- base::sys.calls
[17:42:46.053]             `[[` <- base::`[[`
[17:42:46.053]             `+` <- base::`+`
[17:42:46.053]             `<<-` <- base::`<<-`
[17:42:46.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.053]                   3L)]
[17:42:46.053]             }
[17:42:46.053]             function(cond) {
[17:42:46.053]                 is_error <- inherits(cond, "error")
[17:42:46.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.053]                   NULL)
[17:42:46.053]                 if (is_error) {
[17:42:46.053]                   sessionInformation <- function() {
[17:42:46.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.053]                       search = base::search(), system = base::Sys.info())
[17:42:46.053]                   }
[17:42:46.053]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.053]                     cond$call), session = sessionInformation(), 
[17:42:46.053]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.053]                   signalCondition(cond)
[17:42:46.053]                 }
[17:42:46.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.053]                 "immediateCondition"))) {
[17:42:46.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.053]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.053]                   if (TRUE && !signal) {
[17:42:46.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.053]                     {
[17:42:46.053]                       inherits <- base::inherits
[17:42:46.053]                       invokeRestart <- base::invokeRestart
[17:42:46.053]                       is.null <- base::is.null
[17:42:46.053]                       muffled <- FALSE
[17:42:46.053]                       if (inherits(cond, "message")) {
[17:42:46.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.053]                         if (muffled) 
[17:42:46.053]                           invokeRestart("muffleMessage")
[17:42:46.053]                       }
[17:42:46.053]                       else if (inherits(cond, "warning")) {
[17:42:46.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.053]                         if (muffled) 
[17:42:46.053]                           invokeRestart("muffleWarning")
[17:42:46.053]                       }
[17:42:46.053]                       else if (inherits(cond, "condition")) {
[17:42:46.053]                         if (!is.null(pattern)) {
[17:42:46.053]                           computeRestarts <- base::computeRestarts
[17:42:46.053]                           grepl <- base::grepl
[17:42:46.053]                           restarts <- computeRestarts(cond)
[17:42:46.053]                           for (restart in restarts) {
[17:42:46.053]                             name <- restart$name
[17:42:46.053]                             if (is.null(name)) 
[17:42:46.053]                               next
[17:42:46.053]                             if (!grepl(pattern, name)) 
[17:42:46.053]                               next
[17:42:46.053]                             invokeRestart(restart)
[17:42:46.053]                             muffled <- TRUE
[17:42:46.053]                             break
[17:42:46.053]                           }
[17:42:46.053]                         }
[17:42:46.053]                       }
[17:42:46.053]                       invisible(muffled)
[17:42:46.053]                     }
[17:42:46.053]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.053]                   }
[17:42:46.053]                 }
[17:42:46.053]                 else {
[17:42:46.053]                   if (TRUE) {
[17:42:46.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.053]                     {
[17:42:46.053]                       inherits <- base::inherits
[17:42:46.053]                       invokeRestart <- base::invokeRestart
[17:42:46.053]                       is.null <- base::is.null
[17:42:46.053]                       muffled <- FALSE
[17:42:46.053]                       if (inherits(cond, "message")) {
[17:42:46.053]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.053]                         if (muffled) 
[17:42:46.053]                           invokeRestart("muffleMessage")
[17:42:46.053]                       }
[17:42:46.053]                       else if (inherits(cond, "warning")) {
[17:42:46.053]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.053]                         if (muffled) 
[17:42:46.053]                           invokeRestart("muffleWarning")
[17:42:46.053]                       }
[17:42:46.053]                       else if (inherits(cond, "condition")) {
[17:42:46.053]                         if (!is.null(pattern)) {
[17:42:46.053]                           computeRestarts <- base::computeRestarts
[17:42:46.053]                           grepl <- base::grepl
[17:42:46.053]                           restarts <- computeRestarts(cond)
[17:42:46.053]                           for (restart in restarts) {
[17:42:46.053]                             name <- restart$name
[17:42:46.053]                             if (is.null(name)) 
[17:42:46.053]                               next
[17:42:46.053]                             if (!grepl(pattern, name)) 
[17:42:46.053]                               next
[17:42:46.053]                             invokeRestart(restart)
[17:42:46.053]                             muffled <- TRUE
[17:42:46.053]                             break
[17:42:46.053]                           }
[17:42:46.053]                         }
[17:42:46.053]                       }
[17:42:46.053]                       invisible(muffled)
[17:42:46.053]                     }
[17:42:46.053]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.053]                   }
[17:42:46.053]                 }
[17:42:46.053]             }
[17:42:46.053]         }))
[17:42:46.053]     }, error = function(ex) {
[17:42:46.053]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.053]                 ...future.rng), started = ...future.startTime, 
[17:42:46.053]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.053]             version = "1.8"), class = "FutureResult")
[17:42:46.053]     }, finally = {
[17:42:46.053]         if (!identical(...future.workdir, getwd())) 
[17:42:46.053]             setwd(...future.workdir)
[17:42:46.053]         {
[17:42:46.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.053]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.053]             }
[17:42:46.053]             base::options(...future.oldOptions)
[17:42:46.053]             if (.Platform$OS.type == "windows") {
[17:42:46.053]                 old_names <- names(...future.oldEnvVars)
[17:42:46.053]                 envs <- base::Sys.getenv()
[17:42:46.053]                 names <- names(envs)
[17:42:46.053]                 common <- intersect(names, old_names)
[17:42:46.053]                 added <- setdiff(names, old_names)
[17:42:46.053]                 removed <- setdiff(old_names, names)
[17:42:46.053]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.053]                   envs[common]]
[17:42:46.053]                 NAMES <- toupper(changed)
[17:42:46.053]                 args <- list()
[17:42:46.053]                 for (kk in seq_along(NAMES)) {
[17:42:46.053]                   name <- changed[[kk]]
[17:42:46.053]                   NAME <- NAMES[[kk]]
[17:42:46.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.053]                     next
[17:42:46.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.053]                 }
[17:42:46.053]                 NAMES <- toupper(added)
[17:42:46.053]                 for (kk in seq_along(NAMES)) {
[17:42:46.053]                   name <- added[[kk]]
[17:42:46.053]                   NAME <- NAMES[[kk]]
[17:42:46.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.053]                     next
[17:42:46.053]                   args[[name]] <- ""
[17:42:46.053]                 }
[17:42:46.053]                 NAMES <- toupper(removed)
[17:42:46.053]                 for (kk in seq_along(NAMES)) {
[17:42:46.053]                   name <- removed[[kk]]
[17:42:46.053]                   NAME <- NAMES[[kk]]
[17:42:46.053]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.053]                     next
[17:42:46.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.053]                 }
[17:42:46.053]                 if (length(args) > 0) 
[17:42:46.053]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.053]             }
[17:42:46.053]             else {
[17:42:46.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.053]             }
[17:42:46.053]             {
[17:42:46.053]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.053]                   0L) {
[17:42:46.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.053]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.053]                   base::options(opts)
[17:42:46.053]                 }
[17:42:46.053]                 {
[17:42:46.053]                   {
[17:42:46.053]                     NULL
[17:42:46.053]                     RNGkind("Mersenne-Twister")
[17:42:46.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:46.053]                       inherits = FALSE)
[17:42:46.053]                   }
[17:42:46.053]                   options(future.plan = NULL)
[17:42:46.053]                   if (is.na(NA_character_)) 
[17:42:46.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.053]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:46.053]                     envir = parent.frame()) 
[17:42:46.053]                   {
[17:42:46.053]                     default_workers <- missing(workers)
[17:42:46.053]                     if (is.function(workers)) 
[17:42:46.053]                       workers <- workers()
[17:42:46.053]                     workers <- structure(as.integer(workers), 
[17:42:46.053]                       class = class(workers))
[17:42:46.053]                     stop_if_not(is.finite(workers), workers >= 
[17:42:46.053]                       1L)
[17:42:46.053]                     if ((workers == 1L && !inherits(workers, 
[17:42:46.053]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:46.053]                       if (default_workers) 
[17:42:46.053]                         supportsMulticore(warn = TRUE)
[17:42:46.053]                       return(sequential(..., envir = envir))
[17:42:46.053]                     }
[17:42:46.053]                     oopts <- options(mc.cores = workers)
[17:42:46.053]                     on.exit(options(oopts))
[17:42:46.053]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:46.053]                       envir = envir)
[17:42:46.053]                     if (!future$lazy) 
[17:42:46.053]                       future <- run(future)
[17:42:46.053]                     invisible(future)
[17:42:46.053]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.053]                 }
[17:42:46.053]             }
[17:42:46.053]         }
[17:42:46.053]     })
[17:42:46.053]     if (TRUE) {
[17:42:46.053]         base::sink(type = "output", split = FALSE)
[17:42:46.053]         if (TRUE) {
[17:42:46.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.053]         }
[17:42:46.053]         else {
[17:42:46.053]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.053]         }
[17:42:46.053]         base::close(...future.stdout)
[17:42:46.053]         ...future.stdout <- NULL
[17:42:46.053]     }
[17:42:46.053]     ...future.result$conditions <- ...future.conditions
[17:42:46.053]     ...future.result$finished <- base::Sys.time()
[17:42:46.053]     ...future.result
[17:42:46.053] }
[17:42:46.055] assign_globals() ...
[17:42:46.055] List of 1
[17:42:46.055]  $ pkg: chr "foo"
[17:42:46.055]  - attr(*, "where")=List of 1
[17:42:46.055]   ..$ pkg:<environment: R_EmptyEnv> 
[17:42:46.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:46.055]  - attr(*, "resolved")= logi TRUE
[17:42:46.055]  - attr(*, "total_size")= num 112
[17:42:46.061] - copied ‘pkg’ to environment
[17:42:46.062] assign_globals() ... done
[17:42:46.062] plan(): Setting new future strategy stack:
[17:42:46.062] List of future strategies:
[17:42:46.062] 1. sequential:
[17:42:46.062]    - args: function (..., envir = parent.frame())
[17:42:46.062]    - tweaked: FALSE
[17:42:46.062]    - call: NULL
[17:42:46.063] plan(): nbrOfWorkers() = 1
[17:42:46.064] plan(): Setting new future strategy stack:
[17:42:46.064] List of future strategies:
[17:42:46.064] 1. multicore:
[17:42:46.064]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:46.064]    - tweaked: FALSE
[17:42:46.064]    - call: plan(strategy)
[17:42:46.069] plan(): nbrOfWorkers() = 2
[17:42:46.069] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.070] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.070] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:46.073] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:42:46.073] Searching for globals ... DONE
[17:42:46.073] Resolving globals: TRUE
[17:42:46.073] Resolving any globals that are futures ...
[17:42:46.073] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:42:46.073] Resolving any globals that are futures ... DONE
[17:42:46.074] 
[17:42:46.074] 
[17:42:46.074] getGlobalsAndPackages() ... DONE
[17:42:46.074] run() for ‘Future’ ...
[17:42:46.074] - state: ‘created’
[17:42:46.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:46.078] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:46.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:46.078]   - Field: ‘label’
[17:42:46.078]   - Field: ‘local’
[17:42:46.079]   - Field: ‘owner’
[17:42:46.079]   - Field: ‘envir’
[17:42:46.079]   - Field: ‘workers’
[17:42:46.079]   - Field: ‘packages’
[17:42:46.079]   - Field: ‘gc’
[17:42:46.079]   - Field: ‘job’
[17:42:46.079]   - Field: ‘conditions’
[17:42:46.079]   - Field: ‘expr’
[17:42:46.079]   - Field: ‘uuid’
[17:42:46.080]   - Field: ‘seed’
[17:42:46.080]   - Field: ‘version’
[17:42:46.080]   - Field: ‘result’
[17:42:46.080]   - Field: ‘asynchronous’
[17:42:46.080]   - Field: ‘calls’
[17:42:46.080]   - Field: ‘globals’
[17:42:46.080]   - Field: ‘stdout’
[17:42:46.080]   - Field: ‘earlySignal’
[17:42:46.080]   - Field: ‘lazy’
[17:42:46.080]   - Field: ‘state’
[17:42:46.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:46.081] - Launch lazy future ...
[17:42:46.081] Packages needed by the future expression (n = 0): <none>
[17:42:46.081] Packages needed by future strategies (n = 0): <none>
[17:42:46.081] {
[17:42:46.081]     {
[17:42:46.081]         {
[17:42:46.081]             ...future.startTime <- base::Sys.time()
[17:42:46.081]             {
[17:42:46.081]                 {
[17:42:46.081]                   {
[17:42:46.081]                     {
[17:42:46.081]                       base::local({
[17:42:46.081]                         has_future <- base::requireNamespace("future", 
[17:42:46.081]                           quietly = TRUE)
[17:42:46.081]                         if (has_future) {
[17:42:46.081]                           ns <- base::getNamespace("future")
[17:42:46.081]                           version <- ns[[".package"]][["version"]]
[17:42:46.081]                           if (is.null(version)) 
[17:42:46.081]                             version <- utils::packageVersion("future")
[17:42:46.081]                         }
[17:42:46.081]                         else {
[17:42:46.081]                           version <- NULL
[17:42:46.081]                         }
[17:42:46.081]                         if (!has_future || version < "1.8.0") {
[17:42:46.081]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.081]                             "", base::R.version$version.string), 
[17:42:46.081]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:46.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.081]                               "release", "version")], collapse = " "), 
[17:42:46.081]                             hostname = base::Sys.info()[["nodename"]])
[17:42:46.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.081]                             info)
[17:42:46.081]                           info <- base::paste(info, collapse = "; ")
[17:42:46.081]                           if (!has_future) {
[17:42:46.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.081]                               info)
[17:42:46.081]                           }
[17:42:46.081]                           else {
[17:42:46.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.081]                               info, version)
[17:42:46.081]                           }
[17:42:46.081]                           base::stop(msg)
[17:42:46.081]                         }
[17:42:46.081]                       })
[17:42:46.081]                     }
[17:42:46.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.081]                     base::options(mc.cores = 1L)
[17:42:46.081]                   }
[17:42:46.081]                   options(future.plan = NULL)
[17:42:46.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.081]                 }
[17:42:46.081]                 ...future.workdir <- getwd()
[17:42:46.081]             }
[17:42:46.081]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.081]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.081]         }
[17:42:46.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.081]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:46.081]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.081]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.081]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.081]             base::names(...future.oldOptions))
[17:42:46.081]     }
[17:42:46.081]     if (FALSE) {
[17:42:46.081]     }
[17:42:46.081]     else {
[17:42:46.081]         if (TRUE) {
[17:42:46.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.081]                 open = "w")
[17:42:46.081]         }
[17:42:46.081]         else {
[17:42:46.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.081]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.081]         }
[17:42:46.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.081]             base::sink(type = "output", split = FALSE)
[17:42:46.081]             base::close(...future.stdout)
[17:42:46.081]         }, add = TRUE)
[17:42:46.081]     }
[17:42:46.081]     ...future.frame <- base::sys.nframe()
[17:42:46.081]     ...future.conditions <- base::list()
[17:42:46.081]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.081]     if (FALSE) {
[17:42:46.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.081]     }
[17:42:46.081]     ...future.result <- base::tryCatch({
[17:42:46.081]         base::withCallingHandlers({
[17:42:46.081]             ...future.value <- base::withVisible(base::local({
[17:42:46.081]                 withCallingHandlers({
[17:42:46.081]                   {
[17:42:46.081]                     x <- 0
[17:42:46.081]                     x <- x + 1
[17:42:46.081]                     x
[17:42:46.081]                   }
[17:42:46.081]                 }, immediateCondition = function(cond) {
[17:42:46.081]                   save_rds <- function (object, pathname, ...) 
[17:42:46.081]                   {
[17:42:46.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:46.081]                     if (file_test("-f", pathname_tmp)) {
[17:42:46.081]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:46.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.081]                         fi_tmp[["mtime"]])
[17:42:46.081]                     }
[17:42:46.081]                     tryCatch({
[17:42:46.081]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:46.081]                     }, error = function(ex) {
[17:42:46.081]                       msg <- conditionMessage(ex)
[17:42:46.081]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:46.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.081]                         fi_tmp[["mtime"]], msg)
[17:42:46.081]                       ex$message <- msg
[17:42:46.081]                       stop(ex)
[17:42:46.081]                     })
[17:42:46.081]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:46.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:46.081]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:46.081]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.081]                       fi <- file.info(pathname)
[17:42:46.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:46.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:46.081]                         fi[["size"]], fi[["mtime"]])
[17:42:46.081]                       stop(msg)
[17:42:46.081]                     }
[17:42:46.081]                     invisible(pathname)
[17:42:46.081]                   }
[17:42:46.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:46.081]                     rootPath = tempdir()) 
[17:42:46.081]                   {
[17:42:46.081]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:46.081]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:46.081]                       tmpdir = path, fileext = ".rds")
[17:42:46.081]                     save_rds(obj, file)
[17:42:46.081]                   }
[17:42:46.081]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:46.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.081]                   {
[17:42:46.081]                     inherits <- base::inherits
[17:42:46.081]                     invokeRestart <- base::invokeRestart
[17:42:46.081]                     is.null <- base::is.null
[17:42:46.081]                     muffled <- FALSE
[17:42:46.081]                     if (inherits(cond, "message")) {
[17:42:46.081]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.081]                       if (muffled) 
[17:42:46.081]                         invokeRestart("muffleMessage")
[17:42:46.081]                     }
[17:42:46.081]                     else if (inherits(cond, "warning")) {
[17:42:46.081]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.081]                       if (muffled) 
[17:42:46.081]                         invokeRestart("muffleWarning")
[17:42:46.081]                     }
[17:42:46.081]                     else if (inherits(cond, "condition")) {
[17:42:46.081]                       if (!is.null(pattern)) {
[17:42:46.081]                         computeRestarts <- base::computeRestarts
[17:42:46.081]                         grepl <- base::grepl
[17:42:46.081]                         restarts <- computeRestarts(cond)
[17:42:46.081]                         for (restart in restarts) {
[17:42:46.081]                           name <- restart$name
[17:42:46.081]                           if (is.null(name)) 
[17:42:46.081]                             next
[17:42:46.081]                           if (!grepl(pattern, name)) 
[17:42:46.081]                             next
[17:42:46.081]                           invokeRestart(restart)
[17:42:46.081]                           muffled <- TRUE
[17:42:46.081]                           break
[17:42:46.081]                         }
[17:42:46.081]                       }
[17:42:46.081]                     }
[17:42:46.081]                     invisible(muffled)
[17:42:46.081]                   }
[17:42:46.081]                   muffleCondition(cond)
[17:42:46.081]                 })
[17:42:46.081]             }))
[17:42:46.081]             future::FutureResult(value = ...future.value$value, 
[17:42:46.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.081]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.081]                     ...future.globalenv.names))
[17:42:46.081]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.081]         }, condition = base::local({
[17:42:46.081]             c <- base::c
[17:42:46.081]             inherits <- base::inherits
[17:42:46.081]             invokeRestart <- base::invokeRestart
[17:42:46.081]             length <- base::length
[17:42:46.081]             list <- base::list
[17:42:46.081]             seq.int <- base::seq.int
[17:42:46.081]             signalCondition <- base::signalCondition
[17:42:46.081]             sys.calls <- base::sys.calls
[17:42:46.081]             `[[` <- base::`[[`
[17:42:46.081]             `+` <- base::`+`
[17:42:46.081]             `<<-` <- base::`<<-`
[17:42:46.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.081]                   3L)]
[17:42:46.081]             }
[17:42:46.081]             function(cond) {
[17:42:46.081]                 is_error <- inherits(cond, "error")
[17:42:46.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.081]                   NULL)
[17:42:46.081]                 if (is_error) {
[17:42:46.081]                   sessionInformation <- function() {
[17:42:46.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.081]                       search = base::search(), system = base::Sys.info())
[17:42:46.081]                   }
[17:42:46.081]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.081]                     cond$call), session = sessionInformation(), 
[17:42:46.081]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.081]                   signalCondition(cond)
[17:42:46.081]                 }
[17:42:46.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.081]                 "immediateCondition"))) {
[17:42:46.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.081]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.081]                   if (TRUE && !signal) {
[17:42:46.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.081]                     {
[17:42:46.081]                       inherits <- base::inherits
[17:42:46.081]                       invokeRestart <- base::invokeRestart
[17:42:46.081]                       is.null <- base::is.null
[17:42:46.081]                       muffled <- FALSE
[17:42:46.081]                       if (inherits(cond, "message")) {
[17:42:46.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.081]                         if (muffled) 
[17:42:46.081]                           invokeRestart("muffleMessage")
[17:42:46.081]                       }
[17:42:46.081]                       else if (inherits(cond, "warning")) {
[17:42:46.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.081]                         if (muffled) 
[17:42:46.081]                           invokeRestart("muffleWarning")
[17:42:46.081]                       }
[17:42:46.081]                       else if (inherits(cond, "condition")) {
[17:42:46.081]                         if (!is.null(pattern)) {
[17:42:46.081]                           computeRestarts <- base::computeRestarts
[17:42:46.081]                           grepl <- base::grepl
[17:42:46.081]                           restarts <- computeRestarts(cond)
[17:42:46.081]                           for (restart in restarts) {
[17:42:46.081]                             name <- restart$name
[17:42:46.081]                             if (is.null(name)) 
[17:42:46.081]                               next
[17:42:46.081]                             if (!grepl(pattern, name)) 
[17:42:46.081]                               next
[17:42:46.081]                             invokeRestart(restart)
[17:42:46.081]                             muffled <- TRUE
[17:42:46.081]                             break
[17:42:46.081]                           }
[17:42:46.081]                         }
[17:42:46.081]                       }
[17:42:46.081]                       invisible(muffled)
[17:42:46.081]                     }
[17:42:46.081]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.081]                   }
[17:42:46.081]                 }
[17:42:46.081]                 else {
[17:42:46.081]                   if (TRUE) {
[17:42:46.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.081]                     {
[17:42:46.081]                       inherits <- base::inherits
[17:42:46.081]                       invokeRestart <- base::invokeRestart
[17:42:46.081]                       is.null <- base::is.null
[17:42:46.081]                       muffled <- FALSE
[17:42:46.081]                       if (inherits(cond, "message")) {
[17:42:46.081]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.081]                         if (muffled) 
[17:42:46.081]                           invokeRestart("muffleMessage")
[17:42:46.081]                       }
[17:42:46.081]                       else if (inherits(cond, "warning")) {
[17:42:46.081]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.081]                         if (muffled) 
[17:42:46.081]                           invokeRestart("muffleWarning")
[17:42:46.081]                       }
[17:42:46.081]                       else if (inherits(cond, "condition")) {
[17:42:46.081]                         if (!is.null(pattern)) {
[17:42:46.081]                           computeRestarts <- base::computeRestarts
[17:42:46.081]                           grepl <- base::grepl
[17:42:46.081]                           restarts <- computeRestarts(cond)
[17:42:46.081]                           for (restart in restarts) {
[17:42:46.081]                             name <- restart$name
[17:42:46.081]                             if (is.null(name)) 
[17:42:46.081]                               next
[17:42:46.081]                             if (!grepl(pattern, name)) 
[17:42:46.081]                               next
[17:42:46.081]                             invokeRestart(restart)
[17:42:46.081]                             muffled <- TRUE
[17:42:46.081]                             break
[17:42:46.081]                           }
[17:42:46.081]                         }
[17:42:46.081]                       }
[17:42:46.081]                       invisible(muffled)
[17:42:46.081]                     }
[17:42:46.081]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.081]                   }
[17:42:46.081]                 }
[17:42:46.081]             }
[17:42:46.081]         }))
[17:42:46.081]     }, error = function(ex) {
[17:42:46.081]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.081]                 ...future.rng), started = ...future.startTime, 
[17:42:46.081]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.081]             version = "1.8"), class = "FutureResult")
[17:42:46.081]     }, finally = {
[17:42:46.081]         if (!identical(...future.workdir, getwd())) 
[17:42:46.081]             setwd(...future.workdir)
[17:42:46.081]         {
[17:42:46.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.081]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.081]             }
[17:42:46.081]             base::options(...future.oldOptions)
[17:42:46.081]             if (.Platform$OS.type == "windows") {
[17:42:46.081]                 old_names <- names(...future.oldEnvVars)
[17:42:46.081]                 envs <- base::Sys.getenv()
[17:42:46.081]                 names <- names(envs)
[17:42:46.081]                 common <- intersect(names, old_names)
[17:42:46.081]                 added <- setdiff(names, old_names)
[17:42:46.081]                 removed <- setdiff(old_names, names)
[17:42:46.081]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.081]                   envs[common]]
[17:42:46.081]                 NAMES <- toupper(changed)
[17:42:46.081]                 args <- list()
[17:42:46.081]                 for (kk in seq_along(NAMES)) {
[17:42:46.081]                   name <- changed[[kk]]
[17:42:46.081]                   NAME <- NAMES[[kk]]
[17:42:46.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.081]                     next
[17:42:46.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.081]                 }
[17:42:46.081]                 NAMES <- toupper(added)
[17:42:46.081]                 for (kk in seq_along(NAMES)) {
[17:42:46.081]                   name <- added[[kk]]
[17:42:46.081]                   NAME <- NAMES[[kk]]
[17:42:46.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.081]                     next
[17:42:46.081]                   args[[name]] <- ""
[17:42:46.081]                 }
[17:42:46.081]                 NAMES <- toupper(removed)
[17:42:46.081]                 for (kk in seq_along(NAMES)) {
[17:42:46.081]                   name <- removed[[kk]]
[17:42:46.081]                   NAME <- NAMES[[kk]]
[17:42:46.081]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.081]                     next
[17:42:46.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.081]                 }
[17:42:46.081]                 if (length(args) > 0) 
[17:42:46.081]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.081]             }
[17:42:46.081]             else {
[17:42:46.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.081]             }
[17:42:46.081]             {
[17:42:46.081]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.081]                   0L) {
[17:42:46.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.081]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.081]                   base::options(opts)
[17:42:46.081]                 }
[17:42:46.081]                 {
[17:42:46.081]                   {
[17:42:46.081]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.081]                     NULL
[17:42:46.081]                   }
[17:42:46.081]                   options(future.plan = NULL)
[17:42:46.081]                   if (is.na(NA_character_)) 
[17:42:46.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.081]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:46.081]                     envir = parent.frame()) 
[17:42:46.081]                   {
[17:42:46.081]                     default_workers <- missing(workers)
[17:42:46.081]                     if (is.function(workers)) 
[17:42:46.081]                       workers <- workers()
[17:42:46.081]                     workers <- structure(as.integer(workers), 
[17:42:46.081]                       class = class(workers))
[17:42:46.081]                     stop_if_not(is.finite(workers), workers >= 
[17:42:46.081]                       1L)
[17:42:46.081]                     if ((workers == 1L && !inherits(workers, 
[17:42:46.081]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:46.081]                       if (default_workers) 
[17:42:46.081]                         supportsMulticore(warn = TRUE)
[17:42:46.081]                       return(sequential(..., envir = envir))
[17:42:46.081]                     }
[17:42:46.081]                     oopts <- options(mc.cores = workers)
[17:42:46.081]                     on.exit(options(oopts))
[17:42:46.081]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:46.081]                       envir = envir)
[17:42:46.081]                     if (!future$lazy) 
[17:42:46.081]                       future <- run(future)
[17:42:46.081]                     invisible(future)
[17:42:46.081]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.081]                 }
[17:42:46.081]             }
[17:42:46.081]         }
[17:42:46.081]     })
[17:42:46.081]     if (TRUE) {
[17:42:46.081]         base::sink(type = "output", split = FALSE)
[17:42:46.081]         if (TRUE) {
[17:42:46.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.081]         }
[17:42:46.081]         else {
[17:42:46.081]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.081]         }
[17:42:46.081]         base::close(...future.stdout)
[17:42:46.081]         ...future.stdout <- NULL
[17:42:46.081]     }
[17:42:46.081]     ...future.result$conditions <- ...future.conditions
[17:42:46.081]     ...future.result$finished <- base::Sys.time()
[17:42:46.081]     ...future.result
[17:42:46.081] }
[17:42:46.084] requestCore(): workers = 2
[17:42:46.086] MulticoreFuture started
[17:42:46.087] - Launch lazy future ... done
[17:42:46.087] run() for ‘MulticoreFuture’ ... done
[17:42:46.088] plan(): Setting new future strategy stack:
[17:42:46.088] List of future strategies:
[17:42:46.088] 1. sequential:
[17:42:46.088]    - args: function (..., envir = parent.frame())
[17:42:46.088]    - tweaked: FALSE
[17:42:46.088]    - call: NULL
[17:42:46.089] plan(): nbrOfWorkers() = 1
[17:42:46.091] plan(): Setting new future strategy stack:
[17:42:46.091] List of future strategies:
[17:42:46.091] 1. multicore:
[17:42:46.091]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:46.091]    - tweaked: FALSE
[17:42:46.091]    - call: plan(strategy)
[17:42:46.096] plan(): nbrOfWorkers() = 2
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.097] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.098] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:46.100] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:42:46.100] Searching for globals ... DONE
[17:42:46.100] Resolving globals: TRUE
[17:42:46.100] Resolving any globals that are futures ...
[17:42:46.100] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:42:46.101] Resolving any globals that are futures ... DONE
[17:42:46.101] Resolving futures part of globals (recursively) ...
[17:42:46.101] resolve() on list ...
[17:42:46.102]  recursive: 99
[17:42:46.105]  length: 1
[17:42:46.105]  elements: ‘x’
[17:42:46.105]  length: 0 (resolved future 1)
[17:42:46.105] resolve() on list ... DONE
[17:42:46.105] - globals: [1] ‘x’
[17:42:46.106] Resolving futures part of globals (recursively) ... DONE
[17:42:46.106] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:46.107] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:42:46.107] - globals: [1] ‘x’
[17:42:46.107] 
[17:42:46.107] getGlobalsAndPackages() ... DONE
[17:42:46.107] run() for ‘Future’ ...
[17:42:46.108] - state: ‘created’
[17:42:46.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:46.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:46.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:46.113]   - Field: ‘label’
[17:42:46.113]   - Field: ‘local’
[17:42:46.113]   - Field: ‘owner’
[17:42:46.113]   - Field: ‘envir’
[17:42:46.113]   - Field: ‘workers’
[17:42:46.113]   - Field: ‘packages’
[17:42:46.114]   - Field: ‘gc’
[17:42:46.114]   - Field: ‘job’
[17:42:46.114]   - Field: ‘conditions’
[17:42:46.114]   - Field: ‘expr’
[17:42:46.114]   - Field: ‘uuid’
[17:42:46.114]   - Field: ‘seed’
[17:42:46.114]   - Field: ‘version’
[17:42:46.115]   - Field: ‘result’
[17:42:46.115]   - Field: ‘asynchronous’
[17:42:46.115]   - Field: ‘calls’
[17:42:46.115]   - Field: ‘globals’
[17:42:46.115]   - Field: ‘stdout’
[17:42:46.115]   - Field: ‘earlySignal’
[17:42:46.115]   - Field: ‘lazy’
[17:42:46.115]   - Field: ‘state’
[17:42:46.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:46.116] - Launch lazy future ...
[17:42:46.116] Packages needed by the future expression (n = 0): <none>
[17:42:46.116] Packages needed by future strategies (n = 0): <none>
[17:42:46.117] {
[17:42:46.117]     {
[17:42:46.117]         {
[17:42:46.117]             ...future.startTime <- base::Sys.time()
[17:42:46.117]             {
[17:42:46.117]                 {
[17:42:46.117]                   {
[17:42:46.117]                     {
[17:42:46.117]                       base::local({
[17:42:46.117]                         has_future <- base::requireNamespace("future", 
[17:42:46.117]                           quietly = TRUE)
[17:42:46.117]                         if (has_future) {
[17:42:46.117]                           ns <- base::getNamespace("future")
[17:42:46.117]                           version <- ns[[".package"]][["version"]]
[17:42:46.117]                           if (is.null(version)) 
[17:42:46.117]                             version <- utils::packageVersion("future")
[17:42:46.117]                         }
[17:42:46.117]                         else {
[17:42:46.117]                           version <- NULL
[17:42:46.117]                         }
[17:42:46.117]                         if (!has_future || version < "1.8.0") {
[17:42:46.117]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.117]                             "", base::R.version$version.string), 
[17:42:46.117]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:46.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.117]                               "release", "version")], collapse = " "), 
[17:42:46.117]                             hostname = base::Sys.info()[["nodename"]])
[17:42:46.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.117]                             info)
[17:42:46.117]                           info <- base::paste(info, collapse = "; ")
[17:42:46.117]                           if (!has_future) {
[17:42:46.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.117]                               info)
[17:42:46.117]                           }
[17:42:46.117]                           else {
[17:42:46.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.117]                               info, version)
[17:42:46.117]                           }
[17:42:46.117]                           base::stop(msg)
[17:42:46.117]                         }
[17:42:46.117]                       })
[17:42:46.117]                     }
[17:42:46.117]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.117]                     base::options(mc.cores = 1L)
[17:42:46.117]                   }
[17:42:46.117]                   options(future.plan = NULL)
[17:42:46.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.117]                 }
[17:42:46.117]                 ...future.workdir <- getwd()
[17:42:46.117]             }
[17:42:46.117]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.117]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.117]         }
[17:42:46.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.117]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:46.117]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.117]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.117]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.117]             base::names(...future.oldOptions))
[17:42:46.117]     }
[17:42:46.117]     if (FALSE) {
[17:42:46.117]     }
[17:42:46.117]     else {
[17:42:46.117]         if (TRUE) {
[17:42:46.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.117]                 open = "w")
[17:42:46.117]         }
[17:42:46.117]         else {
[17:42:46.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.117]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.117]         }
[17:42:46.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.117]             base::sink(type = "output", split = FALSE)
[17:42:46.117]             base::close(...future.stdout)
[17:42:46.117]         }, add = TRUE)
[17:42:46.117]     }
[17:42:46.117]     ...future.frame <- base::sys.nframe()
[17:42:46.117]     ...future.conditions <- base::list()
[17:42:46.117]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.117]     if (FALSE) {
[17:42:46.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.117]     }
[17:42:46.117]     ...future.result <- base::tryCatch({
[17:42:46.117]         base::withCallingHandlers({
[17:42:46.117]             ...future.value <- base::withVisible(base::local({
[17:42:46.117]                 withCallingHandlers({
[17:42:46.117]                   {
[17:42:46.117]                     x <- x + 1
[17:42:46.117]                     x
[17:42:46.117]                   }
[17:42:46.117]                 }, immediateCondition = function(cond) {
[17:42:46.117]                   save_rds <- function (object, pathname, ...) 
[17:42:46.117]                   {
[17:42:46.117]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:46.117]                     if (file_test("-f", pathname_tmp)) {
[17:42:46.117]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.117]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:46.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.117]                         fi_tmp[["mtime"]])
[17:42:46.117]                     }
[17:42:46.117]                     tryCatch({
[17:42:46.117]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:46.117]                     }, error = function(ex) {
[17:42:46.117]                       msg <- conditionMessage(ex)
[17:42:46.117]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.117]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:46.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.117]                         fi_tmp[["mtime"]], msg)
[17:42:46.117]                       ex$message <- msg
[17:42:46.117]                       stop(ex)
[17:42:46.117]                     })
[17:42:46.117]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:46.117]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:46.117]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:46.117]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.117]                       fi <- file.info(pathname)
[17:42:46.117]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:46.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.117]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:46.117]                         fi[["size"]], fi[["mtime"]])
[17:42:46.117]                       stop(msg)
[17:42:46.117]                     }
[17:42:46.117]                     invisible(pathname)
[17:42:46.117]                   }
[17:42:46.117]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:46.117]                     rootPath = tempdir()) 
[17:42:46.117]                   {
[17:42:46.117]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:46.117]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:46.117]                       tmpdir = path, fileext = ".rds")
[17:42:46.117]                     save_rds(obj, file)
[17:42:46.117]                   }
[17:42:46.117]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:46.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.117]                   {
[17:42:46.117]                     inherits <- base::inherits
[17:42:46.117]                     invokeRestart <- base::invokeRestart
[17:42:46.117]                     is.null <- base::is.null
[17:42:46.117]                     muffled <- FALSE
[17:42:46.117]                     if (inherits(cond, "message")) {
[17:42:46.117]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.117]                       if (muffled) 
[17:42:46.117]                         invokeRestart("muffleMessage")
[17:42:46.117]                     }
[17:42:46.117]                     else if (inherits(cond, "warning")) {
[17:42:46.117]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.117]                       if (muffled) 
[17:42:46.117]                         invokeRestart("muffleWarning")
[17:42:46.117]                     }
[17:42:46.117]                     else if (inherits(cond, "condition")) {
[17:42:46.117]                       if (!is.null(pattern)) {
[17:42:46.117]                         computeRestarts <- base::computeRestarts
[17:42:46.117]                         grepl <- base::grepl
[17:42:46.117]                         restarts <- computeRestarts(cond)
[17:42:46.117]                         for (restart in restarts) {
[17:42:46.117]                           name <- restart$name
[17:42:46.117]                           if (is.null(name)) 
[17:42:46.117]                             next
[17:42:46.117]                           if (!grepl(pattern, name)) 
[17:42:46.117]                             next
[17:42:46.117]                           invokeRestart(restart)
[17:42:46.117]                           muffled <- TRUE
[17:42:46.117]                           break
[17:42:46.117]                         }
[17:42:46.117]                       }
[17:42:46.117]                     }
[17:42:46.117]                     invisible(muffled)
[17:42:46.117]                   }
[17:42:46.117]                   muffleCondition(cond)
[17:42:46.117]                 })
[17:42:46.117]             }))
[17:42:46.117]             future::FutureResult(value = ...future.value$value, 
[17:42:46.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.117]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.117]                     ...future.globalenv.names))
[17:42:46.117]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.117]         }, condition = base::local({
[17:42:46.117]             c <- base::c
[17:42:46.117]             inherits <- base::inherits
[17:42:46.117]             invokeRestart <- base::invokeRestart
[17:42:46.117]             length <- base::length
[17:42:46.117]             list <- base::list
[17:42:46.117]             seq.int <- base::seq.int
[17:42:46.117]             signalCondition <- base::signalCondition
[17:42:46.117]             sys.calls <- base::sys.calls
[17:42:46.117]             `[[` <- base::`[[`
[17:42:46.117]             `+` <- base::`+`
[17:42:46.117]             `<<-` <- base::`<<-`
[17:42:46.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.117]                   3L)]
[17:42:46.117]             }
[17:42:46.117]             function(cond) {
[17:42:46.117]                 is_error <- inherits(cond, "error")
[17:42:46.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.117]                   NULL)
[17:42:46.117]                 if (is_error) {
[17:42:46.117]                   sessionInformation <- function() {
[17:42:46.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.117]                       search = base::search(), system = base::Sys.info())
[17:42:46.117]                   }
[17:42:46.117]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.117]                     cond$call), session = sessionInformation(), 
[17:42:46.117]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.117]                   signalCondition(cond)
[17:42:46.117]                 }
[17:42:46.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.117]                 "immediateCondition"))) {
[17:42:46.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.117]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.117]                   if (TRUE && !signal) {
[17:42:46.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.117]                     {
[17:42:46.117]                       inherits <- base::inherits
[17:42:46.117]                       invokeRestart <- base::invokeRestart
[17:42:46.117]                       is.null <- base::is.null
[17:42:46.117]                       muffled <- FALSE
[17:42:46.117]                       if (inherits(cond, "message")) {
[17:42:46.117]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.117]                         if (muffled) 
[17:42:46.117]                           invokeRestart("muffleMessage")
[17:42:46.117]                       }
[17:42:46.117]                       else if (inherits(cond, "warning")) {
[17:42:46.117]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.117]                         if (muffled) 
[17:42:46.117]                           invokeRestart("muffleWarning")
[17:42:46.117]                       }
[17:42:46.117]                       else if (inherits(cond, "condition")) {
[17:42:46.117]                         if (!is.null(pattern)) {
[17:42:46.117]                           computeRestarts <- base::computeRestarts
[17:42:46.117]                           grepl <- base::grepl
[17:42:46.117]                           restarts <- computeRestarts(cond)
[17:42:46.117]                           for (restart in restarts) {
[17:42:46.117]                             name <- restart$name
[17:42:46.117]                             if (is.null(name)) 
[17:42:46.117]                               next
[17:42:46.117]                             if (!grepl(pattern, name)) 
[17:42:46.117]                               next
[17:42:46.117]                             invokeRestart(restart)
[17:42:46.117]                             muffled <- TRUE
[17:42:46.117]                             break
[17:42:46.117]                           }
[17:42:46.117]                         }
[17:42:46.117]                       }
[17:42:46.117]                       invisible(muffled)
[17:42:46.117]                     }
[17:42:46.117]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.117]                   }
[17:42:46.117]                 }
[17:42:46.117]                 else {
[17:42:46.117]                   if (TRUE) {
[17:42:46.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.117]                     {
[17:42:46.117]                       inherits <- base::inherits
[17:42:46.117]                       invokeRestart <- base::invokeRestart
[17:42:46.117]                       is.null <- base::is.null
[17:42:46.117]                       muffled <- FALSE
[17:42:46.117]                       if (inherits(cond, "message")) {
[17:42:46.117]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.117]                         if (muffled) 
[17:42:46.117]                           invokeRestart("muffleMessage")
[17:42:46.117]                       }
[17:42:46.117]                       else if (inherits(cond, "warning")) {
[17:42:46.117]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.117]                         if (muffled) 
[17:42:46.117]                           invokeRestart("muffleWarning")
[17:42:46.117]                       }
[17:42:46.117]                       else if (inherits(cond, "condition")) {
[17:42:46.117]                         if (!is.null(pattern)) {
[17:42:46.117]                           computeRestarts <- base::computeRestarts
[17:42:46.117]                           grepl <- base::grepl
[17:42:46.117]                           restarts <- computeRestarts(cond)
[17:42:46.117]                           for (restart in restarts) {
[17:42:46.117]                             name <- restart$name
[17:42:46.117]                             if (is.null(name)) 
[17:42:46.117]                               next
[17:42:46.117]                             if (!grepl(pattern, name)) 
[17:42:46.117]                               next
[17:42:46.117]                             invokeRestart(restart)
[17:42:46.117]                             muffled <- TRUE
[17:42:46.117]                             break
[17:42:46.117]                           }
[17:42:46.117]                         }
[17:42:46.117]                       }
[17:42:46.117]                       invisible(muffled)
[17:42:46.117]                     }
[17:42:46.117]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.117]                   }
[17:42:46.117]                 }
[17:42:46.117]             }
[17:42:46.117]         }))
[17:42:46.117]     }, error = function(ex) {
[17:42:46.117]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.117]                 ...future.rng), started = ...future.startTime, 
[17:42:46.117]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.117]             version = "1.8"), class = "FutureResult")
[17:42:46.117]     }, finally = {
[17:42:46.117]         if (!identical(...future.workdir, getwd())) 
[17:42:46.117]             setwd(...future.workdir)
[17:42:46.117]         {
[17:42:46.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.117]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.117]             }
[17:42:46.117]             base::options(...future.oldOptions)
[17:42:46.117]             if (.Platform$OS.type == "windows") {
[17:42:46.117]                 old_names <- names(...future.oldEnvVars)
[17:42:46.117]                 envs <- base::Sys.getenv()
[17:42:46.117]                 names <- names(envs)
[17:42:46.117]                 common <- intersect(names, old_names)
[17:42:46.117]                 added <- setdiff(names, old_names)
[17:42:46.117]                 removed <- setdiff(old_names, names)
[17:42:46.117]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.117]                   envs[common]]
[17:42:46.117]                 NAMES <- toupper(changed)
[17:42:46.117]                 args <- list()
[17:42:46.117]                 for (kk in seq_along(NAMES)) {
[17:42:46.117]                   name <- changed[[kk]]
[17:42:46.117]                   NAME <- NAMES[[kk]]
[17:42:46.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.117]                     next
[17:42:46.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.117]                 }
[17:42:46.117]                 NAMES <- toupper(added)
[17:42:46.117]                 for (kk in seq_along(NAMES)) {
[17:42:46.117]                   name <- added[[kk]]
[17:42:46.117]                   NAME <- NAMES[[kk]]
[17:42:46.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.117]                     next
[17:42:46.117]                   args[[name]] <- ""
[17:42:46.117]                 }
[17:42:46.117]                 NAMES <- toupper(removed)
[17:42:46.117]                 for (kk in seq_along(NAMES)) {
[17:42:46.117]                   name <- removed[[kk]]
[17:42:46.117]                   NAME <- NAMES[[kk]]
[17:42:46.117]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.117]                     next
[17:42:46.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.117]                 }
[17:42:46.117]                 if (length(args) > 0) 
[17:42:46.117]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.117]             }
[17:42:46.117]             else {
[17:42:46.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.117]             }
[17:42:46.117]             {
[17:42:46.117]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.117]                   0L) {
[17:42:46.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.117]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.117]                   base::options(opts)
[17:42:46.117]                 }
[17:42:46.117]                 {
[17:42:46.117]                   {
[17:42:46.117]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.117]                     NULL
[17:42:46.117]                   }
[17:42:46.117]                   options(future.plan = NULL)
[17:42:46.117]                   if (is.na(NA_character_)) 
[17:42:46.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.117]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:46.117]                     envir = parent.frame()) 
[17:42:46.117]                   {
[17:42:46.117]                     default_workers <- missing(workers)
[17:42:46.117]                     if (is.function(workers)) 
[17:42:46.117]                       workers <- workers()
[17:42:46.117]                     workers <- structure(as.integer(workers), 
[17:42:46.117]                       class = class(workers))
[17:42:46.117]                     stop_if_not(is.finite(workers), workers >= 
[17:42:46.117]                       1L)
[17:42:46.117]                     if ((workers == 1L && !inherits(workers, 
[17:42:46.117]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:46.117]                       if (default_workers) 
[17:42:46.117]                         supportsMulticore(warn = TRUE)
[17:42:46.117]                       return(sequential(..., envir = envir))
[17:42:46.117]                     }
[17:42:46.117]                     oopts <- options(mc.cores = workers)
[17:42:46.117]                     on.exit(options(oopts))
[17:42:46.117]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:46.117]                       envir = envir)
[17:42:46.117]                     if (!future$lazy) 
[17:42:46.117]                       future <- run(future)
[17:42:46.117]                     invisible(future)
[17:42:46.117]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.117]                 }
[17:42:46.117]             }
[17:42:46.117]         }
[17:42:46.117]     })
[17:42:46.117]     if (TRUE) {
[17:42:46.117]         base::sink(type = "output", split = FALSE)
[17:42:46.117]         if (TRUE) {
[17:42:46.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.117]         }
[17:42:46.117]         else {
[17:42:46.117]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.117]         }
[17:42:46.117]         base::close(...future.stdout)
[17:42:46.117]         ...future.stdout <- NULL
[17:42:46.117]     }
[17:42:46.117]     ...future.result$conditions <- ...future.conditions
[17:42:46.117]     ...future.result$finished <- base::Sys.time()
[17:42:46.117]     ...future.result
[17:42:46.117] }
[17:42:46.119] assign_globals() ...
[17:42:46.120] List of 1
[17:42:46.120]  $ x: num 1
[17:42:46.120]  - attr(*, "where")=List of 1
[17:42:46.120]   ..$ x:<environment: R_EmptyEnv> 
[17:42:46.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:46.120]  - attr(*, "resolved")= logi TRUE
[17:42:46.120]  - attr(*, "total_size")= num 56
[17:42:46.120]  - attr(*, "already-done")= logi TRUE
[17:42:46.123] - copied ‘x’ to environment
[17:42:46.123] assign_globals() ... done
[17:42:46.123] requestCore(): workers = 2
[17:42:46.125] MulticoreFuture started
[17:42:46.125] - Launch lazy future ... done
[17:42:46.126] run() for ‘MulticoreFuture’ ... done
[17:42:46.126] plan(): Setting new future strategy stack:
[17:42:46.126] List of future strategies:
[17:42:46.126] 1. sequential:
[17:42:46.126]    - args: function (..., envir = parent.frame())
[17:42:46.126]    - tweaked: FALSE
[17:42:46.126]    - call: NULL
[17:42:46.127] plan(): nbrOfWorkers() = 1
[17:42:46.130] plan(): Setting new future strategy stack:
[17:42:46.130] List of future strategies:
[17:42:46.130] 1. multicore:
[17:42:46.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:46.130]    - tweaked: FALSE
[17:42:46.130]    - call: plan(strategy)
[17:42:46.135] plan(): nbrOfWorkers() = 2
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.136] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.137] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:46.139] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:42:46.139] Searching for globals ... DONE
[17:42:46.140] Resolving globals: TRUE
[17:42:46.140] Resolving any globals that are futures ...
[17:42:46.140] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:42:46.140] Resolving any globals that are futures ... DONE
[17:42:46.140] Resolving futures part of globals (recursively) ...
[17:42:46.141] resolve() on list ...
[17:42:46.141]  recursive: 99
[17:42:46.141]  length: 1
[17:42:46.141]  elements: ‘x’
[17:42:46.141]  length: 0 (resolved future 1)
[17:42:46.141] resolve() on list ... DONE
[17:42:46.141] - globals: [1] ‘x’
[17:42:46.142] Resolving futures part of globals (recursively) ... DONE
[17:42:46.142] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:42:46.142] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:42:46.142] - globals: [1] ‘x’
[17:42:46.143] 
[17:42:46.143] getGlobalsAndPackages() ... DONE
[17:42:46.143] run() for ‘Future’ ...
[17:42:46.143] - state: ‘created’
[17:42:46.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:46.148] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:46.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:46.148]   - Field: ‘label’
[17:42:46.148]   - Field: ‘local’
[17:42:46.148]   - Field: ‘owner’
[17:42:46.148]   - Field: ‘envir’
[17:42:46.151]   - Field: ‘workers’
[17:42:46.151]   - Field: ‘packages’
[17:42:46.151]   - Field: ‘gc’
[17:42:46.152]   - Field: ‘job’
[17:42:46.152]   - Field: ‘conditions’
[17:42:46.152]   - Field: ‘expr’
[17:42:46.152]   - Field: ‘uuid’
[17:42:46.152]   - Field: ‘seed’
[17:42:46.152]   - Field: ‘version’
[17:42:46.153]   - Field: ‘result’
[17:42:46.153]   - Field: ‘asynchronous’
[17:42:46.153]   - Field: ‘calls’
[17:42:46.153]   - Field: ‘globals’
[17:42:46.153]   - Field: ‘stdout’
[17:42:46.153]   - Field: ‘earlySignal’
[17:42:46.153]   - Field: ‘lazy’
[17:42:46.154]   - Field: ‘state’
[17:42:46.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:46.154] - Launch lazy future ...
[17:42:46.154] Packages needed by the future expression (n = 0): <none>
[17:42:46.154] Packages needed by future strategies (n = 0): <none>
[17:42:46.155] {
[17:42:46.155]     {
[17:42:46.155]         {
[17:42:46.155]             ...future.startTime <- base::Sys.time()
[17:42:46.155]             {
[17:42:46.155]                 {
[17:42:46.155]                   {
[17:42:46.155]                     {
[17:42:46.155]                       base::local({
[17:42:46.155]                         has_future <- base::requireNamespace("future", 
[17:42:46.155]                           quietly = TRUE)
[17:42:46.155]                         if (has_future) {
[17:42:46.155]                           ns <- base::getNamespace("future")
[17:42:46.155]                           version <- ns[[".package"]][["version"]]
[17:42:46.155]                           if (is.null(version)) 
[17:42:46.155]                             version <- utils::packageVersion("future")
[17:42:46.155]                         }
[17:42:46.155]                         else {
[17:42:46.155]                           version <- NULL
[17:42:46.155]                         }
[17:42:46.155]                         if (!has_future || version < "1.8.0") {
[17:42:46.155]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.155]                             "", base::R.version$version.string), 
[17:42:46.155]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:46.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.155]                               "release", "version")], collapse = " "), 
[17:42:46.155]                             hostname = base::Sys.info()[["nodename"]])
[17:42:46.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.155]                             info)
[17:42:46.155]                           info <- base::paste(info, collapse = "; ")
[17:42:46.155]                           if (!has_future) {
[17:42:46.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.155]                               info)
[17:42:46.155]                           }
[17:42:46.155]                           else {
[17:42:46.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.155]                               info, version)
[17:42:46.155]                           }
[17:42:46.155]                           base::stop(msg)
[17:42:46.155]                         }
[17:42:46.155]                       })
[17:42:46.155]                     }
[17:42:46.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.155]                     base::options(mc.cores = 1L)
[17:42:46.155]                   }
[17:42:46.155]                   options(future.plan = NULL)
[17:42:46.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.155]                 }
[17:42:46.155]                 ...future.workdir <- getwd()
[17:42:46.155]             }
[17:42:46.155]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.155]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.155]         }
[17:42:46.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.155]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:46.155]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.155]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.155]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.155]             base::names(...future.oldOptions))
[17:42:46.155]     }
[17:42:46.155]     if (FALSE) {
[17:42:46.155]     }
[17:42:46.155]     else {
[17:42:46.155]         if (TRUE) {
[17:42:46.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.155]                 open = "w")
[17:42:46.155]         }
[17:42:46.155]         else {
[17:42:46.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.155]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.155]         }
[17:42:46.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.155]             base::sink(type = "output", split = FALSE)
[17:42:46.155]             base::close(...future.stdout)
[17:42:46.155]         }, add = TRUE)
[17:42:46.155]     }
[17:42:46.155]     ...future.frame <- base::sys.nframe()
[17:42:46.155]     ...future.conditions <- base::list()
[17:42:46.155]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.155]     if (FALSE) {
[17:42:46.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.155]     }
[17:42:46.155]     ...future.result <- base::tryCatch({
[17:42:46.155]         base::withCallingHandlers({
[17:42:46.155]             ...future.value <- base::withVisible(base::local({
[17:42:46.155]                 withCallingHandlers({
[17:42:46.155]                   {
[17:42:46.155]                     x <- x()
[17:42:46.155]                     x
[17:42:46.155]                   }
[17:42:46.155]                 }, immediateCondition = function(cond) {
[17:42:46.155]                   save_rds <- function (object, pathname, ...) 
[17:42:46.155]                   {
[17:42:46.155]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:46.155]                     if (file_test("-f", pathname_tmp)) {
[17:42:46.155]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.155]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:46.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.155]                         fi_tmp[["mtime"]])
[17:42:46.155]                     }
[17:42:46.155]                     tryCatch({
[17:42:46.155]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:46.155]                     }, error = function(ex) {
[17:42:46.155]                       msg <- conditionMessage(ex)
[17:42:46.155]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.155]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:46.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.155]                         fi_tmp[["mtime"]], msg)
[17:42:46.155]                       ex$message <- msg
[17:42:46.155]                       stop(ex)
[17:42:46.155]                     })
[17:42:46.155]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:46.155]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:46.155]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:46.155]                       fi_tmp <- file.info(pathname_tmp)
[17:42:46.155]                       fi <- file.info(pathname)
[17:42:46.155]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:46.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:46.155]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:46.155]                         fi[["size"]], fi[["mtime"]])
[17:42:46.155]                       stop(msg)
[17:42:46.155]                     }
[17:42:46.155]                     invisible(pathname)
[17:42:46.155]                   }
[17:42:46.155]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:46.155]                     rootPath = tempdir()) 
[17:42:46.155]                   {
[17:42:46.155]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:46.155]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:46.155]                       tmpdir = path, fileext = ".rds")
[17:42:46.155]                     save_rds(obj, file)
[17:42:46.155]                   }
[17:42:46.155]                   saveImmediateCondition(cond, path = "/tmp/RtmpsTBDOD/.future/immediateConditions")
[17:42:46.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.155]                   {
[17:42:46.155]                     inherits <- base::inherits
[17:42:46.155]                     invokeRestart <- base::invokeRestart
[17:42:46.155]                     is.null <- base::is.null
[17:42:46.155]                     muffled <- FALSE
[17:42:46.155]                     if (inherits(cond, "message")) {
[17:42:46.155]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.155]                       if (muffled) 
[17:42:46.155]                         invokeRestart("muffleMessage")
[17:42:46.155]                     }
[17:42:46.155]                     else if (inherits(cond, "warning")) {
[17:42:46.155]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.155]                       if (muffled) 
[17:42:46.155]                         invokeRestart("muffleWarning")
[17:42:46.155]                     }
[17:42:46.155]                     else if (inherits(cond, "condition")) {
[17:42:46.155]                       if (!is.null(pattern)) {
[17:42:46.155]                         computeRestarts <- base::computeRestarts
[17:42:46.155]                         grepl <- base::grepl
[17:42:46.155]                         restarts <- computeRestarts(cond)
[17:42:46.155]                         for (restart in restarts) {
[17:42:46.155]                           name <- restart$name
[17:42:46.155]                           if (is.null(name)) 
[17:42:46.155]                             next
[17:42:46.155]                           if (!grepl(pattern, name)) 
[17:42:46.155]                             next
[17:42:46.155]                           invokeRestart(restart)
[17:42:46.155]                           muffled <- TRUE
[17:42:46.155]                           break
[17:42:46.155]                         }
[17:42:46.155]                       }
[17:42:46.155]                     }
[17:42:46.155]                     invisible(muffled)
[17:42:46.155]                   }
[17:42:46.155]                   muffleCondition(cond)
[17:42:46.155]                 })
[17:42:46.155]             }))
[17:42:46.155]             future::FutureResult(value = ...future.value$value, 
[17:42:46.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.155]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.155]                     ...future.globalenv.names))
[17:42:46.155]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.155]         }, condition = base::local({
[17:42:46.155]             c <- base::c
[17:42:46.155]             inherits <- base::inherits
[17:42:46.155]             invokeRestart <- base::invokeRestart
[17:42:46.155]             length <- base::length
[17:42:46.155]             list <- base::list
[17:42:46.155]             seq.int <- base::seq.int
[17:42:46.155]             signalCondition <- base::signalCondition
[17:42:46.155]             sys.calls <- base::sys.calls
[17:42:46.155]             `[[` <- base::`[[`
[17:42:46.155]             `+` <- base::`+`
[17:42:46.155]             `<<-` <- base::`<<-`
[17:42:46.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.155]                   3L)]
[17:42:46.155]             }
[17:42:46.155]             function(cond) {
[17:42:46.155]                 is_error <- inherits(cond, "error")
[17:42:46.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.155]                   NULL)
[17:42:46.155]                 if (is_error) {
[17:42:46.155]                   sessionInformation <- function() {
[17:42:46.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.155]                       search = base::search(), system = base::Sys.info())
[17:42:46.155]                   }
[17:42:46.155]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.155]                     cond$call), session = sessionInformation(), 
[17:42:46.155]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.155]                   signalCondition(cond)
[17:42:46.155]                 }
[17:42:46.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.155]                 "immediateCondition"))) {
[17:42:46.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.155]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.155]                   if (TRUE && !signal) {
[17:42:46.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.155]                     {
[17:42:46.155]                       inherits <- base::inherits
[17:42:46.155]                       invokeRestart <- base::invokeRestart
[17:42:46.155]                       is.null <- base::is.null
[17:42:46.155]                       muffled <- FALSE
[17:42:46.155]                       if (inherits(cond, "message")) {
[17:42:46.155]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.155]                         if (muffled) 
[17:42:46.155]                           invokeRestart("muffleMessage")
[17:42:46.155]                       }
[17:42:46.155]                       else if (inherits(cond, "warning")) {
[17:42:46.155]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.155]                         if (muffled) 
[17:42:46.155]                           invokeRestart("muffleWarning")
[17:42:46.155]                       }
[17:42:46.155]                       else if (inherits(cond, "condition")) {
[17:42:46.155]                         if (!is.null(pattern)) {
[17:42:46.155]                           computeRestarts <- base::computeRestarts
[17:42:46.155]                           grepl <- base::grepl
[17:42:46.155]                           restarts <- computeRestarts(cond)
[17:42:46.155]                           for (restart in restarts) {
[17:42:46.155]                             name <- restart$name
[17:42:46.155]                             if (is.null(name)) 
[17:42:46.155]                               next
[17:42:46.155]                             if (!grepl(pattern, name)) 
[17:42:46.155]                               next
[17:42:46.155]                             invokeRestart(restart)
[17:42:46.155]                             muffled <- TRUE
[17:42:46.155]                             break
[17:42:46.155]                           }
[17:42:46.155]                         }
[17:42:46.155]                       }
[17:42:46.155]                       invisible(muffled)
[17:42:46.155]                     }
[17:42:46.155]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.155]                   }
[17:42:46.155]                 }
[17:42:46.155]                 else {
[17:42:46.155]                   if (TRUE) {
[17:42:46.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.155]                     {
[17:42:46.155]                       inherits <- base::inherits
[17:42:46.155]                       invokeRestart <- base::invokeRestart
[17:42:46.155]                       is.null <- base::is.null
[17:42:46.155]                       muffled <- FALSE
[17:42:46.155]                       if (inherits(cond, "message")) {
[17:42:46.155]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.155]                         if (muffled) 
[17:42:46.155]                           invokeRestart("muffleMessage")
[17:42:46.155]                       }
[17:42:46.155]                       else if (inherits(cond, "warning")) {
[17:42:46.155]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.155]                         if (muffled) 
[17:42:46.155]                           invokeRestart("muffleWarning")
[17:42:46.155]                       }
[17:42:46.155]                       else if (inherits(cond, "condition")) {
[17:42:46.155]                         if (!is.null(pattern)) {
[17:42:46.155]                           computeRestarts <- base::computeRestarts
[17:42:46.155]                           grepl <- base::grepl
[17:42:46.155]                           restarts <- computeRestarts(cond)
[17:42:46.155]                           for (restart in restarts) {
[17:42:46.155]                             name <- restart$name
[17:42:46.155]                             if (is.null(name)) 
[17:42:46.155]                               next
[17:42:46.155]                             if (!grepl(pattern, name)) 
[17:42:46.155]                               next
[17:42:46.155]                             invokeRestart(restart)
[17:42:46.155]                             muffled <- TRUE
[17:42:46.155]                             break
[17:42:46.155]                           }
[17:42:46.155]                         }
[17:42:46.155]                       }
[17:42:46.155]                       invisible(muffled)
[17:42:46.155]                     }
[17:42:46.155]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.155]                   }
[17:42:46.155]                 }
[17:42:46.155]             }
[17:42:46.155]         }))
[17:42:46.155]     }, error = function(ex) {
[17:42:46.155]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.155]                 ...future.rng), started = ...future.startTime, 
[17:42:46.155]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.155]             version = "1.8"), class = "FutureResult")
[17:42:46.155]     }, finally = {
[17:42:46.155]         if (!identical(...future.workdir, getwd())) 
[17:42:46.155]             setwd(...future.workdir)
[17:42:46.155]         {
[17:42:46.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.155]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.155]             }
[17:42:46.155]             base::options(...future.oldOptions)
[17:42:46.155]             if (.Platform$OS.type == "windows") {
[17:42:46.155]                 old_names <- names(...future.oldEnvVars)
[17:42:46.155]                 envs <- base::Sys.getenv()
[17:42:46.155]                 names <- names(envs)
[17:42:46.155]                 common <- intersect(names, old_names)
[17:42:46.155]                 added <- setdiff(names, old_names)
[17:42:46.155]                 removed <- setdiff(old_names, names)
[17:42:46.155]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.155]                   envs[common]]
[17:42:46.155]                 NAMES <- toupper(changed)
[17:42:46.155]                 args <- list()
[17:42:46.155]                 for (kk in seq_along(NAMES)) {
[17:42:46.155]                   name <- changed[[kk]]
[17:42:46.155]                   NAME <- NAMES[[kk]]
[17:42:46.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.155]                     next
[17:42:46.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.155]                 }
[17:42:46.155]                 NAMES <- toupper(added)
[17:42:46.155]                 for (kk in seq_along(NAMES)) {
[17:42:46.155]                   name <- added[[kk]]
[17:42:46.155]                   NAME <- NAMES[[kk]]
[17:42:46.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.155]                     next
[17:42:46.155]                   args[[name]] <- ""
[17:42:46.155]                 }
[17:42:46.155]                 NAMES <- toupper(removed)
[17:42:46.155]                 for (kk in seq_along(NAMES)) {
[17:42:46.155]                   name <- removed[[kk]]
[17:42:46.155]                   NAME <- NAMES[[kk]]
[17:42:46.155]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.155]                     next
[17:42:46.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.155]                 }
[17:42:46.155]                 if (length(args) > 0) 
[17:42:46.155]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.155]             }
[17:42:46.155]             else {
[17:42:46.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.155]             }
[17:42:46.155]             {
[17:42:46.155]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.155]                   0L) {
[17:42:46.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.155]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.155]                   base::options(opts)
[17:42:46.155]                 }
[17:42:46.155]                 {
[17:42:46.155]                   {
[17:42:46.155]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.155]                     NULL
[17:42:46.155]                   }
[17:42:46.155]                   options(future.plan = NULL)
[17:42:46.155]                   if (is.na(NA_character_)) 
[17:42:46.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.155]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:46.155]                     envir = parent.frame()) 
[17:42:46.155]                   {
[17:42:46.155]                     default_workers <- missing(workers)
[17:42:46.155]                     if (is.function(workers)) 
[17:42:46.155]                       workers <- workers()
[17:42:46.155]                     workers <- structure(as.integer(workers), 
[17:42:46.155]                       class = class(workers))
[17:42:46.155]                     stop_if_not(is.finite(workers), workers >= 
[17:42:46.155]                       1L)
[17:42:46.155]                     if ((workers == 1L && !inherits(workers, 
[17:42:46.155]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:46.155]                       if (default_workers) 
[17:42:46.155]                         supportsMulticore(warn = TRUE)
[17:42:46.155]                       return(sequential(..., envir = envir))
[17:42:46.155]                     }
[17:42:46.155]                     oopts <- options(mc.cores = workers)
[17:42:46.155]                     on.exit(options(oopts))
[17:42:46.155]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:46.155]                       envir = envir)
[17:42:46.155]                     if (!future$lazy) 
[17:42:46.155]                       future <- run(future)
[17:42:46.155]                     invisible(future)
[17:42:46.155]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.155]                 }
[17:42:46.155]             }
[17:42:46.155]         }
[17:42:46.155]     })
[17:42:46.155]     if (TRUE) {
[17:42:46.155]         base::sink(type = "output", split = FALSE)
[17:42:46.155]         if (TRUE) {
[17:42:46.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.155]         }
[17:42:46.155]         else {
[17:42:46.155]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.155]         }
[17:42:46.155]         base::close(...future.stdout)
[17:42:46.155]         ...future.stdout <- NULL
[17:42:46.155]     }
[17:42:46.155]     ...future.result$conditions <- ...future.conditions
[17:42:46.155]     ...future.result$finished <- base::Sys.time()
[17:42:46.155]     ...future.result
[17:42:46.155] }
[17:42:46.158] assign_globals() ...
[17:42:46.158] List of 1
[17:42:46.158]  $ x:function ()  
[17:42:46.158]  - attr(*, "where")=List of 1
[17:42:46.158]   ..$ x:<environment: R_EmptyEnv> 
[17:42:46.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:46.158]  - attr(*, "resolved")= logi TRUE
[17:42:46.158]  - attr(*, "total_size")= num 1032
[17:42:46.158]  - attr(*, "already-done")= logi TRUE
[17:42:46.161] - reassign environment for ‘x’
[17:42:46.161] - copied ‘x’ to environment
[17:42:46.162] assign_globals() ... done
[17:42:46.162] requestCore(): workers = 2
[17:42:46.164] MulticoreFuture started
[17:42:46.165] - Launch lazy future ... done
[17:42:46.165] run() for ‘MulticoreFuture’ ... done
[17:42:46.165] plan(): Setting new future strategy stack:
[17:42:46.166] List of future strategies:
[17:42:46.166] 1. sequential:
[17:42:46.166]    - args: function (..., envir = parent.frame())
[17:42:46.166]    - tweaked: FALSE
[17:42:46.166]    - call: NULL
[17:42:46.167] plan(): nbrOfWorkers() = 1
[17:42:46.169] plan(): Setting new future strategy stack:
[17:42:46.169] List of future strategies:
[17:42:46.169] 1. multicore:
[17:42:46.169]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:46.169]    - tweaked: FALSE
[17:42:46.169]    - call: plan(strategy)
[17:42:46.175] plan(): nbrOfWorkers() = 2
value(f) = ‘TRUE’
- plan('multisession') ...
[17:42:46.177] plan(): Setting new future strategy stack:
[17:42:46.177] List of future strategies:
[17:42:46.177] 1. multisession:
[17:42:46.177]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:46.177]    - tweaked: FALSE
[17:42:46.177]    - call: plan(strategy)
[17:42:46.177] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:46.178] multisession:
[17:42:46.178] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:46.178] - tweaked: FALSE
[17:42:46.178] - call: plan(strategy)
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.185] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.185] Not searching for globals
[17:42:46.185] - globals: [0] <none>
[17:42:46.186] getGlobalsAndPackages() ... DONE
[17:42:46.186] [local output] makeClusterPSOCK() ...
[17:42:46.231] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:46.237] [local output] Base port: 11322
[17:42:46.237] [local output] Getting setup options for 2 cluster nodes ...
[17:42:46.237] [local output]  - Node 1 of 2 ...
[17:42:46.237] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:46.238] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsTBDOD/worker.rank=1.parallelly.parent=47656.ba28dcec782.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpsTBDOD/worker.rank=1.parallelly.parent=47656.ba28dcec782.pid")'’
[17:42:46.429] - Possible to infer worker's PID: TRUE
[17:42:46.429] [local output] Rscript port: 11322

[17:42:46.430] [local output]  - Node 2 of 2 ...
[17:42:46.430] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:46.431] [local output] Rscript port: 11322

[17:42:46.431] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:46.431] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:46.432] [local output] Setting up PSOCK nodes in parallel
[17:42:46.432] List of 36
[17:42:46.432]  $ worker          : chr "localhost"
[17:42:46.432]   ..- attr(*, "localhost")= logi TRUE
[17:42:46.432]  $ master          : chr "localhost"
[17:42:46.432]  $ port            : int 11322
[17:42:46.432]  $ connectTimeout  : num 120
[17:42:46.432]  $ timeout         : num 2592000
[17:42:46.432]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:46.432]  $ homogeneous     : logi TRUE
[17:42:46.432]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:46.432]  $ rscript_envs    : NULL
[17:42:46.432]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:46.432]  $ rscript_startup : NULL
[17:42:46.432]  $ rscript_sh      : chr "sh"
[17:42:46.432]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:46.432]  $ methods         : logi TRUE
[17:42:46.432]  $ socketOptions   : chr "no-delay"
[17:42:46.432]  $ useXDR          : logi FALSE
[17:42:46.432]  $ outfile         : chr "/dev/null"
[17:42:46.432]  $ renice          : int NA
[17:42:46.432]  $ rshcmd          : NULL
[17:42:46.432]  $ user            : chr(0) 
[17:42:46.432]  $ revtunnel       : logi FALSE
[17:42:46.432]  $ rshlogfile      : NULL
[17:42:46.432]  $ rshopts         : chr(0) 
[17:42:46.432]  $ rank            : int 1
[17:42:46.432]  $ manual          : logi FALSE
[17:42:46.432]  $ dryrun          : logi FALSE
[17:42:46.432]  $ quiet           : logi FALSE
[17:42:46.432]  $ setup_strategy  : chr "parallel"
[17:42:46.432]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:46.432]  $ pidfile         : chr "/tmp/RtmpsTBDOD/worker.rank=1.parallelly.parent=47656.ba28dcec782.pid"
[17:42:46.432]  $ rshcmd_label    : NULL
[17:42:46.432]  $ rsh_call        : NULL
[17:42:46.432]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:46.432]  $ localMachine    : logi TRUE
[17:42:46.432]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:46.432]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:46.432]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:46.432]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:46.432]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:46.432]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:46.432]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:46.432]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:46.432]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:46.432]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:46.432]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:46.432]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:46.432]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:46.432]  $ arguments       :List of 28
[17:42:46.432]   ..$ worker          : chr "localhost"
[17:42:46.432]   ..$ master          : NULL
[17:42:46.432]   ..$ port            : int 11322
[17:42:46.432]   ..$ connectTimeout  : num 120
[17:42:46.432]   ..$ timeout         : num 2592000
[17:42:46.432]   ..$ rscript         : NULL
[17:42:46.432]   ..$ homogeneous     : NULL
[17:42:46.432]   ..$ rscript_args    : NULL
[17:42:46.432]   ..$ rscript_envs    : NULL
[17:42:46.432]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:46.432]   ..$ rscript_startup : NULL
[17:42:46.432]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:46.432]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:46.432]   ..$ methods         : logi TRUE
[17:42:46.432]   ..$ socketOptions   : chr "no-delay"
[17:42:46.432]   ..$ useXDR          : logi FALSE
[17:42:46.432]   ..$ outfile         : chr "/dev/null"
[17:42:46.432]   ..$ renice          : int NA
[17:42:46.432]   ..$ rshcmd          : NULL
[17:42:46.432]   ..$ user            : NULL
[17:42:46.432]   ..$ revtunnel       : logi NA
[17:42:46.432]   ..$ rshlogfile      : NULL
[17:42:46.432]   ..$ rshopts         : NULL
[17:42:46.432]   ..$ rank            : int 1
[17:42:46.432]   ..$ manual          : logi FALSE
[17:42:46.432]   ..$ dryrun          : logi FALSE
[17:42:46.432]   ..$ quiet           : logi FALSE
[17:42:46.432]   ..$ setup_strategy  : chr "parallel"
[17:42:46.432]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:46.449] [local output] System call to launch all workers:
[17:42:46.449] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpsTBDOD/worker.rank=1.parallelly.parent=47656.ba28dcec782.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11322 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:46.449] [local output] Starting PSOCK main server
[17:42:46.451] [local output] Workers launched
[17:42:46.451] [local output] Waiting for workers to connect back
[17:42:46.451]  - [local output] 0 workers out of 2 ready
[17:42:46.695]  - [local output] 0 workers out of 2 ready
[17:42:46.696]  - [local output] 1 workers out of 2 ready
[17:42:46.697]  - [local output] 1 workers out of 2 ready
[17:42:46.697]  - [local output] 2 workers out of 2 ready
[17:42:46.697] [local output] Launching of workers completed
[17:42:46.698] [local output] Collecting session information from workers
[17:42:46.698] [local output]  - Worker #1 of 2
[17:42:46.699] [local output]  - Worker #2 of 2
[17:42:46.699] [local output] makeClusterPSOCK() ... done
[17:42:46.711] Packages needed by the future expression (n = 0): <none>
[17:42:46.711] Packages needed by future strategies (n = 0): <none>
[17:42:46.712] {
[17:42:46.712]     {
[17:42:46.712]         {
[17:42:46.712]             ...future.startTime <- base::Sys.time()
[17:42:46.712]             {
[17:42:46.712]                 {
[17:42:46.712]                   {
[17:42:46.712]                     {
[17:42:46.712]                       base::local({
[17:42:46.712]                         has_future <- base::requireNamespace("future", 
[17:42:46.712]                           quietly = TRUE)
[17:42:46.712]                         if (has_future) {
[17:42:46.712]                           ns <- base::getNamespace("future")
[17:42:46.712]                           version <- ns[[".package"]][["version"]]
[17:42:46.712]                           if (is.null(version)) 
[17:42:46.712]                             version <- utils::packageVersion("future")
[17:42:46.712]                         }
[17:42:46.712]                         else {
[17:42:46.712]                           version <- NULL
[17:42:46.712]                         }
[17:42:46.712]                         if (!has_future || version < "1.8.0") {
[17:42:46.712]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.712]                             "", base::R.version$version.string), 
[17:42:46.712]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:46.712]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.712]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.712]                               "release", "version")], collapse = " "), 
[17:42:46.712]                             hostname = base::Sys.info()[["nodename"]])
[17:42:46.712]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.712]                             info)
[17:42:46.712]                           info <- base::paste(info, collapse = "; ")
[17:42:46.712]                           if (!has_future) {
[17:42:46.712]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.712]                               info)
[17:42:46.712]                           }
[17:42:46.712]                           else {
[17:42:46.712]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.712]                               info, version)
[17:42:46.712]                           }
[17:42:46.712]                           base::stop(msg)
[17:42:46.712]                         }
[17:42:46.712]                       })
[17:42:46.712]                     }
[17:42:46.712]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.712]                     base::options(mc.cores = 1L)
[17:42:46.712]                   }
[17:42:46.712]                   options(future.plan = NULL)
[17:42:46.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.712]                 }
[17:42:46.712]                 ...future.workdir <- getwd()
[17:42:46.712]             }
[17:42:46.712]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.712]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.712]         }
[17:42:46.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.712]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:46.712]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.712]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.712]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.712]             base::names(...future.oldOptions))
[17:42:46.712]     }
[17:42:46.712]     if (FALSE) {
[17:42:46.712]     }
[17:42:46.712]     else {
[17:42:46.712]         if (TRUE) {
[17:42:46.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.712]                 open = "w")
[17:42:46.712]         }
[17:42:46.712]         else {
[17:42:46.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.712]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.712]         }
[17:42:46.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.712]             base::sink(type = "output", split = FALSE)
[17:42:46.712]             base::close(...future.stdout)
[17:42:46.712]         }, add = TRUE)
[17:42:46.712]     }
[17:42:46.712]     ...future.frame <- base::sys.nframe()
[17:42:46.712]     ...future.conditions <- base::list()
[17:42:46.712]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.712]     if (FALSE) {
[17:42:46.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.712]     }
[17:42:46.712]     ...future.result <- base::tryCatch({
[17:42:46.712]         base::withCallingHandlers({
[17:42:46.712]             ...future.value <- base::withVisible(base::local({
[17:42:46.712]                 ...future.makeSendCondition <- local({
[17:42:46.712]                   sendCondition <- NULL
[17:42:46.712]                   function(frame = 1L) {
[17:42:46.712]                     if (is.function(sendCondition)) 
[17:42:46.712]                       return(sendCondition)
[17:42:46.712]                     ns <- getNamespace("parallel")
[17:42:46.712]                     if (exists("sendData", mode = "function", 
[17:42:46.712]                       envir = ns)) {
[17:42:46.712]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:46.712]                         envir = ns)
[17:42:46.712]                       envir <- sys.frame(frame)
[17:42:46.712]                       master <- NULL
[17:42:46.712]                       while (!identical(envir, .GlobalEnv) && 
[17:42:46.712]                         !identical(envir, emptyenv())) {
[17:42:46.712]                         if (exists("master", mode = "list", envir = envir, 
[17:42:46.712]                           inherits = FALSE)) {
[17:42:46.712]                           master <- get("master", mode = "list", 
[17:42:46.712]                             envir = envir, inherits = FALSE)
[17:42:46.712]                           if (inherits(master, c("SOCKnode", 
[17:42:46.712]                             "SOCK0node"))) {
[17:42:46.712]                             sendCondition <<- function(cond) {
[17:42:46.712]                               data <- list(type = "VALUE", value = cond, 
[17:42:46.712]                                 success = TRUE)
[17:42:46.712]                               parallel_sendData(master, data)
[17:42:46.712]                             }
[17:42:46.712]                             return(sendCondition)
[17:42:46.712]                           }
[17:42:46.712]                         }
[17:42:46.712]                         frame <- frame + 1L
[17:42:46.712]                         envir <- sys.frame(frame)
[17:42:46.712]                       }
[17:42:46.712]                     }
[17:42:46.712]                     sendCondition <<- function(cond) NULL
[17:42:46.712]                   }
[17:42:46.712]                 })
[17:42:46.712]                 withCallingHandlers({
[17:42:46.712]                   NA
[17:42:46.712]                 }, immediateCondition = function(cond) {
[17:42:46.712]                   sendCondition <- ...future.makeSendCondition()
[17:42:46.712]                   sendCondition(cond)
[17:42:46.712]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.712]                   {
[17:42:46.712]                     inherits <- base::inherits
[17:42:46.712]                     invokeRestart <- base::invokeRestart
[17:42:46.712]                     is.null <- base::is.null
[17:42:46.712]                     muffled <- FALSE
[17:42:46.712]                     if (inherits(cond, "message")) {
[17:42:46.712]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.712]                       if (muffled) 
[17:42:46.712]                         invokeRestart("muffleMessage")
[17:42:46.712]                     }
[17:42:46.712]                     else if (inherits(cond, "warning")) {
[17:42:46.712]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.712]                       if (muffled) 
[17:42:46.712]                         invokeRestart("muffleWarning")
[17:42:46.712]                     }
[17:42:46.712]                     else if (inherits(cond, "condition")) {
[17:42:46.712]                       if (!is.null(pattern)) {
[17:42:46.712]                         computeRestarts <- base::computeRestarts
[17:42:46.712]                         grepl <- base::grepl
[17:42:46.712]                         restarts <- computeRestarts(cond)
[17:42:46.712]                         for (restart in restarts) {
[17:42:46.712]                           name <- restart$name
[17:42:46.712]                           if (is.null(name)) 
[17:42:46.712]                             next
[17:42:46.712]                           if (!grepl(pattern, name)) 
[17:42:46.712]                             next
[17:42:46.712]                           invokeRestart(restart)
[17:42:46.712]                           muffled <- TRUE
[17:42:46.712]                           break
[17:42:46.712]                         }
[17:42:46.712]                       }
[17:42:46.712]                     }
[17:42:46.712]                     invisible(muffled)
[17:42:46.712]                   }
[17:42:46.712]                   muffleCondition(cond)
[17:42:46.712]                 })
[17:42:46.712]             }))
[17:42:46.712]             future::FutureResult(value = ...future.value$value, 
[17:42:46.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.712]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.712]                     ...future.globalenv.names))
[17:42:46.712]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.712]         }, condition = base::local({
[17:42:46.712]             c <- base::c
[17:42:46.712]             inherits <- base::inherits
[17:42:46.712]             invokeRestart <- base::invokeRestart
[17:42:46.712]             length <- base::length
[17:42:46.712]             list <- base::list
[17:42:46.712]             seq.int <- base::seq.int
[17:42:46.712]             signalCondition <- base::signalCondition
[17:42:46.712]             sys.calls <- base::sys.calls
[17:42:46.712]             `[[` <- base::`[[`
[17:42:46.712]             `+` <- base::`+`
[17:42:46.712]             `<<-` <- base::`<<-`
[17:42:46.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.712]                   3L)]
[17:42:46.712]             }
[17:42:46.712]             function(cond) {
[17:42:46.712]                 is_error <- inherits(cond, "error")
[17:42:46.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.712]                   NULL)
[17:42:46.712]                 if (is_error) {
[17:42:46.712]                   sessionInformation <- function() {
[17:42:46.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.712]                       search = base::search(), system = base::Sys.info())
[17:42:46.712]                   }
[17:42:46.712]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.712]                     cond$call), session = sessionInformation(), 
[17:42:46.712]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.712]                   signalCondition(cond)
[17:42:46.712]                 }
[17:42:46.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.712]                 "immediateCondition"))) {
[17:42:46.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.712]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.712]                   if (TRUE && !signal) {
[17:42:46.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.712]                     {
[17:42:46.712]                       inherits <- base::inherits
[17:42:46.712]                       invokeRestart <- base::invokeRestart
[17:42:46.712]                       is.null <- base::is.null
[17:42:46.712]                       muffled <- FALSE
[17:42:46.712]                       if (inherits(cond, "message")) {
[17:42:46.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.712]                         if (muffled) 
[17:42:46.712]                           invokeRestart("muffleMessage")
[17:42:46.712]                       }
[17:42:46.712]                       else if (inherits(cond, "warning")) {
[17:42:46.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.712]                         if (muffled) 
[17:42:46.712]                           invokeRestart("muffleWarning")
[17:42:46.712]                       }
[17:42:46.712]                       else if (inherits(cond, "condition")) {
[17:42:46.712]                         if (!is.null(pattern)) {
[17:42:46.712]                           computeRestarts <- base::computeRestarts
[17:42:46.712]                           grepl <- base::grepl
[17:42:46.712]                           restarts <- computeRestarts(cond)
[17:42:46.712]                           for (restart in restarts) {
[17:42:46.712]                             name <- restart$name
[17:42:46.712]                             if (is.null(name)) 
[17:42:46.712]                               next
[17:42:46.712]                             if (!grepl(pattern, name)) 
[17:42:46.712]                               next
[17:42:46.712]                             invokeRestart(restart)
[17:42:46.712]                             muffled <- TRUE
[17:42:46.712]                             break
[17:42:46.712]                           }
[17:42:46.712]                         }
[17:42:46.712]                       }
[17:42:46.712]                       invisible(muffled)
[17:42:46.712]                     }
[17:42:46.712]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.712]                   }
[17:42:46.712]                 }
[17:42:46.712]                 else {
[17:42:46.712]                   if (TRUE) {
[17:42:46.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.712]                     {
[17:42:46.712]                       inherits <- base::inherits
[17:42:46.712]                       invokeRestart <- base::invokeRestart
[17:42:46.712]                       is.null <- base::is.null
[17:42:46.712]                       muffled <- FALSE
[17:42:46.712]                       if (inherits(cond, "message")) {
[17:42:46.712]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.712]                         if (muffled) 
[17:42:46.712]                           invokeRestart("muffleMessage")
[17:42:46.712]                       }
[17:42:46.712]                       else if (inherits(cond, "warning")) {
[17:42:46.712]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.712]                         if (muffled) 
[17:42:46.712]                           invokeRestart("muffleWarning")
[17:42:46.712]                       }
[17:42:46.712]                       else if (inherits(cond, "condition")) {
[17:42:46.712]                         if (!is.null(pattern)) {
[17:42:46.712]                           computeRestarts <- base::computeRestarts
[17:42:46.712]                           grepl <- base::grepl
[17:42:46.712]                           restarts <- computeRestarts(cond)
[17:42:46.712]                           for (restart in restarts) {
[17:42:46.712]                             name <- restart$name
[17:42:46.712]                             if (is.null(name)) 
[17:42:46.712]                               next
[17:42:46.712]                             if (!grepl(pattern, name)) 
[17:42:46.712]                               next
[17:42:46.712]                             invokeRestart(restart)
[17:42:46.712]                             muffled <- TRUE
[17:42:46.712]                             break
[17:42:46.712]                           }
[17:42:46.712]                         }
[17:42:46.712]                       }
[17:42:46.712]                       invisible(muffled)
[17:42:46.712]                     }
[17:42:46.712]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.712]                   }
[17:42:46.712]                 }
[17:42:46.712]             }
[17:42:46.712]         }))
[17:42:46.712]     }, error = function(ex) {
[17:42:46.712]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.712]                 ...future.rng), started = ...future.startTime, 
[17:42:46.712]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.712]             version = "1.8"), class = "FutureResult")
[17:42:46.712]     }, finally = {
[17:42:46.712]         if (!identical(...future.workdir, getwd())) 
[17:42:46.712]             setwd(...future.workdir)
[17:42:46.712]         {
[17:42:46.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.712]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.712]             }
[17:42:46.712]             base::options(...future.oldOptions)
[17:42:46.712]             if (.Platform$OS.type == "windows") {
[17:42:46.712]                 old_names <- names(...future.oldEnvVars)
[17:42:46.712]                 envs <- base::Sys.getenv()
[17:42:46.712]                 names <- names(envs)
[17:42:46.712]                 common <- intersect(names, old_names)
[17:42:46.712]                 added <- setdiff(names, old_names)
[17:42:46.712]                 removed <- setdiff(old_names, names)
[17:42:46.712]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.712]                   envs[common]]
[17:42:46.712]                 NAMES <- toupper(changed)
[17:42:46.712]                 args <- list()
[17:42:46.712]                 for (kk in seq_along(NAMES)) {
[17:42:46.712]                   name <- changed[[kk]]
[17:42:46.712]                   NAME <- NAMES[[kk]]
[17:42:46.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.712]                     next
[17:42:46.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.712]                 }
[17:42:46.712]                 NAMES <- toupper(added)
[17:42:46.712]                 for (kk in seq_along(NAMES)) {
[17:42:46.712]                   name <- added[[kk]]
[17:42:46.712]                   NAME <- NAMES[[kk]]
[17:42:46.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.712]                     next
[17:42:46.712]                   args[[name]] <- ""
[17:42:46.712]                 }
[17:42:46.712]                 NAMES <- toupper(removed)
[17:42:46.712]                 for (kk in seq_along(NAMES)) {
[17:42:46.712]                   name <- removed[[kk]]
[17:42:46.712]                   NAME <- NAMES[[kk]]
[17:42:46.712]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.712]                     next
[17:42:46.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.712]                 }
[17:42:46.712]                 if (length(args) > 0) 
[17:42:46.712]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.712]             }
[17:42:46.712]             else {
[17:42:46.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.712]             }
[17:42:46.712]             {
[17:42:46.712]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.712]                   0L) {
[17:42:46.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.712]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.712]                   base::options(opts)
[17:42:46.712]                 }
[17:42:46.712]                 {
[17:42:46.712]                   {
[17:42:46.712]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.712]                     NULL
[17:42:46.712]                   }
[17:42:46.712]                   options(future.plan = NULL)
[17:42:46.712]                   if (is.na(NA_character_)) 
[17:42:46.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.712]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:46.712]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:46.712]                     envir = parent.frame()) 
[17:42:46.712]                   {
[17:42:46.712]                     if (is.function(workers)) 
[17:42:46.712]                       workers <- workers()
[17:42:46.712]                     workers <- structure(as.integer(workers), 
[17:42:46.712]                       class = class(workers))
[17:42:46.712]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:46.712]                       workers >= 1)
[17:42:46.712]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:46.712]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:46.712]                     }
[17:42:46.712]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:46.712]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:46.712]                       envir = envir)
[17:42:46.712]                     if (!future$lazy) 
[17:42:46.712]                       future <- run(future)
[17:42:46.712]                     invisible(future)
[17:42:46.712]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.712]                 }
[17:42:46.712]             }
[17:42:46.712]         }
[17:42:46.712]     })
[17:42:46.712]     if (TRUE) {
[17:42:46.712]         base::sink(type = "output", split = FALSE)
[17:42:46.712]         if (TRUE) {
[17:42:46.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.712]         }
[17:42:46.712]         else {
[17:42:46.712]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.712]         }
[17:42:46.712]         base::close(...future.stdout)
[17:42:46.712]         ...future.stdout <- NULL
[17:42:46.712]     }
[17:42:46.712]     ...future.result$conditions <- ...future.conditions
[17:42:46.712]     ...future.result$finished <- base::Sys.time()
[17:42:46.712]     ...future.result
[17:42:46.712] }
[17:42:46.784] MultisessionFuture started
[17:42:46.785] result() for ClusterFuture ...
[17:42:46.785] receiveMessageFromWorker() for ClusterFuture ...
[17:42:46.786] - Validating connection of MultisessionFuture
[17:42:46.818] - received message: FutureResult
[17:42:46.819] - Received FutureResult
[17:42:46.819] - Erased future from FutureRegistry
[17:42:46.819] result() for ClusterFuture ...
[17:42:46.819] - result already collected: FutureResult
[17:42:46.819] result() for ClusterFuture ... done
[17:42:46.819] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:46.819] result() for ClusterFuture ... done
[17:42:46.820] result() for ClusterFuture ...
[17:42:46.820] - result already collected: FutureResult
[17:42:46.820] result() for ClusterFuture ... done
[17:42:46.820] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:46.823] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.824] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.824] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:46.826] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:42:46.826] Searching for globals ... DONE
[17:42:46.826] Resolving globals: TRUE
[17:42:46.826] Resolving any globals that are futures ...
[17:42:46.826] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:42:46.826] Resolving any globals that are futures ... DONE
[17:42:46.827] 
[17:42:46.827] 
[17:42:46.827] getGlobalsAndPackages() ... DONE
[17:42:46.827] run() for ‘Future’ ...
[17:42:46.827] - state: ‘created’
[17:42:46.828] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:46.843] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:46.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:46.843]   - Field: ‘node’
[17:42:46.843]   - Field: ‘label’
[17:42:46.843]   - Field: ‘local’
[17:42:46.843]   - Field: ‘owner’
[17:42:46.843]   - Field: ‘envir’
[17:42:46.844]   - Field: ‘workers’
[17:42:46.844]   - Field: ‘packages’
[17:42:46.844]   - Field: ‘gc’
[17:42:46.844]   - Field: ‘conditions’
[17:42:46.844]   - Field: ‘persistent’
[17:42:46.844]   - Field: ‘expr’
[17:42:46.844]   - Field: ‘uuid’
[17:42:46.844]   - Field: ‘seed’
[17:42:46.844]   - Field: ‘version’
[17:42:46.845]   - Field: ‘result’
[17:42:46.845]   - Field: ‘asynchronous’
[17:42:46.845]   - Field: ‘calls’
[17:42:46.845]   - Field: ‘globals’
[17:42:46.845]   - Field: ‘stdout’
[17:42:46.845]   - Field: ‘earlySignal’
[17:42:46.845]   - Field: ‘lazy’
[17:42:46.846]   - Field: ‘state’
[17:42:46.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:46.846] - Launch lazy future ...
[17:42:46.846] Packages needed by the future expression (n = 0): <none>
[17:42:46.847] Packages needed by future strategies (n = 0): <none>
[17:42:46.848] {
[17:42:46.848]     {
[17:42:46.848]         {
[17:42:46.848]             ...future.startTime <- base::Sys.time()
[17:42:46.848]             {
[17:42:46.848]                 {
[17:42:46.848]                   {
[17:42:46.848]                     {
[17:42:46.848]                       base::local({
[17:42:46.848]                         has_future <- base::requireNamespace("future", 
[17:42:46.848]                           quietly = TRUE)
[17:42:46.848]                         if (has_future) {
[17:42:46.848]                           ns <- base::getNamespace("future")
[17:42:46.848]                           version <- ns[[".package"]][["version"]]
[17:42:46.848]                           if (is.null(version)) 
[17:42:46.848]                             version <- utils::packageVersion("future")
[17:42:46.848]                         }
[17:42:46.848]                         else {
[17:42:46.848]                           version <- NULL
[17:42:46.848]                         }
[17:42:46.848]                         if (!has_future || version < "1.8.0") {
[17:42:46.848]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.848]                             "", base::R.version$version.string), 
[17:42:46.848]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:46.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.848]                               "release", "version")], collapse = " "), 
[17:42:46.848]                             hostname = base::Sys.info()[["nodename"]])
[17:42:46.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.848]                             info)
[17:42:46.848]                           info <- base::paste(info, collapse = "; ")
[17:42:46.848]                           if (!has_future) {
[17:42:46.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.848]                               info)
[17:42:46.848]                           }
[17:42:46.848]                           else {
[17:42:46.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.848]                               info, version)
[17:42:46.848]                           }
[17:42:46.848]                           base::stop(msg)
[17:42:46.848]                         }
[17:42:46.848]                       })
[17:42:46.848]                     }
[17:42:46.848]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.848]                     base::options(mc.cores = 1L)
[17:42:46.848]                   }
[17:42:46.848]                   options(future.plan = NULL)
[17:42:46.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.848]                 }
[17:42:46.848]                 ...future.workdir <- getwd()
[17:42:46.848]             }
[17:42:46.848]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.848]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.848]         }
[17:42:46.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.848]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:46.848]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.848]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.848]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.848]             base::names(...future.oldOptions))
[17:42:46.848]     }
[17:42:46.848]     if (FALSE) {
[17:42:46.848]     }
[17:42:46.848]     else {
[17:42:46.848]         if (TRUE) {
[17:42:46.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.848]                 open = "w")
[17:42:46.848]         }
[17:42:46.848]         else {
[17:42:46.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.848]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.848]         }
[17:42:46.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.848]             base::sink(type = "output", split = FALSE)
[17:42:46.848]             base::close(...future.stdout)
[17:42:46.848]         }, add = TRUE)
[17:42:46.848]     }
[17:42:46.848]     ...future.frame <- base::sys.nframe()
[17:42:46.848]     ...future.conditions <- base::list()
[17:42:46.848]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.848]     if (FALSE) {
[17:42:46.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.848]     }
[17:42:46.848]     ...future.result <- base::tryCatch({
[17:42:46.848]         base::withCallingHandlers({
[17:42:46.848]             ...future.value <- base::withVisible(base::local({
[17:42:46.848]                 ...future.makeSendCondition <- local({
[17:42:46.848]                   sendCondition <- NULL
[17:42:46.848]                   function(frame = 1L) {
[17:42:46.848]                     if (is.function(sendCondition)) 
[17:42:46.848]                       return(sendCondition)
[17:42:46.848]                     ns <- getNamespace("parallel")
[17:42:46.848]                     if (exists("sendData", mode = "function", 
[17:42:46.848]                       envir = ns)) {
[17:42:46.848]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:46.848]                         envir = ns)
[17:42:46.848]                       envir <- sys.frame(frame)
[17:42:46.848]                       master <- NULL
[17:42:46.848]                       while (!identical(envir, .GlobalEnv) && 
[17:42:46.848]                         !identical(envir, emptyenv())) {
[17:42:46.848]                         if (exists("master", mode = "list", envir = envir, 
[17:42:46.848]                           inherits = FALSE)) {
[17:42:46.848]                           master <- get("master", mode = "list", 
[17:42:46.848]                             envir = envir, inherits = FALSE)
[17:42:46.848]                           if (inherits(master, c("SOCKnode", 
[17:42:46.848]                             "SOCK0node"))) {
[17:42:46.848]                             sendCondition <<- function(cond) {
[17:42:46.848]                               data <- list(type = "VALUE", value = cond, 
[17:42:46.848]                                 success = TRUE)
[17:42:46.848]                               parallel_sendData(master, data)
[17:42:46.848]                             }
[17:42:46.848]                             return(sendCondition)
[17:42:46.848]                           }
[17:42:46.848]                         }
[17:42:46.848]                         frame <- frame + 1L
[17:42:46.848]                         envir <- sys.frame(frame)
[17:42:46.848]                       }
[17:42:46.848]                     }
[17:42:46.848]                     sendCondition <<- function(cond) NULL
[17:42:46.848]                   }
[17:42:46.848]                 })
[17:42:46.848]                 withCallingHandlers({
[17:42:46.848]                   {
[17:42:46.848]                     b <- a
[17:42:46.848]                     a <- 2
[17:42:46.848]                     a * b
[17:42:46.848]                   }
[17:42:46.848]                 }, immediateCondition = function(cond) {
[17:42:46.848]                   sendCondition <- ...future.makeSendCondition()
[17:42:46.848]                   sendCondition(cond)
[17:42:46.848]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.848]                   {
[17:42:46.848]                     inherits <- base::inherits
[17:42:46.848]                     invokeRestart <- base::invokeRestart
[17:42:46.848]                     is.null <- base::is.null
[17:42:46.848]                     muffled <- FALSE
[17:42:46.848]                     if (inherits(cond, "message")) {
[17:42:46.848]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.848]                       if (muffled) 
[17:42:46.848]                         invokeRestart("muffleMessage")
[17:42:46.848]                     }
[17:42:46.848]                     else if (inherits(cond, "warning")) {
[17:42:46.848]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.848]                       if (muffled) 
[17:42:46.848]                         invokeRestart("muffleWarning")
[17:42:46.848]                     }
[17:42:46.848]                     else if (inherits(cond, "condition")) {
[17:42:46.848]                       if (!is.null(pattern)) {
[17:42:46.848]                         computeRestarts <- base::computeRestarts
[17:42:46.848]                         grepl <- base::grepl
[17:42:46.848]                         restarts <- computeRestarts(cond)
[17:42:46.848]                         for (restart in restarts) {
[17:42:46.848]                           name <- restart$name
[17:42:46.848]                           if (is.null(name)) 
[17:42:46.848]                             next
[17:42:46.848]                           if (!grepl(pattern, name)) 
[17:42:46.848]                             next
[17:42:46.848]                           invokeRestart(restart)
[17:42:46.848]                           muffled <- TRUE
[17:42:46.848]                           break
[17:42:46.848]                         }
[17:42:46.848]                       }
[17:42:46.848]                     }
[17:42:46.848]                     invisible(muffled)
[17:42:46.848]                   }
[17:42:46.848]                   muffleCondition(cond)
[17:42:46.848]                 })
[17:42:46.848]             }))
[17:42:46.848]             future::FutureResult(value = ...future.value$value, 
[17:42:46.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.848]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.848]                     ...future.globalenv.names))
[17:42:46.848]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.848]         }, condition = base::local({
[17:42:46.848]             c <- base::c
[17:42:46.848]             inherits <- base::inherits
[17:42:46.848]             invokeRestart <- base::invokeRestart
[17:42:46.848]             length <- base::length
[17:42:46.848]             list <- base::list
[17:42:46.848]             seq.int <- base::seq.int
[17:42:46.848]             signalCondition <- base::signalCondition
[17:42:46.848]             sys.calls <- base::sys.calls
[17:42:46.848]             `[[` <- base::`[[`
[17:42:46.848]             `+` <- base::`+`
[17:42:46.848]             `<<-` <- base::`<<-`
[17:42:46.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.848]                   3L)]
[17:42:46.848]             }
[17:42:46.848]             function(cond) {
[17:42:46.848]                 is_error <- inherits(cond, "error")
[17:42:46.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.848]                   NULL)
[17:42:46.848]                 if (is_error) {
[17:42:46.848]                   sessionInformation <- function() {
[17:42:46.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.848]                       search = base::search(), system = base::Sys.info())
[17:42:46.848]                   }
[17:42:46.848]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.848]                     cond$call), session = sessionInformation(), 
[17:42:46.848]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.848]                   signalCondition(cond)
[17:42:46.848]                 }
[17:42:46.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.848]                 "immediateCondition"))) {
[17:42:46.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.848]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.848]                   if (TRUE && !signal) {
[17:42:46.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.848]                     {
[17:42:46.848]                       inherits <- base::inherits
[17:42:46.848]                       invokeRestart <- base::invokeRestart
[17:42:46.848]                       is.null <- base::is.null
[17:42:46.848]                       muffled <- FALSE
[17:42:46.848]                       if (inherits(cond, "message")) {
[17:42:46.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.848]                         if (muffled) 
[17:42:46.848]                           invokeRestart("muffleMessage")
[17:42:46.848]                       }
[17:42:46.848]                       else if (inherits(cond, "warning")) {
[17:42:46.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.848]                         if (muffled) 
[17:42:46.848]                           invokeRestart("muffleWarning")
[17:42:46.848]                       }
[17:42:46.848]                       else if (inherits(cond, "condition")) {
[17:42:46.848]                         if (!is.null(pattern)) {
[17:42:46.848]                           computeRestarts <- base::computeRestarts
[17:42:46.848]                           grepl <- base::grepl
[17:42:46.848]                           restarts <- computeRestarts(cond)
[17:42:46.848]                           for (restart in restarts) {
[17:42:46.848]                             name <- restart$name
[17:42:46.848]                             if (is.null(name)) 
[17:42:46.848]                               next
[17:42:46.848]                             if (!grepl(pattern, name)) 
[17:42:46.848]                               next
[17:42:46.848]                             invokeRestart(restart)
[17:42:46.848]                             muffled <- TRUE
[17:42:46.848]                             break
[17:42:46.848]                           }
[17:42:46.848]                         }
[17:42:46.848]                       }
[17:42:46.848]                       invisible(muffled)
[17:42:46.848]                     }
[17:42:46.848]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.848]                   }
[17:42:46.848]                 }
[17:42:46.848]                 else {
[17:42:46.848]                   if (TRUE) {
[17:42:46.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.848]                     {
[17:42:46.848]                       inherits <- base::inherits
[17:42:46.848]                       invokeRestart <- base::invokeRestart
[17:42:46.848]                       is.null <- base::is.null
[17:42:46.848]                       muffled <- FALSE
[17:42:46.848]                       if (inherits(cond, "message")) {
[17:42:46.848]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.848]                         if (muffled) 
[17:42:46.848]                           invokeRestart("muffleMessage")
[17:42:46.848]                       }
[17:42:46.848]                       else if (inherits(cond, "warning")) {
[17:42:46.848]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.848]                         if (muffled) 
[17:42:46.848]                           invokeRestart("muffleWarning")
[17:42:46.848]                       }
[17:42:46.848]                       else if (inherits(cond, "condition")) {
[17:42:46.848]                         if (!is.null(pattern)) {
[17:42:46.848]                           computeRestarts <- base::computeRestarts
[17:42:46.848]                           grepl <- base::grepl
[17:42:46.848]                           restarts <- computeRestarts(cond)
[17:42:46.848]                           for (restart in restarts) {
[17:42:46.848]                             name <- restart$name
[17:42:46.848]                             if (is.null(name)) 
[17:42:46.848]                               next
[17:42:46.848]                             if (!grepl(pattern, name)) 
[17:42:46.848]                               next
[17:42:46.848]                             invokeRestart(restart)
[17:42:46.848]                             muffled <- TRUE
[17:42:46.848]                             break
[17:42:46.848]                           }
[17:42:46.848]                         }
[17:42:46.848]                       }
[17:42:46.848]                       invisible(muffled)
[17:42:46.848]                     }
[17:42:46.848]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.848]                   }
[17:42:46.848]                 }
[17:42:46.848]             }
[17:42:46.848]         }))
[17:42:46.848]     }, error = function(ex) {
[17:42:46.848]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.848]                 ...future.rng), started = ...future.startTime, 
[17:42:46.848]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.848]             version = "1.8"), class = "FutureResult")
[17:42:46.848]     }, finally = {
[17:42:46.848]         if (!identical(...future.workdir, getwd())) 
[17:42:46.848]             setwd(...future.workdir)
[17:42:46.848]         {
[17:42:46.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.848]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.848]             }
[17:42:46.848]             base::options(...future.oldOptions)
[17:42:46.848]             if (.Platform$OS.type == "windows") {
[17:42:46.848]                 old_names <- names(...future.oldEnvVars)
[17:42:46.848]                 envs <- base::Sys.getenv()
[17:42:46.848]                 names <- names(envs)
[17:42:46.848]                 common <- intersect(names, old_names)
[17:42:46.848]                 added <- setdiff(names, old_names)
[17:42:46.848]                 removed <- setdiff(old_names, names)
[17:42:46.848]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.848]                   envs[common]]
[17:42:46.848]                 NAMES <- toupper(changed)
[17:42:46.848]                 args <- list()
[17:42:46.848]                 for (kk in seq_along(NAMES)) {
[17:42:46.848]                   name <- changed[[kk]]
[17:42:46.848]                   NAME <- NAMES[[kk]]
[17:42:46.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.848]                     next
[17:42:46.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.848]                 }
[17:42:46.848]                 NAMES <- toupper(added)
[17:42:46.848]                 for (kk in seq_along(NAMES)) {
[17:42:46.848]                   name <- added[[kk]]
[17:42:46.848]                   NAME <- NAMES[[kk]]
[17:42:46.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.848]                     next
[17:42:46.848]                   args[[name]] <- ""
[17:42:46.848]                 }
[17:42:46.848]                 NAMES <- toupper(removed)
[17:42:46.848]                 for (kk in seq_along(NAMES)) {
[17:42:46.848]                   name <- removed[[kk]]
[17:42:46.848]                   NAME <- NAMES[[kk]]
[17:42:46.848]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.848]                     next
[17:42:46.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.848]                 }
[17:42:46.848]                 if (length(args) > 0) 
[17:42:46.848]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.848]             }
[17:42:46.848]             else {
[17:42:46.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.848]             }
[17:42:46.848]             {
[17:42:46.848]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.848]                   0L) {
[17:42:46.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.848]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.848]                   base::options(opts)
[17:42:46.848]                 }
[17:42:46.848]                 {
[17:42:46.848]                   {
[17:42:46.848]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.848]                     NULL
[17:42:46.848]                   }
[17:42:46.848]                   options(future.plan = NULL)
[17:42:46.848]                   if (is.na(NA_character_)) 
[17:42:46.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.848]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:46.848]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:46.848]                     envir = parent.frame()) 
[17:42:46.848]                   {
[17:42:46.848]                     if (is.function(workers)) 
[17:42:46.848]                       workers <- workers()
[17:42:46.848]                     workers <- structure(as.integer(workers), 
[17:42:46.848]                       class = class(workers))
[17:42:46.848]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:46.848]                       workers >= 1)
[17:42:46.848]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:46.848]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:46.848]                     }
[17:42:46.848]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:46.848]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:46.848]                       envir = envir)
[17:42:46.848]                     if (!future$lazy) 
[17:42:46.848]                       future <- run(future)
[17:42:46.848]                     invisible(future)
[17:42:46.848]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.848]                 }
[17:42:46.848]             }
[17:42:46.848]         }
[17:42:46.848]     })
[17:42:46.848]     if (TRUE) {
[17:42:46.848]         base::sink(type = "output", split = FALSE)
[17:42:46.848]         if (TRUE) {
[17:42:46.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.848]         }
[17:42:46.848]         else {
[17:42:46.848]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.848]         }
[17:42:46.848]         base::close(...future.stdout)
[17:42:46.848]         ...future.stdout <- NULL
[17:42:46.848]     }
[17:42:46.848]     ...future.result$conditions <- ...future.conditions
[17:42:46.848]     ...future.result$finished <- base::Sys.time()
[17:42:46.848]     ...future.result
[17:42:46.848] }
[17:42:46.851] MultisessionFuture started
[17:42:46.852] - Launch lazy future ... done
[17:42:46.852] run() for ‘MultisessionFuture’ ... done
[17:42:46.852] result() for ClusterFuture ...
[17:42:46.852] receiveMessageFromWorker() for ClusterFuture ...
[17:42:46.852] - Validating connection of MultisessionFuture
[17:42:46.901] - received message: FutureResult
[17:42:46.901] - Received FutureResult
[17:42:46.901] - Erased future from FutureRegistry
[17:42:46.901] result() for ClusterFuture ...
[17:42:46.902] - result already collected: FutureResult
[17:42:46.902] result() for ClusterFuture ... done
[17:42:46.902] signalConditions() ...
[17:42:46.902]  - include = ‘immediateCondition’
[17:42:46.902]  - exclude = 
[17:42:46.902]  - resignal = FALSE
[17:42:46.902]  - Number of conditions: 1
[17:42:46.903] signalConditions() ... done
[17:42:46.903] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:46.903] result() for ClusterFuture ... done
[17:42:46.903] result() for ClusterFuture ...
[17:42:46.903] - result already collected: FutureResult
[17:42:46.903] result() for ClusterFuture ... done
[17:42:46.903] signalConditions() ...
[17:42:46.903]  - include = ‘immediateCondition’
[17:42:46.903]  - exclude = 
[17:42:46.904]  - resignal = FALSE
[17:42:46.904]  - Number of conditions: 1
[17:42:46.904] signalConditions() ... done
[17:42:46.904] Future state: ‘finished’
[17:42:46.904] result() for ClusterFuture ...
[17:42:46.904] - result already collected: FutureResult
[17:42:46.904] result() for ClusterFuture ... done
[17:42:46.904] signalConditions() ...
[17:42:46.905]  - include = ‘condition’
[17:42:46.905]  - exclude = ‘immediateCondition’
[17:42:46.905]  - resignal = TRUE
[17:42:46.905]  - Number of conditions: 1
[17:42:46.905]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:46.905] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:46"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:46.922] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:46.922] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:46.924] - globals found: [3] ‘{’, ‘<-’, ‘*’
[17:42:46.924] Searching for globals ... DONE
[17:42:46.924] Resolving globals: TRUE
[17:42:46.924] Resolving any globals that are futures ...
[17:42:46.924] - globals: [3] ‘{’, ‘<-’, ‘*’
[17:42:46.924] Resolving any globals that are futures ... DONE
[17:42:46.925] 
[17:42:46.925] 
[17:42:46.925] getGlobalsAndPackages() ... DONE
[17:42:46.925] run() for ‘Future’ ...
[17:42:46.926] - state: ‘created’
[17:42:46.926] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:46.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:46.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:46.942]   - Field: ‘node’
[17:42:46.942]   - Field: ‘label’
[17:42:46.942]   - Field: ‘local’
[17:42:46.942]   - Field: ‘owner’
[17:42:46.943]   - Field: ‘envir’
[17:42:46.943]   - Field: ‘workers’
[17:42:46.943]   - Field: ‘packages’
[17:42:46.943]   - Field: ‘gc’
[17:42:46.943]   - Field: ‘conditions’
[17:42:46.943]   - Field: ‘persistent’
[17:42:46.943]   - Field: ‘expr’
[17:42:46.943]   - Field: ‘uuid’
[17:42:46.944]   - Field: ‘seed’
[17:42:46.944]   - Field: ‘version’
[17:42:46.944]   - Field: ‘result’
[17:42:46.944]   - Field: ‘asynchronous’
[17:42:46.944]   - Field: ‘calls’
[17:42:46.944]   - Field: ‘globals’
[17:42:46.944]   - Field: ‘stdout’
[17:42:46.944]   - Field: ‘earlySignal’
[17:42:46.944]   - Field: ‘lazy’
[17:42:46.945]   - Field: ‘state’
[17:42:46.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:46.945] - Launch lazy future ...
[17:42:46.945] Packages needed by the future expression (n = 0): <none>
[17:42:46.945] Packages needed by future strategies (n = 0): <none>
[17:42:46.946] {
[17:42:46.946]     {
[17:42:46.946]         {
[17:42:46.946]             ...future.startTime <- base::Sys.time()
[17:42:46.946]             {
[17:42:46.946]                 {
[17:42:46.946]                   {
[17:42:46.946]                     {
[17:42:46.946]                       base::local({
[17:42:46.946]                         has_future <- base::requireNamespace("future", 
[17:42:46.946]                           quietly = TRUE)
[17:42:46.946]                         if (has_future) {
[17:42:46.946]                           ns <- base::getNamespace("future")
[17:42:46.946]                           version <- ns[[".package"]][["version"]]
[17:42:46.946]                           if (is.null(version)) 
[17:42:46.946]                             version <- utils::packageVersion("future")
[17:42:46.946]                         }
[17:42:46.946]                         else {
[17:42:46.946]                           version <- NULL
[17:42:46.946]                         }
[17:42:46.946]                         if (!has_future || version < "1.8.0") {
[17:42:46.946]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:46.946]                             "", base::R.version$version.string), 
[17:42:46.946]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:46.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:46.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:46.946]                               "release", "version")], collapse = " "), 
[17:42:46.946]                             hostname = base::Sys.info()[["nodename"]])
[17:42:46.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:46.946]                             info)
[17:42:46.946]                           info <- base::paste(info, collapse = "; ")
[17:42:46.946]                           if (!has_future) {
[17:42:46.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:46.946]                               info)
[17:42:46.946]                           }
[17:42:46.946]                           else {
[17:42:46.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:46.946]                               info, version)
[17:42:46.946]                           }
[17:42:46.946]                           base::stop(msg)
[17:42:46.946]                         }
[17:42:46.946]                       })
[17:42:46.946]                     }
[17:42:46.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:46.946]                     base::options(mc.cores = 1L)
[17:42:46.946]                   }
[17:42:46.946]                   options(future.plan = NULL)
[17:42:46.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:46.946]                 }
[17:42:46.946]                 ...future.workdir <- getwd()
[17:42:46.946]             }
[17:42:46.946]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:46.946]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:46.946]         }
[17:42:46.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:46.946]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:46.946]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:46.946]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:46.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:46.946]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:46.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:46.946]             base::names(...future.oldOptions))
[17:42:46.946]     }
[17:42:46.946]     if (FALSE) {
[17:42:46.946]     }
[17:42:46.946]     else {
[17:42:46.946]         if (TRUE) {
[17:42:46.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:46.946]                 open = "w")
[17:42:46.946]         }
[17:42:46.946]         else {
[17:42:46.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:46.946]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:46.946]         }
[17:42:46.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:46.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:46.946]             base::sink(type = "output", split = FALSE)
[17:42:46.946]             base::close(...future.stdout)
[17:42:46.946]         }, add = TRUE)
[17:42:46.946]     }
[17:42:46.946]     ...future.frame <- base::sys.nframe()
[17:42:46.946]     ...future.conditions <- base::list()
[17:42:46.946]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:46.946]     if (FALSE) {
[17:42:46.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:46.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:46.946]     }
[17:42:46.946]     ...future.result <- base::tryCatch({
[17:42:46.946]         base::withCallingHandlers({
[17:42:46.946]             ...future.value <- base::withVisible(base::local({
[17:42:46.946]                 ...future.makeSendCondition <- local({
[17:42:46.946]                   sendCondition <- NULL
[17:42:46.946]                   function(frame = 1L) {
[17:42:46.946]                     if (is.function(sendCondition)) 
[17:42:46.946]                       return(sendCondition)
[17:42:46.946]                     ns <- getNamespace("parallel")
[17:42:46.946]                     if (exists("sendData", mode = "function", 
[17:42:46.946]                       envir = ns)) {
[17:42:46.946]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:46.946]                         envir = ns)
[17:42:46.946]                       envir <- sys.frame(frame)
[17:42:46.946]                       master <- NULL
[17:42:46.946]                       while (!identical(envir, .GlobalEnv) && 
[17:42:46.946]                         !identical(envir, emptyenv())) {
[17:42:46.946]                         if (exists("master", mode = "list", envir = envir, 
[17:42:46.946]                           inherits = FALSE)) {
[17:42:46.946]                           master <- get("master", mode = "list", 
[17:42:46.946]                             envir = envir, inherits = FALSE)
[17:42:46.946]                           if (inherits(master, c("SOCKnode", 
[17:42:46.946]                             "SOCK0node"))) {
[17:42:46.946]                             sendCondition <<- function(cond) {
[17:42:46.946]                               data <- list(type = "VALUE", value = cond, 
[17:42:46.946]                                 success = TRUE)
[17:42:46.946]                               parallel_sendData(master, data)
[17:42:46.946]                             }
[17:42:46.946]                             return(sendCondition)
[17:42:46.946]                           }
[17:42:46.946]                         }
[17:42:46.946]                         frame <- frame + 1L
[17:42:46.946]                         envir <- sys.frame(frame)
[17:42:46.946]                       }
[17:42:46.946]                     }
[17:42:46.946]                     sendCondition <<- function(cond) NULL
[17:42:46.946]                   }
[17:42:46.946]                 })
[17:42:46.946]                 withCallingHandlers({
[17:42:46.946]                   {
[17:42:46.946]                     b <- a
[17:42:46.946]                     a <- 2
[17:42:46.946]                     a * b
[17:42:46.946]                   }
[17:42:46.946]                 }, immediateCondition = function(cond) {
[17:42:46.946]                   sendCondition <- ...future.makeSendCondition()
[17:42:46.946]                   sendCondition(cond)
[17:42:46.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.946]                   {
[17:42:46.946]                     inherits <- base::inherits
[17:42:46.946]                     invokeRestart <- base::invokeRestart
[17:42:46.946]                     is.null <- base::is.null
[17:42:46.946]                     muffled <- FALSE
[17:42:46.946]                     if (inherits(cond, "message")) {
[17:42:46.946]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:46.946]                       if (muffled) 
[17:42:46.946]                         invokeRestart("muffleMessage")
[17:42:46.946]                     }
[17:42:46.946]                     else if (inherits(cond, "warning")) {
[17:42:46.946]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:46.946]                       if (muffled) 
[17:42:46.946]                         invokeRestart("muffleWarning")
[17:42:46.946]                     }
[17:42:46.946]                     else if (inherits(cond, "condition")) {
[17:42:46.946]                       if (!is.null(pattern)) {
[17:42:46.946]                         computeRestarts <- base::computeRestarts
[17:42:46.946]                         grepl <- base::grepl
[17:42:46.946]                         restarts <- computeRestarts(cond)
[17:42:46.946]                         for (restart in restarts) {
[17:42:46.946]                           name <- restart$name
[17:42:46.946]                           if (is.null(name)) 
[17:42:46.946]                             next
[17:42:46.946]                           if (!grepl(pattern, name)) 
[17:42:46.946]                             next
[17:42:46.946]                           invokeRestart(restart)
[17:42:46.946]                           muffled <- TRUE
[17:42:46.946]                           break
[17:42:46.946]                         }
[17:42:46.946]                       }
[17:42:46.946]                     }
[17:42:46.946]                     invisible(muffled)
[17:42:46.946]                   }
[17:42:46.946]                   muffleCondition(cond)
[17:42:46.946]                 })
[17:42:46.946]             }))
[17:42:46.946]             future::FutureResult(value = ...future.value$value, 
[17:42:46.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.946]                   ...future.rng), globalenv = if (FALSE) 
[17:42:46.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:46.946]                     ...future.globalenv.names))
[17:42:46.946]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:46.946]         }, condition = base::local({
[17:42:46.946]             c <- base::c
[17:42:46.946]             inherits <- base::inherits
[17:42:46.946]             invokeRestart <- base::invokeRestart
[17:42:46.946]             length <- base::length
[17:42:46.946]             list <- base::list
[17:42:46.946]             seq.int <- base::seq.int
[17:42:46.946]             signalCondition <- base::signalCondition
[17:42:46.946]             sys.calls <- base::sys.calls
[17:42:46.946]             `[[` <- base::`[[`
[17:42:46.946]             `+` <- base::`+`
[17:42:46.946]             `<<-` <- base::`<<-`
[17:42:46.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:46.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:46.946]                   3L)]
[17:42:46.946]             }
[17:42:46.946]             function(cond) {
[17:42:46.946]                 is_error <- inherits(cond, "error")
[17:42:46.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:46.946]                   NULL)
[17:42:46.946]                 if (is_error) {
[17:42:46.946]                   sessionInformation <- function() {
[17:42:46.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:46.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:46.946]                       search = base::search(), system = base::Sys.info())
[17:42:46.946]                   }
[17:42:46.946]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:46.946]                     cond$call), session = sessionInformation(), 
[17:42:46.946]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:46.946]                   signalCondition(cond)
[17:42:46.946]                 }
[17:42:46.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:46.946]                 "immediateCondition"))) {
[17:42:46.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:46.946]                   ...future.conditions[[length(...future.conditions) + 
[17:42:46.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:46.946]                   if (TRUE && !signal) {
[17:42:46.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.946]                     {
[17:42:46.946]                       inherits <- base::inherits
[17:42:46.946]                       invokeRestart <- base::invokeRestart
[17:42:46.946]                       is.null <- base::is.null
[17:42:46.946]                       muffled <- FALSE
[17:42:46.946]                       if (inherits(cond, "message")) {
[17:42:46.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.946]                         if (muffled) 
[17:42:46.946]                           invokeRestart("muffleMessage")
[17:42:46.946]                       }
[17:42:46.946]                       else if (inherits(cond, "warning")) {
[17:42:46.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.946]                         if (muffled) 
[17:42:46.946]                           invokeRestart("muffleWarning")
[17:42:46.946]                       }
[17:42:46.946]                       else if (inherits(cond, "condition")) {
[17:42:46.946]                         if (!is.null(pattern)) {
[17:42:46.946]                           computeRestarts <- base::computeRestarts
[17:42:46.946]                           grepl <- base::grepl
[17:42:46.946]                           restarts <- computeRestarts(cond)
[17:42:46.946]                           for (restart in restarts) {
[17:42:46.946]                             name <- restart$name
[17:42:46.946]                             if (is.null(name)) 
[17:42:46.946]                               next
[17:42:46.946]                             if (!grepl(pattern, name)) 
[17:42:46.946]                               next
[17:42:46.946]                             invokeRestart(restart)
[17:42:46.946]                             muffled <- TRUE
[17:42:46.946]                             break
[17:42:46.946]                           }
[17:42:46.946]                         }
[17:42:46.946]                       }
[17:42:46.946]                       invisible(muffled)
[17:42:46.946]                     }
[17:42:46.946]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.946]                   }
[17:42:46.946]                 }
[17:42:46.946]                 else {
[17:42:46.946]                   if (TRUE) {
[17:42:46.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:46.946]                     {
[17:42:46.946]                       inherits <- base::inherits
[17:42:46.946]                       invokeRestart <- base::invokeRestart
[17:42:46.946]                       is.null <- base::is.null
[17:42:46.946]                       muffled <- FALSE
[17:42:46.946]                       if (inherits(cond, "message")) {
[17:42:46.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:46.946]                         if (muffled) 
[17:42:46.946]                           invokeRestart("muffleMessage")
[17:42:46.946]                       }
[17:42:46.946]                       else if (inherits(cond, "warning")) {
[17:42:46.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:46.946]                         if (muffled) 
[17:42:46.946]                           invokeRestart("muffleWarning")
[17:42:46.946]                       }
[17:42:46.946]                       else if (inherits(cond, "condition")) {
[17:42:46.946]                         if (!is.null(pattern)) {
[17:42:46.946]                           computeRestarts <- base::computeRestarts
[17:42:46.946]                           grepl <- base::grepl
[17:42:46.946]                           restarts <- computeRestarts(cond)
[17:42:46.946]                           for (restart in restarts) {
[17:42:46.946]                             name <- restart$name
[17:42:46.946]                             if (is.null(name)) 
[17:42:46.946]                               next
[17:42:46.946]                             if (!grepl(pattern, name)) 
[17:42:46.946]                               next
[17:42:46.946]                             invokeRestart(restart)
[17:42:46.946]                             muffled <- TRUE
[17:42:46.946]                             break
[17:42:46.946]                           }
[17:42:46.946]                         }
[17:42:46.946]                       }
[17:42:46.946]                       invisible(muffled)
[17:42:46.946]                     }
[17:42:46.946]                     muffleCondition(cond, pattern = "^muffle")
[17:42:46.946]                   }
[17:42:46.946]                 }
[17:42:46.946]             }
[17:42:46.946]         }))
[17:42:46.946]     }, error = function(ex) {
[17:42:46.946]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:46.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:46.946]                 ...future.rng), started = ...future.startTime, 
[17:42:46.946]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:46.946]             version = "1.8"), class = "FutureResult")
[17:42:46.946]     }, finally = {
[17:42:46.946]         if (!identical(...future.workdir, getwd())) 
[17:42:46.946]             setwd(...future.workdir)
[17:42:46.946]         {
[17:42:46.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:46.946]                 ...future.oldOptions$nwarnings <- NULL
[17:42:46.946]             }
[17:42:46.946]             base::options(...future.oldOptions)
[17:42:46.946]             if (.Platform$OS.type == "windows") {
[17:42:46.946]                 old_names <- names(...future.oldEnvVars)
[17:42:46.946]                 envs <- base::Sys.getenv()
[17:42:46.946]                 names <- names(envs)
[17:42:46.946]                 common <- intersect(names, old_names)
[17:42:46.946]                 added <- setdiff(names, old_names)
[17:42:46.946]                 removed <- setdiff(old_names, names)
[17:42:46.946]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:46.946]                   envs[common]]
[17:42:46.946]                 NAMES <- toupper(changed)
[17:42:46.946]                 args <- list()
[17:42:46.946]                 for (kk in seq_along(NAMES)) {
[17:42:46.946]                   name <- changed[[kk]]
[17:42:46.946]                   NAME <- NAMES[[kk]]
[17:42:46.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.946]                     next
[17:42:46.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.946]                 }
[17:42:46.946]                 NAMES <- toupper(added)
[17:42:46.946]                 for (kk in seq_along(NAMES)) {
[17:42:46.946]                   name <- added[[kk]]
[17:42:46.946]                   NAME <- NAMES[[kk]]
[17:42:46.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.946]                     next
[17:42:46.946]                   args[[name]] <- ""
[17:42:46.946]                 }
[17:42:46.946]                 NAMES <- toupper(removed)
[17:42:46.946]                 for (kk in seq_along(NAMES)) {
[17:42:46.946]                   name <- removed[[kk]]
[17:42:46.946]                   NAME <- NAMES[[kk]]
[17:42:46.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:46.946]                     next
[17:42:46.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:46.946]                 }
[17:42:46.946]                 if (length(args) > 0) 
[17:42:46.946]                   base::do.call(base::Sys.setenv, args = args)
[17:42:46.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:46.946]             }
[17:42:46.946]             else {
[17:42:46.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:46.946]             }
[17:42:46.946]             {
[17:42:46.946]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:46.946]                   0L) {
[17:42:46.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:46.946]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:46.946]                   base::options(opts)
[17:42:46.946]                 }
[17:42:46.946]                 {
[17:42:46.946]                   {
[17:42:46.946]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:46.946]                     NULL
[17:42:46.946]                   }
[17:42:46.946]                   options(future.plan = NULL)
[17:42:46.946]                   if (is.na(NA_character_)) 
[17:42:46.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:46.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:46.946]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:46.946]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:46.946]                     envir = parent.frame()) 
[17:42:46.946]                   {
[17:42:46.946]                     if (is.function(workers)) 
[17:42:46.946]                       workers <- workers()
[17:42:46.946]                     workers <- structure(as.integer(workers), 
[17:42:46.946]                       class = class(workers))
[17:42:46.946]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:46.946]                       workers >= 1)
[17:42:46.946]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:46.946]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:46.946]                     }
[17:42:46.946]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:46.946]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:46.946]                       envir = envir)
[17:42:46.946]                     if (!future$lazy) 
[17:42:46.946]                       future <- run(future)
[17:42:46.946]                     invisible(future)
[17:42:46.946]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:46.946]                 }
[17:42:46.946]             }
[17:42:46.946]         }
[17:42:46.946]     })
[17:42:46.946]     if (TRUE) {
[17:42:46.946]         base::sink(type = "output", split = FALSE)
[17:42:46.946]         if (TRUE) {
[17:42:46.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:46.946]         }
[17:42:46.946]         else {
[17:42:46.946]             ...future.result["stdout"] <- base::list(NULL)
[17:42:46.946]         }
[17:42:46.946]         base::close(...future.stdout)
[17:42:46.946]         ...future.stdout <- NULL
[17:42:46.946]     }
[17:42:46.946]     ...future.result$conditions <- ...future.conditions
[17:42:46.946]     ...future.result$finished <- base::Sys.time()
[17:42:46.946]     ...future.result
[17:42:46.946] }
[17:42:46.951] MultisessionFuture started
[17:42:46.952] - Launch lazy future ... done
[17:42:46.952] run() for ‘MultisessionFuture’ ... done
[17:42:46.952] result() for ClusterFuture ...
[17:42:46.952] receiveMessageFromWorker() for ClusterFuture ...
[17:42:46.952] - Validating connection of MultisessionFuture
[17:42:47.001] - received message: FutureResult
[17:42:47.001] - Received FutureResult
[17:42:47.001] - Erased future from FutureRegistry
[17:42:47.001] result() for ClusterFuture ...
[17:42:47.002] - result already collected: FutureResult
[17:42:47.002] result() for ClusterFuture ... done
[17:42:47.002] signalConditions() ...
[17:42:47.002]  - include = ‘immediateCondition’
[17:42:47.002]  - exclude = 
[17:42:47.002]  - resignal = FALSE
[17:42:47.002]  - Number of conditions: 1
[17:42:47.002] signalConditions() ... done
[17:42:47.002] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.002] result() for ClusterFuture ... done
[17:42:47.002] result() for ClusterFuture ...
[17:42:47.003] - result already collected: FutureResult
[17:42:47.003] result() for ClusterFuture ... done
[17:42:47.003] signalConditions() ...
[17:42:47.003]  - include = ‘immediateCondition’
[17:42:47.003]  - exclude = 
[17:42:47.003]  - resignal = FALSE
[17:42:47.003]  - Number of conditions: 1
[17:42:47.003] signalConditions() ... done
[17:42:47.003] Future state: ‘finished’
[17:42:47.003] result() for ClusterFuture ...
[17:42:47.004] - result already collected: FutureResult
[17:42:47.004] result() for ClusterFuture ... done
[17:42:47.004] signalConditions() ...
[17:42:47.004]  - include = ‘condition’
[17:42:47.004]  - exclude = ‘immediateCondition’
[17:42:47.004]  - resignal = TRUE
[17:42:47.004]  - Number of conditions: 1
[17:42:47.004]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:47.004] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:46"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.018] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.019] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.020] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.020] Searching for globals ... DONE
[17:42:47.020] Resolving globals: TRUE
[17:42:47.020] Resolving any globals that are futures ...
[17:42:47.020] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.020] Resolving any globals that are futures ... DONE
[17:42:47.021] Resolving futures part of globals (recursively) ...
[17:42:47.021] resolve() on list ...
[17:42:47.021]  recursive: 99
[17:42:47.021]  length: 1
[17:42:47.021]  elements: ‘ii’
[17:42:47.021]  length: 0 (resolved future 1)
[17:42:47.021] resolve() on list ... DONE
[17:42:47.022] - globals: [1] ‘ii’
[17:42:47.022] Resolving futures part of globals (recursively) ... DONE
[17:42:47.022] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:47.022] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:47.022] - globals: [1] ‘ii’
[17:42:47.022] 
[17:42:47.022] getGlobalsAndPackages() ... DONE
[17:42:47.023] run() for ‘Future’ ...
[17:42:47.023] - state: ‘created’
[17:42:47.023] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.037] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.038]   - Field: ‘node’
[17:42:47.038]   - Field: ‘label’
[17:42:47.038]   - Field: ‘local’
[17:42:47.038]   - Field: ‘owner’
[17:42:47.038]   - Field: ‘envir’
[17:42:47.038]   - Field: ‘workers’
[17:42:47.038]   - Field: ‘packages’
[17:42:47.038]   - Field: ‘gc’
[17:42:47.039]   - Field: ‘conditions’
[17:42:47.039]   - Field: ‘persistent’
[17:42:47.039]   - Field: ‘expr’
[17:42:47.039]   - Field: ‘uuid’
[17:42:47.039]   - Field: ‘seed’
[17:42:47.039]   - Field: ‘version’
[17:42:47.039]   - Field: ‘result’
[17:42:47.039]   - Field: ‘asynchronous’
[17:42:47.039]   - Field: ‘calls’
[17:42:47.039]   - Field: ‘globals’
[17:42:47.039]   - Field: ‘stdout’
[17:42:47.040]   - Field: ‘earlySignal’
[17:42:47.040]   - Field: ‘lazy’
[17:42:47.040]   - Field: ‘state’
[17:42:47.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.040] - Launch lazy future ...
[17:42:47.040] Packages needed by the future expression (n = 0): <none>
[17:42:47.040] Packages needed by future strategies (n = 0): <none>
[17:42:47.041] {
[17:42:47.041]     {
[17:42:47.041]         {
[17:42:47.041]             ...future.startTime <- base::Sys.time()
[17:42:47.041]             {
[17:42:47.041]                 {
[17:42:47.041]                   {
[17:42:47.041]                     {
[17:42:47.041]                       base::local({
[17:42:47.041]                         has_future <- base::requireNamespace("future", 
[17:42:47.041]                           quietly = TRUE)
[17:42:47.041]                         if (has_future) {
[17:42:47.041]                           ns <- base::getNamespace("future")
[17:42:47.041]                           version <- ns[[".package"]][["version"]]
[17:42:47.041]                           if (is.null(version)) 
[17:42:47.041]                             version <- utils::packageVersion("future")
[17:42:47.041]                         }
[17:42:47.041]                         else {
[17:42:47.041]                           version <- NULL
[17:42:47.041]                         }
[17:42:47.041]                         if (!has_future || version < "1.8.0") {
[17:42:47.041]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.041]                             "", base::R.version$version.string), 
[17:42:47.041]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.041]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.041]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.041]                               "release", "version")], collapse = " "), 
[17:42:47.041]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.041]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.041]                             info)
[17:42:47.041]                           info <- base::paste(info, collapse = "; ")
[17:42:47.041]                           if (!has_future) {
[17:42:47.041]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.041]                               info)
[17:42:47.041]                           }
[17:42:47.041]                           else {
[17:42:47.041]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.041]                               info, version)
[17:42:47.041]                           }
[17:42:47.041]                           base::stop(msg)
[17:42:47.041]                         }
[17:42:47.041]                       })
[17:42:47.041]                     }
[17:42:47.041]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.041]                     base::options(mc.cores = 1L)
[17:42:47.041]                   }
[17:42:47.041]                   options(future.plan = NULL)
[17:42:47.041]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.041]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.041]                 }
[17:42:47.041]                 ...future.workdir <- getwd()
[17:42:47.041]             }
[17:42:47.041]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.041]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.041]         }
[17:42:47.041]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.041]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.041]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.041]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.041]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.041]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.041]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.041]             base::names(...future.oldOptions))
[17:42:47.041]     }
[17:42:47.041]     if (FALSE) {
[17:42:47.041]     }
[17:42:47.041]     else {
[17:42:47.041]         if (TRUE) {
[17:42:47.041]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.041]                 open = "w")
[17:42:47.041]         }
[17:42:47.041]         else {
[17:42:47.041]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.041]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.041]         }
[17:42:47.041]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.041]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.041]             base::sink(type = "output", split = FALSE)
[17:42:47.041]             base::close(...future.stdout)
[17:42:47.041]         }, add = TRUE)
[17:42:47.041]     }
[17:42:47.041]     ...future.frame <- base::sys.nframe()
[17:42:47.041]     ...future.conditions <- base::list()
[17:42:47.041]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.041]     if (FALSE) {
[17:42:47.041]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.041]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.041]     }
[17:42:47.041]     ...future.result <- base::tryCatch({
[17:42:47.041]         base::withCallingHandlers({
[17:42:47.041]             ...future.value <- base::withVisible(base::local({
[17:42:47.041]                 ...future.makeSendCondition <- local({
[17:42:47.041]                   sendCondition <- NULL
[17:42:47.041]                   function(frame = 1L) {
[17:42:47.041]                     if (is.function(sendCondition)) 
[17:42:47.041]                       return(sendCondition)
[17:42:47.041]                     ns <- getNamespace("parallel")
[17:42:47.041]                     if (exists("sendData", mode = "function", 
[17:42:47.041]                       envir = ns)) {
[17:42:47.041]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.041]                         envir = ns)
[17:42:47.041]                       envir <- sys.frame(frame)
[17:42:47.041]                       master <- NULL
[17:42:47.041]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.041]                         !identical(envir, emptyenv())) {
[17:42:47.041]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.041]                           inherits = FALSE)) {
[17:42:47.041]                           master <- get("master", mode = "list", 
[17:42:47.041]                             envir = envir, inherits = FALSE)
[17:42:47.041]                           if (inherits(master, c("SOCKnode", 
[17:42:47.041]                             "SOCK0node"))) {
[17:42:47.041]                             sendCondition <<- function(cond) {
[17:42:47.041]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.041]                                 success = TRUE)
[17:42:47.041]                               parallel_sendData(master, data)
[17:42:47.041]                             }
[17:42:47.041]                             return(sendCondition)
[17:42:47.041]                           }
[17:42:47.041]                         }
[17:42:47.041]                         frame <- frame + 1L
[17:42:47.041]                         envir <- sys.frame(frame)
[17:42:47.041]                       }
[17:42:47.041]                     }
[17:42:47.041]                     sendCondition <<- function(cond) NULL
[17:42:47.041]                   }
[17:42:47.041]                 })
[17:42:47.041]                 withCallingHandlers({
[17:42:47.041]                   {
[17:42:47.041]                     b <- a * ii
[17:42:47.041]                     a <- 0
[17:42:47.041]                     b
[17:42:47.041]                   }
[17:42:47.041]                 }, immediateCondition = function(cond) {
[17:42:47.041]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.041]                   sendCondition(cond)
[17:42:47.041]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.041]                   {
[17:42:47.041]                     inherits <- base::inherits
[17:42:47.041]                     invokeRestart <- base::invokeRestart
[17:42:47.041]                     is.null <- base::is.null
[17:42:47.041]                     muffled <- FALSE
[17:42:47.041]                     if (inherits(cond, "message")) {
[17:42:47.041]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.041]                       if (muffled) 
[17:42:47.041]                         invokeRestart("muffleMessage")
[17:42:47.041]                     }
[17:42:47.041]                     else if (inherits(cond, "warning")) {
[17:42:47.041]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.041]                       if (muffled) 
[17:42:47.041]                         invokeRestart("muffleWarning")
[17:42:47.041]                     }
[17:42:47.041]                     else if (inherits(cond, "condition")) {
[17:42:47.041]                       if (!is.null(pattern)) {
[17:42:47.041]                         computeRestarts <- base::computeRestarts
[17:42:47.041]                         grepl <- base::grepl
[17:42:47.041]                         restarts <- computeRestarts(cond)
[17:42:47.041]                         for (restart in restarts) {
[17:42:47.041]                           name <- restart$name
[17:42:47.041]                           if (is.null(name)) 
[17:42:47.041]                             next
[17:42:47.041]                           if (!grepl(pattern, name)) 
[17:42:47.041]                             next
[17:42:47.041]                           invokeRestart(restart)
[17:42:47.041]                           muffled <- TRUE
[17:42:47.041]                           break
[17:42:47.041]                         }
[17:42:47.041]                       }
[17:42:47.041]                     }
[17:42:47.041]                     invisible(muffled)
[17:42:47.041]                   }
[17:42:47.041]                   muffleCondition(cond)
[17:42:47.041]                 })
[17:42:47.041]             }))
[17:42:47.041]             future::FutureResult(value = ...future.value$value, 
[17:42:47.041]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.041]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.041]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.041]                     ...future.globalenv.names))
[17:42:47.041]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.041]         }, condition = base::local({
[17:42:47.041]             c <- base::c
[17:42:47.041]             inherits <- base::inherits
[17:42:47.041]             invokeRestart <- base::invokeRestart
[17:42:47.041]             length <- base::length
[17:42:47.041]             list <- base::list
[17:42:47.041]             seq.int <- base::seq.int
[17:42:47.041]             signalCondition <- base::signalCondition
[17:42:47.041]             sys.calls <- base::sys.calls
[17:42:47.041]             `[[` <- base::`[[`
[17:42:47.041]             `+` <- base::`+`
[17:42:47.041]             `<<-` <- base::`<<-`
[17:42:47.041]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.041]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.041]                   3L)]
[17:42:47.041]             }
[17:42:47.041]             function(cond) {
[17:42:47.041]                 is_error <- inherits(cond, "error")
[17:42:47.041]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.041]                   NULL)
[17:42:47.041]                 if (is_error) {
[17:42:47.041]                   sessionInformation <- function() {
[17:42:47.041]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.041]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.041]                       search = base::search(), system = base::Sys.info())
[17:42:47.041]                   }
[17:42:47.041]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.041]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.041]                     cond$call), session = sessionInformation(), 
[17:42:47.041]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.041]                   signalCondition(cond)
[17:42:47.041]                 }
[17:42:47.041]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.041]                 "immediateCondition"))) {
[17:42:47.041]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.041]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.041]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.041]                   if (TRUE && !signal) {
[17:42:47.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.041]                     {
[17:42:47.041]                       inherits <- base::inherits
[17:42:47.041]                       invokeRestart <- base::invokeRestart
[17:42:47.041]                       is.null <- base::is.null
[17:42:47.041]                       muffled <- FALSE
[17:42:47.041]                       if (inherits(cond, "message")) {
[17:42:47.041]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.041]                         if (muffled) 
[17:42:47.041]                           invokeRestart("muffleMessage")
[17:42:47.041]                       }
[17:42:47.041]                       else if (inherits(cond, "warning")) {
[17:42:47.041]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.041]                         if (muffled) 
[17:42:47.041]                           invokeRestart("muffleWarning")
[17:42:47.041]                       }
[17:42:47.041]                       else if (inherits(cond, "condition")) {
[17:42:47.041]                         if (!is.null(pattern)) {
[17:42:47.041]                           computeRestarts <- base::computeRestarts
[17:42:47.041]                           grepl <- base::grepl
[17:42:47.041]                           restarts <- computeRestarts(cond)
[17:42:47.041]                           for (restart in restarts) {
[17:42:47.041]                             name <- restart$name
[17:42:47.041]                             if (is.null(name)) 
[17:42:47.041]                               next
[17:42:47.041]                             if (!grepl(pattern, name)) 
[17:42:47.041]                               next
[17:42:47.041]                             invokeRestart(restart)
[17:42:47.041]                             muffled <- TRUE
[17:42:47.041]                             break
[17:42:47.041]                           }
[17:42:47.041]                         }
[17:42:47.041]                       }
[17:42:47.041]                       invisible(muffled)
[17:42:47.041]                     }
[17:42:47.041]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.041]                   }
[17:42:47.041]                 }
[17:42:47.041]                 else {
[17:42:47.041]                   if (TRUE) {
[17:42:47.041]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.041]                     {
[17:42:47.041]                       inherits <- base::inherits
[17:42:47.041]                       invokeRestart <- base::invokeRestart
[17:42:47.041]                       is.null <- base::is.null
[17:42:47.041]                       muffled <- FALSE
[17:42:47.041]                       if (inherits(cond, "message")) {
[17:42:47.041]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.041]                         if (muffled) 
[17:42:47.041]                           invokeRestart("muffleMessage")
[17:42:47.041]                       }
[17:42:47.041]                       else if (inherits(cond, "warning")) {
[17:42:47.041]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.041]                         if (muffled) 
[17:42:47.041]                           invokeRestart("muffleWarning")
[17:42:47.041]                       }
[17:42:47.041]                       else if (inherits(cond, "condition")) {
[17:42:47.041]                         if (!is.null(pattern)) {
[17:42:47.041]                           computeRestarts <- base::computeRestarts
[17:42:47.041]                           grepl <- base::grepl
[17:42:47.041]                           restarts <- computeRestarts(cond)
[17:42:47.041]                           for (restart in restarts) {
[17:42:47.041]                             name <- restart$name
[17:42:47.041]                             if (is.null(name)) 
[17:42:47.041]                               next
[17:42:47.041]                             if (!grepl(pattern, name)) 
[17:42:47.041]                               next
[17:42:47.041]                             invokeRestart(restart)
[17:42:47.041]                             muffled <- TRUE
[17:42:47.041]                             break
[17:42:47.041]                           }
[17:42:47.041]                         }
[17:42:47.041]                       }
[17:42:47.041]                       invisible(muffled)
[17:42:47.041]                     }
[17:42:47.041]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.041]                   }
[17:42:47.041]                 }
[17:42:47.041]             }
[17:42:47.041]         }))
[17:42:47.041]     }, error = function(ex) {
[17:42:47.041]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.041]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.041]                 ...future.rng), started = ...future.startTime, 
[17:42:47.041]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.041]             version = "1.8"), class = "FutureResult")
[17:42:47.041]     }, finally = {
[17:42:47.041]         if (!identical(...future.workdir, getwd())) 
[17:42:47.041]             setwd(...future.workdir)
[17:42:47.041]         {
[17:42:47.041]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.041]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.041]             }
[17:42:47.041]             base::options(...future.oldOptions)
[17:42:47.041]             if (.Platform$OS.type == "windows") {
[17:42:47.041]                 old_names <- names(...future.oldEnvVars)
[17:42:47.041]                 envs <- base::Sys.getenv()
[17:42:47.041]                 names <- names(envs)
[17:42:47.041]                 common <- intersect(names, old_names)
[17:42:47.041]                 added <- setdiff(names, old_names)
[17:42:47.041]                 removed <- setdiff(old_names, names)
[17:42:47.041]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.041]                   envs[common]]
[17:42:47.041]                 NAMES <- toupper(changed)
[17:42:47.041]                 args <- list()
[17:42:47.041]                 for (kk in seq_along(NAMES)) {
[17:42:47.041]                   name <- changed[[kk]]
[17:42:47.041]                   NAME <- NAMES[[kk]]
[17:42:47.041]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.041]                     next
[17:42:47.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.041]                 }
[17:42:47.041]                 NAMES <- toupper(added)
[17:42:47.041]                 for (kk in seq_along(NAMES)) {
[17:42:47.041]                   name <- added[[kk]]
[17:42:47.041]                   NAME <- NAMES[[kk]]
[17:42:47.041]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.041]                     next
[17:42:47.041]                   args[[name]] <- ""
[17:42:47.041]                 }
[17:42:47.041]                 NAMES <- toupper(removed)
[17:42:47.041]                 for (kk in seq_along(NAMES)) {
[17:42:47.041]                   name <- removed[[kk]]
[17:42:47.041]                   NAME <- NAMES[[kk]]
[17:42:47.041]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.041]                     next
[17:42:47.041]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.041]                 }
[17:42:47.041]                 if (length(args) > 0) 
[17:42:47.041]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.041]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.041]             }
[17:42:47.041]             else {
[17:42:47.041]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.041]             }
[17:42:47.041]             {
[17:42:47.041]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.041]                   0L) {
[17:42:47.041]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.041]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.041]                   base::options(opts)
[17:42:47.041]                 }
[17:42:47.041]                 {
[17:42:47.041]                   {
[17:42:47.041]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.041]                     NULL
[17:42:47.041]                   }
[17:42:47.041]                   options(future.plan = NULL)
[17:42:47.041]                   if (is.na(NA_character_)) 
[17:42:47.041]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.041]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.041]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.041]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.041]                     envir = parent.frame()) 
[17:42:47.041]                   {
[17:42:47.041]                     if (is.function(workers)) 
[17:42:47.041]                       workers <- workers()
[17:42:47.041]                     workers <- structure(as.integer(workers), 
[17:42:47.041]                       class = class(workers))
[17:42:47.041]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.041]                       workers >= 1)
[17:42:47.041]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.041]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.041]                     }
[17:42:47.041]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.041]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.041]                       envir = envir)
[17:42:47.041]                     if (!future$lazy) 
[17:42:47.041]                       future <- run(future)
[17:42:47.041]                     invisible(future)
[17:42:47.041]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.041]                 }
[17:42:47.041]             }
[17:42:47.041]         }
[17:42:47.041]     })
[17:42:47.041]     if (TRUE) {
[17:42:47.041]         base::sink(type = "output", split = FALSE)
[17:42:47.041]         if (TRUE) {
[17:42:47.041]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.041]         }
[17:42:47.041]         else {
[17:42:47.041]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.041]         }
[17:42:47.041]         base::close(...future.stdout)
[17:42:47.041]         ...future.stdout <- NULL
[17:42:47.041]     }
[17:42:47.041]     ...future.result$conditions <- ...future.conditions
[17:42:47.041]     ...future.result$finished <- base::Sys.time()
[17:42:47.041]     ...future.result
[17:42:47.041] }
[17:42:47.044] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:47.044] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:47.044] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:47.044] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:47.045] MultisessionFuture started
[17:42:47.045] - Launch lazy future ... done
[17:42:47.045] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.045] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.046] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.047] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.047] Searching for globals ... DONE
[17:42:47.047] Resolving globals: TRUE
[17:42:47.047] Resolving any globals that are futures ...
[17:42:47.047] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.048] Resolving any globals that are futures ... DONE
[17:42:47.048] Resolving futures part of globals (recursively) ...
[17:42:47.048] resolve() on list ...
[17:42:47.048]  recursive: 99
[17:42:47.048]  length: 1
[17:42:47.048]  elements: ‘ii’
[17:42:47.048]  length: 0 (resolved future 1)
[17:42:47.049] resolve() on list ... DONE
[17:42:47.049] - globals: [1] ‘ii’
[17:42:47.049] Resolving futures part of globals (recursively) ... DONE
[17:42:47.049] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:47.049] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:47.049] - globals: [1] ‘ii’
[17:42:47.049] 
[17:42:47.050] getGlobalsAndPackages() ... DONE
[17:42:47.050] run() for ‘Future’ ...
[17:42:47.050] - state: ‘created’
[17:42:47.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.064] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.064] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.065]   - Field: ‘node’
[17:42:47.065]   - Field: ‘label’
[17:42:47.065]   - Field: ‘local’
[17:42:47.065]   - Field: ‘owner’
[17:42:47.065]   - Field: ‘envir’
[17:42:47.065]   - Field: ‘workers’
[17:42:47.065]   - Field: ‘packages’
[17:42:47.065]   - Field: ‘gc’
[17:42:47.065]   - Field: ‘conditions’
[17:42:47.065]   - Field: ‘persistent’
[17:42:47.066]   - Field: ‘expr’
[17:42:47.066]   - Field: ‘uuid’
[17:42:47.066]   - Field: ‘seed’
[17:42:47.066]   - Field: ‘version’
[17:42:47.066]   - Field: ‘result’
[17:42:47.066]   - Field: ‘asynchronous’
[17:42:47.066]   - Field: ‘calls’
[17:42:47.066]   - Field: ‘globals’
[17:42:47.066]   - Field: ‘stdout’
[17:42:47.066]   - Field: ‘earlySignal’
[17:42:47.066]   - Field: ‘lazy’
[17:42:47.067]   - Field: ‘state’
[17:42:47.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.067] - Launch lazy future ...
[17:42:47.067] Packages needed by the future expression (n = 0): <none>
[17:42:47.067] Packages needed by future strategies (n = 0): <none>
[17:42:47.068] {
[17:42:47.068]     {
[17:42:47.068]         {
[17:42:47.068]             ...future.startTime <- base::Sys.time()
[17:42:47.068]             {
[17:42:47.068]                 {
[17:42:47.068]                   {
[17:42:47.068]                     {
[17:42:47.068]                       base::local({
[17:42:47.068]                         has_future <- base::requireNamespace("future", 
[17:42:47.068]                           quietly = TRUE)
[17:42:47.068]                         if (has_future) {
[17:42:47.068]                           ns <- base::getNamespace("future")
[17:42:47.068]                           version <- ns[[".package"]][["version"]]
[17:42:47.068]                           if (is.null(version)) 
[17:42:47.068]                             version <- utils::packageVersion("future")
[17:42:47.068]                         }
[17:42:47.068]                         else {
[17:42:47.068]                           version <- NULL
[17:42:47.068]                         }
[17:42:47.068]                         if (!has_future || version < "1.8.0") {
[17:42:47.068]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.068]                             "", base::R.version$version.string), 
[17:42:47.068]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.068]                               "release", "version")], collapse = " "), 
[17:42:47.068]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.068]                             info)
[17:42:47.068]                           info <- base::paste(info, collapse = "; ")
[17:42:47.068]                           if (!has_future) {
[17:42:47.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.068]                               info)
[17:42:47.068]                           }
[17:42:47.068]                           else {
[17:42:47.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.068]                               info, version)
[17:42:47.068]                           }
[17:42:47.068]                           base::stop(msg)
[17:42:47.068]                         }
[17:42:47.068]                       })
[17:42:47.068]                     }
[17:42:47.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.068]                     base::options(mc.cores = 1L)
[17:42:47.068]                   }
[17:42:47.068]                   options(future.plan = NULL)
[17:42:47.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.068]                 }
[17:42:47.068]                 ...future.workdir <- getwd()
[17:42:47.068]             }
[17:42:47.068]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.068]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.068]         }
[17:42:47.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.068]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.068]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.068]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.068]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.068]             base::names(...future.oldOptions))
[17:42:47.068]     }
[17:42:47.068]     if (FALSE) {
[17:42:47.068]     }
[17:42:47.068]     else {
[17:42:47.068]         if (TRUE) {
[17:42:47.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.068]                 open = "w")
[17:42:47.068]         }
[17:42:47.068]         else {
[17:42:47.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.068]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.068]         }
[17:42:47.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.068]             base::sink(type = "output", split = FALSE)
[17:42:47.068]             base::close(...future.stdout)
[17:42:47.068]         }, add = TRUE)
[17:42:47.068]     }
[17:42:47.068]     ...future.frame <- base::sys.nframe()
[17:42:47.068]     ...future.conditions <- base::list()
[17:42:47.068]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.068]     if (FALSE) {
[17:42:47.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.068]     }
[17:42:47.068]     ...future.result <- base::tryCatch({
[17:42:47.068]         base::withCallingHandlers({
[17:42:47.068]             ...future.value <- base::withVisible(base::local({
[17:42:47.068]                 ...future.makeSendCondition <- local({
[17:42:47.068]                   sendCondition <- NULL
[17:42:47.068]                   function(frame = 1L) {
[17:42:47.068]                     if (is.function(sendCondition)) 
[17:42:47.068]                       return(sendCondition)
[17:42:47.068]                     ns <- getNamespace("parallel")
[17:42:47.068]                     if (exists("sendData", mode = "function", 
[17:42:47.068]                       envir = ns)) {
[17:42:47.068]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.068]                         envir = ns)
[17:42:47.068]                       envir <- sys.frame(frame)
[17:42:47.068]                       master <- NULL
[17:42:47.068]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.068]                         !identical(envir, emptyenv())) {
[17:42:47.068]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.068]                           inherits = FALSE)) {
[17:42:47.068]                           master <- get("master", mode = "list", 
[17:42:47.068]                             envir = envir, inherits = FALSE)
[17:42:47.068]                           if (inherits(master, c("SOCKnode", 
[17:42:47.068]                             "SOCK0node"))) {
[17:42:47.068]                             sendCondition <<- function(cond) {
[17:42:47.068]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.068]                                 success = TRUE)
[17:42:47.068]                               parallel_sendData(master, data)
[17:42:47.068]                             }
[17:42:47.068]                             return(sendCondition)
[17:42:47.068]                           }
[17:42:47.068]                         }
[17:42:47.068]                         frame <- frame + 1L
[17:42:47.068]                         envir <- sys.frame(frame)
[17:42:47.068]                       }
[17:42:47.068]                     }
[17:42:47.068]                     sendCondition <<- function(cond) NULL
[17:42:47.068]                   }
[17:42:47.068]                 })
[17:42:47.068]                 withCallingHandlers({
[17:42:47.068]                   {
[17:42:47.068]                     b <- a * ii
[17:42:47.068]                     a <- 0
[17:42:47.068]                     b
[17:42:47.068]                   }
[17:42:47.068]                 }, immediateCondition = function(cond) {
[17:42:47.068]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.068]                   sendCondition(cond)
[17:42:47.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.068]                   {
[17:42:47.068]                     inherits <- base::inherits
[17:42:47.068]                     invokeRestart <- base::invokeRestart
[17:42:47.068]                     is.null <- base::is.null
[17:42:47.068]                     muffled <- FALSE
[17:42:47.068]                     if (inherits(cond, "message")) {
[17:42:47.068]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.068]                       if (muffled) 
[17:42:47.068]                         invokeRestart("muffleMessage")
[17:42:47.068]                     }
[17:42:47.068]                     else if (inherits(cond, "warning")) {
[17:42:47.068]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.068]                       if (muffled) 
[17:42:47.068]                         invokeRestart("muffleWarning")
[17:42:47.068]                     }
[17:42:47.068]                     else if (inherits(cond, "condition")) {
[17:42:47.068]                       if (!is.null(pattern)) {
[17:42:47.068]                         computeRestarts <- base::computeRestarts
[17:42:47.068]                         grepl <- base::grepl
[17:42:47.068]                         restarts <- computeRestarts(cond)
[17:42:47.068]                         for (restart in restarts) {
[17:42:47.068]                           name <- restart$name
[17:42:47.068]                           if (is.null(name)) 
[17:42:47.068]                             next
[17:42:47.068]                           if (!grepl(pattern, name)) 
[17:42:47.068]                             next
[17:42:47.068]                           invokeRestart(restart)
[17:42:47.068]                           muffled <- TRUE
[17:42:47.068]                           break
[17:42:47.068]                         }
[17:42:47.068]                       }
[17:42:47.068]                     }
[17:42:47.068]                     invisible(muffled)
[17:42:47.068]                   }
[17:42:47.068]                   muffleCondition(cond)
[17:42:47.068]                 })
[17:42:47.068]             }))
[17:42:47.068]             future::FutureResult(value = ...future.value$value, 
[17:42:47.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.068]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.068]                     ...future.globalenv.names))
[17:42:47.068]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.068]         }, condition = base::local({
[17:42:47.068]             c <- base::c
[17:42:47.068]             inherits <- base::inherits
[17:42:47.068]             invokeRestart <- base::invokeRestart
[17:42:47.068]             length <- base::length
[17:42:47.068]             list <- base::list
[17:42:47.068]             seq.int <- base::seq.int
[17:42:47.068]             signalCondition <- base::signalCondition
[17:42:47.068]             sys.calls <- base::sys.calls
[17:42:47.068]             `[[` <- base::`[[`
[17:42:47.068]             `+` <- base::`+`
[17:42:47.068]             `<<-` <- base::`<<-`
[17:42:47.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.068]                   3L)]
[17:42:47.068]             }
[17:42:47.068]             function(cond) {
[17:42:47.068]                 is_error <- inherits(cond, "error")
[17:42:47.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.068]                   NULL)
[17:42:47.068]                 if (is_error) {
[17:42:47.068]                   sessionInformation <- function() {
[17:42:47.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.068]                       search = base::search(), system = base::Sys.info())
[17:42:47.068]                   }
[17:42:47.068]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.068]                     cond$call), session = sessionInformation(), 
[17:42:47.068]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.068]                   signalCondition(cond)
[17:42:47.068]                 }
[17:42:47.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.068]                 "immediateCondition"))) {
[17:42:47.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.068]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.068]                   if (TRUE && !signal) {
[17:42:47.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.068]                     {
[17:42:47.068]                       inherits <- base::inherits
[17:42:47.068]                       invokeRestart <- base::invokeRestart
[17:42:47.068]                       is.null <- base::is.null
[17:42:47.068]                       muffled <- FALSE
[17:42:47.068]                       if (inherits(cond, "message")) {
[17:42:47.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.068]                         if (muffled) 
[17:42:47.068]                           invokeRestart("muffleMessage")
[17:42:47.068]                       }
[17:42:47.068]                       else if (inherits(cond, "warning")) {
[17:42:47.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.068]                         if (muffled) 
[17:42:47.068]                           invokeRestart("muffleWarning")
[17:42:47.068]                       }
[17:42:47.068]                       else if (inherits(cond, "condition")) {
[17:42:47.068]                         if (!is.null(pattern)) {
[17:42:47.068]                           computeRestarts <- base::computeRestarts
[17:42:47.068]                           grepl <- base::grepl
[17:42:47.068]                           restarts <- computeRestarts(cond)
[17:42:47.068]                           for (restart in restarts) {
[17:42:47.068]                             name <- restart$name
[17:42:47.068]                             if (is.null(name)) 
[17:42:47.068]                               next
[17:42:47.068]                             if (!grepl(pattern, name)) 
[17:42:47.068]                               next
[17:42:47.068]                             invokeRestart(restart)
[17:42:47.068]                             muffled <- TRUE
[17:42:47.068]                             break
[17:42:47.068]                           }
[17:42:47.068]                         }
[17:42:47.068]                       }
[17:42:47.068]                       invisible(muffled)
[17:42:47.068]                     }
[17:42:47.068]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.068]                   }
[17:42:47.068]                 }
[17:42:47.068]                 else {
[17:42:47.068]                   if (TRUE) {
[17:42:47.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.068]                     {
[17:42:47.068]                       inherits <- base::inherits
[17:42:47.068]                       invokeRestart <- base::invokeRestart
[17:42:47.068]                       is.null <- base::is.null
[17:42:47.068]                       muffled <- FALSE
[17:42:47.068]                       if (inherits(cond, "message")) {
[17:42:47.068]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.068]                         if (muffled) 
[17:42:47.068]                           invokeRestart("muffleMessage")
[17:42:47.068]                       }
[17:42:47.068]                       else if (inherits(cond, "warning")) {
[17:42:47.068]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.068]                         if (muffled) 
[17:42:47.068]                           invokeRestart("muffleWarning")
[17:42:47.068]                       }
[17:42:47.068]                       else if (inherits(cond, "condition")) {
[17:42:47.068]                         if (!is.null(pattern)) {
[17:42:47.068]                           computeRestarts <- base::computeRestarts
[17:42:47.068]                           grepl <- base::grepl
[17:42:47.068]                           restarts <- computeRestarts(cond)
[17:42:47.068]                           for (restart in restarts) {
[17:42:47.068]                             name <- restart$name
[17:42:47.068]                             if (is.null(name)) 
[17:42:47.068]                               next
[17:42:47.068]                             if (!grepl(pattern, name)) 
[17:42:47.068]                               next
[17:42:47.068]                             invokeRestart(restart)
[17:42:47.068]                             muffled <- TRUE
[17:42:47.068]                             break
[17:42:47.068]                           }
[17:42:47.068]                         }
[17:42:47.068]                       }
[17:42:47.068]                       invisible(muffled)
[17:42:47.068]                     }
[17:42:47.068]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.068]                   }
[17:42:47.068]                 }
[17:42:47.068]             }
[17:42:47.068]         }))
[17:42:47.068]     }, error = function(ex) {
[17:42:47.068]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.068]                 ...future.rng), started = ...future.startTime, 
[17:42:47.068]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.068]             version = "1.8"), class = "FutureResult")
[17:42:47.068]     }, finally = {
[17:42:47.068]         if (!identical(...future.workdir, getwd())) 
[17:42:47.068]             setwd(...future.workdir)
[17:42:47.068]         {
[17:42:47.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.068]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.068]             }
[17:42:47.068]             base::options(...future.oldOptions)
[17:42:47.068]             if (.Platform$OS.type == "windows") {
[17:42:47.068]                 old_names <- names(...future.oldEnvVars)
[17:42:47.068]                 envs <- base::Sys.getenv()
[17:42:47.068]                 names <- names(envs)
[17:42:47.068]                 common <- intersect(names, old_names)
[17:42:47.068]                 added <- setdiff(names, old_names)
[17:42:47.068]                 removed <- setdiff(old_names, names)
[17:42:47.068]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.068]                   envs[common]]
[17:42:47.068]                 NAMES <- toupper(changed)
[17:42:47.068]                 args <- list()
[17:42:47.068]                 for (kk in seq_along(NAMES)) {
[17:42:47.068]                   name <- changed[[kk]]
[17:42:47.068]                   NAME <- NAMES[[kk]]
[17:42:47.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.068]                     next
[17:42:47.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.068]                 }
[17:42:47.068]                 NAMES <- toupper(added)
[17:42:47.068]                 for (kk in seq_along(NAMES)) {
[17:42:47.068]                   name <- added[[kk]]
[17:42:47.068]                   NAME <- NAMES[[kk]]
[17:42:47.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.068]                     next
[17:42:47.068]                   args[[name]] <- ""
[17:42:47.068]                 }
[17:42:47.068]                 NAMES <- toupper(removed)
[17:42:47.068]                 for (kk in seq_along(NAMES)) {
[17:42:47.068]                   name <- removed[[kk]]
[17:42:47.068]                   NAME <- NAMES[[kk]]
[17:42:47.068]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.068]                     next
[17:42:47.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.068]                 }
[17:42:47.068]                 if (length(args) > 0) 
[17:42:47.068]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.068]             }
[17:42:47.068]             else {
[17:42:47.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.068]             }
[17:42:47.068]             {
[17:42:47.068]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.068]                   0L) {
[17:42:47.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.068]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.068]                   base::options(opts)
[17:42:47.068]                 }
[17:42:47.068]                 {
[17:42:47.068]                   {
[17:42:47.068]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.068]                     NULL
[17:42:47.068]                   }
[17:42:47.068]                   options(future.plan = NULL)
[17:42:47.068]                   if (is.na(NA_character_)) 
[17:42:47.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.068]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.068]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.068]                     envir = parent.frame()) 
[17:42:47.068]                   {
[17:42:47.068]                     if (is.function(workers)) 
[17:42:47.068]                       workers <- workers()
[17:42:47.068]                     workers <- structure(as.integer(workers), 
[17:42:47.068]                       class = class(workers))
[17:42:47.068]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.068]                       workers >= 1)
[17:42:47.068]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.068]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.068]                     }
[17:42:47.068]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.068]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.068]                       envir = envir)
[17:42:47.068]                     if (!future$lazy) 
[17:42:47.068]                       future <- run(future)
[17:42:47.068]                     invisible(future)
[17:42:47.068]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.068]                 }
[17:42:47.068]             }
[17:42:47.068]         }
[17:42:47.068]     })
[17:42:47.068]     if (TRUE) {
[17:42:47.068]         base::sink(type = "output", split = FALSE)
[17:42:47.068]         if (TRUE) {
[17:42:47.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.068]         }
[17:42:47.068]         else {
[17:42:47.068]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.068]         }
[17:42:47.068]         base::close(...future.stdout)
[17:42:47.068]         ...future.stdout <- NULL
[17:42:47.068]     }
[17:42:47.068]     ...future.result$conditions <- ...future.conditions
[17:42:47.068]     ...future.result$finished <- base::Sys.time()
[17:42:47.068]     ...future.result
[17:42:47.068] }
[17:42:47.143] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:42:47.143] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:42:47.144] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:42:47.144] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:42:47.144] MultisessionFuture started
[17:42:47.144] - Launch lazy future ... done
[17:42:47.144] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.145] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.145] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.147] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.147] Searching for globals ... DONE
[17:42:47.147] Resolving globals: TRUE
[17:42:47.147] Resolving any globals that are futures ...
[17:42:47.147] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.147] Resolving any globals that are futures ... DONE
[17:42:47.148] Resolving futures part of globals (recursively) ...
[17:42:47.148] resolve() on list ...
[17:42:47.148]  recursive: 99
[17:42:47.148]  length: 1
[17:42:47.148]  elements: ‘ii’
[17:42:47.148]  length: 0 (resolved future 1)
[17:42:47.148] resolve() on list ... DONE
[17:42:47.148] - globals: [1] ‘ii’
[17:42:47.148] Resolving futures part of globals (recursively) ... DONE
[17:42:47.149] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:47.149] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:47.149] - globals: [1] ‘ii’
[17:42:47.149] 
[17:42:47.149] getGlobalsAndPackages() ... DONE
[17:42:47.150] run() for ‘Future’ ...
[17:42:47.150] - state: ‘created’
[17:42:47.150] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.164] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.165]   - Field: ‘node’
[17:42:47.165]   - Field: ‘label’
[17:42:47.165]   - Field: ‘local’
[17:42:47.165]   - Field: ‘owner’
[17:42:47.165]   - Field: ‘envir’
[17:42:47.165]   - Field: ‘workers’
[17:42:47.165]   - Field: ‘packages’
[17:42:47.165]   - Field: ‘gc’
[17:42:47.165]   - Field: ‘conditions’
[17:42:47.165]   - Field: ‘persistent’
[17:42:47.166]   - Field: ‘expr’
[17:42:47.166]   - Field: ‘uuid’
[17:42:47.166]   - Field: ‘seed’
[17:42:47.166]   - Field: ‘version’
[17:42:47.166]   - Field: ‘result’
[17:42:47.166]   - Field: ‘asynchronous’
[17:42:47.166]   - Field: ‘calls’
[17:42:47.166]   - Field: ‘globals’
[17:42:47.166]   - Field: ‘stdout’
[17:42:47.166]   - Field: ‘earlySignal’
[17:42:47.166]   - Field: ‘lazy’
[17:42:47.167]   - Field: ‘state’
[17:42:47.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.167] - Launch lazy future ...
[17:42:47.167] Packages needed by the future expression (n = 0): <none>
[17:42:47.167] Packages needed by future strategies (n = 0): <none>
[17:42:47.168] {
[17:42:47.168]     {
[17:42:47.168]         {
[17:42:47.168]             ...future.startTime <- base::Sys.time()
[17:42:47.168]             {
[17:42:47.168]                 {
[17:42:47.168]                   {
[17:42:47.168]                     {
[17:42:47.168]                       base::local({
[17:42:47.168]                         has_future <- base::requireNamespace("future", 
[17:42:47.168]                           quietly = TRUE)
[17:42:47.168]                         if (has_future) {
[17:42:47.168]                           ns <- base::getNamespace("future")
[17:42:47.168]                           version <- ns[[".package"]][["version"]]
[17:42:47.168]                           if (is.null(version)) 
[17:42:47.168]                             version <- utils::packageVersion("future")
[17:42:47.168]                         }
[17:42:47.168]                         else {
[17:42:47.168]                           version <- NULL
[17:42:47.168]                         }
[17:42:47.168]                         if (!has_future || version < "1.8.0") {
[17:42:47.168]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.168]                             "", base::R.version$version.string), 
[17:42:47.168]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.168]                               "release", "version")], collapse = " "), 
[17:42:47.168]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.168]                             info)
[17:42:47.168]                           info <- base::paste(info, collapse = "; ")
[17:42:47.168]                           if (!has_future) {
[17:42:47.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.168]                               info)
[17:42:47.168]                           }
[17:42:47.168]                           else {
[17:42:47.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.168]                               info, version)
[17:42:47.168]                           }
[17:42:47.168]                           base::stop(msg)
[17:42:47.168]                         }
[17:42:47.168]                       })
[17:42:47.168]                     }
[17:42:47.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.168]                     base::options(mc.cores = 1L)
[17:42:47.168]                   }
[17:42:47.168]                   options(future.plan = NULL)
[17:42:47.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.168]                 }
[17:42:47.168]                 ...future.workdir <- getwd()
[17:42:47.168]             }
[17:42:47.168]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.168]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.168]         }
[17:42:47.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.168]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.168]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.168]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.168]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.168]             base::names(...future.oldOptions))
[17:42:47.168]     }
[17:42:47.168]     if (FALSE) {
[17:42:47.168]     }
[17:42:47.168]     else {
[17:42:47.168]         if (TRUE) {
[17:42:47.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.168]                 open = "w")
[17:42:47.168]         }
[17:42:47.168]         else {
[17:42:47.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.168]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.168]         }
[17:42:47.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.168]             base::sink(type = "output", split = FALSE)
[17:42:47.168]             base::close(...future.stdout)
[17:42:47.168]         }, add = TRUE)
[17:42:47.168]     }
[17:42:47.168]     ...future.frame <- base::sys.nframe()
[17:42:47.168]     ...future.conditions <- base::list()
[17:42:47.168]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.168]     if (FALSE) {
[17:42:47.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.168]     }
[17:42:47.168]     ...future.result <- base::tryCatch({
[17:42:47.168]         base::withCallingHandlers({
[17:42:47.168]             ...future.value <- base::withVisible(base::local({
[17:42:47.168]                 ...future.makeSendCondition <- local({
[17:42:47.168]                   sendCondition <- NULL
[17:42:47.168]                   function(frame = 1L) {
[17:42:47.168]                     if (is.function(sendCondition)) 
[17:42:47.168]                       return(sendCondition)
[17:42:47.168]                     ns <- getNamespace("parallel")
[17:42:47.168]                     if (exists("sendData", mode = "function", 
[17:42:47.168]                       envir = ns)) {
[17:42:47.168]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.168]                         envir = ns)
[17:42:47.168]                       envir <- sys.frame(frame)
[17:42:47.168]                       master <- NULL
[17:42:47.168]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.168]                         !identical(envir, emptyenv())) {
[17:42:47.168]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.168]                           inherits = FALSE)) {
[17:42:47.168]                           master <- get("master", mode = "list", 
[17:42:47.168]                             envir = envir, inherits = FALSE)
[17:42:47.168]                           if (inherits(master, c("SOCKnode", 
[17:42:47.168]                             "SOCK0node"))) {
[17:42:47.168]                             sendCondition <<- function(cond) {
[17:42:47.168]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.168]                                 success = TRUE)
[17:42:47.168]                               parallel_sendData(master, data)
[17:42:47.168]                             }
[17:42:47.168]                             return(sendCondition)
[17:42:47.168]                           }
[17:42:47.168]                         }
[17:42:47.168]                         frame <- frame + 1L
[17:42:47.168]                         envir <- sys.frame(frame)
[17:42:47.168]                       }
[17:42:47.168]                     }
[17:42:47.168]                     sendCondition <<- function(cond) NULL
[17:42:47.168]                   }
[17:42:47.168]                 })
[17:42:47.168]                 withCallingHandlers({
[17:42:47.168]                   {
[17:42:47.168]                     b <- a * ii
[17:42:47.168]                     a <- 0
[17:42:47.168]                     b
[17:42:47.168]                   }
[17:42:47.168]                 }, immediateCondition = function(cond) {
[17:42:47.168]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.168]                   sendCondition(cond)
[17:42:47.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.168]                   {
[17:42:47.168]                     inherits <- base::inherits
[17:42:47.168]                     invokeRestart <- base::invokeRestart
[17:42:47.168]                     is.null <- base::is.null
[17:42:47.168]                     muffled <- FALSE
[17:42:47.168]                     if (inherits(cond, "message")) {
[17:42:47.168]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.168]                       if (muffled) 
[17:42:47.168]                         invokeRestart("muffleMessage")
[17:42:47.168]                     }
[17:42:47.168]                     else if (inherits(cond, "warning")) {
[17:42:47.168]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.168]                       if (muffled) 
[17:42:47.168]                         invokeRestart("muffleWarning")
[17:42:47.168]                     }
[17:42:47.168]                     else if (inherits(cond, "condition")) {
[17:42:47.168]                       if (!is.null(pattern)) {
[17:42:47.168]                         computeRestarts <- base::computeRestarts
[17:42:47.168]                         grepl <- base::grepl
[17:42:47.168]                         restarts <- computeRestarts(cond)
[17:42:47.168]                         for (restart in restarts) {
[17:42:47.168]                           name <- restart$name
[17:42:47.168]                           if (is.null(name)) 
[17:42:47.168]                             next
[17:42:47.168]                           if (!grepl(pattern, name)) 
[17:42:47.168]                             next
[17:42:47.168]                           invokeRestart(restart)
[17:42:47.168]                           muffled <- TRUE
[17:42:47.168]                           break
[17:42:47.168]                         }
[17:42:47.168]                       }
[17:42:47.168]                     }
[17:42:47.168]                     invisible(muffled)
[17:42:47.168]                   }
[17:42:47.168]                   muffleCondition(cond)
[17:42:47.168]                 })
[17:42:47.168]             }))
[17:42:47.168]             future::FutureResult(value = ...future.value$value, 
[17:42:47.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.168]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.168]                     ...future.globalenv.names))
[17:42:47.168]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.168]         }, condition = base::local({
[17:42:47.168]             c <- base::c
[17:42:47.168]             inherits <- base::inherits
[17:42:47.168]             invokeRestart <- base::invokeRestart
[17:42:47.168]             length <- base::length
[17:42:47.168]             list <- base::list
[17:42:47.168]             seq.int <- base::seq.int
[17:42:47.168]             signalCondition <- base::signalCondition
[17:42:47.168]             sys.calls <- base::sys.calls
[17:42:47.168]             `[[` <- base::`[[`
[17:42:47.168]             `+` <- base::`+`
[17:42:47.168]             `<<-` <- base::`<<-`
[17:42:47.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.168]                   3L)]
[17:42:47.168]             }
[17:42:47.168]             function(cond) {
[17:42:47.168]                 is_error <- inherits(cond, "error")
[17:42:47.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.168]                   NULL)
[17:42:47.168]                 if (is_error) {
[17:42:47.168]                   sessionInformation <- function() {
[17:42:47.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.168]                       search = base::search(), system = base::Sys.info())
[17:42:47.168]                   }
[17:42:47.168]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.168]                     cond$call), session = sessionInformation(), 
[17:42:47.168]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.168]                   signalCondition(cond)
[17:42:47.168]                 }
[17:42:47.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.168]                 "immediateCondition"))) {
[17:42:47.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.168]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.168]                   if (TRUE && !signal) {
[17:42:47.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.168]                     {
[17:42:47.168]                       inherits <- base::inherits
[17:42:47.168]                       invokeRestart <- base::invokeRestart
[17:42:47.168]                       is.null <- base::is.null
[17:42:47.168]                       muffled <- FALSE
[17:42:47.168]                       if (inherits(cond, "message")) {
[17:42:47.168]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.168]                         if (muffled) 
[17:42:47.168]                           invokeRestart("muffleMessage")
[17:42:47.168]                       }
[17:42:47.168]                       else if (inherits(cond, "warning")) {
[17:42:47.168]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.168]                         if (muffled) 
[17:42:47.168]                           invokeRestart("muffleWarning")
[17:42:47.168]                       }
[17:42:47.168]                       else if (inherits(cond, "condition")) {
[17:42:47.168]                         if (!is.null(pattern)) {
[17:42:47.168]                           computeRestarts <- base::computeRestarts
[17:42:47.168]                           grepl <- base::grepl
[17:42:47.168]                           restarts <- computeRestarts(cond)
[17:42:47.168]                           for (restart in restarts) {
[17:42:47.168]                             name <- restart$name
[17:42:47.168]                             if (is.null(name)) 
[17:42:47.168]                               next
[17:42:47.168]                             if (!grepl(pattern, name)) 
[17:42:47.168]                               next
[17:42:47.168]                             invokeRestart(restart)
[17:42:47.168]                             muffled <- TRUE
[17:42:47.168]                             break
[17:42:47.168]                           }
[17:42:47.168]                         }
[17:42:47.168]                       }
[17:42:47.168]                       invisible(muffled)
[17:42:47.168]                     }
[17:42:47.168]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.168]                   }
[17:42:47.168]                 }
[17:42:47.168]                 else {
[17:42:47.168]                   if (TRUE) {
[17:42:47.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.168]                     {
[17:42:47.168]                       inherits <- base::inherits
[17:42:47.168]                       invokeRestart <- base::invokeRestart
[17:42:47.168]                       is.null <- base::is.null
[17:42:47.168]                       muffled <- FALSE
[17:42:47.168]                       if (inherits(cond, "message")) {
[17:42:47.168]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.168]                         if (muffled) 
[17:42:47.168]                           invokeRestart("muffleMessage")
[17:42:47.168]                       }
[17:42:47.168]                       else if (inherits(cond, "warning")) {
[17:42:47.168]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.168]                         if (muffled) 
[17:42:47.168]                           invokeRestart("muffleWarning")
[17:42:47.168]                       }
[17:42:47.168]                       else if (inherits(cond, "condition")) {
[17:42:47.168]                         if (!is.null(pattern)) {
[17:42:47.168]                           computeRestarts <- base::computeRestarts
[17:42:47.168]                           grepl <- base::grepl
[17:42:47.168]                           restarts <- computeRestarts(cond)
[17:42:47.168]                           for (restart in restarts) {
[17:42:47.168]                             name <- restart$name
[17:42:47.168]                             if (is.null(name)) 
[17:42:47.168]                               next
[17:42:47.168]                             if (!grepl(pattern, name)) 
[17:42:47.168]                               next
[17:42:47.168]                             invokeRestart(restart)
[17:42:47.168]                             muffled <- TRUE
[17:42:47.168]                             break
[17:42:47.168]                           }
[17:42:47.168]                         }
[17:42:47.168]                       }
[17:42:47.168]                       invisible(muffled)
[17:42:47.168]                     }
[17:42:47.168]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.168]                   }
[17:42:47.168]                 }
[17:42:47.168]             }
[17:42:47.168]         }))
[17:42:47.168]     }, error = function(ex) {
[17:42:47.168]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.168]                 ...future.rng), started = ...future.startTime, 
[17:42:47.168]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.168]             version = "1.8"), class = "FutureResult")
[17:42:47.168]     }, finally = {
[17:42:47.168]         if (!identical(...future.workdir, getwd())) 
[17:42:47.168]             setwd(...future.workdir)
[17:42:47.168]         {
[17:42:47.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.168]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.168]             }
[17:42:47.168]             base::options(...future.oldOptions)
[17:42:47.168]             if (.Platform$OS.type == "windows") {
[17:42:47.168]                 old_names <- names(...future.oldEnvVars)
[17:42:47.168]                 envs <- base::Sys.getenv()
[17:42:47.168]                 names <- names(envs)
[17:42:47.168]                 common <- intersect(names, old_names)
[17:42:47.168]                 added <- setdiff(names, old_names)
[17:42:47.168]                 removed <- setdiff(old_names, names)
[17:42:47.168]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.168]                   envs[common]]
[17:42:47.168]                 NAMES <- toupper(changed)
[17:42:47.168]                 args <- list()
[17:42:47.168]                 for (kk in seq_along(NAMES)) {
[17:42:47.168]                   name <- changed[[kk]]
[17:42:47.168]                   NAME <- NAMES[[kk]]
[17:42:47.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.168]                     next
[17:42:47.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.168]                 }
[17:42:47.168]                 NAMES <- toupper(added)
[17:42:47.168]                 for (kk in seq_along(NAMES)) {
[17:42:47.168]                   name <- added[[kk]]
[17:42:47.168]                   NAME <- NAMES[[kk]]
[17:42:47.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.168]                     next
[17:42:47.168]                   args[[name]] <- ""
[17:42:47.168]                 }
[17:42:47.168]                 NAMES <- toupper(removed)
[17:42:47.168]                 for (kk in seq_along(NAMES)) {
[17:42:47.168]                   name <- removed[[kk]]
[17:42:47.168]                   NAME <- NAMES[[kk]]
[17:42:47.168]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.168]                     next
[17:42:47.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.168]                 }
[17:42:47.168]                 if (length(args) > 0) 
[17:42:47.168]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.168]             }
[17:42:47.168]             else {
[17:42:47.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.168]             }
[17:42:47.168]             {
[17:42:47.168]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.168]                   0L) {
[17:42:47.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.168]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.168]                   base::options(opts)
[17:42:47.168]                 }
[17:42:47.168]                 {
[17:42:47.168]                   {
[17:42:47.168]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.168]                     NULL
[17:42:47.168]                   }
[17:42:47.168]                   options(future.plan = NULL)
[17:42:47.168]                   if (is.na(NA_character_)) 
[17:42:47.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.168]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.168]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.168]                     envir = parent.frame()) 
[17:42:47.168]                   {
[17:42:47.168]                     if (is.function(workers)) 
[17:42:47.168]                       workers <- workers()
[17:42:47.168]                     workers <- structure(as.integer(workers), 
[17:42:47.168]                       class = class(workers))
[17:42:47.168]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.168]                       workers >= 1)
[17:42:47.168]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.168]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.168]                     }
[17:42:47.168]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.168]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.168]                       envir = envir)
[17:42:47.168]                     if (!future$lazy) 
[17:42:47.168]                       future <- run(future)
[17:42:47.168]                     invisible(future)
[17:42:47.168]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.168]                 }
[17:42:47.168]             }
[17:42:47.168]         }
[17:42:47.168]     })
[17:42:47.168]     if (TRUE) {
[17:42:47.168]         base::sink(type = "output", split = FALSE)
[17:42:47.168]         if (TRUE) {
[17:42:47.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.168]         }
[17:42:47.168]         else {
[17:42:47.168]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.168]         }
[17:42:47.168]         base::close(...future.stdout)
[17:42:47.168]         ...future.stdout <- NULL
[17:42:47.168]     }
[17:42:47.168]     ...future.result$conditions <- ...future.conditions
[17:42:47.168]     ...future.result$finished <- base::Sys.time()
[17:42:47.168]     ...future.result
[17:42:47.168] }
[17:42:47.170] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:47.181] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.181] - Validating connection of MultisessionFuture
[17:42:47.182] - received message: FutureResult
[17:42:47.182] - Received FutureResult
[17:42:47.182] - Erased future from FutureRegistry
[17:42:47.182] result() for ClusterFuture ...
[17:42:47.182] - result already collected: FutureResult
[17:42:47.182] result() for ClusterFuture ... done
[17:42:47.182] signalConditions() ...
[17:42:47.182]  - include = ‘immediateCondition’
[17:42:47.182]  - exclude = 
[17:42:47.182]  - resignal = FALSE
[17:42:47.183]  - Number of conditions: 1
[17:42:47.183] signalConditions() ... done
[17:42:47.183] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.183] result() for ClusterFuture ...
[17:42:47.183] - result already collected: FutureResult
[17:42:47.183] result() for ClusterFuture ... done
[17:42:47.183] result() for ClusterFuture ...
[17:42:47.183] - result already collected: FutureResult
[17:42:47.183] result() for ClusterFuture ... done
[17:42:47.183] signalConditions() ...
[17:42:47.184]  - include = ‘immediateCondition’
[17:42:47.184]  - exclude = 
[17:42:47.184]  - resignal = FALSE
[17:42:47.184]  - Number of conditions: 1
[17:42:47.184] signalConditions() ... done
[17:42:47.185] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:47.185] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:47.185] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:47.185] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:47.186] MultisessionFuture started
[17:42:47.186] - Launch lazy future ... done
[17:42:47.186] run() for ‘MultisessionFuture’ ... done
[17:42:47.186] result() for ClusterFuture ...
[17:42:47.186] - result already collected: FutureResult
[17:42:47.186] result() for ClusterFuture ... done
[17:42:47.186] result() for ClusterFuture ...
[17:42:47.186] - result already collected: FutureResult
[17:42:47.187] result() for ClusterFuture ... done
[17:42:47.187] signalConditions() ...
[17:42:47.187]  - include = ‘immediateCondition’
[17:42:47.187]  - exclude = 
[17:42:47.187]  - resignal = FALSE
[17:42:47.187]  - Number of conditions: 1
[17:42:47.187] signalConditions() ... done
[17:42:47.187] Future state: ‘finished’
[17:42:47.187] result() for ClusterFuture ...
[17:42:47.188] - result already collected: FutureResult
[17:42:47.188] result() for ClusterFuture ... done
[17:42:47.188] signalConditions() ...
[17:42:47.188]  - include = ‘condition’
[17:42:47.188]  - exclude = ‘immediateCondition’
[17:42:47.188]  - resignal = TRUE
[17:42:47.188]  - Number of conditions: 1
[17:42:47.188]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:47.188] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:47"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.204] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.204] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.205] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.205] Searching for globals ... DONE
[17:42:47.206] Resolving globals: TRUE
[17:42:47.206] Resolving any globals that are futures ...
[17:42:47.206] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.206] Resolving any globals that are futures ... DONE
[17:42:47.206] Resolving futures part of globals (recursively) ...
[17:42:47.207] resolve() on list ...
[17:42:47.207]  recursive: 99
[17:42:47.207]  length: 1
[17:42:47.207]  elements: ‘ii’
[17:42:47.207]  length: 0 (resolved future 1)
[17:42:47.207] resolve() on list ... DONE
[17:42:47.207] - globals: [1] ‘ii’
[17:42:47.207] Resolving futures part of globals (recursively) ... DONE
[17:42:47.208] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:47.208] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:47.208] - globals: [1] ‘ii’
[17:42:47.208] 
[17:42:47.208] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.209] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.209] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.210] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.210] Searching for globals ... DONE
[17:42:47.210] Resolving globals: TRUE
[17:42:47.211] Resolving any globals that are futures ...
[17:42:47.211] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.211] Resolving any globals that are futures ... DONE
[17:42:47.211] Resolving futures part of globals (recursively) ...
[17:42:47.211] resolve() on list ...
[17:42:47.211]  recursive: 99
[17:42:47.212]  length: 1
[17:42:47.212]  elements: ‘ii’
[17:42:47.212]  length: 0 (resolved future 1)
[17:42:47.212] resolve() on list ... DONE
[17:42:47.212] - globals: [1] ‘ii’
[17:42:47.212] Resolving futures part of globals (recursively) ... DONE
[17:42:47.212] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:47.212] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:47.213] - globals: [1] ‘ii’
[17:42:47.213] 
[17:42:47.213] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.213] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.213] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.215] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.215] Searching for globals ... DONE
[17:42:47.215] Resolving globals: TRUE
[17:42:47.215] Resolving any globals that are futures ...
[17:42:47.215] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[17:42:47.215] Resolving any globals that are futures ... DONE
[17:42:47.216] Resolving futures part of globals (recursively) ...
[17:42:47.216] resolve() on list ...
[17:42:47.216]  recursive: 99
[17:42:47.216]  length: 1
[17:42:47.216]  elements: ‘ii’
[17:42:47.216]  length: 0 (resolved future 1)
[17:42:47.217] resolve() on list ... DONE
[17:42:47.217] - globals: [1] ‘ii’
[17:42:47.217] Resolving futures part of globals (recursively) ... DONE
[17:42:47.217] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:47.217] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[17:42:47.218] - globals: [1] ‘ii’
[17:42:47.218] 
[17:42:47.218] getGlobalsAndPackages() ... DONE
[17:42:47.218] run() for ‘Future’ ...
[17:42:47.218] - state: ‘created’
[17:42:47.218] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.234] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.234]   - Field: ‘node’
[17:42:47.234]   - Field: ‘label’
[17:42:47.234]   - Field: ‘local’
[17:42:47.234]   - Field: ‘owner’
[17:42:47.234]   - Field: ‘envir’
[17:42:47.235]   - Field: ‘workers’
[17:42:47.235]   - Field: ‘packages’
[17:42:47.235]   - Field: ‘gc’
[17:42:47.235]   - Field: ‘conditions’
[17:42:47.235]   - Field: ‘persistent’
[17:42:47.235]   - Field: ‘expr’
[17:42:47.236]   - Field: ‘uuid’
[17:42:47.236]   - Field: ‘seed’
[17:42:47.236]   - Field: ‘version’
[17:42:47.236]   - Field: ‘result’
[17:42:47.236]   - Field: ‘asynchronous’
[17:42:47.236]   - Field: ‘calls’
[17:42:47.237]   - Field: ‘globals’
[17:42:47.237]   - Field: ‘stdout’
[17:42:47.237]   - Field: ‘earlySignal’
[17:42:47.237]   - Field: ‘lazy’
[17:42:47.237]   - Field: ‘state’
[17:42:47.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.237] - Launch lazy future ...
[17:42:47.238] Packages needed by the future expression (n = 0): <none>
[17:42:47.238] Packages needed by future strategies (n = 0): <none>
[17:42:47.238] {
[17:42:47.238]     {
[17:42:47.238]         {
[17:42:47.238]             ...future.startTime <- base::Sys.time()
[17:42:47.238]             {
[17:42:47.238]                 {
[17:42:47.238]                   {
[17:42:47.238]                     {
[17:42:47.238]                       base::local({
[17:42:47.238]                         has_future <- base::requireNamespace("future", 
[17:42:47.238]                           quietly = TRUE)
[17:42:47.238]                         if (has_future) {
[17:42:47.238]                           ns <- base::getNamespace("future")
[17:42:47.238]                           version <- ns[[".package"]][["version"]]
[17:42:47.238]                           if (is.null(version)) 
[17:42:47.238]                             version <- utils::packageVersion("future")
[17:42:47.238]                         }
[17:42:47.238]                         else {
[17:42:47.238]                           version <- NULL
[17:42:47.238]                         }
[17:42:47.238]                         if (!has_future || version < "1.8.0") {
[17:42:47.238]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.238]                             "", base::R.version$version.string), 
[17:42:47.238]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.238]                               "release", "version")], collapse = " "), 
[17:42:47.238]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.238]                             info)
[17:42:47.238]                           info <- base::paste(info, collapse = "; ")
[17:42:47.238]                           if (!has_future) {
[17:42:47.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.238]                               info)
[17:42:47.238]                           }
[17:42:47.238]                           else {
[17:42:47.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.238]                               info, version)
[17:42:47.238]                           }
[17:42:47.238]                           base::stop(msg)
[17:42:47.238]                         }
[17:42:47.238]                       })
[17:42:47.238]                     }
[17:42:47.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.238]                     base::options(mc.cores = 1L)
[17:42:47.238]                   }
[17:42:47.238]                   options(future.plan = NULL)
[17:42:47.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.238]                 }
[17:42:47.238]                 ...future.workdir <- getwd()
[17:42:47.238]             }
[17:42:47.238]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.238]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.238]         }
[17:42:47.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.238]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.238]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.238]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.238]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.238]             base::names(...future.oldOptions))
[17:42:47.238]     }
[17:42:47.238]     if (FALSE) {
[17:42:47.238]     }
[17:42:47.238]     else {
[17:42:47.238]         if (TRUE) {
[17:42:47.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.238]                 open = "w")
[17:42:47.238]         }
[17:42:47.238]         else {
[17:42:47.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.238]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.238]         }
[17:42:47.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.238]             base::sink(type = "output", split = FALSE)
[17:42:47.238]             base::close(...future.stdout)
[17:42:47.238]         }, add = TRUE)
[17:42:47.238]     }
[17:42:47.238]     ...future.frame <- base::sys.nframe()
[17:42:47.238]     ...future.conditions <- base::list()
[17:42:47.238]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.238]     if (FALSE) {
[17:42:47.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.238]     }
[17:42:47.238]     ...future.result <- base::tryCatch({
[17:42:47.238]         base::withCallingHandlers({
[17:42:47.238]             ...future.value <- base::withVisible(base::local({
[17:42:47.238]                 ...future.makeSendCondition <- local({
[17:42:47.238]                   sendCondition <- NULL
[17:42:47.238]                   function(frame = 1L) {
[17:42:47.238]                     if (is.function(sendCondition)) 
[17:42:47.238]                       return(sendCondition)
[17:42:47.238]                     ns <- getNamespace("parallel")
[17:42:47.238]                     if (exists("sendData", mode = "function", 
[17:42:47.238]                       envir = ns)) {
[17:42:47.238]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.238]                         envir = ns)
[17:42:47.238]                       envir <- sys.frame(frame)
[17:42:47.238]                       master <- NULL
[17:42:47.238]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.238]                         !identical(envir, emptyenv())) {
[17:42:47.238]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.238]                           inherits = FALSE)) {
[17:42:47.238]                           master <- get("master", mode = "list", 
[17:42:47.238]                             envir = envir, inherits = FALSE)
[17:42:47.238]                           if (inherits(master, c("SOCKnode", 
[17:42:47.238]                             "SOCK0node"))) {
[17:42:47.238]                             sendCondition <<- function(cond) {
[17:42:47.238]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.238]                                 success = TRUE)
[17:42:47.238]                               parallel_sendData(master, data)
[17:42:47.238]                             }
[17:42:47.238]                             return(sendCondition)
[17:42:47.238]                           }
[17:42:47.238]                         }
[17:42:47.238]                         frame <- frame + 1L
[17:42:47.238]                         envir <- sys.frame(frame)
[17:42:47.238]                       }
[17:42:47.238]                     }
[17:42:47.238]                     sendCondition <<- function(cond) NULL
[17:42:47.238]                   }
[17:42:47.238]                 })
[17:42:47.238]                 withCallingHandlers({
[17:42:47.238]                   {
[17:42:47.238]                     b <- a * ii
[17:42:47.238]                     a <- 0
[17:42:47.238]                     b
[17:42:47.238]                   }
[17:42:47.238]                 }, immediateCondition = function(cond) {
[17:42:47.238]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.238]                   sendCondition(cond)
[17:42:47.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.238]                   {
[17:42:47.238]                     inherits <- base::inherits
[17:42:47.238]                     invokeRestart <- base::invokeRestart
[17:42:47.238]                     is.null <- base::is.null
[17:42:47.238]                     muffled <- FALSE
[17:42:47.238]                     if (inherits(cond, "message")) {
[17:42:47.238]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.238]                       if (muffled) 
[17:42:47.238]                         invokeRestart("muffleMessage")
[17:42:47.238]                     }
[17:42:47.238]                     else if (inherits(cond, "warning")) {
[17:42:47.238]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.238]                       if (muffled) 
[17:42:47.238]                         invokeRestart("muffleWarning")
[17:42:47.238]                     }
[17:42:47.238]                     else if (inherits(cond, "condition")) {
[17:42:47.238]                       if (!is.null(pattern)) {
[17:42:47.238]                         computeRestarts <- base::computeRestarts
[17:42:47.238]                         grepl <- base::grepl
[17:42:47.238]                         restarts <- computeRestarts(cond)
[17:42:47.238]                         for (restart in restarts) {
[17:42:47.238]                           name <- restart$name
[17:42:47.238]                           if (is.null(name)) 
[17:42:47.238]                             next
[17:42:47.238]                           if (!grepl(pattern, name)) 
[17:42:47.238]                             next
[17:42:47.238]                           invokeRestart(restart)
[17:42:47.238]                           muffled <- TRUE
[17:42:47.238]                           break
[17:42:47.238]                         }
[17:42:47.238]                       }
[17:42:47.238]                     }
[17:42:47.238]                     invisible(muffled)
[17:42:47.238]                   }
[17:42:47.238]                   muffleCondition(cond)
[17:42:47.238]                 })
[17:42:47.238]             }))
[17:42:47.238]             future::FutureResult(value = ...future.value$value, 
[17:42:47.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.238]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.238]                     ...future.globalenv.names))
[17:42:47.238]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.238]         }, condition = base::local({
[17:42:47.238]             c <- base::c
[17:42:47.238]             inherits <- base::inherits
[17:42:47.238]             invokeRestart <- base::invokeRestart
[17:42:47.238]             length <- base::length
[17:42:47.238]             list <- base::list
[17:42:47.238]             seq.int <- base::seq.int
[17:42:47.238]             signalCondition <- base::signalCondition
[17:42:47.238]             sys.calls <- base::sys.calls
[17:42:47.238]             `[[` <- base::`[[`
[17:42:47.238]             `+` <- base::`+`
[17:42:47.238]             `<<-` <- base::`<<-`
[17:42:47.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.238]                   3L)]
[17:42:47.238]             }
[17:42:47.238]             function(cond) {
[17:42:47.238]                 is_error <- inherits(cond, "error")
[17:42:47.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.238]                   NULL)
[17:42:47.238]                 if (is_error) {
[17:42:47.238]                   sessionInformation <- function() {
[17:42:47.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.238]                       search = base::search(), system = base::Sys.info())
[17:42:47.238]                   }
[17:42:47.238]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.238]                     cond$call), session = sessionInformation(), 
[17:42:47.238]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.238]                   signalCondition(cond)
[17:42:47.238]                 }
[17:42:47.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.238]                 "immediateCondition"))) {
[17:42:47.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.238]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.238]                   if (TRUE && !signal) {
[17:42:47.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.238]                     {
[17:42:47.238]                       inherits <- base::inherits
[17:42:47.238]                       invokeRestart <- base::invokeRestart
[17:42:47.238]                       is.null <- base::is.null
[17:42:47.238]                       muffled <- FALSE
[17:42:47.238]                       if (inherits(cond, "message")) {
[17:42:47.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.238]                         if (muffled) 
[17:42:47.238]                           invokeRestart("muffleMessage")
[17:42:47.238]                       }
[17:42:47.238]                       else if (inherits(cond, "warning")) {
[17:42:47.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.238]                         if (muffled) 
[17:42:47.238]                           invokeRestart("muffleWarning")
[17:42:47.238]                       }
[17:42:47.238]                       else if (inherits(cond, "condition")) {
[17:42:47.238]                         if (!is.null(pattern)) {
[17:42:47.238]                           computeRestarts <- base::computeRestarts
[17:42:47.238]                           grepl <- base::grepl
[17:42:47.238]                           restarts <- computeRestarts(cond)
[17:42:47.238]                           for (restart in restarts) {
[17:42:47.238]                             name <- restart$name
[17:42:47.238]                             if (is.null(name)) 
[17:42:47.238]                               next
[17:42:47.238]                             if (!grepl(pattern, name)) 
[17:42:47.238]                               next
[17:42:47.238]                             invokeRestart(restart)
[17:42:47.238]                             muffled <- TRUE
[17:42:47.238]                             break
[17:42:47.238]                           }
[17:42:47.238]                         }
[17:42:47.238]                       }
[17:42:47.238]                       invisible(muffled)
[17:42:47.238]                     }
[17:42:47.238]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.238]                   }
[17:42:47.238]                 }
[17:42:47.238]                 else {
[17:42:47.238]                   if (TRUE) {
[17:42:47.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.238]                     {
[17:42:47.238]                       inherits <- base::inherits
[17:42:47.238]                       invokeRestart <- base::invokeRestart
[17:42:47.238]                       is.null <- base::is.null
[17:42:47.238]                       muffled <- FALSE
[17:42:47.238]                       if (inherits(cond, "message")) {
[17:42:47.238]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.238]                         if (muffled) 
[17:42:47.238]                           invokeRestart("muffleMessage")
[17:42:47.238]                       }
[17:42:47.238]                       else if (inherits(cond, "warning")) {
[17:42:47.238]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.238]                         if (muffled) 
[17:42:47.238]                           invokeRestart("muffleWarning")
[17:42:47.238]                       }
[17:42:47.238]                       else if (inherits(cond, "condition")) {
[17:42:47.238]                         if (!is.null(pattern)) {
[17:42:47.238]                           computeRestarts <- base::computeRestarts
[17:42:47.238]                           grepl <- base::grepl
[17:42:47.238]                           restarts <- computeRestarts(cond)
[17:42:47.238]                           for (restart in restarts) {
[17:42:47.238]                             name <- restart$name
[17:42:47.238]                             if (is.null(name)) 
[17:42:47.238]                               next
[17:42:47.238]                             if (!grepl(pattern, name)) 
[17:42:47.238]                               next
[17:42:47.238]                             invokeRestart(restart)
[17:42:47.238]                             muffled <- TRUE
[17:42:47.238]                             break
[17:42:47.238]                           }
[17:42:47.238]                         }
[17:42:47.238]                       }
[17:42:47.238]                       invisible(muffled)
[17:42:47.238]                     }
[17:42:47.238]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.238]                   }
[17:42:47.238]                 }
[17:42:47.238]             }
[17:42:47.238]         }))
[17:42:47.238]     }, error = function(ex) {
[17:42:47.238]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.238]                 ...future.rng), started = ...future.startTime, 
[17:42:47.238]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.238]             version = "1.8"), class = "FutureResult")
[17:42:47.238]     }, finally = {
[17:42:47.238]         if (!identical(...future.workdir, getwd())) 
[17:42:47.238]             setwd(...future.workdir)
[17:42:47.238]         {
[17:42:47.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.238]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.238]             }
[17:42:47.238]             base::options(...future.oldOptions)
[17:42:47.238]             if (.Platform$OS.type == "windows") {
[17:42:47.238]                 old_names <- names(...future.oldEnvVars)
[17:42:47.238]                 envs <- base::Sys.getenv()
[17:42:47.238]                 names <- names(envs)
[17:42:47.238]                 common <- intersect(names, old_names)
[17:42:47.238]                 added <- setdiff(names, old_names)
[17:42:47.238]                 removed <- setdiff(old_names, names)
[17:42:47.238]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.238]                   envs[common]]
[17:42:47.238]                 NAMES <- toupper(changed)
[17:42:47.238]                 args <- list()
[17:42:47.238]                 for (kk in seq_along(NAMES)) {
[17:42:47.238]                   name <- changed[[kk]]
[17:42:47.238]                   NAME <- NAMES[[kk]]
[17:42:47.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.238]                     next
[17:42:47.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.238]                 }
[17:42:47.238]                 NAMES <- toupper(added)
[17:42:47.238]                 for (kk in seq_along(NAMES)) {
[17:42:47.238]                   name <- added[[kk]]
[17:42:47.238]                   NAME <- NAMES[[kk]]
[17:42:47.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.238]                     next
[17:42:47.238]                   args[[name]] <- ""
[17:42:47.238]                 }
[17:42:47.238]                 NAMES <- toupper(removed)
[17:42:47.238]                 for (kk in seq_along(NAMES)) {
[17:42:47.238]                   name <- removed[[kk]]
[17:42:47.238]                   NAME <- NAMES[[kk]]
[17:42:47.238]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.238]                     next
[17:42:47.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.238]                 }
[17:42:47.238]                 if (length(args) > 0) 
[17:42:47.238]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.238]             }
[17:42:47.238]             else {
[17:42:47.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.238]             }
[17:42:47.238]             {
[17:42:47.238]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.238]                   0L) {
[17:42:47.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.238]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.238]                   base::options(opts)
[17:42:47.238]                 }
[17:42:47.238]                 {
[17:42:47.238]                   {
[17:42:47.238]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.238]                     NULL
[17:42:47.238]                   }
[17:42:47.238]                   options(future.plan = NULL)
[17:42:47.238]                   if (is.na(NA_character_)) 
[17:42:47.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.238]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.238]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.238]                     envir = parent.frame()) 
[17:42:47.238]                   {
[17:42:47.238]                     if (is.function(workers)) 
[17:42:47.238]                       workers <- workers()
[17:42:47.238]                     workers <- structure(as.integer(workers), 
[17:42:47.238]                       class = class(workers))
[17:42:47.238]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.238]                       workers >= 1)
[17:42:47.238]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.238]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.238]                     }
[17:42:47.238]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.238]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.238]                       envir = envir)
[17:42:47.238]                     if (!future$lazy) 
[17:42:47.238]                       future <- run(future)
[17:42:47.238]                     invisible(future)
[17:42:47.238]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.238]                 }
[17:42:47.238]             }
[17:42:47.238]         }
[17:42:47.238]     })
[17:42:47.238]     if (TRUE) {
[17:42:47.238]         base::sink(type = "output", split = FALSE)
[17:42:47.238]         if (TRUE) {
[17:42:47.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.238]         }
[17:42:47.238]         else {
[17:42:47.238]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.238]         }
[17:42:47.238]         base::close(...future.stdout)
[17:42:47.238]         ...future.stdout <- NULL
[17:42:47.238]     }
[17:42:47.238]     ...future.result$conditions <- ...future.conditions
[17:42:47.238]     ...future.result$finished <- base::Sys.time()
[17:42:47.238]     ...future.result
[17:42:47.238] }
[17:42:47.241] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:47.251] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.252] - Validating connection of MultisessionFuture
[17:42:47.252] - received message: FutureResult
[17:42:47.252] - Received FutureResult
[17:42:47.252] - Erased future from FutureRegistry
[17:42:47.252] result() for ClusterFuture ...
[17:42:47.252] - result already collected: FutureResult
[17:42:47.253] result() for ClusterFuture ... done
[17:42:47.253] signalConditions() ...
[17:42:47.253]  - include = ‘immediateCondition’
[17:42:47.253]  - exclude = 
[17:42:47.253]  - resignal = FALSE
[17:42:47.253]  - Number of conditions: 1
[17:42:47.253] signalConditions() ... done
[17:42:47.253] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.253] result() for ClusterFuture ...
[17:42:47.253] - result already collected: FutureResult
[17:42:47.253] result() for ClusterFuture ... done
[17:42:47.254] result() for ClusterFuture ...
[17:42:47.254] - result already collected: FutureResult
[17:42:47.254] result() for ClusterFuture ... done
[17:42:47.254] signalConditions() ...
[17:42:47.254]  - include = ‘immediateCondition’
[17:42:47.254]  - exclude = 
[17:42:47.254]  - resignal = FALSE
[17:42:47.254]  - Number of conditions: 1
[17:42:47.254] signalConditions() ... done
[17:42:47.255] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:42:47.255] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:42:47.255] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:42:47.256] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:42:47.256] MultisessionFuture started
[17:42:47.256] - Launch lazy future ... done
[17:42:47.256] run() for ‘MultisessionFuture’ ... done
[17:42:47.256] result() for ClusterFuture ...
[17:42:47.256] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.257] - Validating connection of MultisessionFuture
[17:42:47.305] - received message: FutureResult
[17:42:47.305] - Received FutureResult
[17:42:47.305] - Erased future from FutureRegistry
[17:42:47.305] result() for ClusterFuture ...
[17:42:47.306] - result already collected: FutureResult
[17:42:47.306] result() for ClusterFuture ... done
[17:42:47.306] signalConditions() ...
[17:42:47.306]  - include = ‘immediateCondition’
[17:42:47.306]  - exclude = 
[17:42:47.306]  - resignal = FALSE
[17:42:47.306]  - Number of conditions: 1
[17:42:47.306] signalConditions() ... done
[17:42:47.306] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.306] result() for ClusterFuture ... done
[17:42:47.306] result() for ClusterFuture ...
[17:42:47.307] - result already collected: FutureResult
[17:42:47.307] result() for ClusterFuture ... done
[17:42:47.307] signalConditions() ...
[17:42:47.307]  - include = ‘immediateCondition’
[17:42:47.307]  - exclude = 
[17:42:47.307]  - resignal = FALSE
[17:42:47.307]  - Number of conditions: 1
[17:42:47.307] signalConditions() ... done
[17:42:47.307] Future state: ‘finished’
[17:42:47.307] result() for ClusterFuture ...
[17:42:47.308] - result already collected: FutureResult
[17:42:47.308] result() for ClusterFuture ... done
[17:42:47.308] signalConditions() ...
[17:42:47.308]  - include = ‘condition’
[17:42:47.308]  - exclude = ‘immediateCondition’
[17:42:47.308]  - resignal = TRUE
[17:42:47.308]  - Number of conditions: 1
[17:42:47.308]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:42:47.308] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "3.0"
  .. .. .. .. ..$ year          : chr "2023"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "21"
  .. .. .. .. ..$ svn rev       : chr "84292"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.3.0 (2023-04-21)"
  .. .. .. .. ..$ nickname      : chr "Already Tomorrow"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "e448fae16456" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 17:42:47"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.322] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.322] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.323] 
[17:42:47.323] Searching for globals ... DONE
[17:42:47.323] - globals: [0] <none>
[17:42:47.323] getGlobalsAndPackages() ... DONE
[17:42:47.323] run() for ‘Future’ ...
[17:42:47.324] - state: ‘created’
[17:42:47.324] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.338] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.339]   - Field: ‘node’
[17:42:47.339]   - Field: ‘label’
[17:42:47.339]   - Field: ‘local’
[17:42:47.339]   - Field: ‘owner’
[17:42:47.339]   - Field: ‘envir’
[17:42:47.339]   - Field: ‘workers’
[17:42:47.339]   - Field: ‘packages’
[17:42:47.339]   - Field: ‘gc’
[17:42:47.340]   - Field: ‘conditions’
[17:42:47.340]   - Field: ‘persistent’
[17:42:47.340]   - Field: ‘expr’
[17:42:47.340]   - Field: ‘uuid’
[17:42:47.340]   - Field: ‘seed’
[17:42:47.340]   - Field: ‘version’
[17:42:47.340]   - Field: ‘result’
[17:42:47.340]   - Field: ‘asynchronous’
[17:42:47.340]   - Field: ‘calls’
[17:42:47.340]   - Field: ‘globals’
[17:42:47.340]   - Field: ‘stdout’
[17:42:47.341]   - Field: ‘earlySignal’
[17:42:47.341]   - Field: ‘lazy’
[17:42:47.341]   - Field: ‘state’
[17:42:47.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.341] - Launch lazy future ...
[17:42:47.341] Packages needed by the future expression (n = 0): <none>
[17:42:47.341] Packages needed by future strategies (n = 0): <none>
[17:42:47.342] {
[17:42:47.342]     {
[17:42:47.342]         {
[17:42:47.342]             ...future.startTime <- base::Sys.time()
[17:42:47.342]             {
[17:42:47.342]                 {
[17:42:47.342]                   {
[17:42:47.342]                     {
[17:42:47.342]                       base::local({
[17:42:47.342]                         has_future <- base::requireNamespace("future", 
[17:42:47.342]                           quietly = TRUE)
[17:42:47.342]                         if (has_future) {
[17:42:47.342]                           ns <- base::getNamespace("future")
[17:42:47.342]                           version <- ns[[".package"]][["version"]]
[17:42:47.342]                           if (is.null(version)) 
[17:42:47.342]                             version <- utils::packageVersion("future")
[17:42:47.342]                         }
[17:42:47.342]                         else {
[17:42:47.342]                           version <- NULL
[17:42:47.342]                         }
[17:42:47.342]                         if (!has_future || version < "1.8.0") {
[17:42:47.342]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.342]                             "", base::R.version$version.string), 
[17:42:47.342]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.342]                               "release", "version")], collapse = " "), 
[17:42:47.342]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.342]                             info)
[17:42:47.342]                           info <- base::paste(info, collapse = "; ")
[17:42:47.342]                           if (!has_future) {
[17:42:47.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.342]                               info)
[17:42:47.342]                           }
[17:42:47.342]                           else {
[17:42:47.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.342]                               info, version)
[17:42:47.342]                           }
[17:42:47.342]                           base::stop(msg)
[17:42:47.342]                         }
[17:42:47.342]                       })
[17:42:47.342]                     }
[17:42:47.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.342]                     base::options(mc.cores = 1L)
[17:42:47.342]                   }
[17:42:47.342]                   options(future.plan = NULL)
[17:42:47.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.342]                 }
[17:42:47.342]                 ...future.workdir <- getwd()
[17:42:47.342]             }
[17:42:47.342]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.342]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.342]         }
[17:42:47.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.342]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.342]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.342]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.342]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.342]             base::names(...future.oldOptions))
[17:42:47.342]     }
[17:42:47.342]     if (FALSE) {
[17:42:47.342]     }
[17:42:47.342]     else {
[17:42:47.342]         if (TRUE) {
[17:42:47.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.342]                 open = "w")
[17:42:47.342]         }
[17:42:47.342]         else {
[17:42:47.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.342]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.342]         }
[17:42:47.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.342]             base::sink(type = "output", split = FALSE)
[17:42:47.342]             base::close(...future.stdout)
[17:42:47.342]         }, add = TRUE)
[17:42:47.342]     }
[17:42:47.342]     ...future.frame <- base::sys.nframe()
[17:42:47.342]     ...future.conditions <- base::list()
[17:42:47.342]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.342]     if (FALSE) {
[17:42:47.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.342]     }
[17:42:47.342]     ...future.result <- base::tryCatch({
[17:42:47.342]         base::withCallingHandlers({
[17:42:47.342]             ...future.value <- base::withVisible(base::local({
[17:42:47.342]                 ...future.makeSendCondition <- local({
[17:42:47.342]                   sendCondition <- NULL
[17:42:47.342]                   function(frame = 1L) {
[17:42:47.342]                     if (is.function(sendCondition)) 
[17:42:47.342]                       return(sendCondition)
[17:42:47.342]                     ns <- getNamespace("parallel")
[17:42:47.342]                     if (exists("sendData", mode = "function", 
[17:42:47.342]                       envir = ns)) {
[17:42:47.342]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.342]                         envir = ns)
[17:42:47.342]                       envir <- sys.frame(frame)
[17:42:47.342]                       master <- NULL
[17:42:47.342]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.342]                         !identical(envir, emptyenv())) {
[17:42:47.342]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.342]                           inherits = FALSE)) {
[17:42:47.342]                           master <- get("master", mode = "list", 
[17:42:47.342]                             envir = envir, inherits = FALSE)
[17:42:47.342]                           if (inherits(master, c("SOCKnode", 
[17:42:47.342]                             "SOCK0node"))) {
[17:42:47.342]                             sendCondition <<- function(cond) {
[17:42:47.342]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.342]                                 success = TRUE)
[17:42:47.342]                               parallel_sendData(master, data)
[17:42:47.342]                             }
[17:42:47.342]                             return(sendCondition)
[17:42:47.342]                           }
[17:42:47.342]                         }
[17:42:47.342]                         frame <- frame + 1L
[17:42:47.342]                         envir <- sys.frame(frame)
[17:42:47.342]                       }
[17:42:47.342]                     }
[17:42:47.342]                     sendCondition <<- function(cond) NULL
[17:42:47.342]                   }
[17:42:47.342]                 })
[17:42:47.342]                 withCallingHandlers({
[17:42:47.342]                   1
[17:42:47.342]                 }, immediateCondition = function(cond) {
[17:42:47.342]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.342]                   sendCondition(cond)
[17:42:47.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.342]                   {
[17:42:47.342]                     inherits <- base::inherits
[17:42:47.342]                     invokeRestart <- base::invokeRestart
[17:42:47.342]                     is.null <- base::is.null
[17:42:47.342]                     muffled <- FALSE
[17:42:47.342]                     if (inherits(cond, "message")) {
[17:42:47.342]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.342]                       if (muffled) 
[17:42:47.342]                         invokeRestart("muffleMessage")
[17:42:47.342]                     }
[17:42:47.342]                     else if (inherits(cond, "warning")) {
[17:42:47.342]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.342]                       if (muffled) 
[17:42:47.342]                         invokeRestart("muffleWarning")
[17:42:47.342]                     }
[17:42:47.342]                     else if (inherits(cond, "condition")) {
[17:42:47.342]                       if (!is.null(pattern)) {
[17:42:47.342]                         computeRestarts <- base::computeRestarts
[17:42:47.342]                         grepl <- base::grepl
[17:42:47.342]                         restarts <- computeRestarts(cond)
[17:42:47.342]                         for (restart in restarts) {
[17:42:47.342]                           name <- restart$name
[17:42:47.342]                           if (is.null(name)) 
[17:42:47.342]                             next
[17:42:47.342]                           if (!grepl(pattern, name)) 
[17:42:47.342]                             next
[17:42:47.342]                           invokeRestart(restart)
[17:42:47.342]                           muffled <- TRUE
[17:42:47.342]                           break
[17:42:47.342]                         }
[17:42:47.342]                       }
[17:42:47.342]                     }
[17:42:47.342]                     invisible(muffled)
[17:42:47.342]                   }
[17:42:47.342]                   muffleCondition(cond)
[17:42:47.342]                 })
[17:42:47.342]             }))
[17:42:47.342]             future::FutureResult(value = ...future.value$value, 
[17:42:47.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.342]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.342]                     ...future.globalenv.names))
[17:42:47.342]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.342]         }, condition = base::local({
[17:42:47.342]             c <- base::c
[17:42:47.342]             inherits <- base::inherits
[17:42:47.342]             invokeRestart <- base::invokeRestart
[17:42:47.342]             length <- base::length
[17:42:47.342]             list <- base::list
[17:42:47.342]             seq.int <- base::seq.int
[17:42:47.342]             signalCondition <- base::signalCondition
[17:42:47.342]             sys.calls <- base::sys.calls
[17:42:47.342]             `[[` <- base::`[[`
[17:42:47.342]             `+` <- base::`+`
[17:42:47.342]             `<<-` <- base::`<<-`
[17:42:47.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.342]                   3L)]
[17:42:47.342]             }
[17:42:47.342]             function(cond) {
[17:42:47.342]                 is_error <- inherits(cond, "error")
[17:42:47.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.342]                   NULL)
[17:42:47.342]                 if (is_error) {
[17:42:47.342]                   sessionInformation <- function() {
[17:42:47.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.342]                       search = base::search(), system = base::Sys.info())
[17:42:47.342]                   }
[17:42:47.342]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.342]                     cond$call), session = sessionInformation(), 
[17:42:47.342]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.342]                   signalCondition(cond)
[17:42:47.342]                 }
[17:42:47.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.342]                 "immediateCondition"))) {
[17:42:47.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.342]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.342]                   if (TRUE && !signal) {
[17:42:47.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.342]                     {
[17:42:47.342]                       inherits <- base::inherits
[17:42:47.342]                       invokeRestart <- base::invokeRestart
[17:42:47.342]                       is.null <- base::is.null
[17:42:47.342]                       muffled <- FALSE
[17:42:47.342]                       if (inherits(cond, "message")) {
[17:42:47.342]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.342]                         if (muffled) 
[17:42:47.342]                           invokeRestart("muffleMessage")
[17:42:47.342]                       }
[17:42:47.342]                       else if (inherits(cond, "warning")) {
[17:42:47.342]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.342]                         if (muffled) 
[17:42:47.342]                           invokeRestart("muffleWarning")
[17:42:47.342]                       }
[17:42:47.342]                       else if (inherits(cond, "condition")) {
[17:42:47.342]                         if (!is.null(pattern)) {
[17:42:47.342]                           computeRestarts <- base::computeRestarts
[17:42:47.342]                           grepl <- base::grepl
[17:42:47.342]                           restarts <- computeRestarts(cond)
[17:42:47.342]                           for (restart in restarts) {
[17:42:47.342]                             name <- restart$name
[17:42:47.342]                             if (is.null(name)) 
[17:42:47.342]                               next
[17:42:47.342]                             if (!grepl(pattern, name)) 
[17:42:47.342]                               next
[17:42:47.342]                             invokeRestart(restart)
[17:42:47.342]                             muffled <- TRUE
[17:42:47.342]                             break
[17:42:47.342]                           }
[17:42:47.342]                         }
[17:42:47.342]                       }
[17:42:47.342]                       invisible(muffled)
[17:42:47.342]                     }
[17:42:47.342]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.342]                   }
[17:42:47.342]                 }
[17:42:47.342]                 else {
[17:42:47.342]                   if (TRUE) {
[17:42:47.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.342]                     {
[17:42:47.342]                       inherits <- base::inherits
[17:42:47.342]                       invokeRestart <- base::invokeRestart
[17:42:47.342]                       is.null <- base::is.null
[17:42:47.342]                       muffled <- FALSE
[17:42:47.342]                       if (inherits(cond, "message")) {
[17:42:47.342]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.342]                         if (muffled) 
[17:42:47.342]                           invokeRestart("muffleMessage")
[17:42:47.342]                       }
[17:42:47.342]                       else if (inherits(cond, "warning")) {
[17:42:47.342]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.342]                         if (muffled) 
[17:42:47.342]                           invokeRestart("muffleWarning")
[17:42:47.342]                       }
[17:42:47.342]                       else if (inherits(cond, "condition")) {
[17:42:47.342]                         if (!is.null(pattern)) {
[17:42:47.342]                           computeRestarts <- base::computeRestarts
[17:42:47.342]                           grepl <- base::grepl
[17:42:47.342]                           restarts <- computeRestarts(cond)
[17:42:47.342]                           for (restart in restarts) {
[17:42:47.342]                             name <- restart$name
[17:42:47.342]                             if (is.null(name)) 
[17:42:47.342]                               next
[17:42:47.342]                             if (!grepl(pattern, name)) 
[17:42:47.342]                               next
[17:42:47.342]                             invokeRestart(restart)
[17:42:47.342]                             muffled <- TRUE
[17:42:47.342]                             break
[17:42:47.342]                           }
[17:42:47.342]                         }
[17:42:47.342]                       }
[17:42:47.342]                       invisible(muffled)
[17:42:47.342]                     }
[17:42:47.342]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.342]                   }
[17:42:47.342]                 }
[17:42:47.342]             }
[17:42:47.342]         }))
[17:42:47.342]     }, error = function(ex) {
[17:42:47.342]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.342]                 ...future.rng), started = ...future.startTime, 
[17:42:47.342]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.342]             version = "1.8"), class = "FutureResult")
[17:42:47.342]     }, finally = {
[17:42:47.342]         if (!identical(...future.workdir, getwd())) 
[17:42:47.342]             setwd(...future.workdir)
[17:42:47.342]         {
[17:42:47.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.342]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.342]             }
[17:42:47.342]             base::options(...future.oldOptions)
[17:42:47.342]             if (.Platform$OS.type == "windows") {
[17:42:47.342]                 old_names <- names(...future.oldEnvVars)
[17:42:47.342]                 envs <- base::Sys.getenv()
[17:42:47.342]                 names <- names(envs)
[17:42:47.342]                 common <- intersect(names, old_names)
[17:42:47.342]                 added <- setdiff(names, old_names)
[17:42:47.342]                 removed <- setdiff(old_names, names)
[17:42:47.342]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.342]                   envs[common]]
[17:42:47.342]                 NAMES <- toupper(changed)
[17:42:47.342]                 args <- list()
[17:42:47.342]                 for (kk in seq_along(NAMES)) {
[17:42:47.342]                   name <- changed[[kk]]
[17:42:47.342]                   NAME <- NAMES[[kk]]
[17:42:47.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.342]                     next
[17:42:47.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.342]                 }
[17:42:47.342]                 NAMES <- toupper(added)
[17:42:47.342]                 for (kk in seq_along(NAMES)) {
[17:42:47.342]                   name <- added[[kk]]
[17:42:47.342]                   NAME <- NAMES[[kk]]
[17:42:47.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.342]                     next
[17:42:47.342]                   args[[name]] <- ""
[17:42:47.342]                 }
[17:42:47.342]                 NAMES <- toupper(removed)
[17:42:47.342]                 for (kk in seq_along(NAMES)) {
[17:42:47.342]                   name <- removed[[kk]]
[17:42:47.342]                   NAME <- NAMES[[kk]]
[17:42:47.342]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.342]                     next
[17:42:47.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.342]                 }
[17:42:47.342]                 if (length(args) > 0) 
[17:42:47.342]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.342]             }
[17:42:47.342]             else {
[17:42:47.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.342]             }
[17:42:47.342]             {
[17:42:47.342]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.342]                   0L) {
[17:42:47.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.342]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.342]                   base::options(opts)
[17:42:47.342]                 }
[17:42:47.342]                 {
[17:42:47.342]                   {
[17:42:47.342]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.342]                     NULL
[17:42:47.342]                   }
[17:42:47.342]                   options(future.plan = NULL)
[17:42:47.342]                   if (is.na(NA_character_)) 
[17:42:47.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.342]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.342]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.342]                     envir = parent.frame()) 
[17:42:47.342]                   {
[17:42:47.342]                     if (is.function(workers)) 
[17:42:47.342]                       workers <- workers()
[17:42:47.342]                     workers <- structure(as.integer(workers), 
[17:42:47.342]                       class = class(workers))
[17:42:47.342]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.342]                       workers >= 1)
[17:42:47.342]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.342]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.342]                     }
[17:42:47.342]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.342]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.342]                       envir = envir)
[17:42:47.342]                     if (!future$lazy) 
[17:42:47.342]                       future <- run(future)
[17:42:47.342]                     invisible(future)
[17:42:47.342]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.342]                 }
[17:42:47.342]             }
[17:42:47.342]         }
[17:42:47.342]     })
[17:42:47.342]     if (TRUE) {
[17:42:47.342]         base::sink(type = "output", split = FALSE)
[17:42:47.342]         if (TRUE) {
[17:42:47.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.342]         }
[17:42:47.342]         else {
[17:42:47.342]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.342]         }
[17:42:47.342]         base::close(...future.stdout)
[17:42:47.342]         ...future.stdout <- NULL
[17:42:47.342]     }
[17:42:47.342]     ...future.result$conditions <- ...future.conditions
[17:42:47.342]     ...future.result$finished <- base::Sys.time()
[17:42:47.342]     ...future.result
[17:42:47.342] }
[17:42:47.345] MultisessionFuture started
[17:42:47.345] - Launch lazy future ... done
[17:42:47.345] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.346] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.346] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.347] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:47.347] Searching for globals ... DONE
[17:42:47.347] Resolving globals: TRUE
[17:42:47.347] Resolving any globals that are futures ...
[17:42:47.347] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:47.347] Resolving any globals that are futures ... DONE
[17:42:47.348] Resolving futures part of globals (recursively) ...
[17:42:47.348] resolve() on list ...
[17:42:47.348]  recursive: 99
[17:42:47.348]  length: 1
[17:42:47.348]  elements: ‘a’
[17:42:47.392] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.392] - Validating connection of MultisessionFuture
[17:42:47.393] - received message: FutureResult
[17:42:47.393] - Received FutureResult
[17:42:47.393] - Erased future from FutureRegistry
[17:42:47.393] result() for ClusterFuture ...
[17:42:47.393] - result already collected: FutureResult
[17:42:47.393] result() for ClusterFuture ... done
[17:42:47.393] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.394] Future #1
[17:42:47.394] result() for ClusterFuture ...
[17:42:47.394] - result already collected: FutureResult
[17:42:47.394] result() for ClusterFuture ... done
[17:42:47.394] result() for ClusterFuture ...
[17:42:47.394] - result already collected: FutureResult
[17:42:47.394] result() for ClusterFuture ... done
[17:42:47.394] A MultisessionFuture was resolved
[17:42:47.394]  length: 0 (resolved future 1)
[17:42:47.395] resolve() on list ... DONE
[17:42:47.395] - globals: [1] ‘a’
[17:42:47.395] Resolving futures part of globals (recursively) ... DONE
[17:42:47.396] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:42:47.396] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:42:47.396] - globals: [1] ‘a’
[17:42:47.396] - packages: [1] ‘future’
[17:42:47.397] getGlobalsAndPackages() ... DONE
[17:42:47.397] run() for ‘Future’ ...
[17:42:47.397] - state: ‘created’
[17:42:47.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.412]   - Field: ‘node’
[17:42:47.412]   - Field: ‘label’
[17:42:47.412]   - Field: ‘local’
[17:42:47.413]   - Field: ‘owner’
[17:42:47.415]   - Field: ‘envir’
[17:42:47.415]   - Field: ‘workers’
[17:42:47.415]   - Field: ‘packages’
[17:42:47.415]   - Field: ‘gc’
[17:42:47.415]   - Field: ‘conditions’
[17:42:47.415]   - Field: ‘persistent’
[17:42:47.415]   - Field: ‘expr’
[17:42:47.415]   - Field: ‘uuid’
[17:42:47.415]   - Field: ‘seed’
[17:42:47.415]   - Field: ‘version’
[17:42:47.415]   - Field: ‘result’
[17:42:47.416]   - Field: ‘asynchronous’
[17:42:47.416]   - Field: ‘calls’
[17:42:47.416]   - Field: ‘globals’
[17:42:47.416]   - Field: ‘stdout’
[17:42:47.416]   - Field: ‘earlySignal’
[17:42:47.416]   - Field: ‘lazy’
[17:42:47.416]   - Field: ‘state’
[17:42:47.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.416] - Launch lazy future ...
[17:42:47.417] Packages needed by the future expression (n = 1): ‘future’
[17:42:47.417] Packages needed by future strategies (n = 0): <none>
[17:42:47.417] {
[17:42:47.417]     {
[17:42:47.417]         {
[17:42:47.417]             ...future.startTime <- base::Sys.time()
[17:42:47.417]             {
[17:42:47.417]                 {
[17:42:47.417]                   {
[17:42:47.417]                     {
[17:42:47.417]                       {
[17:42:47.417]                         base::local({
[17:42:47.417]                           has_future <- base::requireNamespace("future", 
[17:42:47.417]                             quietly = TRUE)
[17:42:47.417]                           if (has_future) {
[17:42:47.417]                             ns <- base::getNamespace("future")
[17:42:47.417]                             version <- ns[[".package"]][["version"]]
[17:42:47.417]                             if (is.null(version)) 
[17:42:47.417]                               version <- utils::packageVersion("future")
[17:42:47.417]                           }
[17:42:47.417]                           else {
[17:42:47.417]                             version <- NULL
[17:42:47.417]                           }
[17:42:47.417]                           if (!has_future || version < "1.8.0") {
[17:42:47.417]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.417]                               "", base::R.version$version.string), 
[17:42:47.417]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:47.417]                                 base::R.version$platform, 8 * 
[17:42:47.417]                                   base::.Machine$sizeof.pointer), 
[17:42:47.417]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.417]                                 "release", "version")], collapse = " "), 
[17:42:47.417]                               hostname = base::Sys.info()[["nodename"]])
[17:42:47.417]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.417]                               info)
[17:42:47.417]                             info <- base::paste(info, collapse = "; ")
[17:42:47.417]                             if (!has_future) {
[17:42:47.417]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.417]                                 info)
[17:42:47.417]                             }
[17:42:47.417]                             else {
[17:42:47.417]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.417]                                 info, version)
[17:42:47.417]                             }
[17:42:47.417]                             base::stop(msg)
[17:42:47.417]                           }
[17:42:47.417]                         })
[17:42:47.417]                       }
[17:42:47.417]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.417]                       base::options(mc.cores = 1L)
[17:42:47.417]                     }
[17:42:47.417]                     base::local({
[17:42:47.417]                       for (pkg in "future") {
[17:42:47.417]                         base::loadNamespace(pkg)
[17:42:47.417]                         base::library(pkg, character.only = TRUE)
[17:42:47.417]                       }
[17:42:47.417]                     })
[17:42:47.417]                   }
[17:42:47.417]                   options(future.plan = NULL)
[17:42:47.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.417]                 }
[17:42:47.417]                 ...future.workdir <- getwd()
[17:42:47.417]             }
[17:42:47.417]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.417]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.417]         }
[17:42:47.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.417]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.417]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.417]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.417]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.417]             base::names(...future.oldOptions))
[17:42:47.417]     }
[17:42:47.417]     if (FALSE) {
[17:42:47.417]     }
[17:42:47.417]     else {
[17:42:47.417]         if (TRUE) {
[17:42:47.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.417]                 open = "w")
[17:42:47.417]         }
[17:42:47.417]         else {
[17:42:47.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.417]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.417]         }
[17:42:47.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.417]             base::sink(type = "output", split = FALSE)
[17:42:47.417]             base::close(...future.stdout)
[17:42:47.417]         }, add = TRUE)
[17:42:47.417]     }
[17:42:47.417]     ...future.frame <- base::sys.nframe()
[17:42:47.417]     ...future.conditions <- base::list()
[17:42:47.417]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.417]     if (FALSE) {
[17:42:47.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.417]     }
[17:42:47.417]     ...future.result <- base::tryCatch({
[17:42:47.417]         base::withCallingHandlers({
[17:42:47.417]             ...future.value <- base::withVisible(base::local({
[17:42:47.417]                 ...future.makeSendCondition <- local({
[17:42:47.417]                   sendCondition <- NULL
[17:42:47.417]                   function(frame = 1L) {
[17:42:47.417]                     if (is.function(sendCondition)) 
[17:42:47.417]                       return(sendCondition)
[17:42:47.417]                     ns <- getNamespace("parallel")
[17:42:47.417]                     if (exists("sendData", mode = "function", 
[17:42:47.417]                       envir = ns)) {
[17:42:47.417]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.417]                         envir = ns)
[17:42:47.417]                       envir <- sys.frame(frame)
[17:42:47.417]                       master <- NULL
[17:42:47.417]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.417]                         !identical(envir, emptyenv())) {
[17:42:47.417]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.417]                           inherits = FALSE)) {
[17:42:47.417]                           master <- get("master", mode = "list", 
[17:42:47.417]                             envir = envir, inherits = FALSE)
[17:42:47.417]                           if (inherits(master, c("SOCKnode", 
[17:42:47.417]                             "SOCK0node"))) {
[17:42:47.417]                             sendCondition <<- function(cond) {
[17:42:47.417]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.417]                                 success = TRUE)
[17:42:47.417]                               parallel_sendData(master, data)
[17:42:47.417]                             }
[17:42:47.417]                             return(sendCondition)
[17:42:47.417]                           }
[17:42:47.417]                         }
[17:42:47.417]                         frame <- frame + 1L
[17:42:47.417]                         envir <- sys.frame(frame)
[17:42:47.417]                       }
[17:42:47.417]                     }
[17:42:47.417]                     sendCondition <<- function(cond) NULL
[17:42:47.417]                   }
[17:42:47.417]                 })
[17:42:47.417]                 withCallingHandlers({
[17:42:47.417]                   value(a) + 1
[17:42:47.417]                 }, immediateCondition = function(cond) {
[17:42:47.417]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.417]                   sendCondition(cond)
[17:42:47.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.417]                   {
[17:42:47.417]                     inherits <- base::inherits
[17:42:47.417]                     invokeRestart <- base::invokeRestart
[17:42:47.417]                     is.null <- base::is.null
[17:42:47.417]                     muffled <- FALSE
[17:42:47.417]                     if (inherits(cond, "message")) {
[17:42:47.417]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.417]                       if (muffled) 
[17:42:47.417]                         invokeRestart("muffleMessage")
[17:42:47.417]                     }
[17:42:47.417]                     else if (inherits(cond, "warning")) {
[17:42:47.417]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.417]                       if (muffled) 
[17:42:47.417]                         invokeRestart("muffleWarning")
[17:42:47.417]                     }
[17:42:47.417]                     else if (inherits(cond, "condition")) {
[17:42:47.417]                       if (!is.null(pattern)) {
[17:42:47.417]                         computeRestarts <- base::computeRestarts
[17:42:47.417]                         grepl <- base::grepl
[17:42:47.417]                         restarts <- computeRestarts(cond)
[17:42:47.417]                         for (restart in restarts) {
[17:42:47.417]                           name <- restart$name
[17:42:47.417]                           if (is.null(name)) 
[17:42:47.417]                             next
[17:42:47.417]                           if (!grepl(pattern, name)) 
[17:42:47.417]                             next
[17:42:47.417]                           invokeRestart(restart)
[17:42:47.417]                           muffled <- TRUE
[17:42:47.417]                           break
[17:42:47.417]                         }
[17:42:47.417]                       }
[17:42:47.417]                     }
[17:42:47.417]                     invisible(muffled)
[17:42:47.417]                   }
[17:42:47.417]                   muffleCondition(cond)
[17:42:47.417]                 })
[17:42:47.417]             }))
[17:42:47.417]             future::FutureResult(value = ...future.value$value, 
[17:42:47.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.417]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.417]                     ...future.globalenv.names))
[17:42:47.417]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.417]         }, condition = base::local({
[17:42:47.417]             c <- base::c
[17:42:47.417]             inherits <- base::inherits
[17:42:47.417]             invokeRestart <- base::invokeRestart
[17:42:47.417]             length <- base::length
[17:42:47.417]             list <- base::list
[17:42:47.417]             seq.int <- base::seq.int
[17:42:47.417]             signalCondition <- base::signalCondition
[17:42:47.417]             sys.calls <- base::sys.calls
[17:42:47.417]             `[[` <- base::`[[`
[17:42:47.417]             `+` <- base::`+`
[17:42:47.417]             `<<-` <- base::`<<-`
[17:42:47.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.417]                   3L)]
[17:42:47.417]             }
[17:42:47.417]             function(cond) {
[17:42:47.417]                 is_error <- inherits(cond, "error")
[17:42:47.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.417]                   NULL)
[17:42:47.417]                 if (is_error) {
[17:42:47.417]                   sessionInformation <- function() {
[17:42:47.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.417]                       search = base::search(), system = base::Sys.info())
[17:42:47.417]                   }
[17:42:47.417]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.417]                     cond$call), session = sessionInformation(), 
[17:42:47.417]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.417]                   signalCondition(cond)
[17:42:47.417]                 }
[17:42:47.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.417]                 "immediateCondition"))) {
[17:42:47.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.417]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.417]                   if (TRUE && !signal) {
[17:42:47.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.417]                     {
[17:42:47.417]                       inherits <- base::inherits
[17:42:47.417]                       invokeRestart <- base::invokeRestart
[17:42:47.417]                       is.null <- base::is.null
[17:42:47.417]                       muffled <- FALSE
[17:42:47.417]                       if (inherits(cond, "message")) {
[17:42:47.417]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.417]                         if (muffled) 
[17:42:47.417]                           invokeRestart("muffleMessage")
[17:42:47.417]                       }
[17:42:47.417]                       else if (inherits(cond, "warning")) {
[17:42:47.417]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.417]                         if (muffled) 
[17:42:47.417]                           invokeRestart("muffleWarning")
[17:42:47.417]                       }
[17:42:47.417]                       else if (inherits(cond, "condition")) {
[17:42:47.417]                         if (!is.null(pattern)) {
[17:42:47.417]                           computeRestarts <- base::computeRestarts
[17:42:47.417]                           grepl <- base::grepl
[17:42:47.417]                           restarts <- computeRestarts(cond)
[17:42:47.417]                           for (restart in restarts) {
[17:42:47.417]                             name <- restart$name
[17:42:47.417]                             if (is.null(name)) 
[17:42:47.417]                               next
[17:42:47.417]                             if (!grepl(pattern, name)) 
[17:42:47.417]                               next
[17:42:47.417]                             invokeRestart(restart)
[17:42:47.417]                             muffled <- TRUE
[17:42:47.417]                             break
[17:42:47.417]                           }
[17:42:47.417]                         }
[17:42:47.417]                       }
[17:42:47.417]                       invisible(muffled)
[17:42:47.417]                     }
[17:42:47.417]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.417]                   }
[17:42:47.417]                 }
[17:42:47.417]                 else {
[17:42:47.417]                   if (TRUE) {
[17:42:47.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.417]                     {
[17:42:47.417]                       inherits <- base::inherits
[17:42:47.417]                       invokeRestart <- base::invokeRestart
[17:42:47.417]                       is.null <- base::is.null
[17:42:47.417]                       muffled <- FALSE
[17:42:47.417]                       if (inherits(cond, "message")) {
[17:42:47.417]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.417]                         if (muffled) 
[17:42:47.417]                           invokeRestart("muffleMessage")
[17:42:47.417]                       }
[17:42:47.417]                       else if (inherits(cond, "warning")) {
[17:42:47.417]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.417]                         if (muffled) 
[17:42:47.417]                           invokeRestart("muffleWarning")
[17:42:47.417]                       }
[17:42:47.417]                       else if (inherits(cond, "condition")) {
[17:42:47.417]                         if (!is.null(pattern)) {
[17:42:47.417]                           computeRestarts <- base::computeRestarts
[17:42:47.417]                           grepl <- base::grepl
[17:42:47.417]                           restarts <- computeRestarts(cond)
[17:42:47.417]                           for (restart in restarts) {
[17:42:47.417]                             name <- restart$name
[17:42:47.417]                             if (is.null(name)) 
[17:42:47.417]                               next
[17:42:47.417]                             if (!grepl(pattern, name)) 
[17:42:47.417]                               next
[17:42:47.417]                             invokeRestart(restart)
[17:42:47.417]                             muffled <- TRUE
[17:42:47.417]                             break
[17:42:47.417]                           }
[17:42:47.417]                         }
[17:42:47.417]                       }
[17:42:47.417]                       invisible(muffled)
[17:42:47.417]                     }
[17:42:47.417]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.417]                   }
[17:42:47.417]                 }
[17:42:47.417]             }
[17:42:47.417]         }))
[17:42:47.417]     }, error = function(ex) {
[17:42:47.417]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.417]                 ...future.rng), started = ...future.startTime, 
[17:42:47.417]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.417]             version = "1.8"), class = "FutureResult")
[17:42:47.417]     }, finally = {
[17:42:47.417]         if (!identical(...future.workdir, getwd())) 
[17:42:47.417]             setwd(...future.workdir)
[17:42:47.417]         {
[17:42:47.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.417]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.417]             }
[17:42:47.417]             base::options(...future.oldOptions)
[17:42:47.417]             if (.Platform$OS.type == "windows") {
[17:42:47.417]                 old_names <- names(...future.oldEnvVars)
[17:42:47.417]                 envs <- base::Sys.getenv()
[17:42:47.417]                 names <- names(envs)
[17:42:47.417]                 common <- intersect(names, old_names)
[17:42:47.417]                 added <- setdiff(names, old_names)
[17:42:47.417]                 removed <- setdiff(old_names, names)
[17:42:47.417]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.417]                   envs[common]]
[17:42:47.417]                 NAMES <- toupper(changed)
[17:42:47.417]                 args <- list()
[17:42:47.417]                 for (kk in seq_along(NAMES)) {
[17:42:47.417]                   name <- changed[[kk]]
[17:42:47.417]                   NAME <- NAMES[[kk]]
[17:42:47.417]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.417]                     next
[17:42:47.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.417]                 }
[17:42:47.417]                 NAMES <- toupper(added)
[17:42:47.417]                 for (kk in seq_along(NAMES)) {
[17:42:47.417]                   name <- added[[kk]]
[17:42:47.417]                   NAME <- NAMES[[kk]]
[17:42:47.417]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.417]                     next
[17:42:47.417]                   args[[name]] <- ""
[17:42:47.417]                 }
[17:42:47.417]                 NAMES <- toupper(removed)
[17:42:47.417]                 for (kk in seq_along(NAMES)) {
[17:42:47.417]                   name <- removed[[kk]]
[17:42:47.417]                   NAME <- NAMES[[kk]]
[17:42:47.417]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.417]                     next
[17:42:47.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.417]                 }
[17:42:47.417]                 if (length(args) > 0) 
[17:42:47.417]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.417]             }
[17:42:47.417]             else {
[17:42:47.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.417]             }
[17:42:47.417]             {
[17:42:47.417]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.417]                   0L) {
[17:42:47.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.417]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.417]                   base::options(opts)
[17:42:47.417]                 }
[17:42:47.417]                 {
[17:42:47.417]                   {
[17:42:47.417]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.417]                     NULL
[17:42:47.417]                   }
[17:42:47.417]                   options(future.plan = NULL)
[17:42:47.417]                   if (is.na(NA_character_)) 
[17:42:47.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.417]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.417]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.417]                     envir = parent.frame()) 
[17:42:47.417]                   {
[17:42:47.417]                     if (is.function(workers)) 
[17:42:47.417]                       workers <- workers()
[17:42:47.417]                     workers <- structure(as.integer(workers), 
[17:42:47.417]                       class = class(workers))
[17:42:47.417]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.417]                       workers >= 1)
[17:42:47.417]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.417]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.417]                     }
[17:42:47.417]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.417]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.417]                       envir = envir)
[17:42:47.417]                     if (!future$lazy) 
[17:42:47.417]                       future <- run(future)
[17:42:47.417]                     invisible(future)
[17:42:47.417]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.417]                 }
[17:42:47.417]             }
[17:42:47.417]         }
[17:42:47.417]     })
[17:42:47.417]     if (TRUE) {
[17:42:47.417]         base::sink(type = "output", split = FALSE)
[17:42:47.417]         if (TRUE) {
[17:42:47.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.417]         }
[17:42:47.417]         else {
[17:42:47.417]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.417]         }
[17:42:47.417]         base::close(...future.stdout)
[17:42:47.417]         ...future.stdout <- NULL
[17:42:47.417]     }
[17:42:47.417]     ...future.result$conditions <- ...future.conditions
[17:42:47.417]     ...future.result$finished <- base::Sys.time()
[17:42:47.417]     ...future.result
[17:42:47.417] }
[17:42:47.420] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:42:47.421] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:42:47.471] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:42:47.472] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:42:47.472] MultisessionFuture started
[17:42:47.473] - Launch lazy future ... done
[17:42:47.473] run() for ‘MultisessionFuture’ ... done
[17:42:47.473] result() for ClusterFuture ...
[17:42:47.473] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.473] - Validating connection of MultisessionFuture
[17:42:47.524] - received message: FutureResult
[17:42:47.525] - Received FutureResult
[17:42:47.525] - Erased future from FutureRegistry
[17:42:47.525] result() for ClusterFuture ...
[17:42:47.525] - result already collected: FutureResult
[17:42:47.525] result() for ClusterFuture ... done
[17:42:47.525] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.525] result() for ClusterFuture ... done
[17:42:47.525] result() for ClusterFuture ...
[17:42:47.526] - result already collected: FutureResult
[17:42:47.526] result() for ClusterFuture ... done
value(b) = 2
[17:42:47.526] result() for ClusterFuture ...
[17:42:47.526] - result already collected: FutureResult
[17:42:47.526] result() for ClusterFuture ... done
[17:42:47.526] result() for ClusterFuture ...
[17:42:47.526] - result already collected: FutureResult
[17:42:47.526] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.527] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.527] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.527] 
[17:42:47.528] Searching for globals ... DONE
[17:42:47.528] - globals: [0] <none>
[17:42:47.528] getGlobalsAndPackages() ... DONE
[17:42:47.528] run() for ‘Future’ ...
[17:42:47.528] - state: ‘created’
[17:42:47.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.543] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.543]   - Field: ‘node’
[17:42:47.543]   - Field: ‘label’
[17:42:47.543]   - Field: ‘local’
[17:42:47.543]   - Field: ‘owner’
[17:42:47.543]   - Field: ‘envir’
[17:42:47.544]   - Field: ‘workers’
[17:42:47.544]   - Field: ‘packages’
[17:42:47.544]   - Field: ‘gc’
[17:42:47.544]   - Field: ‘conditions’
[17:42:47.544]   - Field: ‘persistent’
[17:42:47.544]   - Field: ‘expr’
[17:42:47.544]   - Field: ‘uuid’
[17:42:47.544]   - Field: ‘seed’
[17:42:47.544]   - Field: ‘version’
[17:42:47.544]   - Field: ‘result’
[17:42:47.544]   - Field: ‘asynchronous’
[17:42:47.545]   - Field: ‘calls’
[17:42:47.545]   - Field: ‘globals’
[17:42:47.545]   - Field: ‘stdout’
[17:42:47.545]   - Field: ‘earlySignal’
[17:42:47.545]   - Field: ‘lazy’
[17:42:47.545]   - Field: ‘state’
[17:42:47.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.545] - Launch lazy future ...
[17:42:47.545] Packages needed by the future expression (n = 0): <none>
[17:42:47.546] Packages needed by future strategies (n = 0): <none>
[17:42:47.546] {
[17:42:47.546]     {
[17:42:47.546]         {
[17:42:47.546]             ...future.startTime <- base::Sys.time()
[17:42:47.546]             {
[17:42:47.546]                 {
[17:42:47.546]                   {
[17:42:47.546]                     {
[17:42:47.546]                       base::local({
[17:42:47.546]                         has_future <- base::requireNamespace("future", 
[17:42:47.546]                           quietly = TRUE)
[17:42:47.546]                         if (has_future) {
[17:42:47.546]                           ns <- base::getNamespace("future")
[17:42:47.546]                           version <- ns[[".package"]][["version"]]
[17:42:47.546]                           if (is.null(version)) 
[17:42:47.546]                             version <- utils::packageVersion("future")
[17:42:47.546]                         }
[17:42:47.546]                         else {
[17:42:47.546]                           version <- NULL
[17:42:47.546]                         }
[17:42:47.546]                         if (!has_future || version < "1.8.0") {
[17:42:47.546]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.546]                             "", base::R.version$version.string), 
[17:42:47.546]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.546]                               "release", "version")], collapse = " "), 
[17:42:47.546]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.546]                             info)
[17:42:47.546]                           info <- base::paste(info, collapse = "; ")
[17:42:47.546]                           if (!has_future) {
[17:42:47.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.546]                               info)
[17:42:47.546]                           }
[17:42:47.546]                           else {
[17:42:47.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.546]                               info, version)
[17:42:47.546]                           }
[17:42:47.546]                           base::stop(msg)
[17:42:47.546]                         }
[17:42:47.546]                       })
[17:42:47.546]                     }
[17:42:47.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.546]                     base::options(mc.cores = 1L)
[17:42:47.546]                   }
[17:42:47.546]                   options(future.plan = NULL)
[17:42:47.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.546]                 }
[17:42:47.546]                 ...future.workdir <- getwd()
[17:42:47.546]             }
[17:42:47.546]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.546]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.546]         }
[17:42:47.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.546]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.546]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.546]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.546]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.546]             base::names(...future.oldOptions))
[17:42:47.546]     }
[17:42:47.546]     if (FALSE) {
[17:42:47.546]     }
[17:42:47.546]     else {
[17:42:47.546]         if (TRUE) {
[17:42:47.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.546]                 open = "w")
[17:42:47.546]         }
[17:42:47.546]         else {
[17:42:47.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.546]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.546]         }
[17:42:47.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.546]             base::sink(type = "output", split = FALSE)
[17:42:47.546]             base::close(...future.stdout)
[17:42:47.546]         }, add = TRUE)
[17:42:47.546]     }
[17:42:47.546]     ...future.frame <- base::sys.nframe()
[17:42:47.546]     ...future.conditions <- base::list()
[17:42:47.546]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.546]     if (FALSE) {
[17:42:47.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.546]     }
[17:42:47.546]     ...future.result <- base::tryCatch({
[17:42:47.546]         base::withCallingHandlers({
[17:42:47.546]             ...future.value <- base::withVisible(base::local({
[17:42:47.546]                 ...future.makeSendCondition <- local({
[17:42:47.546]                   sendCondition <- NULL
[17:42:47.546]                   function(frame = 1L) {
[17:42:47.546]                     if (is.function(sendCondition)) 
[17:42:47.546]                       return(sendCondition)
[17:42:47.546]                     ns <- getNamespace("parallel")
[17:42:47.546]                     if (exists("sendData", mode = "function", 
[17:42:47.546]                       envir = ns)) {
[17:42:47.546]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.546]                         envir = ns)
[17:42:47.546]                       envir <- sys.frame(frame)
[17:42:47.546]                       master <- NULL
[17:42:47.546]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.546]                         !identical(envir, emptyenv())) {
[17:42:47.546]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.546]                           inherits = FALSE)) {
[17:42:47.546]                           master <- get("master", mode = "list", 
[17:42:47.546]                             envir = envir, inherits = FALSE)
[17:42:47.546]                           if (inherits(master, c("SOCKnode", 
[17:42:47.546]                             "SOCK0node"))) {
[17:42:47.546]                             sendCondition <<- function(cond) {
[17:42:47.546]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.546]                                 success = TRUE)
[17:42:47.546]                               parallel_sendData(master, data)
[17:42:47.546]                             }
[17:42:47.546]                             return(sendCondition)
[17:42:47.546]                           }
[17:42:47.546]                         }
[17:42:47.546]                         frame <- frame + 1L
[17:42:47.546]                         envir <- sys.frame(frame)
[17:42:47.546]                       }
[17:42:47.546]                     }
[17:42:47.546]                     sendCondition <<- function(cond) NULL
[17:42:47.546]                   }
[17:42:47.546]                 })
[17:42:47.546]                 withCallingHandlers({
[17:42:47.546]                   1
[17:42:47.546]                 }, immediateCondition = function(cond) {
[17:42:47.546]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.546]                   sendCondition(cond)
[17:42:47.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.546]                   {
[17:42:47.546]                     inherits <- base::inherits
[17:42:47.546]                     invokeRestart <- base::invokeRestart
[17:42:47.546]                     is.null <- base::is.null
[17:42:47.546]                     muffled <- FALSE
[17:42:47.546]                     if (inherits(cond, "message")) {
[17:42:47.546]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.546]                       if (muffled) 
[17:42:47.546]                         invokeRestart("muffleMessage")
[17:42:47.546]                     }
[17:42:47.546]                     else if (inherits(cond, "warning")) {
[17:42:47.546]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.546]                       if (muffled) 
[17:42:47.546]                         invokeRestart("muffleWarning")
[17:42:47.546]                     }
[17:42:47.546]                     else if (inherits(cond, "condition")) {
[17:42:47.546]                       if (!is.null(pattern)) {
[17:42:47.546]                         computeRestarts <- base::computeRestarts
[17:42:47.546]                         grepl <- base::grepl
[17:42:47.546]                         restarts <- computeRestarts(cond)
[17:42:47.546]                         for (restart in restarts) {
[17:42:47.546]                           name <- restart$name
[17:42:47.546]                           if (is.null(name)) 
[17:42:47.546]                             next
[17:42:47.546]                           if (!grepl(pattern, name)) 
[17:42:47.546]                             next
[17:42:47.546]                           invokeRestart(restart)
[17:42:47.546]                           muffled <- TRUE
[17:42:47.546]                           break
[17:42:47.546]                         }
[17:42:47.546]                       }
[17:42:47.546]                     }
[17:42:47.546]                     invisible(muffled)
[17:42:47.546]                   }
[17:42:47.546]                   muffleCondition(cond)
[17:42:47.546]                 })
[17:42:47.546]             }))
[17:42:47.546]             future::FutureResult(value = ...future.value$value, 
[17:42:47.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.546]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.546]                     ...future.globalenv.names))
[17:42:47.546]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.546]         }, condition = base::local({
[17:42:47.546]             c <- base::c
[17:42:47.546]             inherits <- base::inherits
[17:42:47.546]             invokeRestart <- base::invokeRestart
[17:42:47.546]             length <- base::length
[17:42:47.546]             list <- base::list
[17:42:47.546]             seq.int <- base::seq.int
[17:42:47.546]             signalCondition <- base::signalCondition
[17:42:47.546]             sys.calls <- base::sys.calls
[17:42:47.546]             `[[` <- base::`[[`
[17:42:47.546]             `+` <- base::`+`
[17:42:47.546]             `<<-` <- base::`<<-`
[17:42:47.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.546]                   3L)]
[17:42:47.546]             }
[17:42:47.546]             function(cond) {
[17:42:47.546]                 is_error <- inherits(cond, "error")
[17:42:47.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.546]                   NULL)
[17:42:47.546]                 if (is_error) {
[17:42:47.546]                   sessionInformation <- function() {
[17:42:47.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.546]                       search = base::search(), system = base::Sys.info())
[17:42:47.546]                   }
[17:42:47.546]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.546]                     cond$call), session = sessionInformation(), 
[17:42:47.546]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.546]                   signalCondition(cond)
[17:42:47.546]                 }
[17:42:47.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.546]                 "immediateCondition"))) {
[17:42:47.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.546]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.546]                   if (TRUE && !signal) {
[17:42:47.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.546]                     {
[17:42:47.546]                       inherits <- base::inherits
[17:42:47.546]                       invokeRestart <- base::invokeRestart
[17:42:47.546]                       is.null <- base::is.null
[17:42:47.546]                       muffled <- FALSE
[17:42:47.546]                       if (inherits(cond, "message")) {
[17:42:47.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.546]                         if (muffled) 
[17:42:47.546]                           invokeRestart("muffleMessage")
[17:42:47.546]                       }
[17:42:47.546]                       else if (inherits(cond, "warning")) {
[17:42:47.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.546]                         if (muffled) 
[17:42:47.546]                           invokeRestart("muffleWarning")
[17:42:47.546]                       }
[17:42:47.546]                       else if (inherits(cond, "condition")) {
[17:42:47.546]                         if (!is.null(pattern)) {
[17:42:47.546]                           computeRestarts <- base::computeRestarts
[17:42:47.546]                           grepl <- base::grepl
[17:42:47.546]                           restarts <- computeRestarts(cond)
[17:42:47.546]                           for (restart in restarts) {
[17:42:47.546]                             name <- restart$name
[17:42:47.546]                             if (is.null(name)) 
[17:42:47.546]                               next
[17:42:47.546]                             if (!grepl(pattern, name)) 
[17:42:47.546]                               next
[17:42:47.546]                             invokeRestart(restart)
[17:42:47.546]                             muffled <- TRUE
[17:42:47.546]                             break
[17:42:47.546]                           }
[17:42:47.546]                         }
[17:42:47.546]                       }
[17:42:47.546]                       invisible(muffled)
[17:42:47.546]                     }
[17:42:47.546]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.546]                   }
[17:42:47.546]                 }
[17:42:47.546]                 else {
[17:42:47.546]                   if (TRUE) {
[17:42:47.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.546]                     {
[17:42:47.546]                       inherits <- base::inherits
[17:42:47.546]                       invokeRestart <- base::invokeRestart
[17:42:47.546]                       is.null <- base::is.null
[17:42:47.546]                       muffled <- FALSE
[17:42:47.546]                       if (inherits(cond, "message")) {
[17:42:47.546]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.546]                         if (muffled) 
[17:42:47.546]                           invokeRestart("muffleMessage")
[17:42:47.546]                       }
[17:42:47.546]                       else if (inherits(cond, "warning")) {
[17:42:47.546]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.546]                         if (muffled) 
[17:42:47.546]                           invokeRestart("muffleWarning")
[17:42:47.546]                       }
[17:42:47.546]                       else if (inherits(cond, "condition")) {
[17:42:47.546]                         if (!is.null(pattern)) {
[17:42:47.546]                           computeRestarts <- base::computeRestarts
[17:42:47.546]                           grepl <- base::grepl
[17:42:47.546]                           restarts <- computeRestarts(cond)
[17:42:47.546]                           for (restart in restarts) {
[17:42:47.546]                             name <- restart$name
[17:42:47.546]                             if (is.null(name)) 
[17:42:47.546]                               next
[17:42:47.546]                             if (!grepl(pattern, name)) 
[17:42:47.546]                               next
[17:42:47.546]                             invokeRestart(restart)
[17:42:47.546]                             muffled <- TRUE
[17:42:47.546]                             break
[17:42:47.546]                           }
[17:42:47.546]                         }
[17:42:47.546]                       }
[17:42:47.546]                       invisible(muffled)
[17:42:47.546]                     }
[17:42:47.546]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.546]                   }
[17:42:47.546]                 }
[17:42:47.546]             }
[17:42:47.546]         }))
[17:42:47.546]     }, error = function(ex) {
[17:42:47.546]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.546]                 ...future.rng), started = ...future.startTime, 
[17:42:47.546]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.546]             version = "1.8"), class = "FutureResult")
[17:42:47.546]     }, finally = {
[17:42:47.546]         if (!identical(...future.workdir, getwd())) 
[17:42:47.546]             setwd(...future.workdir)
[17:42:47.546]         {
[17:42:47.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.546]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.546]             }
[17:42:47.546]             base::options(...future.oldOptions)
[17:42:47.546]             if (.Platform$OS.type == "windows") {
[17:42:47.546]                 old_names <- names(...future.oldEnvVars)
[17:42:47.546]                 envs <- base::Sys.getenv()
[17:42:47.546]                 names <- names(envs)
[17:42:47.546]                 common <- intersect(names, old_names)
[17:42:47.546]                 added <- setdiff(names, old_names)
[17:42:47.546]                 removed <- setdiff(old_names, names)
[17:42:47.546]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.546]                   envs[common]]
[17:42:47.546]                 NAMES <- toupper(changed)
[17:42:47.546]                 args <- list()
[17:42:47.546]                 for (kk in seq_along(NAMES)) {
[17:42:47.546]                   name <- changed[[kk]]
[17:42:47.546]                   NAME <- NAMES[[kk]]
[17:42:47.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.546]                     next
[17:42:47.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.546]                 }
[17:42:47.546]                 NAMES <- toupper(added)
[17:42:47.546]                 for (kk in seq_along(NAMES)) {
[17:42:47.546]                   name <- added[[kk]]
[17:42:47.546]                   NAME <- NAMES[[kk]]
[17:42:47.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.546]                     next
[17:42:47.546]                   args[[name]] <- ""
[17:42:47.546]                 }
[17:42:47.546]                 NAMES <- toupper(removed)
[17:42:47.546]                 for (kk in seq_along(NAMES)) {
[17:42:47.546]                   name <- removed[[kk]]
[17:42:47.546]                   NAME <- NAMES[[kk]]
[17:42:47.546]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.546]                     next
[17:42:47.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.546]                 }
[17:42:47.546]                 if (length(args) > 0) 
[17:42:47.546]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.546]             }
[17:42:47.546]             else {
[17:42:47.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.546]             }
[17:42:47.546]             {
[17:42:47.546]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.546]                   0L) {
[17:42:47.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.546]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.546]                   base::options(opts)
[17:42:47.546]                 }
[17:42:47.546]                 {
[17:42:47.546]                   {
[17:42:47.546]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.546]                     NULL
[17:42:47.546]                   }
[17:42:47.546]                   options(future.plan = NULL)
[17:42:47.546]                   if (is.na(NA_character_)) 
[17:42:47.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.546]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.546]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.546]                     envir = parent.frame()) 
[17:42:47.546]                   {
[17:42:47.546]                     if (is.function(workers)) 
[17:42:47.546]                       workers <- workers()
[17:42:47.546]                     workers <- structure(as.integer(workers), 
[17:42:47.546]                       class = class(workers))
[17:42:47.546]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.546]                       workers >= 1)
[17:42:47.546]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.546]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.546]                     }
[17:42:47.546]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.546]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.546]                       envir = envir)
[17:42:47.546]                     if (!future$lazy) 
[17:42:47.546]                       future <- run(future)
[17:42:47.546]                     invisible(future)
[17:42:47.546]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.546]                 }
[17:42:47.546]             }
[17:42:47.546]         }
[17:42:47.546]     })
[17:42:47.546]     if (TRUE) {
[17:42:47.546]         base::sink(type = "output", split = FALSE)
[17:42:47.546]         if (TRUE) {
[17:42:47.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.546]         }
[17:42:47.546]         else {
[17:42:47.546]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.546]         }
[17:42:47.546]         base::close(...future.stdout)
[17:42:47.546]         ...future.stdout <- NULL
[17:42:47.546]     }
[17:42:47.546]     ...future.result$conditions <- ...future.conditions
[17:42:47.546]     ...future.result$finished <- base::Sys.time()
[17:42:47.546]     ...future.result
[17:42:47.546] }
[17:42:47.549] MultisessionFuture started
[17:42:47.549] - Launch lazy future ... done
[17:42:47.549] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.550] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.550] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.551] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:47.551] Searching for globals ... DONE
[17:42:47.551] Resolving globals: TRUE
[17:42:47.551] Resolving any globals that are futures ...
[17:42:47.551] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:47.551] Resolving any globals that are futures ... DONE
[17:42:47.552] Resolving futures part of globals (recursively) ...
[17:42:47.552] resolve() on list ...
[17:42:47.552]  recursive: 99
[17:42:47.552]  length: 1
[17:42:47.552]  elements: ‘a’
[17:42:47.596] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.597] - Validating connection of MultisessionFuture
[17:42:47.597] - received message: FutureResult
[17:42:47.597] - Received FutureResult
[17:42:47.597] - Erased future from FutureRegistry
[17:42:47.597] result() for ClusterFuture ...
[17:42:47.597] - result already collected: FutureResult
[17:42:47.597] result() for ClusterFuture ... done
[17:42:47.598] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.598] Future #1
[17:42:47.598] result() for ClusterFuture ...
[17:42:47.598] - result already collected: FutureResult
[17:42:47.598] result() for ClusterFuture ... done
[17:42:47.598] result() for ClusterFuture ...
[17:42:47.598] - result already collected: FutureResult
[17:42:47.598] result() for ClusterFuture ... done
[17:42:47.598] A MultisessionFuture was resolved
[17:42:47.598]  length: 0 (resolved future 1)
[17:42:47.599] resolve() on list ... DONE
[17:42:47.599] - globals: [1] ‘a’
[17:42:47.599] Resolving futures part of globals (recursively) ... DONE
[17:42:47.600] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[17:42:47.600] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[17:42:47.600] - globals: [1] ‘a’
[17:42:47.601] - packages: [1] ‘future’
[17:42:47.601] getGlobalsAndPackages() ... DONE
[17:42:47.601] run() for ‘Future’ ...
[17:42:47.601] - state: ‘created’
[17:42:47.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.616] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.616]   - Field: ‘node’
[17:42:47.616]   - Field: ‘label’
[17:42:47.616]   - Field: ‘local’
[17:42:47.616]   - Field: ‘owner’
[17:42:47.616]   - Field: ‘envir’
[17:42:47.616]   - Field: ‘workers’
[17:42:47.617]   - Field: ‘packages’
[17:42:47.617]   - Field: ‘gc’
[17:42:47.617]   - Field: ‘conditions’
[17:42:47.617]   - Field: ‘persistent’
[17:42:47.617]   - Field: ‘expr’
[17:42:47.617]   - Field: ‘uuid’
[17:42:47.617]   - Field: ‘seed’
[17:42:47.617]   - Field: ‘version’
[17:42:47.617]   - Field: ‘result’
[17:42:47.617]   - Field: ‘asynchronous’
[17:42:47.617]   - Field: ‘calls’
[17:42:47.618]   - Field: ‘globals’
[17:42:47.618]   - Field: ‘stdout’
[17:42:47.618]   - Field: ‘earlySignal’
[17:42:47.618]   - Field: ‘lazy’
[17:42:47.618]   - Field: ‘state’
[17:42:47.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.618] - Launch lazy future ...
[17:42:47.618] Packages needed by the future expression (n = 1): ‘future’
[17:42:47.619] Packages needed by future strategies (n = 0): <none>
[17:42:47.619] {
[17:42:47.619]     {
[17:42:47.619]         {
[17:42:47.619]             ...future.startTime <- base::Sys.time()
[17:42:47.619]             {
[17:42:47.619]                 {
[17:42:47.619]                   {
[17:42:47.619]                     {
[17:42:47.619]                       {
[17:42:47.619]                         base::local({
[17:42:47.619]                           has_future <- base::requireNamespace("future", 
[17:42:47.619]                             quietly = TRUE)
[17:42:47.619]                           if (has_future) {
[17:42:47.619]                             ns <- base::getNamespace("future")
[17:42:47.619]                             version <- ns[[".package"]][["version"]]
[17:42:47.619]                             if (is.null(version)) 
[17:42:47.619]                               version <- utils::packageVersion("future")
[17:42:47.619]                           }
[17:42:47.619]                           else {
[17:42:47.619]                             version <- NULL
[17:42:47.619]                           }
[17:42:47.619]                           if (!has_future || version < "1.8.0") {
[17:42:47.619]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.619]                               "", base::R.version$version.string), 
[17:42:47.619]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:47.619]                                 base::R.version$platform, 8 * 
[17:42:47.619]                                   base::.Machine$sizeof.pointer), 
[17:42:47.619]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.619]                                 "release", "version")], collapse = " "), 
[17:42:47.619]                               hostname = base::Sys.info()[["nodename"]])
[17:42:47.619]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.619]                               info)
[17:42:47.619]                             info <- base::paste(info, collapse = "; ")
[17:42:47.619]                             if (!has_future) {
[17:42:47.619]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.619]                                 info)
[17:42:47.619]                             }
[17:42:47.619]                             else {
[17:42:47.619]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.619]                                 info, version)
[17:42:47.619]                             }
[17:42:47.619]                             base::stop(msg)
[17:42:47.619]                           }
[17:42:47.619]                         })
[17:42:47.619]                       }
[17:42:47.619]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.619]                       base::options(mc.cores = 1L)
[17:42:47.619]                     }
[17:42:47.619]                     base::local({
[17:42:47.619]                       for (pkg in "future") {
[17:42:47.619]                         base::loadNamespace(pkg)
[17:42:47.619]                         base::library(pkg, character.only = TRUE)
[17:42:47.619]                       }
[17:42:47.619]                     })
[17:42:47.619]                   }
[17:42:47.619]                   options(future.plan = NULL)
[17:42:47.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.619]                 }
[17:42:47.619]                 ...future.workdir <- getwd()
[17:42:47.619]             }
[17:42:47.619]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.619]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.619]         }
[17:42:47.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.619]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.619]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.619]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.619]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.619]             base::names(...future.oldOptions))
[17:42:47.619]     }
[17:42:47.619]     if (FALSE) {
[17:42:47.619]     }
[17:42:47.619]     else {
[17:42:47.619]         if (TRUE) {
[17:42:47.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.619]                 open = "w")
[17:42:47.619]         }
[17:42:47.619]         else {
[17:42:47.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.619]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.619]         }
[17:42:47.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.619]             base::sink(type = "output", split = FALSE)
[17:42:47.619]             base::close(...future.stdout)
[17:42:47.619]         }, add = TRUE)
[17:42:47.619]     }
[17:42:47.619]     ...future.frame <- base::sys.nframe()
[17:42:47.619]     ...future.conditions <- base::list()
[17:42:47.619]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.619]     if (FALSE) {
[17:42:47.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.619]     }
[17:42:47.619]     ...future.result <- base::tryCatch({
[17:42:47.619]         base::withCallingHandlers({
[17:42:47.619]             ...future.value <- base::withVisible(base::local({
[17:42:47.619]                 ...future.makeSendCondition <- local({
[17:42:47.619]                   sendCondition <- NULL
[17:42:47.619]                   function(frame = 1L) {
[17:42:47.619]                     if (is.function(sendCondition)) 
[17:42:47.619]                       return(sendCondition)
[17:42:47.619]                     ns <- getNamespace("parallel")
[17:42:47.619]                     if (exists("sendData", mode = "function", 
[17:42:47.619]                       envir = ns)) {
[17:42:47.619]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.619]                         envir = ns)
[17:42:47.619]                       envir <- sys.frame(frame)
[17:42:47.619]                       master <- NULL
[17:42:47.619]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.619]                         !identical(envir, emptyenv())) {
[17:42:47.619]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.619]                           inherits = FALSE)) {
[17:42:47.619]                           master <- get("master", mode = "list", 
[17:42:47.619]                             envir = envir, inherits = FALSE)
[17:42:47.619]                           if (inherits(master, c("SOCKnode", 
[17:42:47.619]                             "SOCK0node"))) {
[17:42:47.619]                             sendCondition <<- function(cond) {
[17:42:47.619]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.619]                                 success = TRUE)
[17:42:47.619]                               parallel_sendData(master, data)
[17:42:47.619]                             }
[17:42:47.619]                             return(sendCondition)
[17:42:47.619]                           }
[17:42:47.619]                         }
[17:42:47.619]                         frame <- frame + 1L
[17:42:47.619]                         envir <- sys.frame(frame)
[17:42:47.619]                       }
[17:42:47.619]                     }
[17:42:47.619]                     sendCondition <<- function(cond) NULL
[17:42:47.619]                   }
[17:42:47.619]                 })
[17:42:47.619]                 withCallingHandlers({
[17:42:47.619]                   value(a) + 1
[17:42:47.619]                 }, immediateCondition = function(cond) {
[17:42:47.619]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.619]                   sendCondition(cond)
[17:42:47.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.619]                   {
[17:42:47.619]                     inherits <- base::inherits
[17:42:47.619]                     invokeRestart <- base::invokeRestart
[17:42:47.619]                     is.null <- base::is.null
[17:42:47.619]                     muffled <- FALSE
[17:42:47.619]                     if (inherits(cond, "message")) {
[17:42:47.619]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.619]                       if (muffled) 
[17:42:47.619]                         invokeRestart("muffleMessage")
[17:42:47.619]                     }
[17:42:47.619]                     else if (inherits(cond, "warning")) {
[17:42:47.619]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.619]                       if (muffled) 
[17:42:47.619]                         invokeRestart("muffleWarning")
[17:42:47.619]                     }
[17:42:47.619]                     else if (inherits(cond, "condition")) {
[17:42:47.619]                       if (!is.null(pattern)) {
[17:42:47.619]                         computeRestarts <- base::computeRestarts
[17:42:47.619]                         grepl <- base::grepl
[17:42:47.619]                         restarts <- computeRestarts(cond)
[17:42:47.619]                         for (restart in restarts) {
[17:42:47.619]                           name <- restart$name
[17:42:47.619]                           if (is.null(name)) 
[17:42:47.619]                             next
[17:42:47.619]                           if (!grepl(pattern, name)) 
[17:42:47.619]                             next
[17:42:47.619]                           invokeRestart(restart)
[17:42:47.619]                           muffled <- TRUE
[17:42:47.619]                           break
[17:42:47.619]                         }
[17:42:47.619]                       }
[17:42:47.619]                     }
[17:42:47.619]                     invisible(muffled)
[17:42:47.619]                   }
[17:42:47.619]                   muffleCondition(cond)
[17:42:47.619]                 })
[17:42:47.619]             }))
[17:42:47.619]             future::FutureResult(value = ...future.value$value, 
[17:42:47.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.619]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.619]                     ...future.globalenv.names))
[17:42:47.619]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.619]         }, condition = base::local({
[17:42:47.619]             c <- base::c
[17:42:47.619]             inherits <- base::inherits
[17:42:47.619]             invokeRestart <- base::invokeRestart
[17:42:47.619]             length <- base::length
[17:42:47.619]             list <- base::list
[17:42:47.619]             seq.int <- base::seq.int
[17:42:47.619]             signalCondition <- base::signalCondition
[17:42:47.619]             sys.calls <- base::sys.calls
[17:42:47.619]             `[[` <- base::`[[`
[17:42:47.619]             `+` <- base::`+`
[17:42:47.619]             `<<-` <- base::`<<-`
[17:42:47.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.619]                   3L)]
[17:42:47.619]             }
[17:42:47.619]             function(cond) {
[17:42:47.619]                 is_error <- inherits(cond, "error")
[17:42:47.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.619]                   NULL)
[17:42:47.619]                 if (is_error) {
[17:42:47.619]                   sessionInformation <- function() {
[17:42:47.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.619]                       search = base::search(), system = base::Sys.info())
[17:42:47.619]                   }
[17:42:47.619]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.619]                     cond$call), session = sessionInformation(), 
[17:42:47.619]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.619]                   signalCondition(cond)
[17:42:47.619]                 }
[17:42:47.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.619]                 "immediateCondition"))) {
[17:42:47.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.619]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.619]                   if (TRUE && !signal) {
[17:42:47.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.619]                     {
[17:42:47.619]                       inherits <- base::inherits
[17:42:47.619]                       invokeRestart <- base::invokeRestart
[17:42:47.619]                       is.null <- base::is.null
[17:42:47.619]                       muffled <- FALSE
[17:42:47.619]                       if (inherits(cond, "message")) {
[17:42:47.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.619]                         if (muffled) 
[17:42:47.619]                           invokeRestart("muffleMessage")
[17:42:47.619]                       }
[17:42:47.619]                       else if (inherits(cond, "warning")) {
[17:42:47.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.619]                         if (muffled) 
[17:42:47.619]                           invokeRestart("muffleWarning")
[17:42:47.619]                       }
[17:42:47.619]                       else if (inherits(cond, "condition")) {
[17:42:47.619]                         if (!is.null(pattern)) {
[17:42:47.619]                           computeRestarts <- base::computeRestarts
[17:42:47.619]                           grepl <- base::grepl
[17:42:47.619]                           restarts <- computeRestarts(cond)
[17:42:47.619]                           for (restart in restarts) {
[17:42:47.619]                             name <- restart$name
[17:42:47.619]                             if (is.null(name)) 
[17:42:47.619]                               next
[17:42:47.619]                             if (!grepl(pattern, name)) 
[17:42:47.619]                               next
[17:42:47.619]                             invokeRestart(restart)
[17:42:47.619]                             muffled <- TRUE
[17:42:47.619]                             break
[17:42:47.619]                           }
[17:42:47.619]                         }
[17:42:47.619]                       }
[17:42:47.619]                       invisible(muffled)
[17:42:47.619]                     }
[17:42:47.619]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.619]                   }
[17:42:47.619]                 }
[17:42:47.619]                 else {
[17:42:47.619]                   if (TRUE) {
[17:42:47.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.619]                     {
[17:42:47.619]                       inherits <- base::inherits
[17:42:47.619]                       invokeRestart <- base::invokeRestart
[17:42:47.619]                       is.null <- base::is.null
[17:42:47.619]                       muffled <- FALSE
[17:42:47.619]                       if (inherits(cond, "message")) {
[17:42:47.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.619]                         if (muffled) 
[17:42:47.619]                           invokeRestart("muffleMessage")
[17:42:47.619]                       }
[17:42:47.619]                       else if (inherits(cond, "warning")) {
[17:42:47.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.619]                         if (muffled) 
[17:42:47.619]                           invokeRestart("muffleWarning")
[17:42:47.619]                       }
[17:42:47.619]                       else if (inherits(cond, "condition")) {
[17:42:47.619]                         if (!is.null(pattern)) {
[17:42:47.619]                           computeRestarts <- base::computeRestarts
[17:42:47.619]                           grepl <- base::grepl
[17:42:47.619]                           restarts <- computeRestarts(cond)
[17:42:47.619]                           for (restart in restarts) {
[17:42:47.619]                             name <- restart$name
[17:42:47.619]                             if (is.null(name)) 
[17:42:47.619]                               next
[17:42:47.619]                             if (!grepl(pattern, name)) 
[17:42:47.619]                               next
[17:42:47.619]                             invokeRestart(restart)
[17:42:47.619]                             muffled <- TRUE
[17:42:47.619]                             break
[17:42:47.619]                           }
[17:42:47.619]                         }
[17:42:47.619]                       }
[17:42:47.619]                       invisible(muffled)
[17:42:47.619]                     }
[17:42:47.619]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.619]                   }
[17:42:47.619]                 }
[17:42:47.619]             }
[17:42:47.619]         }))
[17:42:47.619]     }, error = function(ex) {
[17:42:47.619]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.619]                 ...future.rng), started = ...future.startTime, 
[17:42:47.619]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.619]             version = "1.8"), class = "FutureResult")
[17:42:47.619]     }, finally = {
[17:42:47.619]         if (!identical(...future.workdir, getwd())) 
[17:42:47.619]             setwd(...future.workdir)
[17:42:47.619]         {
[17:42:47.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.619]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.619]             }
[17:42:47.619]             base::options(...future.oldOptions)
[17:42:47.619]             if (.Platform$OS.type == "windows") {
[17:42:47.619]                 old_names <- names(...future.oldEnvVars)
[17:42:47.619]                 envs <- base::Sys.getenv()
[17:42:47.619]                 names <- names(envs)
[17:42:47.619]                 common <- intersect(names, old_names)
[17:42:47.619]                 added <- setdiff(names, old_names)
[17:42:47.619]                 removed <- setdiff(old_names, names)
[17:42:47.619]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.619]                   envs[common]]
[17:42:47.619]                 NAMES <- toupper(changed)
[17:42:47.619]                 args <- list()
[17:42:47.619]                 for (kk in seq_along(NAMES)) {
[17:42:47.619]                   name <- changed[[kk]]
[17:42:47.619]                   NAME <- NAMES[[kk]]
[17:42:47.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.619]                     next
[17:42:47.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.619]                 }
[17:42:47.619]                 NAMES <- toupper(added)
[17:42:47.619]                 for (kk in seq_along(NAMES)) {
[17:42:47.619]                   name <- added[[kk]]
[17:42:47.619]                   NAME <- NAMES[[kk]]
[17:42:47.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.619]                     next
[17:42:47.619]                   args[[name]] <- ""
[17:42:47.619]                 }
[17:42:47.619]                 NAMES <- toupper(removed)
[17:42:47.619]                 for (kk in seq_along(NAMES)) {
[17:42:47.619]                   name <- removed[[kk]]
[17:42:47.619]                   NAME <- NAMES[[kk]]
[17:42:47.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.619]                     next
[17:42:47.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.619]                 }
[17:42:47.619]                 if (length(args) > 0) 
[17:42:47.619]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.619]             }
[17:42:47.619]             else {
[17:42:47.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.619]             }
[17:42:47.619]             {
[17:42:47.619]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.619]                   0L) {
[17:42:47.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.619]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.619]                   base::options(opts)
[17:42:47.619]                 }
[17:42:47.619]                 {
[17:42:47.619]                   {
[17:42:47.619]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.619]                     NULL
[17:42:47.619]                   }
[17:42:47.619]                   options(future.plan = NULL)
[17:42:47.619]                   if (is.na(NA_character_)) 
[17:42:47.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.619]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.619]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.619]                     envir = parent.frame()) 
[17:42:47.619]                   {
[17:42:47.619]                     if (is.function(workers)) 
[17:42:47.619]                       workers <- workers()
[17:42:47.619]                     workers <- structure(as.integer(workers), 
[17:42:47.619]                       class = class(workers))
[17:42:47.619]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.619]                       workers >= 1)
[17:42:47.619]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.619]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.619]                     }
[17:42:47.619]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.619]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.619]                       envir = envir)
[17:42:47.619]                     if (!future$lazy) 
[17:42:47.619]                       future <- run(future)
[17:42:47.619]                     invisible(future)
[17:42:47.619]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.619]                 }
[17:42:47.619]             }
[17:42:47.619]         }
[17:42:47.619]     })
[17:42:47.619]     if (TRUE) {
[17:42:47.619]         base::sink(type = "output", split = FALSE)
[17:42:47.619]         if (TRUE) {
[17:42:47.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.619]         }
[17:42:47.619]         else {
[17:42:47.619]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.619]         }
[17:42:47.619]         base::close(...future.stdout)
[17:42:47.619]         ...future.stdout <- NULL
[17:42:47.619]     }
[17:42:47.619]     ...future.result$conditions <- ...future.conditions
[17:42:47.619]     ...future.result$finished <- base::Sys.time()
[17:42:47.619]     ...future.result
[17:42:47.619] }
[17:42:47.622] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[17:42:47.623] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[17:42:47.675] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[17:42:47.675] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[17:42:47.676] MultisessionFuture started
[17:42:47.676] - Launch lazy future ... done
[17:42:47.676] run() for ‘MultisessionFuture’ ... done
[17:42:47.677] result() for ClusterFuture ...
[17:42:47.677] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.677] - Validating connection of MultisessionFuture
[17:42:47.725] - received message: FutureResult
[17:42:47.725] - Received FutureResult
[17:42:47.725] - Erased future from FutureRegistry
[17:42:47.725] result() for ClusterFuture ...
[17:42:47.725] - result already collected: FutureResult
[17:42:47.725] result() for ClusterFuture ... done
[17:42:47.726] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.726] result() for ClusterFuture ... done
[17:42:47.726] result() for ClusterFuture ...
[17:42:47.726] - result already collected: FutureResult
[17:42:47.726] result() for ClusterFuture ... done
value(b) = 2
[17:42:47.726] result() for ClusterFuture ...
[17:42:47.726] - result already collected: FutureResult
[17:42:47.726] result() for ClusterFuture ... done
[17:42:47.726] result() for ClusterFuture ...
[17:42:47.727] - result already collected: FutureResult
[17:42:47.727] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.727] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.727] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.728] 
[17:42:47.728] Searching for globals ... DONE
[17:42:47.728] - globals: [0] <none>
[17:42:47.728] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.728] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.728] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.729] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:47.729] Searching for globals ... DONE
[17:42:47.730] Resolving globals: TRUE
[17:42:47.730] Resolving any globals that are futures ...
[17:42:47.730] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:47.730] Resolving any globals that are futures ... DONE
[17:42:47.730] Resolving futures part of globals (recursively) ...
[17:42:47.730] resolve() on list ...
[17:42:47.731]  recursive: 99
[17:42:47.731]  length: 1
[17:42:47.731]  elements: ‘a’
[17:42:47.731] run() for ‘Future’ ...
[17:42:47.731] - state: ‘created’
[17:42:47.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.746] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.746]   - Field: ‘node’
[17:42:47.746]   - Field: ‘label’
[17:42:47.746]   - Field: ‘local’
[17:42:47.746]   - Field: ‘owner’
[17:42:47.746]   - Field: ‘envir’
[17:42:47.746]   - Field: ‘workers’
[17:42:47.747]   - Field: ‘packages’
[17:42:47.747]   - Field: ‘gc’
[17:42:47.747]   - Field: ‘conditions’
[17:42:47.747]   - Field: ‘persistent’
[17:42:47.747]   - Field: ‘expr’
[17:42:47.747]   - Field: ‘uuid’
[17:42:47.747]   - Field: ‘seed’
[17:42:47.747]   - Field: ‘version’
[17:42:47.747]   - Field: ‘result’
[17:42:47.747]   - Field: ‘asynchronous’
[17:42:47.748]   - Field: ‘calls’
[17:42:47.748]   - Field: ‘globals’
[17:42:47.748]   - Field: ‘stdout’
[17:42:47.748]   - Field: ‘earlySignal’
[17:42:47.748]   - Field: ‘lazy’
[17:42:47.748]   - Field: ‘state’
[17:42:47.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.748] - Launch lazy future ...
[17:42:47.748] Packages needed by the future expression (n = 0): <none>
[17:42:47.749] Packages needed by future strategies (n = 0): <none>
[17:42:47.749] {
[17:42:47.749]     {
[17:42:47.749]         {
[17:42:47.749]             ...future.startTime <- base::Sys.time()
[17:42:47.749]             {
[17:42:47.749]                 {
[17:42:47.749]                   {
[17:42:47.749]                     {
[17:42:47.749]                       base::local({
[17:42:47.749]                         has_future <- base::requireNamespace("future", 
[17:42:47.749]                           quietly = TRUE)
[17:42:47.749]                         if (has_future) {
[17:42:47.749]                           ns <- base::getNamespace("future")
[17:42:47.749]                           version <- ns[[".package"]][["version"]]
[17:42:47.749]                           if (is.null(version)) 
[17:42:47.749]                             version <- utils::packageVersion("future")
[17:42:47.749]                         }
[17:42:47.749]                         else {
[17:42:47.749]                           version <- NULL
[17:42:47.749]                         }
[17:42:47.749]                         if (!has_future || version < "1.8.0") {
[17:42:47.749]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.749]                             "", base::R.version$version.string), 
[17:42:47.749]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.749]                               "release", "version")], collapse = " "), 
[17:42:47.749]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.749]                             info)
[17:42:47.749]                           info <- base::paste(info, collapse = "; ")
[17:42:47.749]                           if (!has_future) {
[17:42:47.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.749]                               info)
[17:42:47.749]                           }
[17:42:47.749]                           else {
[17:42:47.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.749]                               info, version)
[17:42:47.749]                           }
[17:42:47.749]                           base::stop(msg)
[17:42:47.749]                         }
[17:42:47.749]                       })
[17:42:47.749]                     }
[17:42:47.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.749]                     base::options(mc.cores = 1L)
[17:42:47.749]                   }
[17:42:47.749]                   options(future.plan = NULL)
[17:42:47.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.749]                 }
[17:42:47.749]                 ...future.workdir <- getwd()
[17:42:47.749]             }
[17:42:47.749]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.749]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.749]         }
[17:42:47.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.749]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.749]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.749]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.749]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.749]             base::names(...future.oldOptions))
[17:42:47.749]     }
[17:42:47.749]     if (FALSE) {
[17:42:47.749]     }
[17:42:47.749]     else {
[17:42:47.749]         if (TRUE) {
[17:42:47.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.749]                 open = "w")
[17:42:47.749]         }
[17:42:47.749]         else {
[17:42:47.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.749]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.749]         }
[17:42:47.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.749]             base::sink(type = "output", split = FALSE)
[17:42:47.749]             base::close(...future.stdout)
[17:42:47.749]         }, add = TRUE)
[17:42:47.749]     }
[17:42:47.749]     ...future.frame <- base::sys.nframe()
[17:42:47.749]     ...future.conditions <- base::list()
[17:42:47.749]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.749]     if (FALSE) {
[17:42:47.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.749]     }
[17:42:47.749]     ...future.result <- base::tryCatch({
[17:42:47.749]         base::withCallingHandlers({
[17:42:47.749]             ...future.value <- base::withVisible(base::local({
[17:42:47.749]                 ...future.makeSendCondition <- local({
[17:42:47.749]                   sendCondition <- NULL
[17:42:47.749]                   function(frame = 1L) {
[17:42:47.749]                     if (is.function(sendCondition)) 
[17:42:47.749]                       return(sendCondition)
[17:42:47.749]                     ns <- getNamespace("parallel")
[17:42:47.749]                     if (exists("sendData", mode = "function", 
[17:42:47.749]                       envir = ns)) {
[17:42:47.749]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.749]                         envir = ns)
[17:42:47.749]                       envir <- sys.frame(frame)
[17:42:47.749]                       master <- NULL
[17:42:47.749]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.749]                         !identical(envir, emptyenv())) {
[17:42:47.749]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.749]                           inherits = FALSE)) {
[17:42:47.749]                           master <- get("master", mode = "list", 
[17:42:47.749]                             envir = envir, inherits = FALSE)
[17:42:47.749]                           if (inherits(master, c("SOCKnode", 
[17:42:47.749]                             "SOCK0node"))) {
[17:42:47.749]                             sendCondition <<- function(cond) {
[17:42:47.749]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.749]                                 success = TRUE)
[17:42:47.749]                               parallel_sendData(master, data)
[17:42:47.749]                             }
[17:42:47.749]                             return(sendCondition)
[17:42:47.749]                           }
[17:42:47.749]                         }
[17:42:47.749]                         frame <- frame + 1L
[17:42:47.749]                         envir <- sys.frame(frame)
[17:42:47.749]                       }
[17:42:47.749]                     }
[17:42:47.749]                     sendCondition <<- function(cond) NULL
[17:42:47.749]                   }
[17:42:47.749]                 })
[17:42:47.749]                 withCallingHandlers({
[17:42:47.749]                   1
[17:42:47.749]                 }, immediateCondition = function(cond) {
[17:42:47.749]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.749]                   sendCondition(cond)
[17:42:47.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.749]                   {
[17:42:47.749]                     inherits <- base::inherits
[17:42:47.749]                     invokeRestart <- base::invokeRestart
[17:42:47.749]                     is.null <- base::is.null
[17:42:47.749]                     muffled <- FALSE
[17:42:47.749]                     if (inherits(cond, "message")) {
[17:42:47.749]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.749]                       if (muffled) 
[17:42:47.749]                         invokeRestart("muffleMessage")
[17:42:47.749]                     }
[17:42:47.749]                     else if (inherits(cond, "warning")) {
[17:42:47.749]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.749]                       if (muffled) 
[17:42:47.749]                         invokeRestart("muffleWarning")
[17:42:47.749]                     }
[17:42:47.749]                     else if (inherits(cond, "condition")) {
[17:42:47.749]                       if (!is.null(pattern)) {
[17:42:47.749]                         computeRestarts <- base::computeRestarts
[17:42:47.749]                         grepl <- base::grepl
[17:42:47.749]                         restarts <- computeRestarts(cond)
[17:42:47.749]                         for (restart in restarts) {
[17:42:47.749]                           name <- restart$name
[17:42:47.749]                           if (is.null(name)) 
[17:42:47.749]                             next
[17:42:47.749]                           if (!grepl(pattern, name)) 
[17:42:47.749]                             next
[17:42:47.749]                           invokeRestart(restart)
[17:42:47.749]                           muffled <- TRUE
[17:42:47.749]                           break
[17:42:47.749]                         }
[17:42:47.749]                       }
[17:42:47.749]                     }
[17:42:47.749]                     invisible(muffled)
[17:42:47.749]                   }
[17:42:47.749]                   muffleCondition(cond)
[17:42:47.749]                 })
[17:42:47.749]             }))
[17:42:47.749]             future::FutureResult(value = ...future.value$value, 
[17:42:47.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.749]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.749]                     ...future.globalenv.names))
[17:42:47.749]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.749]         }, condition = base::local({
[17:42:47.749]             c <- base::c
[17:42:47.749]             inherits <- base::inherits
[17:42:47.749]             invokeRestart <- base::invokeRestart
[17:42:47.749]             length <- base::length
[17:42:47.749]             list <- base::list
[17:42:47.749]             seq.int <- base::seq.int
[17:42:47.749]             signalCondition <- base::signalCondition
[17:42:47.749]             sys.calls <- base::sys.calls
[17:42:47.749]             `[[` <- base::`[[`
[17:42:47.749]             `+` <- base::`+`
[17:42:47.749]             `<<-` <- base::`<<-`
[17:42:47.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.749]                   3L)]
[17:42:47.749]             }
[17:42:47.749]             function(cond) {
[17:42:47.749]                 is_error <- inherits(cond, "error")
[17:42:47.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.749]                   NULL)
[17:42:47.749]                 if (is_error) {
[17:42:47.749]                   sessionInformation <- function() {
[17:42:47.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.749]                       search = base::search(), system = base::Sys.info())
[17:42:47.749]                   }
[17:42:47.749]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.749]                     cond$call), session = sessionInformation(), 
[17:42:47.749]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.749]                   signalCondition(cond)
[17:42:47.749]                 }
[17:42:47.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.749]                 "immediateCondition"))) {
[17:42:47.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.749]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.749]                   if (TRUE && !signal) {
[17:42:47.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.749]                     {
[17:42:47.749]                       inherits <- base::inherits
[17:42:47.749]                       invokeRestart <- base::invokeRestart
[17:42:47.749]                       is.null <- base::is.null
[17:42:47.749]                       muffled <- FALSE
[17:42:47.749]                       if (inherits(cond, "message")) {
[17:42:47.749]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.749]                         if (muffled) 
[17:42:47.749]                           invokeRestart("muffleMessage")
[17:42:47.749]                       }
[17:42:47.749]                       else if (inherits(cond, "warning")) {
[17:42:47.749]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.749]                         if (muffled) 
[17:42:47.749]                           invokeRestart("muffleWarning")
[17:42:47.749]                       }
[17:42:47.749]                       else if (inherits(cond, "condition")) {
[17:42:47.749]                         if (!is.null(pattern)) {
[17:42:47.749]                           computeRestarts <- base::computeRestarts
[17:42:47.749]                           grepl <- base::grepl
[17:42:47.749]                           restarts <- computeRestarts(cond)
[17:42:47.749]                           for (restart in restarts) {
[17:42:47.749]                             name <- restart$name
[17:42:47.749]                             if (is.null(name)) 
[17:42:47.749]                               next
[17:42:47.749]                             if (!grepl(pattern, name)) 
[17:42:47.749]                               next
[17:42:47.749]                             invokeRestart(restart)
[17:42:47.749]                             muffled <- TRUE
[17:42:47.749]                             break
[17:42:47.749]                           }
[17:42:47.749]                         }
[17:42:47.749]                       }
[17:42:47.749]                       invisible(muffled)
[17:42:47.749]                     }
[17:42:47.749]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.749]                   }
[17:42:47.749]                 }
[17:42:47.749]                 else {
[17:42:47.749]                   if (TRUE) {
[17:42:47.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.749]                     {
[17:42:47.749]                       inherits <- base::inherits
[17:42:47.749]                       invokeRestart <- base::invokeRestart
[17:42:47.749]                       is.null <- base::is.null
[17:42:47.749]                       muffled <- FALSE
[17:42:47.749]                       if (inherits(cond, "message")) {
[17:42:47.749]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.749]                         if (muffled) 
[17:42:47.749]                           invokeRestart("muffleMessage")
[17:42:47.749]                       }
[17:42:47.749]                       else if (inherits(cond, "warning")) {
[17:42:47.749]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.749]                         if (muffled) 
[17:42:47.749]                           invokeRestart("muffleWarning")
[17:42:47.749]                       }
[17:42:47.749]                       else if (inherits(cond, "condition")) {
[17:42:47.749]                         if (!is.null(pattern)) {
[17:42:47.749]                           computeRestarts <- base::computeRestarts
[17:42:47.749]                           grepl <- base::grepl
[17:42:47.749]                           restarts <- computeRestarts(cond)
[17:42:47.749]                           for (restart in restarts) {
[17:42:47.749]                             name <- restart$name
[17:42:47.749]                             if (is.null(name)) 
[17:42:47.749]                               next
[17:42:47.749]                             if (!grepl(pattern, name)) 
[17:42:47.749]                               next
[17:42:47.749]                             invokeRestart(restart)
[17:42:47.749]                             muffled <- TRUE
[17:42:47.749]                             break
[17:42:47.749]                           }
[17:42:47.749]                         }
[17:42:47.749]                       }
[17:42:47.749]                       invisible(muffled)
[17:42:47.749]                     }
[17:42:47.749]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.749]                   }
[17:42:47.749]                 }
[17:42:47.749]             }
[17:42:47.749]         }))
[17:42:47.749]     }, error = function(ex) {
[17:42:47.749]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.749]                 ...future.rng), started = ...future.startTime, 
[17:42:47.749]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.749]             version = "1.8"), class = "FutureResult")
[17:42:47.749]     }, finally = {
[17:42:47.749]         if (!identical(...future.workdir, getwd())) 
[17:42:47.749]             setwd(...future.workdir)
[17:42:47.749]         {
[17:42:47.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.749]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.749]             }
[17:42:47.749]             base::options(...future.oldOptions)
[17:42:47.749]             if (.Platform$OS.type == "windows") {
[17:42:47.749]                 old_names <- names(...future.oldEnvVars)
[17:42:47.749]                 envs <- base::Sys.getenv()
[17:42:47.749]                 names <- names(envs)
[17:42:47.749]                 common <- intersect(names, old_names)
[17:42:47.749]                 added <- setdiff(names, old_names)
[17:42:47.749]                 removed <- setdiff(old_names, names)
[17:42:47.749]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.749]                   envs[common]]
[17:42:47.749]                 NAMES <- toupper(changed)
[17:42:47.749]                 args <- list()
[17:42:47.749]                 for (kk in seq_along(NAMES)) {
[17:42:47.749]                   name <- changed[[kk]]
[17:42:47.749]                   NAME <- NAMES[[kk]]
[17:42:47.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.749]                     next
[17:42:47.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.749]                 }
[17:42:47.749]                 NAMES <- toupper(added)
[17:42:47.749]                 for (kk in seq_along(NAMES)) {
[17:42:47.749]                   name <- added[[kk]]
[17:42:47.749]                   NAME <- NAMES[[kk]]
[17:42:47.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.749]                     next
[17:42:47.749]                   args[[name]] <- ""
[17:42:47.749]                 }
[17:42:47.749]                 NAMES <- toupper(removed)
[17:42:47.749]                 for (kk in seq_along(NAMES)) {
[17:42:47.749]                   name <- removed[[kk]]
[17:42:47.749]                   NAME <- NAMES[[kk]]
[17:42:47.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.749]                     next
[17:42:47.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.749]                 }
[17:42:47.749]                 if (length(args) > 0) 
[17:42:47.749]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.749]             }
[17:42:47.749]             else {
[17:42:47.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.749]             }
[17:42:47.749]             {
[17:42:47.749]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.749]                   0L) {
[17:42:47.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.749]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.749]                   base::options(opts)
[17:42:47.749]                 }
[17:42:47.749]                 {
[17:42:47.749]                   {
[17:42:47.749]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.749]                     NULL
[17:42:47.749]                   }
[17:42:47.749]                   options(future.plan = NULL)
[17:42:47.749]                   if (is.na(NA_character_)) 
[17:42:47.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.749]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.749]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.749]                     envir = parent.frame()) 
[17:42:47.749]                   {
[17:42:47.749]                     if (is.function(workers)) 
[17:42:47.749]                       workers <- workers()
[17:42:47.749]                     workers <- structure(as.integer(workers), 
[17:42:47.749]                       class = class(workers))
[17:42:47.749]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.749]                       workers >= 1)
[17:42:47.749]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.749]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.749]                     }
[17:42:47.749]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.749]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.749]                       envir = envir)
[17:42:47.749]                     if (!future$lazy) 
[17:42:47.749]                       future <- run(future)
[17:42:47.749]                     invisible(future)
[17:42:47.749]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.749]                 }
[17:42:47.749]             }
[17:42:47.749]         }
[17:42:47.749]     })
[17:42:47.749]     if (TRUE) {
[17:42:47.749]         base::sink(type = "output", split = FALSE)
[17:42:47.749]         if (TRUE) {
[17:42:47.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.749]         }
[17:42:47.749]         else {
[17:42:47.749]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.749]         }
[17:42:47.749]         base::close(...future.stdout)
[17:42:47.749]         ...future.stdout <- NULL
[17:42:47.749]     }
[17:42:47.749]     ...future.result$conditions <- ...future.conditions
[17:42:47.749]     ...future.result$finished <- base::Sys.time()
[17:42:47.749]     ...future.result
[17:42:47.749] }
[17:42:47.752] MultisessionFuture started
[17:42:47.752] - Launch lazy future ... done
[17:42:47.753] run() for ‘MultisessionFuture’ ... done
[17:42:47.800] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.800] - Validating connection of MultisessionFuture
[17:42:47.801] - received message: FutureResult
[17:42:47.801] - Received FutureResult
[17:42:47.801] - Erased future from FutureRegistry
[17:42:47.801] result() for ClusterFuture ...
[17:42:47.801] - result already collected: FutureResult
[17:42:47.801] result() for ClusterFuture ... done
[17:42:47.802] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.802] Future #1
[17:42:47.802] result() for ClusterFuture ...
[17:42:47.802] - result already collected: FutureResult
[17:42:47.802] result() for ClusterFuture ... done
[17:42:47.802] result() for ClusterFuture ...
[17:42:47.802] - result already collected: FutureResult
[17:42:47.802] result() for ClusterFuture ... done
[17:42:47.802] A MultisessionFuture was resolved
[17:42:47.802]  length: 0 (resolved future 1)
[17:42:47.803] resolve() on list ... DONE
[17:42:47.803] - globals: [1] ‘a’
[17:42:47.803] Resolving futures part of globals (recursively) ... DONE
[17:42:47.804] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:42:47.804] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:42:47.804] - globals: [1] ‘a’
[17:42:47.804] - packages: [1] ‘future’
[17:42:47.805] getGlobalsAndPackages() ... DONE
[17:42:47.805] run() for ‘Future’ ...
[17:42:47.805] - state: ‘created’
[17:42:47.805] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.820]   - Field: ‘node’
[17:42:47.820]   - Field: ‘label’
[17:42:47.820]   - Field: ‘local’
[17:42:47.820]   - Field: ‘owner’
[17:42:47.820]   - Field: ‘envir’
[17:42:47.821]   - Field: ‘workers’
[17:42:47.821]   - Field: ‘packages’
[17:42:47.821]   - Field: ‘gc’
[17:42:47.821]   - Field: ‘conditions’
[17:42:47.821]   - Field: ‘persistent’
[17:42:47.821]   - Field: ‘expr’
[17:42:47.821]   - Field: ‘uuid’
[17:42:47.821]   - Field: ‘seed’
[17:42:47.821]   - Field: ‘version’
[17:42:47.821]   - Field: ‘result’
[17:42:47.821]   - Field: ‘asynchronous’
[17:42:47.822]   - Field: ‘calls’
[17:42:47.822]   - Field: ‘globals’
[17:42:47.822]   - Field: ‘stdout’
[17:42:47.822]   - Field: ‘earlySignal’
[17:42:47.822]   - Field: ‘lazy’
[17:42:47.822]   - Field: ‘state’
[17:42:47.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.822] - Launch lazy future ...
[17:42:47.823] Packages needed by the future expression (n = 1): ‘future’
[17:42:47.823] Packages needed by future strategies (n = 0): <none>
[17:42:47.823] {
[17:42:47.823]     {
[17:42:47.823]         {
[17:42:47.823]             ...future.startTime <- base::Sys.time()
[17:42:47.823]             {
[17:42:47.823]                 {
[17:42:47.823]                   {
[17:42:47.823]                     {
[17:42:47.823]                       {
[17:42:47.823]                         base::local({
[17:42:47.823]                           has_future <- base::requireNamespace("future", 
[17:42:47.823]                             quietly = TRUE)
[17:42:47.823]                           if (has_future) {
[17:42:47.823]                             ns <- base::getNamespace("future")
[17:42:47.823]                             version <- ns[[".package"]][["version"]]
[17:42:47.823]                             if (is.null(version)) 
[17:42:47.823]                               version <- utils::packageVersion("future")
[17:42:47.823]                           }
[17:42:47.823]                           else {
[17:42:47.823]                             version <- NULL
[17:42:47.823]                           }
[17:42:47.823]                           if (!has_future || version < "1.8.0") {
[17:42:47.823]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.823]                               "", base::R.version$version.string), 
[17:42:47.823]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:47.823]                                 base::R.version$platform, 8 * 
[17:42:47.823]                                   base::.Machine$sizeof.pointer), 
[17:42:47.823]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.823]                                 "release", "version")], collapse = " "), 
[17:42:47.823]                               hostname = base::Sys.info()[["nodename"]])
[17:42:47.823]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.823]                               info)
[17:42:47.823]                             info <- base::paste(info, collapse = "; ")
[17:42:47.823]                             if (!has_future) {
[17:42:47.823]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.823]                                 info)
[17:42:47.823]                             }
[17:42:47.823]                             else {
[17:42:47.823]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.823]                                 info, version)
[17:42:47.823]                             }
[17:42:47.823]                             base::stop(msg)
[17:42:47.823]                           }
[17:42:47.823]                         })
[17:42:47.823]                       }
[17:42:47.823]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.823]                       base::options(mc.cores = 1L)
[17:42:47.823]                     }
[17:42:47.823]                     base::local({
[17:42:47.823]                       for (pkg in "future") {
[17:42:47.823]                         base::loadNamespace(pkg)
[17:42:47.823]                         base::library(pkg, character.only = TRUE)
[17:42:47.823]                       }
[17:42:47.823]                     })
[17:42:47.823]                   }
[17:42:47.823]                   options(future.plan = NULL)
[17:42:47.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.823]                 }
[17:42:47.823]                 ...future.workdir <- getwd()
[17:42:47.823]             }
[17:42:47.823]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.823]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.823]         }
[17:42:47.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.823]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.823]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.823]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.823]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.823]             base::names(...future.oldOptions))
[17:42:47.823]     }
[17:42:47.823]     if (FALSE) {
[17:42:47.823]     }
[17:42:47.823]     else {
[17:42:47.823]         if (TRUE) {
[17:42:47.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.823]                 open = "w")
[17:42:47.823]         }
[17:42:47.823]         else {
[17:42:47.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.823]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.823]         }
[17:42:47.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.823]             base::sink(type = "output", split = FALSE)
[17:42:47.823]             base::close(...future.stdout)
[17:42:47.823]         }, add = TRUE)
[17:42:47.823]     }
[17:42:47.823]     ...future.frame <- base::sys.nframe()
[17:42:47.823]     ...future.conditions <- base::list()
[17:42:47.823]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.823]     if (FALSE) {
[17:42:47.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.823]     }
[17:42:47.823]     ...future.result <- base::tryCatch({
[17:42:47.823]         base::withCallingHandlers({
[17:42:47.823]             ...future.value <- base::withVisible(base::local({
[17:42:47.823]                 ...future.makeSendCondition <- local({
[17:42:47.823]                   sendCondition <- NULL
[17:42:47.823]                   function(frame = 1L) {
[17:42:47.823]                     if (is.function(sendCondition)) 
[17:42:47.823]                       return(sendCondition)
[17:42:47.823]                     ns <- getNamespace("parallel")
[17:42:47.823]                     if (exists("sendData", mode = "function", 
[17:42:47.823]                       envir = ns)) {
[17:42:47.823]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.823]                         envir = ns)
[17:42:47.823]                       envir <- sys.frame(frame)
[17:42:47.823]                       master <- NULL
[17:42:47.823]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.823]                         !identical(envir, emptyenv())) {
[17:42:47.823]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.823]                           inherits = FALSE)) {
[17:42:47.823]                           master <- get("master", mode = "list", 
[17:42:47.823]                             envir = envir, inherits = FALSE)
[17:42:47.823]                           if (inherits(master, c("SOCKnode", 
[17:42:47.823]                             "SOCK0node"))) {
[17:42:47.823]                             sendCondition <<- function(cond) {
[17:42:47.823]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.823]                                 success = TRUE)
[17:42:47.823]                               parallel_sendData(master, data)
[17:42:47.823]                             }
[17:42:47.823]                             return(sendCondition)
[17:42:47.823]                           }
[17:42:47.823]                         }
[17:42:47.823]                         frame <- frame + 1L
[17:42:47.823]                         envir <- sys.frame(frame)
[17:42:47.823]                       }
[17:42:47.823]                     }
[17:42:47.823]                     sendCondition <<- function(cond) NULL
[17:42:47.823]                   }
[17:42:47.823]                 })
[17:42:47.823]                 withCallingHandlers({
[17:42:47.823]                   value(a) + 1
[17:42:47.823]                 }, immediateCondition = function(cond) {
[17:42:47.823]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.823]                   sendCondition(cond)
[17:42:47.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.823]                   {
[17:42:47.823]                     inherits <- base::inherits
[17:42:47.823]                     invokeRestart <- base::invokeRestart
[17:42:47.823]                     is.null <- base::is.null
[17:42:47.823]                     muffled <- FALSE
[17:42:47.823]                     if (inherits(cond, "message")) {
[17:42:47.823]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.823]                       if (muffled) 
[17:42:47.823]                         invokeRestart("muffleMessage")
[17:42:47.823]                     }
[17:42:47.823]                     else if (inherits(cond, "warning")) {
[17:42:47.823]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.823]                       if (muffled) 
[17:42:47.823]                         invokeRestart("muffleWarning")
[17:42:47.823]                     }
[17:42:47.823]                     else if (inherits(cond, "condition")) {
[17:42:47.823]                       if (!is.null(pattern)) {
[17:42:47.823]                         computeRestarts <- base::computeRestarts
[17:42:47.823]                         grepl <- base::grepl
[17:42:47.823]                         restarts <- computeRestarts(cond)
[17:42:47.823]                         for (restart in restarts) {
[17:42:47.823]                           name <- restart$name
[17:42:47.823]                           if (is.null(name)) 
[17:42:47.823]                             next
[17:42:47.823]                           if (!grepl(pattern, name)) 
[17:42:47.823]                             next
[17:42:47.823]                           invokeRestart(restart)
[17:42:47.823]                           muffled <- TRUE
[17:42:47.823]                           break
[17:42:47.823]                         }
[17:42:47.823]                       }
[17:42:47.823]                     }
[17:42:47.823]                     invisible(muffled)
[17:42:47.823]                   }
[17:42:47.823]                   muffleCondition(cond)
[17:42:47.823]                 })
[17:42:47.823]             }))
[17:42:47.823]             future::FutureResult(value = ...future.value$value, 
[17:42:47.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.823]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.823]                     ...future.globalenv.names))
[17:42:47.823]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.823]         }, condition = base::local({
[17:42:47.823]             c <- base::c
[17:42:47.823]             inherits <- base::inherits
[17:42:47.823]             invokeRestart <- base::invokeRestart
[17:42:47.823]             length <- base::length
[17:42:47.823]             list <- base::list
[17:42:47.823]             seq.int <- base::seq.int
[17:42:47.823]             signalCondition <- base::signalCondition
[17:42:47.823]             sys.calls <- base::sys.calls
[17:42:47.823]             `[[` <- base::`[[`
[17:42:47.823]             `+` <- base::`+`
[17:42:47.823]             `<<-` <- base::`<<-`
[17:42:47.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.823]                   3L)]
[17:42:47.823]             }
[17:42:47.823]             function(cond) {
[17:42:47.823]                 is_error <- inherits(cond, "error")
[17:42:47.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.823]                   NULL)
[17:42:47.823]                 if (is_error) {
[17:42:47.823]                   sessionInformation <- function() {
[17:42:47.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.823]                       search = base::search(), system = base::Sys.info())
[17:42:47.823]                   }
[17:42:47.823]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.823]                     cond$call), session = sessionInformation(), 
[17:42:47.823]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.823]                   signalCondition(cond)
[17:42:47.823]                 }
[17:42:47.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.823]                 "immediateCondition"))) {
[17:42:47.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.823]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.823]                   if (TRUE && !signal) {
[17:42:47.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.823]                     {
[17:42:47.823]                       inherits <- base::inherits
[17:42:47.823]                       invokeRestart <- base::invokeRestart
[17:42:47.823]                       is.null <- base::is.null
[17:42:47.823]                       muffled <- FALSE
[17:42:47.823]                       if (inherits(cond, "message")) {
[17:42:47.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.823]                         if (muffled) 
[17:42:47.823]                           invokeRestart("muffleMessage")
[17:42:47.823]                       }
[17:42:47.823]                       else if (inherits(cond, "warning")) {
[17:42:47.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.823]                         if (muffled) 
[17:42:47.823]                           invokeRestart("muffleWarning")
[17:42:47.823]                       }
[17:42:47.823]                       else if (inherits(cond, "condition")) {
[17:42:47.823]                         if (!is.null(pattern)) {
[17:42:47.823]                           computeRestarts <- base::computeRestarts
[17:42:47.823]                           grepl <- base::grepl
[17:42:47.823]                           restarts <- computeRestarts(cond)
[17:42:47.823]                           for (restart in restarts) {
[17:42:47.823]                             name <- restart$name
[17:42:47.823]                             if (is.null(name)) 
[17:42:47.823]                               next
[17:42:47.823]                             if (!grepl(pattern, name)) 
[17:42:47.823]                               next
[17:42:47.823]                             invokeRestart(restart)
[17:42:47.823]                             muffled <- TRUE
[17:42:47.823]                             break
[17:42:47.823]                           }
[17:42:47.823]                         }
[17:42:47.823]                       }
[17:42:47.823]                       invisible(muffled)
[17:42:47.823]                     }
[17:42:47.823]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.823]                   }
[17:42:47.823]                 }
[17:42:47.823]                 else {
[17:42:47.823]                   if (TRUE) {
[17:42:47.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.823]                     {
[17:42:47.823]                       inherits <- base::inherits
[17:42:47.823]                       invokeRestart <- base::invokeRestart
[17:42:47.823]                       is.null <- base::is.null
[17:42:47.823]                       muffled <- FALSE
[17:42:47.823]                       if (inherits(cond, "message")) {
[17:42:47.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.823]                         if (muffled) 
[17:42:47.823]                           invokeRestart("muffleMessage")
[17:42:47.823]                       }
[17:42:47.823]                       else if (inherits(cond, "warning")) {
[17:42:47.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.823]                         if (muffled) 
[17:42:47.823]                           invokeRestart("muffleWarning")
[17:42:47.823]                       }
[17:42:47.823]                       else if (inherits(cond, "condition")) {
[17:42:47.823]                         if (!is.null(pattern)) {
[17:42:47.823]                           computeRestarts <- base::computeRestarts
[17:42:47.823]                           grepl <- base::grepl
[17:42:47.823]                           restarts <- computeRestarts(cond)
[17:42:47.823]                           for (restart in restarts) {
[17:42:47.823]                             name <- restart$name
[17:42:47.823]                             if (is.null(name)) 
[17:42:47.823]                               next
[17:42:47.823]                             if (!grepl(pattern, name)) 
[17:42:47.823]                               next
[17:42:47.823]                             invokeRestart(restart)
[17:42:47.823]                             muffled <- TRUE
[17:42:47.823]                             break
[17:42:47.823]                           }
[17:42:47.823]                         }
[17:42:47.823]                       }
[17:42:47.823]                       invisible(muffled)
[17:42:47.823]                     }
[17:42:47.823]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.823]                   }
[17:42:47.823]                 }
[17:42:47.823]             }
[17:42:47.823]         }))
[17:42:47.823]     }, error = function(ex) {
[17:42:47.823]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.823]                 ...future.rng), started = ...future.startTime, 
[17:42:47.823]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.823]             version = "1.8"), class = "FutureResult")
[17:42:47.823]     }, finally = {
[17:42:47.823]         if (!identical(...future.workdir, getwd())) 
[17:42:47.823]             setwd(...future.workdir)
[17:42:47.823]         {
[17:42:47.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.823]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.823]             }
[17:42:47.823]             base::options(...future.oldOptions)
[17:42:47.823]             if (.Platform$OS.type == "windows") {
[17:42:47.823]                 old_names <- names(...future.oldEnvVars)
[17:42:47.823]                 envs <- base::Sys.getenv()
[17:42:47.823]                 names <- names(envs)
[17:42:47.823]                 common <- intersect(names, old_names)
[17:42:47.823]                 added <- setdiff(names, old_names)
[17:42:47.823]                 removed <- setdiff(old_names, names)
[17:42:47.823]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.823]                   envs[common]]
[17:42:47.823]                 NAMES <- toupper(changed)
[17:42:47.823]                 args <- list()
[17:42:47.823]                 for (kk in seq_along(NAMES)) {
[17:42:47.823]                   name <- changed[[kk]]
[17:42:47.823]                   NAME <- NAMES[[kk]]
[17:42:47.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.823]                     next
[17:42:47.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.823]                 }
[17:42:47.823]                 NAMES <- toupper(added)
[17:42:47.823]                 for (kk in seq_along(NAMES)) {
[17:42:47.823]                   name <- added[[kk]]
[17:42:47.823]                   NAME <- NAMES[[kk]]
[17:42:47.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.823]                     next
[17:42:47.823]                   args[[name]] <- ""
[17:42:47.823]                 }
[17:42:47.823]                 NAMES <- toupper(removed)
[17:42:47.823]                 for (kk in seq_along(NAMES)) {
[17:42:47.823]                   name <- removed[[kk]]
[17:42:47.823]                   NAME <- NAMES[[kk]]
[17:42:47.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.823]                     next
[17:42:47.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.823]                 }
[17:42:47.823]                 if (length(args) > 0) 
[17:42:47.823]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.823]             }
[17:42:47.823]             else {
[17:42:47.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.823]             }
[17:42:47.823]             {
[17:42:47.823]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.823]                   0L) {
[17:42:47.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.823]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.823]                   base::options(opts)
[17:42:47.823]                 }
[17:42:47.823]                 {
[17:42:47.823]                   {
[17:42:47.823]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.823]                     NULL
[17:42:47.823]                   }
[17:42:47.823]                   options(future.plan = NULL)
[17:42:47.823]                   if (is.na(NA_character_)) 
[17:42:47.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.823]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.823]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.823]                     envir = parent.frame()) 
[17:42:47.823]                   {
[17:42:47.823]                     if (is.function(workers)) 
[17:42:47.823]                       workers <- workers()
[17:42:47.823]                     workers <- structure(as.integer(workers), 
[17:42:47.823]                       class = class(workers))
[17:42:47.823]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.823]                       workers >= 1)
[17:42:47.823]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.823]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.823]                     }
[17:42:47.823]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.823]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.823]                       envir = envir)
[17:42:47.823]                     if (!future$lazy) 
[17:42:47.823]                       future <- run(future)
[17:42:47.823]                     invisible(future)
[17:42:47.823]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.823]                 }
[17:42:47.823]             }
[17:42:47.823]         }
[17:42:47.823]     })
[17:42:47.823]     if (TRUE) {
[17:42:47.823]         base::sink(type = "output", split = FALSE)
[17:42:47.823]         if (TRUE) {
[17:42:47.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.823]         }
[17:42:47.823]         else {
[17:42:47.823]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.823]         }
[17:42:47.823]         base::close(...future.stdout)
[17:42:47.823]         ...future.stdout <- NULL
[17:42:47.823]     }
[17:42:47.823]     ...future.result$conditions <- ...future.conditions
[17:42:47.823]     ...future.result$finished <- base::Sys.time()
[17:42:47.823]     ...future.result
[17:42:47.823] }
[17:42:47.826] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:42:47.827] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:42:47.879] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:42:47.879] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:42:47.880] MultisessionFuture started
[17:42:47.880] - Launch lazy future ... done
[17:42:47.880] run() for ‘MultisessionFuture’ ... done
[17:42:47.881] result() for ClusterFuture ...
[17:42:47.881] receiveMessageFromWorker() for ClusterFuture ...
[17:42:47.881] - Validating connection of MultisessionFuture
[17:42:47.929] - received message: FutureResult
[17:42:47.929] - Received FutureResult
[17:42:47.929] - Erased future from FutureRegistry
[17:42:47.929] result() for ClusterFuture ...
[17:42:47.929] - result already collected: FutureResult
[17:42:47.929] result() for ClusterFuture ... done
[17:42:47.929] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:47.929] result() for ClusterFuture ... done
[17:42:47.930] result() for ClusterFuture ...
[17:42:47.930] - result already collected: FutureResult
[17:42:47.930] result() for ClusterFuture ... done
value(b) = 2
[17:42:47.930] result() for ClusterFuture ...
[17:42:47.930] - result already collected: FutureResult
[17:42:47.930] result() for ClusterFuture ... done
[17:42:47.930] result() for ClusterFuture ...
[17:42:47.930] - result already collected: FutureResult
[17:42:47.930] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.931] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.931] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.932] 
[17:42:47.932] Searching for globals ... DONE
[17:42:47.932] - globals: [0] <none>
[17:42:47.932] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:47.932] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:47.932] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:47.933] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:47.933] Searching for globals ... DONE
[17:42:47.934] Resolving globals: TRUE
[17:42:47.934] Resolving any globals that are futures ...
[17:42:47.934] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:47.934] Resolving any globals that are futures ... DONE
[17:42:47.934] Resolving futures part of globals (recursively) ...
[17:42:47.934] resolve() on list ...
[17:42:47.935]  recursive: 99
[17:42:47.935]  length: 1
[17:42:47.935]  elements: ‘a’
[17:42:47.935] run() for ‘Future’ ...
[17:42:47.938] - state: ‘created’
[17:42:47.938] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:47.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:47.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:47.953]   - Field: ‘node’
[17:42:47.953]   - Field: ‘label’
[17:42:47.954]   - Field: ‘local’
[17:42:47.954]   - Field: ‘owner’
[17:42:47.954]   - Field: ‘envir’
[17:42:47.954]   - Field: ‘workers’
[17:42:47.954]   - Field: ‘packages’
[17:42:47.954]   - Field: ‘gc’
[17:42:47.954]   - Field: ‘conditions’
[17:42:47.954]   - Field: ‘persistent’
[17:42:47.954]   - Field: ‘expr’
[17:42:47.954]   - Field: ‘uuid’
[17:42:47.954]   - Field: ‘seed’
[17:42:47.955]   - Field: ‘version’
[17:42:47.955]   - Field: ‘result’
[17:42:47.955]   - Field: ‘asynchronous’
[17:42:47.955]   - Field: ‘calls’
[17:42:47.955]   - Field: ‘globals’
[17:42:47.955]   - Field: ‘stdout’
[17:42:47.955]   - Field: ‘earlySignal’
[17:42:47.955]   - Field: ‘lazy’
[17:42:47.955]   - Field: ‘state’
[17:42:47.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:47.955] - Launch lazy future ...
[17:42:47.956] Packages needed by the future expression (n = 0): <none>
[17:42:47.956] Packages needed by future strategies (n = 0): <none>
[17:42:47.956] {
[17:42:47.956]     {
[17:42:47.956]         {
[17:42:47.956]             ...future.startTime <- base::Sys.time()
[17:42:47.956]             {
[17:42:47.956]                 {
[17:42:47.956]                   {
[17:42:47.956]                     {
[17:42:47.956]                       base::local({
[17:42:47.956]                         has_future <- base::requireNamespace("future", 
[17:42:47.956]                           quietly = TRUE)
[17:42:47.956]                         if (has_future) {
[17:42:47.956]                           ns <- base::getNamespace("future")
[17:42:47.956]                           version <- ns[[".package"]][["version"]]
[17:42:47.956]                           if (is.null(version)) 
[17:42:47.956]                             version <- utils::packageVersion("future")
[17:42:47.956]                         }
[17:42:47.956]                         else {
[17:42:47.956]                           version <- NULL
[17:42:47.956]                         }
[17:42:47.956]                         if (!has_future || version < "1.8.0") {
[17:42:47.956]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:47.956]                             "", base::R.version$version.string), 
[17:42:47.956]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:47.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:47.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:47.956]                               "release", "version")], collapse = " "), 
[17:42:47.956]                             hostname = base::Sys.info()[["nodename"]])
[17:42:47.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:47.956]                             info)
[17:42:47.956]                           info <- base::paste(info, collapse = "; ")
[17:42:47.956]                           if (!has_future) {
[17:42:47.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:47.956]                               info)
[17:42:47.956]                           }
[17:42:47.956]                           else {
[17:42:47.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:47.956]                               info, version)
[17:42:47.956]                           }
[17:42:47.956]                           base::stop(msg)
[17:42:47.956]                         }
[17:42:47.956]                       })
[17:42:47.956]                     }
[17:42:47.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:47.956]                     base::options(mc.cores = 1L)
[17:42:47.956]                   }
[17:42:47.956]                   options(future.plan = NULL)
[17:42:47.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:47.956]                 }
[17:42:47.956]                 ...future.workdir <- getwd()
[17:42:47.956]             }
[17:42:47.956]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:47.956]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:47.956]         }
[17:42:47.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:47.956]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:47.956]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:47.956]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:47.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:47.956]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:47.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:47.956]             base::names(...future.oldOptions))
[17:42:47.956]     }
[17:42:47.956]     if (FALSE) {
[17:42:47.956]     }
[17:42:47.956]     else {
[17:42:47.956]         if (TRUE) {
[17:42:47.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:47.956]                 open = "w")
[17:42:47.956]         }
[17:42:47.956]         else {
[17:42:47.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:47.956]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:47.956]         }
[17:42:47.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:47.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:47.956]             base::sink(type = "output", split = FALSE)
[17:42:47.956]             base::close(...future.stdout)
[17:42:47.956]         }, add = TRUE)
[17:42:47.956]     }
[17:42:47.956]     ...future.frame <- base::sys.nframe()
[17:42:47.956]     ...future.conditions <- base::list()
[17:42:47.956]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:47.956]     if (FALSE) {
[17:42:47.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:47.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:47.956]     }
[17:42:47.956]     ...future.result <- base::tryCatch({
[17:42:47.956]         base::withCallingHandlers({
[17:42:47.956]             ...future.value <- base::withVisible(base::local({
[17:42:47.956]                 ...future.makeSendCondition <- local({
[17:42:47.956]                   sendCondition <- NULL
[17:42:47.956]                   function(frame = 1L) {
[17:42:47.956]                     if (is.function(sendCondition)) 
[17:42:47.956]                       return(sendCondition)
[17:42:47.956]                     ns <- getNamespace("parallel")
[17:42:47.956]                     if (exists("sendData", mode = "function", 
[17:42:47.956]                       envir = ns)) {
[17:42:47.956]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:47.956]                         envir = ns)
[17:42:47.956]                       envir <- sys.frame(frame)
[17:42:47.956]                       master <- NULL
[17:42:47.956]                       while (!identical(envir, .GlobalEnv) && 
[17:42:47.956]                         !identical(envir, emptyenv())) {
[17:42:47.956]                         if (exists("master", mode = "list", envir = envir, 
[17:42:47.956]                           inherits = FALSE)) {
[17:42:47.956]                           master <- get("master", mode = "list", 
[17:42:47.956]                             envir = envir, inherits = FALSE)
[17:42:47.956]                           if (inherits(master, c("SOCKnode", 
[17:42:47.956]                             "SOCK0node"))) {
[17:42:47.956]                             sendCondition <<- function(cond) {
[17:42:47.956]                               data <- list(type = "VALUE", value = cond, 
[17:42:47.956]                                 success = TRUE)
[17:42:47.956]                               parallel_sendData(master, data)
[17:42:47.956]                             }
[17:42:47.956]                             return(sendCondition)
[17:42:47.956]                           }
[17:42:47.956]                         }
[17:42:47.956]                         frame <- frame + 1L
[17:42:47.956]                         envir <- sys.frame(frame)
[17:42:47.956]                       }
[17:42:47.956]                     }
[17:42:47.956]                     sendCondition <<- function(cond) NULL
[17:42:47.956]                   }
[17:42:47.956]                 })
[17:42:47.956]                 withCallingHandlers({
[17:42:47.956]                   1
[17:42:47.956]                 }, immediateCondition = function(cond) {
[17:42:47.956]                   sendCondition <- ...future.makeSendCondition()
[17:42:47.956]                   sendCondition(cond)
[17:42:47.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.956]                   {
[17:42:47.956]                     inherits <- base::inherits
[17:42:47.956]                     invokeRestart <- base::invokeRestart
[17:42:47.956]                     is.null <- base::is.null
[17:42:47.956]                     muffled <- FALSE
[17:42:47.956]                     if (inherits(cond, "message")) {
[17:42:47.956]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:47.956]                       if (muffled) 
[17:42:47.956]                         invokeRestart("muffleMessage")
[17:42:47.956]                     }
[17:42:47.956]                     else if (inherits(cond, "warning")) {
[17:42:47.956]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:47.956]                       if (muffled) 
[17:42:47.956]                         invokeRestart("muffleWarning")
[17:42:47.956]                     }
[17:42:47.956]                     else if (inherits(cond, "condition")) {
[17:42:47.956]                       if (!is.null(pattern)) {
[17:42:47.956]                         computeRestarts <- base::computeRestarts
[17:42:47.956]                         grepl <- base::grepl
[17:42:47.956]                         restarts <- computeRestarts(cond)
[17:42:47.956]                         for (restart in restarts) {
[17:42:47.956]                           name <- restart$name
[17:42:47.956]                           if (is.null(name)) 
[17:42:47.956]                             next
[17:42:47.956]                           if (!grepl(pattern, name)) 
[17:42:47.956]                             next
[17:42:47.956]                           invokeRestart(restart)
[17:42:47.956]                           muffled <- TRUE
[17:42:47.956]                           break
[17:42:47.956]                         }
[17:42:47.956]                       }
[17:42:47.956]                     }
[17:42:47.956]                     invisible(muffled)
[17:42:47.956]                   }
[17:42:47.956]                   muffleCondition(cond)
[17:42:47.956]                 })
[17:42:47.956]             }))
[17:42:47.956]             future::FutureResult(value = ...future.value$value, 
[17:42:47.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.956]                   ...future.rng), globalenv = if (FALSE) 
[17:42:47.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:47.956]                     ...future.globalenv.names))
[17:42:47.956]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:47.956]         }, condition = base::local({
[17:42:47.956]             c <- base::c
[17:42:47.956]             inherits <- base::inherits
[17:42:47.956]             invokeRestart <- base::invokeRestart
[17:42:47.956]             length <- base::length
[17:42:47.956]             list <- base::list
[17:42:47.956]             seq.int <- base::seq.int
[17:42:47.956]             signalCondition <- base::signalCondition
[17:42:47.956]             sys.calls <- base::sys.calls
[17:42:47.956]             `[[` <- base::`[[`
[17:42:47.956]             `+` <- base::`+`
[17:42:47.956]             `<<-` <- base::`<<-`
[17:42:47.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:47.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:47.956]                   3L)]
[17:42:47.956]             }
[17:42:47.956]             function(cond) {
[17:42:47.956]                 is_error <- inherits(cond, "error")
[17:42:47.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:47.956]                   NULL)
[17:42:47.956]                 if (is_error) {
[17:42:47.956]                   sessionInformation <- function() {
[17:42:47.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:47.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:47.956]                       search = base::search(), system = base::Sys.info())
[17:42:47.956]                   }
[17:42:47.956]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:47.956]                     cond$call), session = sessionInformation(), 
[17:42:47.956]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:47.956]                   signalCondition(cond)
[17:42:47.956]                 }
[17:42:47.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:47.956]                 "immediateCondition"))) {
[17:42:47.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:47.956]                   ...future.conditions[[length(...future.conditions) + 
[17:42:47.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:47.956]                   if (TRUE && !signal) {
[17:42:47.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.956]                     {
[17:42:47.956]                       inherits <- base::inherits
[17:42:47.956]                       invokeRestart <- base::invokeRestart
[17:42:47.956]                       is.null <- base::is.null
[17:42:47.956]                       muffled <- FALSE
[17:42:47.956]                       if (inherits(cond, "message")) {
[17:42:47.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.956]                         if (muffled) 
[17:42:47.956]                           invokeRestart("muffleMessage")
[17:42:47.956]                       }
[17:42:47.956]                       else if (inherits(cond, "warning")) {
[17:42:47.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.956]                         if (muffled) 
[17:42:47.956]                           invokeRestart("muffleWarning")
[17:42:47.956]                       }
[17:42:47.956]                       else if (inherits(cond, "condition")) {
[17:42:47.956]                         if (!is.null(pattern)) {
[17:42:47.956]                           computeRestarts <- base::computeRestarts
[17:42:47.956]                           grepl <- base::grepl
[17:42:47.956]                           restarts <- computeRestarts(cond)
[17:42:47.956]                           for (restart in restarts) {
[17:42:47.956]                             name <- restart$name
[17:42:47.956]                             if (is.null(name)) 
[17:42:47.956]                               next
[17:42:47.956]                             if (!grepl(pattern, name)) 
[17:42:47.956]                               next
[17:42:47.956]                             invokeRestart(restart)
[17:42:47.956]                             muffled <- TRUE
[17:42:47.956]                             break
[17:42:47.956]                           }
[17:42:47.956]                         }
[17:42:47.956]                       }
[17:42:47.956]                       invisible(muffled)
[17:42:47.956]                     }
[17:42:47.956]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.956]                   }
[17:42:47.956]                 }
[17:42:47.956]                 else {
[17:42:47.956]                   if (TRUE) {
[17:42:47.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:47.956]                     {
[17:42:47.956]                       inherits <- base::inherits
[17:42:47.956]                       invokeRestart <- base::invokeRestart
[17:42:47.956]                       is.null <- base::is.null
[17:42:47.956]                       muffled <- FALSE
[17:42:47.956]                       if (inherits(cond, "message")) {
[17:42:47.956]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:47.956]                         if (muffled) 
[17:42:47.956]                           invokeRestart("muffleMessage")
[17:42:47.956]                       }
[17:42:47.956]                       else if (inherits(cond, "warning")) {
[17:42:47.956]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:47.956]                         if (muffled) 
[17:42:47.956]                           invokeRestart("muffleWarning")
[17:42:47.956]                       }
[17:42:47.956]                       else if (inherits(cond, "condition")) {
[17:42:47.956]                         if (!is.null(pattern)) {
[17:42:47.956]                           computeRestarts <- base::computeRestarts
[17:42:47.956]                           grepl <- base::grepl
[17:42:47.956]                           restarts <- computeRestarts(cond)
[17:42:47.956]                           for (restart in restarts) {
[17:42:47.956]                             name <- restart$name
[17:42:47.956]                             if (is.null(name)) 
[17:42:47.956]                               next
[17:42:47.956]                             if (!grepl(pattern, name)) 
[17:42:47.956]                               next
[17:42:47.956]                             invokeRestart(restart)
[17:42:47.956]                             muffled <- TRUE
[17:42:47.956]                             break
[17:42:47.956]                           }
[17:42:47.956]                         }
[17:42:47.956]                       }
[17:42:47.956]                       invisible(muffled)
[17:42:47.956]                     }
[17:42:47.956]                     muffleCondition(cond, pattern = "^muffle")
[17:42:47.956]                   }
[17:42:47.956]                 }
[17:42:47.956]             }
[17:42:47.956]         }))
[17:42:47.956]     }, error = function(ex) {
[17:42:47.956]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:47.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:47.956]                 ...future.rng), started = ...future.startTime, 
[17:42:47.956]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:47.956]             version = "1.8"), class = "FutureResult")
[17:42:47.956]     }, finally = {
[17:42:47.956]         if (!identical(...future.workdir, getwd())) 
[17:42:47.956]             setwd(...future.workdir)
[17:42:47.956]         {
[17:42:47.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:47.956]                 ...future.oldOptions$nwarnings <- NULL
[17:42:47.956]             }
[17:42:47.956]             base::options(...future.oldOptions)
[17:42:47.956]             if (.Platform$OS.type == "windows") {
[17:42:47.956]                 old_names <- names(...future.oldEnvVars)
[17:42:47.956]                 envs <- base::Sys.getenv()
[17:42:47.956]                 names <- names(envs)
[17:42:47.956]                 common <- intersect(names, old_names)
[17:42:47.956]                 added <- setdiff(names, old_names)
[17:42:47.956]                 removed <- setdiff(old_names, names)
[17:42:47.956]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:47.956]                   envs[common]]
[17:42:47.956]                 NAMES <- toupper(changed)
[17:42:47.956]                 args <- list()
[17:42:47.956]                 for (kk in seq_along(NAMES)) {
[17:42:47.956]                   name <- changed[[kk]]
[17:42:47.956]                   NAME <- NAMES[[kk]]
[17:42:47.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.956]                     next
[17:42:47.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.956]                 }
[17:42:47.956]                 NAMES <- toupper(added)
[17:42:47.956]                 for (kk in seq_along(NAMES)) {
[17:42:47.956]                   name <- added[[kk]]
[17:42:47.956]                   NAME <- NAMES[[kk]]
[17:42:47.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.956]                     next
[17:42:47.956]                   args[[name]] <- ""
[17:42:47.956]                 }
[17:42:47.956]                 NAMES <- toupper(removed)
[17:42:47.956]                 for (kk in seq_along(NAMES)) {
[17:42:47.956]                   name <- removed[[kk]]
[17:42:47.956]                   NAME <- NAMES[[kk]]
[17:42:47.956]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:47.956]                     next
[17:42:47.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:47.956]                 }
[17:42:47.956]                 if (length(args) > 0) 
[17:42:47.956]                   base::do.call(base::Sys.setenv, args = args)
[17:42:47.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:47.956]             }
[17:42:47.956]             else {
[17:42:47.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:47.956]             }
[17:42:47.956]             {
[17:42:47.956]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:47.956]                   0L) {
[17:42:47.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:47.956]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:47.956]                   base::options(opts)
[17:42:47.956]                 }
[17:42:47.956]                 {
[17:42:47.956]                   {
[17:42:47.956]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:47.956]                     NULL
[17:42:47.956]                   }
[17:42:47.956]                   options(future.plan = NULL)
[17:42:47.956]                   if (is.na(NA_character_)) 
[17:42:47.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:47.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:47.956]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:47.956]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:47.956]                     envir = parent.frame()) 
[17:42:47.956]                   {
[17:42:47.956]                     if (is.function(workers)) 
[17:42:47.956]                       workers <- workers()
[17:42:47.956]                     workers <- structure(as.integer(workers), 
[17:42:47.956]                       class = class(workers))
[17:42:47.956]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:47.956]                       workers >= 1)
[17:42:47.956]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:47.956]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:47.956]                     }
[17:42:47.956]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:47.956]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:47.956]                       envir = envir)
[17:42:47.956]                     if (!future$lazy) 
[17:42:47.956]                       future <- run(future)
[17:42:47.956]                     invisible(future)
[17:42:47.956]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:47.956]                 }
[17:42:47.956]             }
[17:42:47.956]         }
[17:42:47.956]     })
[17:42:47.956]     if (TRUE) {
[17:42:47.956]         base::sink(type = "output", split = FALSE)
[17:42:47.956]         if (TRUE) {
[17:42:47.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:47.956]         }
[17:42:47.956]         else {
[17:42:47.956]             ...future.result["stdout"] <- base::list(NULL)
[17:42:47.956]         }
[17:42:47.956]         base::close(...future.stdout)
[17:42:47.956]         ...future.stdout <- NULL
[17:42:47.956]     }
[17:42:47.956]     ...future.result$conditions <- ...future.conditions
[17:42:47.956]     ...future.result$finished <- base::Sys.time()
[17:42:47.956]     ...future.result
[17:42:47.956] }
[17:42:47.959] MultisessionFuture started
[17:42:47.960] - Launch lazy future ... done
[17:42:47.960] run() for ‘MultisessionFuture’ ... done
[17:42:48.008] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.008] - Validating connection of MultisessionFuture
[17:42:48.009] - received message: FutureResult
[17:42:48.009] - Received FutureResult
[17:42:48.009] - Erased future from FutureRegistry
[17:42:48.009] result() for ClusterFuture ...
[17:42:48.009] - result already collected: FutureResult
[17:42:48.009] result() for ClusterFuture ... done
[17:42:48.009] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.009] Future #1
[17:42:48.009] result() for ClusterFuture ...
[17:42:48.010] - result already collected: FutureResult
[17:42:48.010] result() for ClusterFuture ... done
[17:42:48.010] result() for ClusterFuture ...
[17:42:48.010] - result already collected: FutureResult
[17:42:48.010] result() for ClusterFuture ... done
[17:42:48.010] A MultisessionFuture was resolved
[17:42:48.010]  length: 0 (resolved future 1)
[17:42:48.010] resolve() on list ... DONE
[17:42:48.010] - globals: [1] ‘a’
[17:42:48.010] Resolving futures part of globals (recursively) ... DONE
[17:42:48.011] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[17:42:48.012] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[17:42:48.012] - globals: [1] ‘a’
[17:42:48.012] - packages: [1] ‘future’
[17:42:48.012] getGlobalsAndPackages() ... DONE
[17:42:48.012] run() for ‘Future’ ...
[17:42:48.013] - state: ‘created’
[17:42:48.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.028]   - Field: ‘node’
[17:42:48.028]   - Field: ‘label’
[17:42:48.028]   - Field: ‘local’
[17:42:48.028]   - Field: ‘owner’
[17:42:48.028]   - Field: ‘envir’
[17:42:48.028]   - Field: ‘workers’
[17:42:48.028]   - Field: ‘packages’
[17:42:48.029]   - Field: ‘gc’
[17:42:48.029]   - Field: ‘conditions’
[17:42:48.029]   - Field: ‘persistent’
[17:42:48.029]   - Field: ‘expr’
[17:42:48.029]   - Field: ‘uuid’
[17:42:48.029]   - Field: ‘seed’
[17:42:48.029]   - Field: ‘version’
[17:42:48.029]   - Field: ‘result’
[17:42:48.029]   - Field: ‘asynchronous’
[17:42:48.029]   - Field: ‘calls’
[17:42:48.029]   - Field: ‘globals’
[17:42:48.030]   - Field: ‘stdout’
[17:42:48.030]   - Field: ‘earlySignal’
[17:42:48.030]   - Field: ‘lazy’
[17:42:48.030]   - Field: ‘state’
[17:42:48.030] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.030] - Launch lazy future ...
[17:42:48.030] Packages needed by the future expression (n = 1): ‘future’
[17:42:48.030] Packages needed by future strategies (n = 0): <none>
[17:42:48.031] {
[17:42:48.031]     {
[17:42:48.031]         {
[17:42:48.031]             ...future.startTime <- base::Sys.time()
[17:42:48.031]             {
[17:42:48.031]                 {
[17:42:48.031]                   {
[17:42:48.031]                     {
[17:42:48.031]                       {
[17:42:48.031]                         base::local({
[17:42:48.031]                           has_future <- base::requireNamespace("future", 
[17:42:48.031]                             quietly = TRUE)
[17:42:48.031]                           if (has_future) {
[17:42:48.031]                             ns <- base::getNamespace("future")
[17:42:48.031]                             version <- ns[[".package"]][["version"]]
[17:42:48.031]                             if (is.null(version)) 
[17:42:48.031]                               version <- utils::packageVersion("future")
[17:42:48.031]                           }
[17:42:48.031]                           else {
[17:42:48.031]                             version <- NULL
[17:42:48.031]                           }
[17:42:48.031]                           if (!has_future || version < "1.8.0") {
[17:42:48.031]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.031]                               "", base::R.version$version.string), 
[17:42:48.031]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:48.031]                                 base::R.version$platform, 8 * 
[17:42:48.031]                                   base::.Machine$sizeof.pointer), 
[17:42:48.031]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.031]                                 "release", "version")], collapse = " "), 
[17:42:48.031]                               hostname = base::Sys.info()[["nodename"]])
[17:42:48.031]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.031]                               info)
[17:42:48.031]                             info <- base::paste(info, collapse = "; ")
[17:42:48.031]                             if (!has_future) {
[17:42:48.031]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.031]                                 info)
[17:42:48.031]                             }
[17:42:48.031]                             else {
[17:42:48.031]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.031]                                 info, version)
[17:42:48.031]                             }
[17:42:48.031]                             base::stop(msg)
[17:42:48.031]                           }
[17:42:48.031]                         })
[17:42:48.031]                       }
[17:42:48.031]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.031]                       base::options(mc.cores = 1L)
[17:42:48.031]                     }
[17:42:48.031]                     base::local({
[17:42:48.031]                       for (pkg in "future") {
[17:42:48.031]                         base::loadNamespace(pkg)
[17:42:48.031]                         base::library(pkg, character.only = TRUE)
[17:42:48.031]                       }
[17:42:48.031]                     })
[17:42:48.031]                   }
[17:42:48.031]                   options(future.plan = NULL)
[17:42:48.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.031]                 }
[17:42:48.031]                 ...future.workdir <- getwd()
[17:42:48.031]             }
[17:42:48.031]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.031]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.031]         }
[17:42:48.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.031]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:48.031]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.031]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.031]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.031]             base::names(...future.oldOptions))
[17:42:48.031]     }
[17:42:48.031]     if (FALSE) {
[17:42:48.031]     }
[17:42:48.031]     else {
[17:42:48.031]         if (TRUE) {
[17:42:48.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.031]                 open = "w")
[17:42:48.031]         }
[17:42:48.031]         else {
[17:42:48.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.031]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.031]         }
[17:42:48.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.031]             base::sink(type = "output", split = FALSE)
[17:42:48.031]             base::close(...future.stdout)
[17:42:48.031]         }, add = TRUE)
[17:42:48.031]     }
[17:42:48.031]     ...future.frame <- base::sys.nframe()
[17:42:48.031]     ...future.conditions <- base::list()
[17:42:48.031]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.031]     if (FALSE) {
[17:42:48.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.031]     }
[17:42:48.031]     ...future.result <- base::tryCatch({
[17:42:48.031]         base::withCallingHandlers({
[17:42:48.031]             ...future.value <- base::withVisible(base::local({
[17:42:48.031]                 ...future.makeSendCondition <- local({
[17:42:48.031]                   sendCondition <- NULL
[17:42:48.031]                   function(frame = 1L) {
[17:42:48.031]                     if (is.function(sendCondition)) 
[17:42:48.031]                       return(sendCondition)
[17:42:48.031]                     ns <- getNamespace("parallel")
[17:42:48.031]                     if (exists("sendData", mode = "function", 
[17:42:48.031]                       envir = ns)) {
[17:42:48.031]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.031]                         envir = ns)
[17:42:48.031]                       envir <- sys.frame(frame)
[17:42:48.031]                       master <- NULL
[17:42:48.031]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.031]                         !identical(envir, emptyenv())) {
[17:42:48.031]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.031]                           inherits = FALSE)) {
[17:42:48.031]                           master <- get("master", mode = "list", 
[17:42:48.031]                             envir = envir, inherits = FALSE)
[17:42:48.031]                           if (inherits(master, c("SOCKnode", 
[17:42:48.031]                             "SOCK0node"))) {
[17:42:48.031]                             sendCondition <<- function(cond) {
[17:42:48.031]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.031]                                 success = TRUE)
[17:42:48.031]                               parallel_sendData(master, data)
[17:42:48.031]                             }
[17:42:48.031]                             return(sendCondition)
[17:42:48.031]                           }
[17:42:48.031]                         }
[17:42:48.031]                         frame <- frame + 1L
[17:42:48.031]                         envir <- sys.frame(frame)
[17:42:48.031]                       }
[17:42:48.031]                     }
[17:42:48.031]                     sendCondition <<- function(cond) NULL
[17:42:48.031]                   }
[17:42:48.031]                 })
[17:42:48.031]                 withCallingHandlers({
[17:42:48.031]                   value(a) + 1
[17:42:48.031]                 }, immediateCondition = function(cond) {
[17:42:48.031]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.031]                   sendCondition(cond)
[17:42:48.031]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.031]                   {
[17:42:48.031]                     inherits <- base::inherits
[17:42:48.031]                     invokeRestart <- base::invokeRestart
[17:42:48.031]                     is.null <- base::is.null
[17:42:48.031]                     muffled <- FALSE
[17:42:48.031]                     if (inherits(cond, "message")) {
[17:42:48.031]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.031]                       if (muffled) 
[17:42:48.031]                         invokeRestart("muffleMessage")
[17:42:48.031]                     }
[17:42:48.031]                     else if (inherits(cond, "warning")) {
[17:42:48.031]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.031]                       if (muffled) 
[17:42:48.031]                         invokeRestart("muffleWarning")
[17:42:48.031]                     }
[17:42:48.031]                     else if (inherits(cond, "condition")) {
[17:42:48.031]                       if (!is.null(pattern)) {
[17:42:48.031]                         computeRestarts <- base::computeRestarts
[17:42:48.031]                         grepl <- base::grepl
[17:42:48.031]                         restarts <- computeRestarts(cond)
[17:42:48.031]                         for (restart in restarts) {
[17:42:48.031]                           name <- restart$name
[17:42:48.031]                           if (is.null(name)) 
[17:42:48.031]                             next
[17:42:48.031]                           if (!grepl(pattern, name)) 
[17:42:48.031]                             next
[17:42:48.031]                           invokeRestart(restart)
[17:42:48.031]                           muffled <- TRUE
[17:42:48.031]                           break
[17:42:48.031]                         }
[17:42:48.031]                       }
[17:42:48.031]                     }
[17:42:48.031]                     invisible(muffled)
[17:42:48.031]                   }
[17:42:48.031]                   muffleCondition(cond)
[17:42:48.031]                 })
[17:42:48.031]             }))
[17:42:48.031]             future::FutureResult(value = ...future.value$value, 
[17:42:48.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.031]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.031]                     ...future.globalenv.names))
[17:42:48.031]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.031]         }, condition = base::local({
[17:42:48.031]             c <- base::c
[17:42:48.031]             inherits <- base::inherits
[17:42:48.031]             invokeRestart <- base::invokeRestart
[17:42:48.031]             length <- base::length
[17:42:48.031]             list <- base::list
[17:42:48.031]             seq.int <- base::seq.int
[17:42:48.031]             signalCondition <- base::signalCondition
[17:42:48.031]             sys.calls <- base::sys.calls
[17:42:48.031]             `[[` <- base::`[[`
[17:42:48.031]             `+` <- base::`+`
[17:42:48.031]             `<<-` <- base::`<<-`
[17:42:48.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.031]                   3L)]
[17:42:48.031]             }
[17:42:48.031]             function(cond) {
[17:42:48.031]                 is_error <- inherits(cond, "error")
[17:42:48.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.031]                   NULL)
[17:42:48.031]                 if (is_error) {
[17:42:48.031]                   sessionInformation <- function() {
[17:42:48.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.031]                       search = base::search(), system = base::Sys.info())
[17:42:48.031]                   }
[17:42:48.031]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.031]                     cond$call), session = sessionInformation(), 
[17:42:48.031]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.031]                   signalCondition(cond)
[17:42:48.031]                 }
[17:42:48.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.031]                 "immediateCondition"))) {
[17:42:48.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.031]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.031]                   if (TRUE && !signal) {
[17:42:48.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.031]                     {
[17:42:48.031]                       inherits <- base::inherits
[17:42:48.031]                       invokeRestart <- base::invokeRestart
[17:42:48.031]                       is.null <- base::is.null
[17:42:48.031]                       muffled <- FALSE
[17:42:48.031]                       if (inherits(cond, "message")) {
[17:42:48.031]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.031]                         if (muffled) 
[17:42:48.031]                           invokeRestart("muffleMessage")
[17:42:48.031]                       }
[17:42:48.031]                       else if (inherits(cond, "warning")) {
[17:42:48.031]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.031]                         if (muffled) 
[17:42:48.031]                           invokeRestart("muffleWarning")
[17:42:48.031]                       }
[17:42:48.031]                       else if (inherits(cond, "condition")) {
[17:42:48.031]                         if (!is.null(pattern)) {
[17:42:48.031]                           computeRestarts <- base::computeRestarts
[17:42:48.031]                           grepl <- base::grepl
[17:42:48.031]                           restarts <- computeRestarts(cond)
[17:42:48.031]                           for (restart in restarts) {
[17:42:48.031]                             name <- restart$name
[17:42:48.031]                             if (is.null(name)) 
[17:42:48.031]                               next
[17:42:48.031]                             if (!grepl(pattern, name)) 
[17:42:48.031]                               next
[17:42:48.031]                             invokeRestart(restart)
[17:42:48.031]                             muffled <- TRUE
[17:42:48.031]                             break
[17:42:48.031]                           }
[17:42:48.031]                         }
[17:42:48.031]                       }
[17:42:48.031]                       invisible(muffled)
[17:42:48.031]                     }
[17:42:48.031]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.031]                   }
[17:42:48.031]                 }
[17:42:48.031]                 else {
[17:42:48.031]                   if (TRUE) {
[17:42:48.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.031]                     {
[17:42:48.031]                       inherits <- base::inherits
[17:42:48.031]                       invokeRestart <- base::invokeRestart
[17:42:48.031]                       is.null <- base::is.null
[17:42:48.031]                       muffled <- FALSE
[17:42:48.031]                       if (inherits(cond, "message")) {
[17:42:48.031]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.031]                         if (muffled) 
[17:42:48.031]                           invokeRestart("muffleMessage")
[17:42:48.031]                       }
[17:42:48.031]                       else if (inherits(cond, "warning")) {
[17:42:48.031]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.031]                         if (muffled) 
[17:42:48.031]                           invokeRestart("muffleWarning")
[17:42:48.031]                       }
[17:42:48.031]                       else if (inherits(cond, "condition")) {
[17:42:48.031]                         if (!is.null(pattern)) {
[17:42:48.031]                           computeRestarts <- base::computeRestarts
[17:42:48.031]                           grepl <- base::grepl
[17:42:48.031]                           restarts <- computeRestarts(cond)
[17:42:48.031]                           for (restart in restarts) {
[17:42:48.031]                             name <- restart$name
[17:42:48.031]                             if (is.null(name)) 
[17:42:48.031]                               next
[17:42:48.031]                             if (!grepl(pattern, name)) 
[17:42:48.031]                               next
[17:42:48.031]                             invokeRestart(restart)
[17:42:48.031]                             muffled <- TRUE
[17:42:48.031]                             break
[17:42:48.031]                           }
[17:42:48.031]                         }
[17:42:48.031]                       }
[17:42:48.031]                       invisible(muffled)
[17:42:48.031]                     }
[17:42:48.031]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.031]                   }
[17:42:48.031]                 }
[17:42:48.031]             }
[17:42:48.031]         }))
[17:42:48.031]     }, error = function(ex) {
[17:42:48.031]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.031]                 ...future.rng), started = ...future.startTime, 
[17:42:48.031]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.031]             version = "1.8"), class = "FutureResult")
[17:42:48.031]     }, finally = {
[17:42:48.031]         if (!identical(...future.workdir, getwd())) 
[17:42:48.031]             setwd(...future.workdir)
[17:42:48.031]         {
[17:42:48.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.031]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.031]             }
[17:42:48.031]             base::options(...future.oldOptions)
[17:42:48.031]             if (.Platform$OS.type == "windows") {
[17:42:48.031]                 old_names <- names(...future.oldEnvVars)
[17:42:48.031]                 envs <- base::Sys.getenv()
[17:42:48.031]                 names <- names(envs)
[17:42:48.031]                 common <- intersect(names, old_names)
[17:42:48.031]                 added <- setdiff(names, old_names)
[17:42:48.031]                 removed <- setdiff(old_names, names)
[17:42:48.031]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.031]                   envs[common]]
[17:42:48.031]                 NAMES <- toupper(changed)
[17:42:48.031]                 args <- list()
[17:42:48.031]                 for (kk in seq_along(NAMES)) {
[17:42:48.031]                   name <- changed[[kk]]
[17:42:48.031]                   NAME <- NAMES[[kk]]
[17:42:48.031]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.031]                     next
[17:42:48.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.031]                 }
[17:42:48.031]                 NAMES <- toupper(added)
[17:42:48.031]                 for (kk in seq_along(NAMES)) {
[17:42:48.031]                   name <- added[[kk]]
[17:42:48.031]                   NAME <- NAMES[[kk]]
[17:42:48.031]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.031]                     next
[17:42:48.031]                   args[[name]] <- ""
[17:42:48.031]                 }
[17:42:48.031]                 NAMES <- toupper(removed)
[17:42:48.031]                 for (kk in seq_along(NAMES)) {
[17:42:48.031]                   name <- removed[[kk]]
[17:42:48.031]                   NAME <- NAMES[[kk]]
[17:42:48.031]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.031]                     next
[17:42:48.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.031]                 }
[17:42:48.031]                 if (length(args) > 0) 
[17:42:48.031]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.031]             }
[17:42:48.031]             else {
[17:42:48.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.031]             }
[17:42:48.031]             {
[17:42:48.031]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.031]                   0L) {
[17:42:48.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.031]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.031]                   base::options(opts)
[17:42:48.031]                 }
[17:42:48.031]                 {
[17:42:48.031]                   {
[17:42:48.031]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.031]                     NULL
[17:42:48.031]                   }
[17:42:48.031]                   options(future.plan = NULL)
[17:42:48.031]                   if (is.na(NA_character_)) 
[17:42:48.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.031]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.031]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.031]                     envir = parent.frame()) 
[17:42:48.031]                   {
[17:42:48.031]                     if (is.function(workers)) 
[17:42:48.031]                       workers <- workers()
[17:42:48.031]                     workers <- structure(as.integer(workers), 
[17:42:48.031]                       class = class(workers))
[17:42:48.031]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.031]                       workers >= 1)
[17:42:48.031]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.031]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.031]                     }
[17:42:48.031]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.031]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.031]                       envir = envir)
[17:42:48.031]                     if (!future$lazy) 
[17:42:48.031]                       future <- run(future)
[17:42:48.031]                     invisible(future)
[17:42:48.031]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.031]                 }
[17:42:48.031]             }
[17:42:48.031]         }
[17:42:48.031]     })
[17:42:48.031]     if (TRUE) {
[17:42:48.031]         base::sink(type = "output", split = FALSE)
[17:42:48.031]         if (TRUE) {
[17:42:48.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.031]         }
[17:42:48.031]         else {
[17:42:48.031]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.031]         }
[17:42:48.031]         base::close(...future.stdout)
[17:42:48.031]         ...future.stdout <- NULL
[17:42:48.031]     }
[17:42:48.031]     ...future.result$conditions <- ...future.conditions
[17:42:48.031]     ...future.result$finished <- base::Sys.time()
[17:42:48.031]     ...future.result
[17:42:48.031] }
[17:42:48.034] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[17:42:48.035] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[17:42:48.088] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[17:42:48.088] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[17:42:48.089] MultisessionFuture started
[17:42:48.089] - Launch lazy future ... done
[17:42:48.089] run() for ‘MultisessionFuture’ ... done
[17:42:48.089] result() for ClusterFuture ...
[17:42:48.089] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.089] - Validating connection of MultisessionFuture
[17:42:48.136] - received message: FutureResult
[17:42:48.137] - Received FutureResult
[17:42:48.137] - Erased future from FutureRegistry
[17:42:48.137] result() for ClusterFuture ...
[17:42:48.137] - result already collected: FutureResult
[17:42:48.137] result() for ClusterFuture ... done
[17:42:48.137] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.137] result() for ClusterFuture ... done
[17:42:48.137] result() for ClusterFuture ...
[17:42:48.138] - result already collected: FutureResult
[17:42:48.138] result() for ClusterFuture ... done
value(b) = 2
[17:42:48.138] result() for ClusterFuture ...
[17:42:48.138] - result already collected: FutureResult
[17:42:48.138] result() for ClusterFuture ... done
[17:42:48.138] result() for ClusterFuture ...
[17:42:48.138] - result already collected: FutureResult
[17:42:48.138] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.139] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.139] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[17:42:48.140] - globals found: [2] ‘{’, ‘pkg’
[17:42:48.140] Searching for globals ... DONE
[17:42:48.140] Resolving globals: TRUE
[17:42:48.140] Resolving any globals that are futures ...
[17:42:48.140] - globals: [2] ‘{’, ‘pkg’
[17:42:48.140] Resolving any globals that are futures ... DONE
[17:42:48.141] Resolving futures part of globals (recursively) ...
[17:42:48.141] resolve() on list ...
[17:42:48.141]  recursive: 99
[17:42:48.141]  length: 1
[17:42:48.141]  elements: ‘pkg’
[17:42:48.141]  length: 0 (resolved future 1)
[17:42:48.141] resolve() on list ... DONE
[17:42:48.141] - globals: [1] ‘pkg’
[17:42:48.141] Resolving futures part of globals (recursively) ... DONE
[17:42:48.142] The total size of the 1 globals is 112 bytes (112 bytes)
[17:42:48.142] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:42:48.142] - globals: [1] ‘pkg’
[17:42:48.142] 
[17:42:48.142] getGlobalsAndPackages() ... DONE
[17:42:48.143] Packages needed by the future expression (n = 0): <none>
[17:42:48.143] Packages needed by future strategies (n = 0): <none>
[17:42:48.143] {
[17:42:48.143]     {
[17:42:48.143]         {
[17:42:48.143]             ...future.startTime <- base::Sys.time()
[17:42:48.143]             {
[17:42:48.143]                 {
[17:42:48.143]                   {
[17:42:48.143]                     base::local({
[17:42:48.143]                       has_future <- base::requireNamespace("future", 
[17:42:48.143]                         quietly = TRUE)
[17:42:48.143]                       if (has_future) {
[17:42:48.143]                         ns <- base::getNamespace("future")
[17:42:48.143]                         version <- ns[[".package"]][["version"]]
[17:42:48.143]                         if (is.null(version)) 
[17:42:48.143]                           version <- utils::packageVersion("future")
[17:42:48.143]                       }
[17:42:48.143]                       else {
[17:42:48.143]                         version <- NULL
[17:42:48.143]                       }
[17:42:48.143]                       if (!has_future || version < "1.8.0") {
[17:42:48.143]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.143]                           "", base::R.version$version.string), 
[17:42:48.143]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:48.143]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.143]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.143]                             "release", "version")], collapse = " "), 
[17:42:48.143]                           hostname = base::Sys.info()[["nodename"]])
[17:42:48.143]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.143]                           info)
[17:42:48.143]                         info <- base::paste(info, collapse = "; ")
[17:42:48.143]                         if (!has_future) {
[17:42:48.143]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.143]                             info)
[17:42:48.143]                         }
[17:42:48.143]                         else {
[17:42:48.143]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.143]                             info, version)
[17:42:48.143]                         }
[17:42:48.143]                         base::stop(msg)
[17:42:48.143]                       }
[17:42:48.143]                     })
[17:42:48.143]                   }
[17:42:48.143]                   options(future.plan = NULL)
[17:42:48.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.143]                 }
[17:42:48.143]                 ...future.workdir <- getwd()
[17:42:48.143]             }
[17:42:48.143]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.143]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.143]         }
[17:42:48.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.143]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[17:42:48.143]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.143]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.143]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.143]             base::names(...future.oldOptions))
[17:42:48.143]     }
[17:42:48.143]     if (FALSE) {
[17:42:48.143]     }
[17:42:48.143]     else {
[17:42:48.143]         if (TRUE) {
[17:42:48.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.143]                 open = "w")
[17:42:48.143]         }
[17:42:48.143]         else {
[17:42:48.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.143]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.143]         }
[17:42:48.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.143]             base::sink(type = "output", split = FALSE)
[17:42:48.143]             base::close(...future.stdout)
[17:42:48.143]         }, add = TRUE)
[17:42:48.143]     }
[17:42:48.143]     ...future.frame <- base::sys.nframe()
[17:42:48.143]     ...future.conditions <- base::list()
[17:42:48.143]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.143]     if (FALSE) {
[17:42:48.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.143]     }
[17:42:48.143]     ...future.result <- base::tryCatch({
[17:42:48.143]         base::withCallingHandlers({
[17:42:48.143]             ...future.value <- base::withVisible(base::local({
[17:42:48.143]                 pkg
[17:42:48.143]             }))
[17:42:48.143]             future::FutureResult(value = ...future.value$value, 
[17:42:48.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.143]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.143]                     ...future.globalenv.names))
[17:42:48.143]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.143]         }, condition = base::local({
[17:42:48.143]             c <- base::c
[17:42:48.143]             inherits <- base::inherits
[17:42:48.143]             invokeRestart <- base::invokeRestart
[17:42:48.143]             length <- base::length
[17:42:48.143]             list <- base::list
[17:42:48.143]             seq.int <- base::seq.int
[17:42:48.143]             signalCondition <- base::signalCondition
[17:42:48.143]             sys.calls <- base::sys.calls
[17:42:48.143]             `[[` <- base::`[[`
[17:42:48.143]             `+` <- base::`+`
[17:42:48.143]             `<<-` <- base::`<<-`
[17:42:48.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.143]                   3L)]
[17:42:48.143]             }
[17:42:48.143]             function(cond) {
[17:42:48.143]                 is_error <- inherits(cond, "error")
[17:42:48.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.143]                   NULL)
[17:42:48.143]                 if (is_error) {
[17:42:48.143]                   sessionInformation <- function() {
[17:42:48.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.143]                       search = base::search(), system = base::Sys.info())
[17:42:48.143]                   }
[17:42:48.143]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.143]                     cond$call), session = sessionInformation(), 
[17:42:48.143]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.143]                   signalCondition(cond)
[17:42:48.143]                 }
[17:42:48.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.143]                 "immediateCondition"))) {
[17:42:48.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.143]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.143]                   if (TRUE && !signal) {
[17:42:48.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.143]                     {
[17:42:48.143]                       inherits <- base::inherits
[17:42:48.143]                       invokeRestart <- base::invokeRestart
[17:42:48.143]                       is.null <- base::is.null
[17:42:48.143]                       muffled <- FALSE
[17:42:48.143]                       if (inherits(cond, "message")) {
[17:42:48.143]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.143]                         if (muffled) 
[17:42:48.143]                           invokeRestart("muffleMessage")
[17:42:48.143]                       }
[17:42:48.143]                       else if (inherits(cond, "warning")) {
[17:42:48.143]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.143]                         if (muffled) 
[17:42:48.143]                           invokeRestart("muffleWarning")
[17:42:48.143]                       }
[17:42:48.143]                       else if (inherits(cond, "condition")) {
[17:42:48.143]                         if (!is.null(pattern)) {
[17:42:48.143]                           computeRestarts <- base::computeRestarts
[17:42:48.143]                           grepl <- base::grepl
[17:42:48.143]                           restarts <- computeRestarts(cond)
[17:42:48.143]                           for (restart in restarts) {
[17:42:48.143]                             name <- restart$name
[17:42:48.143]                             if (is.null(name)) 
[17:42:48.143]                               next
[17:42:48.143]                             if (!grepl(pattern, name)) 
[17:42:48.143]                               next
[17:42:48.143]                             invokeRestart(restart)
[17:42:48.143]                             muffled <- TRUE
[17:42:48.143]                             break
[17:42:48.143]                           }
[17:42:48.143]                         }
[17:42:48.143]                       }
[17:42:48.143]                       invisible(muffled)
[17:42:48.143]                     }
[17:42:48.143]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.143]                   }
[17:42:48.143]                 }
[17:42:48.143]                 else {
[17:42:48.143]                   if (TRUE) {
[17:42:48.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.143]                     {
[17:42:48.143]                       inherits <- base::inherits
[17:42:48.143]                       invokeRestart <- base::invokeRestart
[17:42:48.143]                       is.null <- base::is.null
[17:42:48.143]                       muffled <- FALSE
[17:42:48.143]                       if (inherits(cond, "message")) {
[17:42:48.143]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.143]                         if (muffled) 
[17:42:48.143]                           invokeRestart("muffleMessage")
[17:42:48.143]                       }
[17:42:48.143]                       else if (inherits(cond, "warning")) {
[17:42:48.143]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.143]                         if (muffled) 
[17:42:48.143]                           invokeRestart("muffleWarning")
[17:42:48.143]                       }
[17:42:48.143]                       else if (inherits(cond, "condition")) {
[17:42:48.143]                         if (!is.null(pattern)) {
[17:42:48.143]                           computeRestarts <- base::computeRestarts
[17:42:48.143]                           grepl <- base::grepl
[17:42:48.143]                           restarts <- computeRestarts(cond)
[17:42:48.143]                           for (restart in restarts) {
[17:42:48.143]                             name <- restart$name
[17:42:48.143]                             if (is.null(name)) 
[17:42:48.143]                               next
[17:42:48.143]                             if (!grepl(pattern, name)) 
[17:42:48.143]                               next
[17:42:48.143]                             invokeRestart(restart)
[17:42:48.143]                             muffled <- TRUE
[17:42:48.143]                             break
[17:42:48.143]                           }
[17:42:48.143]                         }
[17:42:48.143]                       }
[17:42:48.143]                       invisible(muffled)
[17:42:48.143]                     }
[17:42:48.143]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.143]                   }
[17:42:48.143]                 }
[17:42:48.143]             }
[17:42:48.143]         }))
[17:42:48.143]     }, error = function(ex) {
[17:42:48.143]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.143]                 ...future.rng), started = ...future.startTime, 
[17:42:48.143]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.143]             version = "1.8"), class = "FutureResult")
[17:42:48.143]     }, finally = {
[17:42:48.143]         if (!identical(...future.workdir, getwd())) 
[17:42:48.143]             setwd(...future.workdir)
[17:42:48.143]         {
[17:42:48.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.143]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.143]             }
[17:42:48.143]             base::options(...future.oldOptions)
[17:42:48.143]             if (.Platform$OS.type == "windows") {
[17:42:48.143]                 old_names <- names(...future.oldEnvVars)
[17:42:48.143]                 envs <- base::Sys.getenv()
[17:42:48.143]                 names <- names(envs)
[17:42:48.143]                 common <- intersect(names, old_names)
[17:42:48.143]                 added <- setdiff(names, old_names)
[17:42:48.143]                 removed <- setdiff(old_names, names)
[17:42:48.143]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.143]                   envs[common]]
[17:42:48.143]                 NAMES <- toupper(changed)
[17:42:48.143]                 args <- list()
[17:42:48.143]                 for (kk in seq_along(NAMES)) {
[17:42:48.143]                   name <- changed[[kk]]
[17:42:48.143]                   NAME <- NAMES[[kk]]
[17:42:48.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.143]                     next
[17:42:48.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.143]                 }
[17:42:48.143]                 NAMES <- toupper(added)
[17:42:48.143]                 for (kk in seq_along(NAMES)) {
[17:42:48.143]                   name <- added[[kk]]
[17:42:48.143]                   NAME <- NAMES[[kk]]
[17:42:48.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.143]                     next
[17:42:48.143]                   args[[name]] <- ""
[17:42:48.143]                 }
[17:42:48.143]                 NAMES <- toupper(removed)
[17:42:48.143]                 for (kk in seq_along(NAMES)) {
[17:42:48.143]                   name <- removed[[kk]]
[17:42:48.143]                   NAME <- NAMES[[kk]]
[17:42:48.143]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.143]                     next
[17:42:48.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.143]                 }
[17:42:48.143]                 if (length(args) > 0) 
[17:42:48.143]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.143]             }
[17:42:48.143]             else {
[17:42:48.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.143]             }
[17:42:48.143]             {
[17:42:48.143]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.143]                   0L) {
[17:42:48.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.143]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.143]                   base::options(opts)
[17:42:48.143]                 }
[17:42:48.143]                 {
[17:42:48.143]                   {
[17:42:48.143]                     NULL
[17:42:48.143]                     RNGkind("Mersenne-Twister")
[17:42:48.143]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:48.143]                       inherits = FALSE)
[17:42:48.143]                   }
[17:42:48.143]                   options(future.plan = NULL)
[17:42:48.143]                   if (is.na(NA_character_)) 
[17:42:48.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.143]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.143]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.143]                     envir = parent.frame()) 
[17:42:48.143]                   {
[17:42:48.143]                     if (is.function(workers)) 
[17:42:48.143]                       workers <- workers()
[17:42:48.143]                     workers <- structure(as.integer(workers), 
[17:42:48.143]                       class = class(workers))
[17:42:48.143]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.143]                       workers >= 1)
[17:42:48.143]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.143]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.143]                     }
[17:42:48.143]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.143]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.143]                       envir = envir)
[17:42:48.143]                     if (!future$lazy) 
[17:42:48.143]                       future <- run(future)
[17:42:48.143]                     invisible(future)
[17:42:48.143]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.143]                 }
[17:42:48.143]             }
[17:42:48.143]         }
[17:42:48.143]     })
[17:42:48.143]     if (TRUE) {
[17:42:48.143]         base::sink(type = "output", split = FALSE)
[17:42:48.143]         if (TRUE) {
[17:42:48.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.143]         }
[17:42:48.143]         else {
[17:42:48.143]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.143]         }
[17:42:48.143]         base::close(...future.stdout)
[17:42:48.143]         ...future.stdout <- NULL
[17:42:48.143]     }
[17:42:48.143]     ...future.result$conditions <- ...future.conditions
[17:42:48.143]     ...future.result$finished <- base::Sys.time()
[17:42:48.143]     ...future.result
[17:42:48.143] }
[17:42:48.145] assign_globals() ...
[17:42:48.145] List of 1
[17:42:48.145]  $ pkg: chr "foo"
[17:42:48.145]  - attr(*, "where")=List of 1
[17:42:48.145]   ..$ pkg:<environment: R_EmptyEnv> 
[17:42:48.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:48.145]  - attr(*, "resolved")= logi TRUE
[17:42:48.145]  - attr(*, "total_size")= num 112
[17:42:48.147] - copied ‘pkg’ to environment
[17:42:48.147] assign_globals() ... done
[17:42:48.148] plan(): Setting new future strategy stack:
[17:42:48.148] List of future strategies:
[17:42:48.148] 1. sequential:
[17:42:48.148]    - args: function (..., envir = parent.frame())
[17:42:48.148]    - tweaked: FALSE
[17:42:48.148]    - call: NULL
[17:42:48.148] plan(): nbrOfWorkers() = 1
[17:42:48.149] plan(): Setting new future strategy stack:
[17:42:48.149] List of future strategies:
[17:42:48.149] 1. multisession:
[17:42:48.149]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:48.149]    - tweaked: FALSE
[17:42:48.149]    - call: plan(strategy)
[17:42:48.153] plan(): nbrOfWorkers() = 2
[17:42:48.153] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.154] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.154] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.156] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:48.156] Searching for globals ... DONE
[17:42:48.156] Resolving globals: TRUE
[17:42:48.156] Resolving any globals that are futures ...
[17:42:48.156] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:48.156] Resolving any globals that are futures ... DONE
[17:42:48.156] Resolving futures part of globals (recursively) ...
[17:42:48.157] resolve() on list ...
[17:42:48.157]  recursive: 99
[17:42:48.157]  length: 1
[17:42:48.157]  elements: ‘a’
[17:42:48.157]  length: 0 (resolved future 1)
[17:42:48.157] resolve() on list ... DONE
[17:42:48.157] - globals: [1] ‘a’
[17:42:48.157] Resolving futures part of globals (recursively) ... DONE
[17:42:48.158] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:48.158] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:48.158] - globals: [1] ‘a’
[17:42:48.158] 
[17:42:48.158] getGlobalsAndPackages() ... DONE
[17:42:48.158] run() for ‘Future’ ...
[17:42:48.159] - state: ‘created’
[17:42:48.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.173]   - Field: ‘node’
[17:42:48.173]   - Field: ‘label’
[17:42:48.173]   - Field: ‘local’
[17:42:48.174]   - Field: ‘owner’
[17:42:48.174]   - Field: ‘envir’
[17:42:48.174]   - Field: ‘workers’
[17:42:48.174]   - Field: ‘packages’
[17:42:48.174]   - Field: ‘gc’
[17:42:48.174]   - Field: ‘conditions’
[17:42:48.174]   - Field: ‘persistent’
[17:42:48.174]   - Field: ‘expr’
[17:42:48.174]   - Field: ‘uuid’
[17:42:48.174]   - Field: ‘seed’
[17:42:48.174]   - Field: ‘version’
[17:42:48.175]   - Field: ‘result’
[17:42:48.175]   - Field: ‘asynchronous’
[17:42:48.175]   - Field: ‘calls’
[17:42:48.175]   - Field: ‘globals’
[17:42:48.175]   - Field: ‘stdout’
[17:42:48.175]   - Field: ‘earlySignal’
[17:42:48.175]   - Field: ‘lazy’
[17:42:48.175]   - Field: ‘state’
[17:42:48.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.175] - Launch lazy future ...
[17:42:48.176] Packages needed by the future expression (n = 0): <none>
[17:42:48.176] Packages needed by future strategies (n = 0): <none>
[17:42:48.176] {
[17:42:48.176]     {
[17:42:48.176]         {
[17:42:48.176]             ...future.startTime <- base::Sys.time()
[17:42:48.176]             {
[17:42:48.176]                 {
[17:42:48.176]                   {
[17:42:48.176]                     {
[17:42:48.176]                       base::local({
[17:42:48.176]                         has_future <- base::requireNamespace("future", 
[17:42:48.176]                           quietly = TRUE)
[17:42:48.176]                         if (has_future) {
[17:42:48.176]                           ns <- base::getNamespace("future")
[17:42:48.176]                           version <- ns[[".package"]][["version"]]
[17:42:48.176]                           if (is.null(version)) 
[17:42:48.176]                             version <- utils::packageVersion("future")
[17:42:48.176]                         }
[17:42:48.176]                         else {
[17:42:48.176]                           version <- NULL
[17:42:48.176]                         }
[17:42:48.176]                         if (!has_future || version < "1.8.0") {
[17:42:48.176]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.176]                             "", base::R.version$version.string), 
[17:42:48.176]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.176]                               "release", "version")], collapse = " "), 
[17:42:48.176]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.176]                             info)
[17:42:48.176]                           info <- base::paste(info, collapse = "; ")
[17:42:48.176]                           if (!has_future) {
[17:42:48.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.176]                               info)
[17:42:48.176]                           }
[17:42:48.176]                           else {
[17:42:48.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.176]                               info, version)
[17:42:48.176]                           }
[17:42:48.176]                           base::stop(msg)
[17:42:48.176]                         }
[17:42:48.176]                       })
[17:42:48.176]                     }
[17:42:48.176]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.176]                     base::options(mc.cores = 1L)
[17:42:48.176]                   }
[17:42:48.176]                   options(future.plan = NULL)
[17:42:48.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.176]                 }
[17:42:48.176]                 ...future.workdir <- getwd()
[17:42:48.176]             }
[17:42:48.176]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.176]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.176]         }
[17:42:48.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.176]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.176]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.176]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.176]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.176]             base::names(...future.oldOptions))
[17:42:48.176]     }
[17:42:48.176]     if (FALSE) {
[17:42:48.176]     }
[17:42:48.176]     else {
[17:42:48.176]         if (TRUE) {
[17:42:48.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.176]                 open = "w")
[17:42:48.176]         }
[17:42:48.176]         else {
[17:42:48.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.176]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.176]         }
[17:42:48.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.176]             base::sink(type = "output", split = FALSE)
[17:42:48.176]             base::close(...future.stdout)
[17:42:48.176]         }, add = TRUE)
[17:42:48.176]     }
[17:42:48.176]     ...future.frame <- base::sys.nframe()
[17:42:48.176]     ...future.conditions <- base::list()
[17:42:48.176]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.176]     if (FALSE) {
[17:42:48.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.176]     }
[17:42:48.176]     ...future.result <- base::tryCatch({
[17:42:48.176]         base::withCallingHandlers({
[17:42:48.176]             ...future.value <- base::withVisible(base::local({
[17:42:48.176]                 ...future.makeSendCondition <- local({
[17:42:48.176]                   sendCondition <- NULL
[17:42:48.176]                   function(frame = 1L) {
[17:42:48.176]                     if (is.function(sendCondition)) 
[17:42:48.176]                       return(sendCondition)
[17:42:48.176]                     ns <- getNamespace("parallel")
[17:42:48.176]                     if (exists("sendData", mode = "function", 
[17:42:48.176]                       envir = ns)) {
[17:42:48.176]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.176]                         envir = ns)
[17:42:48.176]                       envir <- sys.frame(frame)
[17:42:48.176]                       master <- NULL
[17:42:48.176]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.176]                         !identical(envir, emptyenv())) {
[17:42:48.176]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.176]                           inherits = FALSE)) {
[17:42:48.176]                           master <- get("master", mode = "list", 
[17:42:48.176]                             envir = envir, inherits = FALSE)
[17:42:48.176]                           if (inherits(master, c("SOCKnode", 
[17:42:48.176]                             "SOCK0node"))) {
[17:42:48.176]                             sendCondition <<- function(cond) {
[17:42:48.176]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.176]                                 success = TRUE)
[17:42:48.176]                               parallel_sendData(master, data)
[17:42:48.176]                             }
[17:42:48.176]                             return(sendCondition)
[17:42:48.176]                           }
[17:42:48.176]                         }
[17:42:48.176]                         frame <- frame + 1L
[17:42:48.176]                         envir <- sys.frame(frame)
[17:42:48.176]                       }
[17:42:48.176]                     }
[17:42:48.176]                     sendCondition <<- function(cond) NULL
[17:42:48.176]                   }
[17:42:48.176]                 })
[17:42:48.176]                 withCallingHandlers({
[17:42:48.176]                   {
[17:42:48.176]                     b <- a
[17:42:48.176]                     a <- 2
[17:42:48.176]                     a * b
[17:42:48.176]                   }
[17:42:48.176]                 }, immediateCondition = function(cond) {
[17:42:48.176]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.176]                   sendCondition(cond)
[17:42:48.176]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.176]                   {
[17:42:48.176]                     inherits <- base::inherits
[17:42:48.176]                     invokeRestart <- base::invokeRestart
[17:42:48.176]                     is.null <- base::is.null
[17:42:48.176]                     muffled <- FALSE
[17:42:48.176]                     if (inherits(cond, "message")) {
[17:42:48.176]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.176]                       if (muffled) 
[17:42:48.176]                         invokeRestart("muffleMessage")
[17:42:48.176]                     }
[17:42:48.176]                     else if (inherits(cond, "warning")) {
[17:42:48.176]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.176]                       if (muffled) 
[17:42:48.176]                         invokeRestart("muffleWarning")
[17:42:48.176]                     }
[17:42:48.176]                     else if (inherits(cond, "condition")) {
[17:42:48.176]                       if (!is.null(pattern)) {
[17:42:48.176]                         computeRestarts <- base::computeRestarts
[17:42:48.176]                         grepl <- base::grepl
[17:42:48.176]                         restarts <- computeRestarts(cond)
[17:42:48.176]                         for (restart in restarts) {
[17:42:48.176]                           name <- restart$name
[17:42:48.176]                           if (is.null(name)) 
[17:42:48.176]                             next
[17:42:48.176]                           if (!grepl(pattern, name)) 
[17:42:48.176]                             next
[17:42:48.176]                           invokeRestart(restart)
[17:42:48.176]                           muffled <- TRUE
[17:42:48.176]                           break
[17:42:48.176]                         }
[17:42:48.176]                       }
[17:42:48.176]                     }
[17:42:48.176]                     invisible(muffled)
[17:42:48.176]                   }
[17:42:48.176]                   muffleCondition(cond)
[17:42:48.176]                 })
[17:42:48.176]             }))
[17:42:48.176]             future::FutureResult(value = ...future.value$value, 
[17:42:48.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.176]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.176]                     ...future.globalenv.names))
[17:42:48.176]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.176]         }, condition = base::local({
[17:42:48.176]             c <- base::c
[17:42:48.176]             inherits <- base::inherits
[17:42:48.176]             invokeRestart <- base::invokeRestart
[17:42:48.176]             length <- base::length
[17:42:48.176]             list <- base::list
[17:42:48.176]             seq.int <- base::seq.int
[17:42:48.176]             signalCondition <- base::signalCondition
[17:42:48.176]             sys.calls <- base::sys.calls
[17:42:48.176]             `[[` <- base::`[[`
[17:42:48.176]             `+` <- base::`+`
[17:42:48.176]             `<<-` <- base::`<<-`
[17:42:48.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.176]                   3L)]
[17:42:48.176]             }
[17:42:48.176]             function(cond) {
[17:42:48.176]                 is_error <- inherits(cond, "error")
[17:42:48.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.176]                   NULL)
[17:42:48.176]                 if (is_error) {
[17:42:48.176]                   sessionInformation <- function() {
[17:42:48.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.176]                       search = base::search(), system = base::Sys.info())
[17:42:48.176]                   }
[17:42:48.176]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.176]                     cond$call), session = sessionInformation(), 
[17:42:48.176]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.176]                   signalCondition(cond)
[17:42:48.176]                 }
[17:42:48.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.176]                 "immediateCondition"))) {
[17:42:48.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.176]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.176]                   if (TRUE && !signal) {
[17:42:48.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.176]                     {
[17:42:48.176]                       inherits <- base::inherits
[17:42:48.176]                       invokeRestart <- base::invokeRestart
[17:42:48.176]                       is.null <- base::is.null
[17:42:48.176]                       muffled <- FALSE
[17:42:48.176]                       if (inherits(cond, "message")) {
[17:42:48.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.176]                         if (muffled) 
[17:42:48.176]                           invokeRestart("muffleMessage")
[17:42:48.176]                       }
[17:42:48.176]                       else if (inherits(cond, "warning")) {
[17:42:48.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.176]                         if (muffled) 
[17:42:48.176]                           invokeRestart("muffleWarning")
[17:42:48.176]                       }
[17:42:48.176]                       else if (inherits(cond, "condition")) {
[17:42:48.176]                         if (!is.null(pattern)) {
[17:42:48.176]                           computeRestarts <- base::computeRestarts
[17:42:48.176]                           grepl <- base::grepl
[17:42:48.176]                           restarts <- computeRestarts(cond)
[17:42:48.176]                           for (restart in restarts) {
[17:42:48.176]                             name <- restart$name
[17:42:48.176]                             if (is.null(name)) 
[17:42:48.176]                               next
[17:42:48.176]                             if (!grepl(pattern, name)) 
[17:42:48.176]                               next
[17:42:48.176]                             invokeRestart(restart)
[17:42:48.176]                             muffled <- TRUE
[17:42:48.176]                             break
[17:42:48.176]                           }
[17:42:48.176]                         }
[17:42:48.176]                       }
[17:42:48.176]                       invisible(muffled)
[17:42:48.176]                     }
[17:42:48.176]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.176]                   }
[17:42:48.176]                 }
[17:42:48.176]                 else {
[17:42:48.176]                   if (TRUE) {
[17:42:48.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.176]                     {
[17:42:48.176]                       inherits <- base::inherits
[17:42:48.176]                       invokeRestart <- base::invokeRestart
[17:42:48.176]                       is.null <- base::is.null
[17:42:48.176]                       muffled <- FALSE
[17:42:48.176]                       if (inherits(cond, "message")) {
[17:42:48.176]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.176]                         if (muffled) 
[17:42:48.176]                           invokeRestart("muffleMessage")
[17:42:48.176]                       }
[17:42:48.176]                       else if (inherits(cond, "warning")) {
[17:42:48.176]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.176]                         if (muffled) 
[17:42:48.176]                           invokeRestart("muffleWarning")
[17:42:48.176]                       }
[17:42:48.176]                       else if (inherits(cond, "condition")) {
[17:42:48.176]                         if (!is.null(pattern)) {
[17:42:48.176]                           computeRestarts <- base::computeRestarts
[17:42:48.176]                           grepl <- base::grepl
[17:42:48.176]                           restarts <- computeRestarts(cond)
[17:42:48.176]                           for (restart in restarts) {
[17:42:48.176]                             name <- restart$name
[17:42:48.176]                             if (is.null(name)) 
[17:42:48.176]                               next
[17:42:48.176]                             if (!grepl(pattern, name)) 
[17:42:48.176]                               next
[17:42:48.176]                             invokeRestart(restart)
[17:42:48.176]                             muffled <- TRUE
[17:42:48.176]                             break
[17:42:48.176]                           }
[17:42:48.176]                         }
[17:42:48.176]                       }
[17:42:48.176]                       invisible(muffled)
[17:42:48.176]                     }
[17:42:48.176]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.176]                   }
[17:42:48.176]                 }
[17:42:48.176]             }
[17:42:48.176]         }))
[17:42:48.176]     }, error = function(ex) {
[17:42:48.176]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.176]                 ...future.rng), started = ...future.startTime, 
[17:42:48.176]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.176]             version = "1.8"), class = "FutureResult")
[17:42:48.176]     }, finally = {
[17:42:48.176]         if (!identical(...future.workdir, getwd())) 
[17:42:48.176]             setwd(...future.workdir)
[17:42:48.176]         {
[17:42:48.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.176]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.176]             }
[17:42:48.176]             base::options(...future.oldOptions)
[17:42:48.176]             if (.Platform$OS.type == "windows") {
[17:42:48.176]                 old_names <- names(...future.oldEnvVars)
[17:42:48.176]                 envs <- base::Sys.getenv()
[17:42:48.176]                 names <- names(envs)
[17:42:48.176]                 common <- intersect(names, old_names)
[17:42:48.176]                 added <- setdiff(names, old_names)
[17:42:48.176]                 removed <- setdiff(old_names, names)
[17:42:48.176]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.176]                   envs[common]]
[17:42:48.176]                 NAMES <- toupper(changed)
[17:42:48.176]                 args <- list()
[17:42:48.176]                 for (kk in seq_along(NAMES)) {
[17:42:48.176]                   name <- changed[[kk]]
[17:42:48.176]                   NAME <- NAMES[[kk]]
[17:42:48.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.176]                     next
[17:42:48.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.176]                 }
[17:42:48.176]                 NAMES <- toupper(added)
[17:42:48.176]                 for (kk in seq_along(NAMES)) {
[17:42:48.176]                   name <- added[[kk]]
[17:42:48.176]                   NAME <- NAMES[[kk]]
[17:42:48.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.176]                     next
[17:42:48.176]                   args[[name]] <- ""
[17:42:48.176]                 }
[17:42:48.176]                 NAMES <- toupper(removed)
[17:42:48.176]                 for (kk in seq_along(NAMES)) {
[17:42:48.176]                   name <- removed[[kk]]
[17:42:48.176]                   NAME <- NAMES[[kk]]
[17:42:48.176]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.176]                     next
[17:42:48.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.176]                 }
[17:42:48.176]                 if (length(args) > 0) 
[17:42:48.176]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.176]             }
[17:42:48.176]             else {
[17:42:48.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.176]             }
[17:42:48.176]             {
[17:42:48.176]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.176]                   0L) {
[17:42:48.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.176]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.176]                   base::options(opts)
[17:42:48.176]                 }
[17:42:48.176]                 {
[17:42:48.176]                   {
[17:42:48.176]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.176]                     NULL
[17:42:48.176]                   }
[17:42:48.176]                   options(future.plan = NULL)
[17:42:48.176]                   if (is.na(NA_character_)) 
[17:42:48.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.176]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.176]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.176]                     envir = parent.frame()) 
[17:42:48.176]                   {
[17:42:48.176]                     if (is.function(workers)) 
[17:42:48.176]                       workers <- workers()
[17:42:48.176]                     workers <- structure(as.integer(workers), 
[17:42:48.176]                       class = class(workers))
[17:42:48.176]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.176]                       workers >= 1)
[17:42:48.176]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.176]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.176]                     }
[17:42:48.176]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.176]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.176]                       envir = envir)
[17:42:48.176]                     if (!future$lazy) 
[17:42:48.176]                       future <- run(future)
[17:42:48.176]                     invisible(future)
[17:42:48.176]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.176]                 }
[17:42:48.176]             }
[17:42:48.176]         }
[17:42:48.176]     })
[17:42:48.176]     if (TRUE) {
[17:42:48.176]         base::sink(type = "output", split = FALSE)
[17:42:48.176]         if (TRUE) {
[17:42:48.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.176]         }
[17:42:48.176]         else {
[17:42:48.176]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.176]         }
[17:42:48.176]         base::close(...future.stdout)
[17:42:48.176]         ...future.stdout <- NULL
[17:42:48.176]     }
[17:42:48.176]     ...future.result$conditions <- ...future.conditions
[17:42:48.176]     ...future.result$finished <- base::Sys.time()
[17:42:48.176]     ...future.result
[17:42:48.176] }
[17:42:48.179] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:42:48.179] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:42:48.180] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:42:48.180] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:42:48.180] MultisessionFuture started
[17:42:48.180] - Launch lazy future ... done
[17:42:48.180] run() for ‘MultisessionFuture’ ... done
[17:42:48.181] result() for ClusterFuture ...
[17:42:48.181] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.181] - Validating connection of MultisessionFuture
[17:42:48.228] - received message: FutureResult
[17:42:48.229] - Received FutureResult
[17:42:48.229] - Erased future from FutureRegistry
[17:42:48.229] result() for ClusterFuture ...
[17:42:48.229] - result already collected: FutureResult
[17:42:48.229] result() for ClusterFuture ... done
[17:42:48.229] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.229] result() for ClusterFuture ... done
[17:42:48.229] result() for ClusterFuture ...
[17:42:48.229] - result already collected: FutureResult
[17:42:48.230] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.230] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.230] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.232] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:48.232] Searching for globals ... DONE
[17:42:48.232] Resolving globals: TRUE
[17:42:48.233] Resolving any globals that are futures ...
[17:42:48.233] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[17:42:48.233] Resolving any globals that are futures ... DONE
[17:42:48.233] Resolving futures part of globals (recursively) ...
[17:42:48.233] resolve() on list ...
[17:42:48.233]  recursive: 99
[17:42:48.234]  length: 1
[17:42:48.234]  elements: ‘a’
[17:42:48.234]  length: 0 (resolved future 1)
[17:42:48.234] resolve() on list ... DONE
[17:42:48.234] - globals: [1] ‘a’
[17:42:48.234] Resolving futures part of globals (recursively) ... DONE
[17:42:48.234] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:48.234] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[17:42:48.235] - globals: [1] ‘a’
[17:42:48.235] 
[17:42:48.235] getGlobalsAndPackages() ... DONE
[17:42:48.235] run() for ‘Future’ ...
[17:42:48.235] - state: ‘created’
[17:42:48.235] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.250] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.250]   - Field: ‘node’
[17:42:48.250]   - Field: ‘label’
[17:42:48.250]   - Field: ‘local’
[17:42:48.250]   - Field: ‘owner’
[17:42:48.250]   - Field: ‘envir’
[17:42:48.251]   - Field: ‘workers’
[17:42:48.251]   - Field: ‘packages’
[17:42:48.251]   - Field: ‘gc’
[17:42:48.251]   - Field: ‘conditions’
[17:42:48.251]   - Field: ‘persistent’
[17:42:48.251]   - Field: ‘expr’
[17:42:48.251]   - Field: ‘uuid’
[17:42:48.251]   - Field: ‘seed’
[17:42:48.251]   - Field: ‘version’
[17:42:48.251]   - Field: ‘result’
[17:42:48.252]   - Field: ‘asynchronous’
[17:42:48.252]   - Field: ‘calls’
[17:42:48.252]   - Field: ‘globals’
[17:42:48.252]   - Field: ‘stdout’
[17:42:48.252]   - Field: ‘earlySignal’
[17:42:48.252]   - Field: ‘lazy’
[17:42:48.252]   - Field: ‘state’
[17:42:48.252] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.252] - Launch lazy future ...
[17:42:48.253] Packages needed by the future expression (n = 0): <none>
[17:42:48.253] Packages needed by future strategies (n = 0): <none>
[17:42:48.253] {
[17:42:48.253]     {
[17:42:48.253]         {
[17:42:48.253]             ...future.startTime <- base::Sys.time()
[17:42:48.253]             {
[17:42:48.253]                 {
[17:42:48.253]                   {
[17:42:48.253]                     {
[17:42:48.253]                       base::local({
[17:42:48.253]                         has_future <- base::requireNamespace("future", 
[17:42:48.253]                           quietly = TRUE)
[17:42:48.253]                         if (has_future) {
[17:42:48.253]                           ns <- base::getNamespace("future")
[17:42:48.253]                           version <- ns[[".package"]][["version"]]
[17:42:48.253]                           if (is.null(version)) 
[17:42:48.253]                             version <- utils::packageVersion("future")
[17:42:48.253]                         }
[17:42:48.253]                         else {
[17:42:48.253]                           version <- NULL
[17:42:48.253]                         }
[17:42:48.253]                         if (!has_future || version < "1.8.0") {
[17:42:48.253]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.253]                             "", base::R.version$version.string), 
[17:42:48.253]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.253]                               "release", "version")], collapse = " "), 
[17:42:48.253]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.253]                             info)
[17:42:48.253]                           info <- base::paste(info, collapse = "; ")
[17:42:48.253]                           if (!has_future) {
[17:42:48.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.253]                               info)
[17:42:48.253]                           }
[17:42:48.253]                           else {
[17:42:48.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.253]                               info, version)
[17:42:48.253]                           }
[17:42:48.253]                           base::stop(msg)
[17:42:48.253]                         }
[17:42:48.253]                       })
[17:42:48.253]                     }
[17:42:48.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.253]                     base::options(mc.cores = 1L)
[17:42:48.253]                   }
[17:42:48.253]                   options(future.plan = NULL)
[17:42:48.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.253]                 }
[17:42:48.253]                 ...future.workdir <- getwd()
[17:42:48.253]             }
[17:42:48.253]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.253]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.253]         }
[17:42:48.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.253]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.253]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.253]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.253]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.253]             base::names(...future.oldOptions))
[17:42:48.253]     }
[17:42:48.253]     if (FALSE) {
[17:42:48.253]     }
[17:42:48.253]     else {
[17:42:48.253]         if (TRUE) {
[17:42:48.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.253]                 open = "w")
[17:42:48.253]         }
[17:42:48.253]         else {
[17:42:48.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.253]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.253]         }
[17:42:48.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.253]             base::sink(type = "output", split = FALSE)
[17:42:48.253]             base::close(...future.stdout)
[17:42:48.253]         }, add = TRUE)
[17:42:48.253]     }
[17:42:48.253]     ...future.frame <- base::sys.nframe()
[17:42:48.253]     ...future.conditions <- base::list()
[17:42:48.253]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.253]     if (FALSE) {
[17:42:48.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.253]     }
[17:42:48.253]     ...future.result <- base::tryCatch({
[17:42:48.253]         base::withCallingHandlers({
[17:42:48.253]             ...future.value <- base::withVisible(base::local({
[17:42:48.253]                 ...future.makeSendCondition <- local({
[17:42:48.253]                   sendCondition <- NULL
[17:42:48.253]                   function(frame = 1L) {
[17:42:48.253]                     if (is.function(sendCondition)) 
[17:42:48.253]                       return(sendCondition)
[17:42:48.253]                     ns <- getNamespace("parallel")
[17:42:48.253]                     if (exists("sendData", mode = "function", 
[17:42:48.253]                       envir = ns)) {
[17:42:48.253]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.253]                         envir = ns)
[17:42:48.253]                       envir <- sys.frame(frame)
[17:42:48.253]                       master <- NULL
[17:42:48.253]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.253]                         !identical(envir, emptyenv())) {
[17:42:48.253]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.253]                           inherits = FALSE)) {
[17:42:48.253]                           master <- get("master", mode = "list", 
[17:42:48.253]                             envir = envir, inherits = FALSE)
[17:42:48.253]                           if (inherits(master, c("SOCKnode", 
[17:42:48.253]                             "SOCK0node"))) {
[17:42:48.253]                             sendCondition <<- function(cond) {
[17:42:48.253]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.253]                                 success = TRUE)
[17:42:48.253]                               parallel_sendData(master, data)
[17:42:48.253]                             }
[17:42:48.253]                             return(sendCondition)
[17:42:48.253]                           }
[17:42:48.253]                         }
[17:42:48.253]                         frame <- frame + 1L
[17:42:48.253]                         envir <- sys.frame(frame)
[17:42:48.253]                       }
[17:42:48.253]                     }
[17:42:48.253]                     sendCondition <<- function(cond) NULL
[17:42:48.253]                   }
[17:42:48.253]                 })
[17:42:48.253]                 withCallingHandlers({
[17:42:48.253]                   {
[17:42:48.253]                     b <- a
[17:42:48.253]                     a <- 2
[17:42:48.253]                     a * b
[17:42:48.253]                   }
[17:42:48.253]                 }, immediateCondition = function(cond) {
[17:42:48.253]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.253]                   sendCondition(cond)
[17:42:48.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.253]                   {
[17:42:48.253]                     inherits <- base::inherits
[17:42:48.253]                     invokeRestart <- base::invokeRestart
[17:42:48.253]                     is.null <- base::is.null
[17:42:48.253]                     muffled <- FALSE
[17:42:48.253]                     if (inherits(cond, "message")) {
[17:42:48.253]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.253]                       if (muffled) 
[17:42:48.253]                         invokeRestart("muffleMessage")
[17:42:48.253]                     }
[17:42:48.253]                     else if (inherits(cond, "warning")) {
[17:42:48.253]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.253]                       if (muffled) 
[17:42:48.253]                         invokeRestart("muffleWarning")
[17:42:48.253]                     }
[17:42:48.253]                     else if (inherits(cond, "condition")) {
[17:42:48.253]                       if (!is.null(pattern)) {
[17:42:48.253]                         computeRestarts <- base::computeRestarts
[17:42:48.253]                         grepl <- base::grepl
[17:42:48.253]                         restarts <- computeRestarts(cond)
[17:42:48.253]                         for (restart in restarts) {
[17:42:48.253]                           name <- restart$name
[17:42:48.253]                           if (is.null(name)) 
[17:42:48.253]                             next
[17:42:48.253]                           if (!grepl(pattern, name)) 
[17:42:48.253]                             next
[17:42:48.253]                           invokeRestart(restart)
[17:42:48.253]                           muffled <- TRUE
[17:42:48.253]                           break
[17:42:48.253]                         }
[17:42:48.253]                       }
[17:42:48.253]                     }
[17:42:48.253]                     invisible(muffled)
[17:42:48.253]                   }
[17:42:48.253]                   muffleCondition(cond)
[17:42:48.253]                 })
[17:42:48.253]             }))
[17:42:48.253]             future::FutureResult(value = ...future.value$value, 
[17:42:48.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.253]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.253]                     ...future.globalenv.names))
[17:42:48.253]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.253]         }, condition = base::local({
[17:42:48.253]             c <- base::c
[17:42:48.253]             inherits <- base::inherits
[17:42:48.253]             invokeRestart <- base::invokeRestart
[17:42:48.253]             length <- base::length
[17:42:48.253]             list <- base::list
[17:42:48.253]             seq.int <- base::seq.int
[17:42:48.253]             signalCondition <- base::signalCondition
[17:42:48.253]             sys.calls <- base::sys.calls
[17:42:48.253]             `[[` <- base::`[[`
[17:42:48.253]             `+` <- base::`+`
[17:42:48.253]             `<<-` <- base::`<<-`
[17:42:48.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.253]                   3L)]
[17:42:48.253]             }
[17:42:48.253]             function(cond) {
[17:42:48.253]                 is_error <- inherits(cond, "error")
[17:42:48.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.253]                   NULL)
[17:42:48.253]                 if (is_error) {
[17:42:48.253]                   sessionInformation <- function() {
[17:42:48.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.253]                       search = base::search(), system = base::Sys.info())
[17:42:48.253]                   }
[17:42:48.253]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.253]                     cond$call), session = sessionInformation(), 
[17:42:48.253]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.253]                   signalCondition(cond)
[17:42:48.253]                 }
[17:42:48.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.253]                 "immediateCondition"))) {
[17:42:48.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.253]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.253]                   if (TRUE && !signal) {
[17:42:48.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.253]                     {
[17:42:48.253]                       inherits <- base::inherits
[17:42:48.253]                       invokeRestart <- base::invokeRestart
[17:42:48.253]                       is.null <- base::is.null
[17:42:48.253]                       muffled <- FALSE
[17:42:48.253]                       if (inherits(cond, "message")) {
[17:42:48.253]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.253]                         if (muffled) 
[17:42:48.253]                           invokeRestart("muffleMessage")
[17:42:48.253]                       }
[17:42:48.253]                       else if (inherits(cond, "warning")) {
[17:42:48.253]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.253]                         if (muffled) 
[17:42:48.253]                           invokeRestart("muffleWarning")
[17:42:48.253]                       }
[17:42:48.253]                       else if (inherits(cond, "condition")) {
[17:42:48.253]                         if (!is.null(pattern)) {
[17:42:48.253]                           computeRestarts <- base::computeRestarts
[17:42:48.253]                           grepl <- base::grepl
[17:42:48.253]                           restarts <- computeRestarts(cond)
[17:42:48.253]                           for (restart in restarts) {
[17:42:48.253]                             name <- restart$name
[17:42:48.253]                             if (is.null(name)) 
[17:42:48.253]                               next
[17:42:48.253]                             if (!grepl(pattern, name)) 
[17:42:48.253]                               next
[17:42:48.253]                             invokeRestart(restart)
[17:42:48.253]                             muffled <- TRUE
[17:42:48.253]                             break
[17:42:48.253]                           }
[17:42:48.253]                         }
[17:42:48.253]                       }
[17:42:48.253]                       invisible(muffled)
[17:42:48.253]                     }
[17:42:48.253]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.253]                   }
[17:42:48.253]                 }
[17:42:48.253]                 else {
[17:42:48.253]                   if (TRUE) {
[17:42:48.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.253]                     {
[17:42:48.253]                       inherits <- base::inherits
[17:42:48.253]                       invokeRestart <- base::invokeRestart
[17:42:48.253]                       is.null <- base::is.null
[17:42:48.253]                       muffled <- FALSE
[17:42:48.253]                       if (inherits(cond, "message")) {
[17:42:48.253]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.253]                         if (muffled) 
[17:42:48.253]                           invokeRestart("muffleMessage")
[17:42:48.253]                       }
[17:42:48.253]                       else if (inherits(cond, "warning")) {
[17:42:48.253]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.253]                         if (muffled) 
[17:42:48.253]                           invokeRestart("muffleWarning")
[17:42:48.253]                       }
[17:42:48.253]                       else if (inherits(cond, "condition")) {
[17:42:48.253]                         if (!is.null(pattern)) {
[17:42:48.253]                           computeRestarts <- base::computeRestarts
[17:42:48.253]                           grepl <- base::grepl
[17:42:48.253]                           restarts <- computeRestarts(cond)
[17:42:48.253]                           for (restart in restarts) {
[17:42:48.253]                             name <- restart$name
[17:42:48.253]                             if (is.null(name)) 
[17:42:48.253]                               next
[17:42:48.253]                             if (!grepl(pattern, name)) 
[17:42:48.253]                               next
[17:42:48.253]                             invokeRestart(restart)
[17:42:48.253]                             muffled <- TRUE
[17:42:48.253]                             break
[17:42:48.253]                           }
[17:42:48.253]                         }
[17:42:48.253]                       }
[17:42:48.253]                       invisible(muffled)
[17:42:48.253]                     }
[17:42:48.253]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.253]                   }
[17:42:48.253]                 }
[17:42:48.253]             }
[17:42:48.253]         }))
[17:42:48.253]     }, error = function(ex) {
[17:42:48.253]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.253]                 ...future.rng), started = ...future.startTime, 
[17:42:48.253]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.253]             version = "1.8"), class = "FutureResult")
[17:42:48.253]     }, finally = {
[17:42:48.253]         if (!identical(...future.workdir, getwd())) 
[17:42:48.253]             setwd(...future.workdir)
[17:42:48.253]         {
[17:42:48.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.253]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.253]             }
[17:42:48.253]             base::options(...future.oldOptions)
[17:42:48.253]             if (.Platform$OS.type == "windows") {
[17:42:48.253]                 old_names <- names(...future.oldEnvVars)
[17:42:48.253]                 envs <- base::Sys.getenv()
[17:42:48.253]                 names <- names(envs)
[17:42:48.253]                 common <- intersect(names, old_names)
[17:42:48.253]                 added <- setdiff(names, old_names)
[17:42:48.253]                 removed <- setdiff(old_names, names)
[17:42:48.253]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.253]                   envs[common]]
[17:42:48.253]                 NAMES <- toupper(changed)
[17:42:48.253]                 args <- list()
[17:42:48.253]                 for (kk in seq_along(NAMES)) {
[17:42:48.253]                   name <- changed[[kk]]
[17:42:48.253]                   NAME <- NAMES[[kk]]
[17:42:48.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.253]                     next
[17:42:48.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.253]                 }
[17:42:48.253]                 NAMES <- toupper(added)
[17:42:48.253]                 for (kk in seq_along(NAMES)) {
[17:42:48.253]                   name <- added[[kk]]
[17:42:48.253]                   NAME <- NAMES[[kk]]
[17:42:48.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.253]                     next
[17:42:48.253]                   args[[name]] <- ""
[17:42:48.253]                 }
[17:42:48.253]                 NAMES <- toupper(removed)
[17:42:48.253]                 for (kk in seq_along(NAMES)) {
[17:42:48.253]                   name <- removed[[kk]]
[17:42:48.253]                   NAME <- NAMES[[kk]]
[17:42:48.253]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.253]                     next
[17:42:48.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.253]                 }
[17:42:48.253]                 if (length(args) > 0) 
[17:42:48.253]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.253]             }
[17:42:48.253]             else {
[17:42:48.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.253]             }
[17:42:48.253]             {
[17:42:48.253]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.253]                   0L) {
[17:42:48.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.253]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.253]                   base::options(opts)
[17:42:48.253]                 }
[17:42:48.253]                 {
[17:42:48.253]                   {
[17:42:48.253]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.253]                     NULL
[17:42:48.253]                   }
[17:42:48.253]                   options(future.plan = NULL)
[17:42:48.253]                   if (is.na(NA_character_)) 
[17:42:48.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.253]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.253]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.253]                     envir = parent.frame()) 
[17:42:48.253]                   {
[17:42:48.253]                     if (is.function(workers)) 
[17:42:48.253]                       workers <- workers()
[17:42:48.253]                     workers <- structure(as.integer(workers), 
[17:42:48.253]                       class = class(workers))
[17:42:48.253]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.253]                       workers >= 1)
[17:42:48.253]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.253]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.253]                     }
[17:42:48.253]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.253]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.253]                       envir = envir)
[17:42:48.253]                     if (!future$lazy) 
[17:42:48.253]                       future <- run(future)
[17:42:48.253]                     invisible(future)
[17:42:48.253]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.253]                 }
[17:42:48.253]             }
[17:42:48.253]         }
[17:42:48.253]     })
[17:42:48.253]     if (TRUE) {
[17:42:48.253]         base::sink(type = "output", split = FALSE)
[17:42:48.253]         if (TRUE) {
[17:42:48.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.253]         }
[17:42:48.253]         else {
[17:42:48.253]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.253]         }
[17:42:48.253]         base::close(...future.stdout)
[17:42:48.253]         ...future.stdout <- NULL
[17:42:48.253]     }
[17:42:48.253]     ...future.result$conditions <- ...future.conditions
[17:42:48.253]     ...future.result$finished <- base::Sys.time()
[17:42:48.253]     ...future.result
[17:42:48.253] }
[17:42:48.256] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:42:48.256] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:42:48.256] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:42:48.257] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:42:48.257] MultisessionFuture started
[17:42:48.257] - Launch lazy future ... done
[17:42:48.257] run() for ‘MultisessionFuture’ ... done
[17:42:48.257] result() for ClusterFuture ...
[17:42:48.257] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.258] - Validating connection of MultisessionFuture
[17:42:48.305] - received message: FutureResult
[17:42:48.305] - Received FutureResult
[17:42:48.305] - Erased future from FutureRegistry
[17:42:48.305] result() for ClusterFuture ...
[17:42:48.305] - result already collected: FutureResult
[17:42:48.305] result() for ClusterFuture ... done
[17:42:48.305] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.306] result() for ClusterFuture ... done
[17:42:48.306] result() for ClusterFuture ...
[17:42:48.306] - result already collected: FutureResult
[17:42:48.306] result() for ClusterFuture ... done
y = 6
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.307] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.307] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.309] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.309] Searching for globals ... DONE
[17:42:48.309] Resolving globals: TRUE
[17:42:48.309] Resolving any globals that are futures ...
[17:42:48.309] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.309] Resolving any globals that are futures ... DONE
[17:42:48.310] Resolving futures part of globals (recursively) ...
[17:42:48.310] resolve() on list ...
[17:42:48.310]  recursive: 99
[17:42:48.310]  length: 2
[17:42:48.310]  elements: ‘a’, ‘ii’
[17:42:48.310]  length: 1 (resolved future 1)
[17:42:48.310]  length: 0 (resolved future 2)
[17:42:48.311] resolve() on list ... DONE
[17:42:48.311] - globals: [2] ‘a’, ‘ii’
[17:42:48.311] Resolving futures part of globals (recursively) ... DONE
[17:42:48.311] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:48.313] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:48.314] - globals: [2] ‘a’, ‘ii’
[17:42:48.314] 
[17:42:48.314] getGlobalsAndPackages() ... DONE
[17:42:48.314] run() for ‘Future’ ...
[17:42:48.314] - state: ‘created’
[17:42:48.314] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.329] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.329]   - Field: ‘node’
[17:42:48.329]   - Field: ‘label’
[17:42:48.329]   - Field: ‘local’
[17:42:48.329]   - Field: ‘owner’
[17:42:48.329]   - Field: ‘envir’
[17:42:48.329]   - Field: ‘workers’
[17:42:48.329]   - Field: ‘packages’
[17:42:48.330]   - Field: ‘gc’
[17:42:48.330]   - Field: ‘conditions’
[17:42:48.330]   - Field: ‘persistent’
[17:42:48.330]   - Field: ‘expr’
[17:42:48.330]   - Field: ‘uuid’
[17:42:48.330]   - Field: ‘seed’
[17:42:48.330]   - Field: ‘version’
[17:42:48.330]   - Field: ‘result’
[17:42:48.330]   - Field: ‘asynchronous’
[17:42:48.330]   - Field: ‘calls’
[17:42:48.330]   - Field: ‘globals’
[17:42:48.330]   - Field: ‘stdout’
[17:42:48.331]   - Field: ‘earlySignal’
[17:42:48.331]   - Field: ‘lazy’
[17:42:48.331]   - Field: ‘state’
[17:42:48.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.331] - Launch lazy future ...
[17:42:48.331] Packages needed by the future expression (n = 0): <none>
[17:42:48.331] Packages needed by future strategies (n = 0): <none>
[17:42:48.332] {
[17:42:48.332]     {
[17:42:48.332]         {
[17:42:48.332]             ...future.startTime <- base::Sys.time()
[17:42:48.332]             {
[17:42:48.332]                 {
[17:42:48.332]                   {
[17:42:48.332]                     {
[17:42:48.332]                       base::local({
[17:42:48.332]                         has_future <- base::requireNamespace("future", 
[17:42:48.332]                           quietly = TRUE)
[17:42:48.332]                         if (has_future) {
[17:42:48.332]                           ns <- base::getNamespace("future")
[17:42:48.332]                           version <- ns[[".package"]][["version"]]
[17:42:48.332]                           if (is.null(version)) 
[17:42:48.332]                             version <- utils::packageVersion("future")
[17:42:48.332]                         }
[17:42:48.332]                         else {
[17:42:48.332]                           version <- NULL
[17:42:48.332]                         }
[17:42:48.332]                         if (!has_future || version < "1.8.0") {
[17:42:48.332]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.332]                             "", base::R.version$version.string), 
[17:42:48.332]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.332]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.332]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.332]                               "release", "version")], collapse = " "), 
[17:42:48.332]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.332]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.332]                             info)
[17:42:48.332]                           info <- base::paste(info, collapse = "; ")
[17:42:48.332]                           if (!has_future) {
[17:42:48.332]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.332]                               info)
[17:42:48.332]                           }
[17:42:48.332]                           else {
[17:42:48.332]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.332]                               info, version)
[17:42:48.332]                           }
[17:42:48.332]                           base::stop(msg)
[17:42:48.332]                         }
[17:42:48.332]                       })
[17:42:48.332]                     }
[17:42:48.332]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.332]                     base::options(mc.cores = 1L)
[17:42:48.332]                   }
[17:42:48.332]                   options(future.plan = NULL)
[17:42:48.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.332]                 }
[17:42:48.332]                 ...future.workdir <- getwd()
[17:42:48.332]             }
[17:42:48.332]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.332]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.332]         }
[17:42:48.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.332]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.332]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.332]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.332]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.332]             base::names(...future.oldOptions))
[17:42:48.332]     }
[17:42:48.332]     if (FALSE) {
[17:42:48.332]     }
[17:42:48.332]     else {
[17:42:48.332]         if (TRUE) {
[17:42:48.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.332]                 open = "w")
[17:42:48.332]         }
[17:42:48.332]         else {
[17:42:48.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.332]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.332]         }
[17:42:48.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.332]             base::sink(type = "output", split = FALSE)
[17:42:48.332]             base::close(...future.stdout)
[17:42:48.332]         }, add = TRUE)
[17:42:48.332]     }
[17:42:48.332]     ...future.frame <- base::sys.nframe()
[17:42:48.332]     ...future.conditions <- base::list()
[17:42:48.332]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.332]     if (FALSE) {
[17:42:48.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.332]     }
[17:42:48.332]     ...future.result <- base::tryCatch({
[17:42:48.332]         base::withCallingHandlers({
[17:42:48.332]             ...future.value <- base::withVisible(base::local({
[17:42:48.332]                 ...future.makeSendCondition <- local({
[17:42:48.332]                   sendCondition <- NULL
[17:42:48.332]                   function(frame = 1L) {
[17:42:48.332]                     if (is.function(sendCondition)) 
[17:42:48.332]                       return(sendCondition)
[17:42:48.332]                     ns <- getNamespace("parallel")
[17:42:48.332]                     if (exists("sendData", mode = "function", 
[17:42:48.332]                       envir = ns)) {
[17:42:48.332]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.332]                         envir = ns)
[17:42:48.332]                       envir <- sys.frame(frame)
[17:42:48.332]                       master <- NULL
[17:42:48.332]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.332]                         !identical(envir, emptyenv())) {
[17:42:48.332]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.332]                           inherits = FALSE)) {
[17:42:48.332]                           master <- get("master", mode = "list", 
[17:42:48.332]                             envir = envir, inherits = FALSE)
[17:42:48.332]                           if (inherits(master, c("SOCKnode", 
[17:42:48.332]                             "SOCK0node"))) {
[17:42:48.332]                             sendCondition <<- function(cond) {
[17:42:48.332]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.332]                                 success = TRUE)
[17:42:48.332]                               parallel_sendData(master, data)
[17:42:48.332]                             }
[17:42:48.332]                             return(sendCondition)
[17:42:48.332]                           }
[17:42:48.332]                         }
[17:42:48.332]                         frame <- frame + 1L
[17:42:48.332]                         envir <- sys.frame(frame)
[17:42:48.332]                       }
[17:42:48.332]                     }
[17:42:48.332]                     sendCondition <<- function(cond) NULL
[17:42:48.332]                   }
[17:42:48.332]                 })
[17:42:48.332]                 withCallingHandlers({
[17:42:48.332]                   {
[17:42:48.332]                     b <- a * ii
[17:42:48.332]                     a <- 0
[17:42:48.332]                     b
[17:42:48.332]                   }
[17:42:48.332]                 }, immediateCondition = function(cond) {
[17:42:48.332]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.332]                   sendCondition(cond)
[17:42:48.332]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.332]                   {
[17:42:48.332]                     inherits <- base::inherits
[17:42:48.332]                     invokeRestart <- base::invokeRestart
[17:42:48.332]                     is.null <- base::is.null
[17:42:48.332]                     muffled <- FALSE
[17:42:48.332]                     if (inherits(cond, "message")) {
[17:42:48.332]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.332]                       if (muffled) 
[17:42:48.332]                         invokeRestart("muffleMessage")
[17:42:48.332]                     }
[17:42:48.332]                     else if (inherits(cond, "warning")) {
[17:42:48.332]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.332]                       if (muffled) 
[17:42:48.332]                         invokeRestart("muffleWarning")
[17:42:48.332]                     }
[17:42:48.332]                     else if (inherits(cond, "condition")) {
[17:42:48.332]                       if (!is.null(pattern)) {
[17:42:48.332]                         computeRestarts <- base::computeRestarts
[17:42:48.332]                         grepl <- base::grepl
[17:42:48.332]                         restarts <- computeRestarts(cond)
[17:42:48.332]                         for (restart in restarts) {
[17:42:48.332]                           name <- restart$name
[17:42:48.332]                           if (is.null(name)) 
[17:42:48.332]                             next
[17:42:48.332]                           if (!grepl(pattern, name)) 
[17:42:48.332]                             next
[17:42:48.332]                           invokeRestart(restart)
[17:42:48.332]                           muffled <- TRUE
[17:42:48.332]                           break
[17:42:48.332]                         }
[17:42:48.332]                       }
[17:42:48.332]                     }
[17:42:48.332]                     invisible(muffled)
[17:42:48.332]                   }
[17:42:48.332]                   muffleCondition(cond)
[17:42:48.332]                 })
[17:42:48.332]             }))
[17:42:48.332]             future::FutureResult(value = ...future.value$value, 
[17:42:48.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.332]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.332]                     ...future.globalenv.names))
[17:42:48.332]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.332]         }, condition = base::local({
[17:42:48.332]             c <- base::c
[17:42:48.332]             inherits <- base::inherits
[17:42:48.332]             invokeRestart <- base::invokeRestart
[17:42:48.332]             length <- base::length
[17:42:48.332]             list <- base::list
[17:42:48.332]             seq.int <- base::seq.int
[17:42:48.332]             signalCondition <- base::signalCondition
[17:42:48.332]             sys.calls <- base::sys.calls
[17:42:48.332]             `[[` <- base::`[[`
[17:42:48.332]             `+` <- base::`+`
[17:42:48.332]             `<<-` <- base::`<<-`
[17:42:48.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.332]                   3L)]
[17:42:48.332]             }
[17:42:48.332]             function(cond) {
[17:42:48.332]                 is_error <- inherits(cond, "error")
[17:42:48.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.332]                   NULL)
[17:42:48.332]                 if (is_error) {
[17:42:48.332]                   sessionInformation <- function() {
[17:42:48.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.332]                       search = base::search(), system = base::Sys.info())
[17:42:48.332]                   }
[17:42:48.332]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.332]                     cond$call), session = sessionInformation(), 
[17:42:48.332]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.332]                   signalCondition(cond)
[17:42:48.332]                 }
[17:42:48.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.332]                 "immediateCondition"))) {
[17:42:48.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.332]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.332]                   if (TRUE && !signal) {
[17:42:48.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.332]                     {
[17:42:48.332]                       inherits <- base::inherits
[17:42:48.332]                       invokeRestart <- base::invokeRestart
[17:42:48.332]                       is.null <- base::is.null
[17:42:48.332]                       muffled <- FALSE
[17:42:48.332]                       if (inherits(cond, "message")) {
[17:42:48.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.332]                         if (muffled) 
[17:42:48.332]                           invokeRestart("muffleMessage")
[17:42:48.332]                       }
[17:42:48.332]                       else if (inherits(cond, "warning")) {
[17:42:48.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.332]                         if (muffled) 
[17:42:48.332]                           invokeRestart("muffleWarning")
[17:42:48.332]                       }
[17:42:48.332]                       else if (inherits(cond, "condition")) {
[17:42:48.332]                         if (!is.null(pattern)) {
[17:42:48.332]                           computeRestarts <- base::computeRestarts
[17:42:48.332]                           grepl <- base::grepl
[17:42:48.332]                           restarts <- computeRestarts(cond)
[17:42:48.332]                           for (restart in restarts) {
[17:42:48.332]                             name <- restart$name
[17:42:48.332]                             if (is.null(name)) 
[17:42:48.332]                               next
[17:42:48.332]                             if (!grepl(pattern, name)) 
[17:42:48.332]                               next
[17:42:48.332]                             invokeRestart(restart)
[17:42:48.332]                             muffled <- TRUE
[17:42:48.332]                             break
[17:42:48.332]                           }
[17:42:48.332]                         }
[17:42:48.332]                       }
[17:42:48.332]                       invisible(muffled)
[17:42:48.332]                     }
[17:42:48.332]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.332]                   }
[17:42:48.332]                 }
[17:42:48.332]                 else {
[17:42:48.332]                   if (TRUE) {
[17:42:48.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.332]                     {
[17:42:48.332]                       inherits <- base::inherits
[17:42:48.332]                       invokeRestart <- base::invokeRestart
[17:42:48.332]                       is.null <- base::is.null
[17:42:48.332]                       muffled <- FALSE
[17:42:48.332]                       if (inherits(cond, "message")) {
[17:42:48.332]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.332]                         if (muffled) 
[17:42:48.332]                           invokeRestart("muffleMessage")
[17:42:48.332]                       }
[17:42:48.332]                       else if (inherits(cond, "warning")) {
[17:42:48.332]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.332]                         if (muffled) 
[17:42:48.332]                           invokeRestart("muffleWarning")
[17:42:48.332]                       }
[17:42:48.332]                       else if (inherits(cond, "condition")) {
[17:42:48.332]                         if (!is.null(pattern)) {
[17:42:48.332]                           computeRestarts <- base::computeRestarts
[17:42:48.332]                           grepl <- base::grepl
[17:42:48.332]                           restarts <- computeRestarts(cond)
[17:42:48.332]                           for (restart in restarts) {
[17:42:48.332]                             name <- restart$name
[17:42:48.332]                             if (is.null(name)) 
[17:42:48.332]                               next
[17:42:48.332]                             if (!grepl(pattern, name)) 
[17:42:48.332]                               next
[17:42:48.332]                             invokeRestart(restart)
[17:42:48.332]                             muffled <- TRUE
[17:42:48.332]                             break
[17:42:48.332]                           }
[17:42:48.332]                         }
[17:42:48.332]                       }
[17:42:48.332]                       invisible(muffled)
[17:42:48.332]                     }
[17:42:48.332]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.332]                   }
[17:42:48.332]                 }
[17:42:48.332]             }
[17:42:48.332]         }))
[17:42:48.332]     }, error = function(ex) {
[17:42:48.332]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.332]                 ...future.rng), started = ...future.startTime, 
[17:42:48.332]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.332]             version = "1.8"), class = "FutureResult")
[17:42:48.332]     }, finally = {
[17:42:48.332]         if (!identical(...future.workdir, getwd())) 
[17:42:48.332]             setwd(...future.workdir)
[17:42:48.332]         {
[17:42:48.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.332]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.332]             }
[17:42:48.332]             base::options(...future.oldOptions)
[17:42:48.332]             if (.Platform$OS.type == "windows") {
[17:42:48.332]                 old_names <- names(...future.oldEnvVars)
[17:42:48.332]                 envs <- base::Sys.getenv()
[17:42:48.332]                 names <- names(envs)
[17:42:48.332]                 common <- intersect(names, old_names)
[17:42:48.332]                 added <- setdiff(names, old_names)
[17:42:48.332]                 removed <- setdiff(old_names, names)
[17:42:48.332]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.332]                   envs[common]]
[17:42:48.332]                 NAMES <- toupper(changed)
[17:42:48.332]                 args <- list()
[17:42:48.332]                 for (kk in seq_along(NAMES)) {
[17:42:48.332]                   name <- changed[[kk]]
[17:42:48.332]                   NAME <- NAMES[[kk]]
[17:42:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.332]                     next
[17:42:48.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.332]                 }
[17:42:48.332]                 NAMES <- toupper(added)
[17:42:48.332]                 for (kk in seq_along(NAMES)) {
[17:42:48.332]                   name <- added[[kk]]
[17:42:48.332]                   NAME <- NAMES[[kk]]
[17:42:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.332]                     next
[17:42:48.332]                   args[[name]] <- ""
[17:42:48.332]                 }
[17:42:48.332]                 NAMES <- toupper(removed)
[17:42:48.332]                 for (kk in seq_along(NAMES)) {
[17:42:48.332]                   name <- removed[[kk]]
[17:42:48.332]                   NAME <- NAMES[[kk]]
[17:42:48.332]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.332]                     next
[17:42:48.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.332]                 }
[17:42:48.332]                 if (length(args) > 0) 
[17:42:48.332]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.332]             }
[17:42:48.332]             else {
[17:42:48.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.332]             }
[17:42:48.332]             {
[17:42:48.332]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.332]                   0L) {
[17:42:48.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.332]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.332]                   base::options(opts)
[17:42:48.332]                 }
[17:42:48.332]                 {
[17:42:48.332]                   {
[17:42:48.332]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.332]                     NULL
[17:42:48.332]                   }
[17:42:48.332]                   options(future.plan = NULL)
[17:42:48.332]                   if (is.na(NA_character_)) 
[17:42:48.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.332]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.332]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.332]                     envir = parent.frame()) 
[17:42:48.332]                   {
[17:42:48.332]                     if (is.function(workers)) 
[17:42:48.332]                       workers <- workers()
[17:42:48.332]                     workers <- structure(as.integer(workers), 
[17:42:48.332]                       class = class(workers))
[17:42:48.332]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.332]                       workers >= 1)
[17:42:48.332]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.332]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.332]                     }
[17:42:48.332]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.332]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.332]                       envir = envir)
[17:42:48.332]                     if (!future$lazy) 
[17:42:48.332]                       future <- run(future)
[17:42:48.332]                     invisible(future)
[17:42:48.332]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.332]                 }
[17:42:48.332]             }
[17:42:48.332]         }
[17:42:48.332]     })
[17:42:48.332]     if (TRUE) {
[17:42:48.332]         base::sink(type = "output", split = FALSE)
[17:42:48.332]         if (TRUE) {
[17:42:48.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.332]         }
[17:42:48.332]         else {
[17:42:48.332]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.332]         }
[17:42:48.332]         base::close(...future.stdout)
[17:42:48.332]         ...future.stdout <- NULL
[17:42:48.332]     }
[17:42:48.332]     ...future.result$conditions <- ...future.conditions
[17:42:48.332]     ...future.result$finished <- base::Sys.time()
[17:42:48.332]     ...future.result
[17:42:48.332] }
[17:42:48.335] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:42:48.335] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:42:48.335] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:42:48.335] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:42:48.336] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:42:48.336] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:42:48.336] MultisessionFuture started
[17:42:48.336] - Launch lazy future ... done
[17:42:48.336] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.337] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.337] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.339] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.339] Searching for globals ... DONE
[17:42:48.339] Resolving globals: TRUE
[17:42:48.339] Resolving any globals that are futures ...
[17:42:48.339] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.339] Resolving any globals that are futures ... DONE
[17:42:48.340] Resolving futures part of globals (recursively) ...
[17:42:48.340] resolve() on list ...
[17:42:48.340]  recursive: 99
[17:42:48.340]  length: 2
[17:42:48.340]  elements: ‘a’, ‘ii’
[17:42:48.340]  length: 1 (resolved future 1)
[17:42:48.341]  length: 0 (resolved future 2)
[17:42:48.341] resolve() on list ... DONE
[17:42:48.341] - globals: [2] ‘a’, ‘ii’
[17:42:48.341] Resolving futures part of globals (recursively) ... DONE
[17:42:48.341] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:48.341] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:48.341] - globals: [2] ‘a’, ‘ii’
[17:42:48.342] 
[17:42:48.342] getGlobalsAndPackages() ... DONE
[17:42:48.342] run() for ‘Future’ ...
[17:42:48.342] - state: ‘created’
[17:42:48.342] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.357] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.357]   - Field: ‘node’
[17:42:48.357]   - Field: ‘label’
[17:42:48.357]   - Field: ‘local’
[17:42:48.357]   - Field: ‘owner’
[17:42:48.357]   - Field: ‘envir’
[17:42:48.357]   - Field: ‘workers’
[17:42:48.357]   - Field: ‘packages’
[17:42:48.357]   - Field: ‘gc’
[17:42:48.358]   - Field: ‘conditions’
[17:42:48.358]   - Field: ‘persistent’
[17:42:48.358]   - Field: ‘expr’
[17:42:48.358]   - Field: ‘uuid’
[17:42:48.358]   - Field: ‘seed’
[17:42:48.358]   - Field: ‘version’
[17:42:48.358]   - Field: ‘result’
[17:42:48.358]   - Field: ‘asynchronous’
[17:42:48.358]   - Field: ‘calls’
[17:42:48.358]   - Field: ‘globals’
[17:42:48.358]   - Field: ‘stdout’
[17:42:48.359]   - Field: ‘earlySignal’
[17:42:48.359]   - Field: ‘lazy’
[17:42:48.359]   - Field: ‘state’
[17:42:48.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.359] - Launch lazy future ...
[17:42:48.359] Packages needed by the future expression (n = 0): <none>
[17:42:48.359] Packages needed by future strategies (n = 0): <none>
[17:42:48.360] {
[17:42:48.360]     {
[17:42:48.360]         {
[17:42:48.360]             ...future.startTime <- base::Sys.time()
[17:42:48.360]             {
[17:42:48.360]                 {
[17:42:48.360]                   {
[17:42:48.360]                     {
[17:42:48.360]                       base::local({
[17:42:48.360]                         has_future <- base::requireNamespace("future", 
[17:42:48.360]                           quietly = TRUE)
[17:42:48.360]                         if (has_future) {
[17:42:48.360]                           ns <- base::getNamespace("future")
[17:42:48.360]                           version <- ns[[".package"]][["version"]]
[17:42:48.360]                           if (is.null(version)) 
[17:42:48.360]                             version <- utils::packageVersion("future")
[17:42:48.360]                         }
[17:42:48.360]                         else {
[17:42:48.360]                           version <- NULL
[17:42:48.360]                         }
[17:42:48.360]                         if (!has_future || version < "1.8.0") {
[17:42:48.360]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.360]                             "", base::R.version$version.string), 
[17:42:48.360]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.360]                               "release", "version")], collapse = " "), 
[17:42:48.360]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.360]                             info)
[17:42:48.360]                           info <- base::paste(info, collapse = "; ")
[17:42:48.360]                           if (!has_future) {
[17:42:48.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.360]                               info)
[17:42:48.360]                           }
[17:42:48.360]                           else {
[17:42:48.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.360]                               info, version)
[17:42:48.360]                           }
[17:42:48.360]                           base::stop(msg)
[17:42:48.360]                         }
[17:42:48.360]                       })
[17:42:48.360]                     }
[17:42:48.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.360]                     base::options(mc.cores = 1L)
[17:42:48.360]                   }
[17:42:48.360]                   options(future.plan = NULL)
[17:42:48.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.360]                 }
[17:42:48.360]                 ...future.workdir <- getwd()
[17:42:48.360]             }
[17:42:48.360]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.360]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.360]         }
[17:42:48.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.360]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.360]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.360]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.360]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.360]             base::names(...future.oldOptions))
[17:42:48.360]     }
[17:42:48.360]     if (FALSE) {
[17:42:48.360]     }
[17:42:48.360]     else {
[17:42:48.360]         if (TRUE) {
[17:42:48.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.360]                 open = "w")
[17:42:48.360]         }
[17:42:48.360]         else {
[17:42:48.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.360]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.360]         }
[17:42:48.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.360]             base::sink(type = "output", split = FALSE)
[17:42:48.360]             base::close(...future.stdout)
[17:42:48.360]         }, add = TRUE)
[17:42:48.360]     }
[17:42:48.360]     ...future.frame <- base::sys.nframe()
[17:42:48.360]     ...future.conditions <- base::list()
[17:42:48.360]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.360]     if (FALSE) {
[17:42:48.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.360]     }
[17:42:48.360]     ...future.result <- base::tryCatch({
[17:42:48.360]         base::withCallingHandlers({
[17:42:48.360]             ...future.value <- base::withVisible(base::local({
[17:42:48.360]                 ...future.makeSendCondition <- local({
[17:42:48.360]                   sendCondition <- NULL
[17:42:48.360]                   function(frame = 1L) {
[17:42:48.360]                     if (is.function(sendCondition)) 
[17:42:48.360]                       return(sendCondition)
[17:42:48.360]                     ns <- getNamespace("parallel")
[17:42:48.360]                     if (exists("sendData", mode = "function", 
[17:42:48.360]                       envir = ns)) {
[17:42:48.360]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.360]                         envir = ns)
[17:42:48.360]                       envir <- sys.frame(frame)
[17:42:48.360]                       master <- NULL
[17:42:48.360]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.360]                         !identical(envir, emptyenv())) {
[17:42:48.360]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.360]                           inherits = FALSE)) {
[17:42:48.360]                           master <- get("master", mode = "list", 
[17:42:48.360]                             envir = envir, inherits = FALSE)
[17:42:48.360]                           if (inherits(master, c("SOCKnode", 
[17:42:48.360]                             "SOCK0node"))) {
[17:42:48.360]                             sendCondition <<- function(cond) {
[17:42:48.360]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.360]                                 success = TRUE)
[17:42:48.360]                               parallel_sendData(master, data)
[17:42:48.360]                             }
[17:42:48.360]                             return(sendCondition)
[17:42:48.360]                           }
[17:42:48.360]                         }
[17:42:48.360]                         frame <- frame + 1L
[17:42:48.360]                         envir <- sys.frame(frame)
[17:42:48.360]                       }
[17:42:48.360]                     }
[17:42:48.360]                     sendCondition <<- function(cond) NULL
[17:42:48.360]                   }
[17:42:48.360]                 })
[17:42:48.360]                 withCallingHandlers({
[17:42:48.360]                   {
[17:42:48.360]                     b <- a * ii
[17:42:48.360]                     a <- 0
[17:42:48.360]                     b
[17:42:48.360]                   }
[17:42:48.360]                 }, immediateCondition = function(cond) {
[17:42:48.360]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.360]                   sendCondition(cond)
[17:42:48.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.360]                   {
[17:42:48.360]                     inherits <- base::inherits
[17:42:48.360]                     invokeRestart <- base::invokeRestart
[17:42:48.360]                     is.null <- base::is.null
[17:42:48.360]                     muffled <- FALSE
[17:42:48.360]                     if (inherits(cond, "message")) {
[17:42:48.360]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.360]                       if (muffled) 
[17:42:48.360]                         invokeRestart("muffleMessage")
[17:42:48.360]                     }
[17:42:48.360]                     else if (inherits(cond, "warning")) {
[17:42:48.360]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.360]                       if (muffled) 
[17:42:48.360]                         invokeRestart("muffleWarning")
[17:42:48.360]                     }
[17:42:48.360]                     else if (inherits(cond, "condition")) {
[17:42:48.360]                       if (!is.null(pattern)) {
[17:42:48.360]                         computeRestarts <- base::computeRestarts
[17:42:48.360]                         grepl <- base::grepl
[17:42:48.360]                         restarts <- computeRestarts(cond)
[17:42:48.360]                         for (restart in restarts) {
[17:42:48.360]                           name <- restart$name
[17:42:48.360]                           if (is.null(name)) 
[17:42:48.360]                             next
[17:42:48.360]                           if (!grepl(pattern, name)) 
[17:42:48.360]                             next
[17:42:48.360]                           invokeRestart(restart)
[17:42:48.360]                           muffled <- TRUE
[17:42:48.360]                           break
[17:42:48.360]                         }
[17:42:48.360]                       }
[17:42:48.360]                     }
[17:42:48.360]                     invisible(muffled)
[17:42:48.360]                   }
[17:42:48.360]                   muffleCondition(cond)
[17:42:48.360]                 })
[17:42:48.360]             }))
[17:42:48.360]             future::FutureResult(value = ...future.value$value, 
[17:42:48.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.360]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.360]                     ...future.globalenv.names))
[17:42:48.360]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.360]         }, condition = base::local({
[17:42:48.360]             c <- base::c
[17:42:48.360]             inherits <- base::inherits
[17:42:48.360]             invokeRestart <- base::invokeRestart
[17:42:48.360]             length <- base::length
[17:42:48.360]             list <- base::list
[17:42:48.360]             seq.int <- base::seq.int
[17:42:48.360]             signalCondition <- base::signalCondition
[17:42:48.360]             sys.calls <- base::sys.calls
[17:42:48.360]             `[[` <- base::`[[`
[17:42:48.360]             `+` <- base::`+`
[17:42:48.360]             `<<-` <- base::`<<-`
[17:42:48.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.360]                   3L)]
[17:42:48.360]             }
[17:42:48.360]             function(cond) {
[17:42:48.360]                 is_error <- inherits(cond, "error")
[17:42:48.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.360]                   NULL)
[17:42:48.360]                 if (is_error) {
[17:42:48.360]                   sessionInformation <- function() {
[17:42:48.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.360]                       search = base::search(), system = base::Sys.info())
[17:42:48.360]                   }
[17:42:48.360]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.360]                     cond$call), session = sessionInformation(), 
[17:42:48.360]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.360]                   signalCondition(cond)
[17:42:48.360]                 }
[17:42:48.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.360]                 "immediateCondition"))) {
[17:42:48.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.360]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.360]                   if (TRUE && !signal) {
[17:42:48.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.360]                     {
[17:42:48.360]                       inherits <- base::inherits
[17:42:48.360]                       invokeRestart <- base::invokeRestart
[17:42:48.360]                       is.null <- base::is.null
[17:42:48.360]                       muffled <- FALSE
[17:42:48.360]                       if (inherits(cond, "message")) {
[17:42:48.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.360]                         if (muffled) 
[17:42:48.360]                           invokeRestart("muffleMessage")
[17:42:48.360]                       }
[17:42:48.360]                       else if (inherits(cond, "warning")) {
[17:42:48.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.360]                         if (muffled) 
[17:42:48.360]                           invokeRestart("muffleWarning")
[17:42:48.360]                       }
[17:42:48.360]                       else if (inherits(cond, "condition")) {
[17:42:48.360]                         if (!is.null(pattern)) {
[17:42:48.360]                           computeRestarts <- base::computeRestarts
[17:42:48.360]                           grepl <- base::grepl
[17:42:48.360]                           restarts <- computeRestarts(cond)
[17:42:48.360]                           for (restart in restarts) {
[17:42:48.360]                             name <- restart$name
[17:42:48.360]                             if (is.null(name)) 
[17:42:48.360]                               next
[17:42:48.360]                             if (!grepl(pattern, name)) 
[17:42:48.360]                               next
[17:42:48.360]                             invokeRestart(restart)
[17:42:48.360]                             muffled <- TRUE
[17:42:48.360]                             break
[17:42:48.360]                           }
[17:42:48.360]                         }
[17:42:48.360]                       }
[17:42:48.360]                       invisible(muffled)
[17:42:48.360]                     }
[17:42:48.360]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.360]                   }
[17:42:48.360]                 }
[17:42:48.360]                 else {
[17:42:48.360]                   if (TRUE) {
[17:42:48.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.360]                     {
[17:42:48.360]                       inherits <- base::inherits
[17:42:48.360]                       invokeRestart <- base::invokeRestart
[17:42:48.360]                       is.null <- base::is.null
[17:42:48.360]                       muffled <- FALSE
[17:42:48.360]                       if (inherits(cond, "message")) {
[17:42:48.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.360]                         if (muffled) 
[17:42:48.360]                           invokeRestart("muffleMessage")
[17:42:48.360]                       }
[17:42:48.360]                       else if (inherits(cond, "warning")) {
[17:42:48.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.360]                         if (muffled) 
[17:42:48.360]                           invokeRestart("muffleWarning")
[17:42:48.360]                       }
[17:42:48.360]                       else if (inherits(cond, "condition")) {
[17:42:48.360]                         if (!is.null(pattern)) {
[17:42:48.360]                           computeRestarts <- base::computeRestarts
[17:42:48.360]                           grepl <- base::grepl
[17:42:48.360]                           restarts <- computeRestarts(cond)
[17:42:48.360]                           for (restart in restarts) {
[17:42:48.360]                             name <- restart$name
[17:42:48.360]                             if (is.null(name)) 
[17:42:48.360]                               next
[17:42:48.360]                             if (!grepl(pattern, name)) 
[17:42:48.360]                               next
[17:42:48.360]                             invokeRestart(restart)
[17:42:48.360]                             muffled <- TRUE
[17:42:48.360]                             break
[17:42:48.360]                           }
[17:42:48.360]                         }
[17:42:48.360]                       }
[17:42:48.360]                       invisible(muffled)
[17:42:48.360]                     }
[17:42:48.360]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.360]                   }
[17:42:48.360]                 }
[17:42:48.360]             }
[17:42:48.360]         }))
[17:42:48.360]     }, error = function(ex) {
[17:42:48.360]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.360]                 ...future.rng), started = ...future.startTime, 
[17:42:48.360]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.360]             version = "1.8"), class = "FutureResult")
[17:42:48.360]     }, finally = {
[17:42:48.360]         if (!identical(...future.workdir, getwd())) 
[17:42:48.360]             setwd(...future.workdir)
[17:42:48.360]         {
[17:42:48.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.360]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.360]             }
[17:42:48.360]             base::options(...future.oldOptions)
[17:42:48.360]             if (.Platform$OS.type == "windows") {
[17:42:48.360]                 old_names <- names(...future.oldEnvVars)
[17:42:48.360]                 envs <- base::Sys.getenv()
[17:42:48.360]                 names <- names(envs)
[17:42:48.360]                 common <- intersect(names, old_names)
[17:42:48.360]                 added <- setdiff(names, old_names)
[17:42:48.360]                 removed <- setdiff(old_names, names)
[17:42:48.360]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.360]                   envs[common]]
[17:42:48.360]                 NAMES <- toupper(changed)
[17:42:48.360]                 args <- list()
[17:42:48.360]                 for (kk in seq_along(NAMES)) {
[17:42:48.360]                   name <- changed[[kk]]
[17:42:48.360]                   NAME <- NAMES[[kk]]
[17:42:48.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.360]                     next
[17:42:48.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.360]                 }
[17:42:48.360]                 NAMES <- toupper(added)
[17:42:48.360]                 for (kk in seq_along(NAMES)) {
[17:42:48.360]                   name <- added[[kk]]
[17:42:48.360]                   NAME <- NAMES[[kk]]
[17:42:48.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.360]                     next
[17:42:48.360]                   args[[name]] <- ""
[17:42:48.360]                 }
[17:42:48.360]                 NAMES <- toupper(removed)
[17:42:48.360]                 for (kk in seq_along(NAMES)) {
[17:42:48.360]                   name <- removed[[kk]]
[17:42:48.360]                   NAME <- NAMES[[kk]]
[17:42:48.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.360]                     next
[17:42:48.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.360]                 }
[17:42:48.360]                 if (length(args) > 0) 
[17:42:48.360]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.360]             }
[17:42:48.360]             else {
[17:42:48.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.360]             }
[17:42:48.360]             {
[17:42:48.360]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.360]                   0L) {
[17:42:48.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.360]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.360]                   base::options(opts)
[17:42:48.360]                 }
[17:42:48.360]                 {
[17:42:48.360]                   {
[17:42:48.360]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.360]                     NULL
[17:42:48.360]                   }
[17:42:48.360]                   options(future.plan = NULL)
[17:42:48.360]                   if (is.na(NA_character_)) 
[17:42:48.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.360]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.360]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.360]                     envir = parent.frame()) 
[17:42:48.360]                   {
[17:42:48.360]                     if (is.function(workers)) 
[17:42:48.360]                       workers <- workers()
[17:42:48.360]                     workers <- structure(as.integer(workers), 
[17:42:48.360]                       class = class(workers))
[17:42:48.360]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.360]                       workers >= 1)
[17:42:48.360]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.360]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.360]                     }
[17:42:48.360]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.360]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.360]                       envir = envir)
[17:42:48.360]                     if (!future$lazy) 
[17:42:48.360]                       future <- run(future)
[17:42:48.360]                     invisible(future)
[17:42:48.360]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.360]                 }
[17:42:48.360]             }
[17:42:48.360]         }
[17:42:48.360]     })
[17:42:48.360]     if (TRUE) {
[17:42:48.360]         base::sink(type = "output", split = FALSE)
[17:42:48.360]         if (TRUE) {
[17:42:48.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.360]         }
[17:42:48.360]         else {
[17:42:48.360]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.360]         }
[17:42:48.360]         base::close(...future.stdout)
[17:42:48.360]         ...future.stdout <- NULL
[17:42:48.360]     }
[17:42:48.360]     ...future.result$conditions <- ...future.conditions
[17:42:48.360]     ...future.result$finished <- base::Sys.time()
[17:42:48.360]     ...future.result
[17:42:48.360] }
[17:42:48.362] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:48.373] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.373] - Validating connection of MultisessionFuture
[17:42:48.373] - received message: FutureResult
[17:42:48.374] - Received FutureResult
[17:42:48.374] - Erased future from FutureRegistry
[17:42:48.374] result() for ClusterFuture ...
[17:42:48.374] - result already collected: FutureResult
[17:42:48.374] result() for ClusterFuture ... done
[17:42:48.374] signalConditions() ...
[17:42:48.374]  - include = ‘immediateCondition’
[17:42:48.374]  - exclude = 
[17:42:48.374]  - resignal = FALSE
[17:42:48.374]  - Number of conditions: 1
[17:42:48.375] signalConditions() ... done
[17:42:48.375] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.375] result() for ClusterFuture ...
[17:42:48.375] - result already collected: FutureResult
[17:42:48.375] result() for ClusterFuture ... done
[17:42:48.375] result() for ClusterFuture ...
[17:42:48.375] - result already collected: FutureResult
[17:42:48.375] result() for ClusterFuture ... done
[17:42:48.375] signalConditions() ...
[17:42:48.375]  - include = ‘immediateCondition’
[17:42:48.376]  - exclude = 
[17:42:48.376]  - resignal = FALSE
[17:42:48.376]  - Number of conditions: 1
[17:42:48.376] signalConditions() ... done
[17:42:48.377] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:42:48.377] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:42:48.377] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.377] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:48.378] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.378] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:42:48.378] MultisessionFuture started
[17:42:48.378] - Launch lazy future ... done
[17:42:48.379] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.379] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.379] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.381] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.381] Searching for globals ... DONE
[17:42:48.382] Resolving globals: TRUE
[17:42:48.382] Resolving any globals that are futures ...
[17:42:48.382] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.382] Resolving any globals that are futures ... DONE
[17:42:48.382] Resolving futures part of globals (recursively) ...
[17:42:48.382] resolve() on list ...
[17:42:48.383]  recursive: 99
[17:42:48.383]  length: 2
[17:42:48.383]  elements: ‘a’, ‘ii’
[17:42:48.383]  length: 1 (resolved future 1)
[17:42:48.383]  length: 0 (resolved future 2)
[17:42:48.383] resolve() on list ... DONE
[17:42:48.383] - globals: [2] ‘a’, ‘ii’
[17:42:48.383] Resolving futures part of globals (recursively) ... DONE
[17:42:48.384] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:48.384] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:48.384] - globals: [2] ‘a’, ‘ii’
[17:42:48.384] 
[17:42:48.384] getGlobalsAndPackages() ... DONE
[17:42:48.385] run() for ‘Future’ ...
[17:42:48.385] - state: ‘created’
[17:42:48.385] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.399] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.400]   - Field: ‘node’
[17:42:48.400]   - Field: ‘label’
[17:42:48.400]   - Field: ‘local’
[17:42:48.400]   - Field: ‘owner’
[17:42:48.400]   - Field: ‘envir’
[17:42:48.400]   - Field: ‘workers’
[17:42:48.400]   - Field: ‘packages’
[17:42:48.400]   - Field: ‘gc’
[17:42:48.400]   - Field: ‘conditions’
[17:42:48.400]   - Field: ‘persistent’
[17:42:48.401]   - Field: ‘expr’
[17:42:48.401]   - Field: ‘uuid’
[17:42:48.401]   - Field: ‘seed’
[17:42:48.401]   - Field: ‘version’
[17:42:48.401]   - Field: ‘result’
[17:42:48.401]   - Field: ‘asynchronous’
[17:42:48.401]   - Field: ‘calls’
[17:42:48.401]   - Field: ‘globals’
[17:42:48.401]   - Field: ‘stdout’
[17:42:48.401]   - Field: ‘earlySignal’
[17:42:48.401]   - Field: ‘lazy’
[17:42:48.402]   - Field: ‘state’
[17:42:48.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.402] - Launch lazy future ...
[17:42:48.402] Packages needed by the future expression (n = 0): <none>
[17:42:48.402] Packages needed by future strategies (n = 0): <none>
[17:42:48.403] {
[17:42:48.403]     {
[17:42:48.403]         {
[17:42:48.403]             ...future.startTime <- base::Sys.time()
[17:42:48.403]             {
[17:42:48.403]                 {
[17:42:48.403]                   {
[17:42:48.403]                     {
[17:42:48.403]                       base::local({
[17:42:48.403]                         has_future <- base::requireNamespace("future", 
[17:42:48.403]                           quietly = TRUE)
[17:42:48.403]                         if (has_future) {
[17:42:48.403]                           ns <- base::getNamespace("future")
[17:42:48.403]                           version <- ns[[".package"]][["version"]]
[17:42:48.403]                           if (is.null(version)) 
[17:42:48.403]                             version <- utils::packageVersion("future")
[17:42:48.403]                         }
[17:42:48.403]                         else {
[17:42:48.403]                           version <- NULL
[17:42:48.403]                         }
[17:42:48.403]                         if (!has_future || version < "1.8.0") {
[17:42:48.403]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.403]                             "", base::R.version$version.string), 
[17:42:48.403]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.403]                               "release", "version")], collapse = " "), 
[17:42:48.403]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.403]                             info)
[17:42:48.403]                           info <- base::paste(info, collapse = "; ")
[17:42:48.403]                           if (!has_future) {
[17:42:48.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.403]                               info)
[17:42:48.403]                           }
[17:42:48.403]                           else {
[17:42:48.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.403]                               info, version)
[17:42:48.403]                           }
[17:42:48.403]                           base::stop(msg)
[17:42:48.403]                         }
[17:42:48.403]                       })
[17:42:48.403]                     }
[17:42:48.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.403]                     base::options(mc.cores = 1L)
[17:42:48.403]                   }
[17:42:48.403]                   options(future.plan = NULL)
[17:42:48.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.403]                 }
[17:42:48.403]                 ...future.workdir <- getwd()
[17:42:48.403]             }
[17:42:48.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.403]         }
[17:42:48.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.403]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.403]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.403]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.403]             base::names(...future.oldOptions))
[17:42:48.403]     }
[17:42:48.403]     if (FALSE) {
[17:42:48.403]     }
[17:42:48.403]     else {
[17:42:48.403]         if (TRUE) {
[17:42:48.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.403]                 open = "w")
[17:42:48.403]         }
[17:42:48.403]         else {
[17:42:48.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.403]         }
[17:42:48.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.403]             base::sink(type = "output", split = FALSE)
[17:42:48.403]             base::close(...future.stdout)
[17:42:48.403]         }, add = TRUE)
[17:42:48.403]     }
[17:42:48.403]     ...future.frame <- base::sys.nframe()
[17:42:48.403]     ...future.conditions <- base::list()
[17:42:48.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.403]     if (FALSE) {
[17:42:48.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.403]     }
[17:42:48.403]     ...future.result <- base::tryCatch({
[17:42:48.403]         base::withCallingHandlers({
[17:42:48.403]             ...future.value <- base::withVisible(base::local({
[17:42:48.403]                 ...future.makeSendCondition <- local({
[17:42:48.403]                   sendCondition <- NULL
[17:42:48.403]                   function(frame = 1L) {
[17:42:48.403]                     if (is.function(sendCondition)) 
[17:42:48.403]                       return(sendCondition)
[17:42:48.403]                     ns <- getNamespace("parallel")
[17:42:48.403]                     if (exists("sendData", mode = "function", 
[17:42:48.403]                       envir = ns)) {
[17:42:48.403]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.403]                         envir = ns)
[17:42:48.403]                       envir <- sys.frame(frame)
[17:42:48.403]                       master <- NULL
[17:42:48.403]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.403]                         !identical(envir, emptyenv())) {
[17:42:48.403]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.403]                           inherits = FALSE)) {
[17:42:48.403]                           master <- get("master", mode = "list", 
[17:42:48.403]                             envir = envir, inherits = FALSE)
[17:42:48.403]                           if (inherits(master, c("SOCKnode", 
[17:42:48.403]                             "SOCK0node"))) {
[17:42:48.403]                             sendCondition <<- function(cond) {
[17:42:48.403]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.403]                                 success = TRUE)
[17:42:48.403]                               parallel_sendData(master, data)
[17:42:48.403]                             }
[17:42:48.403]                             return(sendCondition)
[17:42:48.403]                           }
[17:42:48.403]                         }
[17:42:48.403]                         frame <- frame + 1L
[17:42:48.403]                         envir <- sys.frame(frame)
[17:42:48.403]                       }
[17:42:48.403]                     }
[17:42:48.403]                     sendCondition <<- function(cond) NULL
[17:42:48.403]                   }
[17:42:48.403]                 })
[17:42:48.403]                 withCallingHandlers({
[17:42:48.403]                   {
[17:42:48.403]                     b <- a * ii
[17:42:48.403]                     a <- 0
[17:42:48.403]                     b
[17:42:48.403]                   }
[17:42:48.403]                 }, immediateCondition = function(cond) {
[17:42:48.403]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.403]                   sendCondition(cond)
[17:42:48.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.403]                   {
[17:42:48.403]                     inherits <- base::inherits
[17:42:48.403]                     invokeRestart <- base::invokeRestart
[17:42:48.403]                     is.null <- base::is.null
[17:42:48.403]                     muffled <- FALSE
[17:42:48.403]                     if (inherits(cond, "message")) {
[17:42:48.403]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.403]                       if (muffled) 
[17:42:48.403]                         invokeRestart("muffleMessage")
[17:42:48.403]                     }
[17:42:48.403]                     else if (inherits(cond, "warning")) {
[17:42:48.403]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.403]                       if (muffled) 
[17:42:48.403]                         invokeRestart("muffleWarning")
[17:42:48.403]                     }
[17:42:48.403]                     else if (inherits(cond, "condition")) {
[17:42:48.403]                       if (!is.null(pattern)) {
[17:42:48.403]                         computeRestarts <- base::computeRestarts
[17:42:48.403]                         grepl <- base::grepl
[17:42:48.403]                         restarts <- computeRestarts(cond)
[17:42:48.403]                         for (restart in restarts) {
[17:42:48.403]                           name <- restart$name
[17:42:48.403]                           if (is.null(name)) 
[17:42:48.403]                             next
[17:42:48.403]                           if (!grepl(pattern, name)) 
[17:42:48.403]                             next
[17:42:48.403]                           invokeRestart(restart)
[17:42:48.403]                           muffled <- TRUE
[17:42:48.403]                           break
[17:42:48.403]                         }
[17:42:48.403]                       }
[17:42:48.403]                     }
[17:42:48.403]                     invisible(muffled)
[17:42:48.403]                   }
[17:42:48.403]                   muffleCondition(cond)
[17:42:48.403]                 })
[17:42:48.403]             }))
[17:42:48.403]             future::FutureResult(value = ...future.value$value, 
[17:42:48.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.403]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.403]                     ...future.globalenv.names))
[17:42:48.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.403]         }, condition = base::local({
[17:42:48.403]             c <- base::c
[17:42:48.403]             inherits <- base::inherits
[17:42:48.403]             invokeRestart <- base::invokeRestart
[17:42:48.403]             length <- base::length
[17:42:48.403]             list <- base::list
[17:42:48.403]             seq.int <- base::seq.int
[17:42:48.403]             signalCondition <- base::signalCondition
[17:42:48.403]             sys.calls <- base::sys.calls
[17:42:48.403]             `[[` <- base::`[[`
[17:42:48.403]             `+` <- base::`+`
[17:42:48.403]             `<<-` <- base::`<<-`
[17:42:48.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.403]                   3L)]
[17:42:48.403]             }
[17:42:48.403]             function(cond) {
[17:42:48.403]                 is_error <- inherits(cond, "error")
[17:42:48.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.403]                   NULL)
[17:42:48.403]                 if (is_error) {
[17:42:48.403]                   sessionInformation <- function() {
[17:42:48.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.403]                       search = base::search(), system = base::Sys.info())
[17:42:48.403]                   }
[17:42:48.403]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.403]                     cond$call), session = sessionInformation(), 
[17:42:48.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.403]                   signalCondition(cond)
[17:42:48.403]                 }
[17:42:48.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.403]                 "immediateCondition"))) {
[17:42:48.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.403]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.403]                   if (TRUE && !signal) {
[17:42:48.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.403]                     {
[17:42:48.403]                       inherits <- base::inherits
[17:42:48.403]                       invokeRestart <- base::invokeRestart
[17:42:48.403]                       is.null <- base::is.null
[17:42:48.403]                       muffled <- FALSE
[17:42:48.403]                       if (inherits(cond, "message")) {
[17:42:48.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.403]                         if (muffled) 
[17:42:48.403]                           invokeRestart("muffleMessage")
[17:42:48.403]                       }
[17:42:48.403]                       else if (inherits(cond, "warning")) {
[17:42:48.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.403]                         if (muffled) 
[17:42:48.403]                           invokeRestart("muffleWarning")
[17:42:48.403]                       }
[17:42:48.403]                       else if (inherits(cond, "condition")) {
[17:42:48.403]                         if (!is.null(pattern)) {
[17:42:48.403]                           computeRestarts <- base::computeRestarts
[17:42:48.403]                           grepl <- base::grepl
[17:42:48.403]                           restarts <- computeRestarts(cond)
[17:42:48.403]                           for (restart in restarts) {
[17:42:48.403]                             name <- restart$name
[17:42:48.403]                             if (is.null(name)) 
[17:42:48.403]                               next
[17:42:48.403]                             if (!grepl(pattern, name)) 
[17:42:48.403]                               next
[17:42:48.403]                             invokeRestart(restart)
[17:42:48.403]                             muffled <- TRUE
[17:42:48.403]                             break
[17:42:48.403]                           }
[17:42:48.403]                         }
[17:42:48.403]                       }
[17:42:48.403]                       invisible(muffled)
[17:42:48.403]                     }
[17:42:48.403]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.403]                   }
[17:42:48.403]                 }
[17:42:48.403]                 else {
[17:42:48.403]                   if (TRUE) {
[17:42:48.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.403]                     {
[17:42:48.403]                       inherits <- base::inherits
[17:42:48.403]                       invokeRestart <- base::invokeRestart
[17:42:48.403]                       is.null <- base::is.null
[17:42:48.403]                       muffled <- FALSE
[17:42:48.403]                       if (inherits(cond, "message")) {
[17:42:48.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.403]                         if (muffled) 
[17:42:48.403]                           invokeRestart("muffleMessage")
[17:42:48.403]                       }
[17:42:48.403]                       else if (inherits(cond, "warning")) {
[17:42:48.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.403]                         if (muffled) 
[17:42:48.403]                           invokeRestart("muffleWarning")
[17:42:48.403]                       }
[17:42:48.403]                       else if (inherits(cond, "condition")) {
[17:42:48.403]                         if (!is.null(pattern)) {
[17:42:48.403]                           computeRestarts <- base::computeRestarts
[17:42:48.403]                           grepl <- base::grepl
[17:42:48.403]                           restarts <- computeRestarts(cond)
[17:42:48.403]                           for (restart in restarts) {
[17:42:48.403]                             name <- restart$name
[17:42:48.403]                             if (is.null(name)) 
[17:42:48.403]                               next
[17:42:48.403]                             if (!grepl(pattern, name)) 
[17:42:48.403]                               next
[17:42:48.403]                             invokeRestart(restart)
[17:42:48.403]                             muffled <- TRUE
[17:42:48.403]                             break
[17:42:48.403]                           }
[17:42:48.403]                         }
[17:42:48.403]                       }
[17:42:48.403]                       invisible(muffled)
[17:42:48.403]                     }
[17:42:48.403]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.403]                   }
[17:42:48.403]                 }
[17:42:48.403]             }
[17:42:48.403]         }))
[17:42:48.403]     }, error = function(ex) {
[17:42:48.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.403]                 ...future.rng), started = ...future.startTime, 
[17:42:48.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.403]             version = "1.8"), class = "FutureResult")
[17:42:48.403]     }, finally = {
[17:42:48.403]         if (!identical(...future.workdir, getwd())) 
[17:42:48.403]             setwd(...future.workdir)
[17:42:48.403]         {
[17:42:48.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.403]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.403]             }
[17:42:48.403]             base::options(...future.oldOptions)
[17:42:48.403]             if (.Platform$OS.type == "windows") {
[17:42:48.403]                 old_names <- names(...future.oldEnvVars)
[17:42:48.403]                 envs <- base::Sys.getenv()
[17:42:48.403]                 names <- names(envs)
[17:42:48.403]                 common <- intersect(names, old_names)
[17:42:48.403]                 added <- setdiff(names, old_names)
[17:42:48.403]                 removed <- setdiff(old_names, names)
[17:42:48.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.403]                   envs[common]]
[17:42:48.403]                 NAMES <- toupper(changed)
[17:42:48.403]                 args <- list()
[17:42:48.403]                 for (kk in seq_along(NAMES)) {
[17:42:48.403]                   name <- changed[[kk]]
[17:42:48.403]                   NAME <- NAMES[[kk]]
[17:42:48.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.403]                     next
[17:42:48.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.403]                 }
[17:42:48.403]                 NAMES <- toupper(added)
[17:42:48.403]                 for (kk in seq_along(NAMES)) {
[17:42:48.403]                   name <- added[[kk]]
[17:42:48.403]                   NAME <- NAMES[[kk]]
[17:42:48.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.403]                     next
[17:42:48.403]                   args[[name]] <- ""
[17:42:48.403]                 }
[17:42:48.403]                 NAMES <- toupper(removed)
[17:42:48.403]                 for (kk in seq_along(NAMES)) {
[17:42:48.403]                   name <- removed[[kk]]
[17:42:48.403]                   NAME <- NAMES[[kk]]
[17:42:48.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.403]                     next
[17:42:48.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.403]                 }
[17:42:48.403]                 if (length(args) > 0) 
[17:42:48.403]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.403]             }
[17:42:48.403]             else {
[17:42:48.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.403]             }
[17:42:48.403]             {
[17:42:48.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.403]                   0L) {
[17:42:48.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.403]                   base::options(opts)
[17:42:48.403]                 }
[17:42:48.403]                 {
[17:42:48.403]                   {
[17:42:48.403]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.403]                     NULL
[17:42:48.403]                   }
[17:42:48.403]                   options(future.plan = NULL)
[17:42:48.403]                   if (is.na(NA_character_)) 
[17:42:48.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.403]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.403]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.403]                     envir = parent.frame()) 
[17:42:48.403]                   {
[17:42:48.403]                     if (is.function(workers)) 
[17:42:48.403]                       workers <- workers()
[17:42:48.403]                     workers <- structure(as.integer(workers), 
[17:42:48.403]                       class = class(workers))
[17:42:48.403]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.403]                       workers >= 1)
[17:42:48.403]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.403]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.403]                     }
[17:42:48.403]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.403]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.403]                       envir = envir)
[17:42:48.403]                     if (!future$lazy) 
[17:42:48.403]                       future <- run(future)
[17:42:48.403]                     invisible(future)
[17:42:48.403]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.403]                 }
[17:42:48.403]             }
[17:42:48.403]         }
[17:42:48.403]     })
[17:42:48.403]     if (TRUE) {
[17:42:48.403]         base::sink(type = "output", split = FALSE)
[17:42:48.403]         if (TRUE) {
[17:42:48.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.403]         }
[17:42:48.403]         else {
[17:42:48.403]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.403]         }
[17:42:48.403]         base::close(...future.stdout)
[17:42:48.403]         ...future.stdout <- NULL
[17:42:48.403]     }
[17:42:48.403]     ...future.result$conditions <- ...future.conditions
[17:42:48.403]     ...future.result$finished <- base::Sys.time()
[17:42:48.403]     ...future.result
[17:42:48.403] }
[17:42:48.405] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:48.416] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.416] - Validating connection of MultisessionFuture
[17:42:48.416] - received message: FutureResult
[17:42:48.416] - Received FutureResult
[17:42:48.416] - Erased future from FutureRegistry
[17:42:48.416] result() for ClusterFuture ...
[17:42:48.416] - result already collected: FutureResult
[17:42:48.416] result() for ClusterFuture ... done
[17:42:48.416] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.417] result() for ClusterFuture ...
[17:42:48.417] - result already collected: FutureResult
[17:42:48.417] result() for ClusterFuture ... done
[17:42:48.417] result() for ClusterFuture ...
[17:42:48.417] - result already collected: FutureResult
[17:42:48.417] result() for ClusterFuture ... done
[17:42:48.418] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[17:42:48.418] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[17:42:48.418] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[17:42:48.418] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[17:42:48.419] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[17:42:48.419] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[17:42:48.419] MultisessionFuture started
[17:42:48.419] - Launch lazy future ... done
[17:42:48.420] run() for ‘MultisessionFuture’ ... done
[17:42:48.420] result() for ClusterFuture ...
[17:42:48.420] - result already collected: FutureResult
[17:42:48.420] result() for ClusterFuture ... done
[17:42:48.420] result() for ClusterFuture ...
[17:42:48.421] - result already collected: FutureResult
[17:42:48.421] result() for ClusterFuture ... done
[17:42:48.421] result() for ClusterFuture ...
[17:42:48.421] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.421] - Validating connection of MultisessionFuture
[17:42:48.424] - received message: FutureResult
[17:42:48.425] - Received FutureResult
[17:42:48.425] - Erased future from FutureRegistry
[17:42:48.425] result() for ClusterFuture ...
[17:42:48.425] - result already collected: FutureResult
[17:42:48.425] result() for ClusterFuture ... done
[17:42:48.425] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.425] result() for ClusterFuture ... done
[17:42:48.425] result() for ClusterFuture ...
[17:42:48.425] - result already collected: FutureResult
[17:42:48.425] result() for ClusterFuture ... done
[17:42:48.426] result() for ClusterFuture ...
[17:42:48.426] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.426] - Validating connection of MultisessionFuture
[17:42:48.468] - received message: FutureResult
[17:42:48.468] - Received FutureResult
[17:42:48.468] - Erased future from FutureRegistry
[17:42:48.468] result() for ClusterFuture ...
[17:42:48.468] - result already collected: FutureResult
[17:42:48.468] result() for ClusterFuture ... done
[17:42:48.469] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.469] result() for ClusterFuture ... done
[17:42:48.469] result() for ClusterFuture ...
[17:42:48.469] - result already collected: FutureResult
[17:42:48.469] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.470] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.470] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.472] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.472] Searching for globals ... DONE
[17:42:48.472] Resolving globals: TRUE
[17:42:48.472] Resolving any globals that are futures ...
[17:42:48.472] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.472] Resolving any globals that are futures ... DONE
[17:42:48.473] Resolving futures part of globals (recursively) ...
[17:42:48.473] resolve() on list ...
[17:42:48.473]  recursive: 99
[17:42:48.473]  length: 2
[17:42:48.473]  elements: ‘a’, ‘ii’
[17:42:48.473]  length: 1 (resolved future 1)
[17:42:48.473]  length: 0 (resolved future 2)
[17:42:48.474] resolve() on list ... DONE
[17:42:48.474] - globals: [2] ‘a’, ‘ii’
[17:42:48.474] Resolving futures part of globals (recursively) ... DONE
[17:42:48.474] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:48.474] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:48.474] - globals: [2] ‘a’, ‘ii’
[17:42:48.475] 
[17:42:48.475] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.475] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.475] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.477] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.477] Searching for globals ... DONE
[17:42:48.477] Resolving globals: TRUE
[17:42:48.478] Resolving any globals that are futures ...
[17:42:48.478] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.478] Resolving any globals that are futures ... DONE
[17:42:48.478] Resolving futures part of globals (recursively) ...
[17:42:48.478] resolve() on list ...
[17:42:48.478]  recursive: 99
[17:42:48.478]  length: 2
[17:42:48.479]  elements: ‘a’, ‘ii’
[17:42:48.479]  length: 1 (resolved future 1)
[17:42:48.479]  length: 0 (resolved future 2)
[17:42:48.479] resolve() on list ... DONE
[17:42:48.479] - globals: [2] ‘a’, ‘ii’
[17:42:48.479] Resolving futures part of globals (recursively) ... DONE
[17:42:48.479] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:48.480] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:48.480] - globals: [2] ‘a’, ‘ii’
[17:42:48.480] 
[17:42:48.480] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.481] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.481] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.482] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.483] Searching for globals ... DONE
[17:42:48.483] Resolving globals: TRUE
[17:42:48.483] Resolving any globals that are futures ...
[17:42:48.483] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[17:42:48.483] Resolving any globals that are futures ... DONE
[17:42:48.483] Resolving futures part of globals (recursively) ...
[17:42:48.484] resolve() on list ...
[17:42:48.484]  recursive: 99
[17:42:48.484]  length: 2
[17:42:48.484]  elements: ‘a’, ‘ii’
[17:42:48.484]  length: 1 (resolved future 1)
[17:42:48.484]  length: 0 (resolved future 2)
[17:42:48.484] resolve() on list ... DONE
[17:42:48.484] - globals: [2] ‘a’, ‘ii’
[17:42:48.484] Resolving futures part of globals (recursively) ... DONE
[17:42:48.484] The total size of the 2 globals is 112 bytes (112 bytes)
[17:42:48.485] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[17:42:48.485] - globals: [2] ‘a’, ‘ii’
[17:42:48.485] 
[17:42:48.485] getGlobalsAndPackages() ... DONE
[17:42:48.485] run() for ‘Future’ ...
[17:42:48.486] - state: ‘created’
[17:42:48.486] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.501]   - Field: ‘node’
[17:42:48.501]   - Field: ‘label’
[17:42:48.501]   - Field: ‘local’
[17:42:48.501]   - Field: ‘owner’
[17:42:48.501]   - Field: ‘envir’
[17:42:48.501]   - Field: ‘workers’
[17:42:48.501]   - Field: ‘packages’
[17:42:48.501]   - Field: ‘gc’
[17:42:48.501]   - Field: ‘conditions’
[17:42:48.501]   - Field: ‘persistent’
[17:42:48.502]   - Field: ‘expr’
[17:42:48.502]   - Field: ‘uuid’
[17:42:48.502]   - Field: ‘seed’
[17:42:48.502]   - Field: ‘version’
[17:42:48.502]   - Field: ‘result’
[17:42:48.502]   - Field: ‘asynchronous’
[17:42:48.502]   - Field: ‘calls’
[17:42:48.502]   - Field: ‘globals’
[17:42:48.502]   - Field: ‘stdout’
[17:42:48.502]   - Field: ‘earlySignal’
[17:42:48.502]   - Field: ‘lazy’
[17:42:48.505]   - Field: ‘state’
[17:42:48.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.505] - Launch lazy future ...
[17:42:48.506] Packages needed by the future expression (n = 0): <none>
[17:42:48.506] Packages needed by future strategies (n = 0): <none>
[17:42:48.506] {
[17:42:48.506]     {
[17:42:48.506]         {
[17:42:48.506]             ...future.startTime <- base::Sys.time()
[17:42:48.506]             {
[17:42:48.506]                 {
[17:42:48.506]                   {
[17:42:48.506]                     {
[17:42:48.506]                       base::local({
[17:42:48.506]                         has_future <- base::requireNamespace("future", 
[17:42:48.506]                           quietly = TRUE)
[17:42:48.506]                         if (has_future) {
[17:42:48.506]                           ns <- base::getNamespace("future")
[17:42:48.506]                           version <- ns[[".package"]][["version"]]
[17:42:48.506]                           if (is.null(version)) 
[17:42:48.506]                             version <- utils::packageVersion("future")
[17:42:48.506]                         }
[17:42:48.506]                         else {
[17:42:48.506]                           version <- NULL
[17:42:48.506]                         }
[17:42:48.506]                         if (!has_future || version < "1.8.0") {
[17:42:48.506]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.506]                             "", base::R.version$version.string), 
[17:42:48.506]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.506]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.506]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.506]                               "release", "version")], collapse = " "), 
[17:42:48.506]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.506]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.506]                             info)
[17:42:48.506]                           info <- base::paste(info, collapse = "; ")
[17:42:48.506]                           if (!has_future) {
[17:42:48.506]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.506]                               info)
[17:42:48.506]                           }
[17:42:48.506]                           else {
[17:42:48.506]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.506]                               info, version)
[17:42:48.506]                           }
[17:42:48.506]                           base::stop(msg)
[17:42:48.506]                         }
[17:42:48.506]                       })
[17:42:48.506]                     }
[17:42:48.506]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.506]                     base::options(mc.cores = 1L)
[17:42:48.506]                   }
[17:42:48.506]                   options(future.plan = NULL)
[17:42:48.506]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.506]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.506]                 }
[17:42:48.506]                 ...future.workdir <- getwd()
[17:42:48.506]             }
[17:42:48.506]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.506]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.506]         }
[17:42:48.506]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.506]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.506]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.506]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.506]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.506]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.506]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.506]             base::names(...future.oldOptions))
[17:42:48.506]     }
[17:42:48.506]     if (FALSE) {
[17:42:48.506]     }
[17:42:48.506]     else {
[17:42:48.506]         if (TRUE) {
[17:42:48.506]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.506]                 open = "w")
[17:42:48.506]         }
[17:42:48.506]         else {
[17:42:48.506]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.506]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.506]         }
[17:42:48.506]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.506]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.506]             base::sink(type = "output", split = FALSE)
[17:42:48.506]             base::close(...future.stdout)
[17:42:48.506]         }, add = TRUE)
[17:42:48.506]     }
[17:42:48.506]     ...future.frame <- base::sys.nframe()
[17:42:48.506]     ...future.conditions <- base::list()
[17:42:48.506]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.506]     if (FALSE) {
[17:42:48.506]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.506]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.506]     }
[17:42:48.506]     ...future.result <- base::tryCatch({
[17:42:48.506]         base::withCallingHandlers({
[17:42:48.506]             ...future.value <- base::withVisible(base::local({
[17:42:48.506]                 ...future.makeSendCondition <- local({
[17:42:48.506]                   sendCondition <- NULL
[17:42:48.506]                   function(frame = 1L) {
[17:42:48.506]                     if (is.function(sendCondition)) 
[17:42:48.506]                       return(sendCondition)
[17:42:48.506]                     ns <- getNamespace("parallel")
[17:42:48.506]                     if (exists("sendData", mode = "function", 
[17:42:48.506]                       envir = ns)) {
[17:42:48.506]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.506]                         envir = ns)
[17:42:48.506]                       envir <- sys.frame(frame)
[17:42:48.506]                       master <- NULL
[17:42:48.506]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.506]                         !identical(envir, emptyenv())) {
[17:42:48.506]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.506]                           inherits = FALSE)) {
[17:42:48.506]                           master <- get("master", mode = "list", 
[17:42:48.506]                             envir = envir, inherits = FALSE)
[17:42:48.506]                           if (inherits(master, c("SOCKnode", 
[17:42:48.506]                             "SOCK0node"))) {
[17:42:48.506]                             sendCondition <<- function(cond) {
[17:42:48.506]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.506]                                 success = TRUE)
[17:42:48.506]                               parallel_sendData(master, data)
[17:42:48.506]                             }
[17:42:48.506]                             return(sendCondition)
[17:42:48.506]                           }
[17:42:48.506]                         }
[17:42:48.506]                         frame <- frame + 1L
[17:42:48.506]                         envir <- sys.frame(frame)
[17:42:48.506]                       }
[17:42:48.506]                     }
[17:42:48.506]                     sendCondition <<- function(cond) NULL
[17:42:48.506]                   }
[17:42:48.506]                 })
[17:42:48.506]                 withCallingHandlers({
[17:42:48.506]                   {
[17:42:48.506]                     b <- a * ii
[17:42:48.506]                     a <- 0
[17:42:48.506]                     b
[17:42:48.506]                   }
[17:42:48.506]                 }, immediateCondition = function(cond) {
[17:42:48.506]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.506]                   sendCondition(cond)
[17:42:48.506]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.506]                   {
[17:42:48.506]                     inherits <- base::inherits
[17:42:48.506]                     invokeRestart <- base::invokeRestart
[17:42:48.506]                     is.null <- base::is.null
[17:42:48.506]                     muffled <- FALSE
[17:42:48.506]                     if (inherits(cond, "message")) {
[17:42:48.506]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.506]                       if (muffled) 
[17:42:48.506]                         invokeRestart("muffleMessage")
[17:42:48.506]                     }
[17:42:48.506]                     else if (inherits(cond, "warning")) {
[17:42:48.506]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.506]                       if (muffled) 
[17:42:48.506]                         invokeRestart("muffleWarning")
[17:42:48.506]                     }
[17:42:48.506]                     else if (inherits(cond, "condition")) {
[17:42:48.506]                       if (!is.null(pattern)) {
[17:42:48.506]                         computeRestarts <- base::computeRestarts
[17:42:48.506]                         grepl <- base::grepl
[17:42:48.506]                         restarts <- computeRestarts(cond)
[17:42:48.506]                         for (restart in restarts) {
[17:42:48.506]                           name <- restart$name
[17:42:48.506]                           if (is.null(name)) 
[17:42:48.506]                             next
[17:42:48.506]                           if (!grepl(pattern, name)) 
[17:42:48.506]                             next
[17:42:48.506]                           invokeRestart(restart)
[17:42:48.506]                           muffled <- TRUE
[17:42:48.506]                           break
[17:42:48.506]                         }
[17:42:48.506]                       }
[17:42:48.506]                     }
[17:42:48.506]                     invisible(muffled)
[17:42:48.506]                   }
[17:42:48.506]                   muffleCondition(cond)
[17:42:48.506]                 })
[17:42:48.506]             }))
[17:42:48.506]             future::FutureResult(value = ...future.value$value, 
[17:42:48.506]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.506]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.506]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.506]                     ...future.globalenv.names))
[17:42:48.506]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.506]         }, condition = base::local({
[17:42:48.506]             c <- base::c
[17:42:48.506]             inherits <- base::inherits
[17:42:48.506]             invokeRestart <- base::invokeRestart
[17:42:48.506]             length <- base::length
[17:42:48.506]             list <- base::list
[17:42:48.506]             seq.int <- base::seq.int
[17:42:48.506]             signalCondition <- base::signalCondition
[17:42:48.506]             sys.calls <- base::sys.calls
[17:42:48.506]             `[[` <- base::`[[`
[17:42:48.506]             `+` <- base::`+`
[17:42:48.506]             `<<-` <- base::`<<-`
[17:42:48.506]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.506]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.506]                   3L)]
[17:42:48.506]             }
[17:42:48.506]             function(cond) {
[17:42:48.506]                 is_error <- inherits(cond, "error")
[17:42:48.506]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.506]                   NULL)
[17:42:48.506]                 if (is_error) {
[17:42:48.506]                   sessionInformation <- function() {
[17:42:48.506]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.506]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.506]                       search = base::search(), system = base::Sys.info())
[17:42:48.506]                   }
[17:42:48.506]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.506]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.506]                     cond$call), session = sessionInformation(), 
[17:42:48.506]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.506]                   signalCondition(cond)
[17:42:48.506]                 }
[17:42:48.506]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.506]                 "immediateCondition"))) {
[17:42:48.506]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.506]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.506]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.506]                   if (TRUE && !signal) {
[17:42:48.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.506]                     {
[17:42:48.506]                       inherits <- base::inherits
[17:42:48.506]                       invokeRestart <- base::invokeRestart
[17:42:48.506]                       is.null <- base::is.null
[17:42:48.506]                       muffled <- FALSE
[17:42:48.506]                       if (inherits(cond, "message")) {
[17:42:48.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.506]                         if (muffled) 
[17:42:48.506]                           invokeRestart("muffleMessage")
[17:42:48.506]                       }
[17:42:48.506]                       else if (inherits(cond, "warning")) {
[17:42:48.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.506]                         if (muffled) 
[17:42:48.506]                           invokeRestart("muffleWarning")
[17:42:48.506]                       }
[17:42:48.506]                       else if (inherits(cond, "condition")) {
[17:42:48.506]                         if (!is.null(pattern)) {
[17:42:48.506]                           computeRestarts <- base::computeRestarts
[17:42:48.506]                           grepl <- base::grepl
[17:42:48.506]                           restarts <- computeRestarts(cond)
[17:42:48.506]                           for (restart in restarts) {
[17:42:48.506]                             name <- restart$name
[17:42:48.506]                             if (is.null(name)) 
[17:42:48.506]                               next
[17:42:48.506]                             if (!grepl(pattern, name)) 
[17:42:48.506]                               next
[17:42:48.506]                             invokeRestart(restart)
[17:42:48.506]                             muffled <- TRUE
[17:42:48.506]                             break
[17:42:48.506]                           }
[17:42:48.506]                         }
[17:42:48.506]                       }
[17:42:48.506]                       invisible(muffled)
[17:42:48.506]                     }
[17:42:48.506]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.506]                   }
[17:42:48.506]                 }
[17:42:48.506]                 else {
[17:42:48.506]                   if (TRUE) {
[17:42:48.506]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.506]                     {
[17:42:48.506]                       inherits <- base::inherits
[17:42:48.506]                       invokeRestart <- base::invokeRestart
[17:42:48.506]                       is.null <- base::is.null
[17:42:48.506]                       muffled <- FALSE
[17:42:48.506]                       if (inherits(cond, "message")) {
[17:42:48.506]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.506]                         if (muffled) 
[17:42:48.506]                           invokeRestart("muffleMessage")
[17:42:48.506]                       }
[17:42:48.506]                       else if (inherits(cond, "warning")) {
[17:42:48.506]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.506]                         if (muffled) 
[17:42:48.506]                           invokeRestart("muffleWarning")
[17:42:48.506]                       }
[17:42:48.506]                       else if (inherits(cond, "condition")) {
[17:42:48.506]                         if (!is.null(pattern)) {
[17:42:48.506]                           computeRestarts <- base::computeRestarts
[17:42:48.506]                           grepl <- base::grepl
[17:42:48.506]                           restarts <- computeRestarts(cond)
[17:42:48.506]                           for (restart in restarts) {
[17:42:48.506]                             name <- restart$name
[17:42:48.506]                             if (is.null(name)) 
[17:42:48.506]                               next
[17:42:48.506]                             if (!grepl(pattern, name)) 
[17:42:48.506]                               next
[17:42:48.506]                             invokeRestart(restart)
[17:42:48.506]                             muffled <- TRUE
[17:42:48.506]                             break
[17:42:48.506]                           }
[17:42:48.506]                         }
[17:42:48.506]                       }
[17:42:48.506]                       invisible(muffled)
[17:42:48.506]                     }
[17:42:48.506]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.506]                   }
[17:42:48.506]                 }
[17:42:48.506]             }
[17:42:48.506]         }))
[17:42:48.506]     }, error = function(ex) {
[17:42:48.506]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.506]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.506]                 ...future.rng), started = ...future.startTime, 
[17:42:48.506]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.506]             version = "1.8"), class = "FutureResult")
[17:42:48.506]     }, finally = {
[17:42:48.506]         if (!identical(...future.workdir, getwd())) 
[17:42:48.506]             setwd(...future.workdir)
[17:42:48.506]         {
[17:42:48.506]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.506]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.506]             }
[17:42:48.506]             base::options(...future.oldOptions)
[17:42:48.506]             if (.Platform$OS.type == "windows") {
[17:42:48.506]                 old_names <- names(...future.oldEnvVars)
[17:42:48.506]                 envs <- base::Sys.getenv()
[17:42:48.506]                 names <- names(envs)
[17:42:48.506]                 common <- intersect(names, old_names)
[17:42:48.506]                 added <- setdiff(names, old_names)
[17:42:48.506]                 removed <- setdiff(old_names, names)
[17:42:48.506]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.506]                   envs[common]]
[17:42:48.506]                 NAMES <- toupper(changed)
[17:42:48.506]                 args <- list()
[17:42:48.506]                 for (kk in seq_along(NAMES)) {
[17:42:48.506]                   name <- changed[[kk]]
[17:42:48.506]                   NAME <- NAMES[[kk]]
[17:42:48.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.506]                     next
[17:42:48.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.506]                 }
[17:42:48.506]                 NAMES <- toupper(added)
[17:42:48.506]                 for (kk in seq_along(NAMES)) {
[17:42:48.506]                   name <- added[[kk]]
[17:42:48.506]                   NAME <- NAMES[[kk]]
[17:42:48.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.506]                     next
[17:42:48.506]                   args[[name]] <- ""
[17:42:48.506]                 }
[17:42:48.506]                 NAMES <- toupper(removed)
[17:42:48.506]                 for (kk in seq_along(NAMES)) {
[17:42:48.506]                   name <- removed[[kk]]
[17:42:48.506]                   NAME <- NAMES[[kk]]
[17:42:48.506]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.506]                     next
[17:42:48.506]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.506]                 }
[17:42:48.506]                 if (length(args) > 0) 
[17:42:48.506]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.506]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.506]             }
[17:42:48.506]             else {
[17:42:48.506]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.506]             }
[17:42:48.506]             {
[17:42:48.506]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.506]                   0L) {
[17:42:48.506]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.506]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.506]                   base::options(opts)
[17:42:48.506]                 }
[17:42:48.506]                 {
[17:42:48.506]                   {
[17:42:48.506]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.506]                     NULL
[17:42:48.506]                   }
[17:42:48.506]                   options(future.plan = NULL)
[17:42:48.506]                   if (is.na(NA_character_)) 
[17:42:48.506]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.506]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.506]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.506]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.506]                     envir = parent.frame()) 
[17:42:48.506]                   {
[17:42:48.506]                     if (is.function(workers)) 
[17:42:48.506]                       workers <- workers()
[17:42:48.506]                     workers <- structure(as.integer(workers), 
[17:42:48.506]                       class = class(workers))
[17:42:48.506]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.506]                       workers >= 1)
[17:42:48.506]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.506]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.506]                     }
[17:42:48.506]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.506]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.506]                       envir = envir)
[17:42:48.506]                     if (!future$lazy) 
[17:42:48.506]                       future <- run(future)
[17:42:48.506]                     invisible(future)
[17:42:48.506]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.506]                 }
[17:42:48.506]             }
[17:42:48.506]         }
[17:42:48.506]     })
[17:42:48.506]     if (TRUE) {
[17:42:48.506]         base::sink(type = "output", split = FALSE)
[17:42:48.506]         if (TRUE) {
[17:42:48.506]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.506]         }
[17:42:48.506]         else {
[17:42:48.506]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.506]         }
[17:42:48.506]         base::close(...future.stdout)
[17:42:48.506]         ...future.stdout <- NULL
[17:42:48.506]     }
[17:42:48.506]     ...future.result$conditions <- ...future.conditions
[17:42:48.506]     ...future.result$finished <- base::Sys.time()
[17:42:48.506]     ...future.result
[17:42:48.506] }
[17:42:48.509] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:42:48.509] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:42:48.509] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.509] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:48.510] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.510] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:42:48.510] MultisessionFuture started
[17:42:48.510] - Launch lazy future ... done
[17:42:48.511] run() for ‘MultisessionFuture’ ... done
[17:42:48.511] result() for ClusterFuture ...
[17:42:48.511] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.511] - Validating connection of MultisessionFuture
[17:42:48.556] - received message: FutureResult
[17:42:48.556] - Received FutureResult
[17:42:48.556] - Erased future from FutureRegistry
[17:42:48.557] result() for ClusterFuture ...
[17:42:48.557] - result already collected: FutureResult
[17:42:48.557] result() for ClusterFuture ... done
[17:42:48.557] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.557] result() for ClusterFuture ... done
[17:42:48.557] result() for ClusterFuture ...
[17:42:48.557] - result already collected: FutureResult
[17:42:48.557] result() for ClusterFuture ... done
[17:42:48.557] run() for ‘Future’ ...
[17:42:48.557] - state: ‘created’
[17:42:48.558] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.572]   - Field: ‘node’
[17:42:48.572]   - Field: ‘label’
[17:42:48.573]   - Field: ‘local’
[17:42:48.573]   - Field: ‘owner’
[17:42:48.573]   - Field: ‘envir’
[17:42:48.573]   - Field: ‘workers’
[17:42:48.573]   - Field: ‘packages’
[17:42:48.573]   - Field: ‘gc’
[17:42:48.573]   - Field: ‘conditions’
[17:42:48.573]   - Field: ‘persistent’
[17:42:48.573]   - Field: ‘expr’
[17:42:48.573]   - Field: ‘uuid’
[17:42:48.573]   - Field: ‘seed’
[17:42:48.574]   - Field: ‘version’
[17:42:48.574]   - Field: ‘result’
[17:42:48.574]   - Field: ‘asynchronous’
[17:42:48.574]   - Field: ‘calls’
[17:42:48.574]   - Field: ‘globals’
[17:42:48.574]   - Field: ‘stdout’
[17:42:48.574]   - Field: ‘earlySignal’
[17:42:48.574]   - Field: ‘lazy’
[17:42:48.574]   - Field: ‘state’
[17:42:48.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.574] - Launch lazy future ...
[17:42:48.575] Packages needed by the future expression (n = 0): <none>
[17:42:48.575] Packages needed by future strategies (n = 0): <none>
[17:42:48.575] {
[17:42:48.575]     {
[17:42:48.575]         {
[17:42:48.575]             ...future.startTime <- base::Sys.time()
[17:42:48.575]             {
[17:42:48.575]                 {
[17:42:48.575]                   {
[17:42:48.575]                     {
[17:42:48.575]                       base::local({
[17:42:48.575]                         has_future <- base::requireNamespace("future", 
[17:42:48.575]                           quietly = TRUE)
[17:42:48.575]                         if (has_future) {
[17:42:48.575]                           ns <- base::getNamespace("future")
[17:42:48.575]                           version <- ns[[".package"]][["version"]]
[17:42:48.575]                           if (is.null(version)) 
[17:42:48.575]                             version <- utils::packageVersion("future")
[17:42:48.575]                         }
[17:42:48.575]                         else {
[17:42:48.575]                           version <- NULL
[17:42:48.575]                         }
[17:42:48.575]                         if (!has_future || version < "1.8.0") {
[17:42:48.575]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.575]                             "", base::R.version$version.string), 
[17:42:48.575]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.575]                               "release", "version")], collapse = " "), 
[17:42:48.575]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.575]                             info)
[17:42:48.575]                           info <- base::paste(info, collapse = "; ")
[17:42:48.575]                           if (!has_future) {
[17:42:48.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.575]                               info)
[17:42:48.575]                           }
[17:42:48.575]                           else {
[17:42:48.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.575]                               info, version)
[17:42:48.575]                           }
[17:42:48.575]                           base::stop(msg)
[17:42:48.575]                         }
[17:42:48.575]                       })
[17:42:48.575]                     }
[17:42:48.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.575]                     base::options(mc.cores = 1L)
[17:42:48.575]                   }
[17:42:48.575]                   options(future.plan = NULL)
[17:42:48.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.575]                 }
[17:42:48.575]                 ...future.workdir <- getwd()
[17:42:48.575]             }
[17:42:48.575]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.575]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.575]         }
[17:42:48.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.575]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.575]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.575]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.575]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.575]             base::names(...future.oldOptions))
[17:42:48.575]     }
[17:42:48.575]     if (FALSE) {
[17:42:48.575]     }
[17:42:48.575]     else {
[17:42:48.575]         if (TRUE) {
[17:42:48.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.575]                 open = "w")
[17:42:48.575]         }
[17:42:48.575]         else {
[17:42:48.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.575]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.575]         }
[17:42:48.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.575]             base::sink(type = "output", split = FALSE)
[17:42:48.575]             base::close(...future.stdout)
[17:42:48.575]         }, add = TRUE)
[17:42:48.575]     }
[17:42:48.575]     ...future.frame <- base::sys.nframe()
[17:42:48.575]     ...future.conditions <- base::list()
[17:42:48.575]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.575]     if (FALSE) {
[17:42:48.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.575]     }
[17:42:48.575]     ...future.result <- base::tryCatch({
[17:42:48.575]         base::withCallingHandlers({
[17:42:48.575]             ...future.value <- base::withVisible(base::local({
[17:42:48.575]                 ...future.makeSendCondition <- local({
[17:42:48.575]                   sendCondition <- NULL
[17:42:48.575]                   function(frame = 1L) {
[17:42:48.575]                     if (is.function(sendCondition)) 
[17:42:48.575]                       return(sendCondition)
[17:42:48.575]                     ns <- getNamespace("parallel")
[17:42:48.575]                     if (exists("sendData", mode = "function", 
[17:42:48.575]                       envir = ns)) {
[17:42:48.575]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.575]                         envir = ns)
[17:42:48.575]                       envir <- sys.frame(frame)
[17:42:48.575]                       master <- NULL
[17:42:48.575]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.575]                         !identical(envir, emptyenv())) {
[17:42:48.575]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.575]                           inherits = FALSE)) {
[17:42:48.575]                           master <- get("master", mode = "list", 
[17:42:48.575]                             envir = envir, inherits = FALSE)
[17:42:48.575]                           if (inherits(master, c("SOCKnode", 
[17:42:48.575]                             "SOCK0node"))) {
[17:42:48.575]                             sendCondition <<- function(cond) {
[17:42:48.575]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.575]                                 success = TRUE)
[17:42:48.575]                               parallel_sendData(master, data)
[17:42:48.575]                             }
[17:42:48.575]                             return(sendCondition)
[17:42:48.575]                           }
[17:42:48.575]                         }
[17:42:48.575]                         frame <- frame + 1L
[17:42:48.575]                         envir <- sys.frame(frame)
[17:42:48.575]                       }
[17:42:48.575]                     }
[17:42:48.575]                     sendCondition <<- function(cond) NULL
[17:42:48.575]                   }
[17:42:48.575]                 })
[17:42:48.575]                 withCallingHandlers({
[17:42:48.575]                   {
[17:42:48.575]                     b <- a * ii
[17:42:48.575]                     a <- 0
[17:42:48.575]                     b
[17:42:48.575]                   }
[17:42:48.575]                 }, immediateCondition = function(cond) {
[17:42:48.575]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.575]                   sendCondition(cond)
[17:42:48.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.575]                   {
[17:42:48.575]                     inherits <- base::inherits
[17:42:48.575]                     invokeRestart <- base::invokeRestart
[17:42:48.575]                     is.null <- base::is.null
[17:42:48.575]                     muffled <- FALSE
[17:42:48.575]                     if (inherits(cond, "message")) {
[17:42:48.575]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.575]                       if (muffled) 
[17:42:48.575]                         invokeRestart("muffleMessage")
[17:42:48.575]                     }
[17:42:48.575]                     else if (inherits(cond, "warning")) {
[17:42:48.575]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.575]                       if (muffled) 
[17:42:48.575]                         invokeRestart("muffleWarning")
[17:42:48.575]                     }
[17:42:48.575]                     else if (inherits(cond, "condition")) {
[17:42:48.575]                       if (!is.null(pattern)) {
[17:42:48.575]                         computeRestarts <- base::computeRestarts
[17:42:48.575]                         grepl <- base::grepl
[17:42:48.575]                         restarts <- computeRestarts(cond)
[17:42:48.575]                         for (restart in restarts) {
[17:42:48.575]                           name <- restart$name
[17:42:48.575]                           if (is.null(name)) 
[17:42:48.575]                             next
[17:42:48.575]                           if (!grepl(pattern, name)) 
[17:42:48.575]                             next
[17:42:48.575]                           invokeRestart(restart)
[17:42:48.575]                           muffled <- TRUE
[17:42:48.575]                           break
[17:42:48.575]                         }
[17:42:48.575]                       }
[17:42:48.575]                     }
[17:42:48.575]                     invisible(muffled)
[17:42:48.575]                   }
[17:42:48.575]                   muffleCondition(cond)
[17:42:48.575]                 })
[17:42:48.575]             }))
[17:42:48.575]             future::FutureResult(value = ...future.value$value, 
[17:42:48.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.575]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.575]                     ...future.globalenv.names))
[17:42:48.575]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.575]         }, condition = base::local({
[17:42:48.575]             c <- base::c
[17:42:48.575]             inherits <- base::inherits
[17:42:48.575]             invokeRestart <- base::invokeRestart
[17:42:48.575]             length <- base::length
[17:42:48.575]             list <- base::list
[17:42:48.575]             seq.int <- base::seq.int
[17:42:48.575]             signalCondition <- base::signalCondition
[17:42:48.575]             sys.calls <- base::sys.calls
[17:42:48.575]             `[[` <- base::`[[`
[17:42:48.575]             `+` <- base::`+`
[17:42:48.575]             `<<-` <- base::`<<-`
[17:42:48.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.575]                   3L)]
[17:42:48.575]             }
[17:42:48.575]             function(cond) {
[17:42:48.575]                 is_error <- inherits(cond, "error")
[17:42:48.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.575]                   NULL)
[17:42:48.575]                 if (is_error) {
[17:42:48.575]                   sessionInformation <- function() {
[17:42:48.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.575]                       search = base::search(), system = base::Sys.info())
[17:42:48.575]                   }
[17:42:48.575]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.575]                     cond$call), session = sessionInformation(), 
[17:42:48.575]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.575]                   signalCondition(cond)
[17:42:48.575]                 }
[17:42:48.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.575]                 "immediateCondition"))) {
[17:42:48.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.575]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.575]                   if (TRUE && !signal) {
[17:42:48.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.575]                     {
[17:42:48.575]                       inherits <- base::inherits
[17:42:48.575]                       invokeRestart <- base::invokeRestart
[17:42:48.575]                       is.null <- base::is.null
[17:42:48.575]                       muffled <- FALSE
[17:42:48.575]                       if (inherits(cond, "message")) {
[17:42:48.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.575]                         if (muffled) 
[17:42:48.575]                           invokeRestart("muffleMessage")
[17:42:48.575]                       }
[17:42:48.575]                       else if (inherits(cond, "warning")) {
[17:42:48.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.575]                         if (muffled) 
[17:42:48.575]                           invokeRestart("muffleWarning")
[17:42:48.575]                       }
[17:42:48.575]                       else if (inherits(cond, "condition")) {
[17:42:48.575]                         if (!is.null(pattern)) {
[17:42:48.575]                           computeRestarts <- base::computeRestarts
[17:42:48.575]                           grepl <- base::grepl
[17:42:48.575]                           restarts <- computeRestarts(cond)
[17:42:48.575]                           for (restart in restarts) {
[17:42:48.575]                             name <- restart$name
[17:42:48.575]                             if (is.null(name)) 
[17:42:48.575]                               next
[17:42:48.575]                             if (!grepl(pattern, name)) 
[17:42:48.575]                               next
[17:42:48.575]                             invokeRestart(restart)
[17:42:48.575]                             muffled <- TRUE
[17:42:48.575]                             break
[17:42:48.575]                           }
[17:42:48.575]                         }
[17:42:48.575]                       }
[17:42:48.575]                       invisible(muffled)
[17:42:48.575]                     }
[17:42:48.575]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.575]                   }
[17:42:48.575]                 }
[17:42:48.575]                 else {
[17:42:48.575]                   if (TRUE) {
[17:42:48.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.575]                     {
[17:42:48.575]                       inherits <- base::inherits
[17:42:48.575]                       invokeRestart <- base::invokeRestart
[17:42:48.575]                       is.null <- base::is.null
[17:42:48.575]                       muffled <- FALSE
[17:42:48.575]                       if (inherits(cond, "message")) {
[17:42:48.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.575]                         if (muffled) 
[17:42:48.575]                           invokeRestart("muffleMessage")
[17:42:48.575]                       }
[17:42:48.575]                       else if (inherits(cond, "warning")) {
[17:42:48.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.575]                         if (muffled) 
[17:42:48.575]                           invokeRestart("muffleWarning")
[17:42:48.575]                       }
[17:42:48.575]                       else if (inherits(cond, "condition")) {
[17:42:48.575]                         if (!is.null(pattern)) {
[17:42:48.575]                           computeRestarts <- base::computeRestarts
[17:42:48.575]                           grepl <- base::grepl
[17:42:48.575]                           restarts <- computeRestarts(cond)
[17:42:48.575]                           for (restart in restarts) {
[17:42:48.575]                             name <- restart$name
[17:42:48.575]                             if (is.null(name)) 
[17:42:48.575]                               next
[17:42:48.575]                             if (!grepl(pattern, name)) 
[17:42:48.575]                               next
[17:42:48.575]                             invokeRestart(restart)
[17:42:48.575]                             muffled <- TRUE
[17:42:48.575]                             break
[17:42:48.575]                           }
[17:42:48.575]                         }
[17:42:48.575]                       }
[17:42:48.575]                       invisible(muffled)
[17:42:48.575]                     }
[17:42:48.575]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.575]                   }
[17:42:48.575]                 }
[17:42:48.575]             }
[17:42:48.575]         }))
[17:42:48.575]     }, error = function(ex) {
[17:42:48.575]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.575]                 ...future.rng), started = ...future.startTime, 
[17:42:48.575]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.575]             version = "1.8"), class = "FutureResult")
[17:42:48.575]     }, finally = {
[17:42:48.575]         if (!identical(...future.workdir, getwd())) 
[17:42:48.575]             setwd(...future.workdir)
[17:42:48.575]         {
[17:42:48.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.575]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.575]             }
[17:42:48.575]             base::options(...future.oldOptions)
[17:42:48.575]             if (.Platform$OS.type == "windows") {
[17:42:48.575]                 old_names <- names(...future.oldEnvVars)
[17:42:48.575]                 envs <- base::Sys.getenv()
[17:42:48.575]                 names <- names(envs)
[17:42:48.575]                 common <- intersect(names, old_names)
[17:42:48.575]                 added <- setdiff(names, old_names)
[17:42:48.575]                 removed <- setdiff(old_names, names)
[17:42:48.575]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.575]                   envs[common]]
[17:42:48.575]                 NAMES <- toupper(changed)
[17:42:48.575]                 args <- list()
[17:42:48.575]                 for (kk in seq_along(NAMES)) {
[17:42:48.575]                   name <- changed[[kk]]
[17:42:48.575]                   NAME <- NAMES[[kk]]
[17:42:48.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.575]                     next
[17:42:48.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.575]                 }
[17:42:48.575]                 NAMES <- toupper(added)
[17:42:48.575]                 for (kk in seq_along(NAMES)) {
[17:42:48.575]                   name <- added[[kk]]
[17:42:48.575]                   NAME <- NAMES[[kk]]
[17:42:48.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.575]                     next
[17:42:48.575]                   args[[name]] <- ""
[17:42:48.575]                 }
[17:42:48.575]                 NAMES <- toupper(removed)
[17:42:48.575]                 for (kk in seq_along(NAMES)) {
[17:42:48.575]                   name <- removed[[kk]]
[17:42:48.575]                   NAME <- NAMES[[kk]]
[17:42:48.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.575]                     next
[17:42:48.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.575]                 }
[17:42:48.575]                 if (length(args) > 0) 
[17:42:48.575]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.575]             }
[17:42:48.575]             else {
[17:42:48.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.575]             }
[17:42:48.575]             {
[17:42:48.575]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.575]                   0L) {
[17:42:48.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.575]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.575]                   base::options(opts)
[17:42:48.575]                 }
[17:42:48.575]                 {
[17:42:48.575]                   {
[17:42:48.575]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.575]                     NULL
[17:42:48.575]                   }
[17:42:48.575]                   options(future.plan = NULL)
[17:42:48.575]                   if (is.na(NA_character_)) 
[17:42:48.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.575]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.575]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.575]                     envir = parent.frame()) 
[17:42:48.575]                   {
[17:42:48.575]                     if (is.function(workers)) 
[17:42:48.575]                       workers <- workers()
[17:42:48.575]                     workers <- structure(as.integer(workers), 
[17:42:48.575]                       class = class(workers))
[17:42:48.575]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.575]                       workers >= 1)
[17:42:48.575]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.575]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.575]                     }
[17:42:48.575]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.575]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.575]                       envir = envir)
[17:42:48.575]                     if (!future$lazy) 
[17:42:48.575]                       future <- run(future)
[17:42:48.575]                     invisible(future)
[17:42:48.575]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.575]                 }
[17:42:48.575]             }
[17:42:48.575]         }
[17:42:48.575]     })
[17:42:48.575]     if (TRUE) {
[17:42:48.575]         base::sink(type = "output", split = FALSE)
[17:42:48.575]         if (TRUE) {
[17:42:48.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.575]         }
[17:42:48.575]         else {
[17:42:48.575]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.575]         }
[17:42:48.575]         base::close(...future.stdout)
[17:42:48.575]         ...future.stdout <- NULL
[17:42:48.575]     }
[17:42:48.575]     ...future.result$conditions <- ...future.conditions
[17:42:48.575]     ...future.result$finished <- base::Sys.time()
[17:42:48.575]     ...future.result
[17:42:48.575] }
[17:42:48.578] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:42:48.578] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:42:48.579] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.579] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:48.579] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.579] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:42:48.580] MultisessionFuture started
[17:42:48.580] - Launch lazy future ... done
[17:42:48.580] run() for ‘MultisessionFuture’ ... done
[17:42:48.580] result() for ClusterFuture ...
[17:42:48.580] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.580] - Validating connection of MultisessionFuture
[17:42:48.628] - received message: FutureResult
[17:42:48.628] - Received FutureResult
[17:42:48.628] - Erased future from FutureRegistry
[17:42:48.629] result() for ClusterFuture ...
[17:42:48.629] - result already collected: FutureResult
[17:42:48.629] result() for ClusterFuture ... done
[17:42:48.629] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.629] result() for ClusterFuture ... done
[17:42:48.629] result() for ClusterFuture ...
[17:42:48.629] - result already collected: FutureResult
[17:42:48.629] result() for ClusterFuture ... done
[17:42:48.629] run() for ‘Future’ ...
[17:42:48.630] - state: ‘created’
[17:42:48.630] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.644] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.645]   - Field: ‘node’
[17:42:48.645]   - Field: ‘label’
[17:42:48.645]   - Field: ‘local’
[17:42:48.645]   - Field: ‘owner’
[17:42:48.645]   - Field: ‘envir’
[17:42:48.645]   - Field: ‘workers’
[17:42:48.645]   - Field: ‘packages’
[17:42:48.645]   - Field: ‘gc’
[17:42:48.645]   - Field: ‘conditions’
[17:42:48.645]   - Field: ‘persistent’
[17:42:48.645]   - Field: ‘expr’
[17:42:48.646]   - Field: ‘uuid’
[17:42:48.646]   - Field: ‘seed’
[17:42:48.646]   - Field: ‘version’
[17:42:48.646]   - Field: ‘result’
[17:42:48.646]   - Field: ‘asynchronous’
[17:42:48.646]   - Field: ‘calls’
[17:42:48.646]   - Field: ‘globals’
[17:42:48.647]   - Field: ‘stdout’
[17:42:48.647]   - Field: ‘earlySignal’
[17:42:48.647]   - Field: ‘lazy’
[17:42:48.647]   - Field: ‘state’
[17:42:48.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.647] - Launch lazy future ...
[17:42:48.647] Packages needed by the future expression (n = 0): <none>
[17:42:48.648] Packages needed by future strategies (n = 0): <none>
[17:42:48.648] {
[17:42:48.648]     {
[17:42:48.648]         {
[17:42:48.648]             ...future.startTime <- base::Sys.time()
[17:42:48.648]             {
[17:42:48.648]                 {
[17:42:48.648]                   {
[17:42:48.648]                     {
[17:42:48.648]                       base::local({
[17:42:48.648]                         has_future <- base::requireNamespace("future", 
[17:42:48.648]                           quietly = TRUE)
[17:42:48.648]                         if (has_future) {
[17:42:48.648]                           ns <- base::getNamespace("future")
[17:42:48.648]                           version <- ns[[".package"]][["version"]]
[17:42:48.648]                           if (is.null(version)) 
[17:42:48.648]                             version <- utils::packageVersion("future")
[17:42:48.648]                         }
[17:42:48.648]                         else {
[17:42:48.648]                           version <- NULL
[17:42:48.648]                         }
[17:42:48.648]                         if (!has_future || version < "1.8.0") {
[17:42:48.648]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.648]                             "", base::R.version$version.string), 
[17:42:48.648]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.648]                               "release", "version")], collapse = " "), 
[17:42:48.648]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.648]                             info)
[17:42:48.648]                           info <- base::paste(info, collapse = "; ")
[17:42:48.648]                           if (!has_future) {
[17:42:48.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.648]                               info)
[17:42:48.648]                           }
[17:42:48.648]                           else {
[17:42:48.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.648]                               info, version)
[17:42:48.648]                           }
[17:42:48.648]                           base::stop(msg)
[17:42:48.648]                         }
[17:42:48.648]                       })
[17:42:48.648]                     }
[17:42:48.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.648]                     base::options(mc.cores = 1L)
[17:42:48.648]                   }
[17:42:48.648]                   options(future.plan = NULL)
[17:42:48.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.648]                 }
[17:42:48.648]                 ...future.workdir <- getwd()
[17:42:48.648]             }
[17:42:48.648]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.648]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.648]         }
[17:42:48.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.648]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.648]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.648]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.648]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.648]             base::names(...future.oldOptions))
[17:42:48.648]     }
[17:42:48.648]     if (FALSE) {
[17:42:48.648]     }
[17:42:48.648]     else {
[17:42:48.648]         if (TRUE) {
[17:42:48.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.648]                 open = "w")
[17:42:48.648]         }
[17:42:48.648]         else {
[17:42:48.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.648]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.648]         }
[17:42:48.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.648]             base::sink(type = "output", split = FALSE)
[17:42:48.648]             base::close(...future.stdout)
[17:42:48.648]         }, add = TRUE)
[17:42:48.648]     }
[17:42:48.648]     ...future.frame <- base::sys.nframe()
[17:42:48.648]     ...future.conditions <- base::list()
[17:42:48.648]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.648]     if (FALSE) {
[17:42:48.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.648]     }
[17:42:48.648]     ...future.result <- base::tryCatch({
[17:42:48.648]         base::withCallingHandlers({
[17:42:48.648]             ...future.value <- base::withVisible(base::local({
[17:42:48.648]                 ...future.makeSendCondition <- local({
[17:42:48.648]                   sendCondition <- NULL
[17:42:48.648]                   function(frame = 1L) {
[17:42:48.648]                     if (is.function(sendCondition)) 
[17:42:48.648]                       return(sendCondition)
[17:42:48.648]                     ns <- getNamespace("parallel")
[17:42:48.648]                     if (exists("sendData", mode = "function", 
[17:42:48.648]                       envir = ns)) {
[17:42:48.648]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.648]                         envir = ns)
[17:42:48.648]                       envir <- sys.frame(frame)
[17:42:48.648]                       master <- NULL
[17:42:48.648]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.648]                         !identical(envir, emptyenv())) {
[17:42:48.648]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.648]                           inherits = FALSE)) {
[17:42:48.648]                           master <- get("master", mode = "list", 
[17:42:48.648]                             envir = envir, inherits = FALSE)
[17:42:48.648]                           if (inherits(master, c("SOCKnode", 
[17:42:48.648]                             "SOCK0node"))) {
[17:42:48.648]                             sendCondition <<- function(cond) {
[17:42:48.648]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.648]                                 success = TRUE)
[17:42:48.648]                               parallel_sendData(master, data)
[17:42:48.648]                             }
[17:42:48.648]                             return(sendCondition)
[17:42:48.648]                           }
[17:42:48.648]                         }
[17:42:48.648]                         frame <- frame + 1L
[17:42:48.648]                         envir <- sys.frame(frame)
[17:42:48.648]                       }
[17:42:48.648]                     }
[17:42:48.648]                     sendCondition <<- function(cond) NULL
[17:42:48.648]                   }
[17:42:48.648]                 })
[17:42:48.648]                 withCallingHandlers({
[17:42:48.648]                   {
[17:42:48.648]                     b <- a * ii
[17:42:48.648]                     a <- 0
[17:42:48.648]                     b
[17:42:48.648]                   }
[17:42:48.648]                 }, immediateCondition = function(cond) {
[17:42:48.648]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.648]                   sendCondition(cond)
[17:42:48.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.648]                   {
[17:42:48.648]                     inherits <- base::inherits
[17:42:48.648]                     invokeRestart <- base::invokeRestart
[17:42:48.648]                     is.null <- base::is.null
[17:42:48.648]                     muffled <- FALSE
[17:42:48.648]                     if (inherits(cond, "message")) {
[17:42:48.648]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.648]                       if (muffled) 
[17:42:48.648]                         invokeRestart("muffleMessage")
[17:42:48.648]                     }
[17:42:48.648]                     else if (inherits(cond, "warning")) {
[17:42:48.648]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.648]                       if (muffled) 
[17:42:48.648]                         invokeRestart("muffleWarning")
[17:42:48.648]                     }
[17:42:48.648]                     else if (inherits(cond, "condition")) {
[17:42:48.648]                       if (!is.null(pattern)) {
[17:42:48.648]                         computeRestarts <- base::computeRestarts
[17:42:48.648]                         grepl <- base::grepl
[17:42:48.648]                         restarts <- computeRestarts(cond)
[17:42:48.648]                         for (restart in restarts) {
[17:42:48.648]                           name <- restart$name
[17:42:48.648]                           if (is.null(name)) 
[17:42:48.648]                             next
[17:42:48.648]                           if (!grepl(pattern, name)) 
[17:42:48.648]                             next
[17:42:48.648]                           invokeRestart(restart)
[17:42:48.648]                           muffled <- TRUE
[17:42:48.648]                           break
[17:42:48.648]                         }
[17:42:48.648]                       }
[17:42:48.648]                     }
[17:42:48.648]                     invisible(muffled)
[17:42:48.648]                   }
[17:42:48.648]                   muffleCondition(cond)
[17:42:48.648]                 })
[17:42:48.648]             }))
[17:42:48.648]             future::FutureResult(value = ...future.value$value, 
[17:42:48.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.648]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.648]                     ...future.globalenv.names))
[17:42:48.648]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.648]         }, condition = base::local({
[17:42:48.648]             c <- base::c
[17:42:48.648]             inherits <- base::inherits
[17:42:48.648]             invokeRestart <- base::invokeRestart
[17:42:48.648]             length <- base::length
[17:42:48.648]             list <- base::list
[17:42:48.648]             seq.int <- base::seq.int
[17:42:48.648]             signalCondition <- base::signalCondition
[17:42:48.648]             sys.calls <- base::sys.calls
[17:42:48.648]             `[[` <- base::`[[`
[17:42:48.648]             `+` <- base::`+`
[17:42:48.648]             `<<-` <- base::`<<-`
[17:42:48.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.648]                   3L)]
[17:42:48.648]             }
[17:42:48.648]             function(cond) {
[17:42:48.648]                 is_error <- inherits(cond, "error")
[17:42:48.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.648]                   NULL)
[17:42:48.648]                 if (is_error) {
[17:42:48.648]                   sessionInformation <- function() {
[17:42:48.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.648]                       search = base::search(), system = base::Sys.info())
[17:42:48.648]                   }
[17:42:48.648]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.648]                     cond$call), session = sessionInformation(), 
[17:42:48.648]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.648]                   signalCondition(cond)
[17:42:48.648]                 }
[17:42:48.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.648]                 "immediateCondition"))) {
[17:42:48.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.648]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.648]                   if (TRUE && !signal) {
[17:42:48.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.648]                     {
[17:42:48.648]                       inherits <- base::inherits
[17:42:48.648]                       invokeRestart <- base::invokeRestart
[17:42:48.648]                       is.null <- base::is.null
[17:42:48.648]                       muffled <- FALSE
[17:42:48.648]                       if (inherits(cond, "message")) {
[17:42:48.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.648]                         if (muffled) 
[17:42:48.648]                           invokeRestart("muffleMessage")
[17:42:48.648]                       }
[17:42:48.648]                       else if (inherits(cond, "warning")) {
[17:42:48.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.648]                         if (muffled) 
[17:42:48.648]                           invokeRestart("muffleWarning")
[17:42:48.648]                       }
[17:42:48.648]                       else if (inherits(cond, "condition")) {
[17:42:48.648]                         if (!is.null(pattern)) {
[17:42:48.648]                           computeRestarts <- base::computeRestarts
[17:42:48.648]                           grepl <- base::grepl
[17:42:48.648]                           restarts <- computeRestarts(cond)
[17:42:48.648]                           for (restart in restarts) {
[17:42:48.648]                             name <- restart$name
[17:42:48.648]                             if (is.null(name)) 
[17:42:48.648]                               next
[17:42:48.648]                             if (!grepl(pattern, name)) 
[17:42:48.648]                               next
[17:42:48.648]                             invokeRestart(restart)
[17:42:48.648]                             muffled <- TRUE
[17:42:48.648]                             break
[17:42:48.648]                           }
[17:42:48.648]                         }
[17:42:48.648]                       }
[17:42:48.648]                       invisible(muffled)
[17:42:48.648]                     }
[17:42:48.648]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.648]                   }
[17:42:48.648]                 }
[17:42:48.648]                 else {
[17:42:48.648]                   if (TRUE) {
[17:42:48.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.648]                     {
[17:42:48.648]                       inherits <- base::inherits
[17:42:48.648]                       invokeRestart <- base::invokeRestart
[17:42:48.648]                       is.null <- base::is.null
[17:42:48.648]                       muffled <- FALSE
[17:42:48.648]                       if (inherits(cond, "message")) {
[17:42:48.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.648]                         if (muffled) 
[17:42:48.648]                           invokeRestart("muffleMessage")
[17:42:48.648]                       }
[17:42:48.648]                       else if (inherits(cond, "warning")) {
[17:42:48.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.648]                         if (muffled) 
[17:42:48.648]                           invokeRestart("muffleWarning")
[17:42:48.648]                       }
[17:42:48.648]                       else if (inherits(cond, "condition")) {
[17:42:48.648]                         if (!is.null(pattern)) {
[17:42:48.648]                           computeRestarts <- base::computeRestarts
[17:42:48.648]                           grepl <- base::grepl
[17:42:48.648]                           restarts <- computeRestarts(cond)
[17:42:48.648]                           for (restart in restarts) {
[17:42:48.648]                             name <- restart$name
[17:42:48.648]                             if (is.null(name)) 
[17:42:48.648]                               next
[17:42:48.648]                             if (!grepl(pattern, name)) 
[17:42:48.648]                               next
[17:42:48.648]                             invokeRestart(restart)
[17:42:48.648]                             muffled <- TRUE
[17:42:48.648]                             break
[17:42:48.648]                           }
[17:42:48.648]                         }
[17:42:48.648]                       }
[17:42:48.648]                       invisible(muffled)
[17:42:48.648]                     }
[17:42:48.648]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.648]                   }
[17:42:48.648]                 }
[17:42:48.648]             }
[17:42:48.648]         }))
[17:42:48.648]     }, error = function(ex) {
[17:42:48.648]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.648]                 ...future.rng), started = ...future.startTime, 
[17:42:48.648]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.648]             version = "1.8"), class = "FutureResult")
[17:42:48.648]     }, finally = {
[17:42:48.648]         if (!identical(...future.workdir, getwd())) 
[17:42:48.648]             setwd(...future.workdir)
[17:42:48.648]         {
[17:42:48.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.648]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.648]             }
[17:42:48.648]             base::options(...future.oldOptions)
[17:42:48.648]             if (.Platform$OS.type == "windows") {
[17:42:48.648]                 old_names <- names(...future.oldEnvVars)
[17:42:48.648]                 envs <- base::Sys.getenv()
[17:42:48.648]                 names <- names(envs)
[17:42:48.648]                 common <- intersect(names, old_names)
[17:42:48.648]                 added <- setdiff(names, old_names)
[17:42:48.648]                 removed <- setdiff(old_names, names)
[17:42:48.648]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.648]                   envs[common]]
[17:42:48.648]                 NAMES <- toupper(changed)
[17:42:48.648]                 args <- list()
[17:42:48.648]                 for (kk in seq_along(NAMES)) {
[17:42:48.648]                   name <- changed[[kk]]
[17:42:48.648]                   NAME <- NAMES[[kk]]
[17:42:48.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.648]                     next
[17:42:48.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.648]                 }
[17:42:48.648]                 NAMES <- toupper(added)
[17:42:48.648]                 for (kk in seq_along(NAMES)) {
[17:42:48.648]                   name <- added[[kk]]
[17:42:48.648]                   NAME <- NAMES[[kk]]
[17:42:48.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.648]                     next
[17:42:48.648]                   args[[name]] <- ""
[17:42:48.648]                 }
[17:42:48.648]                 NAMES <- toupper(removed)
[17:42:48.648]                 for (kk in seq_along(NAMES)) {
[17:42:48.648]                   name <- removed[[kk]]
[17:42:48.648]                   NAME <- NAMES[[kk]]
[17:42:48.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.648]                     next
[17:42:48.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.648]                 }
[17:42:48.648]                 if (length(args) > 0) 
[17:42:48.648]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.648]             }
[17:42:48.648]             else {
[17:42:48.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.648]             }
[17:42:48.648]             {
[17:42:48.648]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.648]                   0L) {
[17:42:48.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.648]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.648]                   base::options(opts)
[17:42:48.648]                 }
[17:42:48.648]                 {
[17:42:48.648]                   {
[17:42:48.648]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.648]                     NULL
[17:42:48.648]                   }
[17:42:48.648]                   options(future.plan = NULL)
[17:42:48.648]                   if (is.na(NA_character_)) 
[17:42:48.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.648]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.648]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.648]                     envir = parent.frame()) 
[17:42:48.648]                   {
[17:42:48.648]                     if (is.function(workers)) 
[17:42:48.648]                       workers <- workers()
[17:42:48.648]                     workers <- structure(as.integer(workers), 
[17:42:48.648]                       class = class(workers))
[17:42:48.648]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.648]                       workers >= 1)
[17:42:48.648]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.648]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.648]                     }
[17:42:48.648]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.648]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.648]                       envir = envir)
[17:42:48.648]                     if (!future$lazy) 
[17:42:48.648]                       future <- run(future)
[17:42:48.648]                     invisible(future)
[17:42:48.648]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.648]                 }
[17:42:48.648]             }
[17:42:48.648]         }
[17:42:48.648]     })
[17:42:48.648]     if (TRUE) {
[17:42:48.648]         base::sink(type = "output", split = FALSE)
[17:42:48.648]         if (TRUE) {
[17:42:48.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.648]         }
[17:42:48.648]         else {
[17:42:48.648]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.648]         }
[17:42:48.648]         base::close(...future.stdout)
[17:42:48.648]         ...future.stdout <- NULL
[17:42:48.648]     }
[17:42:48.648]     ...future.result$conditions <- ...future.conditions
[17:42:48.648]     ...future.result$finished <- base::Sys.time()
[17:42:48.648]     ...future.result
[17:42:48.648] }
[17:42:48.651] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[17:42:48.651] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[17:42:48.651] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.651] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[17:42:48.652] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[17:42:48.652] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[17:42:48.652] MultisessionFuture started
[17:42:48.652] - Launch lazy future ... done
[17:42:48.652] run() for ‘MultisessionFuture’ ... done
[17:42:48.653] result() for ClusterFuture ...
[17:42:48.653] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.653] - Validating connection of MultisessionFuture
[17:42:48.700] - received message: FutureResult
[17:42:48.700] - Received FutureResult
[17:42:48.700] - Erased future from FutureRegistry
[17:42:48.700] result() for ClusterFuture ...
[17:42:48.701] - result already collected: FutureResult
[17:42:48.701] result() for ClusterFuture ... done
[17:42:48.701] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.701] result() for ClusterFuture ... done
[17:42:48.701] result() for ClusterFuture ...
[17:42:48.701] - result already collected: FutureResult
[17:42:48.701] result() for ClusterFuture ... done
[1] 1 2 3
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.702] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.702] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.702] 
[17:42:48.702] Searching for globals ... DONE
[17:42:48.702] - globals: [0] <none>
[17:42:48.702] getGlobalsAndPackages() ... DONE
[17:42:48.703] run() for ‘Future’ ...
[17:42:48.703] - state: ‘created’
[17:42:48.703] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.718]   - Field: ‘node’
[17:42:48.718]   - Field: ‘label’
[17:42:48.718]   - Field: ‘local’
[17:42:48.718]   - Field: ‘owner’
[17:42:48.718]   - Field: ‘envir’
[17:42:48.718]   - Field: ‘workers’
[17:42:48.719]   - Field: ‘packages’
[17:42:48.719]   - Field: ‘gc’
[17:42:48.719]   - Field: ‘conditions’
[17:42:48.719]   - Field: ‘persistent’
[17:42:48.719]   - Field: ‘expr’
[17:42:48.719]   - Field: ‘uuid’
[17:42:48.719]   - Field: ‘seed’
[17:42:48.719]   - Field: ‘version’
[17:42:48.719]   - Field: ‘result’
[17:42:48.719]   - Field: ‘asynchronous’
[17:42:48.719]   - Field: ‘calls’
[17:42:48.720]   - Field: ‘globals’
[17:42:48.720]   - Field: ‘stdout’
[17:42:48.720]   - Field: ‘earlySignal’
[17:42:48.720]   - Field: ‘lazy’
[17:42:48.720]   - Field: ‘state’
[17:42:48.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.720] - Launch lazy future ...
[17:42:48.720] Packages needed by the future expression (n = 0): <none>
[17:42:48.721] Packages needed by future strategies (n = 0): <none>
[17:42:48.721] {
[17:42:48.721]     {
[17:42:48.721]         {
[17:42:48.721]             ...future.startTime <- base::Sys.time()
[17:42:48.721]             {
[17:42:48.721]                 {
[17:42:48.721]                   {
[17:42:48.721]                     {
[17:42:48.721]                       base::local({
[17:42:48.721]                         has_future <- base::requireNamespace("future", 
[17:42:48.721]                           quietly = TRUE)
[17:42:48.721]                         if (has_future) {
[17:42:48.721]                           ns <- base::getNamespace("future")
[17:42:48.721]                           version <- ns[[".package"]][["version"]]
[17:42:48.721]                           if (is.null(version)) 
[17:42:48.721]                             version <- utils::packageVersion("future")
[17:42:48.721]                         }
[17:42:48.721]                         else {
[17:42:48.721]                           version <- NULL
[17:42:48.721]                         }
[17:42:48.721]                         if (!has_future || version < "1.8.0") {
[17:42:48.721]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.721]                             "", base::R.version$version.string), 
[17:42:48.721]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.721]                               "release", "version")], collapse = " "), 
[17:42:48.721]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.721]                             info)
[17:42:48.721]                           info <- base::paste(info, collapse = "; ")
[17:42:48.721]                           if (!has_future) {
[17:42:48.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.721]                               info)
[17:42:48.721]                           }
[17:42:48.721]                           else {
[17:42:48.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.721]                               info, version)
[17:42:48.721]                           }
[17:42:48.721]                           base::stop(msg)
[17:42:48.721]                         }
[17:42:48.721]                       })
[17:42:48.721]                     }
[17:42:48.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.721]                     base::options(mc.cores = 1L)
[17:42:48.721]                   }
[17:42:48.721]                   options(future.plan = NULL)
[17:42:48.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.721]                 }
[17:42:48.721]                 ...future.workdir <- getwd()
[17:42:48.721]             }
[17:42:48.721]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.721]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.721]         }
[17:42:48.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.721]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.721]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.721]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.721]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.721]             base::names(...future.oldOptions))
[17:42:48.721]     }
[17:42:48.721]     if (FALSE) {
[17:42:48.721]     }
[17:42:48.721]     else {
[17:42:48.721]         if (TRUE) {
[17:42:48.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.721]                 open = "w")
[17:42:48.721]         }
[17:42:48.721]         else {
[17:42:48.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.721]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.721]         }
[17:42:48.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.721]             base::sink(type = "output", split = FALSE)
[17:42:48.721]             base::close(...future.stdout)
[17:42:48.721]         }, add = TRUE)
[17:42:48.721]     }
[17:42:48.721]     ...future.frame <- base::sys.nframe()
[17:42:48.721]     ...future.conditions <- base::list()
[17:42:48.721]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.721]     if (FALSE) {
[17:42:48.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.721]     }
[17:42:48.721]     ...future.result <- base::tryCatch({
[17:42:48.721]         base::withCallingHandlers({
[17:42:48.721]             ...future.value <- base::withVisible(base::local({
[17:42:48.721]                 ...future.makeSendCondition <- local({
[17:42:48.721]                   sendCondition <- NULL
[17:42:48.721]                   function(frame = 1L) {
[17:42:48.721]                     if (is.function(sendCondition)) 
[17:42:48.721]                       return(sendCondition)
[17:42:48.721]                     ns <- getNamespace("parallel")
[17:42:48.721]                     if (exists("sendData", mode = "function", 
[17:42:48.721]                       envir = ns)) {
[17:42:48.721]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.721]                         envir = ns)
[17:42:48.721]                       envir <- sys.frame(frame)
[17:42:48.721]                       master <- NULL
[17:42:48.721]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.721]                         !identical(envir, emptyenv())) {
[17:42:48.721]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.721]                           inherits = FALSE)) {
[17:42:48.721]                           master <- get("master", mode = "list", 
[17:42:48.721]                             envir = envir, inherits = FALSE)
[17:42:48.721]                           if (inherits(master, c("SOCKnode", 
[17:42:48.721]                             "SOCK0node"))) {
[17:42:48.721]                             sendCondition <<- function(cond) {
[17:42:48.721]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.721]                                 success = TRUE)
[17:42:48.721]                               parallel_sendData(master, data)
[17:42:48.721]                             }
[17:42:48.721]                             return(sendCondition)
[17:42:48.721]                           }
[17:42:48.721]                         }
[17:42:48.721]                         frame <- frame + 1L
[17:42:48.721]                         envir <- sys.frame(frame)
[17:42:48.721]                       }
[17:42:48.721]                     }
[17:42:48.721]                     sendCondition <<- function(cond) NULL
[17:42:48.721]                   }
[17:42:48.721]                 })
[17:42:48.721]                 withCallingHandlers({
[17:42:48.721]                   1
[17:42:48.721]                 }, immediateCondition = function(cond) {
[17:42:48.721]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.721]                   sendCondition(cond)
[17:42:48.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.721]                   {
[17:42:48.721]                     inherits <- base::inherits
[17:42:48.721]                     invokeRestart <- base::invokeRestart
[17:42:48.721]                     is.null <- base::is.null
[17:42:48.721]                     muffled <- FALSE
[17:42:48.721]                     if (inherits(cond, "message")) {
[17:42:48.721]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.721]                       if (muffled) 
[17:42:48.721]                         invokeRestart("muffleMessage")
[17:42:48.721]                     }
[17:42:48.721]                     else if (inherits(cond, "warning")) {
[17:42:48.721]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.721]                       if (muffled) 
[17:42:48.721]                         invokeRestart("muffleWarning")
[17:42:48.721]                     }
[17:42:48.721]                     else if (inherits(cond, "condition")) {
[17:42:48.721]                       if (!is.null(pattern)) {
[17:42:48.721]                         computeRestarts <- base::computeRestarts
[17:42:48.721]                         grepl <- base::grepl
[17:42:48.721]                         restarts <- computeRestarts(cond)
[17:42:48.721]                         for (restart in restarts) {
[17:42:48.721]                           name <- restart$name
[17:42:48.721]                           if (is.null(name)) 
[17:42:48.721]                             next
[17:42:48.721]                           if (!grepl(pattern, name)) 
[17:42:48.721]                             next
[17:42:48.721]                           invokeRestart(restart)
[17:42:48.721]                           muffled <- TRUE
[17:42:48.721]                           break
[17:42:48.721]                         }
[17:42:48.721]                       }
[17:42:48.721]                     }
[17:42:48.721]                     invisible(muffled)
[17:42:48.721]                   }
[17:42:48.721]                   muffleCondition(cond)
[17:42:48.721]                 })
[17:42:48.721]             }))
[17:42:48.721]             future::FutureResult(value = ...future.value$value, 
[17:42:48.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.721]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.721]                     ...future.globalenv.names))
[17:42:48.721]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.721]         }, condition = base::local({
[17:42:48.721]             c <- base::c
[17:42:48.721]             inherits <- base::inherits
[17:42:48.721]             invokeRestart <- base::invokeRestart
[17:42:48.721]             length <- base::length
[17:42:48.721]             list <- base::list
[17:42:48.721]             seq.int <- base::seq.int
[17:42:48.721]             signalCondition <- base::signalCondition
[17:42:48.721]             sys.calls <- base::sys.calls
[17:42:48.721]             `[[` <- base::`[[`
[17:42:48.721]             `+` <- base::`+`
[17:42:48.721]             `<<-` <- base::`<<-`
[17:42:48.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.721]                   3L)]
[17:42:48.721]             }
[17:42:48.721]             function(cond) {
[17:42:48.721]                 is_error <- inherits(cond, "error")
[17:42:48.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.721]                   NULL)
[17:42:48.721]                 if (is_error) {
[17:42:48.721]                   sessionInformation <- function() {
[17:42:48.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.721]                       search = base::search(), system = base::Sys.info())
[17:42:48.721]                   }
[17:42:48.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.721]                     cond$call), session = sessionInformation(), 
[17:42:48.721]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.721]                   signalCondition(cond)
[17:42:48.721]                 }
[17:42:48.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.721]                 "immediateCondition"))) {
[17:42:48.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.721]                   if (TRUE && !signal) {
[17:42:48.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.721]                     {
[17:42:48.721]                       inherits <- base::inherits
[17:42:48.721]                       invokeRestart <- base::invokeRestart
[17:42:48.721]                       is.null <- base::is.null
[17:42:48.721]                       muffled <- FALSE
[17:42:48.721]                       if (inherits(cond, "message")) {
[17:42:48.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.721]                         if (muffled) 
[17:42:48.721]                           invokeRestart("muffleMessage")
[17:42:48.721]                       }
[17:42:48.721]                       else if (inherits(cond, "warning")) {
[17:42:48.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.721]                         if (muffled) 
[17:42:48.721]                           invokeRestart("muffleWarning")
[17:42:48.721]                       }
[17:42:48.721]                       else if (inherits(cond, "condition")) {
[17:42:48.721]                         if (!is.null(pattern)) {
[17:42:48.721]                           computeRestarts <- base::computeRestarts
[17:42:48.721]                           grepl <- base::grepl
[17:42:48.721]                           restarts <- computeRestarts(cond)
[17:42:48.721]                           for (restart in restarts) {
[17:42:48.721]                             name <- restart$name
[17:42:48.721]                             if (is.null(name)) 
[17:42:48.721]                               next
[17:42:48.721]                             if (!grepl(pattern, name)) 
[17:42:48.721]                               next
[17:42:48.721]                             invokeRestart(restart)
[17:42:48.721]                             muffled <- TRUE
[17:42:48.721]                             break
[17:42:48.721]                           }
[17:42:48.721]                         }
[17:42:48.721]                       }
[17:42:48.721]                       invisible(muffled)
[17:42:48.721]                     }
[17:42:48.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.721]                   }
[17:42:48.721]                 }
[17:42:48.721]                 else {
[17:42:48.721]                   if (TRUE) {
[17:42:48.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.721]                     {
[17:42:48.721]                       inherits <- base::inherits
[17:42:48.721]                       invokeRestart <- base::invokeRestart
[17:42:48.721]                       is.null <- base::is.null
[17:42:48.721]                       muffled <- FALSE
[17:42:48.721]                       if (inherits(cond, "message")) {
[17:42:48.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.721]                         if (muffled) 
[17:42:48.721]                           invokeRestart("muffleMessage")
[17:42:48.721]                       }
[17:42:48.721]                       else if (inherits(cond, "warning")) {
[17:42:48.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.721]                         if (muffled) 
[17:42:48.721]                           invokeRestart("muffleWarning")
[17:42:48.721]                       }
[17:42:48.721]                       else if (inherits(cond, "condition")) {
[17:42:48.721]                         if (!is.null(pattern)) {
[17:42:48.721]                           computeRestarts <- base::computeRestarts
[17:42:48.721]                           grepl <- base::grepl
[17:42:48.721]                           restarts <- computeRestarts(cond)
[17:42:48.721]                           for (restart in restarts) {
[17:42:48.721]                             name <- restart$name
[17:42:48.721]                             if (is.null(name)) 
[17:42:48.721]                               next
[17:42:48.721]                             if (!grepl(pattern, name)) 
[17:42:48.721]                               next
[17:42:48.721]                             invokeRestart(restart)
[17:42:48.721]                             muffled <- TRUE
[17:42:48.721]                             break
[17:42:48.721]                           }
[17:42:48.721]                         }
[17:42:48.721]                       }
[17:42:48.721]                       invisible(muffled)
[17:42:48.721]                     }
[17:42:48.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.721]                   }
[17:42:48.721]                 }
[17:42:48.721]             }
[17:42:48.721]         }))
[17:42:48.721]     }, error = function(ex) {
[17:42:48.721]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.721]                 ...future.rng), started = ...future.startTime, 
[17:42:48.721]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.721]             version = "1.8"), class = "FutureResult")
[17:42:48.721]     }, finally = {
[17:42:48.721]         if (!identical(...future.workdir, getwd())) 
[17:42:48.721]             setwd(...future.workdir)
[17:42:48.721]         {
[17:42:48.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.721]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.721]             }
[17:42:48.721]             base::options(...future.oldOptions)
[17:42:48.721]             if (.Platform$OS.type == "windows") {
[17:42:48.721]                 old_names <- names(...future.oldEnvVars)
[17:42:48.721]                 envs <- base::Sys.getenv()
[17:42:48.721]                 names <- names(envs)
[17:42:48.721]                 common <- intersect(names, old_names)
[17:42:48.721]                 added <- setdiff(names, old_names)
[17:42:48.721]                 removed <- setdiff(old_names, names)
[17:42:48.721]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.721]                   envs[common]]
[17:42:48.721]                 NAMES <- toupper(changed)
[17:42:48.721]                 args <- list()
[17:42:48.721]                 for (kk in seq_along(NAMES)) {
[17:42:48.721]                   name <- changed[[kk]]
[17:42:48.721]                   NAME <- NAMES[[kk]]
[17:42:48.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.721]                     next
[17:42:48.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.721]                 }
[17:42:48.721]                 NAMES <- toupper(added)
[17:42:48.721]                 for (kk in seq_along(NAMES)) {
[17:42:48.721]                   name <- added[[kk]]
[17:42:48.721]                   NAME <- NAMES[[kk]]
[17:42:48.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.721]                     next
[17:42:48.721]                   args[[name]] <- ""
[17:42:48.721]                 }
[17:42:48.721]                 NAMES <- toupper(removed)
[17:42:48.721]                 for (kk in seq_along(NAMES)) {
[17:42:48.721]                   name <- removed[[kk]]
[17:42:48.721]                   NAME <- NAMES[[kk]]
[17:42:48.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.721]                     next
[17:42:48.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.721]                 }
[17:42:48.721]                 if (length(args) > 0) 
[17:42:48.721]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.721]             }
[17:42:48.721]             else {
[17:42:48.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.721]             }
[17:42:48.721]             {
[17:42:48.721]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.721]                   0L) {
[17:42:48.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.721]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.721]                   base::options(opts)
[17:42:48.721]                 }
[17:42:48.721]                 {
[17:42:48.721]                   {
[17:42:48.721]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.721]                     NULL
[17:42:48.721]                   }
[17:42:48.721]                   options(future.plan = NULL)
[17:42:48.721]                   if (is.na(NA_character_)) 
[17:42:48.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.721]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.721]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.721]                     envir = parent.frame()) 
[17:42:48.721]                   {
[17:42:48.721]                     if (is.function(workers)) 
[17:42:48.721]                       workers <- workers()
[17:42:48.721]                     workers <- structure(as.integer(workers), 
[17:42:48.721]                       class = class(workers))
[17:42:48.721]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.721]                       workers >= 1)
[17:42:48.721]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.721]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.721]                     }
[17:42:48.721]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.721]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.721]                       envir = envir)
[17:42:48.721]                     if (!future$lazy) 
[17:42:48.721]                       future <- run(future)
[17:42:48.721]                     invisible(future)
[17:42:48.721]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.721]                 }
[17:42:48.721]             }
[17:42:48.721]         }
[17:42:48.721]     })
[17:42:48.721]     if (TRUE) {
[17:42:48.721]         base::sink(type = "output", split = FALSE)
[17:42:48.721]         if (TRUE) {
[17:42:48.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.721]         }
[17:42:48.721]         else {
[17:42:48.721]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.721]         }
[17:42:48.721]         base::close(...future.stdout)
[17:42:48.721]         ...future.stdout <- NULL
[17:42:48.721]     }
[17:42:48.721]     ...future.result$conditions <- ...future.conditions
[17:42:48.721]     ...future.result$finished <- base::Sys.time()
[17:42:48.721]     ...future.result
[17:42:48.721] }
[17:42:48.724] MultisessionFuture started
[17:42:48.724] - Launch lazy future ... done
[17:42:48.724] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.725] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.725] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.725] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:48.726] Searching for globals ... DONE
[17:42:48.726] Resolving globals: TRUE
[17:42:48.726] Resolving any globals that are futures ...
[17:42:48.726] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:48.726] Resolving any globals that are futures ... DONE
[17:42:48.726] Resolving futures part of globals (recursively) ...
[17:42:48.727] resolve() on list ...
[17:42:48.727]  recursive: 99
[17:42:48.727]  length: 1
[17:42:48.727]  elements: ‘a’
[17:42:48.772] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.772] - Validating connection of MultisessionFuture
[17:42:48.773] - received message: FutureResult
[17:42:48.773] - Received FutureResult
[17:42:48.773] - Erased future from FutureRegistry
[17:42:48.773] result() for ClusterFuture ...
[17:42:48.773] - result already collected: FutureResult
[17:42:48.773] result() for ClusterFuture ... done
[17:42:48.773] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.774] Future #1
[17:42:48.774] result() for ClusterFuture ...
[17:42:48.774] - result already collected: FutureResult
[17:42:48.774] result() for ClusterFuture ... done
[17:42:48.774] result() for ClusterFuture ...
[17:42:48.774] - result already collected: FutureResult
[17:42:48.774] result() for ClusterFuture ... done
[17:42:48.774] A MultisessionFuture was resolved
[17:42:48.774]  length: 0 (resolved future 1)
[17:42:48.774] resolve() on list ... DONE
[17:42:48.775] - globals: [1] ‘a’
[17:42:48.775] Resolving futures part of globals (recursively) ... DONE
[17:42:48.777] The total size of the 1 globals is 1.55 MiB (1629176 bytes)
[17:42:48.777] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:48.777] - globals: [1] ‘a’
[17:42:48.777] - packages: [1] ‘future’
[17:42:48.778] getGlobalsAndPackages() ... DONE
[17:42:48.778] run() for ‘Future’ ...
[17:42:48.778] - state: ‘created’
[17:42:48.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.792] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.792]   - Field: ‘node’
[17:42:48.793]   - Field: ‘label’
[17:42:48.793]   - Field: ‘local’
[17:42:48.793]   - Field: ‘owner’
[17:42:48.793]   - Field: ‘envir’
[17:42:48.793]   - Field: ‘workers’
[17:42:48.793]   - Field: ‘packages’
[17:42:48.793]   - Field: ‘gc’
[17:42:48.793]   - Field: ‘conditions’
[17:42:48.793]   - Field: ‘persistent’
[17:42:48.793]   - Field: ‘expr’
[17:42:48.793]   - Field: ‘uuid’
[17:42:48.794]   - Field: ‘seed’
[17:42:48.794]   - Field: ‘version’
[17:42:48.794]   - Field: ‘result’
[17:42:48.794]   - Field: ‘asynchronous’
[17:42:48.794]   - Field: ‘calls’
[17:42:48.794]   - Field: ‘globals’
[17:42:48.794]   - Field: ‘stdout’
[17:42:48.794]   - Field: ‘earlySignal’
[17:42:48.794]   - Field: ‘lazy’
[17:42:48.794]   - Field: ‘state’
[17:42:48.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.795] - Launch lazy future ...
[17:42:48.795] Packages needed by the future expression (n = 1): ‘future’
[17:42:48.795] Packages needed by future strategies (n = 0): <none>
[17:42:48.795] {
[17:42:48.795]     {
[17:42:48.795]         {
[17:42:48.795]             ...future.startTime <- base::Sys.time()
[17:42:48.795]             {
[17:42:48.795]                 {
[17:42:48.795]                   {
[17:42:48.795]                     {
[17:42:48.795]                       {
[17:42:48.795]                         base::local({
[17:42:48.795]                           has_future <- base::requireNamespace("future", 
[17:42:48.795]                             quietly = TRUE)
[17:42:48.795]                           if (has_future) {
[17:42:48.795]                             ns <- base::getNamespace("future")
[17:42:48.795]                             version <- ns[[".package"]][["version"]]
[17:42:48.795]                             if (is.null(version)) 
[17:42:48.795]                               version <- utils::packageVersion("future")
[17:42:48.795]                           }
[17:42:48.795]                           else {
[17:42:48.795]                             version <- NULL
[17:42:48.795]                           }
[17:42:48.795]                           if (!has_future || version < "1.8.0") {
[17:42:48.795]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.795]                               "", base::R.version$version.string), 
[17:42:48.795]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:48.795]                                 base::R.version$platform, 8 * 
[17:42:48.795]                                   base::.Machine$sizeof.pointer), 
[17:42:48.795]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.795]                                 "release", "version")], collapse = " "), 
[17:42:48.795]                               hostname = base::Sys.info()[["nodename"]])
[17:42:48.795]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.795]                               info)
[17:42:48.795]                             info <- base::paste(info, collapse = "; ")
[17:42:48.795]                             if (!has_future) {
[17:42:48.795]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.795]                                 info)
[17:42:48.795]                             }
[17:42:48.795]                             else {
[17:42:48.795]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.795]                                 info, version)
[17:42:48.795]                             }
[17:42:48.795]                             base::stop(msg)
[17:42:48.795]                           }
[17:42:48.795]                         })
[17:42:48.795]                       }
[17:42:48.795]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.795]                       base::options(mc.cores = 1L)
[17:42:48.795]                     }
[17:42:48.795]                     base::local({
[17:42:48.795]                       for (pkg in "future") {
[17:42:48.795]                         base::loadNamespace(pkg)
[17:42:48.795]                         base::library(pkg, character.only = TRUE)
[17:42:48.795]                       }
[17:42:48.795]                     })
[17:42:48.795]                   }
[17:42:48.795]                   options(future.plan = NULL)
[17:42:48.795]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.795]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.795]                 }
[17:42:48.795]                 ...future.workdir <- getwd()
[17:42:48.795]             }
[17:42:48.795]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.795]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.795]         }
[17:42:48.795]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.795]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.795]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.795]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.795]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.795]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.795]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.795]             base::names(...future.oldOptions))
[17:42:48.795]     }
[17:42:48.795]     if (FALSE) {
[17:42:48.795]     }
[17:42:48.795]     else {
[17:42:48.795]         if (TRUE) {
[17:42:48.795]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.795]                 open = "w")
[17:42:48.795]         }
[17:42:48.795]         else {
[17:42:48.795]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.795]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.795]         }
[17:42:48.795]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.795]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.795]             base::sink(type = "output", split = FALSE)
[17:42:48.795]             base::close(...future.stdout)
[17:42:48.795]         }, add = TRUE)
[17:42:48.795]     }
[17:42:48.795]     ...future.frame <- base::sys.nframe()
[17:42:48.795]     ...future.conditions <- base::list()
[17:42:48.795]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.795]     if (FALSE) {
[17:42:48.795]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.795]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.795]     }
[17:42:48.795]     ...future.result <- base::tryCatch({
[17:42:48.795]         base::withCallingHandlers({
[17:42:48.795]             ...future.value <- base::withVisible(base::local({
[17:42:48.795]                 ...future.makeSendCondition <- local({
[17:42:48.795]                   sendCondition <- NULL
[17:42:48.795]                   function(frame = 1L) {
[17:42:48.795]                     if (is.function(sendCondition)) 
[17:42:48.795]                       return(sendCondition)
[17:42:48.795]                     ns <- getNamespace("parallel")
[17:42:48.795]                     if (exists("sendData", mode = "function", 
[17:42:48.795]                       envir = ns)) {
[17:42:48.795]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.795]                         envir = ns)
[17:42:48.795]                       envir <- sys.frame(frame)
[17:42:48.795]                       master <- NULL
[17:42:48.795]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.795]                         !identical(envir, emptyenv())) {
[17:42:48.795]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.795]                           inherits = FALSE)) {
[17:42:48.795]                           master <- get("master", mode = "list", 
[17:42:48.795]                             envir = envir, inherits = FALSE)
[17:42:48.795]                           if (inherits(master, c("SOCKnode", 
[17:42:48.795]                             "SOCK0node"))) {
[17:42:48.795]                             sendCondition <<- function(cond) {
[17:42:48.795]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.795]                                 success = TRUE)
[17:42:48.795]                               parallel_sendData(master, data)
[17:42:48.795]                             }
[17:42:48.795]                             return(sendCondition)
[17:42:48.795]                           }
[17:42:48.795]                         }
[17:42:48.795]                         frame <- frame + 1L
[17:42:48.795]                         envir <- sys.frame(frame)
[17:42:48.795]                       }
[17:42:48.795]                     }
[17:42:48.795]                     sendCondition <<- function(cond) NULL
[17:42:48.795]                   }
[17:42:48.795]                 })
[17:42:48.795]                 withCallingHandlers({
[17:42:48.795]                   value(a) + 1
[17:42:48.795]                 }, immediateCondition = function(cond) {
[17:42:48.795]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.795]                   sendCondition(cond)
[17:42:48.795]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.795]                   {
[17:42:48.795]                     inherits <- base::inherits
[17:42:48.795]                     invokeRestart <- base::invokeRestart
[17:42:48.795]                     is.null <- base::is.null
[17:42:48.795]                     muffled <- FALSE
[17:42:48.795]                     if (inherits(cond, "message")) {
[17:42:48.795]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.795]                       if (muffled) 
[17:42:48.795]                         invokeRestart("muffleMessage")
[17:42:48.795]                     }
[17:42:48.795]                     else if (inherits(cond, "warning")) {
[17:42:48.795]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.795]                       if (muffled) 
[17:42:48.795]                         invokeRestart("muffleWarning")
[17:42:48.795]                     }
[17:42:48.795]                     else if (inherits(cond, "condition")) {
[17:42:48.795]                       if (!is.null(pattern)) {
[17:42:48.795]                         computeRestarts <- base::computeRestarts
[17:42:48.795]                         grepl <- base::grepl
[17:42:48.795]                         restarts <- computeRestarts(cond)
[17:42:48.795]                         for (restart in restarts) {
[17:42:48.795]                           name <- restart$name
[17:42:48.795]                           if (is.null(name)) 
[17:42:48.795]                             next
[17:42:48.795]                           if (!grepl(pattern, name)) 
[17:42:48.795]                             next
[17:42:48.795]                           invokeRestart(restart)
[17:42:48.795]                           muffled <- TRUE
[17:42:48.795]                           break
[17:42:48.795]                         }
[17:42:48.795]                       }
[17:42:48.795]                     }
[17:42:48.795]                     invisible(muffled)
[17:42:48.795]                   }
[17:42:48.795]                   muffleCondition(cond)
[17:42:48.795]                 })
[17:42:48.795]             }))
[17:42:48.795]             future::FutureResult(value = ...future.value$value, 
[17:42:48.795]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.795]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.795]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.795]                     ...future.globalenv.names))
[17:42:48.795]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.795]         }, condition = base::local({
[17:42:48.795]             c <- base::c
[17:42:48.795]             inherits <- base::inherits
[17:42:48.795]             invokeRestart <- base::invokeRestart
[17:42:48.795]             length <- base::length
[17:42:48.795]             list <- base::list
[17:42:48.795]             seq.int <- base::seq.int
[17:42:48.795]             signalCondition <- base::signalCondition
[17:42:48.795]             sys.calls <- base::sys.calls
[17:42:48.795]             `[[` <- base::`[[`
[17:42:48.795]             `+` <- base::`+`
[17:42:48.795]             `<<-` <- base::`<<-`
[17:42:48.795]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.795]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.795]                   3L)]
[17:42:48.795]             }
[17:42:48.795]             function(cond) {
[17:42:48.795]                 is_error <- inherits(cond, "error")
[17:42:48.795]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.795]                   NULL)
[17:42:48.795]                 if (is_error) {
[17:42:48.795]                   sessionInformation <- function() {
[17:42:48.795]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.795]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.795]                       search = base::search(), system = base::Sys.info())
[17:42:48.795]                   }
[17:42:48.795]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.795]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.795]                     cond$call), session = sessionInformation(), 
[17:42:48.795]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.795]                   signalCondition(cond)
[17:42:48.795]                 }
[17:42:48.795]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.795]                 "immediateCondition"))) {
[17:42:48.795]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.795]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.795]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.795]                   if (TRUE && !signal) {
[17:42:48.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.795]                     {
[17:42:48.795]                       inherits <- base::inherits
[17:42:48.795]                       invokeRestart <- base::invokeRestart
[17:42:48.795]                       is.null <- base::is.null
[17:42:48.795]                       muffled <- FALSE
[17:42:48.795]                       if (inherits(cond, "message")) {
[17:42:48.795]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.795]                         if (muffled) 
[17:42:48.795]                           invokeRestart("muffleMessage")
[17:42:48.795]                       }
[17:42:48.795]                       else if (inherits(cond, "warning")) {
[17:42:48.795]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.795]                         if (muffled) 
[17:42:48.795]                           invokeRestart("muffleWarning")
[17:42:48.795]                       }
[17:42:48.795]                       else if (inherits(cond, "condition")) {
[17:42:48.795]                         if (!is.null(pattern)) {
[17:42:48.795]                           computeRestarts <- base::computeRestarts
[17:42:48.795]                           grepl <- base::grepl
[17:42:48.795]                           restarts <- computeRestarts(cond)
[17:42:48.795]                           for (restart in restarts) {
[17:42:48.795]                             name <- restart$name
[17:42:48.795]                             if (is.null(name)) 
[17:42:48.795]                               next
[17:42:48.795]                             if (!grepl(pattern, name)) 
[17:42:48.795]                               next
[17:42:48.795]                             invokeRestart(restart)
[17:42:48.795]                             muffled <- TRUE
[17:42:48.795]                             break
[17:42:48.795]                           }
[17:42:48.795]                         }
[17:42:48.795]                       }
[17:42:48.795]                       invisible(muffled)
[17:42:48.795]                     }
[17:42:48.795]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.795]                   }
[17:42:48.795]                 }
[17:42:48.795]                 else {
[17:42:48.795]                   if (TRUE) {
[17:42:48.795]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.795]                     {
[17:42:48.795]                       inherits <- base::inherits
[17:42:48.795]                       invokeRestart <- base::invokeRestart
[17:42:48.795]                       is.null <- base::is.null
[17:42:48.795]                       muffled <- FALSE
[17:42:48.795]                       if (inherits(cond, "message")) {
[17:42:48.795]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.795]                         if (muffled) 
[17:42:48.795]                           invokeRestart("muffleMessage")
[17:42:48.795]                       }
[17:42:48.795]                       else if (inherits(cond, "warning")) {
[17:42:48.795]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.795]                         if (muffled) 
[17:42:48.795]                           invokeRestart("muffleWarning")
[17:42:48.795]                       }
[17:42:48.795]                       else if (inherits(cond, "condition")) {
[17:42:48.795]                         if (!is.null(pattern)) {
[17:42:48.795]                           computeRestarts <- base::computeRestarts
[17:42:48.795]                           grepl <- base::grepl
[17:42:48.795]                           restarts <- computeRestarts(cond)
[17:42:48.795]                           for (restart in restarts) {
[17:42:48.795]                             name <- restart$name
[17:42:48.795]                             if (is.null(name)) 
[17:42:48.795]                               next
[17:42:48.795]                             if (!grepl(pattern, name)) 
[17:42:48.795]                               next
[17:42:48.795]                             invokeRestart(restart)
[17:42:48.795]                             muffled <- TRUE
[17:42:48.795]                             break
[17:42:48.795]                           }
[17:42:48.795]                         }
[17:42:48.795]                       }
[17:42:48.795]                       invisible(muffled)
[17:42:48.795]                     }
[17:42:48.795]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.795]                   }
[17:42:48.795]                 }
[17:42:48.795]             }
[17:42:48.795]         }))
[17:42:48.795]     }, error = function(ex) {
[17:42:48.795]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.795]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.795]                 ...future.rng), started = ...future.startTime, 
[17:42:48.795]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.795]             version = "1.8"), class = "FutureResult")
[17:42:48.795]     }, finally = {
[17:42:48.795]         if (!identical(...future.workdir, getwd())) 
[17:42:48.795]             setwd(...future.workdir)
[17:42:48.795]         {
[17:42:48.795]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.795]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.795]             }
[17:42:48.795]             base::options(...future.oldOptions)
[17:42:48.795]             if (.Platform$OS.type == "windows") {
[17:42:48.795]                 old_names <- names(...future.oldEnvVars)
[17:42:48.795]                 envs <- base::Sys.getenv()
[17:42:48.795]                 names <- names(envs)
[17:42:48.795]                 common <- intersect(names, old_names)
[17:42:48.795]                 added <- setdiff(names, old_names)
[17:42:48.795]                 removed <- setdiff(old_names, names)
[17:42:48.795]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.795]                   envs[common]]
[17:42:48.795]                 NAMES <- toupper(changed)
[17:42:48.795]                 args <- list()
[17:42:48.795]                 for (kk in seq_along(NAMES)) {
[17:42:48.795]                   name <- changed[[kk]]
[17:42:48.795]                   NAME <- NAMES[[kk]]
[17:42:48.795]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.795]                     next
[17:42:48.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.795]                 }
[17:42:48.795]                 NAMES <- toupper(added)
[17:42:48.795]                 for (kk in seq_along(NAMES)) {
[17:42:48.795]                   name <- added[[kk]]
[17:42:48.795]                   NAME <- NAMES[[kk]]
[17:42:48.795]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.795]                     next
[17:42:48.795]                   args[[name]] <- ""
[17:42:48.795]                 }
[17:42:48.795]                 NAMES <- toupper(removed)
[17:42:48.795]                 for (kk in seq_along(NAMES)) {
[17:42:48.795]                   name <- removed[[kk]]
[17:42:48.795]                   NAME <- NAMES[[kk]]
[17:42:48.795]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.795]                     next
[17:42:48.795]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.795]                 }
[17:42:48.795]                 if (length(args) > 0) 
[17:42:48.795]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.795]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.795]             }
[17:42:48.795]             else {
[17:42:48.795]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.795]             }
[17:42:48.795]             {
[17:42:48.795]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.795]                   0L) {
[17:42:48.795]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.795]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.795]                   base::options(opts)
[17:42:48.795]                 }
[17:42:48.795]                 {
[17:42:48.795]                   {
[17:42:48.795]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.795]                     NULL
[17:42:48.795]                   }
[17:42:48.795]                   options(future.plan = NULL)
[17:42:48.795]                   if (is.na(NA_character_)) 
[17:42:48.795]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.795]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.795]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.795]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.795]                     envir = parent.frame()) 
[17:42:48.795]                   {
[17:42:48.795]                     if (is.function(workers)) 
[17:42:48.795]                       workers <- workers()
[17:42:48.795]                     workers <- structure(as.integer(workers), 
[17:42:48.795]                       class = class(workers))
[17:42:48.795]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.795]                       workers >= 1)
[17:42:48.795]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.795]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.795]                     }
[17:42:48.795]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.795]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.795]                       envir = envir)
[17:42:48.795]                     if (!future$lazy) 
[17:42:48.795]                       future <- run(future)
[17:42:48.795]                     invisible(future)
[17:42:48.795]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.795]                 }
[17:42:48.795]             }
[17:42:48.795]         }
[17:42:48.795]     })
[17:42:48.795]     if (TRUE) {
[17:42:48.795]         base::sink(type = "output", split = FALSE)
[17:42:48.795]         if (TRUE) {
[17:42:48.795]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.795]         }
[17:42:48.795]         else {
[17:42:48.795]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.795]         }
[17:42:48.795]         base::close(...future.stdout)
[17:42:48.795]         ...future.stdout <- NULL
[17:42:48.795]     }
[17:42:48.795]     ...future.result$conditions <- ...future.conditions
[17:42:48.795]     ...future.result$finished <- base::Sys.time()
[17:42:48.795]     ...future.result
[17:42:48.795] }
[17:42:48.798] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[17:42:48.800] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[17:42:48.851] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[17:42:48.852] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[17:42:48.852] MultisessionFuture started
[17:42:48.852] - Launch lazy future ... done
[17:42:48.852] run() for ‘MultisessionFuture’ ... done
[17:42:48.853] result() for ClusterFuture ...
[17:42:48.853] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.853] - Validating connection of MultisessionFuture
[17:42:48.906] - received message: FutureResult
[17:42:48.906] - Received FutureResult
[17:42:48.906] - Erased future from FutureRegistry
[17:42:48.906] result() for ClusterFuture ...
[17:42:48.906] - result already collected: FutureResult
[17:42:48.907] result() for ClusterFuture ... done
[17:42:48.907] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.907] result() for ClusterFuture ... done
[17:42:48.907] result() for ClusterFuture ...
[17:42:48.907] - result already collected: FutureResult
[17:42:48.907] result() for ClusterFuture ... done
value(b) = 2
[17:42:48.907] result() for ClusterFuture ...
[17:42:48.907] - result already collected: FutureResult
[17:42:48.907] result() for ClusterFuture ... done
[17:42:48.908] result() for ClusterFuture ...
[17:42:48.908] - result already collected: FutureResult
[17:42:48.908] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.908] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.908] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.909] 
[17:42:48.909] Searching for globals ... DONE
[17:42:48.909] - globals: [0] <none>
[17:42:48.909] getGlobalsAndPackages() ... DONE
[17:42:48.909] run() for ‘Future’ ...
[17:42:48.909] - state: ‘created’
[17:42:48.909] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.924] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.924] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.924]   - Field: ‘node’
[17:42:48.924]   - Field: ‘label’
[17:42:48.924]   - Field: ‘local’
[17:42:48.925]   - Field: ‘owner’
[17:42:48.925]   - Field: ‘envir’
[17:42:48.925]   - Field: ‘workers’
[17:42:48.925]   - Field: ‘packages’
[17:42:48.925]   - Field: ‘gc’
[17:42:48.925]   - Field: ‘conditions’
[17:42:48.925]   - Field: ‘persistent’
[17:42:48.925]   - Field: ‘expr’
[17:42:48.925]   - Field: ‘uuid’
[17:42:48.925]   - Field: ‘seed’
[17:42:48.925]   - Field: ‘version’
[17:42:48.926]   - Field: ‘result’
[17:42:48.926]   - Field: ‘asynchronous’
[17:42:48.926]   - Field: ‘calls’
[17:42:48.926]   - Field: ‘globals’
[17:42:48.926]   - Field: ‘stdout’
[17:42:48.926]   - Field: ‘earlySignal’
[17:42:48.926]   - Field: ‘lazy’
[17:42:48.926]   - Field: ‘state’
[17:42:48.926] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:48.926] - Launch lazy future ...
[17:42:48.927] Packages needed by the future expression (n = 0): <none>
[17:42:48.927] Packages needed by future strategies (n = 0): <none>
[17:42:48.927] {
[17:42:48.927]     {
[17:42:48.927]         {
[17:42:48.927]             ...future.startTime <- base::Sys.time()
[17:42:48.927]             {
[17:42:48.927]                 {
[17:42:48.927]                   {
[17:42:48.927]                     {
[17:42:48.927]                       base::local({
[17:42:48.927]                         has_future <- base::requireNamespace("future", 
[17:42:48.927]                           quietly = TRUE)
[17:42:48.927]                         if (has_future) {
[17:42:48.927]                           ns <- base::getNamespace("future")
[17:42:48.927]                           version <- ns[[".package"]][["version"]]
[17:42:48.927]                           if (is.null(version)) 
[17:42:48.927]                             version <- utils::packageVersion("future")
[17:42:48.927]                         }
[17:42:48.927]                         else {
[17:42:48.927]                           version <- NULL
[17:42:48.927]                         }
[17:42:48.927]                         if (!has_future || version < "1.8.0") {
[17:42:48.927]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:48.927]                             "", base::R.version$version.string), 
[17:42:48.927]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:48.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:48.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:48.927]                               "release", "version")], collapse = " "), 
[17:42:48.927]                             hostname = base::Sys.info()[["nodename"]])
[17:42:48.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:48.927]                             info)
[17:42:48.927]                           info <- base::paste(info, collapse = "; ")
[17:42:48.927]                           if (!has_future) {
[17:42:48.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:48.927]                               info)
[17:42:48.927]                           }
[17:42:48.927]                           else {
[17:42:48.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:48.927]                               info, version)
[17:42:48.927]                           }
[17:42:48.927]                           base::stop(msg)
[17:42:48.927]                         }
[17:42:48.927]                       })
[17:42:48.927]                     }
[17:42:48.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:48.927]                     base::options(mc.cores = 1L)
[17:42:48.927]                   }
[17:42:48.927]                   options(future.plan = NULL)
[17:42:48.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:48.927]                 }
[17:42:48.927]                 ...future.workdir <- getwd()
[17:42:48.927]             }
[17:42:48.927]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:48.927]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:48.927]         }
[17:42:48.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:48.927]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:48.927]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:48.927]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:48.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:48.927]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:48.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:48.927]             base::names(...future.oldOptions))
[17:42:48.927]     }
[17:42:48.927]     if (FALSE) {
[17:42:48.927]     }
[17:42:48.927]     else {
[17:42:48.927]         if (TRUE) {
[17:42:48.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:48.927]                 open = "w")
[17:42:48.927]         }
[17:42:48.927]         else {
[17:42:48.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:48.927]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:48.927]         }
[17:42:48.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:48.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:48.927]             base::sink(type = "output", split = FALSE)
[17:42:48.927]             base::close(...future.stdout)
[17:42:48.927]         }, add = TRUE)
[17:42:48.927]     }
[17:42:48.927]     ...future.frame <- base::sys.nframe()
[17:42:48.927]     ...future.conditions <- base::list()
[17:42:48.927]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:48.927]     if (FALSE) {
[17:42:48.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:48.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:48.927]     }
[17:42:48.927]     ...future.result <- base::tryCatch({
[17:42:48.927]         base::withCallingHandlers({
[17:42:48.927]             ...future.value <- base::withVisible(base::local({
[17:42:48.927]                 ...future.makeSendCondition <- local({
[17:42:48.927]                   sendCondition <- NULL
[17:42:48.927]                   function(frame = 1L) {
[17:42:48.927]                     if (is.function(sendCondition)) 
[17:42:48.927]                       return(sendCondition)
[17:42:48.927]                     ns <- getNamespace("parallel")
[17:42:48.927]                     if (exists("sendData", mode = "function", 
[17:42:48.927]                       envir = ns)) {
[17:42:48.927]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:48.927]                         envir = ns)
[17:42:48.927]                       envir <- sys.frame(frame)
[17:42:48.927]                       master <- NULL
[17:42:48.927]                       while (!identical(envir, .GlobalEnv) && 
[17:42:48.927]                         !identical(envir, emptyenv())) {
[17:42:48.927]                         if (exists("master", mode = "list", envir = envir, 
[17:42:48.927]                           inherits = FALSE)) {
[17:42:48.927]                           master <- get("master", mode = "list", 
[17:42:48.927]                             envir = envir, inherits = FALSE)
[17:42:48.927]                           if (inherits(master, c("SOCKnode", 
[17:42:48.927]                             "SOCK0node"))) {
[17:42:48.927]                             sendCondition <<- function(cond) {
[17:42:48.927]                               data <- list(type = "VALUE", value = cond, 
[17:42:48.927]                                 success = TRUE)
[17:42:48.927]                               parallel_sendData(master, data)
[17:42:48.927]                             }
[17:42:48.927]                             return(sendCondition)
[17:42:48.927]                           }
[17:42:48.927]                         }
[17:42:48.927]                         frame <- frame + 1L
[17:42:48.927]                         envir <- sys.frame(frame)
[17:42:48.927]                       }
[17:42:48.927]                     }
[17:42:48.927]                     sendCondition <<- function(cond) NULL
[17:42:48.927]                   }
[17:42:48.927]                 })
[17:42:48.927]                 withCallingHandlers({
[17:42:48.927]                   1
[17:42:48.927]                 }, immediateCondition = function(cond) {
[17:42:48.927]                   sendCondition <- ...future.makeSendCondition()
[17:42:48.927]                   sendCondition(cond)
[17:42:48.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.927]                   {
[17:42:48.927]                     inherits <- base::inherits
[17:42:48.927]                     invokeRestart <- base::invokeRestart
[17:42:48.927]                     is.null <- base::is.null
[17:42:48.927]                     muffled <- FALSE
[17:42:48.927]                     if (inherits(cond, "message")) {
[17:42:48.927]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:48.927]                       if (muffled) 
[17:42:48.927]                         invokeRestart("muffleMessage")
[17:42:48.927]                     }
[17:42:48.927]                     else if (inherits(cond, "warning")) {
[17:42:48.927]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:48.927]                       if (muffled) 
[17:42:48.927]                         invokeRestart("muffleWarning")
[17:42:48.927]                     }
[17:42:48.927]                     else if (inherits(cond, "condition")) {
[17:42:48.927]                       if (!is.null(pattern)) {
[17:42:48.927]                         computeRestarts <- base::computeRestarts
[17:42:48.927]                         grepl <- base::grepl
[17:42:48.927]                         restarts <- computeRestarts(cond)
[17:42:48.927]                         for (restart in restarts) {
[17:42:48.927]                           name <- restart$name
[17:42:48.927]                           if (is.null(name)) 
[17:42:48.927]                             next
[17:42:48.927]                           if (!grepl(pattern, name)) 
[17:42:48.927]                             next
[17:42:48.927]                           invokeRestart(restart)
[17:42:48.927]                           muffled <- TRUE
[17:42:48.927]                           break
[17:42:48.927]                         }
[17:42:48.927]                       }
[17:42:48.927]                     }
[17:42:48.927]                     invisible(muffled)
[17:42:48.927]                   }
[17:42:48.927]                   muffleCondition(cond)
[17:42:48.927]                 })
[17:42:48.927]             }))
[17:42:48.927]             future::FutureResult(value = ...future.value$value, 
[17:42:48.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.927]                   ...future.rng), globalenv = if (FALSE) 
[17:42:48.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:48.927]                     ...future.globalenv.names))
[17:42:48.927]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:48.927]         }, condition = base::local({
[17:42:48.927]             c <- base::c
[17:42:48.927]             inherits <- base::inherits
[17:42:48.927]             invokeRestart <- base::invokeRestart
[17:42:48.927]             length <- base::length
[17:42:48.927]             list <- base::list
[17:42:48.927]             seq.int <- base::seq.int
[17:42:48.927]             signalCondition <- base::signalCondition
[17:42:48.927]             sys.calls <- base::sys.calls
[17:42:48.927]             `[[` <- base::`[[`
[17:42:48.927]             `+` <- base::`+`
[17:42:48.927]             `<<-` <- base::`<<-`
[17:42:48.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:48.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:48.927]                   3L)]
[17:42:48.927]             }
[17:42:48.927]             function(cond) {
[17:42:48.927]                 is_error <- inherits(cond, "error")
[17:42:48.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:48.927]                   NULL)
[17:42:48.927]                 if (is_error) {
[17:42:48.927]                   sessionInformation <- function() {
[17:42:48.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:48.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:48.927]                       search = base::search(), system = base::Sys.info())
[17:42:48.927]                   }
[17:42:48.927]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:48.927]                     cond$call), session = sessionInformation(), 
[17:42:48.927]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:48.927]                   signalCondition(cond)
[17:42:48.927]                 }
[17:42:48.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:48.927]                 "immediateCondition"))) {
[17:42:48.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:48.927]                   ...future.conditions[[length(...future.conditions) + 
[17:42:48.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:48.927]                   if (TRUE && !signal) {
[17:42:48.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.927]                     {
[17:42:48.927]                       inherits <- base::inherits
[17:42:48.927]                       invokeRestart <- base::invokeRestart
[17:42:48.927]                       is.null <- base::is.null
[17:42:48.927]                       muffled <- FALSE
[17:42:48.927]                       if (inherits(cond, "message")) {
[17:42:48.927]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.927]                         if (muffled) 
[17:42:48.927]                           invokeRestart("muffleMessage")
[17:42:48.927]                       }
[17:42:48.927]                       else if (inherits(cond, "warning")) {
[17:42:48.927]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.927]                         if (muffled) 
[17:42:48.927]                           invokeRestart("muffleWarning")
[17:42:48.927]                       }
[17:42:48.927]                       else if (inherits(cond, "condition")) {
[17:42:48.927]                         if (!is.null(pattern)) {
[17:42:48.927]                           computeRestarts <- base::computeRestarts
[17:42:48.927]                           grepl <- base::grepl
[17:42:48.927]                           restarts <- computeRestarts(cond)
[17:42:48.927]                           for (restart in restarts) {
[17:42:48.927]                             name <- restart$name
[17:42:48.927]                             if (is.null(name)) 
[17:42:48.927]                               next
[17:42:48.927]                             if (!grepl(pattern, name)) 
[17:42:48.927]                               next
[17:42:48.927]                             invokeRestart(restart)
[17:42:48.927]                             muffled <- TRUE
[17:42:48.927]                             break
[17:42:48.927]                           }
[17:42:48.927]                         }
[17:42:48.927]                       }
[17:42:48.927]                       invisible(muffled)
[17:42:48.927]                     }
[17:42:48.927]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.927]                   }
[17:42:48.927]                 }
[17:42:48.927]                 else {
[17:42:48.927]                   if (TRUE) {
[17:42:48.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:48.927]                     {
[17:42:48.927]                       inherits <- base::inherits
[17:42:48.927]                       invokeRestart <- base::invokeRestart
[17:42:48.927]                       is.null <- base::is.null
[17:42:48.927]                       muffled <- FALSE
[17:42:48.927]                       if (inherits(cond, "message")) {
[17:42:48.927]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:48.927]                         if (muffled) 
[17:42:48.927]                           invokeRestart("muffleMessage")
[17:42:48.927]                       }
[17:42:48.927]                       else if (inherits(cond, "warning")) {
[17:42:48.927]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:48.927]                         if (muffled) 
[17:42:48.927]                           invokeRestart("muffleWarning")
[17:42:48.927]                       }
[17:42:48.927]                       else if (inherits(cond, "condition")) {
[17:42:48.927]                         if (!is.null(pattern)) {
[17:42:48.927]                           computeRestarts <- base::computeRestarts
[17:42:48.927]                           grepl <- base::grepl
[17:42:48.927]                           restarts <- computeRestarts(cond)
[17:42:48.927]                           for (restart in restarts) {
[17:42:48.927]                             name <- restart$name
[17:42:48.927]                             if (is.null(name)) 
[17:42:48.927]                               next
[17:42:48.927]                             if (!grepl(pattern, name)) 
[17:42:48.927]                               next
[17:42:48.927]                             invokeRestart(restart)
[17:42:48.927]                             muffled <- TRUE
[17:42:48.927]                             break
[17:42:48.927]                           }
[17:42:48.927]                         }
[17:42:48.927]                       }
[17:42:48.927]                       invisible(muffled)
[17:42:48.927]                     }
[17:42:48.927]                     muffleCondition(cond, pattern = "^muffle")
[17:42:48.927]                   }
[17:42:48.927]                 }
[17:42:48.927]             }
[17:42:48.927]         }))
[17:42:48.927]     }, error = function(ex) {
[17:42:48.927]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:48.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:48.927]                 ...future.rng), started = ...future.startTime, 
[17:42:48.927]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:48.927]             version = "1.8"), class = "FutureResult")
[17:42:48.927]     }, finally = {
[17:42:48.927]         if (!identical(...future.workdir, getwd())) 
[17:42:48.927]             setwd(...future.workdir)
[17:42:48.927]         {
[17:42:48.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:48.927]                 ...future.oldOptions$nwarnings <- NULL
[17:42:48.927]             }
[17:42:48.927]             base::options(...future.oldOptions)
[17:42:48.927]             if (.Platform$OS.type == "windows") {
[17:42:48.927]                 old_names <- names(...future.oldEnvVars)
[17:42:48.927]                 envs <- base::Sys.getenv()
[17:42:48.927]                 names <- names(envs)
[17:42:48.927]                 common <- intersect(names, old_names)
[17:42:48.927]                 added <- setdiff(names, old_names)
[17:42:48.927]                 removed <- setdiff(old_names, names)
[17:42:48.927]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:48.927]                   envs[common]]
[17:42:48.927]                 NAMES <- toupper(changed)
[17:42:48.927]                 args <- list()
[17:42:48.927]                 for (kk in seq_along(NAMES)) {
[17:42:48.927]                   name <- changed[[kk]]
[17:42:48.927]                   NAME <- NAMES[[kk]]
[17:42:48.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.927]                     next
[17:42:48.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.927]                 }
[17:42:48.927]                 NAMES <- toupper(added)
[17:42:48.927]                 for (kk in seq_along(NAMES)) {
[17:42:48.927]                   name <- added[[kk]]
[17:42:48.927]                   NAME <- NAMES[[kk]]
[17:42:48.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.927]                     next
[17:42:48.927]                   args[[name]] <- ""
[17:42:48.927]                 }
[17:42:48.927]                 NAMES <- toupper(removed)
[17:42:48.927]                 for (kk in seq_along(NAMES)) {
[17:42:48.927]                   name <- removed[[kk]]
[17:42:48.927]                   NAME <- NAMES[[kk]]
[17:42:48.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:48.927]                     next
[17:42:48.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:48.927]                 }
[17:42:48.927]                 if (length(args) > 0) 
[17:42:48.927]                   base::do.call(base::Sys.setenv, args = args)
[17:42:48.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:48.927]             }
[17:42:48.927]             else {
[17:42:48.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:48.927]             }
[17:42:48.927]             {
[17:42:48.927]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:48.927]                   0L) {
[17:42:48.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:48.927]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:48.927]                   base::options(opts)
[17:42:48.927]                 }
[17:42:48.927]                 {
[17:42:48.927]                   {
[17:42:48.927]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:48.927]                     NULL
[17:42:48.927]                   }
[17:42:48.927]                   options(future.plan = NULL)
[17:42:48.927]                   if (is.na(NA_character_)) 
[17:42:48.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:48.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:48.927]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:48.927]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:48.927]                     envir = parent.frame()) 
[17:42:48.927]                   {
[17:42:48.927]                     if (is.function(workers)) 
[17:42:48.927]                       workers <- workers()
[17:42:48.927]                     workers <- structure(as.integer(workers), 
[17:42:48.927]                       class = class(workers))
[17:42:48.927]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:48.927]                       workers >= 1)
[17:42:48.927]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:48.927]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:48.927]                     }
[17:42:48.927]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:48.927]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:48.927]                       envir = envir)
[17:42:48.927]                     if (!future$lazy) 
[17:42:48.927]                       future <- run(future)
[17:42:48.927]                     invisible(future)
[17:42:48.927]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:48.927]                 }
[17:42:48.927]             }
[17:42:48.927]         }
[17:42:48.927]     })
[17:42:48.927]     if (TRUE) {
[17:42:48.927]         base::sink(type = "output", split = FALSE)
[17:42:48.927]         if (TRUE) {
[17:42:48.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:48.927]         }
[17:42:48.927]         else {
[17:42:48.927]             ...future.result["stdout"] <- base::list(NULL)
[17:42:48.927]         }
[17:42:48.927]         base::close(...future.stdout)
[17:42:48.927]         ...future.stdout <- NULL
[17:42:48.927]     }
[17:42:48.927]     ...future.result$conditions <- ...future.conditions
[17:42:48.927]     ...future.result$finished <- base::Sys.time()
[17:42:48.927]     ...future.result
[17:42:48.927] }
[17:42:48.930] MultisessionFuture started
[17:42:48.931] - Launch lazy future ... done
[17:42:48.931] run() for ‘MultisessionFuture’ ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:48.931] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:48.931] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:48.932] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:48.932] Searching for globals ... DONE
[17:42:48.932] Resolving globals: TRUE
[17:42:48.932] Resolving any globals that are futures ...
[17:42:48.932] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:48.933] Resolving any globals that are futures ... DONE
[17:42:48.933] Resolving futures part of globals (recursively) ...
[17:42:48.933] resolve() on list ...
[17:42:48.933]  recursive: 99
[17:42:48.933]  length: 1
[17:42:48.933]  elements: ‘a’
[17:42:48.976] receiveMessageFromWorker() for ClusterFuture ...
[17:42:48.977] - Validating connection of MultisessionFuture
[17:42:48.977] - received message: FutureResult
[17:42:48.977] - Received FutureResult
[17:42:48.977] - Erased future from FutureRegistry
[17:42:48.977] result() for ClusterFuture ...
[17:42:48.977] - result already collected: FutureResult
[17:42:48.977] result() for ClusterFuture ... done
[17:42:48.977] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:48.978] Future #1
[17:42:48.978] result() for ClusterFuture ...
[17:42:48.978] - result already collected: FutureResult
[17:42:48.978] result() for ClusterFuture ... done
[17:42:48.978] result() for ClusterFuture ...
[17:42:48.978] - result already collected: FutureResult
[17:42:48.978] result() for ClusterFuture ... done
[17:42:48.978] A MultisessionFuture was resolved
[17:42:48.978]  length: 0 (resolved future 1)
[17:42:48.979] resolve() on list ... DONE
[17:42:48.979] - globals: [1] ‘a’
[17:42:48.979] Resolving futures part of globals (recursively) ... DONE
[17:42:48.983] The total size of the 1 globals is 1.55 MiB (1629176 bytes)
[17:42:48.983] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:48.984] - globals: [1] ‘a’
[17:42:48.984] - packages: [1] ‘future’
[17:42:48.984] getGlobalsAndPackages() ... DONE
[17:42:48.984] run() for ‘Future’ ...
[17:42:48.984] - state: ‘created’
[17:42:48.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:48.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:48.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:48.999]   - Field: ‘node’
[17:42:48.999]   - Field: ‘label’
[17:42:48.999]   - Field: ‘local’
[17:42:48.999]   - Field: ‘owner’
[17:42:48.999]   - Field: ‘envir’
[17:42:48.999]   - Field: ‘workers’
[17:42:48.999]   - Field: ‘packages’
[17:42:49.000]   - Field: ‘gc’
[17:42:49.000]   - Field: ‘conditions’
[17:42:49.000]   - Field: ‘persistent’
[17:42:49.000]   - Field: ‘expr’
[17:42:49.000]   - Field: ‘uuid’
[17:42:49.000]   - Field: ‘seed’
[17:42:49.000]   - Field: ‘version’
[17:42:49.000]   - Field: ‘result’
[17:42:49.000]   - Field: ‘asynchronous’
[17:42:49.000]   - Field: ‘calls’
[17:42:49.000]   - Field: ‘globals’
[17:42:49.001]   - Field: ‘stdout’
[17:42:49.001]   - Field: ‘earlySignal’
[17:42:49.001]   - Field: ‘lazy’
[17:42:49.001]   - Field: ‘state’
[17:42:49.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.001] - Launch lazy future ...
[17:42:49.001] Packages needed by the future expression (n = 1): ‘future’
[17:42:49.001] Packages needed by future strategies (n = 0): <none>
[17:42:49.002] {
[17:42:49.002]     {
[17:42:49.002]         {
[17:42:49.002]             ...future.startTime <- base::Sys.time()
[17:42:49.002]             {
[17:42:49.002]                 {
[17:42:49.002]                   {
[17:42:49.002]                     {
[17:42:49.002]                       {
[17:42:49.002]                         base::local({
[17:42:49.002]                           has_future <- base::requireNamespace("future", 
[17:42:49.002]                             quietly = TRUE)
[17:42:49.002]                           if (has_future) {
[17:42:49.002]                             ns <- base::getNamespace("future")
[17:42:49.002]                             version <- ns[[".package"]][["version"]]
[17:42:49.002]                             if (is.null(version)) 
[17:42:49.002]                               version <- utils::packageVersion("future")
[17:42:49.002]                           }
[17:42:49.002]                           else {
[17:42:49.002]                             version <- NULL
[17:42:49.002]                           }
[17:42:49.002]                           if (!has_future || version < "1.8.0") {
[17:42:49.002]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.002]                               "", base::R.version$version.string), 
[17:42:49.002]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:49.002]                                 base::R.version$platform, 8 * 
[17:42:49.002]                                   base::.Machine$sizeof.pointer), 
[17:42:49.002]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.002]                                 "release", "version")], collapse = " "), 
[17:42:49.002]                               hostname = base::Sys.info()[["nodename"]])
[17:42:49.002]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.002]                               info)
[17:42:49.002]                             info <- base::paste(info, collapse = "; ")
[17:42:49.002]                             if (!has_future) {
[17:42:49.002]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.002]                                 info)
[17:42:49.002]                             }
[17:42:49.002]                             else {
[17:42:49.002]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.002]                                 info, version)
[17:42:49.002]                             }
[17:42:49.002]                             base::stop(msg)
[17:42:49.002]                           }
[17:42:49.002]                         })
[17:42:49.002]                       }
[17:42:49.002]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.002]                       base::options(mc.cores = 1L)
[17:42:49.002]                     }
[17:42:49.002]                     base::local({
[17:42:49.002]                       for (pkg in "future") {
[17:42:49.002]                         base::loadNamespace(pkg)
[17:42:49.002]                         base::library(pkg, character.only = TRUE)
[17:42:49.002]                       }
[17:42:49.002]                     })
[17:42:49.002]                   }
[17:42:49.002]                   options(future.plan = NULL)
[17:42:49.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.002]                 }
[17:42:49.002]                 ...future.workdir <- getwd()
[17:42:49.002]             }
[17:42:49.002]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.002]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.002]         }
[17:42:49.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.002]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.002]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.002]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.002]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.002]             base::names(...future.oldOptions))
[17:42:49.002]     }
[17:42:49.002]     if (FALSE) {
[17:42:49.002]     }
[17:42:49.002]     else {
[17:42:49.002]         if (TRUE) {
[17:42:49.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.002]                 open = "w")
[17:42:49.002]         }
[17:42:49.002]         else {
[17:42:49.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.002]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.002]         }
[17:42:49.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.002]             base::sink(type = "output", split = FALSE)
[17:42:49.002]             base::close(...future.stdout)
[17:42:49.002]         }, add = TRUE)
[17:42:49.002]     }
[17:42:49.002]     ...future.frame <- base::sys.nframe()
[17:42:49.002]     ...future.conditions <- base::list()
[17:42:49.002]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.002]     if (FALSE) {
[17:42:49.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.002]     }
[17:42:49.002]     ...future.result <- base::tryCatch({
[17:42:49.002]         base::withCallingHandlers({
[17:42:49.002]             ...future.value <- base::withVisible(base::local({
[17:42:49.002]                 ...future.makeSendCondition <- local({
[17:42:49.002]                   sendCondition <- NULL
[17:42:49.002]                   function(frame = 1L) {
[17:42:49.002]                     if (is.function(sendCondition)) 
[17:42:49.002]                       return(sendCondition)
[17:42:49.002]                     ns <- getNamespace("parallel")
[17:42:49.002]                     if (exists("sendData", mode = "function", 
[17:42:49.002]                       envir = ns)) {
[17:42:49.002]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.002]                         envir = ns)
[17:42:49.002]                       envir <- sys.frame(frame)
[17:42:49.002]                       master <- NULL
[17:42:49.002]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.002]                         !identical(envir, emptyenv())) {
[17:42:49.002]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.002]                           inherits = FALSE)) {
[17:42:49.002]                           master <- get("master", mode = "list", 
[17:42:49.002]                             envir = envir, inherits = FALSE)
[17:42:49.002]                           if (inherits(master, c("SOCKnode", 
[17:42:49.002]                             "SOCK0node"))) {
[17:42:49.002]                             sendCondition <<- function(cond) {
[17:42:49.002]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.002]                                 success = TRUE)
[17:42:49.002]                               parallel_sendData(master, data)
[17:42:49.002]                             }
[17:42:49.002]                             return(sendCondition)
[17:42:49.002]                           }
[17:42:49.002]                         }
[17:42:49.002]                         frame <- frame + 1L
[17:42:49.002]                         envir <- sys.frame(frame)
[17:42:49.002]                       }
[17:42:49.002]                     }
[17:42:49.002]                     sendCondition <<- function(cond) NULL
[17:42:49.002]                   }
[17:42:49.002]                 })
[17:42:49.002]                 withCallingHandlers({
[17:42:49.002]                   value(a) + 1
[17:42:49.002]                 }, immediateCondition = function(cond) {
[17:42:49.002]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.002]                   sendCondition(cond)
[17:42:49.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.002]                   {
[17:42:49.002]                     inherits <- base::inherits
[17:42:49.002]                     invokeRestart <- base::invokeRestart
[17:42:49.002]                     is.null <- base::is.null
[17:42:49.002]                     muffled <- FALSE
[17:42:49.002]                     if (inherits(cond, "message")) {
[17:42:49.002]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.002]                       if (muffled) 
[17:42:49.002]                         invokeRestart("muffleMessage")
[17:42:49.002]                     }
[17:42:49.002]                     else if (inherits(cond, "warning")) {
[17:42:49.002]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.002]                       if (muffled) 
[17:42:49.002]                         invokeRestart("muffleWarning")
[17:42:49.002]                     }
[17:42:49.002]                     else if (inherits(cond, "condition")) {
[17:42:49.002]                       if (!is.null(pattern)) {
[17:42:49.002]                         computeRestarts <- base::computeRestarts
[17:42:49.002]                         grepl <- base::grepl
[17:42:49.002]                         restarts <- computeRestarts(cond)
[17:42:49.002]                         for (restart in restarts) {
[17:42:49.002]                           name <- restart$name
[17:42:49.002]                           if (is.null(name)) 
[17:42:49.002]                             next
[17:42:49.002]                           if (!grepl(pattern, name)) 
[17:42:49.002]                             next
[17:42:49.002]                           invokeRestart(restart)
[17:42:49.002]                           muffled <- TRUE
[17:42:49.002]                           break
[17:42:49.002]                         }
[17:42:49.002]                       }
[17:42:49.002]                     }
[17:42:49.002]                     invisible(muffled)
[17:42:49.002]                   }
[17:42:49.002]                   muffleCondition(cond)
[17:42:49.002]                 })
[17:42:49.002]             }))
[17:42:49.002]             future::FutureResult(value = ...future.value$value, 
[17:42:49.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.002]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.002]                     ...future.globalenv.names))
[17:42:49.002]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.002]         }, condition = base::local({
[17:42:49.002]             c <- base::c
[17:42:49.002]             inherits <- base::inherits
[17:42:49.002]             invokeRestart <- base::invokeRestart
[17:42:49.002]             length <- base::length
[17:42:49.002]             list <- base::list
[17:42:49.002]             seq.int <- base::seq.int
[17:42:49.002]             signalCondition <- base::signalCondition
[17:42:49.002]             sys.calls <- base::sys.calls
[17:42:49.002]             `[[` <- base::`[[`
[17:42:49.002]             `+` <- base::`+`
[17:42:49.002]             `<<-` <- base::`<<-`
[17:42:49.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.002]                   3L)]
[17:42:49.002]             }
[17:42:49.002]             function(cond) {
[17:42:49.002]                 is_error <- inherits(cond, "error")
[17:42:49.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.002]                   NULL)
[17:42:49.002]                 if (is_error) {
[17:42:49.002]                   sessionInformation <- function() {
[17:42:49.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.002]                       search = base::search(), system = base::Sys.info())
[17:42:49.002]                   }
[17:42:49.002]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.002]                     cond$call), session = sessionInformation(), 
[17:42:49.002]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.002]                   signalCondition(cond)
[17:42:49.002]                 }
[17:42:49.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.002]                 "immediateCondition"))) {
[17:42:49.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.002]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.002]                   if (TRUE && !signal) {
[17:42:49.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.002]                     {
[17:42:49.002]                       inherits <- base::inherits
[17:42:49.002]                       invokeRestart <- base::invokeRestart
[17:42:49.002]                       is.null <- base::is.null
[17:42:49.002]                       muffled <- FALSE
[17:42:49.002]                       if (inherits(cond, "message")) {
[17:42:49.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.002]                         if (muffled) 
[17:42:49.002]                           invokeRestart("muffleMessage")
[17:42:49.002]                       }
[17:42:49.002]                       else if (inherits(cond, "warning")) {
[17:42:49.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.002]                         if (muffled) 
[17:42:49.002]                           invokeRestart("muffleWarning")
[17:42:49.002]                       }
[17:42:49.002]                       else if (inherits(cond, "condition")) {
[17:42:49.002]                         if (!is.null(pattern)) {
[17:42:49.002]                           computeRestarts <- base::computeRestarts
[17:42:49.002]                           grepl <- base::grepl
[17:42:49.002]                           restarts <- computeRestarts(cond)
[17:42:49.002]                           for (restart in restarts) {
[17:42:49.002]                             name <- restart$name
[17:42:49.002]                             if (is.null(name)) 
[17:42:49.002]                               next
[17:42:49.002]                             if (!grepl(pattern, name)) 
[17:42:49.002]                               next
[17:42:49.002]                             invokeRestart(restart)
[17:42:49.002]                             muffled <- TRUE
[17:42:49.002]                             break
[17:42:49.002]                           }
[17:42:49.002]                         }
[17:42:49.002]                       }
[17:42:49.002]                       invisible(muffled)
[17:42:49.002]                     }
[17:42:49.002]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.002]                   }
[17:42:49.002]                 }
[17:42:49.002]                 else {
[17:42:49.002]                   if (TRUE) {
[17:42:49.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.002]                     {
[17:42:49.002]                       inherits <- base::inherits
[17:42:49.002]                       invokeRestart <- base::invokeRestart
[17:42:49.002]                       is.null <- base::is.null
[17:42:49.002]                       muffled <- FALSE
[17:42:49.002]                       if (inherits(cond, "message")) {
[17:42:49.002]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.002]                         if (muffled) 
[17:42:49.002]                           invokeRestart("muffleMessage")
[17:42:49.002]                       }
[17:42:49.002]                       else if (inherits(cond, "warning")) {
[17:42:49.002]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.002]                         if (muffled) 
[17:42:49.002]                           invokeRestart("muffleWarning")
[17:42:49.002]                       }
[17:42:49.002]                       else if (inherits(cond, "condition")) {
[17:42:49.002]                         if (!is.null(pattern)) {
[17:42:49.002]                           computeRestarts <- base::computeRestarts
[17:42:49.002]                           grepl <- base::grepl
[17:42:49.002]                           restarts <- computeRestarts(cond)
[17:42:49.002]                           for (restart in restarts) {
[17:42:49.002]                             name <- restart$name
[17:42:49.002]                             if (is.null(name)) 
[17:42:49.002]                               next
[17:42:49.002]                             if (!grepl(pattern, name)) 
[17:42:49.002]                               next
[17:42:49.002]                             invokeRestart(restart)
[17:42:49.002]                             muffled <- TRUE
[17:42:49.002]                             break
[17:42:49.002]                           }
[17:42:49.002]                         }
[17:42:49.002]                       }
[17:42:49.002]                       invisible(muffled)
[17:42:49.002]                     }
[17:42:49.002]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.002]                   }
[17:42:49.002]                 }
[17:42:49.002]             }
[17:42:49.002]         }))
[17:42:49.002]     }, error = function(ex) {
[17:42:49.002]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.002]                 ...future.rng), started = ...future.startTime, 
[17:42:49.002]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.002]             version = "1.8"), class = "FutureResult")
[17:42:49.002]     }, finally = {
[17:42:49.002]         if (!identical(...future.workdir, getwd())) 
[17:42:49.002]             setwd(...future.workdir)
[17:42:49.002]         {
[17:42:49.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.002]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.002]             }
[17:42:49.002]             base::options(...future.oldOptions)
[17:42:49.002]             if (.Platform$OS.type == "windows") {
[17:42:49.002]                 old_names <- names(...future.oldEnvVars)
[17:42:49.002]                 envs <- base::Sys.getenv()
[17:42:49.002]                 names <- names(envs)
[17:42:49.002]                 common <- intersect(names, old_names)
[17:42:49.002]                 added <- setdiff(names, old_names)
[17:42:49.002]                 removed <- setdiff(old_names, names)
[17:42:49.002]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.002]                   envs[common]]
[17:42:49.002]                 NAMES <- toupper(changed)
[17:42:49.002]                 args <- list()
[17:42:49.002]                 for (kk in seq_along(NAMES)) {
[17:42:49.002]                   name <- changed[[kk]]
[17:42:49.002]                   NAME <- NAMES[[kk]]
[17:42:49.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.002]                     next
[17:42:49.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.002]                 }
[17:42:49.002]                 NAMES <- toupper(added)
[17:42:49.002]                 for (kk in seq_along(NAMES)) {
[17:42:49.002]                   name <- added[[kk]]
[17:42:49.002]                   NAME <- NAMES[[kk]]
[17:42:49.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.002]                     next
[17:42:49.002]                   args[[name]] <- ""
[17:42:49.002]                 }
[17:42:49.002]                 NAMES <- toupper(removed)
[17:42:49.002]                 for (kk in seq_along(NAMES)) {
[17:42:49.002]                   name <- removed[[kk]]
[17:42:49.002]                   NAME <- NAMES[[kk]]
[17:42:49.002]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.002]                     next
[17:42:49.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.002]                 }
[17:42:49.002]                 if (length(args) > 0) 
[17:42:49.002]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.002]             }
[17:42:49.002]             else {
[17:42:49.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.002]             }
[17:42:49.002]             {
[17:42:49.002]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.002]                   0L) {
[17:42:49.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.002]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.002]                   base::options(opts)
[17:42:49.002]                 }
[17:42:49.002]                 {
[17:42:49.002]                   {
[17:42:49.002]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.002]                     NULL
[17:42:49.002]                   }
[17:42:49.002]                   options(future.plan = NULL)
[17:42:49.002]                   if (is.na(NA_character_)) 
[17:42:49.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.002]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.002]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.002]                     envir = parent.frame()) 
[17:42:49.002]                   {
[17:42:49.002]                     if (is.function(workers)) 
[17:42:49.002]                       workers <- workers()
[17:42:49.002]                     workers <- structure(as.integer(workers), 
[17:42:49.002]                       class = class(workers))
[17:42:49.002]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.002]                       workers >= 1)
[17:42:49.002]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.002]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.002]                     }
[17:42:49.002]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.002]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.002]                       envir = envir)
[17:42:49.002]                     if (!future$lazy) 
[17:42:49.002]                       future <- run(future)
[17:42:49.002]                     invisible(future)
[17:42:49.002]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.002]                 }
[17:42:49.002]             }
[17:42:49.002]         }
[17:42:49.002]     })
[17:42:49.002]     if (TRUE) {
[17:42:49.002]         base::sink(type = "output", split = FALSE)
[17:42:49.002]         if (TRUE) {
[17:42:49.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.002]         }
[17:42:49.002]         else {
[17:42:49.002]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.002]         }
[17:42:49.002]         base::close(...future.stdout)
[17:42:49.002]         ...future.stdout <- NULL
[17:42:49.002]     }
[17:42:49.002]     ...future.result$conditions <- ...future.conditions
[17:42:49.002]     ...future.result$finished <- base::Sys.time()
[17:42:49.002]     ...future.result
[17:42:49.002] }
[17:42:49.005] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[17:42:49.006] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[17:42:49.059] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[17:42:49.059] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[17:42:49.060] MultisessionFuture started
[17:42:49.060] - Launch lazy future ... done
[17:42:49.060] run() for ‘MultisessionFuture’ ... done
[17:42:49.060] result() for ClusterFuture ...
[17:42:49.061] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.061] - Validating connection of MultisessionFuture
[17:42:49.109] - received message: FutureResult
[17:42:49.109] - Received FutureResult
[17:42:49.109] - Erased future from FutureRegistry
[17:42:49.110] result() for ClusterFuture ...
[17:42:49.110] - result already collected: FutureResult
[17:42:49.110] result() for ClusterFuture ... done
[17:42:49.110] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.110] result() for ClusterFuture ... done
[17:42:49.110] result() for ClusterFuture ...
[17:42:49.110] - result already collected: FutureResult
[17:42:49.110] result() for ClusterFuture ... done
value(b) = 2
[17:42:49.110] result() for ClusterFuture ...
[17:42:49.110] - result already collected: FutureResult
[17:42:49.111] result() for ClusterFuture ... done
[17:42:49.111] result() for ClusterFuture ...
[17:42:49.111] - result already collected: FutureResult
[17:42:49.111] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.111] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.111] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.112] 
[17:42:49.112] Searching for globals ... DONE
[17:42:49.112] - globals: [0] <none>
[17:42:49.112] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.112] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.113] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.113] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:49.113] Searching for globals ... DONE
[17:42:49.114] Resolving globals: TRUE
[17:42:49.114] Resolving any globals that are futures ...
[17:42:49.114] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:49.114] Resolving any globals that are futures ... DONE
[17:42:49.114] Resolving futures part of globals (recursively) ...
[17:42:49.114] resolve() on list ...
[17:42:49.114]  recursive: 99
[17:42:49.115]  length: 1
[17:42:49.115]  elements: ‘a’
[17:42:49.115] run() for ‘Future’ ...
[17:42:49.115] - state: ‘created’
[17:42:49.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.131]   - Field: ‘node’
[17:42:49.131]   - Field: ‘label’
[17:42:49.131]   - Field: ‘local’
[17:42:49.132]   - Field: ‘owner’
[17:42:49.132]   - Field: ‘envir’
[17:42:49.132]   - Field: ‘workers’
[17:42:49.132]   - Field: ‘packages’
[17:42:49.132]   - Field: ‘gc’
[17:42:49.132]   - Field: ‘conditions’
[17:42:49.132]   - Field: ‘persistent’
[17:42:49.132]   - Field: ‘expr’
[17:42:49.132]   - Field: ‘uuid’
[17:42:49.132]   - Field: ‘seed’
[17:42:49.133]   - Field: ‘version’
[17:42:49.133]   - Field: ‘result’
[17:42:49.133]   - Field: ‘asynchronous’
[17:42:49.133]   - Field: ‘calls’
[17:42:49.133]   - Field: ‘globals’
[17:42:49.133]   - Field: ‘stdout’
[17:42:49.133]   - Field: ‘earlySignal’
[17:42:49.133]   - Field: ‘lazy’
[17:42:49.133]   - Field: ‘state’
[17:42:49.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.134] - Launch lazy future ...
[17:42:49.134] Packages needed by the future expression (n = 0): <none>
[17:42:49.134] Packages needed by future strategies (n = 0): <none>
[17:42:49.134] {
[17:42:49.134]     {
[17:42:49.134]         {
[17:42:49.134]             ...future.startTime <- base::Sys.time()
[17:42:49.134]             {
[17:42:49.134]                 {
[17:42:49.134]                   {
[17:42:49.134]                     {
[17:42:49.134]                       base::local({
[17:42:49.134]                         has_future <- base::requireNamespace("future", 
[17:42:49.134]                           quietly = TRUE)
[17:42:49.134]                         if (has_future) {
[17:42:49.134]                           ns <- base::getNamespace("future")
[17:42:49.134]                           version <- ns[[".package"]][["version"]]
[17:42:49.134]                           if (is.null(version)) 
[17:42:49.134]                             version <- utils::packageVersion("future")
[17:42:49.134]                         }
[17:42:49.134]                         else {
[17:42:49.134]                           version <- NULL
[17:42:49.134]                         }
[17:42:49.134]                         if (!has_future || version < "1.8.0") {
[17:42:49.134]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.134]                             "", base::R.version$version.string), 
[17:42:49.134]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:49.134]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:49.134]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.134]                               "release", "version")], collapse = " "), 
[17:42:49.134]                             hostname = base::Sys.info()[["nodename"]])
[17:42:49.134]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.134]                             info)
[17:42:49.134]                           info <- base::paste(info, collapse = "; ")
[17:42:49.134]                           if (!has_future) {
[17:42:49.134]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.134]                               info)
[17:42:49.134]                           }
[17:42:49.134]                           else {
[17:42:49.134]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.134]                               info, version)
[17:42:49.134]                           }
[17:42:49.134]                           base::stop(msg)
[17:42:49.134]                         }
[17:42:49.134]                       })
[17:42:49.134]                     }
[17:42:49.134]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.134]                     base::options(mc.cores = 1L)
[17:42:49.134]                   }
[17:42:49.134]                   options(future.plan = NULL)
[17:42:49.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.134]                 }
[17:42:49.134]                 ...future.workdir <- getwd()
[17:42:49.134]             }
[17:42:49.134]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.134]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.134]         }
[17:42:49.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.134]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.134]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.134]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.134]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.134]             base::names(...future.oldOptions))
[17:42:49.134]     }
[17:42:49.134]     if (FALSE) {
[17:42:49.134]     }
[17:42:49.134]     else {
[17:42:49.134]         if (TRUE) {
[17:42:49.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.134]                 open = "w")
[17:42:49.134]         }
[17:42:49.134]         else {
[17:42:49.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.134]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.134]         }
[17:42:49.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.134]             base::sink(type = "output", split = FALSE)
[17:42:49.134]             base::close(...future.stdout)
[17:42:49.134]         }, add = TRUE)
[17:42:49.134]     }
[17:42:49.134]     ...future.frame <- base::sys.nframe()
[17:42:49.134]     ...future.conditions <- base::list()
[17:42:49.134]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.134]     if (FALSE) {
[17:42:49.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.134]     }
[17:42:49.134]     ...future.result <- base::tryCatch({
[17:42:49.134]         base::withCallingHandlers({
[17:42:49.134]             ...future.value <- base::withVisible(base::local({
[17:42:49.134]                 ...future.makeSendCondition <- local({
[17:42:49.134]                   sendCondition <- NULL
[17:42:49.134]                   function(frame = 1L) {
[17:42:49.134]                     if (is.function(sendCondition)) 
[17:42:49.134]                       return(sendCondition)
[17:42:49.134]                     ns <- getNamespace("parallel")
[17:42:49.134]                     if (exists("sendData", mode = "function", 
[17:42:49.134]                       envir = ns)) {
[17:42:49.134]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.134]                         envir = ns)
[17:42:49.134]                       envir <- sys.frame(frame)
[17:42:49.134]                       master <- NULL
[17:42:49.134]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.134]                         !identical(envir, emptyenv())) {
[17:42:49.134]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.134]                           inherits = FALSE)) {
[17:42:49.134]                           master <- get("master", mode = "list", 
[17:42:49.134]                             envir = envir, inherits = FALSE)
[17:42:49.134]                           if (inherits(master, c("SOCKnode", 
[17:42:49.134]                             "SOCK0node"))) {
[17:42:49.134]                             sendCondition <<- function(cond) {
[17:42:49.134]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.134]                                 success = TRUE)
[17:42:49.134]                               parallel_sendData(master, data)
[17:42:49.134]                             }
[17:42:49.134]                             return(sendCondition)
[17:42:49.134]                           }
[17:42:49.134]                         }
[17:42:49.134]                         frame <- frame + 1L
[17:42:49.134]                         envir <- sys.frame(frame)
[17:42:49.134]                       }
[17:42:49.134]                     }
[17:42:49.134]                     sendCondition <<- function(cond) NULL
[17:42:49.134]                   }
[17:42:49.134]                 })
[17:42:49.134]                 withCallingHandlers({
[17:42:49.134]                   1
[17:42:49.134]                 }, immediateCondition = function(cond) {
[17:42:49.134]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.134]                   sendCondition(cond)
[17:42:49.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.134]                   {
[17:42:49.134]                     inherits <- base::inherits
[17:42:49.134]                     invokeRestart <- base::invokeRestart
[17:42:49.134]                     is.null <- base::is.null
[17:42:49.134]                     muffled <- FALSE
[17:42:49.134]                     if (inherits(cond, "message")) {
[17:42:49.134]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.134]                       if (muffled) 
[17:42:49.134]                         invokeRestart("muffleMessage")
[17:42:49.134]                     }
[17:42:49.134]                     else if (inherits(cond, "warning")) {
[17:42:49.134]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.134]                       if (muffled) 
[17:42:49.134]                         invokeRestart("muffleWarning")
[17:42:49.134]                     }
[17:42:49.134]                     else if (inherits(cond, "condition")) {
[17:42:49.134]                       if (!is.null(pattern)) {
[17:42:49.134]                         computeRestarts <- base::computeRestarts
[17:42:49.134]                         grepl <- base::grepl
[17:42:49.134]                         restarts <- computeRestarts(cond)
[17:42:49.134]                         for (restart in restarts) {
[17:42:49.134]                           name <- restart$name
[17:42:49.134]                           if (is.null(name)) 
[17:42:49.134]                             next
[17:42:49.134]                           if (!grepl(pattern, name)) 
[17:42:49.134]                             next
[17:42:49.134]                           invokeRestart(restart)
[17:42:49.134]                           muffled <- TRUE
[17:42:49.134]                           break
[17:42:49.134]                         }
[17:42:49.134]                       }
[17:42:49.134]                     }
[17:42:49.134]                     invisible(muffled)
[17:42:49.134]                   }
[17:42:49.134]                   muffleCondition(cond)
[17:42:49.134]                 })
[17:42:49.134]             }))
[17:42:49.134]             future::FutureResult(value = ...future.value$value, 
[17:42:49.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.134]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.134]                     ...future.globalenv.names))
[17:42:49.134]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.134]         }, condition = base::local({
[17:42:49.134]             c <- base::c
[17:42:49.134]             inherits <- base::inherits
[17:42:49.134]             invokeRestart <- base::invokeRestart
[17:42:49.134]             length <- base::length
[17:42:49.134]             list <- base::list
[17:42:49.134]             seq.int <- base::seq.int
[17:42:49.134]             signalCondition <- base::signalCondition
[17:42:49.134]             sys.calls <- base::sys.calls
[17:42:49.134]             `[[` <- base::`[[`
[17:42:49.134]             `+` <- base::`+`
[17:42:49.134]             `<<-` <- base::`<<-`
[17:42:49.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.134]                   3L)]
[17:42:49.134]             }
[17:42:49.134]             function(cond) {
[17:42:49.134]                 is_error <- inherits(cond, "error")
[17:42:49.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.134]                   NULL)
[17:42:49.134]                 if (is_error) {
[17:42:49.134]                   sessionInformation <- function() {
[17:42:49.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.134]                       search = base::search(), system = base::Sys.info())
[17:42:49.134]                   }
[17:42:49.134]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.134]                     cond$call), session = sessionInformation(), 
[17:42:49.134]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.134]                   signalCondition(cond)
[17:42:49.134]                 }
[17:42:49.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.134]                 "immediateCondition"))) {
[17:42:49.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.134]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.134]                   if (TRUE && !signal) {
[17:42:49.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.134]                     {
[17:42:49.134]                       inherits <- base::inherits
[17:42:49.134]                       invokeRestart <- base::invokeRestart
[17:42:49.134]                       is.null <- base::is.null
[17:42:49.134]                       muffled <- FALSE
[17:42:49.134]                       if (inherits(cond, "message")) {
[17:42:49.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.134]                         if (muffled) 
[17:42:49.134]                           invokeRestart("muffleMessage")
[17:42:49.134]                       }
[17:42:49.134]                       else if (inherits(cond, "warning")) {
[17:42:49.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.134]                         if (muffled) 
[17:42:49.134]                           invokeRestart("muffleWarning")
[17:42:49.134]                       }
[17:42:49.134]                       else if (inherits(cond, "condition")) {
[17:42:49.134]                         if (!is.null(pattern)) {
[17:42:49.134]                           computeRestarts <- base::computeRestarts
[17:42:49.134]                           grepl <- base::grepl
[17:42:49.134]                           restarts <- computeRestarts(cond)
[17:42:49.134]                           for (restart in restarts) {
[17:42:49.134]                             name <- restart$name
[17:42:49.134]                             if (is.null(name)) 
[17:42:49.134]                               next
[17:42:49.134]                             if (!grepl(pattern, name)) 
[17:42:49.134]                               next
[17:42:49.134]                             invokeRestart(restart)
[17:42:49.134]                             muffled <- TRUE
[17:42:49.134]                             break
[17:42:49.134]                           }
[17:42:49.134]                         }
[17:42:49.134]                       }
[17:42:49.134]                       invisible(muffled)
[17:42:49.134]                     }
[17:42:49.134]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.134]                   }
[17:42:49.134]                 }
[17:42:49.134]                 else {
[17:42:49.134]                   if (TRUE) {
[17:42:49.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.134]                     {
[17:42:49.134]                       inherits <- base::inherits
[17:42:49.134]                       invokeRestart <- base::invokeRestart
[17:42:49.134]                       is.null <- base::is.null
[17:42:49.134]                       muffled <- FALSE
[17:42:49.134]                       if (inherits(cond, "message")) {
[17:42:49.134]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.134]                         if (muffled) 
[17:42:49.134]                           invokeRestart("muffleMessage")
[17:42:49.134]                       }
[17:42:49.134]                       else if (inherits(cond, "warning")) {
[17:42:49.134]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.134]                         if (muffled) 
[17:42:49.134]                           invokeRestart("muffleWarning")
[17:42:49.134]                       }
[17:42:49.134]                       else if (inherits(cond, "condition")) {
[17:42:49.134]                         if (!is.null(pattern)) {
[17:42:49.134]                           computeRestarts <- base::computeRestarts
[17:42:49.134]                           grepl <- base::grepl
[17:42:49.134]                           restarts <- computeRestarts(cond)
[17:42:49.134]                           for (restart in restarts) {
[17:42:49.134]                             name <- restart$name
[17:42:49.134]                             if (is.null(name)) 
[17:42:49.134]                               next
[17:42:49.134]                             if (!grepl(pattern, name)) 
[17:42:49.134]                               next
[17:42:49.134]                             invokeRestart(restart)
[17:42:49.134]                             muffled <- TRUE
[17:42:49.134]                             break
[17:42:49.134]                           }
[17:42:49.134]                         }
[17:42:49.134]                       }
[17:42:49.134]                       invisible(muffled)
[17:42:49.134]                     }
[17:42:49.134]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.134]                   }
[17:42:49.134]                 }
[17:42:49.134]             }
[17:42:49.134]         }))
[17:42:49.134]     }, error = function(ex) {
[17:42:49.134]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.134]                 ...future.rng), started = ...future.startTime, 
[17:42:49.134]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.134]             version = "1.8"), class = "FutureResult")
[17:42:49.134]     }, finally = {
[17:42:49.134]         if (!identical(...future.workdir, getwd())) 
[17:42:49.134]             setwd(...future.workdir)
[17:42:49.134]         {
[17:42:49.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.134]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.134]             }
[17:42:49.134]             base::options(...future.oldOptions)
[17:42:49.134]             if (.Platform$OS.type == "windows") {
[17:42:49.134]                 old_names <- names(...future.oldEnvVars)
[17:42:49.134]                 envs <- base::Sys.getenv()
[17:42:49.134]                 names <- names(envs)
[17:42:49.134]                 common <- intersect(names, old_names)
[17:42:49.134]                 added <- setdiff(names, old_names)
[17:42:49.134]                 removed <- setdiff(old_names, names)
[17:42:49.134]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.134]                   envs[common]]
[17:42:49.134]                 NAMES <- toupper(changed)
[17:42:49.134]                 args <- list()
[17:42:49.134]                 for (kk in seq_along(NAMES)) {
[17:42:49.134]                   name <- changed[[kk]]
[17:42:49.134]                   NAME <- NAMES[[kk]]
[17:42:49.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.134]                     next
[17:42:49.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.134]                 }
[17:42:49.134]                 NAMES <- toupper(added)
[17:42:49.134]                 for (kk in seq_along(NAMES)) {
[17:42:49.134]                   name <- added[[kk]]
[17:42:49.134]                   NAME <- NAMES[[kk]]
[17:42:49.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.134]                     next
[17:42:49.134]                   args[[name]] <- ""
[17:42:49.134]                 }
[17:42:49.134]                 NAMES <- toupper(removed)
[17:42:49.134]                 for (kk in seq_along(NAMES)) {
[17:42:49.134]                   name <- removed[[kk]]
[17:42:49.134]                   NAME <- NAMES[[kk]]
[17:42:49.134]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.134]                     next
[17:42:49.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.134]                 }
[17:42:49.134]                 if (length(args) > 0) 
[17:42:49.134]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.134]             }
[17:42:49.134]             else {
[17:42:49.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.134]             }
[17:42:49.134]             {
[17:42:49.134]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.134]                   0L) {
[17:42:49.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.134]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.134]                   base::options(opts)
[17:42:49.134]                 }
[17:42:49.134]                 {
[17:42:49.134]                   {
[17:42:49.134]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.134]                     NULL
[17:42:49.134]                   }
[17:42:49.134]                   options(future.plan = NULL)
[17:42:49.134]                   if (is.na(NA_character_)) 
[17:42:49.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.134]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.134]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.134]                     envir = parent.frame()) 
[17:42:49.134]                   {
[17:42:49.134]                     if (is.function(workers)) 
[17:42:49.134]                       workers <- workers()
[17:42:49.134]                     workers <- structure(as.integer(workers), 
[17:42:49.134]                       class = class(workers))
[17:42:49.134]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.134]                       workers >= 1)
[17:42:49.134]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.134]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.134]                     }
[17:42:49.134]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.134]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.134]                       envir = envir)
[17:42:49.134]                     if (!future$lazy) 
[17:42:49.134]                       future <- run(future)
[17:42:49.134]                     invisible(future)
[17:42:49.134]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.134]                 }
[17:42:49.134]             }
[17:42:49.134]         }
[17:42:49.134]     })
[17:42:49.134]     if (TRUE) {
[17:42:49.134]         base::sink(type = "output", split = FALSE)
[17:42:49.134]         if (TRUE) {
[17:42:49.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.134]         }
[17:42:49.134]         else {
[17:42:49.134]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.134]         }
[17:42:49.134]         base::close(...future.stdout)
[17:42:49.134]         ...future.stdout <- NULL
[17:42:49.134]     }
[17:42:49.134]     ...future.result$conditions <- ...future.conditions
[17:42:49.134]     ...future.result$finished <- base::Sys.time()
[17:42:49.134]     ...future.result
[17:42:49.134] }
[17:42:49.138] MultisessionFuture started
[17:42:49.138] - Launch lazy future ... done
[17:42:49.138] run() for ‘MultisessionFuture’ ... done
[17:42:49.184] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.184] - Validating connection of MultisessionFuture
[17:42:49.185] - received message: FutureResult
[17:42:49.185] - Received FutureResult
[17:42:49.185] - Erased future from FutureRegistry
[17:42:49.185] result() for ClusterFuture ...
[17:42:49.185] - result already collected: FutureResult
[17:42:49.186] result() for ClusterFuture ... done
[17:42:49.186] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.186] Future #1
[17:42:49.186] result() for ClusterFuture ...
[17:42:49.186] - result already collected: FutureResult
[17:42:49.186] result() for ClusterFuture ... done
[17:42:49.186] result() for ClusterFuture ...
[17:42:49.186] - result already collected: FutureResult
[17:42:49.186] result() for ClusterFuture ... done
[17:42:49.186] A MultisessionFuture was resolved
[17:42:49.187]  length: 0 (resolved future 1)
[17:42:49.187] resolve() on list ... DONE
[17:42:49.187] - globals: [1] ‘a’
[17:42:49.187] Resolving futures part of globals (recursively) ... DONE
[17:42:49.189] The total size of the 1 globals is 1.55 MiB (1629344 bytes)
[17:42:49.189] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:49.189] - globals: [1] ‘a’
[17:42:49.190] - packages: [1] ‘future’
[17:42:49.190] getGlobalsAndPackages() ... DONE
[17:42:49.190] run() for ‘Future’ ...
[17:42:49.190] - state: ‘created’
[17:42:49.190] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.205] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.205]   - Field: ‘node’
[17:42:49.205]   - Field: ‘label’
[17:42:49.205]   - Field: ‘local’
[17:42:49.205]   - Field: ‘owner’
[17:42:49.206]   - Field: ‘envir’
[17:42:49.206]   - Field: ‘workers’
[17:42:49.206]   - Field: ‘packages’
[17:42:49.206]   - Field: ‘gc’
[17:42:49.206]   - Field: ‘conditions’
[17:42:49.206]   - Field: ‘persistent’
[17:42:49.206]   - Field: ‘expr’
[17:42:49.206]   - Field: ‘uuid’
[17:42:49.206]   - Field: ‘seed’
[17:42:49.206]   - Field: ‘version’
[17:42:49.206]   - Field: ‘result’
[17:42:49.207]   - Field: ‘asynchronous’
[17:42:49.207]   - Field: ‘calls’
[17:42:49.207]   - Field: ‘globals’
[17:42:49.207]   - Field: ‘stdout’
[17:42:49.207]   - Field: ‘earlySignal’
[17:42:49.207]   - Field: ‘lazy’
[17:42:49.207]   - Field: ‘state’
[17:42:49.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.207] - Launch lazy future ...
[17:42:49.208] Packages needed by the future expression (n = 1): ‘future’
[17:42:49.208] Packages needed by future strategies (n = 0): <none>
[17:42:49.208] {
[17:42:49.208]     {
[17:42:49.208]         {
[17:42:49.208]             ...future.startTime <- base::Sys.time()
[17:42:49.208]             {
[17:42:49.208]                 {
[17:42:49.208]                   {
[17:42:49.208]                     {
[17:42:49.208]                       {
[17:42:49.208]                         base::local({
[17:42:49.208]                           has_future <- base::requireNamespace("future", 
[17:42:49.208]                             quietly = TRUE)
[17:42:49.208]                           if (has_future) {
[17:42:49.208]                             ns <- base::getNamespace("future")
[17:42:49.208]                             version <- ns[[".package"]][["version"]]
[17:42:49.208]                             if (is.null(version)) 
[17:42:49.208]                               version <- utils::packageVersion("future")
[17:42:49.208]                           }
[17:42:49.208]                           else {
[17:42:49.208]                             version <- NULL
[17:42:49.208]                           }
[17:42:49.208]                           if (!has_future || version < "1.8.0") {
[17:42:49.208]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.208]                               "", base::R.version$version.string), 
[17:42:49.208]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:49.208]                                 base::R.version$platform, 8 * 
[17:42:49.208]                                   base::.Machine$sizeof.pointer), 
[17:42:49.208]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.208]                                 "release", "version")], collapse = " "), 
[17:42:49.208]                               hostname = base::Sys.info()[["nodename"]])
[17:42:49.208]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.208]                               info)
[17:42:49.208]                             info <- base::paste(info, collapse = "; ")
[17:42:49.208]                             if (!has_future) {
[17:42:49.208]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.208]                                 info)
[17:42:49.208]                             }
[17:42:49.208]                             else {
[17:42:49.208]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.208]                                 info, version)
[17:42:49.208]                             }
[17:42:49.208]                             base::stop(msg)
[17:42:49.208]                           }
[17:42:49.208]                         })
[17:42:49.208]                       }
[17:42:49.208]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.208]                       base::options(mc.cores = 1L)
[17:42:49.208]                     }
[17:42:49.208]                     base::local({
[17:42:49.208]                       for (pkg in "future") {
[17:42:49.208]                         base::loadNamespace(pkg)
[17:42:49.208]                         base::library(pkg, character.only = TRUE)
[17:42:49.208]                       }
[17:42:49.208]                     })
[17:42:49.208]                   }
[17:42:49.208]                   options(future.plan = NULL)
[17:42:49.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.208]                 }
[17:42:49.208]                 ...future.workdir <- getwd()
[17:42:49.208]             }
[17:42:49.208]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.208]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.208]         }
[17:42:49.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.208]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.208]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.208]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.208]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.208]             base::names(...future.oldOptions))
[17:42:49.208]     }
[17:42:49.208]     if (FALSE) {
[17:42:49.208]     }
[17:42:49.208]     else {
[17:42:49.208]         if (TRUE) {
[17:42:49.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.208]                 open = "w")
[17:42:49.208]         }
[17:42:49.208]         else {
[17:42:49.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.208]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.208]         }
[17:42:49.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.208]             base::sink(type = "output", split = FALSE)
[17:42:49.208]             base::close(...future.stdout)
[17:42:49.208]         }, add = TRUE)
[17:42:49.208]     }
[17:42:49.208]     ...future.frame <- base::sys.nframe()
[17:42:49.208]     ...future.conditions <- base::list()
[17:42:49.208]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.208]     if (FALSE) {
[17:42:49.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.208]     }
[17:42:49.208]     ...future.result <- base::tryCatch({
[17:42:49.208]         base::withCallingHandlers({
[17:42:49.208]             ...future.value <- base::withVisible(base::local({
[17:42:49.208]                 ...future.makeSendCondition <- local({
[17:42:49.208]                   sendCondition <- NULL
[17:42:49.208]                   function(frame = 1L) {
[17:42:49.208]                     if (is.function(sendCondition)) 
[17:42:49.208]                       return(sendCondition)
[17:42:49.208]                     ns <- getNamespace("parallel")
[17:42:49.208]                     if (exists("sendData", mode = "function", 
[17:42:49.208]                       envir = ns)) {
[17:42:49.208]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.208]                         envir = ns)
[17:42:49.208]                       envir <- sys.frame(frame)
[17:42:49.208]                       master <- NULL
[17:42:49.208]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.208]                         !identical(envir, emptyenv())) {
[17:42:49.208]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.208]                           inherits = FALSE)) {
[17:42:49.208]                           master <- get("master", mode = "list", 
[17:42:49.208]                             envir = envir, inherits = FALSE)
[17:42:49.208]                           if (inherits(master, c("SOCKnode", 
[17:42:49.208]                             "SOCK0node"))) {
[17:42:49.208]                             sendCondition <<- function(cond) {
[17:42:49.208]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.208]                                 success = TRUE)
[17:42:49.208]                               parallel_sendData(master, data)
[17:42:49.208]                             }
[17:42:49.208]                             return(sendCondition)
[17:42:49.208]                           }
[17:42:49.208]                         }
[17:42:49.208]                         frame <- frame + 1L
[17:42:49.208]                         envir <- sys.frame(frame)
[17:42:49.208]                       }
[17:42:49.208]                     }
[17:42:49.208]                     sendCondition <<- function(cond) NULL
[17:42:49.208]                   }
[17:42:49.208]                 })
[17:42:49.208]                 withCallingHandlers({
[17:42:49.208]                   value(a) + 1
[17:42:49.208]                 }, immediateCondition = function(cond) {
[17:42:49.208]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.208]                   sendCondition(cond)
[17:42:49.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.208]                   {
[17:42:49.208]                     inherits <- base::inherits
[17:42:49.208]                     invokeRestart <- base::invokeRestart
[17:42:49.208]                     is.null <- base::is.null
[17:42:49.208]                     muffled <- FALSE
[17:42:49.208]                     if (inherits(cond, "message")) {
[17:42:49.208]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.208]                       if (muffled) 
[17:42:49.208]                         invokeRestart("muffleMessage")
[17:42:49.208]                     }
[17:42:49.208]                     else if (inherits(cond, "warning")) {
[17:42:49.208]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.208]                       if (muffled) 
[17:42:49.208]                         invokeRestart("muffleWarning")
[17:42:49.208]                     }
[17:42:49.208]                     else if (inherits(cond, "condition")) {
[17:42:49.208]                       if (!is.null(pattern)) {
[17:42:49.208]                         computeRestarts <- base::computeRestarts
[17:42:49.208]                         grepl <- base::grepl
[17:42:49.208]                         restarts <- computeRestarts(cond)
[17:42:49.208]                         for (restart in restarts) {
[17:42:49.208]                           name <- restart$name
[17:42:49.208]                           if (is.null(name)) 
[17:42:49.208]                             next
[17:42:49.208]                           if (!grepl(pattern, name)) 
[17:42:49.208]                             next
[17:42:49.208]                           invokeRestart(restart)
[17:42:49.208]                           muffled <- TRUE
[17:42:49.208]                           break
[17:42:49.208]                         }
[17:42:49.208]                       }
[17:42:49.208]                     }
[17:42:49.208]                     invisible(muffled)
[17:42:49.208]                   }
[17:42:49.208]                   muffleCondition(cond)
[17:42:49.208]                 })
[17:42:49.208]             }))
[17:42:49.208]             future::FutureResult(value = ...future.value$value, 
[17:42:49.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.208]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.208]                     ...future.globalenv.names))
[17:42:49.208]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.208]         }, condition = base::local({
[17:42:49.208]             c <- base::c
[17:42:49.208]             inherits <- base::inherits
[17:42:49.208]             invokeRestart <- base::invokeRestart
[17:42:49.208]             length <- base::length
[17:42:49.208]             list <- base::list
[17:42:49.208]             seq.int <- base::seq.int
[17:42:49.208]             signalCondition <- base::signalCondition
[17:42:49.208]             sys.calls <- base::sys.calls
[17:42:49.208]             `[[` <- base::`[[`
[17:42:49.208]             `+` <- base::`+`
[17:42:49.208]             `<<-` <- base::`<<-`
[17:42:49.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.208]                   3L)]
[17:42:49.208]             }
[17:42:49.208]             function(cond) {
[17:42:49.208]                 is_error <- inherits(cond, "error")
[17:42:49.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.208]                   NULL)
[17:42:49.208]                 if (is_error) {
[17:42:49.208]                   sessionInformation <- function() {
[17:42:49.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.208]                       search = base::search(), system = base::Sys.info())
[17:42:49.208]                   }
[17:42:49.208]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.208]                     cond$call), session = sessionInformation(), 
[17:42:49.208]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.208]                   signalCondition(cond)
[17:42:49.208]                 }
[17:42:49.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.208]                 "immediateCondition"))) {
[17:42:49.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.208]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.208]                   if (TRUE && !signal) {
[17:42:49.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.208]                     {
[17:42:49.208]                       inherits <- base::inherits
[17:42:49.208]                       invokeRestart <- base::invokeRestart
[17:42:49.208]                       is.null <- base::is.null
[17:42:49.208]                       muffled <- FALSE
[17:42:49.208]                       if (inherits(cond, "message")) {
[17:42:49.208]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.208]                         if (muffled) 
[17:42:49.208]                           invokeRestart("muffleMessage")
[17:42:49.208]                       }
[17:42:49.208]                       else if (inherits(cond, "warning")) {
[17:42:49.208]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.208]                         if (muffled) 
[17:42:49.208]                           invokeRestart("muffleWarning")
[17:42:49.208]                       }
[17:42:49.208]                       else if (inherits(cond, "condition")) {
[17:42:49.208]                         if (!is.null(pattern)) {
[17:42:49.208]                           computeRestarts <- base::computeRestarts
[17:42:49.208]                           grepl <- base::grepl
[17:42:49.208]                           restarts <- computeRestarts(cond)
[17:42:49.208]                           for (restart in restarts) {
[17:42:49.208]                             name <- restart$name
[17:42:49.208]                             if (is.null(name)) 
[17:42:49.208]                               next
[17:42:49.208]                             if (!grepl(pattern, name)) 
[17:42:49.208]                               next
[17:42:49.208]                             invokeRestart(restart)
[17:42:49.208]                             muffled <- TRUE
[17:42:49.208]                             break
[17:42:49.208]                           }
[17:42:49.208]                         }
[17:42:49.208]                       }
[17:42:49.208]                       invisible(muffled)
[17:42:49.208]                     }
[17:42:49.208]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.208]                   }
[17:42:49.208]                 }
[17:42:49.208]                 else {
[17:42:49.208]                   if (TRUE) {
[17:42:49.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.208]                     {
[17:42:49.208]                       inherits <- base::inherits
[17:42:49.208]                       invokeRestart <- base::invokeRestart
[17:42:49.208]                       is.null <- base::is.null
[17:42:49.208]                       muffled <- FALSE
[17:42:49.208]                       if (inherits(cond, "message")) {
[17:42:49.208]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.208]                         if (muffled) 
[17:42:49.208]                           invokeRestart("muffleMessage")
[17:42:49.208]                       }
[17:42:49.208]                       else if (inherits(cond, "warning")) {
[17:42:49.208]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.208]                         if (muffled) 
[17:42:49.208]                           invokeRestart("muffleWarning")
[17:42:49.208]                       }
[17:42:49.208]                       else if (inherits(cond, "condition")) {
[17:42:49.208]                         if (!is.null(pattern)) {
[17:42:49.208]                           computeRestarts <- base::computeRestarts
[17:42:49.208]                           grepl <- base::grepl
[17:42:49.208]                           restarts <- computeRestarts(cond)
[17:42:49.208]                           for (restart in restarts) {
[17:42:49.208]                             name <- restart$name
[17:42:49.208]                             if (is.null(name)) 
[17:42:49.208]                               next
[17:42:49.208]                             if (!grepl(pattern, name)) 
[17:42:49.208]                               next
[17:42:49.208]                             invokeRestart(restart)
[17:42:49.208]                             muffled <- TRUE
[17:42:49.208]                             break
[17:42:49.208]                           }
[17:42:49.208]                         }
[17:42:49.208]                       }
[17:42:49.208]                       invisible(muffled)
[17:42:49.208]                     }
[17:42:49.208]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.208]                   }
[17:42:49.208]                 }
[17:42:49.208]             }
[17:42:49.208]         }))
[17:42:49.208]     }, error = function(ex) {
[17:42:49.208]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.208]                 ...future.rng), started = ...future.startTime, 
[17:42:49.208]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.208]             version = "1.8"), class = "FutureResult")
[17:42:49.208]     }, finally = {
[17:42:49.208]         if (!identical(...future.workdir, getwd())) 
[17:42:49.208]             setwd(...future.workdir)
[17:42:49.208]         {
[17:42:49.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.208]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.208]             }
[17:42:49.208]             base::options(...future.oldOptions)
[17:42:49.208]             if (.Platform$OS.type == "windows") {
[17:42:49.208]                 old_names <- names(...future.oldEnvVars)
[17:42:49.208]                 envs <- base::Sys.getenv()
[17:42:49.208]                 names <- names(envs)
[17:42:49.208]                 common <- intersect(names, old_names)
[17:42:49.208]                 added <- setdiff(names, old_names)
[17:42:49.208]                 removed <- setdiff(old_names, names)
[17:42:49.208]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.208]                   envs[common]]
[17:42:49.208]                 NAMES <- toupper(changed)
[17:42:49.208]                 args <- list()
[17:42:49.208]                 for (kk in seq_along(NAMES)) {
[17:42:49.208]                   name <- changed[[kk]]
[17:42:49.208]                   NAME <- NAMES[[kk]]
[17:42:49.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.208]                     next
[17:42:49.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.208]                 }
[17:42:49.208]                 NAMES <- toupper(added)
[17:42:49.208]                 for (kk in seq_along(NAMES)) {
[17:42:49.208]                   name <- added[[kk]]
[17:42:49.208]                   NAME <- NAMES[[kk]]
[17:42:49.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.208]                     next
[17:42:49.208]                   args[[name]] <- ""
[17:42:49.208]                 }
[17:42:49.208]                 NAMES <- toupper(removed)
[17:42:49.208]                 for (kk in seq_along(NAMES)) {
[17:42:49.208]                   name <- removed[[kk]]
[17:42:49.208]                   NAME <- NAMES[[kk]]
[17:42:49.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.208]                     next
[17:42:49.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.208]                 }
[17:42:49.208]                 if (length(args) > 0) 
[17:42:49.208]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.208]             }
[17:42:49.208]             else {
[17:42:49.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.208]             }
[17:42:49.208]             {
[17:42:49.208]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.208]                   0L) {
[17:42:49.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.208]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.208]                   base::options(opts)
[17:42:49.208]                 }
[17:42:49.208]                 {
[17:42:49.208]                   {
[17:42:49.208]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.208]                     NULL
[17:42:49.208]                   }
[17:42:49.208]                   options(future.plan = NULL)
[17:42:49.208]                   if (is.na(NA_character_)) 
[17:42:49.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.208]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.208]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.208]                     envir = parent.frame()) 
[17:42:49.208]                   {
[17:42:49.208]                     if (is.function(workers)) 
[17:42:49.208]                       workers <- workers()
[17:42:49.208]                     workers <- structure(as.integer(workers), 
[17:42:49.208]                       class = class(workers))
[17:42:49.208]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.208]                       workers >= 1)
[17:42:49.208]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.208]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.208]                     }
[17:42:49.208]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.208]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.208]                       envir = envir)
[17:42:49.208]                     if (!future$lazy) 
[17:42:49.208]                       future <- run(future)
[17:42:49.208]                     invisible(future)
[17:42:49.208]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.208]                 }
[17:42:49.208]             }
[17:42:49.208]         }
[17:42:49.208]     })
[17:42:49.208]     if (TRUE) {
[17:42:49.208]         base::sink(type = "output", split = FALSE)
[17:42:49.208]         if (TRUE) {
[17:42:49.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.208]         }
[17:42:49.208]         else {
[17:42:49.208]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.208]         }
[17:42:49.208]         base::close(...future.stdout)
[17:42:49.208]         ...future.stdout <- NULL
[17:42:49.208]     }
[17:42:49.208]     ...future.result$conditions <- ...future.conditions
[17:42:49.208]     ...future.result$finished <- base::Sys.time()
[17:42:49.208]     ...future.result
[17:42:49.208] }
[17:42:49.211] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[17:42:49.213] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[17:42:49.267] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[17:42:49.267] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[17:42:49.268] MultisessionFuture started
[17:42:49.268] - Launch lazy future ... done
[17:42:49.268] run() for ‘MultisessionFuture’ ... done
[17:42:49.268] result() for ClusterFuture ...
[17:42:49.268] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.269] - Validating connection of MultisessionFuture
[17:42:49.317] - received message: FutureResult
[17:42:49.317] - Received FutureResult
[17:42:49.317] - Erased future from FutureRegistry
[17:42:49.317] result() for ClusterFuture ...
[17:42:49.317] - result already collected: FutureResult
[17:42:49.317] result() for ClusterFuture ... done
[17:42:49.317] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.317] result() for ClusterFuture ... done
[17:42:49.318] result() for ClusterFuture ...
[17:42:49.318] - result already collected: FutureResult
[17:42:49.318] result() for ClusterFuture ... done
value(b) = 2
[17:42:49.318] result() for ClusterFuture ...
[17:42:49.318] - result already collected: FutureResult
[17:42:49.318] result() for ClusterFuture ... done
[17:42:49.318] result() for ClusterFuture ...
[17:42:49.318] - result already collected: FutureResult
[17:42:49.318] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.319] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.319] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.319] 
[17:42:49.319] Searching for globals ... DONE
[17:42:49.319] - globals: [0] <none>
[17:42:49.320] getGlobalsAndPackages() ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.320] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.320] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.321] - globals found: [3] ‘+’, ‘value’, ‘a’
[17:42:49.321] Searching for globals ... DONE
[17:42:49.321] Resolving globals: TRUE
[17:42:49.321] Resolving any globals that are futures ...
[17:42:49.321] - globals: [3] ‘+’, ‘value’, ‘a’
[17:42:49.321] Resolving any globals that are futures ... DONE
[17:42:49.322] Resolving futures part of globals (recursively) ...
[17:42:49.322] resolve() on list ...
[17:42:49.322]  recursive: 99
[17:42:49.322]  length: 1
[17:42:49.322]  elements: ‘a’
[17:42:49.322] run() for ‘Future’ ...
[17:42:49.322] - state: ‘created’
[17:42:49.323] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.337] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.337]   - Field: ‘node’
[17:42:49.337]   - Field: ‘label’
[17:42:49.337]   - Field: ‘local’
[17:42:49.338]   - Field: ‘owner’
[17:42:49.338]   - Field: ‘envir’
[17:42:49.338]   - Field: ‘workers’
[17:42:49.338]   - Field: ‘packages’
[17:42:49.338]   - Field: ‘gc’
[17:42:49.338]   - Field: ‘conditions’
[17:42:49.338]   - Field: ‘persistent’
[17:42:49.338]   - Field: ‘expr’
[17:42:49.338]   - Field: ‘uuid’
[17:42:49.338]   - Field: ‘seed’
[17:42:49.339]   - Field: ‘version’
[17:42:49.339]   - Field: ‘result’
[17:42:49.339]   - Field: ‘asynchronous’
[17:42:49.339]   - Field: ‘calls’
[17:42:49.339]   - Field: ‘globals’
[17:42:49.339]   - Field: ‘stdout’
[17:42:49.339]   - Field: ‘earlySignal’
[17:42:49.339]   - Field: ‘lazy’
[17:42:49.339]   - Field: ‘state’
[17:42:49.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.340] - Launch lazy future ...
[17:42:49.340] Packages needed by the future expression (n = 0): <none>
[17:42:49.340] Packages needed by future strategies (n = 0): <none>
[17:42:49.340] {
[17:42:49.340]     {
[17:42:49.340]         {
[17:42:49.340]             ...future.startTime <- base::Sys.time()
[17:42:49.340]             {
[17:42:49.340]                 {
[17:42:49.340]                   {
[17:42:49.340]                     {
[17:42:49.340]                       base::local({
[17:42:49.340]                         has_future <- base::requireNamespace("future", 
[17:42:49.340]                           quietly = TRUE)
[17:42:49.340]                         if (has_future) {
[17:42:49.340]                           ns <- base::getNamespace("future")
[17:42:49.340]                           version <- ns[[".package"]][["version"]]
[17:42:49.340]                           if (is.null(version)) 
[17:42:49.340]                             version <- utils::packageVersion("future")
[17:42:49.340]                         }
[17:42:49.340]                         else {
[17:42:49.340]                           version <- NULL
[17:42:49.340]                         }
[17:42:49.340]                         if (!has_future || version < "1.8.0") {
[17:42:49.340]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.340]                             "", base::R.version$version.string), 
[17:42:49.340]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:49.340]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:49.340]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.340]                               "release", "version")], collapse = " "), 
[17:42:49.340]                             hostname = base::Sys.info()[["nodename"]])
[17:42:49.340]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.340]                             info)
[17:42:49.340]                           info <- base::paste(info, collapse = "; ")
[17:42:49.340]                           if (!has_future) {
[17:42:49.340]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.340]                               info)
[17:42:49.340]                           }
[17:42:49.340]                           else {
[17:42:49.340]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.340]                               info, version)
[17:42:49.340]                           }
[17:42:49.340]                           base::stop(msg)
[17:42:49.340]                         }
[17:42:49.340]                       })
[17:42:49.340]                     }
[17:42:49.340]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.340]                     base::options(mc.cores = 1L)
[17:42:49.340]                   }
[17:42:49.340]                   options(future.plan = NULL)
[17:42:49.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.340]                 }
[17:42:49.340]                 ...future.workdir <- getwd()
[17:42:49.340]             }
[17:42:49.340]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.340]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.340]         }
[17:42:49.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.340]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.340]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.340]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.340]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.340]             base::names(...future.oldOptions))
[17:42:49.340]     }
[17:42:49.340]     if (FALSE) {
[17:42:49.340]     }
[17:42:49.340]     else {
[17:42:49.340]         if (TRUE) {
[17:42:49.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.340]                 open = "w")
[17:42:49.340]         }
[17:42:49.340]         else {
[17:42:49.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.340]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.340]         }
[17:42:49.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.340]             base::sink(type = "output", split = FALSE)
[17:42:49.340]             base::close(...future.stdout)
[17:42:49.340]         }, add = TRUE)
[17:42:49.340]     }
[17:42:49.340]     ...future.frame <- base::sys.nframe()
[17:42:49.340]     ...future.conditions <- base::list()
[17:42:49.340]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.340]     if (FALSE) {
[17:42:49.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.340]     }
[17:42:49.340]     ...future.result <- base::tryCatch({
[17:42:49.340]         base::withCallingHandlers({
[17:42:49.340]             ...future.value <- base::withVisible(base::local({
[17:42:49.340]                 ...future.makeSendCondition <- local({
[17:42:49.340]                   sendCondition <- NULL
[17:42:49.340]                   function(frame = 1L) {
[17:42:49.340]                     if (is.function(sendCondition)) 
[17:42:49.340]                       return(sendCondition)
[17:42:49.340]                     ns <- getNamespace("parallel")
[17:42:49.340]                     if (exists("sendData", mode = "function", 
[17:42:49.340]                       envir = ns)) {
[17:42:49.340]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.340]                         envir = ns)
[17:42:49.340]                       envir <- sys.frame(frame)
[17:42:49.340]                       master <- NULL
[17:42:49.340]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.340]                         !identical(envir, emptyenv())) {
[17:42:49.340]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.340]                           inherits = FALSE)) {
[17:42:49.340]                           master <- get("master", mode = "list", 
[17:42:49.340]                             envir = envir, inherits = FALSE)
[17:42:49.340]                           if (inherits(master, c("SOCKnode", 
[17:42:49.340]                             "SOCK0node"))) {
[17:42:49.340]                             sendCondition <<- function(cond) {
[17:42:49.340]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.340]                                 success = TRUE)
[17:42:49.340]                               parallel_sendData(master, data)
[17:42:49.340]                             }
[17:42:49.340]                             return(sendCondition)
[17:42:49.340]                           }
[17:42:49.340]                         }
[17:42:49.340]                         frame <- frame + 1L
[17:42:49.340]                         envir <- sys.frame(frame)
[17:42:49.340]                       }
[17:42:49.340]                     }
[17:42:49.340]                     sendCondition <<- function(cond) NULL
[17:42:49.340]                   }
[17:42:49.340]                 })
[17:42:49.340]                 withCallingHandlers({
[17:42:49.340]                   1
[17:42:49.340]                 }, immediateCondition = function(cond) {
[17:42:49.340]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.340]                   sendCondition(cond)
[17:42:49.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.340]                   {
[17:42:49.340]                     inherits <- base::inherits
[17:42:49.340]                     invokeRestart <- base::invokeRestart
[17:42:49.340]                     is.null <- base::is.null
[17:42:49.340]                     muffled <- FALSE
[17:42:49.340]                     if (inherits(cond, "message")) {
[17:42:49.340]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.340]                       if (muffled) 
[17:42:49.340]                         invokeRestart("muffleMessage")
[17:42:49.340]                     }
[17:42:49.340]                     else if (inherits(cond, "warning")) {
[17:42:49.340]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.340]                       if (muffled) 
[17:42:49.340]                         invokeRestart("muffleWarning")
[17:42:49.340]                     }
[17:42:49.340]                     else if (inherits(cond, "condition")) {
[17:42:49.340]                       if (!is.null(pattern)) {
[17:42:49.340]                         computeRestarts <- base::computeRestarts
[17:42:49.340]                         grepl <- base::grepl
[17:42:49.340]                         restarts <- computeRestarts(cond)
[17:42:49.340]                         for (restart in restarts) {
[17:42:49.340]                           name <- restart$name
[17:42:49.340]                           if (is.null(name)) 
[17:42:49.340]                             next
[17:42:49.340]                           if (!grepl(pattern, name)) 
[17:42:49.340]                             next
[17:42:49.340]                           invokeRestart(restart)
[17:42:49.340]                           muffled <- TRUE
[17:42:49.340]                           break
[17:42:49.340]                         }
[17:42:49.340]                       }
[17:42:49.340]                     }
[17:42:49.340]                     invisible(muffled)
[17:42:49.340]                   }
[17:42:49.340]                   muffleCondition(cond)
[17:42:49.340]                 })
[17:42:49.340]             }))
[17:42:49.340]             future::FutureResult(value = ...future.value$value, 
[17:42:49.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.340]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.340]                     ...future.globalenv.names))
[17:42:49.340]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.340]         }, condition = base::local({
[17:42:49.340]             c <- base::c
[17:42:49.340]             inherits <- base::inherits
[17:42:49.340]             invokeRestart <- base::invokeRestart
[17:42:49.340]             length <- base::length
[17:42:49.340]             list <- base::list
[17:42:49.340]             seq.int <- base::seq.int
[17:42:49.340]             signalCondition <- base::signalCondition
[17:42:49.340]             sys.calls <- base::sys.calls
[17:42:49.340]             `[[` <- base::`[[`
[17:42:49.340]             `+` <- base::`+`
[17:42:49.340]             `<<-` <- base::`<<-`
[17:42:49.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.340]                   3L)]
[17:42:49.340]             }
[17:42:49.340]             function(cond) {
[17:42:49.340]                 is_error <- inherits(cond, "error")
[17:42:49.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.340]                   NULL)
[17:42:49.340]                 if (is_error) {
[17:42:49.340]                   sessionInformation <- function() {
[17:42:49.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.340]                       search = base::search(), system = base::Sys.info())
[17:42:49.340]                   }
[17:42:49.340]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.340]                     cond$call), session = sessionInformation(), 
[17:42:49.340]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.340]                   signalCondition(cond)
[17:42:49.340]                 }
[17:42:49.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.340]                 "immediateCondition"))) {
[17:42:49.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.340]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.340]                   if (TRUE && !signal) {
[17:42:49.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.340]                     {
[17:42:49.340]                       inherits <- base::inherits
[17:42:49.340]                       invokeRestart <- base::invokeRestart
[17:42:49.340]                       is.null <- base::is.null
[17:42:49.340]                       muffled <- FALSE
[17:42:49.340]                       if (inherits(cond, "message")) {
[17:42:49.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.340]                         if (muffled) 
[17:42:49.340]                           invokeRestart("muffleMessage")
[17:42:49.340]                       }
[17:42:49.340]                       else if (inherits(cond, "warning")) {
[17:42:49.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.340]                         if (muffled) 
[17:42:49.340]                           invokeRestart("muffleWarning")
[17:42:49.340]                       }
[17:42:49.340]                       else if (inherits(cond, "condition")) {
[17:42:49.340]                         if (!is.null(pattern)) {
[17:42:49.340]                           computeRestarts <- base::computeRestarts
[17:42:49.340]                           grepl <- base::grepl
[17:42:49.340]                           restarts <- computeRestarts(cond)
[17:42:49.340]                           for (restart in restarts) {
[17:42:49.340]                             name <- restart$name
[17:42:49.340]                             if (is.null(name)) 
[17:42:49.340]                               next
[17:42:49.340]                             if (!grepl(pattern, name)) 
[17:42:49.340]                               next
[17:42:49.340]                             invokeRestart(restart)
[17:42:49.340]                             muffled <- TRUE
[17:42:49.340]                             break
[17:42:49.340]                           }
[17:42:49.340]                         }
[17:42:49.340]                       }
[17:42:49.340]                       invisible(muffled)
[17:42:49.340]                     }
[17:42:49.340]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.340]                   }
[17:42:49.340]                 }
[17:42:49.340]                 else {
[17:42:49.340]                   if (TRUE) {
[17:42:49.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.340]                     {
[17:42:49.340]                       inherits <- base::inherits
[17:42:49.340]                       invokeRestart <- base::invokeRestart
[17:42:49.340]                       is.null <- base::is.null
[17:42:49.340]                       muffled <- FALSE
[17:42:49.340]                       if (inherits(cond, "message")) {
[17:42:49.340]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.340]                         if (muffled) 
[17:42:49.340]                           invokeRestart("muffleMessage")
[17:42:49.340]                       }
[17:42:49.340]                       else if (inherits(cond, "warning")) {
[17:42:49.340]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.340]                         if (muffled) 
[17:42:49.340]                           invokeRestart("muffleWarning")
[17:42:49.340]                       }
[17:42:49.340]                       else if (inherits(cond, "condition")) {
[17:42:49.340]                         if (!is.null(pattern)) {
[17:42:49.340]                           computeRestarts <- base::computeRestarts
[17:42:49.340]                           grepl <- base::grepl
[17:42:49.340]                           restarts <- computeRestarts(cond)
[17:42:49.340]                           for (restart in restarts) {
[17:42:49.340]                             name <- restart$name
[17:42:49.340]                             if (is.null(name)) 
[17:42:49.340]                               next
[17:42:49.340]                             if (!grepl(pattern, name)) 
[17:42:49.340]                               next
[17:42:49.340]                             invokeRestart(restart)
[17:42:49.340]                             muffled <- TRUE
[17:42:49.340]                             break
[17:42:49.340]                           }
[17:42:49.340]                         }
[17:42:49.340]                       }
[17:42:49.340]                       invisible(muffled)
[17:42:49.340]                     }
[17:42:49.340]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.340]                   }
[17:42:49.340]                 }
[17:42:49.340]             }
[17:42:49.340]         }))
[17:42:49.340]     }, error = function(ex) {
[17:42:49.340]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.340]                 ...future.rng), started = ...future.startTime, 
[17:42:49.340]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.340]             version = "1.8"), class = "FutureResult")
[17:42:49.340]     }, finally = {
[17:42:49.340]         if (!identical(...future.workdir, getwd())) 
[17:42:49.340]             setwd(...future.workdir)
[17:42:49.340]         {
[17:42:49.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.340]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.340]             }
[17:42:49.340]             base::options(...future.oldOptions)
[17:42:49.340]             if (.Platform$OS.type == "windows") {
[17:42:49.340]                 old_names <- names(...future.oldEnvVars)
[17:42:49.340]                 envs <- base::Sys.getenv()
[17:42:49.340]                 names <- names(envs)
[17:42:49.340]                 common <- intersect(names, old_names)
[17:42:49.340]                 added <- setdiff(names, old_names)
[17:42:49.340]                 removed <- setdiff(old_names, names)
[17:42:49.340]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.340]                   envs[common]]
[17:42:49.340]                 NAMES <- toupper(changed)
[17:42:49.340]                 args <- list()
[17:42:49.340]                 for (kk in seq_along(NAMES)) {
[17:42:49.340]                   name <- changed[[kk]]
[17:42:49.340]                   NAME <- NAMES[[kk]]
[17:42:49.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.340]                     next
[17:42:49.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.340]                 }
[17:42:49.340]                 NAMES <- toupper(added)
[17:42:49.340]                 for (kk in seq_along(NAMES)) {
[17:42:49.340]                   name <- added[[kk]]
[17:42:49.340]                   NAME <- NAMES[[kk]]
[17:42:49.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.340]                     next
[17:42:49.340]                   args[[name]] <- ""
[17:42:49.340]                 }
[17:42:49.340]                 NAMES <- toupper(removed)
[17:42:49.340]                 for (kk in seq_along(NAMES)) {
[17:42:49.340]                   name <- removed[[kk]]
[17:42:49.340]                   NAME <- NAMES[[kk]]
[17:42:49.340]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.340]                     next
[17:42:49.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.340]                 }
[17:42:49.340]                 if (length(args) > 0) 
[17:42:49.340]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.340]             }
[17:42:49.340]             else {
[17:42:49.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.340]             }
[17:42:49.340]             {
[17:42:49.340]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.340]                   0L) {
[17:42:49.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.340]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.340]                   base::options(opts)
[17:42:49.340]                 }
[17:42:49.340]                 {
[17:42:49.340]                   {
[17:42:49.340]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.340]                     NULL
[17:42:49.340]                   }
[17:42:49.340]                   options(future.plan = NULL)
[17:42:49.340]                   if (is.na(NA_character_)) 
[17:42:49.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.340]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.340]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.340]                     envir = parent.frame()) 
[17:42:49.340]                   {
[17:42:49.340]                     if (is.function(workers)) 
[17:42:49.340]                       workers <- workers()
[17:42:49.340]                     workers <- structure(as.integer(workers), 
[17:42:49.340]                       class = class(workers))
[17:42:49.340]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.340]                       workers >= 1)
[17:42:49.340]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.340]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.340]                     }
[17:42:49.340]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.340]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.340]                       envir = envir)
[17:42:49.340]                     if (!future$lazy) 
[17:42:49.340]                       future <- run(future)
[17:42:49.340]                     invisible(future)
[17:42:49.340]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.340]                 }
[17:42:49.340]             }
[17:42:49.340]         }
[17:42:49.340]     })
[17:42:49.340]     if (TRUE) {
[17:42:49.340]         base::sink(type = "output", split = FALSE)
[17:42:49.340]         if (TRUE) {
[17:42:49.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.340]         }
[17:42:49.340]         else {
[17:42:49.340]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.340]         }
[17:42:49.340]         base::close(...future.stdout)
[17:42:49.340]         ...future.stdout <- NULL
[17:42:49.340]     }
[17:42:49.340]     ...future.result$conditions <- ...future.conditions
[17:42:49.340]     ...future.result$finished <- base::Sys.time()
[17:42:49.340]     ...future.result
[17:42:49.340] }
[17:42:49.344] MultisessionFuture started
[17:42:49.344] - Launch lazy future ... done
[17:42:49.344] run() for ‘MultisessionFuture’ ... done
[17:42:49.406] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.407] - Validating connection of MultisessionFuture
[17:42:49.407] - received message: FutureResult
[17:42:49.407] - Received FutureResult
[17:42:49.407] - Erased future from FutureRegistry
[17:42:49.407] result() for ClusterFuture ...
[17:42:49.407] - result already collected: FutureResult
[17:42:49.407] result() for ClusterFuture ... done
[17:42:49.408] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.408] Future #1
[17:42:49.408] result() for ClusterFuture ...
[17:42:49.408] - result already collected: FutureResult
[17:42:49.408] result() for ClusterFuture ... done
[17:42:49.408] result() for ClusterFuture ...
[17:42:49.408] - result already collected: FutureResult
[17:42:49.408] result() for ClusterFuture ... done
[17:42:49.408] A MultisessionFuture was resolved
[17:42:49.408]  length: 0 (resolved future 1)
[17:42:49.409] resolve() on list ... DONE
[17:42:49.409] - globals: [1] ‘a’
[17:42:49.409] Resolving futures part of globals (recursively) ... DONE
[17:42:49.411] The total size of the 1 globals is 1.55 MiB (1629344 bytes)
[17:42:49.411] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[17:42:49.411] - globals: [1] ‘a’
[17:42:49.411] - packages: [1] ‘future’
[17:42:49.412] getGlobalsAndPackages() ... DONE
[17:42:49.412] run() for ‘Future’ ...
[17:42:49.412] - state: ‘created’
[17:42:49.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.429] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.429]   - Field: ‘node’
[17:42:49.429]   - Field: ‘label’
[17:42:49.429]   - Field: ‘local’
[17:42:49.429]   - Field: ‘owner’
[17:42:49.429]   - Field: ‘envir’
[17:42:49.429]   - Field: ‘workers’
[17:42:49.429]   - Field: ‘packages’
[17:42:49.430]   - Field: ‘gc’
[17:42:49.430]   - Field: ‘conditions’
[17:42:49.430]   - Field: ‘persistent’
[17:42:49.430]   - Field: ‘expr’
[17:42:49.430]   - Field: ‘uuid’
[17:42:49.430]   - Field: ‘seed’
[17:42:49.430]   - Field: ‘version’
[17:42:49.430]   - Field: ‘result’
[17:42:49.430]   - Field: ‘asynchronous’
[17:42:49.430]   - Field: ‘calls’
[17:42:49.430]   - Field: ‘globals’
[17:42:49.431]   - Field: ‘stdout’
[17:42:49.431]   - Field: ‘earlySignal’
[17:42:49.431]   - Field: ‘lazy’
[17:42:49.431]   - Field: ‘state’
[17:42:49.431] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.431] - Launch lazy future ...
[17:42:49.431] Packages needed by the future expression (n = 1): ‘future’
[17:42:49.431] Packages needed by future strategies (n = 0): <none>
[17:42:49.432] {
[17:42:49.432]     {
[17:42:49.432]         {
[17:42:49.432]             ...future.startTime <- base::Sys.time()
[17:42:49.432]             {
[17:42:49.432]                 {
[17:42:49.432]                   {
[17:42:49.432]                     {
[17:42:49.432]                       {
[17:42:49.432]                         base::local({
[17:42:49.432]                           has_future <- base::requireNamespace("future", 
[17:42:49.432]                             quietly = TRUE)
[17:42:49.432]                           if (has_future) {
[17:42:49.432]                             ns <- base::getNamespace("future")
[17:42:49.432]                             version <- ns[[".package"]][["version"]]
[17:42:49.432]                             if (is.null(version)) 
[17:42:49.432]                               version <- utils::packageVersion("future")
[17:42:49.432]                           }
[17:42:49.432]                           else {
[17:42:49.432]                             version <- NULL
[17:42:49.432]                           }
[17:42:49.432]                           if (!has_future || version < "1.8.0") {
[17:42:49.432]                             info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.432]                               "", base::R.version$version.string), 
[17:42:49.432]                               platform = base::sprintf("%s (%s-bit)", 
[17:42:49.432]                                 base::R.version$platform, 8 * 
[17:42:49.432]                                   base::.Machine$sizeof.pointer), 
[17:42:49.432]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.432]                                 "release", "version")], collapse = " "), 
[17:42:49.432]                               hostname = base::Sys.info()[["nodename"]])
[17:42:49.432]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.432]                               info)
[17:42:49.432]                             info <- base::paste(info, collapse = "; ")
[17:42:49.432]                             if (!has_future) {
[17:42:49.432]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.432]                                 info)
[17:42:49.432]                             }
[17:42:49.432]                             else {
[17:42:49.432]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.432]                                 info, version)
[17:42:49.432]                             }
[17:42:49.432]                             base::stop(msg)
[17:42:49.432]                           }
[17:42:49.432]                         })
[17:42:49.432]                       }
[17:42:49.432]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.432]                       base::options(mc.cores = 1L)
[17:42:49.432]                     }
[17:42:49.432]                     base::local({
[17:42:49.432]                       for (pkg in "future") {
[17:42:49.432]                         base::loadNamespace(pkg)
[17:42:49.432]                         base::library(pkg, character.only = TRUE)
[17:42:49.432]                       }
[17:42:49.432]                     })
[17:42:49.432]                   }
[17:42:49.432]                   options(future.plan = NULL)
[17:42:49.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.432]                 }
[17:42:49.432]                 ...future.workdir <- getwd()
[17:42:49.432]             }
[17:42:49.432]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.432]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.432]         }
[17:42:49.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.432]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.432]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.432]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.432]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.432]             base::names(...future.oldOptions))
[17:42:49.432]     }
[17:42:49.432]     if (FALSE) {
[17:42:49.432]     }
[17:42:49.432]     else {
[17:42:49.432]         if (TRUE) {
[17:42:49.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.432]                 open = "w")
[17:42:49.432]         }
[17:42:49.432]         else {
[17:42:49.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.432]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.432]         }
[17:42:49.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.432]             base::sink(type = "output", split = FALSE)
[17:42:49.432]             base::close(...future.stdout)
[17:42:49.432]         }, add = TRUE)
[17:42:49.432]     }
[17:42:49.432]     ...future.frame <- base::sys.nframe()
[17:42:49.432]     ...future.conditions <- base::list()
[17:42:49.432]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.432]     if (FALSE) {
[17:42:49.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.432]     }
[17:42:49.432]     ...future.result <- base::tryCatch({
[17:42:49.432]         base::withCallingHandlers({
[17:42:49.432]             ...future.value <- base::withVisible(base::local({
[17:42:49.432]                 ...future.makeSendCondition <- local({
[17:42:49.432]                   sendCondition <- NULL
[17:42:49.432]                   function(frame = 1L) {
[17:42:49.432]                     if (is.function(sendCondition)) 
[17:42:49.432]                       return(sendCondition)
[17:42:49.432]                     ns <- getNamespace("parallel")
[17:42:49.432]                     if (exists("sendData", mode = "function", 
[17:42:49.432]                       envir = ns)) {
[17:42:49.432]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.432]                         envir = ns)
[17:42:49.432]                       envir <- sys.frame(frame)
[17:42:49.432]                       master <- NULL
[17:42:49.432]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.432]                         !identical(envir, emptyenv())) {
[17:42:49.432]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.432]                           inherits = FALSE)) {
[17:42:49.432]                           master <- get("master", mode = "list", 
[17:42:49.432]                             envir = envir, inherits = FALSE)
[17:42:49.432]                           if (inherits(master, c("SOCKnode", 
[17:42:49.432]                             "SOCK0node"))) {
[17:42:49.432]                             sendCondition <<- function(cond) {
[17:42:49.432]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.432]                                 success = TRUE)
[17:42:49.432]                               parallel_sendData(master, data)
[17:42:49.432]                             }
[17:42:49.432]                             return(sendCondition)
[17:42:49.432]                           }
[17:42:49.432]                         }
[17:42:49.432]                         frame <- frame + 1L
[17:42:49.432]                         envir <- sys.frame(frame)
[17:42:49.432]                       }
[17:42:49.432]                     }
[17:42:49.432]                     sendCondition <<- function(cond) NULL
[17:42:49.432]                   }
[17:42:49.432]                 })
[17:42:49.432]                 withCallingHandlers({
[17:42:49.432]                   value(a) + 1
[17:42:49.432]                 }, immediateCondition = function(cond) {
[17:42:49.432]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.432]                   sendCondition(cond)
[17:42:49.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.432]                   {
[17:42:49.432]                     inherits <- base::inherits
[17:42:49.432]                     invokeRestart <- base::invokeRestart
[17:42:49.432]                     is.null <- base::is.null
[17:42:49.432]                     muffled <- FALSE
[17:42:49.432]                     if (inherits(cond, "message")) {
[17:42:49.432]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.432]                       if (muffled) 
[17:42:49.432]                         invokeRestart("muffleMessage")
[17:42:49.432]                     }
[17:42:49.432]                     else if (inherits(cond, "warning")) {
[17:42:49.432]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.432]                       if (muffled) 
[17:42:49.432]                         invokeRestart("muffleWarning")
[17:42:49.432]                     }
[17:42:49.432]                     else if (inherits(cond, "condition")) {
[17:42:49.432]                       if (!is.null(pattern)) {
[17:42:49.432]                         computeRestarts <- base::computeRestarts
[17:42:49.432]                         grepl <- base::grepl
[17:42:49.432]                         restarts <- computeRestarts(cond)
[17:42:49.432]                         for (restart in restarts) {
[17:42:49.432]                           name <- restart$name
[17:42:49.432]                           if (is.null(name)) 
[17:42:49.432]                             next
[17:42:49.432]                           if (!grepl(pattern, name)) 
[17:42:49.432]                             next
[17:42:49.432]                           invokeRestart(restart)
[17:42:49.432]                           muffled <- TRUE
[17:42:49.432]                           break
[17:42:49.432]                         }
[17:42:49.432]                       }
[17:42:49.432]                     }
[17:42:49.432]                     invisible(muffled)
[17:42:49.432]                   }
[17:42:49.432]                   muffleCondition(cond)
[17:42:49.432]                 })
[17:42:49.432]             }))
[17:42:49.432]             future::FutureResult(value = ...future.value$value, 
[17:42:49.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.432]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.432]                     ...future.globalenv.names))
[17:42:49.432]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.432]         }, condition = base::local({
[17:42:49.432]             c <- base::c
[17:42:49.432]             inherits <- base::inherits
[17:42:49.432]             invokeRestart <- base::invokeRestart
[17:42:49.432]             length <- base::length
[17:42:49.432]             list <- base::list
[17:42:49.432]             seq.int <- base::seq.int
[17:42:49.432]             signalCondition <- base::signalCondition
[17:42:49.432]             sys.calls <- base::sys.calls
[17:42:49.432]             `[[` <- base::`[[`
[17:42:49.432]             `+` <- base::`+`
[17:42:49.432]             `<<-` <- base::`<<-`
[17:42:49.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.432]                   3L)]
[17:42:49.432]             }
[17:42:49.432]             function(cond) {
[17:42:49.432]                 is_error <- inherits(cond, "error")
[17:42:49.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.432]                   NULL)
[17:42:49.432]                 if (is_error) {
[17:42:49.432]                   sessionInformation <- function() {
[17:42:49.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.432]                       search = base::search(), system = base::Sys.info())
[17:42:49.432]                   }
[17:42:49.432]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.432]                     cond$call), session = sessionInformation(), 
[17:42:49.432]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.432]                   signalCondition(cond)
[17:42:49.432]                 }
[17:42:49.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.432]                 "immediateCondition"))) {
[17:42:49.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.432]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.432]                   if (TRUE && !signal) {
[17:42:49.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.432]                     {
[17:42:49.432]                       inherits <- base::inherits
[17:42:49.432]                       invokeRestart <- base::invokeRestart
[17:42:49.432]                       is.null <- base::is.null
[17:42:49.432]                       muffled <- FALSE
[17:42:49.432]                       if (inherits(cond, "message")) {
[17:42:49.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.432]                         if (muffled) 
[17:42:49.432]                           invokeRestart("muffleMessage")
[17:42:49.432]                       }
[17:42:49.432]                       else if (inherits(cond, "warning")) {
[17:42:49.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.432]                         if (muffled) 
[17:42:49.432]                           invokeRestart("muffleWarning")
[17:42:49.432]                       }
[17:42:49.432]                       else if (inherits(cond, "condition")) {
[17:42:49.432]                         if (!is.null(pattern)) {
[17:42:49.432]                           computeRestarts <- base::computeRestarts
[17:42:49.432]                           grepl <- base::grepl
[17:42:49.432]                           restarts <- computeRestarts(cond)
[17:42:49.432]                           for (restart in restarts) {
[17:42:49.432]                             name <- restart$name
[17:42:49.432]                             if (is.null(name)) 
[17:42:49.432]                               next
[17:42:49.432]                             if (!grepl(pattern, name)) 
[17:42:49.432]                               next
[17:42:49.432]                             invokeRestart(restart)
[17:42:49.432]                             muffled <- TRUE
[17:42:49.432]                             break
[17:42:49.432]                           }
[17:42:49.432]                         }
[17:42:49.432]                       }
[17:42:49.432]                       invisible(muffled)
[17:42:49.432]                     }
[17:42:49.432]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.432]                   }
[17:42:49.432]                 }
[17:42:49.432]                 else {
[17:42:49.432]                   if (TRUE) {
[17:42:49.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.432]                     {
[17:42:49.432]                       inherits <- base::inherits
[17:42:49.432]                       invokeRestart <- base::invokeRestart
[17:42:49.432]                       is.null <- base::is.null
[17:42:49.432]                       muffled <- FALSE
[17:42:49.432]                       if (inherits(cond, "message")) {
[17:42:49.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.432]                         if (muffled) 
[17:42:49.432]                           invokeRestart("muffleMessage")
[17:42:49.432]                       }
[17:42:49.432]                       else if (inherits(cond, "warning")) {
[17:42:49.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.432]                         if (muffled) 
[17:42:49.432]                           invokeRestart("muffleWarning")
[17:42:49.432]                       }
[17:42:49.432]                       else if (inherits(cond, "condition")) {
[17:42:49.432]                         if (!is.null(pattern)) {
[17:42:49.432]                           computeRestarts <- base::computeRestarts
[17:42:49.432]                           grepl <- base::grepl
[17:42:49.432]                           restarts <- computeRestarts(cond)
[17:42:49.432]                           for (restart in restarts) {
[17:42:49.432]                             name <- restart$name
[17:42:49.432]                             if (is.null(name)) 
[17:42:49.432]                               next
[17:42:49.432]                             if (!grepl(pattern, name)) 
[17:42:49.432]                               next
[17:42:49.432]                             invokeRestart(restart)
[17:42:49.432]                             muffled <- TRUE
[17:42:49.432]                             break
[17:42:49.432]                           }
[17:42:49.432]                         }
[17:42:49.432]                       }
[17:42:49.432]                       invisible(muffled)
[17:42:49.432]                     }
[17:42:49.432]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.432]                   }
[17:42:49.432]                 }
[17:42:49.432]             }
[17:42:49.432]         }))
[17:42:49.432]     }, error = function(ex) {
[17:42:49.432]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.432]                 ...future.rng), started = ...future.startTime, 
[17:42:49.432]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.432]             version = "1.8"), class = "FutureResult")
[17:42:49.432]     }, finally = {
[17:42:49.432]         if (!identical(...future.workdir, getwd())) 
[17:42:49.432]             setwd(...future.workdir)
[17:42:49.432]         {
[17:42:49.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.432]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.432]             }
[17:42:49.432]             base::options(...future.oldOptions)
[17:42:49.432]             if (.Platform$OS.type == "windows") {
[17:42:49.432]                 old_names <- names(...future.oldEnvVars)
[17:42:49.432]                 envs <- base::Sys.getenv()
[17:42:49.432]                 names <- names(envs)
[17:42:49.432]                 common <- intersect(names, old_names)
[17:42:49.432]                 added <- setdiff(names, old_names)
[17:42:49.432]                 removed <- setdiff(old_names, names)
[17:42:49.432]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.432]                   envs[common]]
[17:42:49.432]                 NAMES <- toupper(changed)
[17:42:49.432]                 args <- list()
[17:42:49.432]                 for (kk in seq_along(NAMES)) {
[17:42:49.432]                   name <- changed[[kk]]
[17:42:49.432]                   NAME <- NAMES[[kk]]
[17:42:49.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.432]                     next
[17:42:49.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.432]                 }
[17:42:49.432]                 NAMES <- toupper(added)
[17:42:49.432]                 for (kk in seq_along(NAMES)) {
[17:42:49.432]                   name <- added[[kk]]
[17:42:49.432]                   NAME <- NAMES[[kk]]
[17:42:49.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.432]                     next
[17:42:49.432]                   args[[name]] <- ""
[17:42:49.432]                 }
[17:42:49.432]                 NAMES <- toupper(removed)
[17:42:49.432]                 for (kk in seq_along(NAMES)) {
[17:42:49.432]                   name <- removed[[kk]]
[17:42:49.432]                   NAME <- NAMES[[kk]]
[17:42:49.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.432]                     next
[17:42:49.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.432]                 }
[17:42:49.432]                 if (length(args) > 0) 
[17:42:49.432]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.432]             }
[17:42:49.432]             else {
[17:42:49.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.432]             }
[17:42:49.432]             {
[17:42:49.432]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.432]                   0L) {
[17:42:49.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.432]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.432]                   base::options(opts)
[17:42:49.432]                 }
[17:42:49.432]                 {
[17:42:49.432]                   {
[17:42:49.432]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.432]                     NULL
[17:42:49.432]                   }
[17:42:49.432]                   options(future.plan = NULL)
[17:42:49.432]                   if (is.na(NA_character_)) 
[17:42:49.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.432]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.432]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.432]                     envir = parent.frame()) 
[17:42:49.432]                   {
[17:42:49.432]                     if (is.function(workers)) 
[17:42:49.432]                       workers <- workers()
[17:42:49.432]                     workers <- structure(as.integer(workers), 
[17:42:49.432]                       class = class(workers))
[17:42:49.432]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.432]                       workers >= 1)
[17:42:49.432]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.432]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.432]                     }
[17:42:49.432]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.432]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.432]                       envir = envir)
[17:42:49.432]                     if (!future$lazy) 
[17:42:49.432]                       future <- run(future)
[17:42:49.432]                     invisible(future)
[17:42:49.432]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.432]                 }
[17:42:49.432]             }
[17:42:49.432]         }
[17:42:49.432]     })
[17:42:49.432]     if (TRUE) {
[17:42:49.432]         base::sink(type = "output", split = FALSE)
[17:42:49.432]         if (TRUE) {
[17:42:49.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.432]         }
[17:42:49.432]         else {
[17:42:49.432]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.432]         }
[17:42:49.432]         base::close(...future.stdout)
[17:42:49.432]         ...future.stdout <- NULL
[17:42:49.432]     }
[17:42:49.432]     ...future.result$conditions <- ...future.conditions
[17:42:49.432]     ...future.result$finished <- base::Sys.time()
[17:42:49.432]     ...future.result
[17:42:49.432] }
[17:42:49.435] Exporting 1 global objects (1.55 MiB) to cluster node #1 ...
[17:42:49.436] Exporting ‘a’ (1.55 MiB) to cluster node #1 ...
[17:42:49.487] Exporting ‘a’ (1.55 MiB) to cluster node #1 ... DONE
[17:42:49.488] Exporting 1 global objects (1.55 MiB) to cluster node #1 ... DONE
[17:42:49.488] MultisessionFuture started
[17:42:49.488] - Launch lazy future ... done
[17:42:49.488] run() for ‘MultisessionFuture’ ... done
[17:42:49.489] result() for ClusterFuture ...
[17:42:49.489] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.489] - Validating connection of MultisessionFuture
[17:42:49.537] - received message: FutureResult
[17:42:49.537] - Received FutureResult
[17:42:49.537] - Erased future from FutureRegistry
[17:42:49.537] result() for ClusterFuture ...
[17:42:49.537] - result already collected: FutureResult
[17:42:49.538] result() for ClusterFuture ... done
[17:42:49.538] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.538] result() for ClusterFuture ... done
[17:42:49.538] result() for ClusterFuture ...
[17:42:49.538] - result already collected: FutureResult
[17:42:49.538] result() for ClusterFuture ... done
value(b) = 2
[17:42:49.538] result() for ClusterFuture ...
[17:42:49.538] - result already collected: FutureResult
[17:42:49.538] result() for ClusterFuture ... done
[17:42:49.539] result() for ClusterFuture ...
[17:42:49.539] - result already collected: FutureResult
[17:42:49.539] result() for ClusterFuture ... done
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.539] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.539] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.540] - globals found: [2] ‘{’, ‘pkg’
[17:42:49.540] Searching for globals ... DONE
[17:42:49.540] Resolving globals: TRUE
[17:42:49.540] Resolving any globals that are futures ...
[17:42:49.540] - globals: [2] ‘{’, ‘pkg’
[17:42:49.541] Resolving any globals that are futures ... DONE
[17:42:49.541] Resolving futures part of globals (recursively) ...
[17:42:49.541] resolve() on list ...
[17:42:49.541]  recursive: 99
[17:42:49.541]  length: 1
[17:42:49.541]  elements: ‘pkg’
[17:42:49.542]  length: 0 (resolved future 1)
[17:42:49.542] resolve() on list ... DONE
[17:42:49.542] - globals: [1] ‘pkg’
[17:42:49.542] Resolving futures part of globals (recursively) ... DONE
[17:42:49.542] The total size of the 1 globals is 112 bytes (112 bytes)
[17:42:49.542] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[17:42:49.542] - globals: [1] ‘pkg’
[17:42:49.543] 
[17:42:49.543] getGlobalsAndPackages() ... DONE
[17:42:49.543] Packages needed by the future expression (n = 0): <none>
[17:42:49.543] Packages needed by future strategies (n = 0): <none>
[17:42:49.544] {
[17:42:49.544]     {
[17:42:49.544]         {
[17:42:49.544]             ...future.startTime <- base::Sys.time()
[17:42:49.544]             {
[17:42:49.544]                 {
[17:42:49.544]                   {
[17:42:49.544]                     base::local({
[17:42:49.544]                       has_future <- base::requireNamespace("future", 
[17:42:49.544]                         quietly = TRUE)
[17:42:49.544]                       if (has_future) {
[17:42:49.544]                         ns <- base::getNamespace("future")
[17:42:49.544]                         version <- ns[[".package"]][["version"]]
[17:42:49.544]                         if (is.null(version)) 
[17:42:49.544]                           version <- utils::packageVersion("future")
[17:42:49.544]                       }
[17:42:49.544]                       else {
[17:42:49.544]                         version <- NULL
[17:42:49.544]                       }
[17:42:49.544]                       if (!has_future || version < "1.8.0") {
[17:42:49.544]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.544]                           "", base::R.version$version.string), 
[17:42:49.544]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:49.544]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:49.544]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.544]                             "release", "version")], collapse = " "), 
[17:42:49.544]                           hostname = base::Sys.info()[["nodename"]])
[17:42:49.544]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.544]                           info)
[17:42:49.544]                         info <- base::paste(info, collapse = "; ")
[17:42:49.544]                         if (!has_future) {
[17:42:49.544]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.544]                             info)
[17:42:49.544]                         }
[17:42:49.544]                         else {
[17:42:49.544]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.544]                             info, version)
[17:42:49.544]                         }
[17:42:49.544]                         base::stop(msg)
[17:42:49.544]                       }
[17:42:49.544]                     })
[17:42:49.544]                   }
[17:42:49.544]                   options(future.plan = NULL)
[17:42:49.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.544]                 }
[17:42:49.544]                 ...future.workdir <- getwd()
[17:42:49.544]             }
[17:42:49.544]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.544]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.544]         }
[17:42:49.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.544]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.544]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.544]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.544]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.544]             base::names(...future.oldOptions))
[17:42:49.544]     }
[17:42:49.544]     if (FALSE) {
[17:42:49.544]     }
[17:42:49.544]     else {
[17:42:49.544]         if (TRUE) {
[17:42:49.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.544]                 open = "w")
[17:42:49.544]         }
[17:42:49.544]         else {
[17:42:49.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.544]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.544]         }
[17:42:49.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.544]             base::sink(type = "output", split = FALSE)
[17:42:49.544]             base::close(...future.stdout)
[17:42:49.544]         }, add = TRUE)
[17:42:49.544]     }
[17:42:49.544]     ...future.frame <- base::sys.nframe()
[17:42:49.544]     ...future.conditions <- base::list()
[17:42:49.544]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.544]     if (FALSE) {
[17:42:49.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.544]     }
[17:42:49.544]     ...future.result <- base::tryCatch({
[17:42:49.544]         base::withCallingHandlers({
[17:42:49.544]             ...future.value <- base::withVisible(base::local({
[17:42:49.544]                 pkg
[17:42:49.544]             }))
[17:42:49.544]             future::FutureResult(value = ...future.value$value, 
[17:42:49.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.544]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.544]                     ...future.globalenv.names))
[17:42:49.544]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.544]         }, condition = base::local({
[17:42:49.544]             c <- base::c
[17:42:49.544]             inherits <- base::inherits
[17:42:49.544]             invokeRestart <- base::invokeRestart
[17:42:49.544]             length <- base::length
[17:42:49.544]             list <- base::list
[17:42:49.544]             seq.int <- base::seq.int
[17:42:49.544]             signalCondition <- base::signalCondition
[17:42:49.544]             sys.calls <- base::sys.calls
[17:42:49.544]             `[[` <- base::`[[`
[17:42:49.544]             `+` <- base::`+`
[17:42:49.544]             `<<-` <- base::`<<-`
[17:42:49.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.544]                   3L)]
[17:42:49.544]             }
[17:42:49.544]             function(cond) {
[17:42:49.544]                 is_error <- inherits(cond, "error")
[17:42:49.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.544]                   NULL)
[17:42:49.544]                 if (is_error) {
[17:42:49.544]                   sessionInformation <- function() {
[17:42:49.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.544]                       search = base::search(), system = base::Sys.info())
[17:42:49.544]                   }
[17:42:49.544]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.544]                     cond$call), session = sessionInformation(), 
[17:42:49.544]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.544]                   signalCondition(cond)
[17:42:49.544]                 }
[17:42:49.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.544]                 "immediateCondition"))) {
[17:42:49.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.544]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.544]                   if (TRUE && !signal) {
[17:42:49.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.544]                     {
[17:42:49.544]                       inherits <- base::inherits
[17:42:49.544]                       invokeRestart <- base::invokeRestart
[17:42:49.544]                       is.null <- base::is.null
[17:42:49.544]                       muffled <- FALSE
[17:42:49.544]                       if (inherits(cond, "message")) {
[17:42:49.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.544]                         if (muffled) 
[17:42:49.544]                           invokeRestart("muffleMessage")
[17:42:49.544]                       }
[17:42:49.544]                       else if (inherits(cond, "warning")) {
[17:42:49.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.544]                         if (muffled) 
[17:42:49.544]                           invokeRestart("muffleWarning")
[17:42:49.544]                       }
[17:42:49.544]                       else if (inherits(cond, "condition")) {
[17:42:49.544]                         if (!is.null(pattern)) {
[17:42:49.544]                           computeRestarts <- base::computeRestarts
[17:42:49.544]                           grepl <- base::grepl
[17:42:49.544]                           restarts <- computeRestarts(cond)
[17:42:49.544]                           for (restart in restarts) {
[17:42:49.544]                             name <- restart$name
[17:42:49.544]                             if (is.null(name)) 
[17:42:49.544]                               next
[17:42:49.544]                             if (!grepl(pattern, name)) 
[17:42:49.544]                               next
[17:42:49.544]                             invokeRestart(restart)
[17:42:49.544]                             muffled <- TRUE
[17:42:49.544]                             break
[17:42:49.544]                           }
[17:42:49.544]                         }
[17:42:49.544]                       }
[17:42:49.544]                       invisible(muffled)
[17:42:49.544]                     }
[17:42:49.544]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.544]                   }
[17:42:49.544]                 }
[17:42:49.544]                 else {
[17:42:49.544]                   if (TRUE) {
[17:42:49.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.544]                     {
[17:42:49.544]                       inherits <- base::inherits
[17:42:49.544]                       invokeRestart <- base::invokeRestart
[17:42:49.544]                       is.null <- base::is.null
[17:42:49.544]                       muffled <- FALSE
[17:42:49.544]                       if (inherits(cond, "message")) {
[17:42:49.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.544]                         if (muffled) 
[17:42:49.544]                           invokeRestart("muffleMessage")
[17:42:49.544]                       }
[17:42:49.544]                       else if (inherits(cond, "warning")) {
[17:42:49.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.544]                         if (muffled) 
[17:42:49.544]                           invokeRestart("muffleWarning")
[17:42:49.544]                       }
[17:42:49.544]                       else if (inherits(cond, "condition")) {
[17:42:49.544]                         if (!is.null(pattern)) {
[17:42:49.544]                           computeRestarts <- base::computeRestarts
[17:42:49.544]                           grepl <- base::grepl
[17:42:49.544]                           restarts <- computeRestarts(cond)
[17:42:49.544]                           for (restart in restarts) {
[17:42:49.544]                             name <- restart$name
[17:42:49.544]                             if (is.null(name)) 
[17:42:49.544]                               next
[17:42:49.544]                             if (!grepl(pattern, name)) 
[17:42:49.544]                               next
[17:42:49.544]                             invokeRestart(restart)
[17:42:49.544]                             muffled <- TRUE
[17:42:49.544]                             break
[17:42:49.544]                           }
[17:42:49.544]                         }
[17:42:49.544]                       }
[17:42:49.544]                       invisible(muffled)
[17:42:49.544]                     }
[17:42:49.544]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.544]                   }
[17:42:49.544]                 }
[17:42:49.544]             }
[17:42:49.544]         }))
[17:42:49.544]     }, error = function(ex) {
[17:42:49.544]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.544]                 ...future.rng), started = ...future.startTime, 
[17:42:49.544]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.544]             version = "1.8"), class = "FutureResult")
[17:42:49.544]     }, finally = {
[17:42:49.544]         if (!identical(...future.workdir, getwd())) 
[17:42:49.544]             setwd(...future.workdir)
[17:42:49.544]         {
[17:42:49.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.544]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.544]             }
[17:42:49.544]             base::options(...future.oldOptions)
[17:42:49.544]             if (.Platform$OS.type == "windows") {
[17:42:49.544]                 old_names <- names(...future.oldEnvVars)
[17:42:49.544]                 envs <- base::Sys.getenv()
[17:42:49.544]                 names <- names(envs)
[17:42:49.544]                 common <- intersect(names, old_names)
[17:42:49.544]                 added <- setdiff(names, old_names)
[17:42:49.544]                 removed <- setdiff(old_names, names)
[17:42:49.544]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.544]                   envs[common]]
[17:42:49.544]                 NAMES <- toupper(changed)
[17:42:49.544]                 args <- list()
[17:42:49.544]                 for (kk in seq_along(NAMES)) {
[17:42:49.544]                   name <- changed[[kk]]
[17:42:49.544]                   NAME <- NAMES[[kk]]
[17:42:49.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.544]                     next
[17:42:49.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.544]                 }
[17:42:49.544]                 NAMES <- toupper(added)
[17:42:49.544]                 for (kk in seq_along(NAMES)) {
[17:42:49.544]                   name <- added[[kk]]
[17:42:49.544]                   NAME <- NAMES[[kk]]
[17:42:49.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.544]                     next
[17:42:49.544]                   args[[name]] <- ""
[17:42:49.544]                 }
[17:42:49.544]                 NAMES <- toupper(removed)
[17:42:49.544]                 for (kk in seq_along(NAMES)) {
[17:42:49.544]                   name <- removed[[kk]]
[17:42:49.544]                   NAME <- NAMES[[kk]]
[17:42:49.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.544]                     next
[17:42:49.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.544]                 }
[17:42:49.544]                 if (length(args) > 0) 
[17:42:49.544]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.544]             }
[17:42:49.544]             else {
[17:42:49.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.544]             }
[17:42:49.544]             {
[17:42:49.544]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.544]                   0L) {
[17:42:49.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.544]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.544]                   base::options(opts)
[17:42:49.544]                 }
[17:42:49.544]                 {
[17:42:49.544]                   {
[17:42:49.544]                     NULL
[17:42:49.544]                     RNGkind("Mersenne-Twister")
[17:42:49.544]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:49.544]                       inherits = FALSE)
[17:42:49.544]                   }
[17:42:49.544]                   options(future.plan = NULL)
[17:42:49.544]                   if (is.na(NA_character_)) 
[17:42:49.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.544]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.544]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.544]                     envir = parent.frame()) 
[17:42:49.544]                   {
[17:42:49.544]                     if (is.function(workers)) 
[17:42:49.544]                       workers <- workers()
[17:42:49.544]                     workers <- structure(as.integer(workers), 
[17:42:49.544]                       class = class(workers))
[17:42:49.544]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.544]                       workers >= 1)
[17:42:49.544]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.544]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.544]                     }
[17:42:49.544]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.544]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.544]                       envir = envir)
[17:42:49.544]                     if (!future$lazy) 
[17:42:49.544]                       future <- run(future)
[17:42:49.544]                     invisible(future)
[17:42:49.544]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.544]                 }
[17:42:49.544]             }
[17:42:49.544]         }
[17:42:49.544]     })
[17:42:49.544]     if (TRUE) {
[17:42:49.544]         base::sink(type = "output", split = FALSE)
[17:42:49.544]         if (TRUE) {
[17:42:49.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.544]         }
[17:42:49.544]         else {
[17:42:49.544]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.544]         }
[17:42:49.544]         base::close(...future.stdout)
[17:42:49.544]         ...future.stdout <- NULL
[17:42:49.544]     }
[17:42:49.544]     ...future.result$conditions <- ...future.conditions
[17:42:49.544]     ...future.result$finished <- base::Sys.time()
[17:42:49.544]     ...future.result
[17:42:49.544] }
[17:42:49.545] assign_globals() ...
[17:42:49.545] List of 1
[17:42:49.545]  $ pkg: chr "foo"
[17:42:49.545]  - attr(*, "where")=List of 1
[17:42:49.545]   ..$ pkg:<environment: R_EmptyEnv> 
[17:42:49.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:42:49.545]  - attr(*, "resolved")= logi TRUE
[17:42:49.545]  - attr(*, "total_size")= num 112
[17:42:49.548] - copied ‘pkg’ to environment
[17:42:49.548] assign_globals() ... done
[17:42:49.548] plan(): Setting new future strategy stack:
[17:42:49.548] List of future strategies:
[17:42:49.548] 1. sequential:
[17:42:49.548]    - args: function (..., envir = parent.frame())
[17:42:49.548]    - tweaked: FALSE
[17:42:49.548]    - call: NULL
[17:42:49.548] plan(): nbrOfWorkers() = 1
[17:42:49.549] plan(): Setting new future strategy stack:
[17:42:49.549] List of future strategies:
[17:42:49.549] 1. multisession:
[17:42:49.549]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:49.549]    - tweaked: FALSE
[17:42:49.549]    - call: plan(strategy)
[17:42:49.553] plan(): nbrOfWorkers() = 2
[17:42:49.553] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.553] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.554] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.555] - globals found: [3] ‘{’, ‘<-’, ‘+’
[17:42:49.556] Searching for globals ... DONE
[17:42:49.556] Resolving globals: TRUE
[17:42:49.556] Resolving any globals that are futures ...
[17:42:49.556] - globals: [3] ‘{’, ‘<-’, ‘+’
[17:42:49.556] Resolving any globals that are futures ... DONE
[17:42:49.556] 
[17:42:49.556] 
[17:42:49.556] getGlobalsAndPackages() ... DONE
[17:42:49.557] run() for ‘Future’ ...
[17:42:49.557] - state: ‘created’
[17:42:49.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.571] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.572]   - Field: ‘node’
[17:42:49.572]   - Field: ‘label’
[17:42:49.572]   - Field: ‘local’
[17:42:49.572]   - Field: ‘owner’
[17:42:49.572]   - Field: ‘envir’
[17:42:49.572]   - Field: ‘workers’
[17:42:49.572]   - Field: ‘packages’
[17:42:49.572]   - Field: ‘gc’
[17:42:49.572]   - Field: ‘conditions’
[17:42:49.573]   - Field: ‘persistent’
[17:42:49.573]   - Field: ‘expr’
[17:42:49.573]   - Field: ‘uuid’
[17:42:49.573]   - Field: ‘seed’
[17:42:49.573]   - Field: ‘version’
[17:42:49.573]   - Field: ‘result’
[17:42:49.573]   - Field: ‘asynchronous’
[17:42:49.573]   - Field: ‘calls’
[17:42:49.573]   - Field: ‘globals’
[17:42:49.573]   - Field: ‘stdout’
[17:42:49.573]   - Field: ‘earlySignal’
[17:42:49.574]   - Field: ‘lazy’
[17:42:49.574]   - Field: ‘state’
[17:42:49.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.574] - Launch lazy future ...
[17:42:49.574] Packages needed by the future expression (n = 0): <none>
[17:42:49.574] Packages needed by future strategies (n = 0): <none>
[17:42:49.575] {
[17:42:49.575]     {
[17:42:49.575]         {
[17:42:49.575]             ...future.startTime <- base::Sys.time()
[17:42:49.575]             {
[17:42:49.575]                 {
[17:42:49.575]                   {
[17:42:49.575]                     {
[17:42:49.575]                       base::local({
[17:42:49.575]                         has_future <- base::requireNamespace("future", 
[17:42:49.575]                           quietly = TRUE)
[17:42:49.575]                         if (has_future) {
[17:42:49.575]                           ns <- base::getNamespace("future")
[17:42:49.575]                           version <- ns[[".package"]][["version"]]
[17:42:49.575]                           if (is.null(version)) 
[17:42:49.575]                             version <- utils::packageVersion("future")
[17:42:49.575]                         }
[17:42:49.575]                         else {
[17:42:49.575]                           version <- NULL
[17:42:49.575]                         }
[17:42:49.575]                         if (!has_future || version < "1.8.0") {
[17:42:49.575]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.575]                             "", base::R.version$version.string), 
[17:42:49.575]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:49.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:49.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.575]                               "release", "version")], collapse = " "), 
[17:42:49.575]                             hostname = base::Sys.info()[["nodename"]])
[17:42:49.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.575]                             info)
[17:42:49.575]                           info <- base::paste(info, collapse = "; ")
[17:42:49.575]                           if (!has_future) {
[17:42:49.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.575]                               info)
[17:42:49.575]                           }
[17:42:49.575]                           else {
[17:42:49.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.575]                               info, version)
[17:42:49.575]                           }
[17:42:49.575]                           base::stop(msg)
[17:42:49.575]                         }
[17:42:49.575]                       })
[17:42:49.575]                     }
[17:42:49.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.575]                     base::options(mc.cores = 1L)
[17:42:49.575]                   }
[17:42:49.575]                   options(future.plan = NULL)
[17:42:49.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.575]                 }
[17:42:49.575]                 ...future.workdir <- getwd()
[17:42:49.575]             }
[17:42:49.575]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.575]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.575]         }
[17:42:49.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.575]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.575]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.575]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.575]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.575]             base::names(...future.oldOptions))
[17:42:49.575]     }
[17:42:49.575]     if (FALSE) {
[17:42:49.575]     }
[17:42:49.575]     else {
[17:42:49.575]         if (TRUE) {
[17:42:49.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.575]                 open = "w")
[17:42:49.575]         }
[17:42:49.575]         else {
[17:42:49.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.575]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.575]         }
[17:42:49.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.575]             base::sink(type = "output", split = FALSE)
[17:42:49.575]             base::close(...future.stdout)
[17:42:49.575]         }, add = TRUE)
[17:42:49.575]     }
[17:42:49.575]     ...future.frame <- base::sys.nframe()
[17:42:49.575]     ...future.conditions <- base::list()
[17:42:49.575]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.575]     if (FALSE) {
[17:42:49.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.575]     }
[17:42:49.575]     ...future.result <- base::tryCatch({
[17:42:49.575]         base::withCallingHandlers({
[17:42:49.575]             ...future.value <- base::withVisible(base::local({
[17:42:49.575]                 ...future.makeSendCondition <- local({
[17:42:49.575]                   sendCondition <- NULL
[17:42:49.575]                   function(frame = 1L) {
[17:42:49.575]                     if (is.function(sendCondition)) 
[17:42:49.575]                       return(sendCondition)
[17:42:49.575]                     ns <- getNamespace("parallel")
[17:42:49.575]                     if (exists("sendData", mode = "function", 
[17:42:49.575]                       envir = ns)) {
[17:42:49.575]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.575]                         envir = ns)
[17:42:49.575]                       envir <- sys.frame(frame)
[17:42:49.575]                       master <- NULL
[17:42:49.575]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.575]                         !identical(envir, emptyenv())) {
[17:42:49.575]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.575]                           inherits = FALSE)) {
[17:42:49.575]                           master <- get("master", mode = "list", 
[17:42:49.575]                             envir = envir, inherits = FALSE)
[17:42:49.575]                           if (inherits(master, c("SOCKnode", 
[17:42:49.575]                             "SOCK0node"))) {
[17:42:49.575]                             sendCondition <<- function(cond) {
[17:42:49.575]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.575]                                 success = TRUE)
[17:42:49.575]                               parallel_sendData(master, data)
[17:42:49.575]                             }
[17:42:49.575]                             return(sendCondition)
[17:42:49.575]                           }
[17:42:49.575]                         }
[17:42:49.575]                         frame <- frame + 1L
[17:42:49.575]                         envir <- sys.frame(frame)
[17:42:49.575]                       }
[17:42:49.575]                     }
[17:42:49.575]                     sendCondition <<- function(cond) NULL
[17:42:49.575]                   }
[17:42:49.575]                 })
[17:42:49.575]                 withCallingHandlers({
[17:42:49.575]                   {
[17:42:49.575]                     x <- 0
[17:42:49.575]                     x <- x + 1
[17:42:49.575]                     x
[17:42:49.575]                   }
[17:42:49.575]                 }, immediateCondition = function(cond) {
[17:42:49.575]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.575]                   sendCondition(cond)
[17:42:49.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.575]                   {
[17:42:49.575]                     inherits <- base::inherits
[17:42:49.575]                     invokeRestart <- base::invokeRestart
[17:42:49.575]                     is.null <- base::is.null
[17:42:49.575]                     muffled <- FALSE
[17:42:49.575]                     if (inherits(cond, "message")) {
[17:42:49.575]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.575]                       if (muffled) 
[17:42:49.575]                         invokeRestart("muffleMessage")
[17:42:49.575]                     }
[17:42:49.575]                     else if (inherits(cond, "warning")) {
[17:42:49.575]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.575]                       if (muffled) 
[17:42:49.575]                         invokeRestart("muffleWarning")
[17:42:49.575]                     }
[17:42:49.575]                     else if (inherits(cond, "condition")) {
[17:42:49.575]                       if (!is.null(pattern)) {
[17:42:49.575]                         computeRestarts <- base::computeRestarts
[17:42:49.575]                         grepl <- base::grepl
[17:42:49.575]                         restarts <- computeRestarts(cond)
[17:42:49.575]                         for (restart in restarts) {
[17:42:49.575]                           name <- restart$name
[17:42:49.575]                           if (is.null(name)) 
[17:42:49.575]                             next
[17:42:49.575]                           if (!grepl(pattern, name)) 
[17:42:49.575]                             next
[17:42:49.575]                           invokeRestart(restart)
[17:42:49.575]                           muffled <- TRUE
[17:42:49.575]                           break
[17:42:49.575]                         }
[17:42:49.575]                       }
[17:42:49.575]                     }
[17:42:49.575]                     invisible(muffled)
[17:42:49.575]                   }
[17:42:49.575]                   muffleCondition(cond)
[17:42:49.575]                 })
[17:42:49.575]             }))
[17:42:49.575]             future::FutureResult(value = ...future.value$value, 
[17:42:49.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.575]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.575]                     ...future.globalenv.names))
[17:42:49.575]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.575]         }, condition = base::local({
[17:42:49.575]             c <- base::c
[17:42:49.575]             inherits <- base::inherits
[17:42:49.575]             invokeRestart <- base::invokeRestart
[17:42:49.575]             length <- base::length
[17:42:49.575]             list <- base::list
[17:42:49.575]             seq.int <- base::seq.int
[17:42:49.575]             signalCondition <- base::signalCondition
[17:42:49.575]             sys.calls <- base::sys.calls
[17:42:49.575]             `[[` <- base::`[[`
[17:42:49.575]             `+` <- base::`+`
[17:42:49.575]             `<<-` <- base::`<<-`
[17:42:49.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.575]                   3L)]
[17:42:49.575]             }
[17:42:49.575]             function(cond) {
[17:42:49.575]                 is_error <- inherits(cond, "error")
[17:42:49.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.575]                   NULL)
[17:42:49.575]                 if (is_error) {
[17:42:49.575]                   sessionInformation <- function() {
[17:42:49.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.575]                       search = base::search(), system = base::Sys.info())
[17:42:49.575]                   }
[17:42:49.575]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.575]                     cond$call), session = sessionInformation(), 
[17:42:49.575]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.575]                   signalCondition(cond)
[17:42:49.575]                 }
[17:42:49.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.575]                 "immediateCondition"))) {
[17:42:49.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.575]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.575]                   if (TRUE && !signal) {
[17:42:49.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.575]                     {
[17:42:49.575]                       inherits <- base::inherits
[17:42:49.575]                       invokeRestart <- base::invokeRestart
[17:42:49.575]                       is.null <- base::is.null
[17:42:49.575]                       muffled <- FALSE
[17:42:49.575]                       if (inherits(cond, "message")) {
[17:42:49.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.575]                         if (muffled) 
[17:42:49.575]                           invokeRestart("muffleMessage")
[17:42:49.575]                       }
[17:42:49.575]                       else if (inherits(cond, "warning")) {
[17:42:49.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.575]                         if (muffled) 
[17:42:49.575]                           invokeRestart("muffleWarning")
[17:42:49.575]                       }
[17:42:49.575]                       else if (inherits(cond, "condition")) {
[17:42:49.575]                         if (!is.null(pattern)) {
[17:42:49.575]                           computeRestarts <- base::computeRestarts
[17:42:49.575]                           grepl <- base::grepl
[17:42:49.575]                           restarts <- computeRestarts(cond)
[17:42:49.575]                           for (restart in restarts) {
[17:42:49.575]                             name <- restart$name
[17:42:49.575]                             if (is.null(name)) 
[17:42:49.575]                               next
[17:42:49.575]                             if (!grepl(pattern, name)) 
[17:42:49.575]                               next
[17:42:49.575]                             invokeRestart(restart)
[17:42:49.575]                             muffled <- TRUE
[17:42:49.575]                             break
[17:42:49.575]                           }
[17:42:49.575]                         }
[17:42:49.575]                       }
[17:42:49.575]                       invisible(muffled)
[17:42:49.575]                     }
[17:42:49.575]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.575]                   }
[17:42:49.575]                 }
[17:42:49.575]                 else {
[17:42:49.575]                   if (TRUE) {
[17:42:49.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.575]                     {
[17:42:49.575]                       inherits <- base::inherits
[17:42:49.575]                       invokeRestart <- base::invokeRestart
[17:42:49.575]                       is.null <- base::is.null
[17:42:49.575]                       muffled <- FALSE
[17:42:49.575]                       if (inherits(cond, "message")) {
[17:42:49.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.575]                         if (muffled) 
[17:42:49.575]                           invokeRestart("muffleMessage")
[17:42:49.575]                       }
[17:42:49.575]                       else if (inherits(cond, "warning")) {
[17:42:49.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.575]                         if (muffled) 
[17:42:49.575]                           invokeRestart("muffleWarning")
[17:42:49.575]                       }
[17:42:49.575]                       else if (inherits(cond, "condition")) {
[17:42:49.575]                         if (!is.null(pattern)) {
[17:42:49.575]                           computeRestarts <- base::computeRestarts
[17:42:49.575]                           grepl <- base::grepl
[17:42:49.575]                           restarts <- computeRestarts(cond)
[17:42:49.575]                           for (restart in restarts) {
[17:42:49.575]                             name <- restart$name
[17:42:49.575]                             if (is.null(name)) 
[17:42:49.575]                               next
[17:42:49.575]                             if (!grepl(pattern, name)) 
[17:42:49.575]                               next
[17:42:49.575]                             invokeRestart(restart)
[17:42:49.575]                             muffled <- TRUE
[17:42:49.575]                             break
[17:42:49.575]                           }
[17:42:49.575]                         }
[17:42:49.575]                       }
[17:42:49.575]                       invisible(muffled)
[17:42:49.575]                     }
[17:42:49.575]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.575]                   }
[17:42:49.575]                 }
[17:42:49.575]             }
[17:42:49.575]         }))
[17:42:49.575]     }, error = function(ex) {
[17:42:49.575]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.575]                 ...future.rng), started = ...future.startTime, 
[17:42:49.575]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.575]             version = "1.8"), class = "FutureResult")
[17:42:49.575]     }, finally = {
[17:42:49.575]         if (!identical(...future.workdir, getwd())) 
[17:42:49.575]             setwd(...future.workdir)
[17:42:49.575]         {
[17:42:49.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.575]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.575]             }
[17:42:49.575]             base::options(...future.oldOptions)
[17:42:49.575]             if (.Platform$OS.type == "windows") {
[17:42:49.575]                 old_names <- names(...future.oldEnvVars)
[17:42:49.575]                 envs <- base::Sys.getenv()
[17:42:49.575]                 names <- names(envs)
[17:42:49.575]                 common <- intersect(names, old_names)
[17:42:49.575]                 added <- setdiff(names, old_names)
[17:42:49.575]                 removed <- setdiff(old_names, names)
[17:42:49.575]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.575]                   envs[common]]
[17:42:49.575]                 NAMES <- toupper(changed)
[17:42:49.575]                 args <- list()
[17:42:49.575]                 for (kk in seq_along(NAMES)) {
[17:42:49.575]                   name <- changed[[kk]]
[17:42:49.575]                   NAME <- NAMES[[kk]]
[17:42:49.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.575]                     next
[17:42:49.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.575]                 }
[17:42:49.575]                 NAMES <- toupper(added)
[17:42:49.575]                 for (kk in seq_along(NAMES)) {
[17:42:49.575]                   name <- added[[kk]]
[17:42:49.575]                   NAME <- NAMES[[kk]]
[17:42:49.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.575]                     next
[17:42:49.575]                   args[[name]] <- ""
[17:42:49.575]                 }
[17:42:49.575]                 NAMES <- toupper(removed)
[17:42:49.575]                 for (kk in seq_along(NAMES)) {
[17:42:49.575]                   name <- removed[[kk]]
[17:42:49.575]                   NAME <- NAMES[[kk]]
[17:42:49.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.575]                     next
[17:42:49.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.575]                 }
[17:42:49.575]                 if (length(args) > 0) 
[17:42:49.575]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.575]             }
[17:42:49.575]             else {
[17:42:49.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.575]             }
[17:42:49.575]             {
[17:42:49.575]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.575]                   0L) {
[17:42:49.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.575]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.575]                   base::options(opts)
[17:42:49.575]                 }
[17:42:49.575]                 {
[17:42:49.575]                   {
[17:42:49.575]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.575]                     NULL
[17:42:49.575]                   }
[17:42:49.575]                   options(future.plan = NULL)
[17:42:49.575]                   if (is.na(NA_character_)) 
[17:42:49.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.575]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.575]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.575]                     envir = parent.frame()) 
[17:42:49.575]                   {
[17:42:49.575]                     if (is.function(workers)) 
[17:42:49.575]                       workers <- workers()
[17:42:49.575]                     workers <- structure(as.integer(workers), 
[17:42:49.575]                       class = class(workers))
[17:42:49.575]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.575]                       workers >= 1)
[17:42:49.575]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.575]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.575]                     }
[17:42:49.575]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.575]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.575]                       envir = envir)
[17:42:49.575]                     if (!future$lazy) 
[17:42:49.575]                       future <- run(future)
[17:42:49.575]                     invisible(future)
[17:42:49.575]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.575]                 }
[17:42:49.575]             }
[17:42:49.575]         }
[17:42:49.575]     })
[17:42:49.575]     if (TRUE) {
[17:42:49.575]         base::sink(type = "output", split = FALSE)
[17:42:49.575]         if (TRUE) {
[17:42:49.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.575]         }
[17:42:49.575]         else {
[17:42:49.575]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.575]         }
[17:42:49.575]         base::close(...future.stdout)
[17:42:49.575]         ...future.stdout <- NULL
[17:42:49.575]     }
[17:42:49.575]     ...future.result$conditions <- ...future.conditions
[17:42:49.575]     ...future.result$finished <- base::Sys.time()
[17:42:49.575]     ...future.result
[17:42:49.575] }
[17:42:49.578] MultisessionFuture started
[17:42:49.578] - Launch lazy future ... done
[17:42:49.578] run() for ‘MultisessionFuture’ ... done
[17:42:49.578] result() for ClusterFuture ...
[17:42:49.578] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.579] - Validating connection of MultisessionFuture
[17:42:49.624] - received message: FutureResult
[17:42:49.624] - Received FutureResult
[17:42:49.625] - Erased future from FutureRegistry
[17:42:49.625] result() for ClusterFuture ...
[17:42:49.625] - result already collected: FutureResult
[17:42:49.625] result() for ClusterFuture ... done
[17:42:49.625] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.625] result() for ClusterFuture ... done
[17:42:49.625] result() for ClusterFuture ...
[17:42:49.625] - result already collected: FutureResult
[17:42:49.625] result() for ClusterFuture ... done
value(f) = ‘1’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.626] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.626] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.627] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:42:49.628] Searching for globals ... DONE
[17:42:49.628] Resolving globals: TRUE
[17:42:49.628] Resolving any globals that are futures ...
[17:42:49.628] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[17:42:49.628] Resolving any globals that are futures ... DONE
[17:42:49.628] Resolving futures part of globals (recursively) ...
[17:42:49.629] resolve() on list ...
[17:42:49.629]  recursive: 99
[17:42:49.629]  length: 1
[17:42:49.629]  elements: ‘x’
[17:42:49.629]  length: 0 (resolved future 1)
[17:42:49.629] resolve() on list ... DONE
[17:42:49.629] - globals: [1] ‘x’
[17:42:49.629] Resolving futures part of globals (recursively) ... DONE
[17:42:49.629] The total size of the 1 globals is 56 bytes (56 bytes)
[17:42:49.630] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[17:42:49.630] - globals: [1] ‘x’
[17:42:49.630] 
[17:42:49.630] getGlobalsAndPackages() ... DONE
[17:42:49.630] run() for ‘Future’ ...
[17:42:49.630] - state: ‘created’
[17:42:49.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.645] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.645]   - Field: ‘node’
[17:42:49.645]   - Field: ‘label’
[17:42:49.646]   - Field: ‘local’
[17:42:49.646]   - Field: ‘owner’
[17:42:49.646]   - Field: ‘envir’
[17:42:49.646]   - Field: ‘workers’
[17:42:49.646]   - Field: ‘packages’
[17:42:49.646]   - Field: ‘gc’
[17:42:49.646]   - Field: ‘conditions’
[17:42:49.646]   - Field: ‘persistent’
[17:42:49.646]   - Field: ‘expr’
[17:42:49.646]   - Field: ‘uuid’
[17:42:49.646]   - Field: ‘seed’
[17:42:49.647]   - Field: ‘version’
[17:42:49.647]   - Field: ‘result’
[17:42:49.647]   - Field: ‘asynchronous’
[17:42:49.647]   - Field: ‘calls’
[17:42:49.647]   - Field: ‘globals’
[17:42:49.647]   - Field: ‘stdout’
[17:42:49.647]   - Field: ‘earlySignal’
[17:42:49.647]   - Field: ‘lazy’
[17:42:49.647]   - Field: ‘state’
[17:42:49.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.648] - Launch lazy future ...
[17:42:49.648] Packages needed by the future expression (n = 0): <none>
[17:42:49.648] Packages needed by future strategies (n = 0): <none>
[17:42:49.648] {
[17:42:49.648]     {
[17:42:49.648]         {
[17:42:49.648]             ...future.startTime <- base::Sys.time()
[17:42:49.648]             {
[17:42:49.648]                 {
[17:42:49.648]                   {
[17:42:49.648]                     {
[17:42:49.648]                       base::local({
[17:42:49.648]                         has_future <- base::requireNamespace("future", 
[17:42:49.648]                           quietly = TRUE)
[17:42:49.648]                         if (has_future) {
[17:42:49.648]                           ns <- base::getNamespace("future")
[17:42:49.648]                           version <- ns[[".package"]][["version"]]
[17:42:49.648]                           if (is.null(version)) 
[17:42:49.648]                             version <- utils::packageVersion("future")
[17:42:49.648]                         }
[17:42:49.648]                         else {
[17:42:49.648]                           version <- NULL
[17:42:49.648]                         }
[17:42:49.648]                         if (!has_future || version < "1.8.0") {
[17:42:49.648]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.648]                             "", base::R.version$version.string), 
[17:42:49.648]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:49.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:49.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.648]                               "release", "version")], collapse = " "), 
[17:42:49.648]                             hostname = base::Sys.info()[["nodename"]])
[17:42:49.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.648]                             info)
[17:42:49.648]                           info <- base::paste(info, collapse = "; ")
[17:42:49.648]                           if (!has_future) {
[17:42:49.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.648]                               info)
[17:42:49.648]                           }
[17:42:49.648]                           else {
[17:42:49.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.648]                               info, version)
[17:42:49.648]                           }
[17:42:49.648]                           base::stop(msg)
[17:42:49.648]                         }
[17:42:49.648]                       })
[17:42:49.648]                     }
[17:42:49.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.648]                     base::options(mc.cores = 1L)
[17:42:49.648]                   }
[17:42:49.648]                   options(future.plan = NULL)
[17:42:49.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.648]                 }
[17:42:49.648]                 ...future.workdir <- getwd()
[17:42:49.648]             }
[17:42:49.648]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.648]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.648]         }
[17:42:49.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.648]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.648]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.648]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.648]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.648]             base::names(...future.oldOptions))
[17:42:49.648]     }
[17:42:49.648]     if (FALSE) {
[17:42:49.648]     }
[17:42:49.648]     else {
[17:42:49.648]         if (TRUE) {
[17:42:49.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.648]                 open = "w")
[17:42:49.648]         }
[17:42:49.648]         else {
[17:42:49.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.648]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.648]         }
[17:42:49.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.648]             base::sink(type = "output", split = FALSE)
[17:42:49.648]             base::close(...future.stdout)
[17:42:49.648]         }, add = TRUE)
[17:42:49.648]     }
[17:42:49.648]     ...future.frame <- base::sys.nframe()
[17:42:49.648]     ...future.conditions <- base::list()
[17:42:49.648]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.648]     if (FALSE) {
[17:42:49.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.648]     }
[17:42:49.648]     ...future.result <- base::tryCatch({
[17:42:49.648]         base::withCallingHandlers({
[17:42:49.648]             ...future.value <- base::withVisible(base::local({
[17:42:49.648]                 ...future.makeSendCondition <- local({
[17:42:49.648]                   sendCondition <- NULL
[17:42:49.648]                   function(frame = 1L) {
[17:42:49.648]                     if (is.function(sendCondition)) 
[17:42:49.648]                       return(sendCondition)
[17:42:49.648]                     ns <- getNamespace("parallel")
[17:42:49.648]                     if (exists("sendData", mode = "function", 
[17:42:49.648]                       envir = ns)) {
[17:42:49.648]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.648]                         envir = ns)
[17:42:49.648]                       envir <- sys.frame(frame)
[17:42:49.648]                       master <- NULL
[17:42:49.648]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.648]                         !identical(envir, emptyenv())) {
[17:42:49.648]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.648]                           inherits = FALSE)) {
[17:42:49.648]                           master <- get("master", mode = "list", 
[17:42:49.648]                             envir = envir, inherits = FALSE)
[17:42:49.648]                           if (inherits(master, c("SOCKnode", 
[17:42:49.648]                             "SOCK0node"))) {
[17:42:49.648]                             sendCondition <<- function(cond) {
[17:42:49.648]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.648]                                 success = TRUE)
[17:42:49.648]                               parallel_sendData(master, data)
[17:42:49.648]                             }
[17:42:49.648]                             return(sendCondition)
[17:42:49.648]                           }
[17:42:49.648]                         }
[17:42:49.648]                         frame <- frame + 1L
[17:42:49.648]                         envir <- sys.frame(frame)
[17:42:49.648]                       }
[17:42:49.648]                     }
[17:42:49.648]                     sendCondition <<- function(cond) NULL
[17:42:49.648]                   }
[17:42:49.648]                 })
[17:42:49.648]                 withCallingHandlers({
[17:42:49.648]                   {
[17:42:49.648]                     x <- x + 1
[17:42:49.648]                     x
[17:42:49.648]                   }
[17:42:49.648]                 }, immediateCondition = function(cond) {
[17:42:49.648]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.648]                   sendCondition(cond)
[17:42:49.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.648]                   {
[17:42:49.648]                     inherits <- base::inherits
[17:42:49.648]                     invokeRestart <- base::invokeRestart
[17:42:49.648]                     is.null <- base::is.null
[17:42:49.648]                     muffled <- FALSE
[17:42:49.648]                     if (inherits(cond, "message")) {
[17:42:49.648]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.648]                       if (muffled) 
[17:42:49.648]                         invokeRestart("muffleMessage")
[17:42:49.648]                     }
[17:42:49.648]                     else if (inherits(cond, "warning")) {
[17:42:49.648]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.648]                       if (muffled) 
[17:42:49.648]                         invokeRestart("muffleWarning")
[17:42:49.648]                     }
[17:42:49.648]                     else if (inherits(cond, "condition")) {
[17:42:49.648]                       if (!is.null(pattern)) {
[17:42:49.648]                         computeRestarts <- base::computeRestarts
[17:42:49.648]                         grepl <- base::grepl
[17:42:49.648]                         restarts <- computeRestarts(cond)
[17:42:49.648]                         for (restart in restarts) {
[17:42:49.648]                           name <- restart$name
[17:42:49.648]                           if (is.null(name)) 
[17:42:49.648]                             next
[17:42:49.648]                           if (!grepl(pattern, name)) 
[17:42:49.648]                             next
[17:42:49.648]                           invokeRestart(restart)
[17:42:49.648]                           muffled <- TRUE
[17:42:49.648]                           break
[17:42:49.648]                         }
[17:42:49.648]                       }
[17:42:49.648]                     }
[17:42:49.648]                     invisible(muffled)
[17:42:49.648]                   }
[17:42:49.648]                   muffleCondition(cond)
[17:42:49.648]                 })
[17:42:49.648]             }))
[17:42:49.648]             future::FutureResult(value = ...future.value$value, 
[17:42:49.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.648]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.648]                     ...future.globalenv.names))
[17:42:49.648]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.648]         }, condition = base::local({
[17:42:49.648]             c <- base::c
[17:42:49.648]             inherits <- base::inherits
[17:42:49.648]             invokeRestart <- base::invokeRestart
[17:42:49.648]             length <- base::length
[17:42:49.648]             list <- base::list
[17:42:49.648]             seq.int <- base::seq.int
[17:42:49.648]             signalCondition <- base::signalCondition
[17:42:49.648]             sys.calls <- base::sys.calls
[17:42:49.648]             `[[` <- base::`[[`
[17:42:49.648]             `+` <- base::`+`
[17:42:49.648]             `<<-` <- base::`<<-`
[17:42:49.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.648]                   3L)]
[17:42:49.648]             }
[17:42:49.648]             function(cond) {
[17:42:49.648]                 is_error <- inherits(cond, "error")
[17:42:49.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.648]                   NULL)
[17:42:49.648]                 if (is_error) {
[17:42:49.648]                   sessionInformation <- function() {
[17:42:49.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.648]                       search = base::search(), system = base::Sys.info())
[17:42:49.648]                   }
[17:42:49.648]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.648]                     cond$call), session = sessionInformation(), 
[17:42:49.648]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.648]                   signalCondition(cond)
[17:42:49.648]                 }
[17:42:49.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.648]                 "immediateCondition"))) {
[17:42:49.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.648]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.648]                   if (TRUE && !signal) {
[17:42:49.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.648]                     {
[17:42:49.648]                       inherits <- base::inherits
[17:42:49.648]                       invokeRestart <- base::invokeRestart
[17:42:49.648]                       is.null <- base::is.null
[17:42:49.648]                       muffled <- FALSE
[17:42:49.648]                       if (inherits(cond, "message")) {
[17:42:49.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.648]                         if (muffled) 
[17:42:49.648]                           invokeRestart("muffleMessage")
[17:42:49.648]                       }
[17:42:49.648]                       else if (inherits(cond, "warning")) {
[17:42:49.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.648]                         if (muffled) 
[17:42:49.648]                           invokeRestart("muffleWarning")
[17:42:49.648]                       }
[17:42:49.648]                       else if (inherits(cond, "condition")) {
[17:42:49.648]                         if (!is.null(pattern)) {
[17:42:49.648]                           computeRestarts <- base::computeRestarts
[17:42:49.648]                           grepl <- base::grepl
[17:42:49.648]                           restarts <- computeRestarts(cond)
[17:42:49.648]                           for (restart in restarts) {
[17:42:49.648]                             name <- restart$name
[17:42:49.648]                             if (is.null(name)) 
[17:42:49.648]                               next
[17:42:49.648]                             if (!grepl(pattern, name)) 
[17:42:49.648]                               next
[17:42:49.648]                             invokeRestart(restart)
[17:42:49.648]                             muffled <- TRUE
[17:42:49.648]                             break
[17:42:49.648]                           }
[17:42:49.648]                         }
[17:42:49.648]                       }
[17:42:49.648]                       invisible(muffled)
[17:42:49.648]                     }
[17:42:49.648]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.648]                   }
[17:42:49.648]                 }
[17:42:49.648]                 else {
[17:42:49.648]                   if (TRUE) {
[17:42:49.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.648]                     {
[17:42:49.648]                       inherits <- base::inherits
[17:42:49.648]                       invokeRestart <- base::invokeRestart
[17:42:49.648]                       is.null <- base::is.null
[17:42:49.648]                       muffled <- FALSE
[17:42:49.648]                       if (inherits(cond, "message")) {
[17:42:49.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.648]                         if (muffled) 
[17:42:49.648]                           invokeRestart("muffleMessage")
[17:42:49.648]                       }
[17:42:49.648]                       else if (inherits(cond, "warning")) {
[17:42:49.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.648]                         if (muffled) 
[17:42:49.648]                           invokeRestart("muffleWarning")
[17:42:49.648]                       }
[17:42:49.648]                       else if (inherits(cond, "condition")) {
[17:42:49.648]                         if (!is.null(pattern)) {
[17:42:49.648]                           computeRestarts <- base::computeRestarts
[17:42:49.648]                           grepl <- base::grepl
[17:42:49.648]                           restarts <- computeRestarts(cond)
[17:42:49.648]                           for (restart in restarts) {
[17:42:49.648]                             name <- restart$name
[17:42:49.648]                             if (is.null(name)) 
[17:42:49.648]                               next
[17:42:49.648]                             if (!grepl(pattern, name)) 
[17:42:49.648]                               next
[17:42:49.648]                             invokeRestart(restart)
[17:42:49.648]                             muffled <- TRUE
[17:42:49.648]                             break
[17:42:49.648]                           }
[17:42:49.648]                         }
[17:42:49.648]                       }
[17:42:49.648]                       invisible(muffled)
[17:42:49.648]                     }
[17:42:49.648]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.648]                   }
[17:42:49.648]                 }
[17:42:49.648]             }
[17:42:49.648]         }))
[17:42:49.648]     }, error = function(ex) {
[17:42:49.648]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.648]                 ...future.rng), started = ...future.startTime, 
[17:42:49.648]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.648]             version = "1.8"), class = "FutureResult")
[17:42:49.648]     }, finally = {
[17:42:49.648]         if (!identical(...future.workdir, getwd())) 
[17:42:49.648]             setwd(...future.workdir)
[17:42:49.648]         {
[17:42:49.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.648]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.648]             }
[17:42:49.648]             base::options(...future.oldOptions)
[17:42:49.648]             if (.Platform$OS.type == "windows") {
[17:42:49.648]                 old_names <- names(...future.oldEnvVars)
[17:42:49.648]                 envs <- base::Sys.getenv()
[17:42:49.648]                 names <- names(envs)
[17:42:49.648]                 common <- intersect(names, old_names)
[17:42:49.648]                 added <- setdiff(names, old_names)
[17:42:49.648]                 removed <- setdiff(old_names, names)
[17:42:49.648]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.648]                   envs[common]]
[17:42:49.648]                 NAMES <- toupper(changed)
[17:42:49.648]                 args <- list()
[17:42:49.648]                 for (kk in seq_along(NAMES)) {
[17:42:49.648]                   name <- changed[[kk]]
[17:42:49.648]                   NAME <- NAMES[[kk]]
[17:42:49.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.648]                     next
[17:42:49.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.648]                 }
[17:42:49.648]                 NAMES <- toupper(added)
[17:42:49.648]                 for (kk in seq_along(NAMES)) {
[17:42:49.648]                   name <- added[[kk]]
[17:42:49.648]                   NAME <- NAMES[[kk]]
[17:42:49.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.648]                     next
[17:42:49.648]                   args[[name]] <- ""
[17:42:49.648]                 }
[17:42:49.648]                 NAMES <- toupper(removed)
[17:42:49.648]                 for (kk in seq_along(NAMES)) {
[17:42:49.648]                   name <- removed[[kk]]
[17:42:49.648]                   NAME <- NAMES[[kk]]
[17:42:49.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.648]                     next
[17:42:49.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.648]                 }
[17:42:49.648]                 if (length(args) > 0) 
[17:42:49.648]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.648]             }
[17:42:49.648]             else {
[17:42:49.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.648]             }
[17:42:49.648]             {
[17:42:49.648]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.648]                   0L) {
[17:42:49.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.648]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.648]                   base::options(opts)
[17:42:49.648]                 }
[17:42:49.648]                 {
[17:42:49.648]                   {
[17:42:49.648]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.648]                     NULL
[17:42:49.648]                   }
[17:42:49.648]                   options(future.plan = NULL)
[17:42:49.648]                   if (is.na(NA_character_)) 
[17:42:49.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.648]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.648]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.648]                     envir = parent.frame()) 
[17:42:49.648]                   {
[17:42:49.648]                     if (is.function(workers)) 
[17:42:49.648]                       workers <- workers()
[17:42:49.648]                     workers <- structure(as.integer(workers), 
[17:42:49.648]                       class = class(workers))
[17:42:49.648]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.648]                       workers >= 1)
[17:42:49.648]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.648]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.648]                     }
[17:42:49.648]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.648]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.648]                       envir = envir)
[17:42:49.648]                     if (!future$lazy) 
[17:42:49.648]                       future <- run(future)
[17:42:49.648]                     invisible(future)
[17:42:49.648]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.648]                 }
[17:42:49.648]             }
[17:42:49.648]         }
[17:42:49.648]     })
[17:42:49.648]     if (TRUE) {
[17:42:49.648]         base::sink(type = "output", split = FALSE)
[17:42:49.648]         if (TRUE) {
[17:42:49.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.648]         }
[17:42:49.648]         else {
[17:42:49.648]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.648]         }
[17:42:49.648]         base::close(...future.stdout)
[17:42:49.648]         ...future.stdout <- NULL
[17:42:49.648]     }
[17:42:49.648]     ...future.result$conditions <- ...future.conditions
[17:42:49.648]     ...future.result$finished <- base::Sys.time()
[17:42:49.648]     ...future.result
[17:42:49.648] }
[17:42:49.651] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:42:49.651] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[17:42:49.652] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[17:42:49.652] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:42:49.652] MultisessionFuture started
[17:42:49.652] - Launch lazy future ... done
[17:42:49.653] run() for ‘MultisessionFuture’ ... done
[17:42:49.653] result() for ClusterFuture ...
[17:42:49.653] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.653] - Validating connection of MultisessionFuture
[17:42:49.700] - received message: FutureResult
[17:42:49.701] - Received FutureResult
[17:42:49.701] - Erased future from FutureRegistry
[17:42:49.701] result() for ClusterFuture ...
[17:42:49.701] - result already collected: FutureResult
[17:42:49.701] result() for ClusterFuture ... done
[17:42:49.701] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.701] result() for ClusterFuture ... done
[17:42:49.701] result() for ClusterFuture ...
[17:42:49.701] - result already collected: FutureResult
[17:42:49.701] result() for ClusterFuture ... done
value(f) = ‘2’
Warning: R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[17:42:49.702] getGlobalsAndPackages() ...
Warning: R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[17:42:49.702] Searching for globals...
Warning: R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[17:42:49.704] - globals found: [3] ‘{’, ‘<-’, ‘x’
[17:42:49.704] Searching for globals ... DONE
[17:42:49.704] Resolving globals: TRUE
[17:42:49.704] Resolving any globals that are futures ...
[17:42:49.704] - globals: [3] ‘{’, ‘<-’, ‘x’
[17:42:49.704] Resolving any globals that are futures ... DONE
[17:42:49.705] Resolving futures part of globals (recursively) ...
[17:42:49.705] resolve() on list ...
[17:42:49.705]  recursive: 99
[17:42:49.705]  length: 1
[17:42:49.705]  elements: ‘x’
[17:42:49.705]  length: 0 (resolved future 1)
[17:42:49.705] resolve() on list ... DONE
[17:42:49.705] - globals: [1] ‘x’
[17:42:49.706] Resolving futures part of globals (recursively) ... DONE
[17:42:49.706] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[17:42:49.706] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[17:42:49.706] - globals: [1] ‘x’
[17:42:49.706] 
[17:42:49.706] getGlobalsAndPackages() ... DONE
[17:42:49.707] run() for ‘Future’ ...
[17:42:49.707] - state: ‘created’
[17:42:49.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:49.721] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:49.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:49.721]   - Field: ‘node’
[17:42:49.721]   - Field: ‘label’
[17:42:49.721]   - Field: ‘local’
[17:42:49.722]   - Field: ‘owner’
[17:42:49.722]   - Field: ‘envir’
[17:42:49.722]   - Field: ‘workers’
[17:42:49.722]   - Field: ‘packages’
[17:42:49.722]   - Field: ‘gc’
[17:42:49.722]   - Field: ‘conditions’
[17:42:49.722]   - Field: ‘persistent’
[17:42:49.722]   - Field: ‘expr’
[17:42:49.722]   - Field: ‘uuid’
[17:42:49.722]   - Field: ‘seed’
[17:42:49.722]   - Field: ‘version’
[17:42:49.723]   - Field: ‘result’
[17:42:49.723]   - Field: ‘asynchronous’
[17:42:49.723]   - Field: ‘calls’
[17:42:49.723]   - Field: ‘globals’
[17:42:49.723]   - Field: ‘stdout’
[17:42:49.723]   - Field: ‘earlySignal’
[17:42:49.723]   - Field: ‘lazy’
[17:42:49.723]   - Field: ‘state’
[17:42:49.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:49.723] - Launch lazy future ...
[17:42:49.724] Packages needed by the future expression (n = 0): <none>
[17:42:49.724] Packages needed by future strategies (n = 0): <none>
[17:42:49.724] {
[17:42:49.724]     {
[17:42:49.724]         {
[17:42:49.724]             ...future.startTime <- base::Sys.time()
[17:42:49.724]             {
[17:42:49.724]                 {
[17:42:49.724]                   {
[17:42:49.724]                     {
[17:42:49.724]                       base::local({
[17:42:49.724]                         has_future <- base::requireNamespace("future", 
[17:42:49.724]                           quietly = TRUE)
[17:42:49.724]                         if (has_future) {
[17:42:49.724]                           ns <- base::getNamespace("future")
[17:42:49.724]                           version <- ns[[".package"]][["version"]]
[17:42:49.724]                           if (is.null(version)) 
[17:42:49.724]                             version <- utils::packageVersion("future")
[17:42:49.724]                         }
[17:42:49.724]                         else {
[17:42:49.724]                           version <- NULL
[17:42:49.724]                         }
[17:42:49.724]                         if (!has_future || version < "1.8.0") {
[17:42:49.724]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:49.724]                             "", base::R.version$version.string), 
[17:42:49.724]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:49.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:49.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:49.724]                               "release", "version")], collapse = " "), 
[17:42:49.724]                             hostname = base::Sys.info()[["nodename"]])
[17:42:49.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:49.724]                             info)
[17:42:49.724]                           info <- base::paste(info, collapse = "; ")
[17:42:49.724]                           if (!has_future) {
[17:42:49.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:49.724]                               info)
[17:42:49.724]                           }
[17:42:49.724]                           else {
[17:42:49.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:49.724]                               info, version)
[17:42:49.724]                           }
[17:42:49.724]                           base::stop(msg)
[17:42:49.724]                         }
[17:42:49.724]                       })
[17:42:49.724]                     }
[17:42:49.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:49.724]                     base::options(mc.cores = 1L)
[17:42:49.724]                   }
[17:42:49.724]                   options(future.plan = NULL)
[17:42:49.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:49.724]                 }
[17:42:49.724]                 ...future.workdir <- getwd()
[17:42:49.724]             }
[17:42:49.724]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:49.724]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:49.724]         }
[17:42:49.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[17:42:49.724]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[17:42:49.724]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[17:42:49.724]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[17:42:49.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:49.724]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:49.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:49.724]             base::names(...future.oldOptions))
[17:42:49.724]     }
[17:42:49.724]     if (FALSE) {
[17:42:49.724]     }
[17:42:49.724]     else {
[17:42:49.724]         if (TRUE) {
[17:42:49.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:49.724]                 open = "w")
[17:42:49.724]         }
[17:42:49.724]         else {
[17:42:49.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:49.724]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:49.724]         }
[17:42:49.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:49.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:49.724]             base::sink(type = "output", split = FALSE)
[17:42:49.724]             base::close(...future.stdout)
[17:42:49.724]         }, add = TRUE)
[17:42:49.724]     }
[17:42:49.724]     ...future.frame <- base::sys.nframe()
[17:42:49.724]     ...future.conditions <- base::list()
[17:42:49.724]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:49.724]     if (FALSE) {
[17:42:49.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:49.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:49.724]     }
[17:42:49.724]     ...future.result <- base::tryCatch({
[17:42:49.724]         base::withCallingHandlers({
[17:42:49.724]             ...future.value <- base::withVisible(base::local({
[17:42:49.724]                 ...future.makeSendCondition <- local({
[17:42:49.724]                   sendCondition <- NULL
[17:42:49.724]                   function(frame = 1L) {
[17:42:49.724]                     if (is.function(sendCondition)) 
[17:42:49.724]                       return(sendCondition)
[17:42:49.724]                     ns <- getNamespace("parallel")
[17:42:49.724]                     if (exists("sendData", mode = "function", 
[17:42:49.724]                       envir = ns)) {
[17:42:49.724]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:49.724]                         envir = ns)
[17:42:49.724]                       envir <- sys.frame(frame)
[17:42:49.724]                       master <- NULL
[17:42:49.724]                       while (!identical(envir, .GlobalEnv) && 
[17:42:49.724]                         !identical(envir, emptyenv())) {
[17:42:49.724]                         if (exists("master", mode = "list", envir = envir, 
[17:42:49.724]                           inherits = FALSE)) {
[17:42:49.724]                           master <- get("master", mode = "list", 
[17:42:49.724]                             envir = envir, inherits = FALSE)
[17:42:49.724]                           if (inherits(master, c("SOCKnode", 
[17:42:49.724]                             "SOCK0node"))) {
[17:42:49.724]                             sendCondition <<- function(cond) {
[17:42:49.724]                               data <- list(type = "VALUE", value = cond, 
[17:42:49.724]                                 success = TRUE)
[17:42:49.724]                               parallel_sendData(master, data)
[17:42:49.724]                             }
[17:42:49.724]                             return(sendCondition)
[17:42:49.724]                           }
[17:42:49.724]                         }
[17:42:49.724]                         frame <- frame + 1L
[17:42:49.724]                         envir <- sys.frame(frame)
[17:42:49.724]                       }
[17:42:49.724]                     }
[17:42:49.724]                     sendCondition <<- function(cond) NULL
[17:42:49.724]                   }
[17:42:49.724]                 })
[17:42:49.724]                 withCallingHandlers({
[17:42:49.724]                   {
[17:42:49.724]                     x <- x()
[17:42:49.724]                     x
[17:42:49.724]                   }
[17:42:49.724]                 }, immediateCondition = function(cond) {
[17:42:49.724]                   sendCondition <- ...future.makeSendCondition()
[17:42:49.724]                   sendCondition(cond)
[17:42:49.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.724]                   {
[17:42:49.724]                     inherits <- base::inherits
[17:42:49.724]                     invokeRestart <- base::invokeRestart
[17:42:49.724]                     is.null <- base::is.null
[17:42:49.724]                     muffled <- FALSE
[17:42:49.724]                     if (inherits(cond, "message")) {
[17:42:49.724]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:49.724]                       if (muffled) 
[17:42:49.724]                         invokeRestart("muffleMessage")
[17:42:49.724]                     }
[17:42:49.724]                     else if (inherits(cond, "warning")) {
[17:42:49.724]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:49.724]                       if (muffled) 
[17:42:49.724]                         invokeRestart("muffleWarning")
[17:42:49.724]                     }
[17:42:49.724]                     else if (inherits(cond, "condition")) {
[17:42:49.724]                       if (!is.null(pattern)) {
[17:42:49.724]                         computeRestarts <- base::computeRestarts
[17:42:49.724]                         grepl <- base::grepl
[17:42:49.724]                         restarts <- computeRestarts(cond)
[17:42:49.724]                         for (restart in restarts) {
[17:42:49.724]                           name <- restart$name
[17:42:49.724]                           if (is.null(name)) 
[17:42:49.724]                             next
[17:42:49.724]                           if (!grepl(pattern, name)) 
[17:42:49.724]                             next
[17:42:49.724]                           invokeRestart(restart)
[17:42:49.724]                           muffled <- TRUE
[17:42:49.724]                           break
[17:42:49.724]                         }
[17:42:49.724]                       }
[17:42:49.724]                     }
[17:42:49.724]                     invisible(muffled)
[17:42:49.724]                   }
[17:42:49.724]                   muffleCondition(cond)
[17:42:49.724]                 })
[17:42:49.724]             }))
[17:42:49.724]             future::FutureResult(value = ...future.value$value, 
[17:42:49.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.724]                   ...future.rng), globalenv = if (FALSE) 
[17:42:49.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:49.724]                     ...future.globalenv.names))
[17:42:49.724]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:49.724]         }, condition = base::local({
[17:42:49.724]             c <- base::c
[17:42:49.724]             inherits <- base::inherits
[17:42:49.724]             invokeRestart <- base::invokeRestart
[17:42:49.724]             length <- base::length
[17:42:49.724]             list <- base::list
[17:42:49.724]             seq.int <- base::seq.int
[17:42:49.724]             signalCondition <- base::signalCondition
[17:42:49.724]             sys.calls <- base::sys.calls
[17:42:49.724]             `[[` <- base::`[[`
[17:42:49.724]             `+` <- base::`+`
[17:42:49.724]             `<<-` <- base::`<<-`
[17:42:49.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:49.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:49.724]                   3L)]
[17:42:49.724]             }
[17:42:49.724]             function(cond) {
[17:42:49.724]                 is_error <- inherits(cond, "error")
[17:42:49.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:49.724]                   NULL)
[17:42:49.724]                 if (is_error) {
[17:42:49.724]                   sessionInformation <- function() {
[17:42:49.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:49.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:49.724]                       search = base::search(), system = base::Sys.info())
[17:42:49.724]                   }
[17:42:49.724]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:49.724]                     cond$call), session = sessionInformation(), 
[17:42:49.724]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:49.724]                   signalCondition(cond)
[17:42:49.724]                 }
[17:42:49.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:49.724]                 "immediateCondition"))) {
[17:42:49.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:49.724]                   ...future.conditions[[length(...future.conditions) + 
[17:42:49.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:49.724]                   if (TRUE && !signal) {
[17:42:49.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.724]                     {
[17:42:49.724]                       inherits <- base::inherits
[17:42:49.724]                       invokeRestart <- base::invokeRestart
[17:42:49.724]                       is.null <- base::is.null
[17:42:49.724]                       muffled <- FALSE
[17:42:49.724]                       if (inherits(cond, "message")) {
[17:42:49.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.724]                         if (muffled) 
[17:42:49.724]                           invokeRestart("muffleMessage")
[17:42:49.724]                       }
[17:42:49.724]                       else if (inherits(cond, "warning")) {
[17:42:49.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.724]                         if (muffled) 
[17:42:49.724]                           invokeRestart("muffleWarning")
[17:42:49.724]                       }
[17:42:49.724]                       else if (inherits(cond, "condition")) {
[17:42:49.724]                         if (!is.null(pattern)) {
[17:42:49.724]                           computeRestarts <- base::computeRestarts
[17:42:49.724]                           grepl <- base::grepl
[17:42:49.724]                           restarts <- computeRestarts(cond)
[17:42:49.724]                           for (restart in restarts) {
[17:42:49.724]                             name <- restart$name
[17:42:49.724]                             if (is.null(name)) 
[17:42:49.724]                               next
[17:42:49.724]                             if (!grepl(pattern, name)) 
[17:42:49.724]                               next
[17:42:49.724]                             invokeRestart(restart)
[17:42:49.724]                             muffled <- TRUE
[17:42:49.724]                             break
[17:42:49.724]                           }
[17:42:49.724]                         }
[17:42:49.724]                       }
[17:42:49.724]                       invisible(muffled)
[17:42:49.724]                     }
[17:42:49.724]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.724]                   }
[17:42:49.724]                 }
[17:42:49.724]                 else {
[17:42:49.724]                   if (TRUE) {
[17:42:49.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:49.724]                     {
[17:42:49.724]                       inherits <- base::inherits
[17:42:49.724]                       invokeRestart <- base::invokeRestart
[17:42:49.724]                       is.null <- base::is.null
[17:42:49.724]                       muffled <- FALSE
[17:42:49.724]                       if (inherits(cond, "message")) {
[17:42:49.724]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:49.724]                         if (muffled) 
[17:42:49.724]                           invokeRestart("muffleMessage")
[17:42:49.724]                       }
[17:42:49.724]                       else if (inherits(cond, "warning")) {
[17:42:49.724]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:49.724]                         if (muffled) 
[17:42:49.724]                           invokeRestart("muffleWarning")
[17:42:49.724]                       }
[17:42:49.724]                       else if (inherits(cond, "condition")) {
[17:42:49.724]                         if (!is.null(pattern)) {
[17:42:49.724]                           computeRestarts <- base::computeRestarts
[17:42:49.724]                           grepl <- base::grepl
[17:42:49.724]                           restarts <- computeRestarts(cond)
[17:42:49.724]                           for (restart in restarts) {
[17:42:49.724]                             name <- restart$name
[17:42:49.724]                             if (is.null(name)) 
[17:42:49.724]                               next
[17:42:49.724]                             if (!grepl(pattern, name)) 
[17:42:49.724]                               next
[17:42:49.724]                             invokeRestart(restart)
[17:42:49.724]                             muffled <- TRUE
[17:42:49.724]                             break
[17:42:49.724]                           }
[17:42:49.724]                         }
[17:42:49.724]                       }
[17:42:49.724]                       invisible(muffled)
[17:42:49.724]                     }
[17:42:49.724]                     muffleCondition(cond, pattern = "^muffle")
[17:42:49.724]                   }
[17:42:49.724]                 }
[17:42:49.724]             }
[17:42:49.724]         }))
[17:42:49.724]     }, error = function(ex) {
[17:42:49.724]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:49.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:49.724]                 ...future.rng), started = ...future.startTime, 
[17:42:49.724]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:49.724]             version = "1.8"), class = "FutureResult")
[17:42:49.724]     }, finally = {
[17:42:49.724]         if (!identical(...future.workdir, getwd())) 
[17:42:49.724]             setwd(...future.workdir)
[17:42:49.724]         {
[17:42:49.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:49.724]                 ...future.oldOptions$nwarnings <- NULL
[17:42:49.724]             }
[17:42:49.724]             base::options(...future.oldOptions)
[17:42:49.724]             if (.Platform$OS.type == "windows") {
[17:42:49.724]                 old_names <- names(...future.oldEnvVars)
[17:42:49.724]                 envs <- base::Sys.getenv()
[17:42:49.724]                 names <- names(envs)
[17:42:49.724]                 common <- intersect(names, old_names)
[17:42:49.724]                 added <- setdiff(names, old_names)
[17:42:49.724]                 removed <- setdiff(old_names, names)
[17:42:49.724]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:49.724]                   envs[common]]
[17:42:49.724]                 NAMES <- toupper(changed)
[17:42:49.724]                 args <- list()
[17:42:49.724]                 for (kk in seq_along(NAMES)) {
[17:42:49.724]                   name <- changed[[kk]]
[17:42:49.724]                   NAME <- NAMES[[kk]]
[17:42:49.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.724]                     next
[17:42:49.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.724]                 }
[17:42:49.724]                 NAMES <- toupper(added)
[17:42:49.724]                 for (kk in seq_along(NAMES)) {
[17:42:49.724]                   name <- added[[kk]]
[17:42:49.724]                   NAME <- NAMES[[kk]]
[17:42:49.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.724]                     next
[17:42:49.724]                   args[[name]] <- ""
[17:42:49.724]                 }
[17:42:49.724]                 NAMES <- toupper(removed)
[17:42:49.724]                 for (kk in seq_along(NAMES)) {
[17:42:49.724]                   name <- removed[[kk]]
[17:42:49.724]                   NAME <- NAMES[[kk]]
[17:42:49.724]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:49.724]                     next
[17:42:49.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:49.724]                 }
[17:42:49.724]                 if (length(args) > 0) 
[17:42:49.724]                   base::do.call(base::Sys.setenv, args = args)
[17:42:49.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:49.724]             }
[17:42:49.724]             else {
[17:42:49.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:49.724]             }
[17:42:49.724]             {
[17:42:49.724]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:49.724]                   0L) {
[17:42:49.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:49.724]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:49.724]                   base::options(opts)
[17:42:49.724]                 }
[17:42:49.724]                 {
[17:42:49.724]                   {
[17:42:49.724]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:49.724]                     NULL
[17:42:49.724]                   }
[17:42:49.724]                   options(future.plan = NULL)
[17:42:49.724]                   if (is.na(NA_character_)) 
[17:42:49.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:49.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:49.724]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:49.724]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:49.724]                     envir = parent.frame()) 
[17:42:49.724]                   {
[17:42:49.724]                     if (is.function(workers)) 
[17:42:49.724]                       workers <- workers()
[17:42:49.724]                     workers <- structure(as.integer(workers), 
[17:42:49.724]                       class = class(workers))
[17:42:49.724]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:49.724]                       workers >= 1)
[17:42:49.724]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:49.724]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:49.724]                     }
[17:42:49.724]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:49.724]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:49.724]                       envir = envir)
[17:42:49.724]                     if (!future$lazy) 
[17:42:49.724]                       future <- run(future)
[17:42:49.724]                     invisible(future)
[17:42:49.724]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:49.724]                 }
[17:42:49.724]             }
[17:42:49.724]         }
[17:42:49.724]     })
[17:42:49.724]     if (TRUE) {
[17:42:49.724]         base::sink(type = "output", split = FALSE)
[17:42:49.724]         if (TRUE) {
[17:42:49.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:49.724]         }
[17:42:49.724]         else {
[17:42:49.724]             ...future.result["stdout"] <- base::list(NULL)
[17:42:49.724]         }
[17:42:49.724]         base::close(...future.stdout)
[17:42:49.724]         ...future.stdout <- NULL
[17:42:49.724]     }
[17:42:49.724]     ...future.result$conditions <- ...future.conditions
[17:42:49.724]     ...future.result$finished <- base::Sys.time()
[17:42:49.724]     ...future.result
[17:42:49.724] }
[17:42:49.727] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[17:42:49.727] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[17:42:49.727] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[17:42:49.728] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[17:42:49.728] MultisessionFuture started
[17:42:49.728] - Launch lazy future ... done
[17:42:49.728] run() for ‘MultisessionFuture’ ... done
[17:42:49.728] result() for ClusterFuture ...
[17:42:49.728] receiveMessageFromWorker() for ClusterFuture ...
[17:42:49.729] - Validating connection of MultisessionFuture
[17:42:49.776] - received message: FutureResult
[17:42:49.776] - Received FutureResult
[17:42:49.777] - Erased future from FutureRegistry
[17:42:49.777] result() for ClusterFuture ...
[17:42:49.777] - result already collected: FutureResult
[17:42:49.777] result() for ClusterFuture ... done
[17:42:49.777] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:49.777] result() for ClusterFuture ... done
[17:42:49.777] result() for ClusterFuture ...
[17:42:49.777] - result already collected: FutureResult
[17:42:49.777] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[17:42:49.778] plan(): Setting new future strategy stack:
[17:42:49.778] List of future strategies:
[17:42:49.778] 1. FutureStrategy:
[17:42:49.778]    - args: function (..., envir = parent.frame())
[17:42:49.778]    - tweaked: FALSE
[17:42:49.778]    - call: future::plan(oplan)
[17:42:49.779] plan(): nbrOfWorkers() = 1
> 
