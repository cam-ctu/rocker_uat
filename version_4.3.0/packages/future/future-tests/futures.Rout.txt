
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:42:18.966] plan(): Setting new future strategy stack:
[17:42:18.967] List of future strategies:
[17:42:18.967] 1. sequential:
[17:42:18.967]    - args: function (..., envir = parent.frame())
[17:42:18.967]    - tweaked: FALSE
[17:42:18.967]    - call: future::plan("sequential")
[17:42:18.980] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[17:42:19.032] plan(): Setting new future strategy stack:
[17:42:19.032] List of future strategies:
[17:42:19.032] 1. sequential:
[17:42:19.032]    - args: function (..., envir = parent.frame())
[17:42:19.032]    - tweaked: FALSE
[17:42:19.032]    - call: plan(strategy)
[17:42:19.044] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:42:19.045] getGlobalsAndPackages() ...
[17:42:19.046] Searching for globals...
[17:42:19.048] 
[17:42:19.048] Searching for globals ... DONE
[17:42:19.048] - globals: [0] <none>
[17:42:19.048] getGlobalsAndPackages() ... DONE
[17:42:19.049] run() for ‘Future’ ...
[17:42:19.049] - state: ‘created’
[17:42:19.049] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.050] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.050]   - Field: ‘label’
[17:42:19.050]   - Field: ‘local’
[17:42:19.050]   - Field: ‘owner’
[17:42:19.050]   - Field: ‘envir’
[17:42:19.050]   - Field: ‘packages’
[17:42:19.050]   - Field: ‘gc’
[17:42:19.050]   - Field: ‘conditions’
[17:42:19.051]   - Field: ‘expr’
[17:42:19.051]   - Field: ‘uuid’
[17:42:19.051]   - Field: ‘seed’
[17:42:19.051]   - Field: ‘version’
[17:42:19.051]   - Field: ‘result’
[17:42:19.051]   - Field: ‘asynchronous’
[17:42:19.051]   - Field: ‘calls’
[17:42:19.051]   - Field: ‘globals’
[17:42:19.051]   - Field: ‘stdout’
[17:42:19.051]   - Field: ‘earlySignal’
[17:42:19.052]   - Field: ‘lazy’
[17:42:19.052]   - Field: ‘state’
[17:42:19.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.052] - Launch lazy future ...
[17:42:19.053] Packages needed by the future expression (n = 0): <none>
[17:42:19.053] Packages needed by future strategies (n = 0): <none>
[17:42:19.054] {
[17:42:19.054]     {
[17:42:19.054]         {
[17:42:19.054]             ...future.startTime <- base::Sys.time()
[17:42:19.054]             {
[17:42:19.054]                 {
[17:42:19.054]                   {
[17:42:19.054]                     base::local({
[17:42:19.054]                       has_future <- base::requireNamespace("future", 
[17:42:19.054]                         quietly = TRUE)
[17:42:19.054]                       if (has_future) {
[17:42:19.054]                         ns <- base::getNamespace("future")
[17:42:19.054]                         version <- ns[[".package"]][["version"]]
[17:42:19.054]                         if (is.null(version)) 
[17:42:19.054]                           version <- utils::packageVersion("future")
[17:42:19.054]                       }
[17:42:19.054]                       else {
[17:42:19.054]                         version <- NULL
[17:42:19.054]                       }
[17:42:19.054]                       if (!has_future || version < "1.8.0") {
[17:42:19.054]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.054]                           "", base::R.version$version.string), 
[17:42:19.054]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.054]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.054]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.054]                             "release", "version")], collapse = " "), 
[17:42:19.054]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.054]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.054]                           info)
[17:42:19.054]                         info <- base::paste(info, collapse = "; ")
[17:42:19.054]                         if (!has_future) {
[17:42:19.054]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.054]                             info)
[17:42:19.054]                         }
[17:42:19.054]                         else {
[17:42:19.054]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.054]                             info, version)
[17:42:19.054]                         }
[17:42:19.054]                         base::stop(msg)
[17:42:19.054]                       }
[17:42:19.054]                     })
[17:42:19.054]                   }
[17:42:19.054]                   options(future.plan = NULL)
[17:42:19.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.054]                 }
[17:42:19.054]                 ...future.workdir <- getwd()
[17:42:19.054]             }
[17:42:19.054]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.054]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.054]         }
[17:42:19.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.054]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.054]             base::names(...future.oldOptions))
[17:42:19.054]     }
[17:42:19.054]     if (FALSE) {
[17:42:19.054]     }
[17:42:19.054]     else {
[17:42:19.054]         if (TRUE) {
[17:42:19.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.054]                 open = "w")
[17:42:19.054]         }
[17:42:19.054]         else {
[17:42:19.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.054]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.054]         }
[17:42:19.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.054]             base::sink(type = "output", split = FALSE)
[17:42:19.054]             base::close(...future.stdout)
[17:42:19.054]         }, add = TRUE)
[17:42:19.054]     }
[17:42:19.054]     ...future.frame <- base::sys.nframe()
[17:42:19.054]     ...future.conditions <- base::list()
[17:42:19.054]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.054]     if (FALSE) {
[17:42:19.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.054]     }
[17:42:19.054]     ...future.result <- base::tryCatch({
[17:42:19.054]         base::withCallingHandlers({
[17:42:19.054]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.054]             future::FutureResult(value = ...future.value$value, 
[17:42:19.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.054]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.054]                     ...future.globalenv.names))
[17:42:19.054]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.054]         }, condition = base::local({
[17:42:19.054]             c <- base::c
[17:42:19.054]             inherits <- base::inherits
[17:42:19.054]             invokeRestart <- base::invokeRestart
[17:42:19.054]             length <- base::length
[17:42:19.054]             list <- base::list
[17:42:19.054]             seq.int <- base::seq.int
[17:42:19.054]             signalCondition <- base::signalCondition
[17:42:19.054]             sys.calls <- base::sys.calls
[17:42:19.054]             `[[` <- base::`[[`
[17:42:19.054]             `+` <- base::`+`
[17:42:19.054]             `<<-` <- base::`<<-`
[17:42:19.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.054]                   3L)]
[17:42:19.054]             }
[17:42:19.054]             function(cond) {
[17:42:19.054]                 is_error <- inherits(cond, "error")
[17:42:19.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.054]                   NULL)
[17:42:19.054]                 if (is_error) {
[17:42:19.054]                   sessionInformation <- function() {
[17:42:19.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.054]                       search = base::search(), system = base::Sys.info())
[17:42:19.054]                   }
[17:42:19.054]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.054]                     cond$call), session = sessionInformation(), 
[17:42:19.054]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.054]                   signalCondition(cond)
[17:42:19.054]                 }
[17:42:19.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.054]                 "immediateCondition"))) {
[17:42:19.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.054]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.054]                   if (TRUE && !signal) {
[17:42:19.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.054]                     {
[17:42:19.054]                       inherits <- base::inherits
[17:42:19.054]                       invokeRestart <- base::invokeRestart
[17:42:19.054]                       is.null <- base::is.null
[17:42:19.054]                       muffled <- FALSE
[17:42:19.054]                       if (inherits(cond, "message")) {
[17:42:19.054]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.054]                         if (muffled) 
[17:42:19.054]                           invokeRestart("muffleMessage")
[17:42:19.054]                       }
[17:42:19.054]                       else if (inherits(cond, "warning")) {
[17:42:19.054]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.054]                         if (muffled) 
[17:42:19.054]                           invokeRestart("muffleWarning")
[17:42:19.054]                       }
[17:42:19.054]                       else if (inherits(cond, "condition")) {
[17:42:19.054]                         if (!is.null(pattern)) {
[17:42:19.054]                           computeRestarts <- base::computeRestarts
[17:42:19.054]                           grepl <- base::grepl
[17:42:19.054]                           restarts <- computeRestarts(cond)
[17:42:19.054]                           for (restart in restarts) {
[17:42:19.054]                             name <- restart$name
[17:42:19.054]                             if (is.null(name)) 
[17:42:19.054]                               next
[17:42:19.054]                             if (!grepl(pattern, name)) 
[17:42:19.054]                               next
[17:42:19.054]                             invokeRestart(restart)
[17:42:19.054]                             muffled <- TRUE
[17:42:19.054]                             break
[17:42:19.054]                           }
[17:42:19.054]                         }
[17:42:19.054]                       }
[17:42:19.054]                       invisible(muffled)
[17:42:19.054]                     }
[17:42:19.054]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.054]                   }
[17:42:19.054]                 }
[17:42:19.054]                 else {
[17:42:19.054]                   if (TRUE) {
[17:42:19.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.054]                     {
[17:42:19.054]                       inherits <- base::inherits
[17:42:19.054]                       invokeRestart <- base::invokeRestart
[17:42:19.054]                       is.null <- base::is.null
[17:42:19.054]                       muffled <- FALSE
[17:42:19.054]                       if (inherits(cond, "message")) {
[17:42:19.054]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.054]                         if (muffled) 
[17:42:19.054]                           invokeRestart("muffleMessage")
[17:42:19.054]                       }
[17:42:19.054]                       else if (inherits(cond, "warning")) {
[17:42:19.054]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.054]                         if (muffled) 
[17:42:19.054]                           invokeRestart("muffleWarning")
[17:42:19.054]                       }
[17:42:19.054]                       else if (inherits(cond, "condition")) {
[17:42:19.054]                         if (!is.null(pattern)) {
[17:42:19.054]                           computeRestarts <- base::computeRestarts
[17:42:19.054]                           grepl <- base::grepl
[17:42:19.054]                           restarts <- computeRestarts(cond)
[17:42:19.054]                           for (restart in restarts) {
[17:42:19.054]                             name <- restart$name
[17:42:19.054]                             if (is.null(name)) 
[17:42:19.054]                               next
[17:42:19.054]                             if (!grepl(pattern, name)) 
[17:42:19.054]                               next
[17:42:19.054]                             invokeRestart(restart)
[17:42:19.054]                             muffled <- TRUE
[17:42:19.054]                             break
[17:42:19.054]                           }
[17:42:19.054]                         }
[17:42:19.054]                       }
[17:42:19.054]                       invisible(muffled)
[17:42:19.054]                     }
[17:42:19.054]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.054]                   }
[17:42:19.054]                 }
[17:42:19.054]             }
[17:42:19.054]         }))
[17:42:19.054]     }, error = function(ex) {
[17:42:19.054]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.054]                 ...future.rng), started = ...future.startTime, 
[17:42:19.054]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.054]             version = "1.8"), class = "FutureResult")
[17:42:19.054]     }, finally = {
[17:42:19.054]         if (!identical(...future.workdir, getwd())) 
[17:42:19.054]             setwd(...future.workdir)
[17:42:19.054]         {
[17:42:19.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.054]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.054]             }
[17:42:19.054]             base::options(...future.oldOptions)
[17:42:19.054]             if (.Platform$OS.type == "windows") {
[17:42:19.054]                 old_names <- names(...future.oldEnvVars)
[17:42:19.054]                 envs <- base::Sys.getenv()
[17:42:19.054]                 names <- names(envs)
[17:42:19.054]                 common <- intersect(names, old_names)
[17:42:19.054]                 added <- setdiff(names, old_names)
[17:42:19.054]                 removed <- setdiff(old_names, names)
[17:42:19.054]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.054]                   envs[common]]
[17:42:19.054]                 NAMES <- toupper(changed)
[17:42:19.054]                 args <- list()
[17:42:19.054]                 for (kk in seq_along(NAMES)) {
[17:42:19.054]                   name <- changed[[kk]]
[17:42:19.054]                   NAME <- NAMES[[kk]]
[17:42:19.054]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.054]                     next
[17:42:19.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.054]                 }
[17:42:19.054]                 NAMES <- toupper(added)
[17:42:19.054]                 for (kk in seq_along(NAMES)) {
[17:42:19.054]                   name <- added[[kk]]
[17:42:19.054]                   NAME <- NAMES[[kk]]
[17:42:19.054]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.054]                     next
[17:42:19.054]                   args[[name]] <- ""
[17:42:19.054]                 }
[17:42:19.054]                 NAMES <- toupper(removed)
[17:42:19.054]                 for (kk in seq_along(NAMES)) {
[17:42:19.054]                   name <- removed[[kk]]
[17:42:19.054]                   NAME <- NAMES[[kk]]
[17:42:19.054]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.054]                     next
[17:42:19.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.054]                 }
[17:42:19.054]                 if (length(args) > 0) 
[17:42:19.054]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.054]             }
[17:42:19.054]             else {
[17:42:19.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.054]             }
[17:42:19.054]             {
[17:42:19.054]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.054]                   0L) {
[17:42:19.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.054]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.054]                   base::options(opts)
[17:42:19.054]                 }
[17:42:19.054]                 {
[17:42:19.054]                   {
[17:42:19.054]                     NULL
[17:42:19.054]                     RNGkind("Mersenne-Twister")
[17:42:19.054]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.054]                       inherits = FALSE)
[17:42:19.054]                   }
[17:42:19.054]                   options(future.plan = NULL)
[17:42:19.054]                   if (is.na(NA_character_)) 
[17:42:19.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.054]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.054]                   {
[17:42:19.054]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.054]                     if (!future$lazy) 
[17:42:19.054]                       future <- run(future)
[17:42:19.054]                     invisible(future)
[17:42:19.054]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.054]                 }
[17:42:19.054]             }
[17:42:19.054]         }
[17:42:19.054]     })
[17:42:19.054]     if (TRUE) {
[17:42:19.054]         base::sink(type = "output", split = FALSE)
[17:42:19.054]         if (TRUE) {
[17:42:19.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.054]         }
[17:42:19.054]         else {
[17:42:19.054]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.054]         }
[17:42:19.054]         base::close(...future.stdout)
[17:42:19.054]         ...future.stdout <- NULL
[17:42:19.054]     }
[17:42:19.054]     ...future.result$conditions <- ...future.conditions
[17:42:19.054]     ...future.result$finished <- base::Sys.time()
[17:42:19.054]     ...future.result
[17:42:19.054] }
[17:42:19.056] plan(): Setting new future strategy stack:
[17:42:19.056] List of future strategies:
[17:42:19.056] 1. sequential:
[17:42:19.056]    - args: function (..., envir = parent.frame())
[17:42:19.056]    - tweaked: FALSE
[17:42:19.056]    - call: NULL
[17:42:19.056] plan(): nbrOfWorkers() = 1
[17:42:19.057] plan(): Setting new future strategy stack:
[17:42:19.057] List of future strategies:
[17:42:19.057] 1. sequential:
[17:42:19.057]    - args: function (..., envir = parent.frame())
[17:42:19.057]    - tweaked: FALSE
[17:42:19.057]    - call: plan(strategy)
[17:42:19.058] plan(): nbrOfWorkers() = 1
[17:42:19.058] SequentialFuture started (and completed)
[17:42:19.058] - Launch lazy future ... done
[17:42:19.058] run() for ‘SequentialFuture’ ... done
[17:42:19.059] getGlobalsAndPackages() ...
[17:42:19.059] Searching for globals...
[17:42:19.059] 
[17:42:19.059] Searching for globals ... DONE
[17:42:19.059] - globals: [0] <none>
[17:42:19.059] getGlobalsAndPackages() ... DONE
[17:42:19.059] run() for ‘Future’ ...
[17:42:19.060] - state: ‘created’
[17:42:19.060] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.060] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.060]   - Field: ‘label’
[17:42:19.060]   - Field: ‘local’
[17:42:19.060]   - Field: ‘owner’
[17:42:19.060]   - Field: ‘envir’
[17:42:19.061]   - Field: ‘packages’
[17:42:19.061]   - Field: ‘gc’
[17:42:19.061]   - Field: ‘conditions’
[17:42:19.061]   - Field: ‘expr’
[17:42:19.061]   - Field: ‘uuid’
[17:42:19.061]   - Field: ‘seed’
[17:42:19.061]   - Field: ‘version’
[17:42:19.061]   - Field: ‘result’
[17:42:19.061]   - Field: ‘asynchronous’
[17:42:19.061]   - Field: ‘calls’
[17:42:19.061]   - Field: ‘globals’
[17:42:19.062]   - Field: ‘stdout’
[17:42:19.062]   - Field: ‘earlySignal’
[17:42:19.062]   - Field: ‘lazy’
[17:42:19.062]   - Field: ‘state’
[17:42:19.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.062] - Launch lazy future ...
[17:42:19.062] Packages needed by the future expression (n = 0): <none>
[17:42:19.062] Packages needed by future strategies (n = 0): <none>
[17:42:19.063] {
[17:42:19.063]     {
[17:42:19.063]         {
[17:42:19.063]             ...future.startTime <- base::Sys.time()
[17:42:19.063]             {
[17:42:19.063]                 {
[17:42:19.063]                   {
[17:42:19.063]                     base::local({
[17:42:19.063]                       has_future <- base::requireNamespace("future", 
[17:42:19.063]                         quietly = TRUE)
[17:42:19.063]                       if (has_future) {
[17:42:19.063]                         ns <- base::getNamespace("future")
[17:42:19.063]                         version <- ns[[".package"]][["version"]]
[17:42:19.063]                         if (is.null(version)) 
[17:42:19.063]                           version <- utils::packageVersion("future")
[17:42:19.063]                       }
[17:42:19.063]                       else {
[17:42:19.063]                         version <- NULL
[17:42:19.063]                       }
[17:42:19.063]                       if (!has_future || version < "1.8.0") {
[17:42:19.063]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.063]                           "", base::R.version$version.string), 
[17:42:19.063]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.063]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.063]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.063]                             "release", "version")], collapse = " "), 
[17:42:19.063]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.063]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.063]                           info)
[17:42:19.063]                         info <- base::paste(info, collapse = "; ")
[17:42:19.063]                         if (!has_future) {
[17:42:19.063]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.063]                             info)
[17:42:19.063]                         }
[17:42:19.063]                         else {
[17:42:19.063]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.063]                             info, version)
[17:42:19.063]                         }
[17:42:19.063]                         base::stop(msg)
[17:42:19.063]                       }
[17:42:19.063]                     })
[17:42:19.063]                   }
[17:42:19.063]                   options(future.plan = NULL)
[17:42:19.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.063]                 }
[17:42:19.063]                 ...future.workdir <- getwd()
[17:42:19.063]             }
[17:42:19.063]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.063]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.063]         }
[17:42:19.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.063]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.063]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.063]             base::names(...future.oldOptions))
[17:42:19.063]     }
[17:42:19.063]     if (FALSE) {
[17:42:19.063]     }
[17:42:19.063]     else {
[17:42:19.063]         if (TRUE) {
[17:42:19.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.063]                 open = "w")
[17:42:19.063]         }
[17:42:19.063]         else {
[17:42:19.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.063]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.063]         }
[17:42:19.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.063]             base::sink(type = "output", split = FALSE)
[17:42:19.063]             base::close(...future.stdout)
[17:42:19.063]         }, add = TRUE)
[17:42:19.063]     }
[17:42:19.063]     ...future.frame <- base::sys.nframe()
[17:42:19.063]     ...future.conditions <- base::list()
[17:42:19.063]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.063]     if (FALSE) {
[17:42:19.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.063]     }
[17:42:19.063]     ...future.result <- base::tryCatch({
[17:42:19.063]         base::withCallingHandlers({
[17:42:19.063]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.063]             future::FutureResult(value = ...future.value$value, 
[17:42:19.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.063]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.063]                     ...future.globalenv.names))
[17:42:19.063]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.063]         }, condition = base::local({
[17:42:19.063]             c <- base::c
[17:42:19.063]             inherits <- base::inherits
[17:42:19.063]             invokeRestart <- base::invokeRestart
[17:42:19.063]             length <- base::length
[17:42:19.063]             list <- base::list
[17:42:19.063]             seq.int <- base::seq.int
[17:42:19.063]             signalCondition <- base::signalCondition
[17:42:19.063]             sys.calls <- base::sys.calls
[17:42:19.063]             `[[` <- base::`[[`
[17:42:19.063]             `+` <- base::`+`
[17:42:19.063]             `<<-` <- base::`<<-`
[17:42:19.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.063]                   3L)]
[17:42:19.063]             }
[17:42:19.063]             function(cond) {
[17:42:19.063]                 is_error <- inherits(cond, "error")
[17:42:19.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.063]                   NULL)
[17:42:19.063]                 if (is_error) {
[17:42:19.063]                   sessionInformation <- function() {
[17:42:19.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.063]                       search = base::search(), system = base::Sys.info())
[17:42:19.063]                   }
[17:42:19.063]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.063]                     cond$call), session = sessionInformation(), 
[17:42:19.063]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.063]                   signalCondition(cond)
[17:42:19.063]                 }
[17:42:19.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.063]                 "immediateCondition"))) {
[17:42:19.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.063]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.063]                   if (TRUE && !signal) {
[17:42:19.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.063]                     {
[17:42:19.063]                       inherits <- base::inherits
[17:42:19.063]                       invokeRestart <- base::invokeRestart
[17:42:19.063]                       is.null <- base::is.null
[17:42:19.063]                       muffled <- FALSE
[17:42:19.063]                       if (inherits(cond, "message")) {
[17:42:19.063]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.063]                         if (muffled) 
[17:42:19.063]                           invokeRestart("muffleMessage")
[17:42:19.063]                       }
[17:42:19.063]                       else if (inherits(cond, "warning")) {
[17:42:19.063]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.063]                         if (muffled) 
[17:42:19.063]                           invokeRestart("muffleWarning")
[17:42:19.063]                       }
[17:42:19.063]                       else if (inherits(cond, "condition")) {
[17:42:19.063]                         if (!is.null(pattern)) {
[17:42:19.063]                           computeRestarts <- base::computeRestarts
[17:42:19.063]                           grepl <- base::grepl
[17:42:19.063]                           restarts <- computeRestarts(cond)
[17:42:19.063]                           for (restart in restarts) {
[17:42:19.063]                             name <- restart$name
[17:42:19.063]                             if (is.null(name)) 
[17:42:19.063]                               next
[17:42:19.063]                             if (!grepl(pattern, name)) 
[17:42:19.063]                               next
[17:42:19.063]                             invokeRestart(restart)
[17:42:19.063]                             muffled <- TRUE
[17:42:19.063]                             break
[17:42:19.063]                           }
[17:42:19.063]                         }
[17:42:19.063]                       }
[17:42:19.063]                       invisible(muffled)
[17:42:19.063]                     }
[17:42:19.063]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.063]                   }
[17:42:19.063]                 }
[17:42:19.063]                 else {
[17:42:19.063]                   if (TRUE) {
[17:42:19.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.063]                     {
[17:42:19.063]                       inherits <- base::inherits
[17:42:19.063]                       invokeRestart <- base::invokeRestart
[17:42:19.063]                       is.null <- base::is.null
[17:42:19.063]                       muffled <- FALSE
[17:42:19.063]                       if (inherits(cond, "message")) {
[17:42:19.063]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.063]                         if (muffled) 
[17:42:19.063]                           invokeRestart("muffleMessage")
[17:42:19.063]                       }
[17:42:19.063]                       else if (inherits(cond, "warning")) {
[17:42:19.063]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.063]                         if (muffled) 
[17:42:19.063]                           invokeRestart("muffleWarning")
[17:42:19.063]                       }
[17:42:19.063]                       else if (inherits(cond, "condition")) {
[17:42:19.063]                         if (!is.null(pattern)) {
[17:42:19.063]                           computeRestarts <- base::computeRestarts
[17:42:19.063]                           grepl <- base::grepl
[17:42:19.063]                           restarts <- computeRestarts(cond)
[17:42:19.063]                           for (restart in restarts) {
[17:42:19.063]                             name <- restart$name
[17:42:19.063]                             if (is.null(name)) 
[17:42:19.063]                               next
[17:42:19.063]                             if (!grepl(pattern, name)) 
[17:42:19.063]                               next
[17:42:19.063]                             invokeRestart(restart)
[17:42:19.063]                             muffled <- TRUE
[17:42:19.063]                             break
[17:42:19.063]                           }
[17:42:19.063]                         }
[17:42:19.063]                       }
[17:42:19.063]                       invisible(muffled)
[17:42:19.063]                     }
[17:42:19.063]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.063]                   }
[17:42:19.063]                 }
[17:42:19.063]             }
[17:42:19.063]         }))
[17:42:19.063]     }, error = function(ex) {
[17:42:19.063]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.063]                 ...future.rng), started = ...future.startTime, 
[17:42:19.063]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.063]             version = "1.8"), class = "FutureResult")
[17:42:19.063]     }, finally = {
[17:42:19.063]         if (!identical(...future.workdir, getwd())) 
[17:42:19.063]             setwd(...future.workdir)
[17:42:19.063]         {
[17:42:19.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.063]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.063]             }
[17:42:19.063]             base::options(...future.oldOptions)
[17:42:19.063]             if (.Platform$OS.type == "windows") {
[17:42:19.063]                 old_names <- names(...future.oldEnvVars)
[17:42:19.063]                 envs <- base::Sys.getenv()
[17:42:19.063]                 names <- names(envs)
[17:42:19.063]                 common <- intersect(names, old_names)
[17:42:19.063]                 added <- setdiff(names, old_names)
[17:42:19.063]                 removed <- setdiff(old_names, names)
[17:42:19.063]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.063]                   envs[common]]
[17:42:19.063]                 NAMES <- toupper(changed)
[17:42:19.063]                 args <- list()
[17:42:19.063]                 for (kk in seq_along(NAMES)) {
[17:42:19.063]                   name <- changed[[kk]]
[17:42:19.063]                   NAME <- NAMES[[kk]]
[17:42:19.063]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.063]                     next
[17:42:19.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.063]                 }
[17:42:19.063]                 NAMES <- toupper(added)
[17:42:19.063]                 for (kk in seq_along(NAMES)) {
[17:42:19.063]                   name <- added[[kk]]
[17:42:19.063]                   NAME <- NAMES[[kk]]
[17:42:19.063]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.063]                     next
[17:42:19.063]                   args[[name]] <- ""
[17:42:19.063]                 }
[17:42:19.063]                 NAMES <- toupper(removed)
[17:42:19.063]                 for (kk in seq_along(NAMES)) {
[17:42:19.063]                   name <- removed[[kk]]
[17:42:19.063]                   NAME <- NAMES[[kk]]
[17:42:19.063]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.063]                     next
[17:42:19.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.063]                 }
[17:42:19.063]                 if (length(args) > 0) 
[17:42:19.063]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.063]             }
[17:42:19.063]             else {
[17:42:19.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.063]             }
[17:42:19.063]             {
[17:42:19.063]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.063]                   0L) {
[17:42:19.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.063]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.063]                   base::options(opts)
[17:42:19.063]                 }
[17:42:19.063]                 {
[17:42:19.063]                   {
[17:42:19.063]                     NULL
[17:42:19.063]                     RNGkind("Mersenne-Twister")
[17:42:19.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.063]                       inherits = FALSE)
[17:42:19.063]                   }
[17:42:19.063]                   options(future.plan = NULL)
[17:42:19.063]                   if (is.na(NA_character_)) 
[17:42:19.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.063]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.063]                   {
[17:42:19.063]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.063]                     if (!future$lazy) 
[17:42:19.063]                       future <- run(future)
[17:42:19.063]                     invisible(future)
[17:42:19.063]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.063]                 }
[17:42:19.063]             }
[17:42:19.063]         }
[17:42:19.063]     })
[17:42:19.063]     if (TRUE) {
[17:42:19.063]         base::sink(type = "output", split = FALSE)
[17:42:19.063]         if (TRUE) {
[17:42:19.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.063]         }
[17:42:19.063]         else {
[17:42:19.063]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.063]         }
[17:42:19.063]         base::close(...future.stdout)
[17:42:19.063]         ...future.stdout <- NULL
[17:42:19.063]     }
[17:42:19.063]     ...future.result$conditions <- ...future.conditions
[17:42:19.063]     ...future.result$finished <- base::Sys.time()
[17:42:19.063]     ...future.result
[17:42:19.063] }
[17:42:19.064] plan(): Setting new future strategy stack:
[17:42:19.065] List of future strategies:
[17:42:19.065] 1. sequential:
[17:42:19.065]    - args: function (..., envir = parent.frame())
[17:42:19.065]    - tweaked: FALSE
[17:42:19.065]    - call: NULL
[17:42:19.065] plan(): nbrOfWorkers() = 1
[17:42:19.066] plan(): Setting new future strategy stack:
[17:42:19.066] List of future strategies:
[17:42:19.066] 1. sequential:
[17:42:19.066]    - args: function (..., envir = parent.frame())
[17:42:19.066]    - tweaked: FALSE
[17:42:19.066]    - call: plan(strategy)
[17:42:19.066] plan(): nbrOfWorkers() = 1
[17:42:19.066] SequentialFuture started (and completed)
[17:42:19.066] - Launch lazy future ... done
[17:42:19.066] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef7e3bb10> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef82643c0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef7e3bb10> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef82643c0> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:42:19.076] resolved() for ‘SequentialFuture’ ...
[17:42:19.076] - state: ‘finished’
[17:42:19.076] - run: TRUE
[17:42:19.076] - result: ‘FutureResult’
[17:42:19.076] resolved() for ‘SequentialFuture’ ... done
[17:42:19.076] resolved() for ‘SequentialFuture’ ...
[17:42:19.077] - state: ‘finished’
[17:42:19.077] - run: TRUE
[17:42:19.077] - result: ‘FutureResult’
[17:42:19.077] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.078] resolve() on list ...
[17:42:19.078]  recursive: 0
[17:42:19.078]  length: 6
[17:42:19.078]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.079] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.079] - nx: 6
[17:42:19.079] - relay: TRUE
[17:42:19.079] - stdout: TRUE
[17:42:19.079] - signal: TRUE
[17:42:19.079] - resignal: FALSE
[17:42:19.079] - force: TRUE
[17:42:19.079] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.079] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.079]  - until=2
[17:42:19.079]  - relaying element #2
[17:42:19.080] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.080] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.080] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.080]  length: 5 (resolved future 1)
[17:42:19.080] resolved() for ‘SequentialFuture’ ...
[17:42:19.080] - state: ‘finished’
[17:42:19.080] - run: TRUE
[17:42:19.080] - result: ‘FutureResult’
[17:42:19.080] resolved() for ‘SequentialFuture’ ... done
[17:42:19.080] Future #2
[17:42:19.081] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.081] - nx: 6
[17:42:19.081] - relay: TRUE
[17:42:19.081] - stdout: TRUE
[17:42:19.081] - signal: TRUE
[17:42:19.081] - resignal: FALSE
[17:42:19.081] - force: TRUE
[17:42:19.081] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.081] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.082]  - until=2
[17:42:19.082]  - relaying element #2
[17:42:19.082] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.082] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.082] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.082]  length: 4 (resolved future 2)
[17:42:19.082] resolved() for ‘SequentialFuture’ ...
[17:42:19.083] - state: ‘finished’
[17:42:19.083] - run: TRUE
[17:42:19.083] - result: ‘FutureResult’
[17:42:19.083] resolved() for ‘SequentialFuture’ ... done
[17:42:19.083] Future #3
[17:42:19.083] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.083] - nx: 6
[17:42:19.083] - relay: TRUE
[17:42:19.083] - stdout: TRUE
[17:42:19.083] - signal: TRUE
[17:42:19.084] - resignal: FALSE
[17:42:19.084] - force: TRUE
[17:42:19.084] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.084] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.084]  - until=3
[17:42:19.084]  - relaying element #3
[17:42:19.084] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.084] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.084] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.084]  length: 3 (resolved future 3)
[17:42:19.085] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.085] - nx: 6
[17:42:19.085] - relay: TRUE
[17:42:19.085] - stdout: TRUE
[17:42:19.085] - signal: TRUE
[17:42:19.085] - resignal: FALSE
[17:42:19.085] - force: TRUE
[17:42:19.085] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.085] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.085]  - until=5
[17:42:19.085]  - relaying element #5
[17:42:19.085] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.086] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.086] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.086]  length: 2 (resolved future 4)
[17:42:19.086] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.086] - nx: 6
[17:42:19.086] - relay: TRUE
[17:42:19.086] - stdout: TRUE
[17:42:19.086] - signal: TRUE
[17:42:19.086] - resignal: FALSE
[17:42:19.086] - force: TRUE
[17:42:19.086] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.087] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.087]  - until=6
[17:42:19.087]  - relaying element #6
[17:42:19.087] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.087] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.087] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.087]  length: 1 (resolved future 5)
[17:42:19.087] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.087] - nx: 6
[17:42:19.087] - relay: TRUE
[17:42:19.087] - stdout: TRUE
[17:42:19.088] - signal: TRUE
[17:42:19.088] - resignal: FALSE
[17:42:19.088] - force: TRUE
[17:42:19.088] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.088] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.088]  - until=6
[17:42:19.088] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.088] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.088] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.088]  length: 0 (resolved future 6)
[17:42:19.088] Relaying remaining futures
[17:42:19.088] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.089] - nx: 6
[17:42:19.089] - relay: TRUE
[17:42:19.089] - stdout: TRUE
[17:42:19.089] - signal: TRUE
[17:42:19.089] - resignal: FALSE
[17:42:19.089] - force: TRUE
[17:42:19.089] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.089] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.089] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.090] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:42:19.092] getGlobalsAndPackages() ...
[17:42:19.092] Searching for globals...
[17:42:19.092] 
[17:42:19.092] Searching for globals ... DONE
[17:42:19.092] - globals: [0] <none>
[17:42:19.092] getGlobalsAndPackages() ... DONE
[17:42:19.093] run() for ‘Future’ ...
[17:42:19.093] - state: ‘created’
[17:42:19.093] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.093] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.093] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.093]   - Field: ‘label’
[17:42:19.093]   - Field: ‘local’
[17:42:19.094]   - Field: ‘owner’
[17:42:19.094]   - Field: ‘envir’
[17:42:19.094]   - Field: ‘packages’
[17:42:19.094]   - Field: ‘gc’
[17:42:19.094]   - Field: ‘conditions’
[17:42:19.094]   - Field: ‘expr’
[17:42:19.094]   - Field: ‘uuid’
[17:42:19.094]   - Field: ‘seed’
[17:42:19.094]   - Field: ‘version’
[17:42:19.094]   - Field: ‘result’
[17:42:19.094]   - Field: ‘asynchronous’
[17:42:19.095]   - Field: ‘calls’
[17:42:19.095]   - Field: ‘globals’
[17:42:19.095]   - Field: ‘stdout’
[17:42:19.095]   - Field: ‘earlySignal’
[17:42:19.095]   - Field: ‘lazy’
[17:42:19.095]   - Field: ‘state’
[17:42:19.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.095] - Launch lazy future ...
[17:42:19.095] Packages needed by the future expression (n = 0): <none>
[17:42:19.096] Packages needed by future strategies (n = 0): <none>
[17:42:19.096] {
[17:42:19.096]     {
[17:42:19.096]         {
[17:42:19.096]             ...future.startTime <- base::Sys.time()
[17:42:19.096]             {
[17:42:19.096]                 {
[17:42:19.096]                   {
[17:42:19.096]                     base::local({
[17:42:19.096]                       has_future <- base::requireNamespace("future", 
[17:42:19.096]                         quietly = TRUE)
[17:42:19.096]                       if (has_future) {
[17:42:19.096]                         ns <- base::getNamespace("future")
[17:42:19.096]                         version <- ns[[".package"]][["version"]]
[17:42:19.096]                         if (is.null(version)) 
[17:42:19.096]                           version <- utils::packageVersion("future")
[17:42:19.096]                       }
[17:42:19.096]                       else {
[17:42:19.096]                         version <- NULL
[17:42:19.096]                       }
[17:42:19.096]                       if (!has_future || version < "1.8.0") {
[17:42:19.096]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.096]                           "", base::R.version$version.string), 
[17:42:19.096]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.096]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.096]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.096]                             "release", "version")], collapse = " "), 
[17:42:19.096]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.096]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.096]                           info)
[17:42:19.096]                         info <- base::paste(info, collapse = "; ")
[17:42:19.096]                         if (!has_future) {
[17:42:19.096]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.096]                             info)
[17:42:19.096]                         }
[17:42:19.096]                         else {
[17:42:19.096]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.096]                             info, version)
[17:42:19.096]                         }
[17:42:19.096]                         base::stop(msg)
[17:42:19.096]                       }
[17:42:19.096]                     })
[17:42:19.096]                   }
[17:42:19.096]                   options(future.plan = NULL)
[17:42:19.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.096]                 }
[17:42:19.096]                 ...future.workdir <- getwd()
[17:42:19.096]             }
[17:42:19.096]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.096]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.096]         }
[17:42:19.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.096]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.096]             base::names(...future.oldOptions))
[17:42:19.096]     }
[17:42:19.096]     if (FALSE) {
[17:42:19.096]     }
[17:42:19.096]     else {
[17:42:19.096]         if (TRUE) {
[17:42:19.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.096]                 open = "w")
[17:42:19.096]         }
[17:42:19.096]         else {
[17:42:19.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.096]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.096]         }
[17:42:19.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.096]             base::sink(type = "output", split = FALSE)
[17:42:19.096]             base::close(...future.stdout)
[17:42:19.096]         }, add = TRUE)
[17:42:19.096]     }
[17:42:19.096]     ...future.frame <- base::sys.nframe()
[17:42:19.096]     ...future.conditions <- base::list()
[17:42:19.096]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.096]     if (FALSE) {
[17:42:19.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.096]     }
[17:42:19.096]     ...future.result <- base::tryCatch({
[17:42:19.096]         base::withCallingHandlers({
[17:42:19.096]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.096]             future::FutureResult(value = ...future.value$value, 
[17:42:19.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.096]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.096]                     ...future.globalenv.names))
[17:42:19.096]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.096]         }, condition = base::local({
[17:42:19.096]             c <- base::c
[17:42:19.096]             inherits <- base::inherits
[17:42:19.096]             invokeRestart <- base::invokeRestart
[17:42:19.096]             length <- base::length
[17:42:19.096]             list <- base::list
[17:42:19.096]             seq.int <- base::seq.int
[17:42:19.096]             signalCondition <- base::signalCondition
[17:42:19.096]             sys.calls <- base::sys.calls
[17:42:19.096]             `[[` <- base::`[[`
[17:42:19.096]             `+` <- base::`+`
[17:42:19.096]             `<<-` <- base::`<<-`
[17:42:19.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.096]                   3L)]
[17:42:19.096]             }
[17:42:19.096]             function(cond) {
[17:42:19.096]                 is_error <- inherits(cond, "error")
[17:42:19.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.096]                   NULL)
[17:42:19.096]                 if (is_error) {
[17:42:19.096]                   sessionInformation <- function() {
[17:42:19.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.096]                       search = base::search(), system = base::Sys.info())
[17:42:19.096]                   }
[17:42:19.096]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.096]                     cond$call), session = sessionInformation(), 
[17:42:19.096]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.096]                   signalCondition(cond)
[17:42:19.096]                 }
[17:42:19.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.096]                 "immediateCondition"))) {
[17:42:19.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.096]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.096]                   if (TRUE && !signal) {
[17:42:19.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.096]                     {
[17:42:19.096]                       inherits <- base::inherits
[17:42:19.096]                       invokeRestart <- base::invokeRestart
[17:42:19.096]                       is.null <- base::is.null
[17:42:19.096]                       muffled <- FALSE
[17:42:19.096]                       if (inherits(cond, "message")) {
[17:42:19.096]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.096]                         if (muffled) 
[17:42:19.096]                           invokeRestart("muffleMessage")
[17:42:19.096]                       }
[17:42:19.096]                       else if (inherits(cond, "warning")) {
[17:42:19.096]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.096]                         if (muffled) 
[17:42:19.096]                           invokeRestart("muffleWarning")
[17:42:19.096]                       }
[17:42:19.096]                       else if (inherits(cond, "condition")) {
[17:42:19.096]                         if (!is.null(pattern)) {
[17:42:19.096]                           computeRestarts <- base::computeRestarts
[17:42:19.096]                           grepl <- base::grepl
[17:42:19.096]                           restarts <- computeRestarts(cond)
[17:42:19.096]                           for (restart in restarts) {
[17:42:19.096]                             name <- restart$name
[17:42:19.096]                             if (is.null(name)) 
[17:42:19.096]                               next
[17:42:19.096]                             if (!grepl(pattern, name)) 
[17:42:19.096]                               next
[17:42:19.096]                             invokeRestart(restart)
[17:42:19.096]                             muffled <- TRUE
[17:42:19.096]                             break
[17:42:19.096]                           }
[17:42:19.096]                         }
[17:42:19.096]                       }
[17:42:19.096]                       invisible(muffled)
[17:42:19.096]                     }
[17:42:19.096]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.096]                   }
[17:42:19.096]                 }
[17:42:19.096]                 else {
[17:42:19.096]                   if (TRUE) {
[17:42:19.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.096]                     {
[17:42:19.096]                       inherits <- base::inherits
[17:42:19.096]                       invokeRestart <- base::invokeRestart
[17:42:19.096]                       is.null <- base::is.null
[17:42:19.096]                       muffled <- FALSE
[17:42:19.096]                       if (inherits(cond, "message")) {
[17:42:19.096]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.096]                         if (muffled) 
[17:42:19.096]                           invokeRestart("muffleMessage")
[17:42:19.096]                       }
[17:42:19.096]                       else if (inherits(cond, "warning")) {
[17:42:19.096]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.096]                         if (muffled) 
[17:42:19.096]                           invokeRestart("muffleWarning")
[17:42:19.096]                       }
[17:42:19.096]                       else if (inherits(cond, "condition")) {
[17:42:19.096]                         if (!is.null(pattern)) {
[17:42:19.096]                           computeRestarts <- base::computeRestarts
[17:42:19.096]                           grepl <- base::grepl
[17:42:19.096]                           restarts <- computeRestarts(cond)
[17:42:19.096]                           for (restart in restarts) {
[17:42:19.096]                             name <- restart$name
[17:42:19.096]                             if (is.null(name)) 
[17:42:19.096]                               next
[17:42:19.096]                             if (!grepl(pattern, name)) 
[17:42:19.096]                               next
[17:42:19.096]                             invokeRestart(restart)
[17:42:19.096]                             muffled <- TRUE
[17:42:19.096]                             break
[17:42:19.096]                           }
[17:42:19.096]                         }
[17:42:19.096]                       }
[17:42:19.096]                       invisible(muffled)
[17:42:19.096]                     }
[17:42:19.096]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.096]                   }
[17:42:19.096]                 }
[17:42:19.096]             }
[17:42:19.096]         }))
[17:42:19.096]     }, error = function(ex) {
[17:42:19.096]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.096]                 ...future.rng), started = ...future.startTime, 
[17:42:19.096]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.096]             version = "1.8"), class = "FutureResult")
[17:42:19.096]     }, finally = {
[17:42:19.096]         if (!identical(...future.workdir, getwd())) 
[17:42:19.096]             setwd(...future.workdir)
[17:42:19.096]         {
[17:42:19.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.096]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.096]             }
[17:42:19.096]             base::options(...future.oldOptions)
[17:42:19.096]             if (.Platform$OS.type == "windows") {
[17:42:19.096]                 old_names <- names(...future.oldEnvVars)
[17:42:19.096]                 envs <- base::Sys.getenv()
[17:42:19.096]                 names <- names(envs)
[17:42:19.096]                 common <- intersect(names, old_names)
[17:42:19.096]                 added <- setdiff(names, old_names)
[17:42:19.096]                 removed <- setdiff(old_names, names)
[17:42:19.096]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.096]                   envs[common]]
[17:42:19.096]                 NAMES <- toupper(changed)
[17:42:19.096]                 args <- list()
[17:42:19.096]                 for (kk in seq_along(NAMES)) {
[17:42:19.096]                   name <- changed[[kk]]
[17:42:19.096]                   NAME <- NAMES[[kk]]
[17:42:19.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.096]                     next
[17:42:19.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.096]                 }
[17:42:19.096]                 NAMES <- toupper(added)
[17:42:19.096]                 for (kk in seq_along(NAMES)) {
[17:42:19.096]                   name <- added[[kk]]
[17:42:19.096]                   NAME <- NAMES[[kk]]
[17:42:19.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.096]                     next
[17:42:19.096]                   args[[name]] <- ""
[17:42:19.096]                 }
[17:42:19.096]                 NAMES <- toupper(removed)
[17:42:19.096]                 for (kk in seq_along(NAMES)) {
[17:42:19.096]                   name <- removed[[kk]]
[17:42:19.096]                   NAME <- NAMES[[kk]]
[17:42:19.096]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.096]                     next
[17:42:19.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.096]                 }
[17:42:19.096]                 if (length(args) > 0) 
[17:42:19.096]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.096]             }
[17:42:19.096]             else {
[17:42:19.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.096]             }
[17:42:19.096]             {
[17:42:19.096]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.096]                   0L) {
[17:42:19.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.096]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.096]                   base::options(opts)
[17:42:19.096]                 }
[17:42:19.096]                 {
[17:42:19.096]                   {
[17:42:19.096]                     NULL
[17:42:19.096]                     RNGkind("Mersenne-Twister")
[17:42:19.096]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.096]                       inherits = FALSE)
[17:42:19.096]                   }
[17:42:19.096]                   options(future.plan = NULL)
[17:42:19.096]                   if (is.na(NA_character_)) 
[17:42:19.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.096]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.096]                   {
[17:42:19.096]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.096]                     if (!future$lazy) 
[17:42:19.096]                       future <- run(future)
[17:42:19.096]                     invisible(future)
[17:42:19.096]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.096]                 }
[17:42:19.096]             }
[17:42:19.096]         }
[17:42:19.096]     })
[17:42:19.096]     if (TRUE) {
[17:42:19.096]         base::sink(type = "output", split = FALSE)
[17:42:19.096]         if (TRUE) {
[17:42:19.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.096]         }
[17:42:19.096]         else {
[17:42:19.096]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.096]         }
[17:42:19.096]         base::close(...future.stdout)
[17:42:19.096]         ...future.stdout <- NULL
[17:42:19.096]     }
[17:42:19.096]     ...future.result$conditions <- ...future.conditions
[17:42:19.096]     ...future.result$finished <- base::Sys.time()
[17:42:19.096]     ...future.result
[17:42:19.096] }
[17:42:19.098] plan(): Setting new future strategy stack:
[17:42:19.098] List of future strategies:
[17:42:19.098] 1. sequential:
[17:42:19.098]    - args: function (..., envir = parent.frame())
[17:42:19.098]    - tweaked: FALSE
[17:42:19.098]    - call: NULL
[17:42:19.098] plan(): nbrOfWorkers() = 1
[17:42:19.099] plan(): Setting new future strategy stack:
[17:42:19.099] List of future strategies:
[17:42:19.099] 1. sequential:
[17:42:19.099]    - args: function (..., envir = parent.frame())
[17:42:19.099]    - tweaked: FALSE
[17:42:19.099]    - call: plan(strategy)
[17:42:19.100] plan(): nbrOfWorkers() = 1
[17:42:19.100] SequentialFuture started (and completed)
[17:42:19.100] - Launch lazy future ... done
[17:42:19.100] run() for ‘SequentialFuture’ ... done
[17:42:19.100] getGlobalsAndPackages() ...
[17:42:19.100] Searching for globals...
[17:42:19.100] 
[17:42:19.101] Searching for globals ... DONE
[17:42:19.101] - globals: [0] <none>
[17:42:19.101] getGlobalsAndPackages() ... DONE
[17:42:19.101] run() for ‘Future’ ...
[17:42:19.101] - state: ‘created’
[17:42:19.101] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.101] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.102]   - Field: ‘label’
[17:42:19.102]   - Field: ‘local’
[17:42:19.102]   - Field: ‘owner’
[17:42:19.104]   - Field: ‘envir’
[17:42:19.104]   - Field: ‘packages’
[17:42:19.104]   - Field: ‘gc’
[17:42:19.104]   - Field: ‘conditions’
[17:42:19.104]   - Field: ‘expr’
[17:42:19.104]   - Field: ‘uuid’
[17:42:19.105]   - Field: ‘seed’
[17:42:19.105]   - Field: ‘version’
[17:42:19.105]   - Field: ‘result’
[17:42:19.105]   - Field: ‘asynchronous’
[17:42:19.105]   - Field: ‘calls’
[17:42:19.105]   - Field: ‘globals’
[17:42:19.105]   - Field: ‘stdout’
[17:42:19.105]   - Field: ‘earlySignal’
[17:42:19.105]   - Field: ‘lazy’
[17:42:19.105]   - Field: ‘state’
[17:42:19.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.106] - Launch lazy future ...
[17:42:19.106] Packages needed by the future expression (n = 0): <none>
[17:42:19.106] Packages needed by future strategies (n = 0): <none>
[17:42:19.106] {
[17:42:19.106]     {
[17:42:19.106]         {
[17:42:19.106]             ...future.startTime <- base::Sys.time()
[17:42:19.106]             {
[17:42:19.106]                 {
[17:42:19.106]                   {
[17:42:19.106]                     base::local({
[17:42:19.106]                       has_future <- base::requireNamespace("future", 
[17:42:19.106]                         quietly = TRUE)
[17:42:19.106]                       if (has_future) {
[17:42:19.106]                         ns <- base::getNamespace("future")
[17:42:19.106]                         version <- ns[[".package"]][["version"]]
[17:42:19.106]                         if (is.null(version)) 
[17:42:19.106]                           version <- utils::packageVersion("future")
[17:42:19.106]                       }
[17:42:19.106]                       else {
[17:42:19.106]                         version <- NULL
[17:42:19.106]                       }
[17:42:19.106]                       if (!has_future || version < "1.8.0") {
[17:42:19.106]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.106]                           "", base::R.version$version.string), 
[17:42:19.106]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.106]                             "release", "version")], collapse = " "), 
[17:42:19.106]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.106]                           info)
[17:42:19.106]                         info <- base::paste(info, collapse = "; ")
[17:42:19.106]                         if (!has_future) {
[17:42:19.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.106]                             info)
[17:42:19.106]                         }
[17:42:19.106]                         else {
[17:42:19.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.106]                             info, version)
[17:42:19.106]                         }
[17:42:19.106]                         base::stop(msg)
[17:42:19.106]                       }
[17:42:19.106]                     })
[17:42:19.106]                   }
[17:42:19.106]                   options(future.plan = NULL)
[17:42:19.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.106]                 }
[17:42:19.106]                 ...future.workdir <- getwd()
[17:42:19.106]             }
[17:42:19.106]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.106]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.106]         }
[17:42:19.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.106]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.106]             base::names(...future.oldOptions))
[17:42:19.106]     }
[17:42:19.106]     if (FALSE) {
[17:42:19.106]     }
[17:42:19.106]     else {
[17:42:19.106]         if (TRUE) {
[17:42:19.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.106]                 open = "w")
[17:42:19.106]         }
[17:42:19.106]         else {
[17:42:19.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.106]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.106]         }
[17:42:19.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.106]             base::sink(type = "output", split = FALSE)
[17:42:19.106]             base::close(...future.stdout)
[17:42:19.106]         }, add = TRUE)
[17:42:19.106]     }
[17:42:19.106]     ...future.frame <- base::sys.nframe()
[17:42:19.106]     ...future.conditions <- base::list()
[17:42:19.106]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.106]     if (FALSE) {
[17:42:19.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.106]     }
[17:42:19.106]     ...future.result <- base::tryCatch({
[17:42:19.106]         base::withCallingHandlers({
[17:42:19.106]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.106]             future::FutureResult(value = ...future.value$value, 
[17:42:19.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.106]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.106]                     ...future.globalenv.names))
[17:42:19.106]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.106]         }, condition = base::local({
[17:42:19.106]             c <- base::c
[17:42:19.106]             inherits <- base::inherits
[17:42:19.106]             invokeRestart <- base::invokeRestart
[17:42:19.106]             length <- base::length
[17:42:19.106]             list <- base::list
[17:42:19.106]             seq.int <- base::seq.int
[17:42:19.106]             signalCondition <- base::signalCondition
[17:42:19.106]             sys.calls <- base::sys.calls
[17:42:19.106]             `[[` <- base::`[[`
[17:42:19.106]             `+` <- base::`+`
[17:42:19.106]             `<<-` <- base::`<<-`
[17:42:19.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.106]                   3L)]
[17:42:19.106]             }
[17:42:19.106]             function(cond) {
[17:42:19.106]                 is_error <- inherits(cond, "error")
[17:42:19.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.106]                   NULL)
[17:42:19.106]                 if (is_error) {
[17:42:19.106]                   sessionInformation <- function() {
[17:42:19.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.106]                       search = base::search(), system = base::Sys.info())
[17:42:19.106]                   }
[17:42:19.106]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.106]                     cond$call), session = sessionInformation(), 
[17:42:19.106]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.106]                   signalCondition(cond)
[17:42:19.106]                 }
[17:42:19.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.106]                 "immediateCondition"))) {
[17:42:19.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.106]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.106]                   if (TRUE && !signal) {
[17:42:19.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.106]                     {
[17:42:19.106]                       inherits <- base::inherits
[17:42:19.106]                       invokeRestart <- base::invokeRestart
[17:42:19.106]                       is.null <- base::is.null
[17:42:19.106]                       muffled <- FALSE
[17:42:19.106]                       if (inherits(cond, "message")) {
[17:42:19.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.106]                         if (muffled) 
[17:42:19.106]                           invokeRestart("muffleMessage")
[17:42:19.106]                       }
[17:42:19.106]                       else if (inherits(cond, "warning")) {
[17:42:19.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.106]                         if (muffled) 
[17:42:19.106]                           invokeRestart("muffleWarning")
[17:42:19.106]                       }
[17:42:19.106]                       else if (inherits(cond, "condition")) {
[17:42:19.106]                         if (!is.null(pattern)) {
[17:42:19.106]                           computeRestarts <- base::computeRestarts
[17:42:19.106]                           grepl <- base::grepl
[17:42:19.106]                           restarts <- computeRestarts(cond)
[17:42:19.106]                           for (restart in restarts) {
[17:42:19.106]                             name <- restart$name
[17:42:19.106]                             if (is.null(name)) 
[17:42:19.106]                               next
[17:42:19.106]                             if (!grepl(pattern, name)) 
[17:42:19.106]                               next
[17:42:19.106]                             invokeRestart(restart)
[17:42:19.106]                             muffled <- TRUE
[17:42:19.106]                             break
[17:42:19.106]                           }
[17:42:19.106]                         }
[17:42:19.106]                       }
[17:42:19.106]                       invisible(muffled)
[17:42:19.106]                     }
[17:42:19.106]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.106]                   }
[17:42:19.106]                 }
[17:42:19.106]                 else {
[17:42:19.106]                   if (TRUE) {
[17:42:19.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.106]                     {
[17:42:19.106]                       inherits <- base::inherits
[17:42:19.106]                       invokeRestart <- base::invokeRestart
[17:42:19.106]                       is.null <- base::is.null
[17:42:19.106]                       muffled <- FALSE
[17:42:19.106]                       if (inherits(cond, "message")) {
[17:42:19.106]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.106]                         if (muffled) 
[17:42:19.106]                           invokeRestart("muffleMessage")
[17:42:19.106]                       }
[17:42:19.106]                       else if (inherits(cond, "warning")) {
[17:42:19.106]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.106]                         if (muffled) 
[17:42:19.106]                           invokeRestart("muffleWarning")
[17:42:19.106]                       }
[17:42:19.106]                       else if (inherits(cond, "condition")) {
[17:42:19.106]                         if (!is.null(pattern)) {
[17:42:19.106]                           computeRestarts <- base::computeRestarts
[17:42:19.106]                           grepl <- base::grepl
[17:42:19.106]                           restarts <- computeRestarts(cond)
[17:42:19.106]                           for (restart in restarts) {
[17:42:19.106]                             name <- restart$name
[17:42:19.106]                             if (is.null(name)) 
[17:42:19.106]                               next
[17:42:19.106]                             if (!grepl(pattern, name)) 
[17:42:19.106]                               next
[17:42:19.106]                             invokeRestart(restart)
[17:42:19.106]                             muffled <- TRUE
[17:42:19.106]                             break
[17:42:19.106]                           }
[17:42:19.106]                         }
[17:42:19.106]                       }
[17:42:19.106]                       invisible(muffled)
[17:42:19.106]                     }
[17:42:19.106]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.106]                   }
[17:42:19.106]                 }
[17:42:19.106]             }
[17:42:19.106]         }))
[17:42:19.106]     }, error = function(ex) {
[17:42:19.106]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.106]                 ...future.rng), started = ...future.startTime, 
[17:42:19.106]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.106]             version = "1.8"), class = "FutureResult")
[17:42:19.106]     }, finally = {
[17:42:19.106]         if (!identical(...future.workdir, getwd())) 
[17:42:19.106]             setwd(...future.workdir)
[17:42:19.106]         {
[17:42:19.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.106]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.106]             }
[17:42:19.106]             base::options(...future.oldOptions)
[17:42:19.106]             if (.Platform$OS.type == "windows") {
[17:42:19.106]                 old_names <- names(...future.oldEnvVars)
[17:42:19.106]                 envs <- base::Sys.getenv()
[17:42:19.106]                 names <- names(envs)
[17:42:19.106]                 common <- intersect(names, old_names)
[17:42:19.106]                 added <- setdiff(names, old_names)
[17:42:19.106]                 removed <- setdiff(old_names, names)
[17:42:19.106]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.106]                   envs[common]]
[17:42:19.106]                 NAMES <- toupper(changed)
[17:42:19.106]                 args <- list()
[17:42:19.106]                 for (kk in seq_along(NAMES)) {
[17:42:19.106]                   name <- changed[[kk]]
[17:42:19.106]                   NAME <- NAMES[[kk]]
[17:42:19.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.106]                     next
[17:42:19.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.106]                 }
[17:42:19.106]                 NAMES <- toupper(added)
[17:42:19.106]                 for (kk in seq_along(NAMES)) {
[17:42:19.106]                   name <- added[[kk]]
[17:42:19.106]                   NAME <- NAMES[[kk]]
[17:42:19.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.106]                     next
[17:42:19.106]                   args[[name]] <- ""
[17:42:19.106]                 }
[17:42:19.106]                 NAMES <- toupper(removed)
[17:42:19.106]                 for (kk in seq_along(NAMES)) {
[17:42:19.106]                   name <- removed[[kk]]
[17:42:19.106]                   NAME <- NAMES[[kk]]
[17:42:19.106]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.106]                     next
[17:42:19.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.106]                 }
[17:42:19.106]                 if (length(args) > 0) 
[17:42:19.106]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.106]             }
[17:42:19.106]             else {
[17:42:19.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.106]             }
[17:42:19.106]             {
[17:42:19.106]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.106]                   0L) {
[17:42:19.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.106]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.106]                   base::options(opts)
[17:42:19.106]                 }
[17:42:19.106]                 {
[17:42:19.106]                   {
[17:42:19.106]                     NULL
[17:42:19.106]                     RNGkind("Mersenne-Twister")
[17:42:19.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.106]                       inherits = FALSE)
[17:42:19.106]                   }
[17:42:19.106]                   options(future.plan = NULL)
[17:42:19.106]                   if (is.na(NA_character_)) 
[17:42:19.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.106]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.106]                   {
[17:42:19.106]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.106]                     if (!future$lazy) 
[17:42:19.106]                       future <- run(future)
[17:42:19.106]                     invisible(future)
[17:42:19.106]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.106]                 }
[17:42:19.106]             }
[17:42:19.106]         }
[17:42:19.106]     })
[17:42:19.106]     if (TRUE) {
[17:42:19.106]         base::sink(type = "output", split = FALSE)
[17:42:19.106]         if (TRUE) {
[17:42:19.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.106]         }
[17:42:19.106]         else {
[17:42:19.106]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.106]         }
[17:42:19.106]         base::close(...future.stdout)
[17:42:19.106]         ...future.stdout <- NULL
[17:42:19.106]     }
[17:42:19.106]     ...future.result$conditions <- ...future.conditions
[17:42:19.106]     ...future.result$finished <- base::Sys.time()
[17:42:19.106]     ...future.result
[17:42:19.106] }
[17:42:19.108] plan(): Setting new future strategy stack:
[17:42:19.108] List of future strategies:
[17:42:19.108] 1. sequential:
[17:42:19.108]    - args: function (..., envir = parent.frame())
[17:42:19.108]    - tweaked: FALSE
[17:42:19.108]    - call: NULL
[17:42:19.109] plan(): nbrOfWorkers() = 1
[17:42:19.110] plan(): Setting new future strategy stack:
[17:42:19.110] List of future strategies:
[17:42:19.110] 1. sequential:
[17:42:19.110]    - args: function (..., envir = parent.frame())
[17:42:19.110]    - tweaked: FALSE
[17:42:19.110]    - call: plan(strategy)
[17:42:19.110] plan(): nbrOfWorkers() = 1
[17:42:19.110] SequentialFuture started (and completed)
[17:42:19.110] - Launch lazy future ... done
[17:42:19.111] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef821f188> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef867ef78> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef821f188> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef867ef78> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:42:19.116] resolved() for ‘SequentialFuture’ ...
[17:42:19.116] - state: ‘finished’
[17:42:19.116] - run: TRUE
[17:42:19.116] - result: ‘FutureResult’
[17:42:19.116] resolved() for ‘SequentialFuture’ ... done
[17:42:19.116] resolved() for ‘SequentialFuture’ ...
[17:42:19.116] - state: ‘finished’
[17:42:19.116] - run: TRUE
[17:42:19.116] - result: ‘FutureResult’
[17:42:19.117] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.118] resolve() on list ...
[17:42:19.119]  recursive: 0
[17:42:19.119]  length: 6
[17:42:19.119]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.119] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.119] - nx: 6
[17:42:19.119] - relay: TRUE
[17:42:19.119] - stdout: TRUE
[17:42:19.119] - signal: TRUE
[17:42:19.119] - resignal: FALSE
[17:42:19.119] - force: TRUE
[17:42:19.120] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.120] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.120]  - until=2
[17:42:19.120]  - relaying element #2
[17:42:19.120] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.120] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.120] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.120]  length: 5 (resolved future 1)
[17:42:19.120] resolved() for ‘SequentialFuture’ ...
[17:42:19.120] - state: ‘finished’
[17:42:19.120] - run: TRUE
[17:42:19.121] - result: ‘FutureResult’
[17:42:19.121] resolved() for ‘SequentialFuture’ ... done
[17:42:19.121] Future #2
[17:42:19.121] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.121] - nx: 6
[17:42:19.121] - relay: TRUE
[17:42:19.121] - stdout: TRUE
[17:42:19.121] - signal: TRUE
[17:42:19.121] - resignal: FALSE
[17:42:19.121] - force: TRUE
[17:42:19.122] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.122] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.122]  - until=2
[17:42:19.122]  - relaying element #2
[17:42:19.122] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.122] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.122] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.122]  length: 4 (resolved future 2)
[17:42:19.122] resolved() for ‘SequentialFuture’ ...
[17:42:19.122] - state: ‘finished’
[17:42:19.123] - run: TRUE
[17:42:19.123] - result: ‘FutureResult’
[17:42:19.123] resolved() for ‘SequentialFuture’ ... done
[17:42:19.123] Future #3
[17:42:19.123] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.123] - nx: 6
[17:42:19.123] - relay: TRUE
[17:42:19.123] - stdout: TRUE
[17:42:19.123] - signal: TRUE
[17:42:19.123] - resignal: FALSE
[17:42:19.124] - force: TRUE
[17:42:19.124] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.124] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.124]  - until=3
[17:42:19.124]  - relaying element #3
[17:42:19.124] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.124] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.124] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.124]  length: 3 (resolved future 3)
[17:42:19.124] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.125] - nx: 6
[17:42:19.125] - relay: TRUE
[17:42:19.125] - stdout: TRUE
[17:42:19.125] - signal: TRUE
[17:42:19.125] - resignal: FALSE
[17:42:19.125] - force: TRUE
[17:42:19.125] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.125] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.125]  - until=5
[17:42:19.125]  - relaying element #5
[17:42:19.125] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.125] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.126] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.126]  length: 2 (resolved future 4)
[17:42:19.126] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.126] - nx: 6
[17:42:19.126] - relay: TRUE
[17:42:19.126] - stdout: TRUE
[17:42:19.126] - signal: TRUE
[17:42:19.126] - resignal: FALSE
[17:42:19.126] - force: TRUE
[17:42:19.126] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.126] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.126]  - until=6
[17:42:19.127]  - relaying element #6
[17:42:19.127] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.127] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.127] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.127]  length: 1 (resolved future 5)
[17:42:19.127] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.127] - nx: 6
[17:42:19.127] - relay: TRUE
[17:42:19.127] - stdout: TRUE
[17:42:19.127] - signal: TRUE
[17:42:19.127] - resignal: FALSE
[17:42:19.128] - force: TRUE
[17:42:19.128] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.128] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.128]  - until=6
[17:42:19.128] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.128] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.128] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.128]  length: 0 (resolved future 6)
[17:42:19.128] Relaying remaining futures
[17:42:19.128] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.128] - nx: 6
[17:42:19.128] - relay: TRUE
[17:42:19.129] - stdout: TRUE
[17:42:19.129] - signal: TRUE
[17:42:19.129] - resignal: FALSE
[17:42:19.129] - force: TRUE
[17:42:19.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.129] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.129] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.129] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.129] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:42:19.134] getGlobalsAndPackages() ...
[17:42:19.134] Searching for globals...
[17:42:19.135] 
[17:42:19.135] Searching for globals ... DONE
[17:42:19.135] - globals: [0] <none>
[17:42:19.135] getGlobalsAndPackages() ... DONE
[17:42:19.135] run() for ‘Future’ ...
[17:42:19.135] - state: ‘created’
[17:42:19.136] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.136] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.136]   - Field: ‘label’
[17:42:19.136]   - Field: ‘local’
[17:42:19.136]   - Field: ‘owner’
[17:42:19.136]   - Field: ‘envir’
[17:42:19.136]   - Field: ‘packages’
[17:42:19.137]   - Field: ‘gc’
[17:42:19.137]   - Field: ‘conditions’
[17:42:19.137]   - Field: ‘expr’
[17:42:19.137]   - Field: ‘uuid’
[17:42:19.137]   - Field: ‘seed’
[17:42:19.137]   - Field: ‘version’
[17:42:19.137]   - Field: ‘result’
[17:42:19.137]   - Field: ‘asynchronous’
[17:42:19.137]   - Field: ‘calls’
[17:42:19.137]   - Field: ‘globals’
[17:42:19.138]   - Field: ‘stdout’
[17:42:19.138]   - Field: ‘earlySignal’
[17:42:19.138]   - Field: ‘lazy’
[17:42:19.138]   - Field: ‘state’
[17:42:19.138] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.138] - Launch lazy future ...
[17:42:19.138] Packages needed by the future expression (n = 0): <none>
[17:42:19.138] Packages needed by future strategies (n = 0): <none>
[17:42:19.139] {
[17:42:19.139]     {
[17:42:19.139]         {
[17:42:19.139]             ...future.startTime <- base::Sys.time()
[17:42:19.139]             {
[17:42:19.139]                 {
[17:42:19.139]                   {
[17:42:19.139]                     base::local({
[17:42:19.139]                       has_future <- base::requireNamespace("future", 
[17:42:19.139]                         quietly = TRUE)
[17:42:19.139]                       if (has_future) {
[17:42:19.139]                         ns <- base::getNamespace("future")
[17:42:19.139]                         version <- ns[[".package"]][["version"]]
[17:42:19.139]                         if (is.null(version)) 
[17:42:19.139]                           version <- utils::packageVersion("future")
[17:42:19.139]                       }
[17:42:19.139]                       else {
[17:42:19.139]                         version <- NULL
[17:42:19.139]                       }
[17:42:19.139]                       if (!has_future || version < "1.8.0") {
[17:42:19.139]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.139]                           "", base::R.version$version.string), 
[17:42:19.139]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.139]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.139]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.139]                             "release", "version")], collapse = " "), 
[17:42:19.139]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.139]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.139]                           info)
[17:42:19.139]                         info <- base::paste(info, collapse = "; ")
[17:42:19.139]                         if (!has_future) {
[17:42:19.139]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.139]                             info)
[17:42:19.139]                         }
[17:42:19.139]                         else {
[17:42:19.139]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.139]                             info, version)
[17:42:19.139]                         }
[17:42:19.139]                         base::stop(msg)
[17:42:19.139]                       }
[17:42:19.139]                     })
[17:42:19.139]                   }
[17:42:19.139]                   options(future.plan = NULL)
[17:42:19.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.139]                 }
[17:42:19.139]                 ...future.workdir <- getwd()
[17:42:19.139]             }
[17:42:19.139]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.139]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.139]         }
[17:42:19.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.139]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.139]             base::names(...future.oldOptions))
[17:42:19.139]     }
[17:42:19.139]     if (FALSE) {
[17:42:19.139]     }
[17:42:19.139]     else {
[17:42:19.139]         if (TRUE) {
[17:42:19.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.139]                 open = "w")
[17:42:19.139]         }
[17:42:19.139]         else {
[17:42:19.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.139]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.139]         }
[17:42:19.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.139]             base::sink(type = "output", split = FALSE)
[17:42:19.139]             base::close(...future.stdout)
[17:42:19.139]         }, add = TRUE)
[17:42:19.139]     }
[17:42:19.139]     ...future.frame <- base::sys.nframe()
[17:42:19.139]     ...future.conditions <- base::list()
[17:42:19.139]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.139]     if (FALSE) {
[17:42:19.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.139]     }
[17:42:19.139]     ...future.result <- base::tryCatch({
[17:42:19.139]         base::withCallingHandlers({
[17:42:19.139]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.139]             future::FutureResult(value = ...future.value$value, 
[17:42:19.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.139]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.139]                     ...future.globalenv.names))
[17:42:19.139]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.139]         }, condition = base::local({
[17:42:19.139]             c <- base::c
[17:42:19.139]             inherits <- base::inherits
[17:42:19.139]             invokeRestart <- base::invokeRestart
[17:42:19.139]             length <- base::length
[17:42:19.139]             list <- base::list
[17:42:19.139]             seq.int <- base::seq.int
[17:42:19.139]             signalCondition <- base::signalCondition
[17:42:19.139]             sys.calls <- base::sys.calls
[17:42:19.139]             `[[` <- base::`[[`
[17:42:19.139]             `+` <- base::`+`
[17:42:19.139]             `<<-` <- base::`<<-`
[17:42:19.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.139]                   3L)]
[17:42:19.139]             }
[17:42:19.139]             function(cond) {
[17:42:19.139]                 is_error <- inherits(cond, "error")
[17:42:19.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.139]                   NULL)
[17:42:19.139]                 if (is_error) {
[17:42:19.139]                   sessionInformation <- function() {
[17:42:19.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.139]                       search = base::search(), system = base::Sys.info())
[17:42:19.139]                   }
[17:42:19.139]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.139]                     cond$call), session = sessionInformation(), 
[17:42:19.139]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.139]                   signalCondition(cond)
[17:42:19.139]                 }
[17:42:19.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.139]                 "immediateCondition"))) {
[17:42:19.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.139]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.139]                   if (TRUE && !signal) {
[17:42:19.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.139]                     {
[17:42:19.139]                       inherits <- base::inherits
[17:42:19.139]                       invokeRestart <- base::invokeRestart
[17:42:19.139]                       is.null <- base::is.null
[17:42:19.139]                       muffled <- FALSE
[17:42:19.139]                       if (inherits(cond, "message")) {
[17:42:19.139]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.139]                         if (muffled) 
[17:42:19.139]                           invokeRestart("muffleMessage")
[17:42:19.139]                       }
[17:42:19.139]                       else if (inherits(cond, "warning")) {
[17:42:19.139]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.139]                         if (muffled) 
[17:42:19.139]                           invokeRestart("muffleWarning")
[17:42:19.139]                       }
[17:42:19.139]                       else if (inherits(cond, "condition")) {
[17:42:19.139]                         if (!is.null(pattern)) {
[17:42:19.139]                           computeRestarts <- base::computeRestarts
[17:42:19.139]                           grepl <- base::grepl
[17:42:19.139]                           restarts <- computeRestarts(cond)
[17:42:19.139]                           for (restart in restarts) {
[17:42:19.139]                             name <- restart$name
[17:42:19.139]                             if (is.null(name)) 
[17:42:19.139]                               next
[17:42:19.139]                             if (!grepl(pattern, name)) 
[17:42:19.139]                               next
[17:42:19.139]                             invokeRestart(restart)
[17:42:19.139]                             muffled <- TRUE
[17:42:19.139]                             break
[17:42:19.139]                           }
[17:42:19.139]                         }
[17:42:19.139]                       }
[17:42:19.139]                       invisible(muffled)
[17:42:19.139]                     }
[17:42:19.139]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.139]                   }
[17:42:19.139]                 }
[17:42:19.139]                 else {
[17:42:19.139]                   if (TRUE) {
[17:42:19.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.139]                     {
[17:42:19.139]                       inherits <- base::inherits
[17:42:19.139]                       invokeRestart <- base::invokeRestart
[17:42:19.139]                       is.null <- base::is.null
[17:42:19.139]                       muffled <- FALSE
[17:42:19.139]                       if (inherits(cond, "message")) {
[17:42:19.139]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.139]                         if (muffled) 
[17:42:19.139]                           invokeRestart("muffleMessage")
[17:42:19.139]                       }
[17:42:19.139]                       else if (inherits(cond, "warning")) {
[17:42:19.139]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.139]                         if (muffled) 
[17:42:19.139]                           invokeRestart("muffleWarning")
[17:42:19.139]                       }
[17:42:19.139]                       else if (inherits(cond, "condition")) {
[17:42:19.139]                         if (!is.null(pattern)) {
[17:42:19.139]                           computeRestarts <- base::computeRestarts
[17:42:19.139]                           grepl <- base::grepl
[17:42:19.139]                           restarts <- computeRestarts(cond)
[17:42:19.139]                           for (restart in restarts) {
[17:42:19.139]                             name <- restart$name
[17:42:19.139]                             if (is.null(name)) 
[17:42:19.139]                               next
[17:42:19.139]                             if (!grepl(pattern, name)) 
[17:42:19.139]                               next
[17:42:19.139]                             invokeRestart(restart)
[17:42:19.139]                             muffled <- TRUE
[17:42:19.139]                             break
[17:42:19.139]                           }
[17:42:19.139]                         }
[17:42:19.139]                       }
[17:42:19.139]                       invisible(muffled)
[17:42:19.139]                     }
[17:42:19.139]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.139]                   }
[17:42:19.139]                 }
[17:42:19.139]             }
[17:42:19.139]         }))
[17:42:19.139]     }, error = function(ex) {
[17:42:19.139]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.139]                 ...future.rng), started = ...future.startTime, 
[17:42:19.139]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.139]             version = "1.8"), class = "FutureResult")
[17:42:19.139]     }, finally = {
[17:42:19.139]         if (!identical(...future.workdir, getwd())) 
[17:42:19.139]             setwd(...future.workdir)
[17:42:19.139]         {
[17:42:19.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.139]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.139]             }
[17:42:19.139]             base::options(...future.oldOptions)
[17:42:19.139]             if (.Platform$OS.type == "windows") {
[17:42:19.139]                 old_names <- names(...future.oldEnvVars)
[17:42:19.139]                 envs <- base::Sys.getenv()
[17:42:19.139]                 names <- names(envs)
[17:42:19.139]                 common <- intersect(names, old_names)
[17:42:19.139]                 added <- setdiff(names, old_names)
[17:42:19.139]                 removed <- setdiff(old_names, names)
[17:42:19.139]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.139]                   envs[common]]
[17:42:19.139]                 NAMES <- toupper(changed)
[17:42:19.139]                 args <- list()
[17:42:19.139]                 for (kk in seq_along(NAMES)) {
[17:42:19.139]                   name <- changed[[kk]]
[17:42:19.139]                   NAME <- NAMES[[kk]]
[17:42:19.139]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.139]                     next
[17:42:19.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.139]                 }
[17:42:19.139]                 NAMES <- toupper(added)
[17:42:19.139]                 for (kk in seq_along(NAMES)) {
[17:42:19.139]                   name <- added[[kk]]
[17:42:19.139]                   NAME <- NAMES[[kk]]
[17:42:19.139]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.139]                     next
[17:42:19.139]                   args[[name]] <- ""
[17:42:19.139]                 }
[17:42:19.139]                 NAMES <- toupper(removed)
[17:42:19.139]                 for (kk in seq_along(NAMES)) {
[17:42:19.139]                   name <- removed[[kk]]
[17:42:19.139]                   NAME <- NAMES[[kk]]
[17:42:19.139]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.139]                     next
[17:42:19.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.139]                 }
[17:42:19.139]                 if (length(args) > 0) 
[17:42:19.139]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.139]             }
[17:42:19.139]             else {
[17:42:19.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.139]             }
[17:42:19.139]             {
[17:42:19.139]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.139]                   0L) {
[17:42:19.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.139]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.139]                   base::options(opts)
[17:42:19.139]                 }
[17:42:19.139]                 {
[17:42:19.139]                   {
[17:42:19.139]                     NULL
[17:42:19.139]                     RNGkind("Mersenne-Twister")
[17:42:19.139]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.139]                       inherits = FALSE)
[17:42:19.139]                   }
[17:42:19.139]                   options(future.plan = NULL)
[17:42:19.139]                   if (is.na(NA_character_)) 
[17:42:19.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.139]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.139]                   {
[17:42:19.139]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.139]                     if (!future$lazy) 
[17:42:19.139]                       future <- run(future)
[17:42:19.139]                     invisible(future)
[17:42:19.139]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.139]                 }
[17:42:19.139]             }
[17:42:19.139]         }
[17:42:19.139]     })
[17:42:19.139]     if (TRUE) {
[17:42:19.139]         base::sink(type = "output", split = FALSE)
[17:42:19.139]         if (TRUE) {
[17:42:19.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.139]         }
[17:42:19.139]         else {
[17:42:19.139]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.139]         }
[17:42:19.139]         base::close(...future.stdout)
[17:42:19.139]         ...future.stdout <- NULL
[17:42:19.139]     }
[17:42:19.139]     ...future.result$conditions <- ...future.conditions
[17:42:19.139]     ...future.result$finished <- base::Sys.time()
[17:42:19.139]     ...future.result
[17:42:19.139] }
[17:42:19.141] plan(): Setting new future strategy stack:
[17:42:19.141] List of future strategies:
[17:42:19.141] 1. sequential:
[17:42:19.141]    - args: function (..., envir = parent.frame())
[17:42:19.141]    - tweaked: FALSE
[17:42:19.141]    - call: NULL
[17:42:19.141] plan(): nbrOfWorkers() = 1
[17:42:19.142] plan(): Setting new future strategy stack:
[17:42:19.142] List of future strategies:
[17:42:19.142] 1. sequential:
[17:42:19.142]    - args: function (..., envir = parent.frame())
[17:42:19.142]    - tweaked: FALSE
[17:42:19.142]    - call: plan(strategy)
[17:42:19.143] plan(): nbrOfWorkers() = 1
[17:42:19.143] SequentialFuture started (and completed)
[17:42:19.143] - Launch lazy future ... done
[17:42:19.143] run() for ‘SequentialFuture’ ... done
[17:42:19.143] getGlobalsAndPackages() ...
[17:42:19.143] Searching for globals...
[17:42:19.143] 
[17:42:19.144] Searching for globals ... DONE
[17:42:19.144] - globals: [0] <none>
[17:42:19.144] getGlobalsAndPackages() ... DONE
[17:42:19.144] run() for ‘Future’ ...
[17:42:19.144] - state: ‘created’
[17:42:19.144] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.145] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.145]   - Field: ‘label’
[17:42:19.145]   - Field: ‘local’
[17:42:19.145]   - Field: ‘owner’
[17:42:19.145]   - Field: ‘envir’
[17:42:19.145]   - Field: ‘packages’
[17:42:19.145]   - Field: ‘gc’
[17:42:19.145]   - Field: ‘conditions’
[17:42:19.145]   - Field: ‘expr’
[17:42:19.145]   - Field: ‘uuid’
[17:42:19.146]   - Field: ‘seed’
[17:42:19.146]   - Field: ‘version’
[17:42:19.146]   - Field: ‘result’
[17:42:19.146]   - Field: ‘asynchronous’
[17:42:19.146]   - Field: ‘calls’
[17:42:19.146]   - Field: ‘globals’
[17:42:19.146]   - Field: ‘stdout’
[17:42:19.146]   - Field: ‘earlySignal’
[17:42:19.146]   - Field: ‘lazy’
[17:42:19.146]   - Field: ‘state’
[17:42:19.147] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.147] - Launch lazy future ...
[17:42:19.147] Packages needed by the future expression (n = 0): <none>
[17:42:19.147] Packages needed by future strategies (n = 0): <none>
[17:42:19.147] {
[17:42:19.147]     {
[17:42:19.147]         {
[17:42:19.147]             ...future.startTime <- base::Sys.time()
[17:42:19.147]             {
[17:42:19.147]                 {
[17:42:19.147]                   {
[17:42:19.147]                     base::local({
[17:42:19.147]                       has_future <- base::requireNamespace("future", 
[17:42:19.147]                         quietly = TRUE)
[17:42:19.147]                       if (has_future) {
[17:42:19.147]                         ns <- base::getNamespace("future")
[17:42:19.147]                         version <- ns[[".package"]][["version"]]
[17:42:19.147]                         if (is.null(version)) 
[17:42:19.147]                           version <- utils::packageVersion("future")
[17:42:19.147]                       }
[17:42:19.147]                       else {
[17:42:19.147]                         version <- NULL
[17:42:19.147]                       }
[17:42:19.147]                       if (!has_future || version < "1.8.0") {
[17:42:19.147]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.147]                           "", base::R.version$version.string), 
[17:42:19.147]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.147]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.147]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.147]                             "release", "version")], collapse = " "), 
[17:42:19.147]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.147]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.147]                           info)
[17:42:19.147]                         info <- base::paste(info, collapse = "; ")
[17:42:19.147]                         if (!has_future) {
[17:42:19.147]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.147]                             info)
[17:42:19.147]                         }
[17:42:19.147]                         else {
[17:42:19.147]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.147]                             info, version)
[17:42:19.147]                         }
[17:42:19.147]                         base::stop(msg)
[17:42:19.147]                       }
[17:42:19.147]                     })
[17:42:19.147]                   }
[17:42:19.147]                   options(future.plan = NULL)
[17:42:19.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.147]                 }
[17:42:19.147]                 ...future.workdir <- getwd()
[17:42:19.147]             }
[17:42:19.147]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.147]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.147]         }
[17:42:19.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.147]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.147]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.147]             base::names(...future.oldOptions))
[17:42:19.147]     }
[17:42:19.147]     if (FALSE) {
[17:42:19.147]     }
[17:42:19.147]     else {
[17:42:19.147]         if (TRUE) {
[17:42:19.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.147]                 open = "w")
[17:42:19.147]         }
[17:42:19.147]         else {
[17:42:19.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.147]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.147]         }
[17:42:19.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.147]             base::sink(type = "output", split = FALSE)
[17:42:19.147]             base::close(...future.stdout)
[17:42:19.147]         }, add = TRUE)
[17:42:19.147]     }
[17:42:19.147]     ...future.frame <- base::sys.nframe()
[17:42:19.147]     ...future.conditions <- base::list()
[17:42:19.147]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.147]     if (FALSE) {
[17:42:19.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.147]     }
[17:42:19.147]     ...future.result <- base::tryCatch({
[17:42:19.147]         base::withCallingHandlers({
[17:42:19.147]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.147]             future::FutureResult(value = ...future.value$value, 
[17:42:19.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.147]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.147]                     ...future.globalenv.names))
[17:42:19.147]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.147]         }, condition = base::local({
[17:42:19.147]             c <- base::c
[17:42:19.147]             inherits <- base::inherits
[17:42:19.147]             invokeRestart <- base::invokeRestart
[17:42:19.147]             length <- base::length
[17:42:19.147]             list <- base::list
[17:42:19.147]             seq.int <- base::seq.int
[17:42:19.147]             signalCondition <- base::signalCondition
[17:42:19.147]             sys.calls <- base::sys.calls
[17:42:19.147]             `[[` <- base::`[[`
[17:42:19.147]             `+` <- base::`+`
[17:42:19.147]             `<<-` <- base::`<<-`
[17:42:19.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.147]                   3L)]
[17:42:19.147]             }
[17:42:19.147]             function(cond) {
[17:42:19.147]                 is_error <- inherits(cond, "error")
[17:42:19.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.147]                   NULL)
[17:42:19.147]                 if (is_error) {
[17:42:19.147]                   sessionInformation <- function() {
[17:42:19.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.147]                       search = base::search(), system = base::Sys.info())
[17:42:19.147]                   }
[17:42:19.147]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.147]                     cond$call), session = sessionInformation(), 
[17:42:19.147]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.147]                   signalCondition(cond)
[17:42:19.147]                 }
[17:42:19.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.147]                 "immediateCondition"))) {
[17:42:19.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.147]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.147]                   if (TRUE && !signal) {
[17:42:19.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.147]                     {
[17:42:19.147]                       inherits <- base::inherits
[17:42:19.147]                       invokeRestart <- base::invokeRestart
[17:42:19.147]                       is.null <- base::is.null
[17:42:19.147]                       muffled <- FALSE
[17:42:19.147]                       if (inherits(cond, "message")) {
[17:42:19.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.147]                         if (muffled) 
[17:42:19.147]                           invokeRestart("muffleMessage")
[17:42:19.147]                       }
[17:42:19.147]                       else if (inherits(cond, "warning")) {
[17:42:19.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.147]                         if (muffled) 
[17:42:19.147]                           invokeRestart("muffleWarning")
[17:42:19.147]                       }
[17:42:19.147]                       else if (inherits(cond, "condition")) {
[17:42:19.147]                         if (!is.null(pattern)) {
[17:42:19.147]                           computeRestarts <- base::computeRestarts
[17:42:19.147]                           grepl <- base::grepl
[17:42:19.147]                           restarts <- computeRestarts(cond)
[17:42:19.147]                           for (restart in restarts) {
[17:42:19.147]                             name <- restart$name
[17:42:19.147]                             if (is.null(name)) 
[17:42:19.147]                               next
[17:42:19.147]                             if (!grepl(pattern, name)) 
[17:42:19.147]                               next
[17:42:19.147]                             invokeRestart(restart)
[17:42:19.147]                             muffled <- TRUE
[17:42:19.147]                             break
[17:42:19.147]                           }
[17:42:19.147]                         }
[17:42:19.147]                       }
[17:42:19.147]                       invisible(muffled)
[17:42:19.147]                     }
[17:42:19.147]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.147]                   }
[17:42:19.147]                 }
[17:42:19.147]                 else {
[17:42:19.147]                   if (TRUE) {
[17:42:19.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.147]                     {
[17:42:19.147]                       inherits <- base::inherits
[17:42:19.147]                       invokeRestart <- base::invokeRestart
[17:42:19.147]                       is.null <- base::is.null
[17:42:19.147]                       muffled <- FALSE
[17:42:19.147]                       if (inherits(cond, "message")) {
[17:42:19.147]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.147]                         if (muffled) 
[17:42:19.147]                           invokeRestart("muffleMessage")
[17:42:19.147]                       }
[17:42:19.147]                       else if (inherits(cond, "warning")) {
[17:42:19.147]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.147]                         if (muffled) 
[17:42:19.147]                           invokeRestart("muffleWarning")
[17:42:19.147]                       }
[17:42:19.147]                       else if (inherits(cond, "condition")) {
[17:42:19.147]                         if (!is.null(pattern)) {
[17:42:19.147]                           computeRestarts <- base::computeRestarts
[17:42:19.147]                           grepl <- base::grepl
[17:42:19.147]                           restarts <- computeRestarts(cond)
[17:42:19.147]                           for (restart in restarts) {
[17:42:19.147]                             name <- restart$name
[17:42:19.147]                             if (is.null(name)) 
[17:42:19.147]                               next
[17:42:19.147]                             if (!grepl(pattern, name)) 
[17:42:19.147]                               next
[17:42:19.147]                             invokeRestart(restart)
[17:42:19.147]                             muffled <- TRUE
[17:42:19.147]                             break
[17:42:19.147]                           }
[17:42:19.147]                         }
[17:42:19.147]                       }
[17:42:19.147]                       invisible(muffled)
[17:42:19.147]                     }
[17:42:19.147]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.147]                   }
[17:42:19.147]                 }
[17:42:19.147]             }
[17:42:19.147]         }))
[17:42:19.147]     }, error = function(ex) {
[17:42:19.147]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.147]                 ...future.rng), started = ...future.startTime, 
[17:42:19.147]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.147]             version = "1.8"), class = "FutureResult")
[17:42:19.147]     }, finally = {
[17:42:19.147]         if (!identical(...future.workdir, getwd())) 
[17:42:19.147]             setwd(...future.workdir)
[17:42:19.147]         {
[17:42:19.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.147]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.147]             }
[17:42:19.147]             base::options(...future.oldOptions)
[17:42:19.147]             if (.Platform$OS.type == "windows") {
[17:42:19.147]                 old_names <- names(...future.oldEnvVars)
[17:42:19.147]                 envs <- base::Sys.getenv()
[17:42:19.147]                 names <- names(envs)
[17:42:19.147]                 common <- intersect(names, old_names)
[17:42:19.147]                 added <- setdiff(names, old_names)
[17:42:19.147]                 removed <- setdiff(old_names, names)
[17:42:19.147]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.147]                   envs[common]]
[17:42:19.147]                 NAMES <- toupper(changed)
[17:42:19.147]                 args <- list()
[17:42:19.147]                 for (kk in seq_along(NAMES)) {
[17:42:19.147]                   name <- changed[[kk]]
[17:42:19.147]                   NAME <- NAMES[[kk]]
[17:42:19.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.147]                     next
[17:42:19.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.147]                 }
[17:42:19.147]                 NAMES <- toupper(added)
[17:42:19.147]                 for (kk in seq_along(NAMES)) {
[17:42:19.147]                   name <- added[[kk]]
[17:42:19.147]                   NAME <- NAMES[[kk]]
[17:42:19.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.147]                     next
[17:42:19.147]                   args[[name]] <- ""
[17:42:19.147]                 }
[17:42:19.147]                 NAMES <- toupper(removed)
[17:42:19.147]                 for (kk in seq_along(NAMES)) {
[17:42:19.147]                   name <- removed[[kk]]
[17:42:19.147]                   NAME <- NAMES[[kk]]
[17:42:19.147]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.147]                     next
[17:42:19.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.147]                 }
[17:42:19.147]                 if (length(args) > 0) 
[17:42:19.147]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.147]             }
[17:42:19.147]             else {
[17:42:19.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.147]             }
[17:42:19.147]             {
[17:42:19.147]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.147]                   0L) {
[17:42:19.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.147]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.147]                   base::options(opts)
[17:42:19.147]                 }
[17:42:19.147]                 {
[17:42:19.147]                   {
[17:42:19.147]                     NULL
[17:42:19.147]                     RNGkind("Mersenne-Twister")
[17:42:19.147]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.147]                       inherits = FALSE)
[17:42:19.147]                   }
[17:42:19.147]                   options(future.plan = NULL)
[17:42:19.147]                   if (is.na(NA_character_)) 
[17:42:19.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.147]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.147]                   {
[17:42:19.147]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.147]                     if (!future$lazy) 
[17:42:19.147]                       future <- run(future)
[17:42:19.147]                     invisible(future)
[17:42:19.147]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.147]                 }
[17:42:19.147]             }
[17:42:19.147]         }
[17:42:19.147]     })
[17:42:19.147]     if (TRUE) {
[17:42:19.147]         base::sink(type = "output", split = FALSE)
[17:42:19.147]         if (TRUE) {
[17:42:19.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.147]         }
[17:42:19.147]         else {
[17:42:19.147]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.147]         }
[17:42:19.147]         base::close(...future.stdout)
[17:42:19.147]         ...future.stdout <- NULL
[17:42:19.147]     }
[17:42:19.147]     ...future.result$conditions <- ...future.conditions
[17:42:19.147]     ...future.result$finished <- base::Sys.time()
[17:42:19.147]     ...future.result
[17:42:19.147] }
[17:42:19.149] plan(): Setting new future strategy stack:
[17:42:19.149] List of future strategies:
[17:42:19.149] 1. sequential:
[17:42:19.149]    - args: function (..., envir = parent.frame())
[17:42:19.149]    - tweaked: FALSE
[17:42:19.149]    - call: NULL
[17:42:19.150] plan(): nbrOfWorkers() = 1
[17:42:19.150] plan(): Setting new future strategy stack:
[17:42:19.150] List of future strategies:
[17:42:19.150] 1. sequential:
[17:42:19.150]    - args: function (..., envir = parent.frame())
[17:42:19.150]    - tweaked: FALSE
[17:42:19.150]    - call: plan(strategy)
[17:42:19.151] plan(): nbrOfWorkers() = 1
[17:42:19.151] SequentialFuture started (and completed)
[17:42:19.151] - Launch lazy future ... done
[17:42:19.151] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef6cef0d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef78faf18> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef6cef0d0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef78faf18> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:42:19.156] resolved() for ‘SequentialFuture’ ...
[17:42:19.156] - state: ‘finished’
[17:42:19.156] - run: TRUE
[17:42:19.157] - result: ‘FutureResult’
[17:42:19.157] resolved() for ‘SequentialFuture’ ... done
[17:42:19.157] resolved() for ‘SequentialFuture’ ...
[17:42:19.157] - state: ‘finished’
[17:42:19.157] - run: TRUE
[17:42:19.157] - result: ‘FutureResult’
[17:42:19.157] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.159] resolve() on list ...
[17:42:19.159]  recursive: 0
[17:42:19.159]  length: 6
[17:42:19.159]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.159] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.159] - nx: 6
[17:42:19.159] - relay: TRUE
[17:42:19.159] - stdout: TRUE
[17:42:19.159] - signal: TRUE
[17:42:19.160] - resignal: FALSE
[17:42:19.160] - force: TRUE
[17:42:19.160] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.160] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.160]  - until=2
[17:42:19.160]  - relaying element #2
[17:42:19.160] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.160] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.160] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.160]  length: 5 (resolved future 1)
[17:42:19.160] resolved() for ‘SequentialFuture’ ...
[17:42:19.161] - state: ‘finished’
[17:42:19.161] - run: TRUE
[17:42:19.161] - result: ‘FutureResult’
[17:42:19.161] resolved() for ‘SequentialFuture’ ... done
[17:42:19.161] Future #2
[17:42:19.161] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.161] - nx: 6
[17:42:19.161] - relay: TRUE
[17:42:19.161] - stdout: TRUE
[17:42:19.161] - signal: TRUE
[17:42:19.161] - resignal: FALSE
[17:42:19.162] - force: TRUE
[17:42:19.162] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.162] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.162]  - until=2
[17:42:19.162]  - relaying element #2
[17:42:19.162] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.162] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.162] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.162]  length: 4 (resolved future 2)
[17:42:19.162] resolved() for ‘SequentialFuture’ ...
[17:42:19.163] - state: ‘finished’
[17:42:19.163] - run: TRUE
[17:42:19.163] - result: ‘FutureResult’
[17:42:19.163] resolved() for ‘SequentialFuture’ ... done
[17:42:19.165] Future #3
[17:42:19.165] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.165] - nx: 6
[17:42:19.165] - relay: TRUE
[17:42:19.165] - stdout: TRUE
[17:42:19.165] - signal: TRUE
[17:42:19.165] - resignal: FALSE
[17:42:19.165] - force: TRUE
[17:42:19.165] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.166] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.166]  - until=3
[17:42:19.166]  - relaying element #3
[17:42:19.166] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.166] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.166] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.166]  length: 3 (resolved future 3)
[17:42:19.166] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.166] - nx: 6
[17:42:19.166] - relay: TRUE
[17:42:19.167] - stdout: TRUE
[17:42:19.167] - signal: TRUE
[17:42:19.167] - resignal: FALSE
[17:42:19.167] - force: TRUE
[17:42:19.167] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.167] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.167]  - until=5
[17:42:19.167]  - relaying element #5
[17:42:19.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.167] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.168] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.168]  length: 2 (resolved future 4)
[17:42:19.168] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.168] - nx: 6
[17:42:19.168] - relay: TRUE
[17:42:19.168] - stdout: TRUE
[17:42:19.168] - signal: TRUE
[17:42:19.168] - resignal: FALSE
[17:42:19.168] - force: TRUE
[17:42:19.168] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.168] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.168]  - until=6
[17:42:19.169]  - relaying element #6
[17:42:19.169] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.169] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.169] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.169]  length: 1 (resolved future 5)
[17:42:19.169] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.169] - nx: 6
[17:42:19.169] - relay: TRUE
[17:42:19.169] - stdout: TRUE
[17:42:19.169] - signal: TRUE
[17:42:19.169] - resignal: FALSE
[17:42:19.169] - force: TRUE
[17:42:19.170] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.170] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.170]  - until=6
[17:42:19.170] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.170] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.170] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.170]  length: 0 (resolved future 6)
[17:42:19.170] Relaying remaining futures
[17:42:19.170] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.170] - nx: 6
[17:42:19.170] - relay: TRUE
[17:42:19.171] - stdout: TRUE
[17:42:19.171] - signal: TRUE
[17:42:19.171] - resignal: FALSE
[17:42:19.171] - force: TRUE
[17:42:19.171] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.171] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.171] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.171] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.171] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.171] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:42:19.175] getGlobalsAndPackages() ...
[17:42:19.175] Searching for globals...
[17:42:19.175] 
[17:42:19.176] Searching for globals ... DONE
[17:42:19.176] - globals: [0] <none>
[17:42:19.176] getGlobalsAndPackages() ... DONE
[17:42:19.176] run() for ‘Future’ ...
[17:42:19.176] - state: ‘created’
[17:42:19.176] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.177] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.177]   - Field: ‘label’
[17:42:19.177]   - Field: ‘local’
[17:42:19.177]   - Field: ‘owner’
[17:42:19.177]   - Field: ‘envir’
[17:42:19.177]   - Field: ‘packages’
[17:42:19.177]   - Field: ‘gc’
[17:42:19.177]   - Field: ‘conditions’
[17:42:19.177]   - Field: ‘expr’
[17:42:19.178]   - Field: ‘uuid’
[17:42:19.178]   - Field: ‘seed’
[17:42:19.178]   - Field: ‘version’
[17:42:19.178]   - Field: ‘result’
[17:42:19.178]   - Field: ‘asynchronous’
[17:42:19.178]   - Field: ‘calls’
[17:42:19.178]   - Field: ‘globals’
[17:42:19.178]   - Field: ‘stdout’
[17:42:19.178]   - Field: ‘earlySignal’
[17:42:19.178]   - Field: ‘lazy’
[17:42:19.178]   - Field: ‘state’
[17:42:19.179] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.179] - Launch lazy future ...
[17:42:19.179] Packages needed by the future expression (n = 0): <none>
[17:42:19.179] Packages needed by future strategies (n = 0): <none>
[17:42:19.179] {
[17:42:19.179]     {
[17:42:19.179]         {
[17:42:19.179]             ...future.startTime <- base::Sys.time()
[17:42:19.179]             {
[17:42:19.179]                 {
[17:42:19.179]                   {
[17:42:19.179]                     base::local({
[17:42:19.179]                       has_future <- base::requireNamespace("future", 
[17:42:19.179]                         quietly = TRUE)
[17:42:19.179]                       if (has_future) {
[17:42:19.179]                         ns <- base::getNamespace("future")
[17:42:19.179]                         version <- ns[[".package"]][["version"]]
[17:42:19.179]                         if (is.null(version)) 
[17:42:19.179]                           version <- utils::packageVersion("future")
[17:42:19.179]                       }
[17:42:19.179]                       else {
[17:42:19.179]                         version <- NULL
[17:42:19.179]                       }
[17:42:19.179]                       if (!has_future || version < "1.8.0") {
[17:42:19.179]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.179]                           "", base::R.version$version.string), 
[17:42:19.179]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.179]                             "release", "version")], collapse = " "), 
[17:42:19.179]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.179]                           info)
[17:42:19.179]                         info <- base::paste(info, collapse = "; ")
[17:42:19.179]                         if (!has_future) {
[17:42:19.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.179]                             info)
[17:42:19.179]                         }
[17:42:19.179]                         else {
[17:42:19.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.179]                             info, version)
[17:42:19.179]                         }
[17:42:19.179]                         base::stop(msg)
[17:42:19.179]                       }
[17:42:19.179]                     })
[17:42:19.179]                   }
[17:42:19.179]                   options(future.plan = NULL)
[17:42:19.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.179]                 }
[17:42:19.179]                 ...future.workdir <- getwd()
[17:42:19.179]             }
[17:42:19.179]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.179]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.179]         }
[17:42:19.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.179]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.179]             base::names(...future.oldOptions))
[17:42:19.179]     }
[17:42:19.179]     if (FALSE) {
[17:42:19.179]     }
[17:42:19.179]     else {
[17:42:19.179]         if (TRUE) {
[17:42:19.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.179]                 open = "w")
[17:42:19.179]         }
[17:42:19.179]         else {
[17:42:19.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.179]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.179]         }
[17:42:19.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.179]             base::sink(type = "output", split = FALSE)
[17:42:19.179]             base::close(...future.stdout)
[17:42:19.179]         }, add = TRUE)
[17:42:19.179]     }
[17:42:19.179]     ...future.frame <- base::sys.nframe()
[17:42:19.179]     ...future.conditions <- base::list()
[17:42:19.179]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.179]     if (FALSE) {
[17:42:19.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.179]     }
[17:42:19.179]     ...future.result <- base::tryCatch({
[17:42:19.179]         base::withCallingHandlers({
[17:42:19.179]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.179]             future::FutureResult(value = ...future.value$value, 
[17:42:19.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.179]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.179]                     ...future.globalenv.names))
[17:42:19.179]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.179]         }, condition = base::local({
[17:42:19.179]             c <- base::c
[17:42:19.179]             inherits <- base::inherits
[17:42:19.179]             invokeRestart <- base::invokeRestart
[17:42:19.179]             length <- base::length
[17:42:19.179]             list <- base::list
[17:42:19.179]             seq.int <- base::seq.int
[17:42:19.179]             signalCondition <- base::signalCondition
[17:42:19.179]             sys.calls <- base::sys.calls
[17:42:19.179]             `[[` <- base::`[[`
[17:42:19.179]             `+` <- base::`+`
[17:42:19.179]             `<<-` <- base::`<<-`
[17:42:19.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.179]                   3L)]
[17:42:19.179]             }
[17:42:19.179]             function(cond) {
[17:42:19.179]                 is_error <- inherits(cond, "error")
[17:42:19.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.179]                   NULL)
[17:42:19.179]                 if (is_error) {
[17:42:19.179]                   sessionInformation <- function() {
[17:42:19.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.179]                       search = base::search(), system = base::Sys.info())
[17:42:19.179]                   }
[17:42:19.179]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.179]                     cond$call), session = sessionInformation(), 
[17:42:19.179]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.179]                   signalCondition(cond)
[17:42:19.179]                 }
[17:42:19.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.179]                 "immediateCondition"))) {
[17:42:19.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.179]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.179]                   if (TRUE && !signal) {
[17:42:19.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.179]                     {
[17:42:19.179]                       inherits <- base::inherits
[17:42:19.179]                       invokeRestart <- base::invokeRestart
[17:42:19.179]                       is.null <- base::is.null
[17:42:19.179]                       muffled <- FALSE
[17:42:19.179]                       if (inherits(cond, "message")) {
[17:42:19.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.179]                         if (muffled) 
[17:42:19.179]                           invokeRestart("muffleMessage")
[17:42:19.179]                       }
[17:42:19.179]                       else if (inherits(cond, "warning")) {
[17:42:19.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.179]                         if (muffled) 
[17:42:19.179]                           invokeRestart("muffleWarning")
[17:42:19.179]                       }
[17:42:19.179]                       else if (inherits(cond, "condition")) {
[17:42:19.179]                         if (!is.null(pattern)) {
[17:42:19.179]                           computeRestarts <- base::computeRestarts
[17:42:19.179]                           grepl <- base::grepl
[17:42:19.179]                           restarts <- computeRestarts(cond)
[17:42:19.179]                           for (restart in restarts) {
[17:42:19.179]                             name <- restart$name
[17:42:19.179]                             if (is.null(name)) 
[17:42:19.179]                               next
[17:42:19.179]                             if (!grepl(pattern, name)) 
[17:42:19.179]                               next
[17:42:19.179]                             invokeRestart(restart)
[17:42:19.179]                             muffled <- TRUE
[17:42:19.179]                             break
[17:42:19.179]                           }
[17:42:19.179]                         }
[17:42:19.179]                       }
[17:42:19.179]                       invisible(muffled)
[17:42:19.179]                     }
[17:42:19.179]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.179]                   }
[17:42:19.179]                 }
[17:42:19.179]                 else {
[17:42:19.179]                   if (TRUE) {
[17:42:19.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.179]                     {
[17:42:19.179]                       inherits <- base::inherits
[17:42:19.179]                       invokeRestart <- base::invokeRestart
[17:42:19.179]                       is.null <- base::is.null
[17:42:19.179]                       muffled <- FALSE
[17:42:19.179]                       if (inherits(cond, "message")) {
[17:42:19.179]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.179]                         if (muffled) 
[17:42:19.179]                           invokeRestart("muffleMessage")
[17:42:19.179]                       }
[17:42:19.179]                       else if (inherits(cond, "warning")) {
[17:42:19.179]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.179]                         if (muffled) 
[17:42:19.179]                           invokeRestart("muffleWarning")
[17:42:19.179]                       }
[17:42:19.179]                       else if (inherits(cond, "condition")) {
[17:42:19.179]                         if (!is.null(pattern)) {
[17:42:19.179]                           computeRestarts <- base::computeRestarts
[17:42:19.179]                           grepl <- base::grepl
[17:42:19.179]                           restarts <- computeRestarts(cond)
[17:42:19.179]                           for (restart in restarts) {
[17:42:19.179]                             name <- restart$name
[17:42:19.179]                             if (is.null(name)) 
[17:42:19.179]                               next
[17:42:19.179]                             if (!grepl(pattern, name)) 
[17:42:19.179]                               next
[17:42:19.179]                             invokeRestart(restart)
[17:42:19.179]                             muffled <- TRUE
[17:42:19.179]                             break
[17:42:19.179]                           }
[17:42:19.179]                         }
[17:42:19.179]                       }
[17:42:19.179]                       invisible(muffled)
[17:42:19.179]                     }
[17:42:19.179]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.179]                   }
[17:42:19.179]                 }
[17:42:19.179]             }
[17:42:19.179]         }))
[17:42:19.179]     }, error = function(ex) {
[17:42:19.179]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.179]                 ...future.rng), started = ...future.startTime, 
[17:42:19.179]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.179]             version = "1.8"), class = "FutureResult")
[17:42:19.179]     }, finally = {
[17:42:19.179]         if (!identical(...future.workdir, getwd())) 
[17:42:19.179]             setwd(...future.workdir)
[17:42:19.179]         {
[17:42:19.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.179]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.179]             }
[17:42:19.179]             base::options(...future.oldOptions)
[17:42:19.179]             if (.Platform$OS.type == "windows") {
[17:42:19.179]                 old_names <- names(...future.oldEnvVars)
[17:42:19.179]                 envs <- base::Sys.getenv()
[17:42:19.179]                 names <- names(envs)
[17:42:19.179]                 common <- intersect(names, old_names)
[17:42:19.179]                 added <- setdiff(names, old_names)
[17:42:19.179]                 removed <- setdiff(old_names, names)
[17:42:19.179]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.179]                   envs[common]]
[17:42:19.179]                 NAMES <- toupper(changed)
[17:42:19.179]                 args <- list()
[17:42:19.179]                 for (kk in seq_along(NAMES)) {
[17:42:19.179]                   name <- changed[[kk]]
[17:42:19.179]                   NAME <- NAMES[[kk]]
[17:42:19.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.179]                     next
[17:42:19.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.179]                 }
[17:42:19.179]                 NAMES <- toupper(added)
[17:42:19.179]                 for (kk in seq_along(NAMES)) {
[17:42:19.179]                   name <- added[[kk]]
[17:42:19.179]                   NAME <- NAMES[[kk]]
[17:42:19.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.179]                     next
[17:42:19.179]                   args[[name]] <- ""
[17:42:19.179]                 }
[17:42:19.179]                 NAMES <- toupper(removed)
[17:42:19.179]                 for (kk in seq_along(NAMES)) {
[17:42:19.179]                   name <- removed[[kk]]
[17:42:19.179]                   NAME <- NAMES[[kk]]
[17:42:19.179]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.179]                     next
[17:42:19.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.179]                 }
[17:42:19.179]                 if (length(args) > 0) 
[17:42:19.179]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.179]             }
[17:42:19.179]             else {
[17:42:19.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.179]             }
[17:42:19.179]             {
[17:42:19.179]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.179]                   0L) {
[17:42:19.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.179]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.179]                   base::options(opts)
[17:42:19.179]                 }
[17:42:19.179]                 {
[17:42:19.179]                   {
[17:42:19.179]                     NULL
[17:42:19.179]                     RNGkind("Mersenne-Twister")
[17:42:19.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.179]                       inherits = FALSE)
[17:42:19.179]                   }
[17:42:19.179]                   options(future.plan = NULL)
[17:42:19.179]                   if (is.na(NA_character_)) 
[17:42:19.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.179]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.179]                   {
[17:42:19.179]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.179]                     if (!future$lazy) 
[17:42:19.179]                       future <- run(future)
[17:42:19.179]                     invisible(future)
[17:42:19.179]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.179]                 }
[17:42:19.179]             }
[17:42:19.179]         }
[17:42:19.179]     })
[17:42:19.179]     if (TRUE) {
[17:42:19.179]         base::sink(type = "output", split = FALSE)
[17:42:19.179]         if (TRUE) {
[17:42:19.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.179]         }
[17:42:19.179]         else {
[17:42:19.179]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.179]         }
[17:42:19.179]         base::close(...future.stdout)
[17:42:19.179]         ...future.stdout <- NULL
[17:42:19.179]     }
[17:42:19.179]     ...future.result$conditions <- ...future.conditions
[17:42:19.179]     ...future.result$finished <- base::Sys.time()
[17:42:19.179]     ...future.result
[17:42:19.179] }
[17:42:19.181] plan(): Setting new future strategy stack:
[17:42:19.181] List of future strategies:
[17:42:19.181] 1. sequential:
[17:42:19.181]    - args: function (..., envir = parent.frame())
[17:42:19.181]    - tweaked: FALSE
[17:42:19.181]    - call: NULL
[17:42:19.182] plan(): nbrOfWorkers() = 1
[17:42:19.183] plan(): Setting new future strategy stack:
[17:42:19.183] List of future strategies:
[17:42:19.183] 1. sequential:
[17:42:19.183]    - args: function (..., envir = parent.frame())
[17:42:19.183]    - tweaked: FALSE
[17:42:19.183]    - call: plan(strategy)
[17:42:19.183] plan(): nbrOfWorkers() = 1
[17:42:19.183] SequentialFuture started (and completed)
[17:42:19.183] - Launch lazy future ... done
[17:42:19.183] run() for ‘SequentialFuture’ ... done
[17:42:19.184] getGlobalsAndPackages() ...
[17:42:19.184] Searching for globals...
[17:42:19.184] 
[17:42:19.184] Searching for globals ... DONE
[17:42:19.184] - globals: [0] <none>
[17:42:19.184] getGlobalsAndPackages() ... DONE
[17:42:19.185] run() for ‘Future’ ...
[17:42:19.185] - state: ‘created’
[17:42:19.185] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.185] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.185] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.185]   - Field: ‘label’
[17:42:19.185]   - Field: ‘local’
[17:42:19.185]   - Field: ‘owner’
[17:42:19.185]   - Field: ‘envir’
[17:42:19.186]   - Field: ‘packages’
[17:42:19.186]   - Field: ‘gc’
[17:42:19.186]   - Field: ‘conditions’
[17:42:19.186]   - Field: ‘expr’
[17:42:19.186]   - Field: ‘uuid’
[17:42:19.186]   - Field: ‘seed’
[17:42:19.186]   - Field: ‘version’
[17:42:19.186]   - Field: ‘result’
[17:42:19.186]   - Field: ‘asynchronous’
[17:42:19.186]   - Field: ‘calls’
[17:42:19.187]   - Field: ‘globals’
[17:42:19.187]   - Field: ‘stdout’
[17:42:19.187]   - Field: ‘earlySignal’
[17:42:19.187]   - Field: ‘lazy’
[17:42:19.187]   - Field: ‘state’
[17:42:19.187] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.187] - Launch lazy future ...
[17:42:19.187] Packages needed by the future expression (n = 0): <none>
[17:42:19.187] Packages needed by future strategies (n = 0): <none>
[17:42:19.188] {
[17:42:19.188]     {
[17:42:19.188]         {
[17:42:19.188]             ...future.startTime <- base::Sys.time()
[17:42:19.188]             {
[17:42:19.188]                 {
[17:42:19.188]                   {
[17:42:19.188]                     base::local({
[17:42:19.188]                       has_future <- base::requireNamespace("future", 
[17:42:19.188]                         quietly = TRUE)
[17:42:19.188]                       if (has_future) {
[17:42:19.188]                         ns <- base::getNamespace("future")
[17:42:19.188]                         version <- ns[[".package"]][["version"]]
[17:42:19.188]                         if (is.null(version)) 
[17:42:19.188]                           version <- utils::packageVersion("future")
[17:42:19.188]                       }
[17:42:19.188]                       else {
[17:42:19.188]                         version <- NULL
[17:42:19.188]                       }
[17:42:19.188]                       if (!has_future || version < "1.8.0") {
[17:42:19.188]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.188]                           "", base::R.version$version.string), 
[17:42:19.188]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.188]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.188]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.188]                             "release", "version")], collapse = " "), 
[17:42:19.188]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.188]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.188]                           info)
[17:42:19.188]                         info <- base::paste(info, collapse = "; ")
[17:42:19.188]                         if (!has_future) {
[17:42:19.188]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.188]                             info)
[17:42:19.188]                         }
[17:42:19.188]                         else {
[17:42:19.188]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.188]                             info, version)
[17:42:19.188]                         }
[17:42:19.188]                         base::stop(msg)
[17:42:19.188]                       }
[17:42:19.188]                     })
[17:42:19.188]                   }
[17:42:19.188]                   options(future.plan = NULL)
[17:42:19.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.188]                 }
[17:42:19.188]                 ...future.workdir <- getwd()
[17:42:19.188]             }
[17:42:19.188]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.188]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.188]         }
[17:42:19.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.188]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.188]             base::names(...future.oldOptions))
[17:42:19.188]     }
[17:42:19.188]     if (FALSE) {
[17:42:19.188]     }
[17:42:19.188]     else {
[17:42:19.188]         if (TRUE) {
[17:42:19.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.188]                 open = "w")
[17:42:19.188]         }
[17:42:19.188]         else {
[17:42:19.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.188]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.188]         }
[17:42:19.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.188]             base::sink(type = "output", split = FALSE)
[17:42:19.188]             base::close(...future.stdout)
[17:42:19.188]         }, add = TRUE)
[17:42:19.188]     }
[17:42:19.188]     ...future.frame <- base::sys.nframe()
[17:42:19.188]     ...future.conditions <- base::list()
[17:42:19.188]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.188]     if (FALSE) {
[17:42:19.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.188]     }
[17:42:19.188]     ...future.result <- base::tryCatch({
[17:42:19.188]         base::withCallingHandlers({
[17:42:19.188]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.188]             future::FutureResult(value = ...future.value$value, 
[17:42:19.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.188]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.188]                     ...future.globalenv.names))
[17:42:19.188]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.188]         }, condition = base::local({
[17:42:19.188]             c <- base::c
[17:42:19.188]             inherits <- base::inherits
[17:42:19.188]             invokeRestart <- base::invokeRestart
[17:42:19.188]             length <- base::length
[17:42:19.188]             list <- base::list
[17:42:19.188]             seq.int <- base::seq.int
[17:42:19.188]             signalCondition <- base::signalCondition
[17:42:19.188]             sys.calls <- base::sys.calls
[17:42:19.188]             `[[` <- base::`[[`
[17:42:19.188]             `+` <- base::`+`
[17:42:19.188]             `<<-` <- base::`<<-`
[17:42:19.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.188]                   3L)]
[17:42:19.188]             }
[17:42:19.188]             function(cond) {
[17:42:19.188]                 is_error <- inherits(cond, "error")
[17:42:19.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.188]                   NULL)
[17:42:19.188]                 if (is_error) {
[17:42:19.188]                   sessionInformation <- function() {
[17:42:19.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.188]                       search = base::search(), system = base::Sys.info())
[17:42:19.188]                   }
[17:42:19.188]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.188]                     cond$call), session = sessionInformation(), 
[17:42:19.188]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.188]                   signalCondition(cond)
[17:42:19.188]                 }
[17:42:19.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.188]                 "immediateCondition"))) {
[17:42:19.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.188]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.188]                   if (TRUE && !signal) {
[17:42:19.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.188]                     {
[17:42:19.188]                       inherits <- base::inherits
[17:42:19.188]                       invokeRestart <- base::invokeRestart
[17:42:19.188]                       is.null <- base::is.null
[17:42:19.188]                       muffled <- FALSE
[17:42:19.188]                       if (inherits(cond, "message")) {
[17:42:19.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.188]                         if (muffled) 
[17:42:19.188]                           invokeRestart("muffleMessage")
[17:42:19.188]                       }
[17:42:19.188]                       else if (inherits(cond, "warning")) {
[17:42:19.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.188]                         if (muffled) 
[17:42:19.188]                           invokeRestart("muffleWarning")
[17:42:19.188]                       }
[17:42:19.188]                       else if (inherits(cond, "condition")) {
[17:42:19.188]                         if (!is.null(pattern)) {
[17:42:19.188]                           computeRestarts <- base::computeRestarts
[17:42:19.188]                           grepl <- base::grepl
[17:42:19.188]                           restarts <- computeRestarts(cond)
[17:42:19.188]                           for (restart in restarts) {
[17:42:19.188]                             name <- restart$name
[17:42:19.188]                             if (is.null(name)) 
[17:42:19.188]                               next
[17:42:19.188]                             if (!grepl(pattern, name)) 
[17:42:19.188]                               next
[17:42:19.188]                             invokeRestart(restart)
[17:42:19.188]                             muffled <- TRUE
[17:42:19.188]                             break
[17:42:19.188]                           }
[17:42:19.188]                         }
[17:42:19.188]                       }
[17:42:19.188]                       invisible(muffled)
[17:42:19.188]                     }
[17:42:19.188]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.188]                   }
[17:42:19.188]                 }
[17:42:19.188]                 else {
[17:42:19.188]                   if (TRUE) {
[17:42:19.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.188]                     {
[17:42:19.188]                       inherits <- base::inherits
[17:42:19.188]                       invokeRestart <- base::invokeRestart
[17:42:19.188]                       is.null <- base::is.null
[17:42:19.188]                       muffled <- FALSE
[17:42:19.188]                       if (inherits(cond, "message")) {
[17:42:19.188]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.188]                         if (muffled) 
[17:42:19.188]                           invokeRestart("muffleMessage")
[17:42:19.188]                       }
[17:42:19.188]                       else if (inherits(cond, "warning")) {
[17:42:19.188]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.188]                         if (muffled) 
[17:42:19.188]                           invokeRestart("muffleWarning")
[17:42:19.188]                       }
[17:42:19.188]                       else if (inherits(cond, "condition")) {
[17:42:19.188]                         if (!is.null(pattern)) {
[17:42:19.188]                           computeRestarts <- base::computeRestarts
[17:42:19.188]                           grepl <- base::grepl
[17:42:19.188]                           restarts <- computeRestarts(cond)
[17:42:19.188]                           for (restart in restarts) {
[17:42:19.188]                             name <- restart$name
[17:42:19.188]                             if (is.null(name)) 
[17:42:19.188]                               next
[17:42:19.188]                             if (!grepl(pattern, name)) 
[17:42:19.188]                               next
[17:42:19.188]                             invokeRestart(restart)
[17:42:19.188]                             muffled <- TRUE
[17:42:19.188]                             break
[17:42:19.188]                           }
[17:42:19.188]                         }
[17:42:19.188]                       }
[17:42:19.188]                       invisible(muffled)
[17:42:19.188]                     }
[17:42:19.188]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.188]                   }
[17:42:19.188]                 }
[17:42:19.188]             }
[17:42:19.188]         }))
[17:42:19.188]     }, error = function(ex) {
[17:42:19.188]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.188]                 ...future.rng), started = ...future.startTime, 
[17:42:19.188]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.188]             version = "1.8"), class = "FutureResult")
[17:42:19.188]     }, finally = {
[17:42:19.188]         if (!identical(...future.workdir, getwd())) 
[17:42:19.188]             setwd(...future.workdir)
[17:42:19.188]         {
[17:42:19.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.188]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.188]             }
[17:42:19.188]             base::options(...future.oldOptions)
[17:42:19.188]             if (.Platform$OS.type == "windows") {
[17:42:19.188]                 old_names <- names(...future.oldEnvVars)
[17:42:19.188]                 envs <- base::Sys.getenv()
[17:42:19.188]                 names <- names(envs)
[17:42:19.188]                 common <- intersect(names, old_names)
[17:42:19.188]                 added <- setdiff(names, old_names)
[17:42:19.188]                 removed <- setdiff(old_names, names)
[17:42:19.188]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.188]                   envs[common]]
[17:42:19.188]                 NAMES <- toupper(changed)
[17:42:19.188]                 args <- list()
[17:42:19.188]                 for (kk in seq_along(NAMES)) {
[17:42:19.188]                   name <- changed[[kk]]
[17:42:19.188]                   NAME <- NAMES[[kk]]
[17:42:19.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.188]                     next
[17:42:19.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.188]                 }
[17:42:19.188]                 NAMES <- toupper(added)
[17:42:19.188]                 for (kk in seq_along(NAMES)) {
[17:42:19.188]                   name <- added[[kk]]
[17:42:19.188]                   NAME <- NAMES[[kk]]
[17:42:19.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.188]                     next
[17:42:19.188]                   args[[name]] <- ""
[17:42:19.188]                 }
[17:42:19.188]                 NAMES <- toupper(removed)
[17:42:19.188]                 for (kk in seq_along(NAMES)) {
[17:42:19.188]                   name <- removed[[kk]]
[17:42:19.188]                   NAME <- NAMES[[kk]]
[17:42:19.188]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.188]                     next
[17:42:19.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.188]                 }
[17:42:19.188]                 if (length(args) > 0) 
[17:42:19.188]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.188]             }
[17:42:19.188]             else {
[17:42:19.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.188]             }
[17:42:19.188]             {
[17:42:19.188]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.188]                   0L) {
[17:42:19.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.188]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.188]                   base::options(opts)
[17:42:19.188]                 }
[17:42:19.188]                 {
[17:42:19.188]                   {
[17:42:19.188]                     NULL
[17:42:19.188]                     RNGkind("Mersenne-Twister")
[17:42:19.188]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.188]                       inherits = FALSE)
[17:42:19.188]                   }
[17:42:19.188]                   options(future.plan = NULL)
[17:42:19.188]                   if (is.na(NA_character_)) 
[17:42:19.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.188]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.188]                   {
[17:42:19.188]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.188]                     if (!future$lazy) 
[17:42:19.188]                       future <- run(future)
[17:42:19.188]                     invisible(future)
[17:42:19.188]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.188]                 }
[17:42:19.188]             }
[17:42:19.188]         }
[17:42:19.188]     })
[17:42:19.188]     if (TRUE) {
[17:42:19.188]         base::sink(type = "output", split = FALSE)
[17:42:19.188]         if (TRUE) {
[17:42:19.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.188]         }
[17:42:19.188]         else {
[17:42:19.188]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.188]         }
[17:42:19.188]         base::close(...future.stdout)
[17:42:19.188]         ...future.stdout <- NULL
[17:42:19.188]     }
[17:42:19.188]     ...future.result$conditions <- ...future.conditions
[17:42:19.188]     ...future.result$finished <- base::Sys.time()
[17:42:19.188]     ...future.result
[17:42:19.188] }
[17:42:19.190] plan(): Setting new future strategy stack:
[17:42:19.190] List of future strategies:
[17:42:19.190] 1. sequential:
[17:42:19.190]    - args: function (..., envir = parent.frame())
[17:42:19.190]    - tweaked: FALSE
[17:42:19.190]    - call: NULL
[17:42:19.190] plan(): nbrOfWorkers() = 1
[17:42:19.191] plan(): Setting new future strategy stack:
[17:42:19.191] List of future strategies:
[17:42:19.191] 1. sequential:
[17:42:19.191]    - args: function (..., envir = parent.frame())
[17:42:19.191]    - tweaked: FALSE
[17:42:19.191]    - call: plan(strategy)
[17:42:19.191] plan(): nbrOfWorkers() = 1
[17:42:19.191] SequentialFuture started (and completed)
[17:42:19.192] - Launch lazy future ... done
[17:42:19.192] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef7b43c30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef81679f0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef7b43c30> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef81679f0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:19.199] resolved() for ‘SequentialFuture’ ...
[17:42:19.199] - state: ‘finished’
[17:42:19.199] - run: TRUE
[17:42:19.199] - result: ‘FutureResult’
[17:42:19.199] resolved() for ‘SequentialFuture’ ... done
[17:42:19.199] resolved() for ‘SequentialFuture’ ...
[17:42:19.199] - state: ‘finished’
[17:42:19.199] - run: TRUE
[17:42:19.199] - result: ‘FutureResult’
[17:42:19.200] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.201] resolve() on list ...
[17:42:19.201]  recursive: 0
[17:42:19.202]  length: 6
[17:42:19.202]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.202] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.202] - nx: 6
[17:42:19.202] - relay: TRUE
[17:42:19.202] - stdout: TRUE
[17:42:19.202] - signal: TRUE
[17:42:19.202] - resignal: FALSE
[17:42:19.202] - force: TRUE
[17:42:19.202] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.202] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.202]  - until=2
[17:42:19.203]  - relaying element #2
[17:42:19.203] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.203] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.203] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.203]  length: 5 (resolved future 1)
[17:42:19.203] resolved() for ‘SequentialFuture’ ...
[17:42:19.203] - state: ‘finished’
[17:42:19.203] - run: TRUE
[17:42:19.203] - result: ‘FutureResult’
[17:42:19.203] resolved() for ‘SequentialFuture’ ... done
[17:42:19.204] Future #2
[17:42:19.204] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.204] - nx: 6
[17:42:19.204] - relay: TRUE
[17:42:19.204] - stdout: TRUE
[17:42:19.204] - signal: TRUE
[17:42:19.204] - resignal: FALSE
[17:42:19.204] - force: TRUE
[17:42:19.204] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.204] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.205]  - until=2
[17:42:19.205]  - relaying element #2
[17:42:19.205] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.205] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.205] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.205]  length: 4 (resolved future 2)
[17:42:19.205] resolved() for ‘SequentialFuture’ ...
[17:42:19.205] - state: ‘finished’
[17:42:19.205] - run: TRUE
[17:42:19.205] - result: ‘FutureResult’
[17:42:19.206] resolved() for ‘SequentialFuture’ ... done
[17:42:19.206] Future #3
[17:42:19.206] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.206] - nx: 6
[17:42:19.206] - relay: TRUE
[17:42:19.206] - stdout: TRUE
[17:42:19.206] - signal: TRUE
[17:42:19.206] - resignal: FALSE
[17:42:19.206] - force: TRUE
[17:42:19.206] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.207] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.207]  - until=3
[17:42:19.207]  - relaying element #3
[17:42:19.207] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.207] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.207] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.207]  length: 3 (resolved future 3)
[17:42:19.207] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.207] - nx: 6
[17:42:19.207] - relay: TRUE
[17:42:19.208] - stdout: TRUE
[17:42:19.208] - signal: TRUE
[17:42:19.208] - resignal: FALSE
[17:42:19.208] - force: TRUE
[17:42:19.208] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.208] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.208]  - until=5
[17:42:19.208]  - relaying element #5
[17:42:19.208] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.208] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.208] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.209]  length: 2 (resolved future 4)
[17:42:19.209] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.209] - nx: 6
[17:42:19.209] - relay: TRUE
[17:42:19.209] - stdout: TRUE
[17:42:19.209] - signal: TRUE
[17:42:19.209] - resignal: FALSE
[17:42:19.209] - force: TRUE
[17:42:19.209] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.209]  - until=6
[17:42:19.209]  - relaying element #6
[17:42:19.210] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.210] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.210] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.210]  length: 1 (resolved future 5)
[17:42:19.210] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.210] - nx: 6
[17:42:19.210] - relay: TRUE
[17:42:19.210] - stdout: TRUE
[17:42:19.210] - signal: TRUE
[17:42:19.210] - resignal: FALSE
[17:42:19.210] - force: TRUE
[17:42:19.210] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.211] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.211]  - until=6
[17:42:19.211] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.211] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.211] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.211]  length: 0 (resolved future 6)
[17:42:19.211] Relaying remaining futures
[17:42:19.211] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.211] - nx: 6
[17:42:19.211] - relay: TRUE
[17:42:19.211] - stdout: TRUE
[17:42:19.211] - signal: TRUE
[17:42:19.212] - resignal: FALSE
[17:42:19.212] - force: TRUE
[17:42:19.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.212] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.212] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.212] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.212] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:42:19.216] getGlobalsAndPackages() ...
[17:42:19.216] Searching for globals...
[17:42:19.216] 
[17:42:19.216] Searching for globals ... DONE
[17:42:19.216] - globals: [0] <none>
[17:42:19.216] getGlobalsAndPackages() ... DONE
[17:42:19.217] run() for ‘Future’ ...
[17:42:19.217] - state: ‘created’
[17:42:19.217] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.217]   - Field: ‘label’
[17:42:19.218]   - Field: ‘local’
[17:42:19.218]   - Field: ‘owner’
[17:42:19.218]   - Field: ‘envir’
[17:42:19.218]   - Field: ‘packages’
[17:42:19.218]   - Field: ‘gc’
[17:42:19.218]   - Field: ‘conditions’
[17:42:19.218]   - Field: ‘expr’
[17:42:19.218]   - Field: ‘uuid’
[17:42:19.218]   - Field: ‘seed’
[17:42:19.218]   - Field: ‘version’
[17:42:19.218]   - Field: ‘result’
[17:42:19.219]   - Field: ‘asynchronous’
[17:42:19.219]   - Field: ‘calls’
[17:42:19.219]   - Field: ‘globals’
[17:42:19.219]   - Field: ‘stdout’
[17:42:19.219]   - Field: ‘earlySignal’
[17:42:19.219]   - Field: ‘lazy’
[17:42:19.219]   - Field: ‘state’
[17:42:19.219] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.219] - Launch lazy future ...
[17:42:19.220] Packages needed by the future expression (n = 0): <none>
[17:42:19.220] Packages needed by future strategies (n = 0): <none>
[17:42:19.220] {
[17:42:19.220]     {
[17:42:19.220]         {
[17:42:19.220]             ...future.startTime <- base::Sys.time()
[17:42:19.220]             {
[17:42:19.220]                 {
[17:42:19.220]                   {
[17:42:19.220]                     base::local({
[17:42:19.220]                       has_future <- base::requireNamespace("future", 
[17:42:19.220]                         quietly = TRUE)
[17:42:19.220]                       if (has_future) {
[17:42:19.220]                         ns <- base::getNamespace("future")
[17:42:19.220]                         version <- ns[[".package"]][["version"]]
[17:42:19.220]                         if (is.null(version)) 
[17:42:19.220]                           version <- utils::packageVersion("future")
[17:42:19.220]                       }
[17:42:19.220]                       else {
[17:42:19.220]                         version <- NULL
[17:42:19.220]                       }
[17:42:19.220]                       if (!has_future || version < "1.8.0") {
[17:42:19.220]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.220]                           "", base::R.version$version.string), 
[17:42:19.220]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.220]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.220]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.220]                             "release", "version")], collapse = " "), 
[17:42:19.220]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.220]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.220]                           info)
[17:42:19.220]                         info <- base::paste(info, collapse = "; ")
[17:42:19.220]                         if (!has_future) {
[17:42:19.220]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.220]                             info)
[17:42:19.220]                         }
[17:42:19.220]                         else {
[17:42:19.220]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.220]                             info, version)
[17:42:19.220]                         }
[17:42:19.220]                         base::stop(msg)
[17:42:19.220]                       }
[17:42:19.220]                     })
[17:42:19.220]                   }
[17:42:19.220]                   options(future.plan = NULL)
[17:42:19.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.220]                 }
[17:42:19.220]                 ...future.workdir <- getwd()
[17:42:19.220]             }
[17:42:19.220]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.220]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.220]         }
[17:42:19.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.220]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.220]             base::names(...future.oldOptions))
[17:42:19.220]     }
[17:42:19.220]     if (FALSE) {
[17:42:19.220]     }
[17:42:19.220]     else {
[17:42:19.220]         if (TRUE) {
[17:42:19.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.220]                 open = "w")
[17:42:19.220]         }
[17:42:19.220]         else {
[17:42:19.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.220]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.220]         }
[17:42:19.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.220]             base::sink(type = "output", split = FALSE)
[17:42:19.220]             base::close(...future.stdout)
[17:42:19.220]         }, add = TRUE)
[17:42:19.220]     }
[17:42:19.220]     ...future.frame <- base::sys.nframe()
[17:42:19.220]     ...future.conditions <- base::list()
[17:42:19.220]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.220]     if (FALSE) {
[17:42:19.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.220]     }
[17:42:19.220]     ...future.result <- base::tryCatch({
[17:42:19.220]         base::withCallingHandlers({
[17:42:19.220]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.220]             future::FutureResult(value = ...future.value$value, 
[17:42:19.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.220]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.220]                     ...future.globalenv.names))
[17:42:19.220]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.220]         }, condition = base::local({
[17:42:19.220]             c <- base::c
[17:42:19.220]             inherits <- base::inherits
[17:42:19.220]             invokeRestart <- base::invokeRestart
[17:42:19.220]             length <- base::length
[17:42:19.220]             list <- base::list
[17:42:19.220]             seq.int <- base::seq.int
[17:42:19.220]             signalCondition <- base::signalCondition
[17:42:19.220]             sys.calls <- base::sys.calls
[17:42:19.220]             `[[` <- base::`[[`
[17:42:19.220]             `+` <- base::`+`
[17:42:19.220]             `<<-` <- base::`<<-`
[17:42:19.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.220]                   3L)]
[17:42:19.220]             }
[17:42:19.220]             function(cond) {
[17:42:19.220]                 is_error <- inherits(cond, "error")
[17:42:19.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.220]                   NULL)
[17:42:19.220]                 if (is_error) {
[17:42:19.220]                   sessionInformation <- function() {
[17:42:19.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.220]                       search = base::search(), system = base::Sys.info())
[17:42:19.220]                   }
[17:42:19.220]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.220]                     cond$call), session = sessionInformation(), 
[17:42:19.220]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.220]                   signalCondition(cond)
[17:42:19.220]                 }
[17:42:19.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.220]                 "immediateCondition"))) {
[17:42:19.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.220]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.220]                   if (TRUE && !signal) {
[17:42:19.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.220]                     {
[17:42:19.220]                       inherits <- base::inherits
[17:42:19.220]                       invokeRestart <- base::invokeRestart
[17:42:19.220]                       is.null <- base::is.null
[17:42:19.220]                       muffled <- FALSE
[17:42:19.220]                       if (inherits(cond, "message")) {
[17:42:19.220]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.220]                         if (muffled) 
[17:42:19.220]                           invokeRestart("muffleMessage")
[17:42:19.220]                       }
[17:42:19.220]                       else if (inherits(cond, "warning")) {
[17:42:19.220]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.220]                         if (muffled) 
[17:42:19.220]                           invokeRestart("muffleWarning")
[17:42:19.220]                       }
[17:42:19.220]                       else if (inherits(cond, "condition")) {
[17:42:19.220]                         if (!is.null(pattern)) {
[17:42:19.220]                           computeRestarts <- base::computeRestarts
[17:42:19.220]                           grepl <- base::grepl
[17:42:19.220]                           restarts <- computeRestarts(cond)
[17:42:19.220]                           for (restart in restarts) {
[17:42:19.220]                             name <- restart$name
[17:42:19.220]                             if (is.null(name)) 
[17:42:19.220]                               next
[17:42:19.220]                             if (!grepl(pattern, name)) 
[17:42:19.220]                               next
[17:42:19.220]                             invokeRestart(restart)
[17:42:19.220]                             muffled <- TRUE
[17:42:19.220]                             break
[17:42:19.220]                           }
[17:42:19.220]                         }
[17:42:19.220]                       }
[17:42:19.220]                       invisible(muffled)
[17:42:19.220]                     }
[17:42:19.220]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.220]                   }
[17:42:19.220]                 }
[17:42:19.220]                 else {
[17:42:19.220]                   if (TRUE) {
[17:42:19.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.220]                     {
[17:42:19.220]                       inherits <- base::inherits
[17:42:19.220]                       invokeRestart <- base::invokeRestart
[17:42:19.220]                       is.null <- base::is.null
[17:42:19.220]                       muffled <- FALSE
[17:42:19.220]                       if (inherits(cond, "message")) {
[17:42:19.220]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.220]                         if (muffled) 
[17:42:19.220]                           invokeRestart("muffleMessage")
[17:42:19.220]                       }
[17:42:19.220]                       else if (inherits(cond, "warning")) {
[17:42:19.220]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.220]                         if (muffled) 
[17:42:19.220]                           invokeRestart("muffleWarning")
[17:42:19.220]                       }
[17:42:19.220]                       else if (inherits(cond, "condition")) {
[17:42:19.220]                         if (!is.null(pattern)) {
[17:42:19.220]                           computeRestarts <- base::computeRestarts
[17:42:19.220]                           grepl <- base::grepl
[17:42:19.220]                           restarts <- computeRestarts(cond)
[17:42:19.220]                           for (restart in restarts) {
[17:42:19.220]                             name <- restart$name
[17:42:19.220]                             if (is.null(name)) 
[17:42:19.220]                               next
[17:42:19.220]                             if (!grepl(pattern, name)) 
[17:42:19.220]                               next
[17:42:19.220]                             invokeRestart(restart)
[17:42:19.220]                             muffled <- TRUE
[17:42:19.220]                             break
[17:42:19.220]                           }
[17:42:19.220]                         }
[17:42:19.220]                       }
[17:42:19.220]                       invisible(muffled)
[17:42:19.220]                     }
[17:42:19.220]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.220]                   }
[17:42:19.220]                 }
[17:42:19.220]             }
[17:42:19.220]         }))
[17:42:19.220]     }, error = function(ex) {
[17:42:19.220]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.220]                 ...future.rng), started = ...future.startTime, 
[17:42:19.220]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.220]             version = "1.8"), class = "FutureResult")
[17:42:19.220]     }, finally = {
[17:42:19.220]         if (!identical(...future.workdir, getwd())) 
[17:42:19.220]             setwd(...future.workdir)
[17:42:19.220]         {
[17:42:19.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.220]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.220]             }
[17:42:19.220]             base::options(...future.oldOptions)
[17:42:19.220]             if (.Platform$OS.type == "windows") {
[17:42:19.220]                 old_names <- names(...future.oldEnvVars)
[17:42:19.220]                 envs <- base::Sys.getenv()
[17:42:19.220]                 names <- names(envs)
[17:42:19.220]                 common <- intersect(names, old_names)
[17:42:19.220]                 added <- setdiff(names, old_names)
[17:42:19.220]                 removed <- setdiff(old_names, names)
[17:42:19.220]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.220]                   envs[common]]
[17:42:19.220]                 NAMES <- toupper(changed)
[17:42:19.220]                 args <- list()
[17:42:19.220]                 for (kk in seq_along(NAMES)) {
[17:42:19.220]                   name <- changed[[kk]]
[17:42:19.220]                   NAME <- NAMES[[kk]]
[17:42:19.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.220]                     next
[17:42:19.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.220]                 }
[17:42:19.220]                 NAMES <- toupper(added)
[17:42:19.220]                 for (kk in seq_along(NAMES)) {
[17:42:19.220]                   name <- added[[kk]]
[17:42:19.220]                   NAME <- NAMES[[kk]]
[17:42:19.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.220]                     next
[17:42:19.220]                   args[[name]] <- ""
[17:42:19.220]                 }
[17:42:19.220]                 NAMES <- toupper(removed)
[17:42:19.220]                 for (kk in seq_along(NAMES)) {
[17:42:19.220]                   name <- removed[[kk]]
[17:42:19.220]                   NAME <- NAMES[[kk]]
[17:42:19.220]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.220]                     next
[17:42:19.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.220]                 }
[17:42:19.220]                 if (length(args) > 0) 
[17:42:19.220]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.220]             }
[17:42:19.220]             else {
[17:42:19.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.220]             }
[17:42:19.220]             {
[17:42:19.220]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.220]                   0L) {
[17:42:19.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.220]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.220]                   base::options(opts)
[17:42:19.220]                 }
[17:42:19.220]                 {
[17:42:19.220]                   {
[17:42:19.220]                     NULL
[17:42:19.220]                     RNGkind("Mersenne-Twister")
[17:42:19.220]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.220]                       inherits = FALSE)
[17:42:19.220]                   }
[17:42:19.220]                   options(future.plan = NULL)
[17:42:19.220]                   if (is.na(NA_character_)) 
[17:42:19.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.220]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.220]                   {
[17:42:19.220]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.220]                     if (!future$lazy) 
[17:42:19.220]                       future <- run(future)
[17:42:19.220]                     invisible(future)
[17:42:19.220]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.220]                 }
[17:42:19.220]             }
[17:42:19.220]         }
[17:42:19.220]     })
[17:42:19.220]     if (TRUE) {
[17:42:19.220]         base::sink(type = "output", split = FALSE)
[17:42:19.220]         if (TRUE) {
[17:42:19.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.220]         }
[17:42:19.220]         else {
[17:42:19.220]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.220]         }
[17:42:19.220]         base::close(...future.stdout)
[17:42:19.220]         ...future.stdout <- NULL
[17:42:19.220]     }
[17:42:19.220]     ...future.result$conditions <- ...future.conditions
[17:42:19.220]     ...future.result$finished <- base::Sys.time()
[17:42:19.220]     ...future.result
[17:42:19.220] }
[17:42:19.224] plan(): Setting new future strategy stack:
[17:42:19.224] List of future strategies:
[17:42:19.224] 1. sequential:
[17:42:19.224]    - args: function (..., envir = parent.frame())
[17:42:19.224]    - tweaked: FALSE
[17:42:19.224]    - call: NULL
[17:42:19.224] plan(): nbrOfWorkers() = 1
[17:42:19.225] plan(): Setting new future strategy stack:
[17:42:19.225] List of future strategies:
[17:42:19.225] 1. sequential:
[17:42:19.225]    - args: function (..., envir = parent.frame())
[17:42:19.225]    - tweaked: FALSE
[17:42:19.225]    - call: plan(strategy)
[17:42:19.226] plan(): nbrOfWorkers() = 1
[17:42:19.226] SequentialFuture started (and completed)
[17:42:19.226] - Launch lazy future ... done
[17:42:19.226] run() for ‘SequentialFuture’ ... done
[17:42:19.226] getGlobalsAndPackages() ...
[17:42:19.226] Searching for globals...
[17:42:19.227] 
[17:42:19.227] Searching for globals ... DONE
[17:42:19.227] - globals: [0] <none>
[17:42:19.227] getGlobalsAndPackages() ... DONE
[17:42:19.227] run() for ‘Future’ ...
[17:42:19.227] - state: ‘created’
[17:42:19.227] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.228] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.228] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.228]   - Field: ‘label’
[17:42:19.228]   - Field: ‘local’
[17:42:19.228]   - Field: ‘owner’
[17:42:19.228]   - Field: ‘envir’
[17:42:19.228]   - Field: ‘packages’
[17:42:19.228]   - Field: ‘gc’
[17:42:19.228]   - Field: ‘conditions’
[17:42:19.228]   - Field: ‘expr’
[17:42:19.229]   - Field: ‘uuid’
[17:42:19.229]   - Field: ‘seed’
[17:42:19.229]   - Field: ‘version’
[17:42:19.229]   - Field: ‘result’
[17:42:19.229]   - Field: ‘asynchronous’
[17:42:19.229]   - Field: ‘calls’
[17:42:19.229]   - Field: ‘globals’
[17:42:19.229]   - Field: ‘stdout’
[17:42:19.229]   - Field: ‘earlySignal’
[17:42:19.229]   - Field: ‘lazy’
[17:42:19.229]   - Field: ‘state’
[17:42:19.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.230] - Launch lazy future ...
[17:42:19.230] Packages needed by the future expression (n = 0): <none>
[17:42:19.230] Packages needed by future strategies (n = 0): <none>
[17:42:19.230] {
[17:42:19.230]     {
[17:42:19.230]         {
[17:42:19.230]             ...future.startTime <- base::Sys.time()
[17:42:19.230]             {
[17:42:19.230]                 {
[17:42:19.230]                   {
[17:42:19.230]                     base::local({
[17:42:19.230]                       has_future <- base::requireNamespace("future", 
[17:42:19.230]                         quietly = TRUE)
[17:42:19.230]                       if (has_future) {
[17:42:19.230]                         ns <- base::getNamespace("future")
[17:42:19.230]                         version <- ns[[".package"]][["version"]]
[17:42:19.230]                         if (is.null(version)) 
[17:42:19.230]                           version <- utils::packageVersion("future")
[17:42:19.230]                       }
[17:42:19.230]                       else {
[17:42:19.230]                         version <- NULL
[17:42:19.230]                       }
[17:42:19.230]                       if (!has_future || version < "1.8.0") {
[17:42:19.230]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.230]                           "", base::R.version$version.string), 
[17:42:19.230]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.230]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.230]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.230]                             "release", "version")], collapse = " "), 
[17:42:19.230]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.230]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.230]                           info)
[17:42:19.230]                         info <- base::paste(info, collapse = "; ")
[17:42:19.230]                         if (!has_future) {
[17:42:19.230]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.230]                             info)
[17:42:19.230]                         }
[17:42:19.230]                         else {
[17:42:19.230]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.230]                             info, version)
[17:42:19.230]                         }
[17:42:19.230]                         base::stop(msg)
[17:42:19.230]                       }
[17:42:19.230]                     })
[17:42:19.230]                   }
[17:42:19.230]                   options(future.plan = NULL)
[17:42:19.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.230]                 }
[17:42:19.230]                 ...future.workdir <- getwd()
[17:42:19.230]             }
[17:42:19.230]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.230]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.230]         }
[17:42:19.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.230]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.230]             base::names(...future.oldOptions))
[17:42:19.230]     }
[17:42:19.230]     if (FALSE) {
[17:42:19.230]     }
[17:42:19.230]     else {
[17:42:19.230]         if (TRUE) {
[17:42:19.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.230]                 open = "w")
[17:42:19.230]         }
[17:42:19.230]         else {
[17:42:19.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.230]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.230]         }
[17:42:19.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.230]             base::sink(type = "output", split = FALSE)
[17:42:19.230]             base::close(...future.stdout)
[17:42:19.230]         }, add = TRUE)
[17:42:19.230]     }
[17:42:19.230]     ...future.frame <- base::sys.nframe()
[17:42:19.230]     ...future.conditions <- base::list()
[17:42:19.230]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.230]     if (FALSE) {
[17:42:19.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.230]     }
[17:42:19.230]     ...future.result <- base::tryCatch({
[17:42:19.230]         base::withCallingHandlers({
[17:42:19.230]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.230]             future::FutureResult(value = ...future.value$value, 
[17:42:19.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.230]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.230]                     ...future.globalenv.names))
[17:42:19.230]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.230]         }, condition = base::local({
[17:42:19.230]             c <- base::c
[17:42:19.230]             inherits <- base::inherits
[17:42:19.230]             invokeRestart <- base::invokeRestart
[17:42:19.230]             length <- base::length
[17:42:19.230]             list <- base::list
[17:42:19.230]             seq.int <- base::seq.int
[17:42:19.230]             signalCondition <- base::signalCondition
[17:42:19.230]             sys.calls <- base::sys.calls
[17:42:19.230]             `[[` <- base::`[[`
[17:42:19.230]             `+` <- base::`+`
[17:42:19.230]             `<<-` <- base::`<<-`
[17:42:19.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.230]                   3L)]
[17:42:19.230]             }
[17:42:19.230]             function(cond) {
[17:42:19.230]                 is_error <- inherits(cond, "error")
[17:42:19.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.230]                   NULL)
[17:42:19.230]                 if (is_error) {
[17:42:19.230]                   sessionInformation <- function() {
[17:42:19.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.230]                       search = base::search(), system = base::Sys.info())
[17:42:19.230]                   }
[17:42:19.230]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.230]                     cond$call), session = sessionInformation(), 
[17:42:19.230]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.230]                   signalCondition(cond)
[17:42:19.230]                 }
[17:42:19.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.230]                 "immediateCondition"))) {
[17:42:19.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.230]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.230]                   if (TRUE && !signal) {
[17:42:19.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.230]                     {
[17:42:19.230]                       inherits <- base::inherits
[17:42:19.230]                       invokeRestart <- base::invokeRestart
[17:42:19.230]                       is.null <- base::is.null
[17:42:19.230]                       muffled <- FALSE
[17:42:19.230]                       if (inherits(cond, "message")) {
[17:42:19.230]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.230]                         if (muffled) 
[17:42:19.230]                           invokeRestart("muffleMessage")
[17:42:19.230]                       }
[17:42:19.230]                       else if (inherits(cond, "warning")) {
[17:42:19.230]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.230]                         if (muffled) 
[17:42:19.230]                           invokeRestart("muffleWarning")
[17:42:19.230]                       }
[17:42:19.230]                       else if (inherits(cond, "condition")) {
[17:42:19.230]                         if (!is.null(pattern)) {
[17:42:19.230]                           computeRestarts <- base::computeRestarts
[17:42:19.230]                           grepl <- base::grepl
[17:42:19.230]                           restarts <- computeRestarts(cond)
[17:42:19.230]                           for (restart in restarts) {
[17:42:19.230]                             name <- restart$name
[17:42:19.230]                             if (is.null(name)) 
[17:42:19.230]                               next
[17:42:19.230]                             if (!grepl(pattern, name)) 
[17:42:19.230]                               next
[17:42:19.230]                             invokeRestart(restart)
[17:42:19.230]                             muffled <- TRUE
[17:42:19.230]                             break
[17:42:19.230]                           }
[17:42:19.230]                         }
[17:42:19.230]                       }
[17:42:19.230]                       invisible(muffled)
[17:42:19.230]                     }
[17:42:19.230]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.230]                   }
[17:42:19.230]                 }
[17:42:19.230]                 else {
[17:42:19.230]                   if (TRUE) {
[17:42:19.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.230]                     {
[17:42:19.230]                       inherits <- base::inherits
[17:42:19.230]                       invokeRestart <- base::invokeRestart
[17:42:19.230]                       is.null <- base::is.null
[17:42:19.230]                       muffled <- FALSE
[17:42:19.230]                       if (inherits(cond, "message")) {
[17:42:19.230]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.230]                         if (muffled) 
[17:42:19.230]                           invokeRestart("muffleMessage")
[17:42:19.230]                       }
[17:42:19.230]                       else if (inherits(cond, "warning")) {
[17:42:19.230]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.230]                         if (muffled) 
[17:42:19.230]                           invokeRestart("muffleWarning")
[17:42:19.230]                       }
[17:42:19.230]                       else if (inherits(cond, "condition")) {
[17:42:19.230]                         if (!is.null(pattern)) {
[17:42:19.230]                           computeRestarts <- base::computeRestarts
[17:42:19.230]                           grepl <- base::grepl
[17:42:19.230]                           restarts <- computeRestarts(cond)
[17:42:19.230]                           for (restart in restarts) {
[17:42:19.230]                             name <- restart$name
[17:42:19.230]                             if (is.null(name)) 
[17:42:19.230]                               next
[17:42:19.230]                             if (!grepl(pattern, name)) 
[17:42:19.230]                               next
[17:42:19.230]                             invokeRestart(restart)
[17:42:19.230]                             muffled <- TRUE
[17:42:19.230]                             break
[17:42:19.230]                           }
[17:42:19.230]                         }
[17:42:19.230]                       }
[17:42:19.230]                       invisible(muffled)
[17:42:19.230]                     }
[17:42:19.230]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.230]                   }
[17:42:19.230]                 }
[17:42:19.230]             }
[17:42:19.230]         }))
[17:42:19.230]     }, error = function(ex) {
[17:42:19.230]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.230]                 ...future.rng), started = ...future.startTime, 
[17:42:19.230]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.230]             version = "1.8"), class = "FutureResult")
[17:42:19.230]     }, finally = {
[17:42:19.230]         if (!identical(...future.workdir, getwd())) 
[17:42:19.230]             setwd(...future.workdir)
[17:42:19.230]         {
[17:42:19.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.230]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.230]             }
[17:42:19.230]             base::options(...future.oldOptions)
[17:42:19.230]             if (.Platform$OS.type == "windows") {
[17:42:19.230]                 old_names <- names(...future.oldEnvVars)
[17:42:19.230]                 envs <- base::Sys.getenv()
[17:42:19.230]                 names <- names(envs)
[17:42:19.230]                 common <- intersect(names, old_names)
[17:42:19.230]                 added <- setdiff(names, old_names)
[17:42:19.230]                 removed <- setdiff(old_names, names)
[17:42:19.230]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.230]                   envs[common]]
[17:42:19.230]                 NAMES <- toupper(changed)
[17:42:19.230]                 args <- list()
[17:42:19.230]                 for (kk in seq_along(NAMES)) {
[17:42:19.230]                   name <- changed[[kk]]
[17:42:19.230]                   NAME <- NAMES[[kk]]
[17:42:19.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.230]                     next
[17:42:19.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.230]                 }
[17:42:19.230]                 NAMES <- toupper(added)
[17:42:19.230]                 for (kk in seq_along(NAMES)) {
[17:42:19.230]                   name <- added[[kk]]
[17:42:19.230]                   NAME <- NAMES[[kk]]
[17:42:19.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.230]                     next
[17:42:19.230]                   args[[name]] <- ""
[17:42:19.230]                 }
[17:42:19.230]                 NAMES <- toupper(removed)
[17:42:19.230]                 for (kk in seq_along(NAMES)) {
[17:42:19.230]                   name <- removed[[kk]]
[17:42:19.230]                   NAME <- NAMES[[kk]]
[17:42:19.230]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.230]                     next
[17:42:19.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.230]                 }
[17:42:19.230]                 if (length(args) > 0) 
[17:42:19.230]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.230]             }
[17:42:19.230]             else {
[17:42:19.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.230]             }
[17:42:19.230]             {
[17:42:19.230]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.230]                   0L) {
[17:42:19.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.230]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.230]                   base::options(opts)
[17:42:19.230]                 }
[17:42:19.230]                 {
[17:42:19.230]                   {
[17:42:19.230]                     NULL
[17:42:19.230]                     RNGkind("Mersenne-Twister")
[17:42:19.230]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.230]                       inherits = FALSE)
[17:42:19.230]                   }
[17:42:19.230]                   options(future.plan = NULL)
[17:42:19.230]                   if (is.na(NA_character_)) 
[17:42:19.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.230]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.230]                   {
[17:42:19.230]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.230]                     if (!future$lazy) 
[17:42:19.230]                       future <- run(future)
[17:42:19.230]                     invisible(future)
[17:42:19.230]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.230]                 }
[17:42:19.230]             }
[17:42:19.230]         }
[17:42:19.230]     })
[17:42:19.230]     if (TRUE) {
[17:42:19.230]         base::sink(type = "output", split = FALSE)
[17:42:19.230]         if (TRUE) {
[17:42:19.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.230]         }
[17:42:19.230]         else {
[17:42:19.230]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.230]         }
[17:42:19.230]         base::close(...future.stdout)
[17:42:19.230]         ...future.stdout <- NULL
[17:42:19.230]     }
[17:42:19.230]     ...future.result$conditions <- ...future.conditions
[17:42:19.230]     ...future.result$finished <- base::Sys.time()
[17:42:19.230]     ...future.result
[17:42:19.230] }
[17:42:19.232] plan(): Setting new future strategy stack:
[17:42:19.232] List of future strategies:
[17:42:19.232] 1. sequential:
[17:42:19.232]    - args: function (..., envir = parent.frame())
[17:42:19.232]    - tweaked: FALSE
[17:42:19.232]    - call: NULL
[17:42:19.233] plan(): nbrOfWorkers() = 1
[17:42:19.233] plan(): Setting new future strategy stack:
[17:42:19.233] List of future strategies:
[17:42:19.233] 1. sequential:
[17:42:19.233]    - args: function (..., envir = parent.frame())
[17:42:19.233]    - tweaked: FALSE
[17:42:19.233]    - call: plan(strategy)
[17:42:19.234] plan(): nbrOfWorkers() = 1
[17:42:19.234] SequentialFuture started (and completed)
[17:42:19.234] - Launch lazy future ... done
[17:42:19.234] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef83e3320> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef6ac41f0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef83e3320> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55bef6ac41f0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:19.240] resolved() for ‘SequentialFuture’ ...
[17:42:19.240] - state: ‘finished’
[17:42:19.240] - run: TRUE
[17:42:19.240] - result: ‘FutureResult’
[17:42:19.240] resolved() for ‘SequentialFuture’ ... done
[17:42:19.240] resolved() for ‘SequentialFuture’ ...
[17:42:19.241] - state: ‘finished’
[17:42:19.241] - run: TRUE
[17:42:19.241] - result: ‘FutureResult’
[17:42:19.241] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.243] resolve() on list ...
[17:42:19.243]  recursive: 0
[17:42:19.243]  length: 6
[17:42:19.243]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.243] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.243] - nx: 6
[17:42:19.243] - relay: TRUE
[17:42:19.244] - stdout: TRUE
[17:42:19.244] - signal: TRUE
[17:42:19.244] - resignal: FALSE
[17:42:19.244] - force: TRUE
[17:42:19.244] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.244] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.244]  - until=2
[17:42:19.244]  - relaying element #2
[17:42:19.244] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.244] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.244] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.244]  length: 5 (resolved future 1)
[17:42:19.245] resolved() for ‘SequentialFuture’ ...
[17:42:19.245] - state: ‘finished’
[17:42:19.245] - run: TRUE
[17:42:19.245] - result: ‘FutureResult’
[17:42:19.245] resolved() for ‘SequentialFuture’ ... done
[17:42:19.245] Future #2
[17:42:19.245] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.245] - nx: 6
[17:42:19.245] - relay: TRUE
[17:42:19.245] - stdout: TRUE
[17:42:19.246] - signal: TRUE
[17:42:19.246] - resignal: FALSE
[17:42:19.246] - force: TRUE
[17:42:19.246] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.246] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.246]  - until=2
[17:42:19.246]  - relaying element #2
[17:42:19.246] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.246] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.246] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.247]  length: 4 (resolved future 2)
[17:42:19.247] resolved() for ‘SequentialFuture’ ...
[17:42:19.247] - state: ‘finished’
[17:42:19.247] - run: TRUE
[17:42:19.247] - result: ‘FutureResult’
[17:42:19.247] resolved() for ‘SequentialFuture’ ... done
[17:42:19.247] Future #3
[17:42:19.247] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.247] - nx: 6
[17:42:19.247] - relay: TRUE
[17:42:19.248] - stdout: TRUE
[17:42:19.248] - signal: TRUE
[17:42:19.248] - resignal: FALSE
[17:42:19.248] - force: TRUE
[17:42:19.248] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.248] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.248]  - until=3
[17:42:19.248]  - relaying element #3
[17:42:19.248] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.248] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.248] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.249]  length: 3 (resolved future 3)
[17:42:19.249] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.249] - nx: 6
[17:42:19.249] - relay: TRUE
[17:42:19.249] - stdout: TRUE
[17:42:19.249] - signal: TRUE
[17:42:19.249] - resignal: FALSE
[17:42:19.249] - force: TRUE
[17:42:19.249] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.249] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.249]  - until=5
[17:42:19.250]  - relaying element #5
[17:42:19.250] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.250] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.250] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.250]  length: 2 (resolved future 4)
[17:42:19.250] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.250] - nx: 6
[17:42:19.250] - relay: TRUE
[17:42:19.250] - stdout: TRUE
[17:42:19.250] - signal: TRUE
[17:42:19.250] - resignal: FALSE
[17:42:19.250] - force: TRUE
[17:42:19.251] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.251] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.251]  - until=6
[17:42:19.251]  - relaying element #6
[17:42:19.253] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.253] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.253] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.253]  length: 1 (resolved future 5)
[17:42:19.253] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.253] - nx: 6
[17:42:19.253] - relay: TRUE
[17:42:19.253] - stdout: TRUE
[17:42:19.254] - signal: TRUE
[17:42:19.254] - resignal: FALSE
[17:42:19.254] - force: TRUE
[17:42:19.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.254] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.254]  - until=6
[17:42:19.254] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.254] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.254] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.254]  length: 0 (resolved future 6)
[17:42:19.255] Relaying remaining futures
[17:42:19.255] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.255] - nx: 6
[17:42:19.255] - relay: TRUE
[17:42:19.255] - stdout: TRUE
[17:42:19.255] - signal: TRUE
[17:42:19.255] - resignal: FALSE
[17:42:19.255] - force: TRUE
[17:42:19.255] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.255] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.256] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.256] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.256] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.256] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[17:42:19.265] plan(): Setting new future strategy stack:
[17:42:19.266] List of future strategies:
[17:42:19.266] 1. sequential:
[17:42:19.266]    - args: function (..., envir = parent.frame())
[17:42:19.266]    - tweaked: FALSE
[17:42:19.266]    - call: plan(strategy)
[17:42:19.266] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:42:19.266] getGlobalsAndPackages() ...
[17:42:19.266] Searching for globals...
[17:42:19.267] 
[17:42:19.267] Searching for globals ... DONE
[17:42:19.267] - globals: [0] <none>
[17:42:19.267] getGlobalsAndPackages() ... DONE
[17:42:19.267] run() for ‘Future’ ...
[17:42:19.267] - state: ‘created’
[17:42:19.267] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.268] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.268]   - Field: ‘label’
[17:42:19.268]   - Field: ‘local’
[17:42:19.268]   - Field: ‘owner’
[17:42:19.268]   - Field: ‘envir’
[17:42:19.268]   - Field: ‘packages’
[17:42:19.268]   - Field: ‘gc’
[17:42:19.269]   - Field: ‘conditions’
[17:42:19.269]   - Field: ‘expr’
[17:42:19.269]   - Field: ‘uuid’
[17:42:19.269]   - Field: ‘seed’
[17:42:19.269]   - Field: ‘version’
[17:42:19.269]   - Field: ‘result’
[17:42:19.269]   - Field: ‘asynchronous’
[17:42:19.269]   - Field: ‘calls’
[17:42:19.269]   - Field: ‘globals’
[17:42:19.269]   - Field: ‘stdout’
[17:42:19.269]   - Field: ‘earlySignal’
[17:42:19.270]   - Field: ‘lazy’
[17:42:19.270]   - Field: ‘state’
[17:42:19.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.270] - Launch lazy future ...
[17:42:19.270] Packages needed by the future expression (n = 0): <none>
[17:42:19.270] Packages needed by future strategies (n = 0): <none>
[17:42:19.271] {
[17:42:19.271]     {
[17:42:19.271]         {
[17:42:19.271]             ...future.startTime <- base::Sys.time()
[17:42:19.271]             {
[17:42:19.271]                 {
[17:42:19.271]                   {
[17:42:19.271]                     base::local({
[17:42:19.271]                       has_future <- base::requireNamespace("future", 
[17:42:19.271]                         quietly = TRUE)
[17:42:19.271]                       if (has_future) {
[17:42:19.271]                         ns <- base::getNamespace("future")
[17:42:19.271]                         version <- ns[[".package"]][["version"]]
[17:42:19.271]                         if (is.null(version)) 
[17:42:19.271]                           version <- utils::packageVersion("future")
[17:42:19.271]                       }
[17:42:19.271]                       else {
[17:42:19.271]                         version <- NULL
[17:42:19.271]                       }
[17:42:19.271]                       if (!has_future || version < "1.8.0") {
[17:42:19.271]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.271]                           "", base::R.version$version.string), 
[17:42:19.271]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.271]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.271]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.271]                             "release", "version")], collapse = " "), 
[17:42:19.271]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.271]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.271]                           info)
[17:42:19.271]                         info <- base::paste(info, collapse = "; ")
[17:42:19.271]                         if (!has_future) {
[17:42:19.271]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.271]                             info)
[17:42:19.271]                         }
[17:42:19.271]                         else {
[17:42:19.271]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.271]                             info, version)
[17:42:19.271]                         }
[17:42:19.271]                         base::stop(msg)
[17:42:19.271]                       }
[17:42:19.271]                     })
[17:42:19.271]                   }
[17:42:19.271]                   options(future.plan = NULL)
[17:42:19.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.271]                 }
[17:42:19.271]                 ...future.workdir <- getwd()
[17:42:19.271]             }
[17:42:19.271]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.271]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.271]         }
[17:42:19.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.271]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.271]             base::names(...future.oldOptions))
[17:42:19.271]     }
[17:42:19.271]     if (FALSE) {
[17:42:19.271]     }
[17:42:19.271]     else {
[17:42:19.271]         if (TRUE) {
[17:42:19.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.271]                 open = "w")
[17:42:19.271]         }
[17:42:19.271]         else {
[17:42:19.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.271]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.271]         }
[17:42:19.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.271]             base::sink(type = "output", split = FALSE)
[17:42:19.271]             base::close(...future.stdout)
[17:42:19.271]         }, add = TRUE)
[17:42:19.271]     }
[17:42:19.271]     ...future.frame <- base::sys.nframe()
[17:42:19.271]     ...future.conditions <- base::list()
[17:42:19.271]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.271]     if (FALSE) {
[17:42:19.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.271]     }
[17:42:19.271]     ...future.result <- base::tryCatch({
[17:42:19.271]         base::withCallingHandlers({
[17:42:19.271]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.271]             future::FutureResult(value = ...future.value$value, 
[17:42:19.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.271]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.271]                     ...future.globalenv.names))
[17:42:19.271]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.271]         }, condition = base::local({
[17:42:19.271]             c <- base::c
[17:42:19.271]             inherits <- base::inherits
[17:42:19.271]             invokeRestart <- base::invokeRestart
[17:42:19.271]             length <- base::length
[17:42:19.271]             list <- base::list
[17:42:19.271]             seq.int <- base::seq.int
[17:42:19.271]             signalCondition <- base::signalCondition
[17:42:19.271]             sys.calls <- base::sys.calls
[17:42:19.271]             `[[` <- base::`[[`
[17:42:19.271]             `+` <- base::`+`
[17:42:19.271]             `<<-` <- base::`<<-`
[17:42:19.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.271]                   3L)]
[17:42:19.271]             }
[17:42:19.271]             function(cond) {
[17:42:19.271]                 is_error <- inherits(cond, "error")
[17:42:19.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.271]                   NULL)
[17:42:19.271]                 if (is_error) {
[17:42:19.271]                   sessionInformation <- function() {
[17:42:19.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.271]                       search = base::search(), system = base::Sys.info())
[17:42:19.271]                   }
[17:42:19.271]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.271]                     cond$call), session = sessionInformation(), 
[17:42:19.271]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.271]                   signalCondition(cond)
[17:42:19.271]                 }
[17:42:19.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.271]                 "immediateCondition"))) {
[17:42:19.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.271]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.271]                   if (TRUE && !signal) {
[17:42:19.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.271]                     {
[17:42:19.271]                       inherits <- base::inherits
[17:42:19.271]                       invokeRestart <- base::invokeRestart
[17:42:19.271]                       is.null <- base::is.null
[17:42:19.271]                       muffled <- FALSE
[17:42:19.271]                       if (inherits(cond, "message")) {
[17:42:19.271]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.271]                         if (muffled) 
[17:42:19.271]                           invokeRestart("muffleMessage")
[17:42:19.271]                       }
[17:42:19.271]                       else if (inherits(cond, "warning")) {
[17:42:19.271]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.271]                         if (muffled) 
[17:42:19.271]                           invokeRestart("muffleWarning")
[17:42:19.271]                       }
[17:42:19.271]                       else if (inherits(cond, "condition")) {
[17:42:19.271]                         if (!is.null(pattern)) {
[17:42:19.271]                           computeRestarts <- base::computeRestarts
[17:42:19.271]                           grepl <- base::grepl
[17:42:19.271]                           restarts <- computeRestarts(cond)
[17:42:19.271]                           for (restart in restarts) {
[17:42:19.271]                             name <- restart$name
[17:42:19.271]                             if (is.null(name)) 
[17:42:19.271]                               next
[17:42:19.271]                             if (!grepl(pattern, name)) 
[17:42:19.271]                               next
[17:42:19.271]                             invokeRestart(restart)
[17:42:19.271]                             muffled <- TRUE
[17:42:19.271]                             break
[17:42:19.271]                           }
[17:42:19.271]                         }
[17:42:19.271]                       }
[17:42:19.271]                       invisible(muffled)
[17:42:19.271]                     }
[17:42:19.271]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.271]                   }
[17:42:19.271]                 }
[17:42:19.271]                 else {
[17:42:19.271]                   if (TRUE) {
[17:42:19.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.271]                     {
[17:42:19.271]                       inherits <- base::inherits
[17:42:19.271]                       invokeRestart <- base::invokeRestart
[17:42:19.271]                       is.null <- base::is.null
[17:42:19.271]                       muffled <- FALSE
[17:42:19.271]                       if (inherits(cond, "message")) {
[17:42:19.271]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.271]                         if (muffled) 
[17:42:19.271]                           invokeRestart("muffleMessage")
[17:42:19.271]                       }
[17:42:19.271]                       else if (inherits(cond, "warning")) {
[17:42:19.271]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.271]                         if (muffled) 
[17:42:19.271]                           invokeRestart("muffleWarning")
[17:42:19.271]                       }
[17:42:19.271]                       else if (inherits(cond, "condition")) {
[17:42:19.271]                         if (!is.null(pattern)) {
[17:42:19.271]                           computeRestarts <- base::computeRestarts
[17:42:19.271]                           grepl <- base::grepl
[17:42:19.271]                           restarts <- computeRestarts(cond)
[17:42:19.271]                           for (restart in restarts) {
[17:42:19.271]                             name <- restart$name
[17:42:19.271]                             if (is.null(name)) 
[17:42:19.271]                               next
[17:42:19.271]                             if (!grepl(pattern, name)) 
[17:42:19.271]                               next
[17:42:19.271]                             invokeRestart(restart)
[17:42:19.271]                             muffled <- TRUE
[17:42:19.271]                             break
[17:42:19.271]                           }
[17:42:19.271]                         }
[17:42:19.271]                       }
[17:42:19.271]                       invisible(muffled)
[17:42:19.271]                     }
[17:42:19.271]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.271]                   }
[17:42:19.271]                 }
[17:42:19.271]             }
[17:42:19.271]         }))
[17:42:19.271]     }, error = function(ex) {
[17:42:19.271]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.271]                 ...future.rng), started = ...future.startTime, 
[17:42:19.271]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.271]             version = "1.8"), class = "FutureResult")
[17:42:19.271]     }, finally = {
[17:42:19.271]         if (!identical(...future.workdir, getwd())) 
[17:42:19.271]             setwd(...future.workdir)
[17:42:19.271]         {
[17:42:19.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.271]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.271]             }
[17:42:19.271]             base::options(...future.oldOptions)
[17:42:19.271]             if (.Platform$OS.type == "windows") {
[17:42:19.271]                 old_names <- names(...future.oldEnvVars)
[17:42:19.271]                 envs <- base::Sys.getenv()
[17:42:19.271]                 names <- names(envs)
[17:42:19.271]                 common <- intersect(names, old_names)
[17:42:19.271]                 added <- setdiff(names, old_names)
[17:42:19.271]                 removed <- setdiff(old_names, names)
[17:42:19.271]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.271]                   envs[common]]
[17:42:19.271]                 NAMES <- toupper(changed)
[17:42:19.271]                 args <- list()
[17:42:19.271]                 for (kk in seq_along(NAMES)) {
[17:42:19.271]                   name <- changed[[kk]]
[17:42:19.271]                   NAME <- NAMES[[kk]]
[17:42:19.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.271]                     next
[17:42:19.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.271]                 }
[17:42:19.271]                 NAMES <- toupper(added)
[17:42:19.271]                 for (kk in seq_along(NAMES)) {
[17:42:19.271]                   name <- added[[kk]]
[17:42:19.271]                   NAME <- NAMES[[kk]]
[17:42:19.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.271]                     next
[17:42:19.271]                   args[[name]] <- ""
[17:42:19.271]                 }
[17:42:19.271]                 NAMES <- toupper(removed)
[17:42:19.271]                 for (kk in seq_along(NAMES)) {
[17:42:19.271]                   name <- removed[[kk]]
[17:42:19.271]                   NAME <- NAMES[[kk]]
[17:42:19.271]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.271]                     next
[17:42:19.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.271]                 }
[17:42:19.271]                 if (length(args) > 0) 
[17:42:19.271]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.271]             }
[17:42:19.271]             else {
[17:42:19.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.271]             }
[17:42:19.271]             {
[17:42:19.271]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.271]                   0L) {
[17:42:19.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.271]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.271]                   base::options(opts)
[17:42:19.271]                 }
[17:42:19.271]                 {
[17:42:19.271]                   {
[17:42:19.271]                     NULL
[17:42:19.271]                     RNGkind("Mersenne-Twister")
[17:42:19.271]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.271]                       inherits = FALSE)
[17:42:19.271]                   }
[17:42:19.271]                   options(future.plan = NULL)
[17:42:19.271]                   if (is.na(NA_character_)) 
[17:42:19.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.271]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.271]                   {
[17:42:19.271]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.271]                     if (!future$lazy) 
[17:42:19.271]                       future <- run(future)
[17:42:19.271]                     invisible(future)
[17:42:19.271]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.271]                 }
[17:42:19.271]             }
[17:42:19.271]         }
[17:42:19.271]     })
[17:42:19.271]     if (TRUE) {
[17:42:19.271]         base::sink(type = "output", split = FALSE)
[17:42:19.271]         if (TRUE) {
[17:42:19.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.271]         }
[17:42:19.271]         else {
[17:42:19.271]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.271]         }
[17:42:19.271]         base::close(...future.stdout)
[17:42:19.271]         ...future.stdout <- NULL
[17:42:19.271]     }
[17:42:19.271]     ...future.result$conditions <- ...future.conditions
[17:42:19.271]     ...future.result$finished <- base::Sys.time()
[17:42:19.271]     ...future.result
[17:42:19.271] }
[17:42:19.273] plan(): Setting new future strategy stack:
[17:42:19.273] List of future strategies:
[17:42:19.273] 1. sequential:
[17:42:19.273]    - args: function (..., envir = parent.frame())
[17:42:19.273]    - tweaked: FALSE
[17:42:19.273]    - call: NULL
[17:42:19.273] plan(): nbrOfWorkers() = 1
[17:42:19.274] plan(): Setting new future strategy stack:
[17:42:19.274] List of future strategies:
[17:42:19.274] 1. sequential:
[17:42:19.274]    - args: function (..., envir = parent.frame())
[17:42:19.274]    - tweaked: FALSE
[17:42:19.274]    - call: plan(strategy)
[17:42:19.274] plan(): nbrOfWorkers() = 1
[17:42:19.275] SequentialFuture started (and completed)
[17:42:19.275] - Launch lazy future ... done
[17:42:19.275] run() for ‘SequentialFuture’ ... done
[17:42:19.275] getGlobalsAndPackages() ...
[17:42:19.275] Searching for globals...
[17:42:19.275] 
[17:42:19.276] Searching for globals ... DONE
[17:42:19.276] - globals: [0] <none>
[17:42:19.276] getGlobalsAndPackages() ... DONE
[17:42:19.276] run() for ‘Future’ ...
[17:42:19.276] - state: ‘created’
[17:42:19.276] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.276] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.277]   - Field: ‘label’
[17:42:19.277]   - Field: ‘local’
[17:42:19.277]   - Field: ‘owner’
[17:42:19.277]   - Field: ‘envir’
[17:42:19.277]   - Field: ‘packages’
[17:42:19.277]   - Field: ‘gc’
[17:42:19.277]   - Field: ‘conditions’
[17:42:19.277]   - Field: ‘expr’
[17:42:19.277]   - Field: ‘uuid’
[17:42:19.277]   - Field: ‘seed’
[17:42:19.278]   - Field: ‘version’
[17:42:19.278]   - Field: ‘result’
[17:42:19.278]   - Field: ‘asynchronous’
[17:42:19.278]   - Field: ‘calls’
[17:42:19.278]   - Field: ‘globals’
[17:42:19.278]   - Field: ‘stdout’
[17:42:19.278]   - Field: ‘earlySignal’
[17:42:19.278]   - Field: ‘lazy’
[17:42:19.278]   - Field: ‘state’
[17:42:19.280] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.280] - Launch lazy future ...
[17:42:19.281] Packages needed by the future expression (n = 0): <none>
[17:42:19.281] Packages needed by future strategies (n = 0): <none>
[17:42:19.281] {
[17:42:19.281]     {
[17:42:19.281]         {
[17:42:19.281]             ...future.startTime <- base::Sys.time()
[17:42:19.281]             {
[17:42:19.281]                 {
[17:42:19.281]                   {
[17:42:19.281]                     base::local({
[17:42:19.281]                       has_future <- base::requireNamespace("future", 
[17:42:19.281]                         quietly = TRUE)
[17:42:19.281]                       if (has_future) {
[17:42:19.281]                         ns <- base::getNamespace("future")
[17:42:19.281]                         version <- ns[[".package"]][["version"]]
[17:42:19.281]                         if (is.null(version)) 
[17:42:19.281]                           version <- utils::packageVersion("future")
[17:42:19.281]                       }
[17:42:19.281]                       else {
[17:42:19.281]                         version <- NULL
[17:42:19.281]                       }
[17:42:19.281]                       if (!has_future || version < "1.8.0") {
[17:42:19.281]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.281]                           "", base::R.version$version.string), 
[17:42:19.281]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.281]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.281]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.281]                             "release", "version")], collapse = " "), 
[17:42:19.281]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.281]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.281]                           info)
[17:42:19.281]                         info <- base::paste(info, collapse = "; ")
[17:42:19.281]                         if (!has_future) {
[17:42:19.281]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.281]                             info)
[17:42:19.281]                         }
[17:42:19.281]                         else {
[17:42:19.281]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.281]                             info, version)
[17:42:19.281]                         }
[17:42:19.281]                         base::stop(msg)
[17:42:19.281]                       }
[17:42:19.281]                     })
[17:42:19.281]                   }
[17:42:19.281]                   options(future.plan = NULL)
[17:42:19.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.281]                 }
[17:42:19.281]                 ...future.workdir <- getwd()
[17:42:19.281]             }
[17:42:19.281]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.281]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.281]         }
[17:42:19.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.281]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.281]             base::names(...future.oldOptions))
[17:42:19.281]     }
[17:42:19.281]     if (FALSE) {
[17:42:19.281]     }
[17:42:19.281]     else {
[17:42:19.281]         if (TRUE) {
[17:42:19.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.281]                 open = "w")
[17:42:19.281]         }
[17:42:19.281]         else {
[17:42:19.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.281]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.281]         }
[17:42:19.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.281]             base::sink(type = "output", split = FALSE)
[17:42:19.281]             base::close(...future.stdout)
[17:42:19.281]         }, add = TRUE)
[17:42:19.281]     }
[17:42:19.281]     ...future.frame <- base::sys.nframe()
[17:42:19.281]     ...future.conditions <- base::list()
[17:42:19.281]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.281]     if (FALSE) {
[17:42:19.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.281]     }
[17:42:19.281]     ...future.result <- base::tryCatch({
[17:42:19.281]         base::withCallingHandlers({
[17:42:19.281]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.281]             future::FutureResult(value = ...future.value$value, 
[17:42:19.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.281]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.281]                     ...future.globalenv.names))
[17:42:19.281]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.281]         }, condition = base::local({
[17:42:19.281]             c <- base::c
[17:42:19.281]             inherits <- base::inherits
[17:42:19.281]             invokeRestart <- base::invokeRestart
[17:42:19.281]             length <- base::length
[17:42:19.281]             list <- base::list
[17:42:19.281]             seq.int <- base::seq.int
[17:42:19.281]             signalCondition <- base::signalCondition
[17:42:19.281]             sys.calls <- base::sys.calls
[17:42:19.281]             `[[` <- base::`[[`
[17:42:19.281]             `+` <- base::`+`
[17:42:19.281]             `<<-` <- base::`<<-`
[17:42:19.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.281]                   3L)]
[17:42:19.281]             }
[17:42:19.281]             function(cond) {
[17:42:19.281]                 is_error <- inherits(cond, "error")
[17:42:19.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.281]                   NULL)
[17:42:19.281]                 if (is_error) {
[17:42:19.281]                   sessionInformation <- function() {
[17:42:19.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.281]                       search = base::search(), system = base::Sys.info())
[17:42:19.281]                   }
[17:42:19.281]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.281]                     cond$call), session = sessionInformation(), 
[17:42:19.281]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.281]                   signalCondition(cond)
[17:42:19.281]                 }
[17:42:19.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.281]                 "immediateCondition"))) {
[17:42:19.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.281]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.281]                   if (TRUE && !signal) {
[17:42:19.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.281]                     {
[17:42:19.281]                       inherits <- base::inherits
[17:42:19.281]                       invokeRestart <- base::invokeRestart
[17:42:19.281]                       is.null <- base::is.null
[17:42:19.281]                       muffled <- FALSE
[17:42:19.281]                       if (inherits(cond, "message")) {
[17:42:19.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.281]                         if (muffled) 
[17:42:19.281]                           invokeRestart("muffleMessage")
[17:42:19.281]                       }
[17:42:19.281]                       else if (inherits(cond, "warning")) {
[17:42:19.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.281]                         if (muffled) 
[17:42:19.281]                           invokeRestart("muffleWarning")
[17:42:19.281]                       }
[17:42:19.281]                       else if (inherits(cond, "condition")) {
[17:42:19.281]                         if (!is.null(pattern)) {
[17:42:19.281]                           computeRestarts <- base::computeRestarts
[17:42:19.281]                           grepl <- base::grepl
[17:42:19.281]                           restarts <- computeRestarts(cond)
[17:42:19.281]                           for (restart in restarts) {
[17:42:19.281]                             name <- restart$name
[17:42:19.281]                             if (is.null(name)) 
[17:42:19.281]                               next
[17:42:19.281]                             if (!grepl(pattern, name)) 
[17:42:19.281]                               next
[17:42:19.281]                             invokeRestart(restart)
[17:42:19.281]                             muffled <- TRUE
[17:42:19.281]                             break
[17:42:19.281]                           }
[17:42:19.281]                         }
[17:42:19.281]                       }
[17:42:19.281]                       invisible(muffled)
[17:42:19.281]                     }
[17:42:19.281]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.281]                   }
[17:42:19.281]                 }
[17:42:19.281]                 else {
[17:42:19.281]                   if (TRUE) {
[17:42:19.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.281]                     {
[17:42:19.281]                       inherits <- base::inherits
[17:42:19.281]                       invokeRestart <- base::invokeRestart
[17:42:19.281]                       is.null <- base::is.null
[17:42:19.281]                       muffled <- FALSE
[17:42:19.281]                       if (inherits(cond, "message")) {
[17:42:19.281]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.281]                         if (muffled) 
[17:42:19.281]                           invokeRestart("muffleMessage")
[17:42:19.281]                       }
[17:42:19.281]                       else if (inherits(cond, "warning")) {
[17:42:19.281]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.281]                         if (muffled) 
[17:42:19.281]                           invokeRestart("muffleWarning")
[17:42:19.281]                       }
[17:42:19.281]                       else if (inherits(cond, "condition")) {
[17:42:19.281]                         if (!is.null(pattern)) {
[17:42:19.281]                           computeRestarts <- base::computeRestarts
[17:42:19.281]                           grepl <- base::grepl
[17:42:19.281]                           restarts <- computeRestarts(cond)
[17:42:19.281]                           for (restart in restarts) {
[17:42:19.281]                             name <- restart$name
[17:42:19.281]                             if (is.null(name)) 
[17:42:19.281]                               next
[17:42:19.281]                             if (!grepl(pattern, name)) 
[17:42:19.281]                               next
[17:42:19.281]                             invokeRestart(restart)
[17:42:19.281]                             muffled <- TRUE
[17:42:19.281]                             break
[17:42:19.281]                           }
[17:42:19.281]                         }
[17:42:19.281]                       }
[17:42:19.281]                       invisible(muffled)
[17:42:19.281]                     }
[17:42:19.281]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.281]                   }
[17:42:19.281]                 }
[17:42:19.281]             }
[17:42:19.281]         }))
[17:42:19.281]     }, error = function(ex) {
[17:42:19.281]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.281]                 ...future.rng), started = ...future.startTime, 
[17:42:19.281]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.281]             version = "1.8"), class = "FutureResult")
[17:42:19.281]     }, finally = {
[17:42:19.281]         if (!identical(...future.workdir, getwd())) 
[17:42:19.281]             setwd(...future.workdir)
[17:42:19.281]         {
[17:42:19.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.281]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.281]             }
[17:42:19.281]             base::options(...future.oldOptions)
[17:42:19.281]             if (.Platform$OS.type == "windows") {
[17:42:19.281]                 old_names <- names(...future.oldEnvVars)
[17:42:19.281]                 envs <- base::Sys.getenv()
[17:42:19.281]                 names <- names(envs)
[17:42:19.281]                 common <- intersect(names, old_names)
[17:42:19.281]                 added <- setdiff(names, old_names)
[17:42:19.281]                 removed <- setdiff(old_names, names)
[17:42:19.281]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.281]                   envs[common]]
[17:42:19.281]                 NAMES <- toupper(changed)
[17:42:19.281]                 args <- list()
[17:42:19.281]                 for (kk in seq_along(NAMES)) {
[17:42:19.281]                   name <- changed[[kk]]
[17:42:19.281]                   NAME <- NAMES[[kk]]
[17:42:19.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.281]                     next
[17:42:19.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.281]                 }
[17:42:19.281]                 NAMES <- toupper(added)
[17:42:19.281]                 for (kk in seq_along(NAMES)) {
[17:42:19.281]                   name <- added[[kk]]
[17:42:19.281]                   NAME <- NAMES[[kk]]
[17:42:19.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.281]                     next
[17:42:19.281]                   args[[name]] <- ""
[17:42:19.281]                 }
[17:42:19.281]                 NAMES <- toupper(removed)
[17:42:19.281]                 for (kk in seq_along(NAMES)) {
[17:42:19.281]                   name <- removed[[kk]]
[17:42:19.281]                   NAME <- NAMES[[kk]]
[17:42:19.281]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.281]                     next
[17:42:19.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.281]                 }
[17:42:19.281]                 if (length(args) > 0) 
[17:42:19.281]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.281]             }
[17:42:19.281]             else {
[17:42:19.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.281]             }
[17:42:19.281]             {
[17:42:19.281]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.281]                   0L) {
[17:42:19.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.281]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.281]                   base::options(opts)
[17:42:19.281]                 }
[17:42:19.281]                 {
[17:42:19.281]                   {
[17:42:19.281]                     NULL
[17:42:19.281]                     RNGkind("Mersenne-Twister")
[17:42:19.281]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.281]                       inherits = FALSE)
[17:42:19.281]                   }
[17:42:19.281]                   options(future.plan = NULL)
[17:42:19.281]                   if (is.na(NA_character_)) 
[17:42:19.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.281]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.281]                   {
[17:42:19.281]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.281]                     if (!future$lazy) 
[17:42:19.281]                       future <- run(future)
[17:42:19.281]                     invisible(future)
[17:42:19.281]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.281]                 }
[17:42:19.281]             }
[17:42:19.281]         }
[17:42:19.281]     })
[17:42:19.281]     if (TRUE) {
[17:42:19.281]         base::sink(type = "output", split = FALSE)
[17:42:19.281]         if (TRUE) {
[17:42:19.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.281]         }
[17:42:19.281]         else {
[17:42:19.281]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.281]         }
[17:42:19.281]         base::close(...future.stdout)
[17:42:19.281]         ...future.stdout <- NULL
[17:42:19.281]     }
[17:42:19.281]     ...future.result$conditions <- ...future.conditions
[17:42:19.281]     ...future.result$finished <- base::Sys.time()
[17:42:19.281]     ...future.result
[17:42:19.281] }
[17:42:19.283] plan(): Setting new future strategy stack:
[17:42:19.283] List of future strategies:
[17:42:19.283] 1. sequential:
[17:42:19.283]    - args: function (..., envir = parent.frame())
[17:42:19.283]    - tweaked: FALSE
[17:42:19.283]    - call: NULL
[17:42:19.283] plan(): nbrOfWorkers() = 1
[17:42:19.284] plan(): Setting new future strategy stack:
[17:42:19.284] List of future strategies:
[17:42:19.284] 1. sequential:
[17:42:19.284]    - args: function (..., envir = parent.frame())
[17:42:19.284]    - tweaked: FALSE
[17:42:19.284]    - call: plan(strategy)
[17:42:19.285] plan(): nbrOfWorkers() = 1
[17:42:19.285] SequentialFuture started (and completed)
[17:42:19.285] - Launch lazy future ... done
[17:42:19.285] run() for ‘SequentialFuture’ ... done
[17:42:19.286] getGlobalsAndPackages() ...
[17:42:19.286] Searching for globals...
[17:42:19.288] - globals found: [1] ‘{’
[17:42:19.288] Searching for globals ... DONE
[17:42:19.288] Resolving globals: FALSE
[17:42:19.289] 
[17:42:19.289] 
[17:42:19.289] getGlobalsAndPackages() ... DONE
[17:42:19.289] run() for ‘Future’ ...
[17:42:19.289] - state: ‘created’
[17:42:19.289] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.290] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.290] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.290]   - Field: ‘label’
[17:42:19.290]   - Field: ‘local’
[17:42:19.290]   - Field: ‘owner’
[17:42:19.290]   - Field: ‘envir’
[17:42:19.290]   - Field: ‘packages’
[17:42:19.290]   - Field: ‘gc’
[17:42:19.290]   - Field: ‘conditions’
[17:42:19.290]   - Field: ‘expr’
[17:42:19.291]   - Field: ‘uuid’
[17:42:19.291]   - Field: ‘seed’
[17:42:19.291]   - Field: ‘version’
[17:42:19.291]   - Field: ‘result’
[17:42:19.291]   - Field: ‘asynchronous’
[17:42:19.291]   - Field: ‘calls’
[17:42:19.291]   - Field: ‘globals’
[17:42:19.291]   - Field: ‘stdout’
[17:42:19.291]   - Field: ‘earlySignal’
[17:42:19.291]   - Field: ‘lazy’
[17:42:19.292]   - Field: ‘state’
[17:42:19.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.292] - Launch lazy future ...
[17:42:19.292] Packages needed by the future expression (n = 0): <none>
[17:42:19.292] Packages needed by future strategies (n = 0): <none>
[17:42:19.292] {
[17:42:19.292]     {
[17:42:19.292]         {
[17:42:19.292]             ...future.startTime <- base::Sys.time()
[17:42:19.292]             {
[17:42:19.292]                 {
[17:42:19.292]                   {
[17:42:19.292]                     base::local({
[17:42:19.292]                       has_future <- base::requireNamespace("future", 
[17:42:19.292]                         quietly = TRUE)
[17:42:19.292]                       if (has_future) {
[17:42:19.292]                         ns <- base::getNamespace("future")
[17:42:19.292]                         version <- ns[[".package"]][["version"]]
[17:42:19.292]                         if (is.null(version)) 
[17:42:19.292]                           version <- utils::packageVersion("future")
[17:42:19.292]                       }
[17:42:19.292]                       else {
[17:42:19.292]                         version <- NULL
[17:42:19.292]                       }
[17:42:19.292]                       if (!has_future || version < "1.8.0") {
[17:42:19.292]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.292]                           "", base::R.version$version.string), 
[17:42:19.292]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.292]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.292]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.292]                             "release", "version")], collapse = " "), 
[17:42:19.292]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.292]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.292]                           info)
[17:42:19.292]                         info <- base::paste(info, collapse = "; ")
[17:42:19.292]                         if (!has_future) {
[17:42:19.292]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.292]                             info)
[17:42:19.292]                         }
[17:42:19.292]                         else {
[17:42:19.292]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.292]                             info, version)
[17:42:19.292]                         }
[17:42:19.292]                         base::stop(msg)
[17:42:19.292]                       }
[17:42:19.292]                     })
[17:42:19.292]                   }
[17:42:19.292]                   options(future.plan = NULL)
[17:42:19.292]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.292]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.292]                 }
[17:42:19.292]                 ...future.workdir <- getwd()
[17:42:19.292]             }
[17:42:19.292]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.292]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.292]         }
[17:42:19.292]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.292]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.292]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.292]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.292]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.292]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.292]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.292]             base::names(...future.oldOptions))
[17:42:19.292]     }
[17:42:19.292]     if (FALSE) {
[17:42:19.292]     }
[17:42:19.292]     else {
[17:42:19.292]         if (TRUE) {
[17:42:19.292]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.292]                 open = "w")
[17:42:19.292]         }
[17:42:19.292]         else {
[17:42:19.292]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.292]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.292]         }
[17:42:19.292]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.292]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.292]             base::sink(type = "output", split = FALSE)
[17:42:19.292]             base::close(...future.stdout)
[17:42:19.292]         }, add = TRUE)
[17:42:19.292]     }
[17:42:19.292]     ...future.frame <- base::sys.nframe()
[17:42:19.292]     ...future.conditions <- base::list()
[17:42:19.292]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.292]     if (FALSE) {
[17:42:19.292]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.292]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.292]     }
[17:42:19.292]     ...future.result <- base::tryCatch({
[17:42:19.292]         base::withCallingHandlers({
[17:42:19.292]             ...future.value <- base::withVisible(base::local({
[17:42:19.292]                 4
[17:42:19.292]             }))
[17:42:19.292]             future::FutureResult(value = ...future.value$value, 
[17:42:19.292]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.292]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.292]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.292]                     ...future.globalenv.names))
[17:42:19.292]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.292]         }, condition = base::local({
[17:42:19.292]             c <- base::c
[17:42:19.292]             inherits <- base::inherits
[17:42:19.292]             invokeRestart <- base::invokeRestart
[17:42:19.292]             length <- base::length
[17:42:19.292]             list <- base::list
[17:42:19.292]             seq.int <- base::seq.int
[17:42:19.292]             signalCondition <- base::signalCondition
[17:42:19.292]             sys.calls <- base::sys.calls
[17:42:19.292]             `[[` <- base::`[[`
[17:42:19.292]             `+` <- base::`+`
[17:42:19.292]             `<<-` <- base::`<<-`
[17:42:19.292]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.292]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.292]                   3L)]
[17:42:19.292]             }
[17:42:19.292]             function(cond) {
[17:42:19.292]                 is_error <- inherits(cond, "error")
[17:42:19.292]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.292]                   NULL)
[17:42:19.292]                 if (is_error) {
[17:42:19.292]                   sessionInformation <- function() {
[17:42:19.292]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.292]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.292]                       search = base::search(), system = base::Sys.info())
[17:42:19.292]                   }
[17:42:19.292]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.292]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.292]                     cond$call), session = sessionInformation(), 
[17:42:19.292]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.292]                   signalCondition(cond)
[17:42:19.292]                 }
[17:42:19.292]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.292]                 "immediateCondition"))) {
[17:42:19.292]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.292]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.292]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.292]                   if (TRUE && !signal) {
[17:42:19.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.292]                     {
[17:42:19.292]                       inherits <- base::inherits
[17:42:19.292]                       invokeRestart <- base::invokeRestart
[17:42:19.292]                       is.null <- base::is.null
[17:42:19.292]                       muffled <- FALSE
[17:42:19.292]                       if (inherits(cond, "message")) {
[17:42:19.292]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.292]                         if (muffled) 
[17:42:19.292]                           invokeRestart("muffleMessage")
[17:42:19.292]                       }
[17:42:19.292]                       else if (inherits(cond, "warning")) {
[17:42:19.292]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.292]                         if (muffled) 
[17:42:19.292]                           invokeRestart("muffleWarning")
[17:42:19.292]                       }
[17:42:19.292]                       else if (inherits(cond, "condition")) {
[17:42:19.292]                         if (!is.null(pattern)) {
[17:42:19.292]                           computeRestarts <- base::computeRestarts
[17:42:19.292]                           grepl <- base::grepl
[17:42:19.292]                           restarts <- computeRestarts(cond)
[17:42:19.292]                           for (restart in restarts) {
[17:42:19.292]                             name <- restart$name
[17:42:19.292]                             if (is.null(name)) 
[17:42:19.292]                               next
[17:42:19.292]                             if (!grepl(pattern, name)) 
[17:42:19.292]                               next
[17:42:19.292]                             invokeRestart(restart)
[17:42:19.292]                             muffled <- TRUE
[17:42:19.292]                             break
[17:42:19.292]                           }
[17:42:19.292]                         }
[17:42:19.292]                       }
[17:42:19.292]                       invisible(muffled)
[17:42:19.292]                     }
[17:42:19.292]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.292]                   }
[17:42:19.292]                 }
[17:42:19.292]                 else {
[17:42:19.292]                   if (TRUE) {
[17:42:19.292]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.292]                     {
[17:42:19.292]                       inherits <- base::inherits
[17:42:19.292]                       invokeRestart <- base::invokeRestart
[17:42:19.292]                       is.null <- base::is.null
[17:42:19.292]                       muffled <- FALSE
[17:42:19.292]                       if (inherits(cond, "message")) {
[17:42:19.292]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.292]                         if (muffled) 
[17:42:19.292]                           invokeRestart("muffleMessage")
[17:42:19.292]                       }
[17:42:19.292]                       else if (inherits(cond, "warning")) {
[17:42:19.292]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.292]                         if (muffled) 
[17:42:19.292]                           invokeRestart("muffleWarning")
[17:42:19.292]                       }
[17:42:19.292]                       else if (inherits(cond, "condition")) {
[17:42:19.292]                         if (!is.null(pattern)) {
[17:42:19.292]                           computeRestarts <- base::computeRestarts
[17:42:19.292]                           grepl <- base::grepl
[17:42:19.292]                           restarts <- computeRestarts(cond)
[17:42:19.292]                           for (restart in restarts) {
[17:42:19.292]                             name <- restart$name
[17:42:19.292]                             if (is.null(name)) 
[17:42:19.292]                               next
[17:42:19.292]                             if (!grepl(pattern, name)) 
[17:42:19.292]                               next
[17:42:19.292]                             invokeRestart(restart)
[17:42:19.292]                             muffled <- TRUE
[17:42:19.292]                             break
[17:42:19.292]                           }
[17:42:19.292]                         }
[17:42:19.292]                       }
[17:42:19.292]                       invisible(muffled)
[17:42:19.292]                     }
[17:42:19.292]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.292]                   }
[17:42:19.292]                 }
[17:42:19.292]             }
[17:42:19.292]         }))
[17:42:19.292]     }, error = function(ex) {
[17:42:19.292]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.292]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.292]                 ...future.rng), started = ...future.startTime, 
[17:42:19.292]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.292]             version = "1.8"), class = "FutureResult")
[17:42:19.292]     }, finally = {
[17:42:19.292]         if (!identical(...future.workdir, getwd())) 
[17:42:19.292]             setwd(...future.workdir)
[17:42:19.292]         {
[17:42:19.292]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.292]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.292]             }
[17:42:19.292]             base::options(...future.oldOptions)
[17:42:19.292]             if (.Platform$OS.type == "windows") {
[17:42:19.292]                 old_names <- names(...future.oldEnvVars)
[17:42:19.292]                 envs <- base::Sys.getenv()
[17:42:19.292]                 names <- names(envs)
[17:42:19.292]                 common <- intersect(names, old_names)
[17:42:19.292]                 added <- setdiff(names, old_names)
[17:42:19.292]                 removed <- setdiff(old_names, names)
[17:42:19.292]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.292]                   envs[common]]
[17:42:19.292]                 NAMES <- toupper(changed)
[17:42:19.292]                 args <- list()
[17:42:19.292]                 for (kk in seq_along(NAMES)) {
[17:42:19.292]                   name <- changed[[kk]]
[17:42:19.292]                   NAME <- NAMES[[kk]]
[17:42:19.292]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.292]                     next
[17:42:19.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.292]                 }
[17:42:19.292]                 NAMES <- toupper(added)
[17:42:19.292]                 for (kk in seq_along(NAMES)) {
[17:42:19.292]                   name <- added[[kk]]
[17:42:19.292]                   NAME <- NAMES[[kk]]
[17:42:19.292]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.292]                     next
[17:42:19.292]                   args[[name]] <- ""
[17:42:19.292]                 }
[17:42:19.292]                 NAMES <- toupper(removed)
[17:42:19.292]                 for (kk in seq_along(NAMES)) {
[17:42:19.292]                   name <- removed[[kk]]
[17:42:19.292]                   NAME <- NAMES[[kk]]
[17:42:19.292]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.292]                     next
[17:42:19.292]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.292]                 }
[17:42:19.292]                 if (length(args) > 0) 
[17:42:19.292]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.292]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.292]             }
[17:42:19.292]             else {
[17:42:19.292]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.292]             }
[17:42:19.292]             {
[17:42:19.292]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.292]                   0L) {
[17:42:19.292]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.292]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.292]                   base::options(opts)
[17:42:19.292]                 }
[17:42:19.292]                 {
[17:42:19.292]                   {
[17:42:19.292]                     NULL
[17:42:19.292]                     RNGkind("Mersenne-Twister")
[17:42:19.292]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.292]                       inherits = FALSE)
[17:42:19.292]                   }
[17:42:19.292]                   options(future.plan = NULL)
[17:42:19.292]                   if (is.na(NA_character_)) 
[17:42:19.292]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.292]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.292]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.292]                   {
[17:42:19.292]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.292]                     if (!future$lazy) 
[17:42:19.292]                       future <- run(future)
[17:42:19.292]                     invisible(future)
[17:42:19.292]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.292]                 }
[17:42:19.292]             }
[17:42:19.292]         }
[17:42:19.292]     })
[17:42:19.292]     if (TRUE) {
[17:42:19.292]         base::sink(type = "output", split = FALSE)
[17:42:19.292]         if (TRUE) {
[17:42:19.292]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.292]         }
[17:42:19.292]         else {
[17:42:19.292]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.292]         }
[17:42:19.292]         base::close(...future.stdout)
[17:42:19.292]         ...future.stdout <- NULL
[17:42:19.292]     }
[17:42:19.292]     ...future.result$conditions <- ...future.conditions
[17:42:19.292]     ...future.result$finished <- base::Sys.time()
[17:42:19.292]     ...future.result
[17:42:19.292] }
[17:42:19.294] plan(): Setting new future strategy stack:
[17:42:19.294] List of future strategies:
[17:42:19.294] 1. sequential:
[17:42:19.294]    - args: function (..., envir = parent.frame())
[17:42:19.294]    - tweaked: FALSE
[17:42:19.294]    - call: NULL
[17:42:19.295] plan(): nbrOfWorkers() = 1
[17:42:19.295] plan(): Setting new future strategy stack:
[17:42:19.296] List of future strategies:
[17:42:19.296] 1. sequential:
[17:42:19.296]    - args: function (..., envir = parent.frame())
[17:42:19.296]    - tweaked: FALSE
[17:42:19.296]    - call: plan(strategy)
[17:42:19.296] plan(): nbrOfWorkers() = 1
[17:42:19.296] SequentialFuture started (and completed)
[17:42:19.296] - Launch lazy future ... done
[17:42:19.296] run() for ‘SequentialFuture’ ... done
<environment: 0x55bef7ffeab0> 
<environment: 0x55bef7b71168> 
[17:42:19.298] resolved() for ‘SequentialFuture’ ...
[17:42:19.298] - state: ‘finished’
[17:42:19.298] - run: TRUE
[17:42:19.298] - result: ‘FutureResult’
[17:42:19.298] resolved() for ‘SequentialFuture’ ... done
[17:42:19.298] resolved() for ‘SequentialFuture’ ...
[17:42:19.298] - state: ‘finished’
[17:42:19.298] - run: TRUE
[17:42:19.299] - result: ‘FutureResult’
[17:42:19.299] resolved() for ‘SequentialFuture’ ... done
[17:42:19.299] resolved() for ‘SequentialFuture’ ...
[17:42:19.299] - state: ‘finished’
[17:42:19.299] - run: TRUE
[17:42:19.299] - result: ‘FutureResult’
[17:42:19.299] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:19.301] resolve() on environment ...
[17:42:19.301]  recursive: 0
[17:42:19.301]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:19.301] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.301] - nx: 4
[17:42:19.302] - relay: TRUE
[17:42:19.302] - stdout: TRUE
[17:42:19.302] - signal: TRUE
[17:42:19.302] - resignal: FALSE
[17:42:19.302] - force: TRUE
[17:42:19.302] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.302] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.302]  - until=2
[17:42:19.302]  - relaying element #2
[17:42:19.302] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.302] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.303] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.303]  length: 3 (resolved future 1)
[17:42:19.303] resolved() for ‘SequentialFuture’ ...
[17:42:19.303] - state: ‘finished’
[17:42:19.303] - run: TRUE
[17:42:19.303] - result: ‘FutureResult’
[17:42:19.303] resolved() for ‘SequentialFuture’ ... done
[17:42:19.303] Future #2
[17:42:19.303] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.304] - nx: 4
[17:42:19.304] - relay: TRUE
[17:42:19.304] - stdout: TRUE
[17:42:19.304] - signal: TRUE
[17:42:19.304] - resignal: FALSE
[17:42:19.304] - force: TRUE
[17:42:19.304] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.304] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.304]  - until=2
[17:42:19.304]  - relaying element #2
[17:42:19.304] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.305] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.305] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.305]  length: 2 (resolved future 2)
[17:42:19.305] resolved() for ‘SequentialFuture’ ...
[17:42:19.305] - state: ‘finished’
[17:42:19.305] - run: TRUE
[17:42:19.305] - result: ‘FutureResult’
[17:42:19.305] resolved() for ‘SequentialFuture’ ... done
[17:42:19.305] Future #3
[17:42:19.306] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.306] - nx: 4
[17:42:19.306] - relay: TRUE
[17:42:19.306] - stdout: TRUE
[17:42:19.306] - signal: TRUE
[17:42:19.306] - resignal: FALSE
[17:42:19.306] - force: TRUE
[17:42:19.306] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.306] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.306]  - until=3
[17:42:19.306]  - relaying element #3
[17:42:19.307] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.307] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.307] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.307]  length: 1 (resolved future 3)
[17:42:19.307] resolved() for ‘SequentialFuture’ ...
[17:42:19.307] - state: ‘finished’
[17:42:19.307] - run: TRUE
[17:42:19.307] - result: ‘FutureResult’
[17:42:19.307] resolved() for ‘SequentialFuture’ ... done
[17:42:19.307] Future #4
[17:42:19.308] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.308] - nx: 4
[17:42:19.308] - relay: TRUE
[17:42:19.308] - stdout: TRUE
[17:42:19.308] - signal: TRUE
[17:42:19.308] - resignal: FALSE
[17:42:19.308] - force: TRUE
[17:42:19.308] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.308] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.308]  - until=4
[17:42:19.308]  - relaying element #4
[17:42:19.309] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.309] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.309] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.309]  length: 0 (resolved future 4)
[17:42:19.309] Relaying remaining futures
[17:42:19.309] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.309] - nx: 4
[17:42:19.309] - relay: TRUE
[17:42:19.309] - stdout: TRUE
[17:42:19.309] - signal: TRUE
[17:42:19.309] - resignal: FALSE
[17:42:19.310] - force: TRUE
[17:42:19.310] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.310] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:19.310] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.310] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.312] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.312] resolve() on environment ... DONE
<environment: 0x55bef7f790d0> 
Dimensions: c(1, 6)
[17:42:19.313] getGlobalsAndPackages() ...
[17:42:19.313] Searching for globals...
[17:42:19.313] 
[17:42:19.314] Searching for globals ... DONE
[17:42:19.314] - globals: [0] <none>
[17:42:19.314] getGlobalsAndPackages() ... DONE
[17:42:19.314] run() for ‘Future’ ...
[17:42:19.314] - state: ‘created’
[17:42:19.314] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.315] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.315] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.315]   - Field: ‘label’
[17:42:19.315]   - Field: ‘local’
[17:42:19.315]   - Field: ‘owner’
[17:42:19.315]   - Field: ‘envir’
[17:42:19.315]   - Field: ‘packages’
[17:42:19.315]   - Field: ‘gc’
[17:42:19.315]   - Field: ‘conditions’
[17:42:19.316]   - Field: ‘expr’
[17:42:19.316]   - Field: ‘uuid’
[17:42:19.316]   - Field: ‘seed’
[17:42:19.316]   - Field: ‘version’
[17:42:19.316]   - Field: ‘result’
[17:42:19.316]   - Field: ‘asynchronous’
[17:42:19.316]   - Field: ‘calls’
[17:42:19.316]   - Field: ‘globals’
[17:42:19.316]   - Field: ‘stdout’
[17:42:19.316]   - Field: ‘earlySignal’
[17:42:19.317]   - Field: ‘lazy’
[17:42:19.317]   - Field: ‘state’
[17:42:19.317] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.317] - Launch lazy future ...
[17:42:19.317] Packages needed by the future expression (n = 0): <none>
[17:42:19.317] Packages needed by future strategies (n = 0): <none>
[17:42:19.318] {
[17:42:19.318]     {
[17:42:19.318]         {
[17:42:19.318]             ...future.startTime <- base::Sys.time()
[17:42:19.318]             {
[17:42:19.318]                 {
[17:42:19.318]                   {
[17:42:19.318]                     base::local({
[17:42:19.318]                       has_future <- base::requireNamespace("future", 
[17:42:19.318]                         quietly = TRUE)
[17:42:19.318]                       if (has_future) {
[17:42:19.318]                         ns <- base::getNamespace("future")
[17:42:19.318]                         version <- ns[[".package"]][["version"]]
[17:42:19.318]                         if (is.null(version)) 
[17:42:19.318]                           version <- utils::packageVersion("future")
[17:42:19.318]                       }
[17:42:19.318]                       else {
[17:42:19.318]                         version <- NULL
[17:42:19.318]                       }
[17:42:19.318]                       if (!has_future || version < "1.8.0") {
[17:42:19.318]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.318]                           "", base::R.version$version.string), 
[17:42:19.318]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.318]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.318]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.318]                             "release", "version")], collapse = " "), 
[17:42:19.318]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.318]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.318]                           info)
[17:42:19.318]                         info <- base::paste(info, collapse = "; ")
[17:42:19.318]                         if (!has_future) {
[17:42:19.318]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.318]                             info)
[17:42:19.318]                         }
[17:42:19.318]                         else {
[17:42:19.318]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.318]                             info, version)
[17:42:19.318]                         }
[17:42:19.318]                         base::stop(msg)
[17:42:19.318]                       }
[17:42:19.318]                     })
[17:42:19.318]                   }
[17:42:19.318]                   options(future.plan = NULL)
[17:42:19.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.318]                 }
[17:42:19.318]                 ...future.workdir <- getwd()
[17:42:19.318]             }
[17:42:19.318]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.318]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.318]         }
[17:42:19.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.318]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.318]             base::names(...future.oldOptions))
[17:42:19.318]     }
[17:42:19.318]     if (FALSE) {
[17:42:19.318]     }
[17:42:19.318]     else {
[17:42:19.318]         if (TRUE) {
[17:42:19.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.318]                 open = "w")
[17:42:19.318]         }
[17:42:19.318]         else {
[17:42:19.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.318]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.318]         }
[17:42:19.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.318]             base::sink(type = "output", split = FALSE)
[17:42:19.318]             base::close(...future.stdout)
[17:42:19.318]         }, add = TRUE)
[17:42:19.318]     }
[17:42:19.318]     ...future.frame <- base::sys.nframe()
[17:42:19.318]     ...future.conditions <- base::list()
[17:42:19.318]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.318]     if (FALSE) {
[17:42:19.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.318]     }
[17:42:19.318]     ...future.result <- base::tryCatch({
[17:42:19.318]         base::withCallingHandlers({
[17:42:19.318]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.318]             future::FutureResult(value = ...future.value$value, 
[17:42:19.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.318]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.318]                     ...future.globalenv.names))
[17:42:19.318]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.318]         }, condition = base::local({
[17:42:19.318]             c <- base::c
[17:42:19.318]             inherits <- base::inherits
[17:42:19.318]             invokeRestart <- base::invokeRestart
[17:42:19.318]             length <- base::length
[17:42:19.318]             list <- base::list
[17:42:19.318]             seq.int <- base::seq.int
[17:42:19.318]             signalCondition <- base::signalCondition
[17:42:19.318]             sys.calls <- base::sys.calls
[17:42:19.318]             `[[` <- base::`[[`
[17:42:19.318]             `+` <- base::`+`
[17:42:19.318]             `<<-` <- base::`<<-`
[17:42:19.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.318]                   3L)]
[17:42:19.318]             }
[17:42:19.318]             function(cond) {
[17:42:19.318]                 is_error <- inherits(cond, "error")
[17:42:19.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.318]                   NULL)
[17:42:19.318]                 if (is_error) {
[17:42:19.318]                   sessionInformation <- function() {
[17:42:19.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.318]                       search = base::search(), system = base::Sys.info())
[17:42:19.318]                   }
[17:42:19.318]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.318]                     cond$call), session = sessionInformation(), 
[17:42:19.318]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.318]                   signalCondition(cond)
[17:42:19.318]                 }
[17:42:19.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.318]                 "immediateCondition"))) {
[17:42:19.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.318]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.318]                   if (TRUE && !signal) {
[17:42:19.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.318]                     {
[17:42:19.318]                       inherits <- base::inherits
[17:42:19.318]                       invokeRestart <- base::invokeRestart
[17:42:19.318]                       is.null <- base::is.null
[17:42:19.318]                       muffled <- FALSE
[17:42:19.318]                       if (inherits(cond, "message")) {
[17:42:19.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.318]                         if (muffled) 
[17:42:19.318]                           invokeRestart("muffleMessage")
[17:42:19.318]                       }
[17:42:19.318]                       else if (inherits(cond, "warning")) {
[17:42:19.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.318]                         if (muffled) 
[17:42:19.318]                           invokeRestart("muffleWarning")
[17:42:19.318]                       }
[17:42:19.318]                       else if (inherits(cond, "condition")) {
[17:42:19.318]                         if (!is.null(pattern)) {
[17:42:19.318]                           computeRestarts <- base::computeRestarts
[17:42:19.318]                           grepl <- base::grepl
[17:42:19.318]                           restarts <- computeRestarts(cond)
[17:42:19.318]                           for (restart in restarts) {
[17:42:19.318]                             name <- restart$name
[17:42:19.318]                             if (is.null(name)) 
[17:42:19.318]                               next
[17:42:19.318]                             if (!grepl(pattern, name)) 
[17:42:19.318]                               next
[17:42:19.318]                             invokeRestart(restart)
[17:42:19.318]                             muffled <- TRUE
[17:42:19.318]                             break
[17:42:19.318]                           }
[17:42:19.318]                         }
[17:42:19.318]                       }
[17:42:19.318]                       invisible(muffled)
[17:42:19.318]                     }
[17:42:19.318]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.318]                   }
[17:42:19.318]                 }
[17:42:19.318]                 else {
[17:42:19.318]                   if (TRUE) {
[17:42:19.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.318]                     {
[17:42:19.318]                       inherits <- base::inherits
[17:42:19.318]                       invokeRestart <- base::invokeRestart
[17:42:19.318]                       is.null <- base::is.null
[17:42:19.318]                       muffled <- FALSE
[17:42:19.318]                       if (inherits(cond, "message")) {
[17:42:19.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.318]                         if (muffled) 
[17:42:19.318]                           invokeRestart("muffleMessage")
[17:42:19.318]                       }
[17:42:19.318]                       else if (inherits(cond, "warning")) {
[17:42:19.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.318]                         if (muffled) 
[17:42:19.318]                           invokeRestart("muffleWarning")
[17:42:19.318]                       }
[17:42:19.318]                       else if (inherits(cond, "condition")) {
[17:42:19.318]                         if (!is.null(pattern)) {
[17:42:19.318]                           computeRestarts <- base::computeRestarts
[17:42:19.318]                           grepl <- base::grepl
[17:42:19.318]                           restarts <- computeRestarts(cond)
[17:42:19.318]                           for (restart in restarts) {
[17:42:19.318]                             name <- restart$name
[17:42:19.318]                             if (is.null(name)) 
[17:42:19.318]                               next
[17:42:19.318]                             if (!grepl(pattern, name)) 
[17:42:19.318]                               next
[17:42:19.318]                             invokeRestart(restart)
[17:42:19.318]                             muffled <- TRUE
[17:42:19.318]                             break
[17:42:19.318]                           }
[17:42:19.318]                         }
[17:42:19.318]                       }
[17:42:19.318]                       invisible(muffled)
[17:42:19.318]                     }
[17:42:19.318]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.318]                   }
[17:42:19.318]                 }
[17:42:19.318]             }
[17:42:19.318]         }))
[17:42:19.318]     }, error = function(ex) {
[17:42:19.318]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.318]                 ...future.rng), started = ...future.startTime, 
[17:42:19.318]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.318]             version = "1.8"), class = "FutureResult")
[17:42:19.318]     }, finally = {
[17:42:19.318]         if (!identical(...future.workdir, getwd())) 
[17:42:19.318]             setwd(...future.workdir)
[17:42:19.318]         {
[17:42:19.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.318]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.318]             }
[17:42:19.318]             base::options(...future.oldOptions)
[17:42:19.318]             if (.Platform$OS.type == "windows") {
[17:42:19.318]                 old_names <- names(...future.oldEnvVars)
[17:42:19.318]                 envs <- base::Sys.getenv()
[17:42:19.318]                 names <- names(envs)
[17:42:19.318]                 common <- intersect(names, old_names)
[17:42:19.318]                 added <- setdiff(names, old_names)
[17:42:19.318]                 removed <- setdiff(old_names, names)
[17:42:19.318]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.318]                   envs[common]]
[17:42:19.318]                 NAMES <- toupper(changed)
[17:42:19.318]                 args <- list()
[17:42:19.318]                 for (kk in seq_along(NAMES)) {
[17:42:19.318]                   name <- changed[[kk]]
[17:42:19.318]                   NAME <- NAMES[[kk]]
[17:42:19.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.318]                     next
[17:42:19.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.318]                 }
[17:42:19.318]                 NAMES <- toupper(added)
[17:42:19.318]                 for (kk in seq_along(NAMES)) {
[17:42:19.318]                   name <- added[[kk]]
[17:42:19.318]                   NAME <- NAMES[[kk]]
[17:42:19.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.318]                     next
[17:42:19.318]                   args[[name]] <- ""
[17:42:19.318]                 }
[17:42:19.318]                 NAMES <- toupper(removed)
[17:42:19.318]                 for (kk in seq_along(NAMES)) {
[17:42:19.318]                   name <- removed[[kk]]
[17:42:19.318]                   NAME <- NAMES[[kk]]
[17:42:19.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.318]                     next
[17:42:19.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.318]                 }
[17:42:19.318]                 if (length(args) > 0) 
[17:42:19.318]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.318]             }
[17:42:19.318]             else {
[17:42:19.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.318]             }
[17:42:19.318]             {
[17:42:19.318]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.318]                   0L) {
[17:42:19.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.318]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.318]                   base::options(opts)
[17:42:19.318]                 }
[17:42:19.318]                 {
[17:42:19.318]                   {
[17:42:19.318]                     NULL
[17:42:19.318]                     RNGkind("Mersenne-Twister")
[17:42:19.318]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.318]                       inherits = FALSE)
[17:42:19.318]                   }
[17:42:19.318]                   options(future.plan = NULL)
[17:42:19.318]                   if (is.na(NA_character_)) 
[17:42:19.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.318]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.318]                   {
[17:42:19.318]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.318]                     if (!future$lazy) 
[17:42:19.318]                       future <- run(future)
[17:42:19.318]                     invisible(future)
[17:42:19.318]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.318]                 }
[17:42:19.318]             }
[17:42:19.318]         }
[17:42:19.318]     })
[17:42:19.318]     if (TRUE) {
[17:42:19.318]         base::sink(type = "output", split = FALSE)
[17:42:19.318]         if (TRUE) {
[17:42:19.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.318]         }
[17:42:19.318]         else {
[17:42:19.318]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.318]         }
[17:42:19.318]         base::close(...future.stdout)
[17:42:19.318]         ...future.stdout <- NULL
[17:42:19.318]     }
[17:42:19.318]     ...future.result$conditions <- ...future.conditions
[17:42:19.318]     ...future.result$finished <- base::Sys.time()
[17:42:19.318]     ...future.result
[17:42:19.318] }
[17:42:19.319] plan(): Setting new future strategy stack:
[17:42:19.320] List of future strategies:
[17:42:19.320] 1. sequential:
[17:42:19.320]    - args: function (..., envir = parent.frame())
[17:42:19.320]    - tweaked: FALSE
[17:42:19.320]    - call: NULL
[17:42:19.320] plan(): nbrOfWorkers() = 1
[17:42:19.321] plan(): Setting new future strategy stack:
[17:42:19.321] List of future strategies:
[17:42:19.321] 1. sequential:
[17:42:19.321]    - args: function (..., envir = parent.frame())
[17:42:19.321]    - tweaked: FALSE
[17:42:19.321]    - call: plan(strategy)
[17:42:19.321] plan(): nbrOfWorkers() = 1
[17:42:19.321] SequentialFuture started (and completed)
[17:42:19.322] - Launch lazy future ... done
[17:42:19.322] run() for ‘SequentialFuture’ ... done
[17:42:19.322] getGlobalsAndPackages() ...
[17:42:19.322] Searching for globals...
[17:42:19.322] 
[17:42:19.322] Searching for globals ... DONE
[17:42:19.322] - globals: [0] <none>
[17:42:19.322] getGlobalsAndPackages() ... DONE
[17:42:19.323] run() for ‘Future’ ...
[17:42:19.323] - state: ‘created’
[17:42:19.323] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.323] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.324]   - Field: ‘label’
[17:42:19.324]   - Field: ‘local’
[17:42:19.324]   - Field: ‘owner’
[17:42:19.324]   - Field: ‘envir’
[17:42:19.324]   - Field: ‘packages’
[17:42:19.324]   - Field: ‘gc’
[17:42:19.324]   - Field: ‘conditions’
[17:42:19.324]   - Field: ‘expr’
[17:42:19.324]   - Field: ‘uuid’
[17:42:19.324]   - Field: ‘seed’
[17:42:19.325]   - Field: ‘version’
[17:42:19.325]   - Field: ‘result’
[17:42:19.325]   - Field: ‘asynchronous’
[17:42:19.325]   - Field: ‘calls’
[17:42:19.325]   - Field: ‘globals’
[17:42:19.325]   - Field: ‘stdout’
[17:42:19.325]   - Field: ‘earlySignal’
[17:42:19.325]   - Field: ‘lazy’
[17:42:19.325]   - Field: ‘state’
[17:42:19.325] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.325] - Launch lazy future ...
[17:42:19.326] Packages needed by the future expression (n = 0): <none>
[17:42:19.326] Packages needed by future strategies (n = 0): <none>
[17:42:19.326] {
[17:42:19.326]     {
[17:42:19.326]         {
[17:42:19.326]             ...future.startTime <- base::Sys.time()
[17:42:19.326]             {
[17:42:19.326]                 {
[17:42:19.326]                   {
[17:42:19.326]                     base::local({
[17:42:19.326]                       has_future <- base::requireNamespace("future", 
[17:42:19.326]                         quietly = TRUE)
[17:42:19.326]                       if (has_future) {
[17:42:19.326]                         ns <- base::getNamespace("future")
[17:42:19.326]                         version <- ns[[".package"]][["version"]]
[17:42:19.326]                         if (is.null(version)) 
[17:42:19.326]                           version <- utils::packageVersion("future")
[17:42:19.326]                       }
[17:42:19.326]                       else {
[17:42:19.326]                         version <- NULL
[17:42:19.326]                       }
[17:42:19.326]                       if (!has_future || version < "1.8.0") {
[17:42:19.326]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.326]                           "", base::R.version$version.string), 
[17:42:19.326]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.326]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.326]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.326]                             "release", "version")], collapse = " "), 
[17:42:19.326]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.326]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.326]                           info)
[17:42:19.326]                         info <- base::paste(info, collapse = "; ")
[17:42:19.326]                         if (!has_future) {
[17:42:19.326]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.326]                             info)
[17:42:19.326]                         }
[17:42:19.326]                         else {
[17:42:19.326]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.326]                             info, version)
[17:42:19.326]                         }
[17:42:19.326]                         base::stop(msg)
[17:42:19.326]                       }
[17:42:19.326]                     })
[17:42:19.326]                   }
[17:42:19.326]                   options(future.plan = NULL)
[17:42:19.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.326]                 }
[17:42:19.326]                 ...future.workdir <- getwd()
[17:42:19.326]             }
[17:42:19.326]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.326]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.326]         }
[17:42:19.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.326]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.326]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.326]             base::names(...future.oldOptions))
[17:42:19.326]     }
[17:42:19.326]     if (FALSE) {
[17:42:19.326]     }
[17:42:19.326]     else {
[17:42:19.326]         if (TRUE) {
[17:42:19.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.326]                 open = "w")
[17:42:19.326]         }
[17:42:19.326]         else {
[17:42:19.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.326]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.326]         }
[17:42:19.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.326]             base::sink(type = "output", split = FALSE)
[17:42:19.326]             base::close(...future.stdout)
[17:42:19.326]         }, add = TRUE)
[17:42:19.326]     }
[17:42:19.326]     ...future.frame <- base::sys.nframe()
[17:42:19.326]     ...future.conditions <- base::list()
[17:42:19.326]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.326]     if (FALSE) {
[17:42:19.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.326]     }
[17:42:19.326]     ...future.result <- base::tryCatch({
[17:42:19.326]         base::withCallingHandlers({
[17:42:19.326]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.326]             future::FutureResult(value = ...future.value$value, 
[17:42:19.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.326]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.326]                     ...future.globalenv.names))
[17:42:19.326]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.326]         }, condition = base::local({
[17:42:19.326]             c <- base::c
[17:42:19.326]             inherits <- base::inherits
[17:42:19.326]             invokeRestart <- base::invokeRestart
[17:42:19.326]             length <- base::length
[17:42:19.326]             list <- base::list
[17:42:19.326]             seq.int <- base::seq.int
[17:42:19.326]             signalCondition <- base::signalCondition
[17:42:19.326]             sys.calls <- base::sys.calls
[17:42:19.326]             `[[` <- base::`[[`
[17:42:19.326]             `+` <- base::`+`
[17:42:19.326]             `<<-` <- base::`<<-`
[17:42:19.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.326]                   3L)]
[17:42:19.326]             }
[17:42:19.326]             function(cond) {
[17:42:19.326]                 is_error <- inherits(cond, "error")
[17:42:19.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.326]                   NULL)
[17:42:19.326]                 if (is_error) {
[17:42:19.326]                   sessionInformation <- function() {
[17:42:19.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.326]                       search = base::search(), system = base::Sys.info())
[17:42:19.326]                   }
[17:42:19.326]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.326]                     cond$call), session = sessionInformation(), 
[17:42:19.326]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.326]                   signalCondition(cond)
[17:42:19.326]                 }
[17:42:19.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.326]                 "immediateCondition"))) {
[17:42:19.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.326]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.326]                   if (TRUE && !signal) {
[17:42:19.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.326]                     {
[17:42:19.326]                       inherits <- base::inherits
[17:42:19.326]                       invokeRestart <- base::invokeRestart
[17:42:19.326]                       is.null <- base::is.null
[17:42:19.326]                       muffled <- FALSE
[17:42:19.326]                       if (inherits(cond, "message")) {
[17:42:19.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.326]                         if (muffled) 
[17:42:19.326]                           invokeRestart("muffleMessage")
[17:42:19.326]                       }
[17:42:19.326]                       else if (inherits(cond, "warning")) {
[17:42:19.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.326]                         if (muffled) 
[17:42:19.326]                           invokeRestart("muffleWarning")
[17:42:19.326]                       }
[17:42:19.326]                       else if (inherits(cond, "condition")) {
[17:42:19.326]                         if (!is.null(pattern)) {
[17:42:19.326]                           computeRestarts <- base::computeRestarts
[17:42:19.326]                           grepl <- base::grepl
[17:42:19.326]                           restarts <- computeRestarts(cond)
[17:42:19.326]                           for (restart in restarts) {
[17:42:19.326]                             name <- restart$name
[17:42:19.326]                             if (is.null(name)) 
[17:42:19.326]                               next
[17:42:19.326]                             if (!grepl(pattern, name)) 
[17:42:19.326]                               next
[17:42:19.326]                             invokeRestart(restart)
[17:42:19.326]                             muffled <- TRUE
[17:42:19.326]                             break
[17:42:19.326]                           }
[17:42:19.326]                         }
[17:42:19.326]                       }
[17:42:19.326]                       invisible(muffled)
[17:42:19.326]                     }
[17:42:19.326]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.326]                   }
[17:42:19.326]                 }
[17:42:19.326]                 else {
[17:42:19.326]                   if (TRUE) {
[17:42:19.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.326]                     {
[17:42:19.326]                       inherits <- base::inherits
[17:42:19.326]                       invokeRestart <- base::invokeRestart
[17:42:19.326]                       is.null <- base::is.null
[17:42:19.326]                       muffled <- FALSE
[17:42:19.326]                       if (inherits(cond, "message")) {
[17:42:19.326]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.326]                         if (muffled) 
[17:42:19.326]                           invokeRestart("muffleMessage")
[17:42:19.326]                       }
[17:42:19.326]                       else if (inherits(cond, "warning")) {
[17:42:19.326]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.326]                         if (muffled) 
[17:42:19.326]                           invokeRestart("muffleWarning")
[17:42:19.326]                       }
[17:42:19.326]                       else if (inherits(cond, "condition")) {
[17:42:19.326]                         if (!is.null(pattern)) {
[17:42:19.326]                           computeRestarts <- base::computeRestarts
[17:42:19.326]                           grepl <- base::grepl
[17:42:19.326]                           restarts <- computeRestarts(cond)
[17:42:19.326]                           for (restart in restarts) {
[17:42:19.326]                             name <- restart$name
[17:42:19.326]                             if (is.null(name)) 
[17:42:19.326]                               next
[17:42:19.326]                             if (!grepl(pattern, name)) 
[17:42:19.326]                               next
[17:42:19.326]                             invokeRestart(restart)
[17:42:19.326]                             muffled <- TRUE
[17:42:19.326]                             break
[17:42:19.326]                           }
[17:42:19.326]                         }
[17:42:19.326]                       }
[17:42:19.326]                       invisible(muffled)
[17:42:19.326]                     }
[17:42:19.326]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.326]                   }
[17:42:19.326]                 }
[17:42:19.326]             }
[17:42:19.326]         }))
[17:42:19.326]     }, error = function(ex) {
[17:42:19.326]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.326]                 ...future.rng), started = ...future.startTime, 
[17:42:19.326]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.326]             version = "1.8"), class = "FutureResult")
[17:42:19.326]     }, finally = {
[17:42:19.326]         if (!identical(...future.workdir, getwd())) 
[17:42:19.326]             setwd(...future.workdir)
[17:42:19.326]         {
[17:42:19.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.326]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.326]             }
[17:42:19.326]             base::options(...future.oldOptions)
[17:42:19.326]             if (.Platform$OS.type == "windows") {
[17:42:19.326]                 old_names <- names(...future.oldEnvVars)
[17:42:19.326]                 envs <- base::Sys.getenv()
[17:42:19.326]                 names <- names(envs)
[17:42:19.326]                 common <- intersect(names, old_names)
[17:42:19.326]                 added <- setdiff(names, old_names)
[17:42:19.326]                 removed <- setdiff(old_names, names)
[17:42:19.326]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.326]                   envs[common]]
[17:42:19.326]                 NAMES <- toupper(changed)
[17:42:19.326]                 args <- list()
[17:42:19.326]                 for (kk in seq_along(NAMES)) {
[17:42:19.326]                   name <- changed[[kk]]
[17:42:19.326]                   NAME <- NAMES[[kk]]
[17:42:19.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.326]                     next
[17:42:19.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.326]                 }
[17:42:19.326]                 NAMES <- toupper(added)
[17:42:19.326]                 for (kk in seq_along(NAMES)) {
[17:42:19.326]                   name <- added[[kk]]
[17:42:19.326]                   NAME <- NAMES[[kk]]
[17:42:19.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.326]                     next
[17:42:19.326]                   args[[name]] <- ""
[17:42:19.326]                 }
[17:42:19.326]                 NAMES <- toupper(removed)
[17:42:19.326]                 for (kk in seq_along(NAMES)) {
[17:42:19.326]                   name <- removed[[kk]]
[17:42:19.326]                   NAME <- NAMES[[kk]]
[17:42:19.326]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.326]                     next
[17:42:19.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.326]                 }
[17:42:19.326]                 if (length(args) > 0) 
[17:42:19.326]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.326]             }
[17:42:19.326]             else {
[17:42:19.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.326]             }
[17:42:19.326]             {
[17:42:19.326]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.326]                   0L) {
[17:42:19.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.326]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.326]                   base::options(opts)
[17:42:19.326]                 }
[17:42:19.326]                 {
[17:42:19.326]                   {
[17:42:19.326]                     NULL
[17:42:19.326]                     RNGkind("Mersenne-Twister")
[17:42:19.326]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.326]                       inherits = FALSE)
[17:42:19.326]                   }
[17:42:19.326]                   options(future.plan = NULL)
[17:42:19.326]                   if (is.na(NA_character_)) 
[17:42:19.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.326]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.326]                   {
[17:42:19.326]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.326]                     if (!future$lazy) 
[17:42:19.326]                       future <- run(future)
[17:42:19.326]                     invisible(future)
[17:42:19.326]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.326]                 }
[17:42:19.326]             }
[17:42:19.326]         }
[17:42:19.326]     })
[17:42:19.326]     if (TRUE) {
[17:42:19.326]         base::sink(type = "output", split = FALSE)
[17:42:19.326]         if (TRUE) {
[17:42:19.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.326]         }
[17:42:19.326]         else {
[17:42:19.326]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.326]         }
[17:42:19.326]         base::close(...future.stdout)
[17:42:19.326]         ...future.stdout <- NULL
[17:42:19.326]     }
[17:42:19.326]     ...future.result$conditions <- ...future.conditions
[17:42:19.326]     ...future.result$finished <- base::Sys.time()
[17:42:19.326]     ...future.result
[17:42:19.326] }
[17:42:19.328] plan(): Setting new future strategy stack:
[17:42:19.328] List of future strategies:
[17:42:19.328] 1. sequential:
[17:42:19.328]    - args: function (..., envir = parent.frame())
[17:42:19.328]    - tweaked: FALSE
[17:42:19.328]    - call: NULL
[17:42:19.329] plan(): nbrOfWorkers() = 1
[17:42:19.329] plan(): Setting new future strategy stack:
[17:42:19.329] List of future strategies:
[17:42:19.329] 1. sequential:
[17:42:19.329]    - args: function (..., envir = parent.frame())
[17:42:19.329]    - tweaked: FALSE
[17:42:19.329]    - call: plan(strategy)
[17:42:19.330] plan(): nbrOfWorkers() = 1
[17:42:19.330] SequentialFuture started (and completed)
[17:42:19.330] - Launch lazy future ... done
[17:42:19.330] run() for ‘SequentialFuture’ ... done
[17:42:19.331] getGlobalsAndPackages() ...
[17:42:19.331] Searching for globals...
[17:42:19.331] - globals found: [1] ‘{’
[17:42:19.332] Searching for globals ... DONE
[17:42:19.332] Resolving globals: FALSE
[17:42:19.332] 
[17:42:19.332] 
[17:42:19.332] getGlobalsAndPackages() ... DONE
[17:42:19.332] run() for ‘Future’ ...
[17:42:19.333] - state: ‘created’
[17:42:19.333] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.333]   - Field: ‘label’
[17:42:19.333]   - Field: ‘local’
[17:42:19.333]   - Field: ‘owner’
[17:42:19.333]   - Field: ‘envir’
[17:42:19.334]   - Field: ‘packages’
[17:42:19.334]   - Field: ‘gc’
[17:42:19.334]   - Field: ‘conditions’
[17:42:19.334]   - Field: ‘expr’
[17:42:19.334]   - Field: ‘uuid’
[17:42:19.334]   - Field: ‘seed’
[17:42:19.334]   - Field: ‘version’
[17:42:19.334]   - Field: ‘result’
[17:42:19.334]   - Field: ‘asynchronous’
[17:42:19.334]   - Field: ‘calls’
[17:42:19.335]   - Field: ‘globals’
[17:42:19.335]   - Field: ‘stdout’
[17:42:19.335]   - Field: ‘earlySignal’
[17:42:19.335]   - Field: ‘lazy’
[17:42:19.335]   - Field: ‘state’
[17:42:19.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.335] - Launch lazy future ...
[17:42:19.335] Packages needed by the future expression (n = 0): <none>
[17:42:19.335] Packages needed by future strategies (n = 0): <none>
[17:42:19.336] {
[17:42:19.336]     {
[17:42:19.336]         {
[17:42:19.336]             ...future.startTime <- base::Sys.time()
[17:42:19.336]             {
[17:42:19.336]                 {
[17:42:19.336]                   {
[17:42:19.336]                     base::local({
[17:42:19.336]                       has_future <- base::requireNamespace("future", 
[17:42:19.336]                         quietly = TRUE)
[17:42:19.336]                       if (has_future) {
[17:42:19.336]                         ns <- base::getNamespace("future")
[17:42:19.336]                         version <- ns[[".package"]][["version"]]
[17:42:19.336]                         if (is.null(version)) 
[17:42:19.336]                           version <- utils::packageVersion("future")
[17:42:19.336]                       }
[17:42:19.336]                       else {
[17:42:19.336]                         version <- NULL
[17:42:19.336]                       }
[17:42:19.336]                       if (!has_future || version < "1.8.0") {
[17:42:19.336]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.336]                           "", base::R.version$version.string), 
[17:42:19.336]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.336]                             "release", "version")], collapse = " "), 
[17:42:19.336]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.336]                           info)
[17:42:19.336]                         info <- base::paste(info, collapse = "; ")
[17:42:19.336]                         if (!has_future) {
[17:42:19.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.336]                             info)
[17:42:19.336]                         }
[17:42:19.336]                         else {
[17:42:19.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.336]                             info, version)
[17:42:19.336]                         }
[17:42:19.336]                         base::stop(msg)
[17:42:19.336]                       }
[17:42:19.336]                     })
[17:42:19.336]                   }
[17:42:19.336]                   options(future.plan = NULL)
[17:42:19.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.336]                 }
[17:42:19.336]                 ...future.workdir <- getwd()
[17:42:19.336]             }
[17:42:19.336]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.336]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.336]         }
[17:42:19.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.336]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.336]             base::names(...future.oldOptions))
[17:42:19.336]     }
[17:42:19.336]     if (FALSE) {
[17:42:19.336]     }
[17:42:19.336]     else {
[17:42:19.336]         if (TRUE) {
[17:42:19.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.336]                 open = "w")
[17:42:19.336]         }
[17:42:19.336]         else {
[17:42:19.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.336]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.336]         }
[17:42:19.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.336]             base::sink(type = "output", split = FALSE)
[17:42:19.336]             base::close(...future.stdout)
[17:42:19.336]         }, add = TRUE)
[17:42:19.336]     }
[17:42:19.336]     ...future.frame <- base::sys.nframe()
[17:42:19.336]     ...future.conditions <- base::list()
[17:42:19.336]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.336]     if (FALSE) {
[17:42:19.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.336]     }
[17:42:19.336]     ...future.result <- base::tryCatch({
[17:42:19.336]         base::withCallingHandlers({
[17:42:19.336]             ...future.value <- base::withVisible(base::local({
[17:42:19.336]                 4
[17:42:19.336]             }))
[17:42:19.336]             future::FutureResult(value = ...future.value$value, 
[17:42:19.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.336]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.336]                     ...future.globalenv.names))
[17:42:19.336]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.336]         }, condition = base::local({
[17:42:19.336]             c <- base::c
[17:42:19.336]             inherits <- base::inherits
[17:42:19.336]             invokeRestart <- base::invokeRestart
[17:42:19.336]             length <- base::length
[17:42:19.336]             list <- base::list
[17:42:19.336]             seq.int <- base::seq.int
[17:42:19.336]             signalCondition <- base::signalCondition
[17:42:19.336]             sys.calls <- base::sys.calls
[17:42:19.336]             `[[` <- base::`[[`
[17:42:19.336]             `+` <- base::`+`
[17:42:19.336]             `<<-` <- base::`<<-`
[17:42:19.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.336]                   3L)]
[17:42:19.336]             }
[17:42:19.336]             function(cond) {
[17:42:19.336]                 is_error <- inherits(cond, "error")
[17:42:19.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.336]                   NULL)
[17:42:19.336]                 if (is_error) {
[17:42:19.336]                   sessionInformation <- function() {
[17:42:19.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.336]                       search = base::search(), system = base::Sys.info())
[17:42:19.336]                   }
[17:42:19.336]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.336]                     cond$call), session = sessionInformation(), 
[17:42:19.336]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.336]                   signalCondition(cond)
[17:42:19.336]                 }
[17:42:19.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.336]                 "immediateCondition"))) {
[17:42:19.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.336]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.336]                   if (TRUE && !signal) {
[17:42:19.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.336]                     {
[17:42:19.336]                       inherits <- base::inherits
[17:42:19.336]                       invokeRestart <- base::invokeRestart
[17:42:19.336]                       is.null <- base::is.null
[17:42:19.336]                       muffled <- FALSE
[17:42:19.336]                       if (inherits(cond, "message")) {
[17:42:19.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.336]                         if (muffled) 
[17:42:19.336]                           invokeRestart("muffleMessage")
[17:42:19.336]                       }
[17:42:19.336]                       else if (inherits(cond, "warning")) {
[17:42:19.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.336]                         if (muffled) 
[17:42:19.336]                           invokeRestart("muffleWarning")
[17:42:19.336]                       }
[17:42:19.336]                       else if (inherits(cond, "condition")) {
[17:42:19.336]                         if (!is.null(pattern)) {
[17:42:19.336]                           computeRestarts <- base::computeRestarts
[17:42:19.336]                           grepl <- base::grepl
[17:42:19.336]                           restarts <- computeRestarts(cond)
[17:42:19.336]                           for (restart in restarts) {
[17:42:19.336]                             name <- restart$name
[17:42:19.336]                             if (is.null(name)) 
[17:42:19.336]                               next
[17:42:19.336]                             if (!grepl(pattern, name)) 
[17:42:19.336]                               next
[17:42:19.336]                             invokeRestart(restart)
[17:42:19.336]                             muffled <- TRUE
[17:42:19.336]                             break
[17:42:19.336]                           }
[17:42:19.336]                         }
[17:42:19.336]                       }
[17:42:19.336]                       invisible(muffled)
[17:42:19.336]                     }
[17:42:19.336]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.336]                   }
[17:42:19.336]                 }
[17:42:19.336]                 else {
[17:42:19.336]                   if (TRUE) {
[17:42:19.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.336]                     {
[17:42:19.336]                       inherits <- base::inherits
[17:42:19.336]                       invokeRestart <- base::invokeRestart
[17:42:19.336]                       is.null <- base::is.null
[17:42:19.336]                       muffled <- FALSE
[17:42:19.336]                       if (inherits(cond, "message")) {
[17:42:19.336]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.336]                         if (muffled) 
[17:42:19.336]                           invokeRestart("muffleMessage")
[17:42:19.336]                       }
[17:42:19.336]                       else if (inherits(cond, "warning")) {
[17:42:19.336]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.336]                         if (muffled) 
[17:42:19.336]                           invokeRestart("muffleWarning")
[17:42:19.336]                       }
[17:42:19.336]                       else if (inherits(cond, "condition")) {
[17:42:19.336]                         if (!is.null(pattern)) {
[17:42:19.336]                           computeRestarts <- base::computeRestarts
[17:42:19.336]                           grepl <- base::grepl
[17:42:19.336]                           restarts <- computeRestarts(cond)
[17:42:19.336]                           for (restart in restarts) {
[17:42:19.336]                             name <- restart$name
[17:42:19.336]                             if (is.null(name)) 
[17:42:19.336]                               next
[17:42:19.336]                             if (!grepl(pattern, name)) 
[17:42:19.336]                               next
[17:42:19.336]                             invokeRestart(restart)
[17:42:19.336]                             muffled <- TRUE
[17:42:19.336]                             break
[17:42:19.336]                           }
[17:42:19.336]                         }
[17:42:19.336]                       }
[17:42:19.336]                       invisible(muffled)
[17:42:19.336]                     }
[17:42:19.336]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.336]                   }
[17:42:19.336]                 }
[17:42:19.336]             }
[17:42:19.336]         }))
[17:42:19.336]     }, error = function(ex) {
[17:42:19.336]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.336]                 ...future.rng), started = ...future.startTime, 
[17:42:19.336]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.336]             version = "1.8"), class = "FutureResult")
[17:42:19.336]     }, finally = {
[17:42:19.336]         if (!identical(...future.workdir, getwd())) 
[17:42:19.336]             setwd(...future.workdir)
[17:42:19.336]         {
[17:42:19.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.336]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.336]             }
[17:42:19.336]             base::options(...future.oldOptions)
[17:42:19.336]             if (.Platform$OS.type == "windows") {
[17:42:19.336]                 old_names <- names(...future.oldEnvVars)
[17:42:19.336]                 envs <- base::Sys.getenv()
[17:42:19.336]                 names <- names(envs)
[17:42:19.336]                 common <- intersect(names, old_names)
[17:42:19.336]                 added <- setdiff(names, old_names)
[17:42:19.336]                 removed <- setdiff(old_names, names)
[17:42:19.336]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.336]                   envs[common]]
[17:42:19.336]                 NAMES <- toupper(changed)
[17:42:19.336]                 args <- list()
[17:42:19.336]                 for (kk in seq_along(NAMES)) {
[17:42:19.336]                   name <- changed[[kk]]
[17:42:19.336]                   NAME <- NAMES[[kk]]
[17:42:19.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.336]                     next
[17:42:19.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.336]                 }
[17:42:19.336]                 NAMES <- toupper(added)
[17:42:19.336]                 for (kk in seq_along(NAMES)) {
[17:42:19.336]                   name <- added[[kk]]
[17:42:19.336]                   NAME <- NAMES[[kk]]
[17:42:19.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.336]                     next
[17:42:19.336]                   args[[name]] <- ""
[17:42:19.336]                 }
[17:42:19.336]                 NAMES <- toupper(removed)
[17:42:19.336]                 for (kk in seq_along(NAMES)) {
[17:42:19.336]                   name <- removed[[kk]]
[17:42:19.336]                   NAME <- NAMES[[kk]]
[17:42:19.336]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.336]                     next
[17:42:19.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.336]                 }
[17:42:19.336]                 if (length(args) > 0) 
[17:42:19.336]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.336]             }
[17:42:19.336]             else {
[17:42:19.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.336]             }
[17:42:19.336]             {
[17:42:19.336]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.336]                   0L) {
[17:42:19.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.336]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.336]                   base::options(opts)
[17:42:19.336]                 }
[17:42:19.336]                 {
[17:42:19.336]                   {
[17:42:19.336]                     NULL
[17:42:19.336]                     RNGkind("Mersenne-Twister")
[17:42:19.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.336]                       inherits = FALSE)
[17:42:19.336]                   }
[17:42:19.336]                   options(future.plan = NULL)
[17:42:19.336]                   if (is.na(NA_character_)) 
[17:42:19.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.336]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.336]                   {
[17:42:19.336]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.336]                     if (!future$lazy) 
[17:42:19.336]                       future <- run(future)
[17:42:19.336]                     invisible(future)
[17:42:19.336]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.336]                 }
[17:42:19.336]             }
[17:42:19.336]         }
[17:42:19.336]     })
[17:42:19.336]     if (TRUE) {
[17:42:19.336]         base::sink(type = "output", split = FALSE)
[17:42:19.336]         if (TRUE) {
[17:42:19.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.336]         }
[17:42:19.336]         else {
[17:42:19.336]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.336]         }
[17:42:19.336]         base::close(...future.stdout)
[17:42:19.336]         ...future.stdout <- NULL
[17:42:19.336]     }
[17:42:19.336]     ...future.result$conditions <- ...future.conditions
[17:42:19.336]     ...future.result$finished <- base::Sys.time()
[17:42:19.336]     ...future.result
[17:42:19.336] }
[17:42:19.338] plan(): Setting new future strategy stack:
[17:42:19.338] List of future strategies:
[17:42:19.338] 1. sequential:
[17:42:19.338]    - args: function (..., envir = parent.frame())
[17:42:19.338]    - tweaked: FALSE
[17:42:19.338]    - call: NULL
[17:42:19.338] plan(): nbrOfWorkers() = 1
[17:42:19.339] plan(): Setting new future strategy stack:
[17:42:19.339] List of future strategies:
[17:42:19.339] 1. sequential:
[17:42:19.339]    - args: function (..., envir = parent.frame())
[17:42:19.339]    - tweaked: FALSE
[17:42:19.339]    - call: plan(strategy)
[17:42:19.339] plan(): nbrOfWorkers() = 1
[17:42:19.340] SequentialFuture started (and completed)
[17:42:19.340] - Launch lazy future ... done
[17:42:19.340] run() for ‘SequentialFuture’ ... done
<environment: 0x55bef7588070> 
<environment: 0x55bef841a388> 
[17:42:19.341] resolved() for ‘SequentialFuture’ ...
[17:42:19.341] - state: ‘finished’
[17:42:19.341] - run: TRUE
[17:42:19.341] - result: ‘FutureResult’
[17:42:19.342] resolved() for ‘SequentialFuture’ ... done
[17:42:19.342] resolved() for ‘SequentialFuture’ ...
[17:42:19.342] - state: ‘finished’
[17:42:19.342] - run: TRUE
[17:42:19.342] - result: ‘FutureResult’
[17:42:19.342] resolved() for ‘SequentialFuture’ ... done
[17:42:19.342] resolved() for ‘SequentialFuture’ ...
[17:42:19.342] - state: ‘finished’
[17:42:19.342] - run: TRUE
[17:42:19.342] - result: ‘FutureResult’
[17:42:19.342] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:19.346] resolve() on environment ...
[17:42:19.346]  recursive: 0
[17:42:19.346]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:19.347] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.347] - nx: 4
[17:42:19.347] - relay: TRUE
[17:42:19.347] - stdout: TRUE
[17:42:19.347] - signal: TRUE
[17:42:19.347] - resignal: FALSE
[17:42:19.347] - force: TRUE
[17:42:19.347] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.347] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.347]  - until=2
[17:42:19.347]  - relaying element #2
[17:42:19.348] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.348] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.348] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.348]  length: 3 (resolved future 1)
[17:42:19.348] resolved() for ‘SequentialFuture’ ...
[17:42:19.348] - state: ‘finished’
[17:42:19.348] - run: TRUE
[17:42:19.348] - result: ‘FutureResult’
[17:42:19.348] resolved() for ‘SequentialFuture’ ... done
[17:42:19.348] Future #2
[17:42:19.349] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.349] - nx: 4
[17:42:19.349] - relay: TRUE
[17:42:19.349] - stdout: TRUE
[17:42:19.349] - signal: TRUE
[17:42:19.349] - resignal: FALSE
[17:42:19.349] - force: TRUE
[17:42:19.349] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.349] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.349]  - until=2
[17:42:19.349]  - relaying element #2
[17:42:19.350] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.350] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.350] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.350]  length: 2 (resolved future 2)
[17:42:19.350] resolved() for ‘SequentialFuture’ ...
[17:42:19.350] - state: ‘finished’
[17:42:19.350] - run: TRUE
[17:42:19.350] - result: ‘FutureResult’
[17:42:19.350] resolved() for ‘SequentialFuture’ ... done
[17:42:19.351] Future #3
[17:42:19.351] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.351] - nx: 4
[17:42:19.351] - relay: TRUE
[17:42:19.351] - stdout: TRUE
[17:42:19.351] - signal: TRUE
[17:42:19.351] - resignal: FALSE
[17:42:19.351] - force: TRUE
[17:42:19.351] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.351] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.352]  - until=3
[17:42:19.352]  - relaying element #3
[17:42:19.352] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.352] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.352] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.352]  length: 1 (resolved future 3)
[17:42:19.352] resolved() for ‘SequentialFuture’ ...
[17:42:19.352] - state: ‘finished’
[17:42:19.352] - run: TRUE
[17:42:19.352] - result: ‘FutureResult’
[17:42:19.353] resolved() for ‘SequentialFuture’ ... done
[17:42:19.353] Future #4
[17:42:19.353] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.353] - nx: 4
[17:42:19.353] - relay: TRUE
[17:42:19.353] - stdout: TRUE
[17:42:19.353] - signal: TRUE
[17:42:19.353] - resignal: FALSE
[17:42:19.353] - force: TRUE
[17:42:19.353] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.354] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.354]  - until=4
[17:42:19.354]  - relaying element #4
[17:42:19.354] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.354] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.354] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.354]  length: 0 (resolved future 4)
[17:42:19.354] Relaying remaining futures
[17:42:19.354] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.354] - nx: 4
[17:42:19.354] - relay: TRUE
[17:42:19.355] - stdout: TRUE
[17:42:19.355] - signal: TRUE
[17:42:19.355] - resignal: FALSE
[17:42:19.355] - force: TRUE
[17:42:19.355] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.355] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:19.355] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.355] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.355] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.355] resolve() on environment ... DONE
<environment: 0x55bef7543880> 
Dimensions: c(2, 3)
[17:42:19.356] getGlobalsAndPackages() ...
[17:42:19.356] Searching for globals...
[17:42:19.356] 
[17:42:19.356] Searching for globals ... DONE
[17:42:19.357] - globals: [0] <none>
[17:42:19.357] getGlobalsAndPackages() ... DONE
[17:42:19.357] run() for ‘Future’ ...
[17:42:19.357] - state: ‘created’
[17:42:19.357] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.358]   - Field: ‘label’
[17:42:19.358]   - Field: ‘local’
[17:42:19.358]   - Field: ‘owner’
[17:42:19.358]   - Field: ‘envir’
[17:42:19.358]   - Field: ‘packages’
[17:42:19.358]   - Field: ‘gc’
[17:42:19.358]   - Field: ‘conditions’
[17:42:19.358]   - Field: ‘expr’
[17:42:19.358]   - Field: ‘uuid’
[17:42:19.358]   - Field: ‘seed’
[17:42:19.359]   - Field: ‘version’
[17:42:19.359]   - Field: ‘result’
[17:42:19.359]   - Field: ‘asynchronous’
[17:42:19.359]   - Field: ‘calls’
[17:42:19.359]   - Field: ‘globals’
[17:42:19.359]   - Field: ‘stdout’
[17:42:19.359]   - Field: ‘earlySignal’
[17:42:19.359]   - Field: ‘lazy’
[17:42:19.359]   - Field: ‘state’
[17:42:19.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.359] - Launch lazy future ...
[17:42:19.360] Packages needed by the future expression (n = 0): <none>
[17:42:19.360] Packages needed by future strategies (n = 0): <none>
[17:42:19.360] {
[17:42:19.360]     {
[17:42:19.360]         {
[17:42:19.360]             ...future.startTime <- base::Sys.time()
[17:42:19.360]             {
[17:42:19.360]                 {
[17:42:19.360]                   {
[17:42:19.360]                     base::local({
[17:42:19.360]                       has_future <- base::requireNamespace("future", 
[17:42:19.360]                         quietly = TRUE)
[17:42:19.360]                       if (has_future) {
[17:42:19.360]                         ns <- base::getNamespace("future")
[17:42:19.360]                         version <- ns[[".package"]][["version"]]
[17:42:19.360]                         if (is.null(version)) 
[17:42:19.360]                           version <- utils::packageVersion("future")
[17:42:19.360]                       }
[17:42:19.360]                       else {
[17:42:19.360]                         version <- NULL
[17:42:19.360]                       }
[17:42:19.360]                       if (!has_future || version < "1.8.0") {
[17:42:19.360]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.360]                           "", base::R.version$version.string), 
[17:42:19.360]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.360]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.360]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.360]                             "release", "version")], collapse = " "), 
[17:42:19.360]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.360]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.360]                           info)
[17:42:19.360]                         info <- base::paste(info, collapse = "; ")
[17:42:19.360]                         if (!has_future) {
[17:42:19.360]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.360]                             info)
[17:42:19.360]                         }
[17:42:19.360]                         else {
[17:42:19.360]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.360]                             info, version)
[17:42:19.360]                         }
[17:42:19.360]                         base::stop(msg)
[17:42:19.360]                       }
[17:42:19.360]                     })
[17:42:19.360]                   }
[17:42:19.360]                   options(future.plan = NULL)
[17:42:19.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.360]                 }
[17:42:19.360]                 ...future.workdir <- getwd()
[17:42:19.360]             }
[17:42:19.360]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.360]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.360]         }
[17:42:19.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.360]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.360]             base::names(...future.oldOptions))
[17:42:19.360]     }
[17:42:19.360]     if (FALSE) {
[17:42:19.360]     }
[17:42:19.360]     else {
[17:42:19.360]         if (TRUE) {
[17:42:19.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.360]                 open = "w")
[17:42:19.360]         }
[17:42:19.360]         else {
[17:42:19.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.360]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.360]         }
[17:42:19.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.360]             base::sink(type = "output", split = FALSE)
[17:42:19.360]             base::close(...future.stdout)
[17:42:19.360]         }, add = TRUE)
[17:42:19.360]     }
[17:42:19.360]     ...future.frame <- base::sys.nframe()
[17:42:19.360]     ...future.conditions <- base::list()
[17:42:19.360]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.360]     if (FALSE) {
[17:42:19.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.360]     }
[17:42:19.360]     ...future.result <- base::tryCatch({
[17:42:19.360]         base::withCallingHandlers({
[17:42:19.360]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.360]             future::FutureResult(value = ...future.value$value, 
[17:42:19.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.360]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.360]                     ...future.globalenv.names))
[17:42:19.360]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.360]         }, condition = base::local({
[17:42:19.360]             c <- base::c
[17:42:19.360]             inherits <- base::inherits
[17:42:19.360]             invokeRestart <- base::invokeRestart
[17:42:19.360]             length <- base::length
[17:42:19.360]             list <- base::list
[17:42:19.360]             seq.int <- base::seq.int
[17:42:19.360]             signalCondition <- base::signalCondition
[17:42:19.360]             sys.calls <- base::sys.calls
[17:42:19.360]             `[[` <- base::`[[`
[17:42:19.360]             `+` <- base::`+`
[17:42:19.360]             `<<-` <- base::`<<-`
[17:42:19.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.360]                   3L)]
[17:42:19.360]             }
[17:42:19.360]             function(cond) {
[17:42:19.360]                 is_error <- inherits(cond, "error")
[17:42:19.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.360]                   NULL)
[17:42:19.360]                 if (is_error) {
[17:42:19.360]                   sessionInformation <- function() {
[17:42:19.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.360]                       search = base::search(), system = base::Sys.info())
[17:42:19.360]                   }
[17:42:19.360]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.360]                     cond$call), session = sessionInformation(), 
[17:42:19.360]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.360]                   signalCondition(cond)
[17:42:19.360]                 }
[17:42:19.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.360]                 "immediateCondition"))) {
[17:42:19.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.360]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.360]                   if (TRUE && !signal) {
[17:42:19.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.360]                     {
[17:42:19.360]                       inherits <- base::inherits
[17:42:19.360]                       invokeRestart <- base::invokeRestart
[17:42:19.360]                       is.null <- base::is.null
[17:42:19.360]                       muffled <- FALSE
[17:42:19.360]                       if (inherits(cond, "message")) {
[17:42:19.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.360]                         if (muffled) 
[17:42:19.360]                           invokeRestart("muffleMessage")
[17:42:19.360]                       }
[17:42:19.360]                       else if (inherits(cond, "warning")) {
[17:42:19.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.360]                         if (muffled) 
[17:42:19.360]                           invokeRestart("muffleWarning")
[17:42:19.360]                       }
[17:42:19.360]                       else if (inherits(cond, "condition")) {
[17:42:19.360]                         if (!is.null(pattern)) {
[17:42:19.360]                           computeRestarts <- base::computeRestarts
[17:42:19.360]                           grepl <- base::grepl
[17:42:19.360]                           restarts <- computeRestarts(cond)
[17:42:19.360]                           for (restart in restarts) {
[17:42:19.360]                             name <- restart$name
[17:42:19.360]                             if (is.null(name)) 
[17:42:19.360]                               next
[17:42:19.360]                             if (!grepl(pattern, name)) 
[17:42:19.360]                               next
[17:42:19.360]                             invokeRestart(restart)
[17:42:19.360]                             muffled <- TRUE
[17:42:19.360]                             break
[17:42:19.360]                           }
[17:42:19.360]                         }
[17:42:19.360]                       }
[17:42:19.360]                       invisible(muffled)
[17:42:19.360]                     }
[17:42:19.360]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.360]                   }
[17:42:19.360]                 }
[17:42:19.360]                 else {
[17:42:19.360]                   if (TRUE) {
[17:42:19.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.360]                     {
[17:42:19.360]                       inherits <- base::inherits
[17:42:19.360]                       invokeRestart <- base::invokeRestart
[17:42:19.360]                       is.null <- base::is.null
[17:42:19.360]                       muffled <- FALSE
[17:42:19.360]                       if (inherits(cond, "message")) {
[17:42:19.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.360]                         if (muffled) 
[17:42:19.360]                           invokeRestart("muffleMessage")
[17:42:19.360]                       }
[17:42:19.360]                       else if (inherits(cond, "warning")) {
[17:42:19.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.360]                         if (muffled) 
[17:42:19.360]                           invokeRestart("muffleWarning")
[17:42:19.360]                       }
[17:42:19.360]                       else if (inherits(cond, "condition")) {
[17:42:19.360]                         if (!is.null(pattern)) {
[17:42:19.360]                           computeRestarts <- base::computeRestarts
[17:42:19.360]                           grepl <- base::grepl
[17:42:19.360]                           restarts <- computeRestarts(cond)
[17:42:19.360]                           for (restart in restarts) {
[17:42:19.360]                             name <- restart$name
[17:42:19.360]                             if (is.null(name)) 
[17:42:19.360]                               next
[17:42:19.360]                             if (!grepl(pattern, name)) 
[17:42:19.360]                               next
[17:42:19.360]                             invokeRestart(restart)
[17:42:19.360]                             muffled <- TRUE
[17:42:19.360]                             break
[17:42:19.360]                           }
[17:42:19.360]                         }
[17:42:19.360]                       }
[17:42:19.360]                       invisible(muffled)
[17:42:19.360]                     }
[17:42:19.360]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.360]                   }
[17:42:19.360]                 }
[17:42:19.360]             }
[17:42:19.360]         }))
[17:42:19.360]     }, error = function(ex) {
[17:42:19.360]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.360]                 ...future.rng), started = ...future.startTime, 
[17:42:19.360]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.360]             version = "1.8"), class = "FutureResult")
[17:42:19.360]     }, finally = {
[17:42:19.360]         if (!identical(...future.workdir, getwd())) 
[17:42:19.360]             setwd(...future.workdir)
[17:42:19.360]         {
[17:42:19.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.360]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.360]             }
[17:42:19.360]             base::options(...future.oldOptions)
[17:42:19.360]             if (.Platform$OS.type == "windows") {
[17:42:19.360]                 old_names <- names(...future.oldEnvVars)
[17:42:19.360]                 envs <- base::Sys.getenv()
[17:42:19.360]                 names <- names(envs)
[17:42:19.360]                 common <- intersect(names, old_names)
[17:42:19.360]                 added <- setdiff(names, old_names)
[17:42:19.360]                 removed <- setdiff(old_names, names)
[17:42:19.360]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.360]                   envs[common]]
[17:42:19.360]                 NAMES <- toupper(changed)
[17:42:19.360]                 args <- list()
[17:42:19.360]                 for (kk in seq_along(NAMES)) {
[17:42:19.360]                   name <- changed[[kk]]
[17:42:19.360]                   NAME <- NAMES[[kk]]
[17:42:19.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.360]                     next
[17:42:19.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.360]                 }
[17:42:19.360]                 NAMES <- toupper(added)
[17:42:19.360]                 for (kk in seq_along(NAMES)) {
[17:42:19.360]                   name <- added[[kk]]
[17:42:19.360]                   NAME <- NAMES[[kk]]
[17:42:19.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.360]                     next
[17:42:19.360]                   args[[name]] <- ""
[17:42:19.360]                 }
[17:42:19.360]                 NAMES <- toupper(removed)
[17:42:19.360]                 for (kk in seq_along(NAMES)) {
[17:42:19.360]                   name <- removed[[kk]]
[17:42:19.360]                   NAME <- NAMES[[kk]]
[17:42:19.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.360]                     next
[17:42:19.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.360]                 }
[17:42:19.360]                 if (length(args) > 0) 
[17:42:19.360]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.360]             }
[17:42:19.360]             else {
[17:42:19.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.360]             }
[17:42:19.360]             {
[17:42:19.360]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.360]                   0L) {
[17:42:19.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.360]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.360]                   base::options(opts)
[17:42:19.360]                 }
[17:42:19.360]                 {
[17:42:19.360]                   {
[17:42:19.360]                     NULL
[17:42:19.360]                     RNGkind("Mersenne-Twister")
[17:42:19.360]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.360]                       inherits = FALSE)
[17:42:19.360]                   }
[17:42:19.360]                   options(future.plan = NULL)
[17:42:19.360]                   if (is.na(NA_character_)) 
[17:42:19.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.360]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.360]                   {
[17:42:19.360]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.360]                     if (!future$lazy) 
[17:42:19.360]                       future <- run(future)
[17:42:19.360]                     invisible(future)
[17:42:19.360]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.360]                 }
[17:42:19.360]             }
[17:42:19.360]         }
[17:42:19.360]     })
[17:42:19.360]     if (TRUE) {
[17:42:19.360]         base::sink(type = "output", split = FALSE)
[17:42:19.360]         if (TRUE) {
[17:42:19.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.360]         }
[17:42:19.360]         else {
[17:42:19.360]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.360]         }
[17:42:19.360]         base::close(...future.stdout)
[17:42:19.360]         ...future.stdout <- NULL
[17:42:19.360]     }
[17:42:19.360]     ...future.result$conditions <- ...future.conditions
[17:42:19.360]     ...future.result$finished <- base::Sys.time()
[17:42:19.360]     ...future.result
[17:42:19.360] }
[17:42:19.362] plan(): Setting new future strategy stack:
[17:42:19.362] List of future strategies:
[17:42:19.362] 1. sequential:
[17:42:19.362]    - args: function (..., envir = parent.frame())
[17:42:19.362]    - tweaked: FALSE
[17:42:19.362]    - call: NULL
[17:42:19.362] plan(): nbrOfWorkers() = 1
[17:42:19.363] plan(): Setting new future strategy stack:
[17:42:19.363] List of future strategies:
[17:42:19.363] 1. sequential:
[17:42:19.363]    - args: function (..., envir = parent.frame())
[17:42:19.363]    - tweaked: FALSE
[17:42:19.363]    - call: plan(strategy)
[17:42:19.364] plan(): nbrOfWorkers() = 1
[17:42:19.364] SequentialFuture started (and completed)
[17:42:19.364] - Launch lazy future ... done
[17:42:19.364] run() for ‘SequentialFuture’ ... done
[17:42:19.364] getGlobalsAndPackages() ...
[17:42:19.364] Searching for globals...
[17:42:19.365] 
[17:42:19.365] Searching for globals ... DONE
[17:42:19.365] - globals: [0] <none>
[17:42:19.365] getGlobalsAndPackages() ... DONE
[17:42:19.365] run() for ‘Future’ ...
[17:42:19.365] - state: ‘created’
[17:42:19.365] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.366] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.366]   - Field: ‘label’
[17:42:19.366]   - Field: ‘local’
[17:42:19.366]   - Field: ‘owner’
[17:42:19.366]   - Field: ‘envir’
[17:42:19.366]   - Field: ‘packages’
[17:42:19.366]   - Field: ‘gc’
[17:42:19.366]   - Field: ‘conditions’
[17:42:19.366]   - Field: ‘expr’
[17:42:19.367]   - Field: ‘uuid’
[17:42:19.367]   - Field: ‘seed’
[17:42:19.367]   - Field: ‘version’
[17:42:19.367]   - Field: ‘result’
[17:42:19.367]   - Field: ‘asynchronous’
[17:42:19.367]   - Field: ‘calls’
[17:42:19.367]   - Field: ‘globals’
[17:42:19.367]   - Field: ‘stdout’
[17:42:19.367]   - Field: ‘earlySignal’
[17:42:19.368]   - Field: ‘lazy’
[17:42:19.368]   - Field: ‘state’
[17:42:19.368] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.368] - Launch lazy future ...
[17:42:19.368] Packages needed by the future expression (n = 0): <none>
[17:42:19.368] Packages needed by future strategies (n = 0): <none>
[17:42:19.369] {
[17:42:19.369]     {
[17:42:19.369]         {
[17:42:19.369]             ...future.startTime <- base::Sys.time()
[17:42:19.369]             {
[17:42:19.369]                 {
[17:42:19.369]                   {
[17:42:19.369]                     base::local({
[17:42:19.369]                       has_future <- base::requireNamespace("future", 
[17:42:19.369]                         quietly = TRUE)
[17:42:19.369]                       if (has_future) {
[17:42:19.369]                         ns <- base::getNamespace("future")
[17:42:19.369]                         version <- ns[[".package"]][["version"]]
[17:42:19.369]                         if (is.null(version)) 
[17:42:19.369]                           version <- utils::packageVersion("future")
[17:42:19.369]                       }
[17:42:19.369]                       else {
[17:42:19.369]                         version <- NULL
[17:42:19.369]                       }
[17:42:19.369]                       if (!has_future || version < "1.8.0") {
[17:42:19.369]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.369]                           "", base::R.version$version.string), 
[17:42:19.369]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.369]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.369]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.369]                             "release", "version")], collapse = " "), 
[17:42:19.369]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.369]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.369]                           info)
[17:42:19.369]                         info <- base::paste(info, collapse = "; ")
[17:42:19.369]                         if (!has_future) {
[17:42:19.369]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.369]                             info)
[17:42:19.369]                         }
[17:42:19.369]                         else {
[17:42:19.369]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.369]                             info, version)
[17:42:19.369]                         }
[17:42:19.369]                         base::stop(msg)
[17:42:19.369]                       }
[17:42:19.369]                     })
[17:42:19.369]                   }
[17:42:19.369]                   options(future.plan = NULL)
[17:42:19.369]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.369]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.369]                 }
[17:42:19.369]                 ...future.workdir <- getwd()
[17:42:19.369]             }
[17:42:19.369]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.369]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.369]         }
[17:42:19.369]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.369]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.369]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.369]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.369]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.369]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.369]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.369]             base::names(...future.oldOptions))
[17:42:19.369]     }
[17:42:19.369]     if (FALSE) {
[17:42:19.369]     }
[17:42:19.369]     else {
[17:42:19.369]         if (TRUE) {
[17:42:19.369]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.369]                 open = "w")
[17:42:19.369]         }
[17:42:19.369]         else {
[17:42:19.369]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.369]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.369]         }
[17:42:19.369]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.369]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.369]             base::sink(type = "output", split = FALSE)
[17:42:19.369]             base::close(...future.stdout)
[17:42:19.369]         }, add = TRUE)
[17:42:19.369]     }
[17:42:19.369]     ...future.frame <- base::sys.nframe()
[17:42:19.369]     ...future.conditions <- base::list()
[17:42:19.369]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.369]     if (FALSE) {
[17:42:19.369]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.369]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.369]     }
[17:42:19.369]     ...future.result <- base::tryCatch({
[17:42:19.369]         base::withCallingHandlers({
[17:42:19.369]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.369]             future::FutureResult(value = ...future.value$value, 
[17:42:19.369]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.369]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.369]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.369]                     ...future.globalenv.names))
[17:42:19.369]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.369]         }, condition = base::local({
[17:42:19.369]             c <- base::c
[17:42:19.369]             inherits <- base::inherits
[17:42:19.369]             invokeRestart <- base::invokeRestart
[17:42:19.369]             length <- base::length
[17:42:19.369]             list <- base::list
[17:42:19.369]             seq.int <- base::seq.int
[17:42:19.369]             signalCondition <- base::signalCondition
[17:42:19.369]             sys.calls <- base::sys.calls
[17:42:19.369]             `[[` <- base::`[[`
[17:42:19.369]             `+` <- base::`+`
[17:42:19.369]             `<<-` <- base::`<<-`
[17:42:19.369]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.369]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.369]                   3L)]
[17:42:19.369]             }
[17:42:19.369]             function(cond) {
[17:42:19.369]                 is_error <- inherits(cond, "error")
[17:42:19.369]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.369]                   NULL)
[17:42:19.369]                 if (is_error) {
[17:42:19.369]                   sessionInformation <- function() {
[17:42:19.369]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.369]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.369]                       search = base::search(), system = base::Sys.info())
[17:42:19.369]                   }
[17:42:19.369]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.369]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.369]                     cond$call), session = sessionInformation(), 
[17:42:19.369]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.369]                   signalCondition(cond)
[17:42:19.369]                 }
[17:42:19.369]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.369]                 "immediateCondition"))) {
[17:42:19.369]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.369]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.369]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.369]                   if (TRUE && !signal) {
[17:42:19.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.369]                     {
[17:42:19.369]                       inherits <- base::inherits
[17:42:19.369]                       invokeRestart <- base::invokeRestart
[17:42:19.369]                       is.null <- base::is.null
[17:42:19.369]                       muffled <- FALSE
[17:42:19.369]                       if (inherits(cond, "message")) {
[17:42:19.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.369]                         if (muffled) 
[17:42:19.369]                           invokeRestart("muffleMessage")
[17:42:19.369]                       }
[17:42:19.369]                       else if (inherits(cond, "warning")) {
[17:42:19.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.369]                         if (muffled) 
[17:42:19.369]                           invokeRestart("muffleWarning")
[17:42:19.369]                       }
[17:42:19.369]                       else if (inherits(cond, "condition")) {
[17:42:19.369]                         if (!is.null(pattern)) {
[17:42:19.369]                           computeRestarts <- base::computeRestarts
[17:42:19.369]                           grepl <- base::grepl
[17:42:19.369]                           restarts <- computeRestarts(cond)
[17:42:19.369]                           for (restart in restarts) {
[17:42:19.369]                             name <- restart$name
[17:42:19.369]                             if (is.null(name)) 
[17:42:19.369]                               next
[17:42:19.369]                             if (!grepl(pattern, name)) 
[17:42:19.369]                               next
[17:42:19.369]                             invokeRestart(restart)
[17:42:19.369]                             muffled <- TRUE
[17:42:19.369]                             break
[17:42:19.369]                           }
[17:42:19.369]                         }
[17:42:19.369]                       }
[17:42:19.369]                       invisible(muffled)
[17:42:19.369]                     }
[17:42:19.369]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.369]                   }
[17:42:19.369]                 }
[17:42:19.369]                 else {
[17:42:19.369]                   if (TRUE) {
[17:42:19.369]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.369]                     {
[17:42:19.369]                       inherits <- base::inherits
[17:42:19.369]                       invokeRestart <- base::invokeRestart
[17:42:19.369]                       is.null <- base::is.null
[17:42:19.369]                       muffled <- FALSE
[17:42:19.369]                       if (inherits(cond, "message")) {
[17:42:19.369]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.369]                         if (muffled) 
[17:42:19.369]                           invokeRestart("muffleMessage")
[17:42:19.369]                       }
[17:42:19.369]                       else if (inherits(cond, "warning")) {
[17:42:19.369]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.369]                         if (muffled) 
[17:42:19.369]                           invokeRestart("muffleWarning")
[17:42:19.369]                       }
[17:42:19.369]                       else if (inherits(cond, "condition")) {
[17:42:19.369]                         if (!is.null(pattern)) {
[17:42:19.369]                           computeRestarts <- base::computeRestarts
[17:42:19.369]                           grepl <- base::grepl
[17:42:19.369]                           restarts <- computeRestarts(cond)
[17:42:19.369]                           for (restart in restarts) {
[17:42:19.369]                             name <- restart$name
[17:42:19.369]                             if (is.null(name)) 
[17:42:19.369]                               next
[17:42:19.369]                             if (!grepl(pattern, name)) 
[17:42:19.369]                               next
[17:42:19.369]                             invokeRestart(restart)
[17:42:19.369]                             muffled <- TRUE
[17:42:19.369]                             break
[17:42:19.369]                           }
[17:42:19.369]                         }
[17:42:19.369]                       }
[17:42:19.369]                       invisible(muffled)
[17:42:19.369]                     }
[17:42:19.369]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.369]                   }
[17:42:19.369]                 }
[17:42:19.369]             }
[17:42:19.369]         }))
[17:42:19.369]     }, error = function(ex) {
[17:42:19.369]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.369]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.369]                 ...future.rng), started = ...future.startTime, 
[17:42:19.369]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.369]             version = "1.8"), class = "FutureResult")
[17:42:19.369]     }, finally = {
[17:42:19.369]         if (!identical(...future.workdir, getwd())) 
[17:42:19.369]             setwd(...future.workdir)
[17:42:19.369]         {
[17:42:19.369]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.369]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.369]             }
[17:42:19.369]             base::options(...future.oldOptions)
[17:42:19.369]             if (.Platform$OS.type == "windows") {
[17:42:19.369]                 old_names <- names(...future.oldEnvVars)
[17:42:19.369]                 envs <- base::Sys.getenv()
[17:42:19.369]                 names <- names(envs)
[17:42:19.369]                 common <- intersect(names, old_names)
[17:42:19.369]                 added <- setdiff(names, old_names)
[17:42:19.369]                 removed <- setdiff(old_names, names)
[17:42:19.369]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.369]                   envs[common]]
[17:42:19.369]                 NAMES <- toupper(changed)
[17:42:19.369]                 args <- list()
[17:42:19.369]                 for (kk in seq_along(NAMES)) {
[17:42:19.369]                   name <- changed[[kk]]
[17:42:19.369]                   NAME <- NAMES[[kk]]
[17:42:19.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.369]                     next
[17:42:19.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.369]                 }
[17:42:19.369]                 NAMES <- toupper(added)
[17:42:19.369]                 for (kk in seq_along(NAMES)) {
[17:42:19.369]                   name <- added[[kk]]
[17:42:19.369]                   NAME <- NAMES[[kk]]
[17:42:19.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.369]                     next
[17:42:19.369]                   args[[name]] <- ""
[17:42:19.369]                 }
[17:42:19.369]                 NAMES <- toupper(removed)
[17:42:19.369]                 for (kk in seq_along(NAMES)) {
[17:42:19.369]                   name <- removed[[kk]]
[17:42:19.369]                   NAME <- NAMES[[kk]]
[17:42:19.369]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.369]                     next
[17:42:19.369]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.369]                 }
[17:42:19.369]                 if (length(args) > 0) 
[17:42:19.369]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.369]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.369]             }
[17:42:19.369]             else {
[17:42:19.369]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.369]             }
[17:42:19.369]             {
[17:42:19.369]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.369]                   0L) {
[17:42:19.369]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.369]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.369]                   base::options(opts)
[17:42:19.369]                 }
[17:42:19.369]                 {
[17:42:19.369]                   {
[17:42:19.369]                     NULL
[17:42:19.369]                     RNGkind("Mersenne-Twister")
[17:42:19.369]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.369]                       inherits = FALSE)
[17:42:19.369]                   }
[17:42:19.369]                   options(future.plan = NULL)
[17:42:19.369]                   if (is.na(NA_character_)) 
[17:42:19.369]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.369]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.369]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.369]                   {
[17:42:19.369]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.369]                     if (!future$lazy) 
[17:42:19.369]                       future <- run(future)
[17:42:19.369]                     invisible(future)
[17:42:19.369]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.369]                 }
[17:42:19.369]             }
[17:42:19.369]         }
[17:42:19.369]     })
[17:42:19.369]     if (TRUE) {
[17:42:19.369]         base::sink(type = "output", split = FALSE)
[17:42:19.369]         if (TRUE) {
[17:42:19.369]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.369]         }
[17:42:19.369]         else {
[17:42:19.369]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.369]         }
[17:42:19.369]         base::close(...future.stdout)
[17:42:19.369]         ...future.stdout <- NULL
[17:42:19.369]     }
[17:42:19.369]     ...future.result$conditions <- ...future.conditions
[17:42:19.369]     ...future.result$finished <- base::Sys.time()
[17:42:19.369]     ...future.result
[17:42:19.369] }
[17:42:19.370] plan(): Setting new future strategy stack:
[17:42:19.370] List of future strategies:
[17:42:19.370] 1. sequential:
[17:42:19.370]    - args: function (..., envir = parent.frame())
[17:42:19.370]    - tweaked: FALSE
[17:42:19.370]    - call: NULL
[17:42:19.371] plan(): nbrOfWorkers() = 1
[17:42:19.371] plan(): Setting new future strategy stack:
[17:42:19.372] List of future strategies:
[17:42:19.372] 1. sequential:
[17:42:19.372]    - args: function (..., envir = parent.frame())
[17:42:19.372]    - tweaked: FALSE
[17:42:19.372]    - call: plan(strategy)
[17:42:19.374] plan(): nbrOfWorkers() = 1
[17:42:19.374] SequentialFuture started (and completed)
[17:42:19.374] - Launch lazy future ... done
[17:42:19.374] run() for ‘SequentialFuture’ ... done
[17:42:19.375] getGlobalsAndPackages() ...
[17:42:19.375] Searching for globals...
[17:42:19.375] - globals found: [1] ‘{’
[17:42:19.375] Searching for globals ... DONE
[17:42:19.376] Resolving globals: FALSE
[17:42:19.376] 
[17:42:19.376] 
[17:42:19.376] getGlobalsAndPackages() ... DONE
[17:42:19.376] run() for ‘Future’ ...
[17:42:19.376] - state: ‘created’
[17:42:19.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.377] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.377]   - Field: ‘label’
[17:42:19.377]   - Field: ‘local’
[17:42:19.377]   - Field: ‘owner’
[17:42:19.377]   - Field: ‘envir’
[17:42:19.377]   - Field: ‘packages’
[17:42:19.377]   - Field: ‘gc’
[17:42:19.378]   - Field: ‘conditions’
[17:42:19.378]   - Field: ‘expr’
[17:42:19.378]   - Field: ‘uuid’
[17:42:19.378]   - Field: ‘seed’
[17:42:19.378]   - Field: ‘version’
[17:42:19.378]   - Field: ‘result’
[17:42:19.378]   - Field: ‘asynchronous’
[17:42:19.378]   - Field: ‘calls’
[17:42:19.378]   - Field: ‘globals’
[17:42:19.378]   - Field: ‘stdout’
[17:42:19.378]   - Field: ‘earlySignal’
[17:42:19.379]   - Field: ‘lazy’
[17:42:19.379]   - Field: ‘state’
[17:42:19.379] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.379] - Launch lazy future ...
[17:42:19.379] Packages needed by the future expression (n = 0): <none>
[17:42:19.379] Packages needed by future strategies (n = 0): <none>
[17:42:19.380] {
[17:42:19.380]     {
[17:42:19.380]         {
[17:42:19.380]             ...future.startTime <- base::Sys.time()
[17:42:19.380]             {
[17:42:19.380]                 {
[17:42:19.380]                   {
[17:42:19.380]                     base::local({
[17:42:19.380]                       has_future <- base::requireNamespace("future", 
[17:42:19.380]                         quietly = TRUE)
[17:42:19.380]                       if (has_future) {
[17:42:19.380]                         ns <- base::getNamespace("future")
[17:42:19.380]                         version <- ns[[".package"]][["version"]]
[17:42:19.380]                         if (is.null(version)) 
[17:42:19.380]                           version <- utils::packageVersion("future")
[17:42:19.380]                       }
[17:42:19.380]                       else {
[17:42:19.380]                         version <- NULL
[17:42:19.380]                       }
[17:42:19.380]                       if (!has_future || version < "1.8.0") {
[17:42:19.380]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.380]                           "", base::R.version$version.string), 
[17:42:19.380]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.380]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.380]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.380]                             "release", "version")], collapse = " "), 
[17:42:19.380]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.380]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.380]                           info)
[17:42:19.380]                         info <- base::paste(info, collapse = "; ")
[17:42:19.380]                         if (!has_future) {
[17:42:19.380]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.380]                             info)
[17:42:19.380]                         }
[17:42:19.380]                         else {
[17:42:19.380]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.380]                             info, version)
[17:42:19.380]                         }
[17:42:19.380]                         base::stop(msg)
[17:42:19.380]                       }
[17:42:19.380]                     })
[17:42:19.380]                   }
[17:42:19.380]                   options(future.plan = NULL)
[17:42:19.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.380]                 }
[17:42:19.380]                 ...future.workdir <- getwd()
[17:42:19.380]             }
[17:42:19.380]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.380]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.380]         }
[17:42:19.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.380]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.380]             base::names(...future.oldOptions))
[17:42:19.380]     }
[17:42:19.380]     if (FALSE) {
[17:42:19.380]     }
[17:42:19.380]     else {
[17:42:19.380]         if (TRUE) {
[17:42:19.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.380]                 open = "w")
[17:42:19.380]         }
[17:42:19.380]         else {
[17:42:19.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.380]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.380]         }
[17:42:19.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.380]             base::sink(type = "output", split = FALSE)
[17:42:19.380]             base::close(...future.stdout)
[17:42:19.380]         }, add = TRUE)
[17:42:19.380]     }
[17:42:19.380]     ...future.frame <- base::sys.nframe()
[17:42:19.380]     ...future.conditions <- base::list()
[17:42:19.380]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.380]     if (FALSE) {
[17:42:19.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.380]     }
[17:42:19.380]     ...future.result <- base::tryCatch({
[17:42:19.380]         base::withCallingHandlers({
[17:42:19.380]             ...future.value <- base::withVisible(base::local({
[17:42:19.380]                 4
[17:42:19.380]             }))
[17:42:19.380]             future::FutureResult(value = ...future.value$value, 
[17:42:19.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.380]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.380]                     ...future.globalenv.names))
[17:42:19.380]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.380]         }, condition = base::local({
[17:42:19.380]             c <- base::c
[17:42:19.380]             inherits <- base::inherits
[17:42:19.380]             invokeRestart <- base::invokeRestart
[17:42:19.380]             length <- base::length
[17:42:19.380]             list <- base::list
[17:42:19.380]             seq.int <- base::seq.int
[17:42:19.380]             signalCondition <- base::signalCondition
[17:42:19.380]             sys.calls <- base::sys.calls
[17:42:19.380]             `[[` <- base::`[[`
[17:42:19.380]             `+` <- base::`+`
[17:42:19.380]             `<<-` <- base::`<<-`
[17:42:19.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.380]                   3L)]
[17:42:19.380]             }
[17:42:19.380]             function(cond) {
[17:42:19.380]                 is_error <- inherits(cond, "error")
[17:42:19.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.380]                   NULL)
[17:42:19.380]                 if (is_error) {
[17:42:19.380]                   sessionInformation <- function() {
[17:42:19.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.380]                       search = base::search(), system = base::Sys.info())
[17:42:19.380]                   }
[17:42:19.380]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.380]                     cond$call), session = sessionInformation(), 
[17:42:19.380]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.380]                   signalCondition(cond)
[17:42:19.380]                 }
[17:42:19.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.380]                 "immediateCondition"))) {
[17:42:19.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.380]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.380]                   if (TRUE && !signal) {
[17:42:19.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.380]                     {
[17:42:19.380]                       inherits <- base::inherits
[17:42:19.380]                       invokeRestart <- base::invokeRestart
[17:42:19.380]                       is.null <- base::is.null
[17:42:19.380]                       muffled <- FALSE
[17:42:19.380]                       if (inherits(cond, "message")) {
[17:42:19.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.380]                         if (muffled) 
[17:42:19.380]                           invokeRestart("muffleMessage")
[17:42:19.380]                       }
[17:42:19.380]                       else if (inherits(cond, "warning")) {
[17:42:19.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.380]                         if (muffled) 
[17:42:19.380]                           invokeRestart("muffleWarning")
[17:42:19.380]                       }
[17:42:19.380]                       else if (inherits(cond, "condition")) {
[17:42:19.380]                         if (!is.null(pattern)) {
[17:42:19.380]                           computeRestarts <- base::computeRestarts
[17:42:19.380]                           grepl <- base::grepl
[17:42:19.380]                           restarts <- computeRestarts(cond)
[17:42:19.380]                           for (restart in restarts) {
[17:42:19.380]                             name <- restart$name
[17:42:19.380]                             if (is.null(name)) 
[17:42:19.380]                               next
[17:42:19.380]                             if (!grepl(pattern, name)) 
[17:42:19.380]                               next
[17:42:19.380]                             invokeRestart(restart)
[17:42:19.380]                             muffled <- TRUE
[17:42:19.380]                             break
[17:42:19.380]                           }
[17:42:19.380]                         }
[17:42:19.380]                       }
[17:42:19.380]                       invisible(muffled)
[17:42:19.380]                     }
[17:42:19.380]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.380]                   }
[17:42:19.380]                 }
[17:42:19.380]                 else {
[17:42:19.380]                   if (TRUE) {
[17:42:19.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.380]                     {
[17:42:19.380]                       inherits <- base::inherits
[17:42:19.380]                       invokeRestart <- base::invokeRestart
[17:42:19.380]                       is.null <- base::is.null
[17:42:19.380]                       muffled <- FALSE
[17:42:19.380]                       if (inherits(cond, "message")) {
[17:42:19.380]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.380]                         if (muffled) 
[17:42:19.380]                           invokeRestart("muffleMessage")
[17:42:19.380]                       }
[17:42:19.380]                       else if (inherits(cond, "warning")) {
[17:42:19.380]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.380]                         if (muffled) 
[17:42:19.380]                           invokeRestart("muffleWarning")
[17:42:19.380]                       }
[17:42:19.380]                       else if (inherits(cond, "condition")) {
[17:42:19.380]                         if (!is.null(pattern)) {
[17:42:19.380]                           computeRestarts <- base::computeRestarts
[17:42:19.380]                           grepl <- base::grepl
[17:42:19.380]                           restarts <- computeRestarts(cond)
[17:42:19.380]                           for (restart in restarts) {
[17:42:19.380]                             name <- restart$name
[17:42:19.380]                             if (is.null(name)) 
[17:42:19.380]                               next
[17:42:19.380]                             if (!grepl(pattern, name)) 
[17:42:19.380]                               next
[17:42:19.380]                             invokeRestart(restart)
[17:42:19.380]                             muffled <- TRUE
[17:42:19.380]                             break
[17:42:19.380]                           }
[17:42:19.380]                         }
[17:42:19.380]                       }
[17:42:19.380]                       invisible(muffled)
[17:42:19.380]                     }
[17:42:19.380]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.380]                   }
[17:42:19.380]                 }
[17:42:19.380]             }
[17:42:19.380]         }))
[17:42:19.380]     }, error = function(ex) {
[17:42:19.380]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.380]                 ...future.rng), started = ...future.startTime, 
[17:42:19.380]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.380]             version = "1.8"), class = "FutureResult")
[17:42:19.380]     }, finally = {
[17:42:19.380]         if (!identical(...future.workdir, getwd())) 
[17:42:19.380]             setwd(...future.workdir)
[17:42:19.380]         {
[17:42:19.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.380]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.380]             }
[17:42:19.380]             base::options(...future.oldOptions)
[17:42:19.380]             if (.Platform$OS.type == "windows") {
[17:42:19.380]                 old_names <- names(...future.oldEnvVars)
[17:42:19.380]                 envs <- base::Sys.getenv()
[17:42:19.380]                 names <- names(envs)
[17:42:19.380]                 common <- intersect(names, old_names)
[17:42:19.380]                 added <- setdiff(names, old_names)
[17:42:19.380]                 removed <- setdiff(old_names, names)
[17:42:19.380]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.380]                   envs[common]]
[17:42:19.380]                 NAMES <- toupper(changed)
[17:42:19.380]                 args <- list()
[17:42:19.380]                 for (kk in seq_along(NAMES)) {
[17:42:19.380]                   name <- changed[[kk]]
[17:42:19.380]                   NAME <- NAMES[[kk]]
[17:42:19.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.380]                     next
[17:42:19.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.380]                 }
[17:42:19.380]                 NAMES <- toupper(added)
[17:42:19.380]                 for (kk in seq_along(NAMES)) {
[17:42:19.380]                   name <- added[[kk]]
[17:42:19.380]                   NAME <- NAMES[[kk]]
[17:42:19.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.380]                     next
[17:42:19.380]                   args[[name]] <- ""
[17:42:19.380]                 }
[17:42:19.380]                 NAMES <- toupper(removed)
[17:42:19.380]                 for (kk in seq_along(NAMES)) {
[17:42:19.380]                   name <- removed[[kk]]
[17:42:19.380]                   NAME <- NAMES[[kk]]
[17:42:19.380]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.380]                     next
[17:42:19.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.380]                 }
[17:42:19.380]                 if (length(args) > 0) 
[17:42:19.380]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.380]             }
[17:42:19.380]             else {
[17:42:19.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.380]             }
[17:42:19.380]             {
[17:42:19.380]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.380]                   0L) {
[17:42:19.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.380]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.380]                   base::options(opts)
[17:42:19.380]                 }
[17:42:19.380]                 {
[17:42:19.380]                   {
[17:42:19.380]                     NULL
[17:42:19.380]                     RNGkind("Mersenne-Twister")
[17:42:19.380]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.380]                       inherits = FALSE)
[17:42:19.380]                   }
[17:42:19.380]                   options(future.plan = NULL)
[17:42:19.380]                   if (is.na(NA_character_)) 
[17:42:19.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.380]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.380]                   {
[17:42:19.380]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.380]                     if (!future$lazy) 
[17:42:19.380]                       future <- run(future)
[17:42:19.380]                     invisible(future)
[17:42:19.380]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.380]                 }
[17:42:19.380]             }
[17:42:19.380]         }
[17:42:19.380]     })
[17:42:19.380]     if (TRUE) {
[17:42:19.380]         base::sink(type = "output", split = FALSE)
[17:42:19.380]         if (TRUE) {
[17:42:19.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.380]         }
[17:42:19.380]         else {
[17:42:19.380]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.380]         }
[17:42:19.380]         base::close(...future.stdout)
[17:42:19.380]         ...future.stdout <- NULL
[17:42:19.380]     }
[17:42:19.380]     ...future.result$conditions <- ...future.conditions
[17:42:19.380]     ...future.result$finished <- base::Sys.time()
[17:42:19.380]     ...future.result
[17:42:19.380] }
[17:42:19.381] plan(): Setting new future strategy stack:
[17:42:19.381] List of future strategies:
[17:42:19.381] 1. sequential:
[17:42:19.381]    - args: function (..., envir = parent.frame())
[17:42:19.381]    - tweaked: FALSE
[17:42:19.381]    - call: NULL
[17:42:19.382] plan(): nbrOfWorkers() = 1
[17:42:19.383] plan(): Setting new future strategy stack:
[17:42:19.383] List of future strategies:
[17:42:19.383] 1. sequential:
[17:42:19.383]    - args: function (..., envir = parent.frame())
[17:42:19.383]    - tweaked: FALSE
[17:42:19.383]    - call: plan(strategy)
[17:42:19.383] plan(): nbrOfWorkers() = 1
[17:42:19.383] SequentialFuture started (and completed)
[17:42:19.383] - Launch lazy future ... done
[17:42:19.383] run() for ‘SequentialFuture’ ... done
<environment: 0x55bef7d992b0> 
<environment: 0x55bef79c5878> 
[17:42:19.385] resolved() for ‘SequentialFuture’ ...
[17:42:19.385] - state: ‘finished’
[17:42:19.385] - run: TRUE
[17:42:19.385] - result: ‘FutureResult’
[17:42:19.385] resolved() for ‘SequentialFuture’ ... done
[17:42:19.385] resolved() for ‘SequentialFuture’ ...
[17:42:19.385] - state: ‘finished’
[17:42:19.385] - run: TRUE
[17:42:19.385] - result: ‘FutureResult’
[17:42:19.386] resolved() for ‘SequentialFuture’ ... done
[17:42:19.386] resolved() for ‘SequentialFuture’ ...
[17:42:19.386] - state: ‘finished’
[17:42:19.386] - run: TRUE
[17:42:19.386] - result: ‘FutureResult’
[17:42:19.386] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:19.387] resolve() on environment ...
[17:42:19.387]  recursive: 0
[17:42:19.388]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:19.388] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.388] - nx: 4
[17:42:19.388] - relay: TRUE
[17:42:19.388] - stdout: TRUE
[17:42:19.388] - signal: TRUE
[17:42:19.388] - resignal: FALSE
[17:42:19.388] - force: TRUE
[17:42:19.388] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.389] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.389]  - until=2
[17:42:19.389]  - relaying element #2
[17:42:19.389] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.389] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.389] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.389]  length: 3 (resolved future 1)
[17:42:19.389] resolved() for ‘SequentialFuture’ ...
[17:42:19.389] - state: ‘finished’
[17:42:19.389] - run: TRUE
[17:42:19.389] - result: ‘FutureResult’
[17:42:19.390] resolved() for ‘SequentialFuture’ ... done
[17:42:19.390] Future #2
[17:42:19.390] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.390] - nx: 4
[17:42:19.390] - relay: TRUE
[17:42:19.390] - stdout: TRUE
[17:42:19.390] - signal: TRUE
[17:42:19.390] - resignal: FALSE
[17:42:19.390] - force: TRUE
[17:42:19.390] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.390] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.391]  - until=2
[17:42:19.391]  - relaying element #2
[17:42:19.391] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.391] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.391] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.391]  length: 2 (resolved future 2)
[17:42:19.391] resolved() for ‘SequentialFuture’ ...
[17:42:19.391] - state: ‘finished’
[17:42:19.391] - run: TRUE
[17:42:19.392] - result: ‘FutureResult’
[17:42:19.392] resolved() for ‘SequentialFuture’ ... done
[17:42:19.392] Future #3
[17:42:19.392] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.392] - nx: 4
[17:42:19.392] - relay: TRUE
[17:42:19.392] - stdout: TRUE
[17:42:19.392] - signal: TRUE
[17:42:19.392] - resignal: FALSE
[17:42:19.392] - force: TRUE
[17:42:19.392] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.393] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.393]  - until=3
[17:42:19.393]  - relaying element #3
[17:42:19.393] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.393] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.393] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.393]  length: 1 (resolved future 3)
[17:42:19.393] resolved() for ‘SequentialFuture’ ...
[17:42:19.393] - state: ‘finished’
[17:42:19.393] - run: TRUE
[17:42:19.394] - result: ‘FutureResult’
[17:42:19.394] resolved() for ‘SequentialFuture’ ... done
[17:42:19.394] Future #4
[17:42:19.394] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.394] - nx: 4
[17:42:19.394] - relay: TRUE
[17:42:19.394] - stdout: TRUE
[17:42:19.394] - signal: TRUE
[17:42:19.394] - resignal: FALSE
[17:42:19.394] - force: TRUE
[17:42:19.394] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.394] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.395]  - until=4
[17:42:19.395]  - relaying element #4
[17:42:19.395] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.395] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.395] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.395]  length: 0 (resolved future 4)
[17:42:19.395] Relaying remaining futures
[17:42:19.395] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.395] - nx: 4
[17:42:19.395] - relay: TRUE
[17:42:19.396] - stdout: TRUE
[17:42:19.396] - signal: TRUE
[17:42:19.396] - resignal: FALSE
[17:42:19.396] - force: TRUE
[17:42:19.396] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.396] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:19.396] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.396] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.396] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.396] resolve() on environment ... DONE
<environment: 0x55bef7ddf348> 
Dimensions: c(2, 3, 1)
[17:42:19.397] getGlobalsAndPackages() ...
[17:42:19.397] Searching for globals...
[17:42:19.397] 
[17:42:19.397] Searching for globals ... DONE
[17:42:19.397] - globals: [0] <none>
[17:42:19.398] getGlobalsAndPackages() ... DONE
[17:42:19.398] run() for ‘Future’ ...
[17:42:19.398] - state: ‘created’
[17:42:19.398] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.400] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.400]   - Field: ‘label’
[17:42:19.400]   - Field: ‘local’
[17:42:19.400]   - Field: ‘owner’
[17:42:19.400]   - Field: ‘envir’
[17:42:19.401]   - Field: ‘packages’
[17:42:19.401]   - Field: ‘gc’
[17:42:19.401]   - Field: ‘conditions’
[17:42:19.401]   - Field: ‘expr’
[17:42:19.401]   - Field: ‘uuid’
[17:42:19.401]   - Field: ‘seed’
[17:42:19.401]   - Field: ‘version’
[17:42:19.401]   - Field: ‘result’
[17:42:19.401]   - Field: ‘asynchronous’
[17:42:19.401]   - Field: ‘calls’
[17:42:19.401]   - Field: ‘globals’
[17:42:19.402]   - Field: ‘stdout’
[17:42:19.402]   - Field: ‘earlySignal’
[17:42:19.402]   - Field: ‘lazy’
[17:42:19.402]   - Field: ‘state’
[17:42:19.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.402] - Launch lazy future ...
[17:42:19.402] Packages needed by the future expression (n = 0): <none>
[17:42:19.402] Packages needed by future strategies (n = 0): <none>
[17:42:19.403] {
[17:42:19.403]     {
[17:42:19.403]         {
[17:42:19.403]             ...future.startTime <- base::Sys.time()
[17:42:19.403]             {
[17:42:19.403]                 {
[17:42:19.403]                   {
[17:42:19.403]                     base::local({
[17:42:19.403]                       has_future <- base::requireNamespace("future", 
[17:42:19.403]                         quietly = TRUE)
[17:42:19.403]                       if (has_future) {
[17:42:19.403]                         ns <- base::getNamespace("future")
[17:42:19.403]                         version <- ns[[".package"]][["version"]]
[17:42:19.403]                         if (is.null(version)) 
[17:42:19.403]                           version <- utils::packageVersion("future")
[17:42:19.403]                       }
[17:42:19.403]                       else {
[17:42:19.403]                         version <- NULL
[17:42:19.403]                       }
[17:42:19.403]                       if (!has_future || version < "1.8.0") {
[17:42:19.403]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.403]                           "", base::R.version$version.string), 
[17:42:19.403]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.403]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.403]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.403]                             "release", "version")], collapse = " "), 
[17:42:19.403]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.403]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.403]                           info)
[17:42:19.403]                         info <- base::paste(info, collapse = "; ")
[17:42:19.403]                         if (!has_future) {
[17:42:19.403]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.403]                             info)
[17:42:19.403]                         }
[17:42:19.403]                         else {
[17:42:19.403]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.403]                             info, version)
[17:42:19.403]                         }
[17:42:19.403]                         base::stop(msg)
[17:42:19.403]                       }
[17:42:19.403]                     })
[17:42:19.403]                   }
[17:42:19.403]                   options(future.plan = NULL)
[17:42:19.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.403]                 }
[17:42:19.403]                 ...future.workdir <- getwd()
[17:42:19.403]             }
[17:42:19.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.403]         }
[17:42:19.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.403]             base::names(...future.oldOptions))
[17:42:19.403]     }
[17:42:19.403]     if (FALSE) {
[17:42:19.403]     }
[17:42:19.403]     else {
[17:42:19.403]         if (TRUE) {
[17:42:19.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.403]                 open = "w")
[17:42:19.403]         }
[17:42:19.403]         else {
[17:42:19.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.403]         }
[17:42:19.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.403]             base::sink(type = "output", split = FALSE)
[17:42:19.403]             base::close(...future.stdout)
[17:42:19.403]         }, add = TRUE)
[17:42:19.403]     }
[17:42:19.403]     ...future.frame <- base::sys.nframe()
[17:42:19.403]     ...future.conditions <- base::list()
[17:42:19.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.403]     if (FALSE) {
[17:42:19.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.403]     }
[17:42:19.403]     ...future.result <- base::tryCatch({
[17:42:19.403]         base::withCallingHandlers({
[17:42:19.403]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.403]             future::FutureResult(value = ...future.value$value, 
[17:42:19.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.403]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.403]                     ...future.globalenv.names))
[17:42:19.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.403]         }, condition = base::local({
[17:42:19.403]             c <- base::c
[17:42:19.403]             inherits <- base::inherits
[17:42:19.403]             invokeRestart <- base::invokeRestart
[17:42:19.403]             length <- base::length
[17:42:19.403]             list <- base::list
[17:42:19.403]             seq.int <- base::seq.int
[17:42:19.403]             signalCondition <- base::signalCondition
[17:42:19.403]             sys.calls <- base::sys.calls
[17:42:19.403]             `[[` <- base::`[[`
[17:42:19.403]             `+` <- base::`+`
[17:42:19.403]             `<<-` <- base::`<<-`
[17:42:19.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.403]                   3L)]
[17:42:19.403]             }
[17:42:19.403]             function(cond) {
[17:42:19.403]                 is_error <- inherits(cond, "error")
[17:42:19.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.403]                   NULL)
[17:42:19.403]                 if (is_error) {
[17:42:19.403]                   sessionInformation <- function() {
[17:42:19.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.403]                       search = base::search(), system = base::Sys.info())
[17:42:19.403]                   }
[17:42:19.403]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.403]                     cond$call), session = sessionInformation(), 
[17:42:19.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.403]                   signalCondition(cond)
[17:42:19.403]                 }
[17:42:19.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.403]                 "immediateCondition"))) {
[17:42:19.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.403]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.403]                   if (TRUE && !signal) {
[17:42:19.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.403]                     {
[17:42:19.403]                       inherits <- base::inherits
[17:42:19.403]                       invokeRestart <- base::invokeRestart
[17:42:19.403]                       is.null <- base::is.null
[17:42:19.403]                       muffled <- FALSE
[17:42:19.403]                       if (inherits(cond, "message")) {
[17:42:19.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.403]                         if (muffled) 
[17:42:19.403]                           invokeRestart("muffleMessage")
[17:42:19.403]                       }
[17:42:19.403]                       else if (inherits(cond, "warning")) {
[17:42:19.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.403]                         if (muffled) 
[17:42:19.403]                           invokeRestart("muffleWarning")
[17:42:19.403]                       }
[17:42:19.403]                       else if (inherits(cond, "condition")) {
[17:42:19.403]                         if (!is.null(pattern)) {
[17:42:19.403]                           computeRestarts <- base::computeRestarts
[17:42:19.403]                           grepl <- base::grepl
[17:42:19.403]                           restarts <- computeRestarts(cond)
[17:42:19.403]                           for (restart in restarts) {
[17:42:19.403]                             name <- restart$name
[17:42:19.403]                             if (is.null(name)) 
[17:42:19.403]                               next
[17:42:19.403]                             if (!grepl(pattern, name)) 
[17:42:19.403]                               next
[17:42:19.403]                             invokeRestart(restart)
[17:42:19.403]                             muffled <- TRUE
[17:42:19.403]                             break
[17:42:19.403]                           }
[17:42:19.403]                         }
[17:42:19.403]                       }
[17:42:19.403]                       invisible(muffled)
[17:42:19.403]                     }
[17:42:19.403]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.403]                   }
[17:42:19.403]                 }
[17:42:19.403]                 else {
[17:42:19.403]                   if (TRUE) {
[17:42:19.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.403]                     {
[17:42:19.403]                       inherits <- base::inherits
[17:42:19.403]                       invokeRestart <- base::invokeRestart
[17:42:19.403]                       is.null <- base::is.null
[17:42:19.403]                       muffled <- FALSE
[17:42:19.403]                       if (inherits(cond, "message")) {
[17:42:19.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.403]                         if (muffled) 
[17:42:19.403]                           invokeRestart("muffleMessage")
[17:42:19.403]                       }
[17:42:19.403]                       else if (inherits(cond, "warning")) {
[17:42:19.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.403]                         if (muffled) 
[17:42:19.403]                           invokeRestart("muffleWarning")
[17:42:19.403]                       }
[17:42:19.403]                       else if (inherits(cond, "condition")) {
[17:42:19.403]                         if (!is.null(pattern)) {
[17:42:19.403]                           computeRestarts <- base::computeRestarts
[17:42:19.403]                           grepl <- base::grepl
[17:42:19.403]                           restarts <- computeRestarts(cond)
[17:42:19.403]                           for (restart in restarts) {
[17:42:19.403]                             name <- restart$name
[17:42:19.403]                             if (is.null(name)) 
[17:42:19.403]                               next
[17:42:19.403]                             if (!grepl(pattern, name)) 
[17:42:19.403]                               next
[17:42:19.403]                             invokeRestart(restart)
[17:42:19.403]                             muffled <- TRUE
[17:42:19.403]                             break
[17:42:19.403]                           }
[17:42:19.403]                         }
[17:42:19.403]                       }
[17:42:19.403]                       invisible(muffled)
[17:42:19.403]                     }
[17:42:19.403]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.403]                   }
[17:42:19.403]                 }
[17:42:19.403]             }
[17:42:19.403]         }))
[17:42:19.403]     }, error = function(ex) {
[17:42:19.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.403]                 ...future.rng), started = ...future.startTime, 
[17:42:19.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.403]             version = "1.8"), class = "FutureResult")
[17:42:19.403]     }, finally = {
[17:42:19.403]         if (!identical(...future.workdir, getwd())) 
[17:42:19.403]             setwd(...future.workdir)
[17:42:19.403]         {
[17:42:19.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.403]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.403]             }
[17:42:19.403]             base::options(...future.oldOptions)
[17:42:19.403]             if (.Platform$OS.type == "windows") {
[17:42:19.403]                 old_names <- names(...future.oldEnvVars)
[17:42:19.403]                 envs <- base::Sys.getenv()
[17:42:19.403]                 names <- names(envs)
[17:42:19.403]                 common <- intersect(names, old_names)
[17:42:19.403]                 added <- setdiff(names, old_names)
[17:42:19.403]                 removed <- setdiff(old_names, names)
[17:42:19.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.403]                   envs[common]]
[17:42:19.403]                 NAMES <- toupper(changed)
[17:42:19.403]                 args <- list()
[17:42:19.403]                 for (kk in seq_along(NAMES)) {
[17:42:19.403]                   name <- changed[[kk]]
[17:42:19.403]                   NAME <- NAMES[[kk]]
[17:42:19.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.403]                     next
[17:42:19.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.403]                 }
[17:42:19.403]                 NAMES <- toupper(added)
[17:42:19.403]                 for (kk in seq_along(NAMES)) {
[17:42:19.403]                   name <- added[[kk]]
[17:42:19.403]                   NAME <- NAMES[[kk]]
[17:42:19.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.403]                     next
[17:42:19.403]                   args[[name]] <- ""
[17:42:19.403]                 }
[17:42:19.403]                 NAMES <- toupper(removed)
[17:42:19.403]                 for (kk in seq_along(NAMES)) {
[17:42:19.403]                   name <- removed[[kk]]
[17:42:19.403]                   NAME <- NAMES[[kk]]
[17:42:19.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.403]                     next
[17:42:19.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.403]                 }
[17:42:19.403]                 if (length(args) > 0) 
[17:42:19.403]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.403]             }
[17:42:19.403]             else {
[17:42:19.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.403]             }
[17:42:19.403]             {
[17:42:19.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.403]                   0L) {
[17:42:19.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.403]                   base::options(opts)
[17:42:19.403]                 }
[17:42:19.403]                 {
[17:42:19.403]                   {
[17:42:19.403]                     NULL
[17:42:19.403]                     RNGkind("Mersenne-Twister")
[17:42:19.403]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.403]                       inherits = FALSE)
[17:42:19.403]                   }
[17:42:19.403]                   options(future.plan = NULL)
[17:42:19.403]                   if (is.na(NA_character_)) 
[17:42:19.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.403]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.403]                   {
[17:42:19.403]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.403]                     if (!future$lazy) 
[17:42:19.403]                       future <- run(future)
[17:42:19.403]                     invisible(future)
[17:42:19.403]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.403]                 }
[17:42:19.403]             }
[17:42:19.403]         }
[17:42:19.403]     })
[17:42:19.403]     if (TRUE) {
[17:42:19.403]         base::sink(type = "output", split = FALSE)
[17:42:19.403]         if (TRUE) {
[17:42:19.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.403]         }
[17:42:19.403]         else {
[17:42:19.403]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.403]         }
[17:42:19.403]         base::close(...future.stdout)
[17:42:19.403]         ...future.stdout <- NULL
[17:42:19.403]     }
[17:42:19.403]     ...future.result$conditions <- ...future.conditions
[17:42:19.403]     ...future.result$finished <- base::Sys.time()
[17:42:19.403]     ...future.result
[17:42:19.403] }
[17:42:19.405] plan(): Setting new future strategy stack:
[17:42:19.405] List of future strategies:
[17:42:19.405] 1. sequential:
[17:42:19.405]    - args: function (..., envir = parent.frame())
[17:42:19.405]    - tweaked: FALSE
[17:42:19.405]    - call: NULL
[17:42:19.405] plan(): nbrOfWorkers() = 1
[17:42:19.406] plan(): Setting new future strategy stack:
[17:42:19.406] List of future strategies:
[17:42:19.406] 1. sequential:
[17:42:19.406]    - args: function (..., envir = parent.frame())
[17:42:19.406]    - tweaked: FALSE
[17:42:19.406]    - call: plan(strategy)
[17:42:19.406] plan(): nbrOfWorkers() = 1
[17:42:19.406] SequentialFuture started (and completed)
[17:42:19.407] - Launch lazy future ... done
[17:42:19.407] run() for ‘SequentialFuture’ ... done
[17:42:19.407] getGlobalsAndPackages() ...
[17:42:19.407] Searching for globals...
[17:42:19.407] 
[17:42:19.407] Searching for globals ... DONE
[17:42:19.407] - globals: [0] <none>
[17:42:19.408] getGlobalsAndPackages() ... DONE
[17:42:19.408] run() for ‘Future’ ...
[17:42:19.408] - state: ‘created’
[17:42:19.408] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.409]   - Field: ‘label’
[17:42:19.409]   - Field: ‘local’
[17:42:19.409]   - Field: ‘owner’
[17:42:19.409]   - Field: ‘envir’
[17:42:19.409]   - Field: ‘packages’
[17:42:19.409]   - Field: ‘gc’
[17:42:19.409]   - Field: ‘conditions’
[17:42:19.409]   - Field: ‘expr’
[17:42:19.409]   - Field: ‘uuid’
[17:42:19.409]   - Field: ‘seed’
[17:42:19.409]   - Field: ‘version’
[17:42:19.410]   - Field: ‘result’
[17:42:19.410]   - Field: ‘asynchronous’
[17:42:19.410]   - Field: ‘calls’
[17:42:19.410]   - Field: ‘globals’
[17:42:19.410]   - Field: ‘stdout’
[17:42:19.410]   - Field: ‘earlySignal’
[17:42:19.410]   - Field: ‘lazy’
[17:42:19.410]   - Field: ‘state’
[17:42:19.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.410] - Launch lazy future ...
[17:42:19.411] Packages needed by the future expression (n = 0): <none>
[17:42:19.411] Packages needed by future strategies (n = 0): <none>
[17:42:19.411] {
[17:42:19.411]     {
[17:42:19.411]         {
[17:42:19.411]             ...future.startTime <- base::Sys.time()
[17:42:19.411]             {
[17:42:19.411]                 {
[17:42:19.411]                   {
[17:42:19.411]                     base::local({
[17:42:19.411]                       has_future <- base::requireNamespace("future", 
[17:42:19.411]                         quietly = TRUE)
[17:42:19.411]                       if (has_future) {
[17:42:19.411]                         ns <- base::getNamespace("future")
[17:42:19.411]                         version <- ns[[".package"]][["version"]]
[17:42:19.411]                         if (is.null(version)) 
[17:42:19.411]                           version <- utils::packageVersion("future")
[17:42:19.411]                       }
[17:42:19.411]                       else {
[17:42:19.411]                         version <- NULL
[17:42:19.411]                       }
[17:42:19.411]                       if (!has_future || version < "1.8.0") {
[17:42:19.411]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.411]                           "", base::R.version$version.string), 
[17:42:19.411]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.411]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.411]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.411]                             "release", "version")], collapse = " "), 
[17:42:19.411]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.411]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.411]                           info)
[17:42:19.411]                         info <- base::paste(info, collapse = "; ")
[17:42:19.411]                         if (!has_future) {
[17:42:19.411]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.411]                             info)
[17:42:19.411]                         }
[17:42:19.411]                         else {
[17:42:19.411]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.411]                             info, version)
[17:42:19.411]                         }
[17:42:19.411]                         base::stop(msg)
[17:42:19.411]                       }
[17:42:19.411]                     })
[17:42:19.411]                   }
[17:42:19.411]                   options(future.plan = NULL)
[17:42:19.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.411]                 }
[17:42:19.411]                 ...future.workdir <- getwd()
[17:42:19.411]             }
[17:42:19.411]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.411]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.411]         }
[17:42:19.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.411]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.411]             base::names(...future.oldOptions))
[17:42:19.411]     }
[17:42:19.411]     if (FALSE) {
[17:42:19.411]     }
[17:42:19.411]     else {
[17:42:19.411]         if (TRUE) {
[17:42:19.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.411]                 open = "w")
[17:42:19.411]         }
[17:42:19.411]         else {
[17:42:19.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.411]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.411]         }
[17:42:19.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.411]             base::sink(type = "output", split = FALSE)
[17:42:19.411]             base::close(...future.stdout)
[17:42:19.411]         }, add = TRUE)
[17:42:19.411]     }
[17:42:19.411]     ...future.frame <- base::sys.nframe()
[17:42:19.411]     ...future.conditions <- base::list()
[17:42:19.411]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.411]     if (FALSE) {
[17:42:19.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.411]     }
[17:42:19.411]     ...future.result <- base::tryCatch({
[17:42:19.411]         base::withCallingHandlers({
[17:42:19.411]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.411]             future::FutureResult(value = ...future.value$value, 
[17:42:19.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.411]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.411]                     ...future.globalenv.names))
[17:42:19.411]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.411]         }, condition = base::local({
[17:42:19.411]             c <- base::c
[17:42:19.411]             inherits <- base::inherits
[17:42:19.411]             invokeRestart <- base::invokeRestart
[17:42:19.411]             length <- base::length
[17:42:19.411]             list <- base::list
[17:42:19.411]             seq.int <- base::seq.int
[17:42:19.411]             signalCondition <- base::signalCondition
[17:42:19.411]             sys.calls <- base::sys.calls
[17:42:19.411]             `[[` <- base::`[[`
[17:42:19.411]             `+` <- base::`+`
[17:42:19.411]             `<<-` <- base::`<<-`
[17:42:19.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.411]                   3L)]
[17:42:19.411]             }
[17:42:19.411]             function(cond) {
[17:42:19.411]                 is_error <- inherits(cond, "error")
[17:42:19.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.411]                   NULL)
[17:42:19.411]                 if (is_error) {
[17:42:19.411]                   sessionInformation <- function() {
[17:42:19.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.411]                       search = base::search(), system = base::Sys.info())
[17:42:19.411]                   }
[17:42:19.411]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.411]                     cond$call), session = sessionInformation(), 
[17:42:19.411]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.411]                   signalCondition(cond)
[17:42:19.411]                 }
[17:42:19.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.411]                 "immediateCondition"))) {
[17:42:19.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.411]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.411]                   if (TRUE && !signal) {
[17:42:19.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.411]                     {
[17:42:19.411]                       inherits <- base::inherits
[17:42:19.411]                       invokeRestart <- base::invokeRestart
[17:42:19.411]                       is.null <- base::is.null
[17:42:19.411]                       muffled <- FALSE
[17:42:19.411]                       if (inherits(cond, "message")) {
[17:42:19.411]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.411]                         if (muffled) 
[17:42:19.411]                           invokeRestart("muffleMessage")
[17:42:19.411]                       }
[17:42:19.411]                       else if (inherits(cond, "warning")) {
[17:42:19.411]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.411]                         if (muffled) 
[17:42:19.411]                           invokeRestart("muffleWarning")
[17:42:19.411]                       }
[17:42:19.411]                       else if (inherits(cond, "condition")) {
[17:42:19.411]                         if (!is.null(pattern)) {
[17:42:19.411]                           computeRestarts <- base::computeRestarts
[17:42:19.411]                           grepl <- base::grepl
[17:42:19.411]                           restarts <- computeRestarts(cond)
[17:42:19.411]                           for (restart in restarts) {
[17:42:19.411]                             name <- restart$name
[17:42:19.411]                             if (is.null(name)) 
[17:42:19.411]                               next
[17:42:19.411]                             if (!grepl(pattern, name)) 
[17:42:19.411]                               next
[17:42:19.411]                             invokeRestart(restart)
[17:42:19.411]                             muffled <- TRUE
[17:42:19.411]                             break
[17:42:19.411]                           }
[17:42:19.411]                         }
[17:42:19.411]                       }
[17:42:19.411]                       invisible(muffled)
[17:42:19.411]                     }
[17:42:19.411]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.411]                   }
[17:42:19.411]                 }
[17:42:19.411]                 else {
[17:42:19.411]                   if (TRUE) {
[17:42:19.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.411]                     {
[17:42:19.411]                       inherits <- base::inherits
[17:42:19.411]                       invokeRestart <- base::invokeRestart
[17:42:19.411]                       is.null <- base::is.null
[17:42:19.411]                       muffled <- FALSE
[17:42:19.411]                       if (inherits(cond, "message")) {
[17:42:19.411]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.411]                         if (muffled) 
[17:42:19.411]                           invokeRestart("muffleMessage")
[17:42:19.411]                       }
[17:42:19.411]                       else if (inherits(cond, "warning")) {
[17:42:19.411]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.411]                         if (muffled) 
[17:42:19.411]                           invokeRestart("muffleWarning")
[17:42:19.411]                       }
[17:42:19.411]                       else if (inherits(cond, "condition")) {
[17:42:19.411]                         if (!is.null(pattern)) {
[17:42:19.411]                           computeRestarts <- base::computeRestarts
[17:42:19.411]                           grepl <- base::grepl
[17:42:19.411]                           restarts <- computeRestarts(cond)
[17:42:19.411]                           for (restart in restarts) {
[17:42:19.411]                             name <- restart$name
[17:42:19.411]                             if (is.null(name)) 
[17:42:19.411]                               next
[17:42:19.411]                             if (!grepl(pattern, name)) 
[17:42:19.411]                               next
[17:42:19.411]                             invokeRestart(restart)
[17:42:19.411]                             muffled <- TRUE
[17:42:19.411]                             break
[17:42:19.411]                           }
[17:42:19.411]                         }
[17:42:19.411]                       }
[17:42:19.411]                       invisible(muffled)
[17:42:19.411]                     }
[17:42:19.411]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.411]                   }
[17:42:19.411]                 }
[17:42:19.411]             }
[17:42:19.411]         }))
[17:42:19.411]     }, error = function(ex) {
[17:42:19.411]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.411]                 ...future.rng), started = ...future.startTime, 
[17:42:19.411]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.411]             version = "1.8"), class = "FutureResult")
[17:42:19.411]     }, finally = {
[17:42:19.411]         if (!identical(...future.workdir, getwd())) 
[17:42:19.411]             setwd(...future.workdir)
[17:42:19.411]         {
[17:42:19.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.411]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.411]             }
[17:42:19.411]             base::options(...future.oldOptions)
[17:42:19.411]             if (.Platform$OS.type == "windows") {
[17:42:19.411]                 old_names <- names(...future.oldEnvVars)
[17:42:19.411]                 envs <- base::Sys.getenv()
[17:42:19.411]                 names <- names(envs)
[17:42:19.411]                 common <- intersect(names, old_names)
[17:42:19.411]                 added <- setdiff(names, old_names)
[17:42:19.411]                 removed <- setdiff(old_names, names)
[17:42:19.411]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.411]                   envs[common]]
[17:42:19.411]                 NAMES <- toupper(changed)
[17:42:19.411]                 args <- list()
[17:42:19.411]                 for (kk in seq_along(NAMES)) {
[17:42:19.411]                   name <- changed[[kk]]
[17:42:19.411]                   NAME <- NAMES[[kk]]
[17:42:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.411]                     next
[17:42:19.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.411]                 }
[17:42:19.411]                 NAMES <- toupper(added)
[17:42:19.411]                 for (kk in seq_along(NAMES)) {
[17:42:19.411]                   name <- added[[kk]]
[17:42:19.411]                   NAME <- NAMES[[kk]]
[17:42:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.411]                     next
[17:42:19.411]                   args[[name]] <- ""
[17:42:19.411]                 }
[17:42:19.411]                 NAMES <- toupper(removed)
[17:42:19.411]                 for (kk in seq_along(NAMES)) {
[17:42:19.411]                   name <- removed[[kk]]
[17:42:19.411]                   NAME <- NAMES[[kk]]
[17:42:19.411]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.411]                     next
[17:42:19.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.411]                 }
[17:42:19.411]                 if (length(args) > 0) 
[17:42:19.411]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.411]             }
[17:42:19.411]             else {
[17:42:19.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.411]             }
[17:42:19.411]             {
[17:42:19.411]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.411]                   0L) {
[17:42:19.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.411]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.411]                   base::options(opts)
[17:42:19.411]                 }
[17:42:19.411]                 {
[17:42:19.411]                   {
[17:42:19.411]                     NULL
[17:42:19.411]                     RNGkind("Mersenne-Twister")
[17:42:19.411]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.411]                       inherits = FALSE)
[17:42:19.411]                   }
[17:42:19.411]                   options(future.plan = NULL)
[17:42:19.411]                   if (is.na(NA_character_)) 
[17:42:19.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.411]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.411]                   {
[17:42:19.411]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.411]                     if (!future$lazy) 
[17:42:19.411]                       future <- run(future)
[17:42:19.411]                     invisible(future)
[17:42:19.411]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.411]                 }
[17:42:19.411]             }
[17:42:19.411]         }
[17:42:19.411]     })
[17:42:19.411]     if (TRUE) {
[17:42:19.411]         base::sink(type = "output", split = FALSE)
[17:42:19.411]         if (TRUE) {
[17:42:19.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.411]         }
[17:42:19.411]         else {
[17:42:19.411]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.411]         }
[17:42:19.411]         base::close(...future.stdout)
[17:42:19.411]         ...future.stdout <- NULL
[17:42:19.411]     }
[17:42:19.411]     ...future.result$conditions <- ...future.conditions
[17:42:19.411]     ...future.result$finished <- base::Sys.time()
[17:42:19.411]     ...future.result
[17:42:19.411] }
[17:42:19.413] plan(): Setting new future strategy stack:
[17:42:19.413] List of future strategies:
[17:42:19.413] 1. sequential:
[17:42:19.413]    - args: function (..., envir = parent.frame())
[17:42:19.413]    - tweaked: FALSE
[17:42:19.413]    - call: NULL
[17:42:19.413] plan(): nbrOfWorkers() = 1
[17:42:19.414] plan(): Setting new future strategy stack:
[17:42:19.414] List of future strategies:
[17:42:19.414] 1. sequential:
[17:42:19.414]    - args: function (..., envir = parent.frame())
[17:42:19.414]    - tweaked: FALSE
[17:42:19.414]    - call: plan(strategy)
[17:42:19.414] plan(): nbrOfWorkers() = 1
[17:42:19.415] SequentialFuture started (and completed)
[17:42:19.415] - Launch lazy future ... done
[17:42:19.415] run() for ‘SequentialFuture’ ... done
[17:42:19.415] getGlobalsAndPackages() ...
[17:42:19.415] Searching for globals...
[17:42:19.416] - globals found: [1] ‘{’
[17:42:19.416] Searching for globals ... DONE
[17:42:19.416] Resolving globals: FALSE
[17:42:19.416] 
[17:42:19.416] 
[17:42:19.416] getGlobalsAndPackages() ... DONE
[17:42:19.417] run() for ‘Future’ ...
[17:42:19.417] - state: ‘created’
[17:42:19.417] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.417] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.417]   - Field: ‘label’
[17:42:19.417]   - Field: ‘local’
[17:42:19.417]   - Field: ‘owner’
[17:42:19.418]   - Field: ‘envir’
[17:42:19.418]   - Field: ‘packages’
[17:42:19.418]   - Field: ‘gc’
[17:42:19.418]   - Field: ‘conditions’
[17:42:19.418]   - Field: ‘expr’
[17:42:19.418]   - Field: ‘uuid’
[17:42:19.418]   - Field: ‘seed’
[17:42:19.418]   - Field: ‘version’
[17:42:19.418]   - Field: ‘result’
[17:42:19.418]   - Field: ‘asynchronous’
[17:42:19.418]   - Field: ‘calls’
[17:42:19.419]   - Field: ‘globals’
[17:42:19.419]   - Field: ‘stdout’
[17:42:19.419]   - Field: ‘earlySignal’
[17:42:19.419]   - Field: ‘lazy’
[17:42:19.419]   - Field: ‘state’
[17:42:19.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.419] - Launch lazy future ...
[17:42:19.419] Packages needed by the future expression (n = 0): <none>
[17:42:19.419] Packages needed by future strategies (n = 0): <none>
[17:42:19.420] {
[17:42:19.420]     {
[17:42:19.420]         {
[17:42:19.420]             ...future.startTime <- base::Sys.time()
[17:42:19.420]             {
[17:42:19.420]                 {
[17:42:19.420]                   {
[17:42:19.420]                     base::local({
[17:42:19.420]                       has_future <- base::requireNamespace("future", 
[17:42:19.420]                         quietly = TRUE)
[17:42:19.420]                       if (has_future) {
[17:42:19.420]                         ns <- base::getNamespace("future")
[17:42:19.420]                         version <- ns[[".package"]][["version"]]
[17:42:19.420]                         if (is.null(version)) 
[17:42:19.420]                           version <- utils::packageVersion("future")
[17:42:19.420]                       }
[17:42:19.420]                       else {
[17:42:19.420]                         version <- NULL
[17:42:19.420]                       }
[17:42:19.420]                       if (!has_future || version < "1.8.0") {
[17:42:19.420]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.420]                           "", base::R.version$version.string), 
[17:42:19.420]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.420]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.420]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.420]                             "release", "version")], collapse = " "), 
[17:42:19.420]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.420]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.420]                           info)
[17:42:19.420]                         info <- base::paste(info, collapse = "; ")
[17:42:19.420]                         if (!has_future) {
[17:42:19.420]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.420]                             info)
[17:42:19.420]                         }
[17:42:19.420]                         else {
[17:42:19.420]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.420]                             info, version)
[17:42:19.420]                         }
[17:42:19.420]                         base::stop(msg)
[17:42:19.420]                       }
[17:42:19.420]                     })
[17:42:19.420]                   }
[17:42:19.420]                   options(future.plan = NULL)
[17:42:19.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.420]                 }
[17:42:19.420]                 ...future.workdir <- getwd()
[17:42:19.420]             }
[17:42:19.420]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.420]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.420]         }
[17:42:19.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.420]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.420]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.420]             base::names(...future.oldOptions))
[17:42:19.420]     }
[17:42:19.420]     if (FALSE) {
[17:42:19.420]     }
[17:42:19.420]     else {
[17:42:19.420]         if (TRUE) {
[17:42:19.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.420]                 open = "w")
[17:42:19.420]         }
[17:42:19.420]         else {
[17:42:19.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.420]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.420]         }
[17:42:19.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.420]             base::sink(type = "output", split = FALSE)
[17:42:19.420]             base::close(...future.stdout)
[17:42:19.420]         }, add = TRUE)
[17:42:19.420]     }
[17:42:19.420]     ...future.frame <- base::sys.nframe()
[17:42:19.420]     ...future.conditions <- base::list()
[17:42:19.420]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.420]     if (FALSE) {
[17:42:19.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.420]     }
[17:42:19.420]     ...future.result <- base::tryCatch({
[17:42:19.420]         base::withCallingHandlers({
[17:42:19.420]             ...future.value <- base::withVisible(base::local({
[17:42:19.420]                 4
[17:42:19.420]             }))
[17:42:19.420]             future::FutureResult(value = ...future.value$value, 
[17:42:19.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.420]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.420]                     ...future.globalenv.names))
[17:42:19.420]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.420]         }, condition = base::local({
[17:42:19.420]             c <- base::c
[17:42:19.420]             inherits <- base::inherits
[17:42:19.420]             invokeRestart <- base::invokeRestart
[17:42:19.420]             length <- base::length
[17:42:19.420]             list <- base::list
[17:42:19.420]             seq.int <- base::seq.int
[17:42:19.420]             signalCondition <- base::signalCondition
[17:42:19.420]             sys.calls <- base::sys.calls
[17:42:19.420]             `[[` <- base::`[[`
[17:42:19.420]             `+` <- base::`+`
[17:42:19.420]             `<<-` <- base::`<<-`
[17:42:19.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.420]                   3L)]
[17:42:19.420]             }
[17:42:19.420]             function(cond) {
[17:42:19.420]                 is_error <- inherits(cond, "error")
[17:42:19.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.420]                   NULL)
[17:42:19.420]                 if (is_error) {
[17:42:19.420]                   sessionInformation <- function() {
[17:42:19.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.420]                       search = base::search(), system = base::Sys.info())
[17:42:19.420]                   }
[17:42:19.420]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.420]                     cond$call), session = sessionInformation(), 
[17:42:19.420]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.420]                   signalCondition(cond)
[17:42:19.420]                 }
[17:42:19.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.420]                 "immediateCondition"))) {
[17:42:19.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.420]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.420]                   if (TRUE && !signal) {
[17:42:19.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.420]                     {
[17:42:19.420]                       inherits <- base::inherits
[17:42:19.420]                       invokeRestart <- base::invokeRestart
[17:42:19.420]                       is.null <- base::is.null
[17:42:19.420]                       muffled <- FALSE
[17:42:19.420]                       if (inherits(cond, "message")) {
[17:42:19.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.420]                         if (muffled) 
[17:42:19.420]                           invokeRestart("muffleMessage")
[17:42:19.420]                       }
[17:42:19.420]                       else if (inherits(cond, "warning")) {
[17:42:19.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.420]                         if (muffled) 
[17:42:19.420]                           invokeRestart("muffleWarning")
[17:42:19.420]                       }
[17:42:19.420]                       else if (inherits(cond, "condition")) {
[17:42:19.420]                         if (!is.null(pattern)) {
[17:42:19.420]                           computeRestarts <- base::computeRestarts
[17:42:19.420]                           grepl <- base::grepl
[17:42:19.420]                           restarts <- computeRestarts(cond)
[17:42:19.420]                           for (restart in restarts) {
[17:42:19.420]                             name <- restart$name
[17:42:19.420]                             if (is.null(name)) 
[17:42:19.420]                               next
[17:42:19.420]                             if (!grepl(pattern, name)) 
[17:42:19.420]                               next
[17:42:19.420]                             invokeRestart(restart)
[17:42:19.420]                             muffled <- TRUE
[17:42:19.420]                             break
[17:42:19.420]                           }
[17:42:19.420]                         }
[17:42:19.420]                       }
[17:42:19.420]                       invisible(muffled)
[17:42:19.420]                     }
[17:42:19.420]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.420]                   }
[17:42:19.420]                 }
[17:42:19.420]                 else {
[17:42:19.420]                   if (TRUE) {
[17:42:19.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.420]                     {
[17:42:19.420]                       inherits <- base::inherits
[17:42:19.420]                       invokeRestart <- base::invokeRestart
[17:42:19.420]                       is.null <- base::is.null
[17:42:19.420]                       muffled <- FALSE
[17:42:19.420]                       if (inherits(cond, "message")) {
[17:42:19.420]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.420]                         if (muffled) 
[17:42:19.420]                           invokeRestart("muffleMessage")
[17:42:19.420]                       }
[17:42:19.420]                       else if (inherits(cond, "warning")) {
[17:42:19.420]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.420]                         if (muffled) 
[17:42:19.420]                           invokeRestart("muffleWarning")
[17:42:19.420]                       }
[17:42:19.420]                       else if (inherits(cond, "condition")) {
[17:42:19.420]                         if (!is.null(pattern)) {
[17:42:19.420]                           computeRestarts <- base::computeRestarts
[17:42:19.420]                           grepl <- base::grepl
[17:42:19.420]                           restarts <- computeRestarts(cond)
[17:42:19.420]                           for (restart in restarts) {
[17:42:19.420]                             name <- restart$name
[17:42:19.420]                             if (is.null(name)) 
[17:42:19.420]                               next
[17:42:19.420]                             if (!grepl(pattern, name)) 
[17:42:19.420]                               next
[17:42:19.420]                             invokeRestart(restart)
[17:42:19.420]                             muffled <- TRUE
[17:42:19.420]                             break
[17:42:19.420]                           }
[17:42:19.420]                         }
[17:42:19.420]                       }
[17:42:19.420]                       invisible(muffled)
[17:42:19.420]                     }
[17:42:19.420]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.420]                   }
[17:42:19.420]                 }
[17:42:19.420]             }
[17:42:19.420]         }))
[17:42:19.420]     }, error = function(ex) {
[17:42:19.420]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.420]                 ...future.rng), started = ...future.startTime, 
[17:42:19.420]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.420]             version = "1.8"), class = "FutureResult")
[17:42:19.420]     }, finally = {
[17:42:19.420]         if (!identical(...future.workdir, getwd())) 
[17:42:19.420]             setwd(...future.workdir)
[17:42:19.420]         {
[17:42:19.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.420]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.420]             }
[17:42:19.420]             base::options(...future.oldOptions)
[17:42:19.420]             if (.Platform$OS.type == "windows") {
[17:42:19.420]                 old_names <- names(...future.oldEnvVars)
[17:42:19.420]                 envs <- base::Sys.getenv()
[17:42:19.420]                 names <- names(envs)
[17:42:19.420]                 common <- intersect(names, old_names)
[17:42:19.420]                 added <- setdiff(names, old_names)
[17:42:19.420]                 removed <- setdiff(old_names, names)
[17:42:19.420]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.420]                   envs[common]]
[17:42:19.420]                 NAMES <- toupper(changed)
[17:42:19.420]                 args <- list()
[17:42:19.420]                 for (kk in seq_along(NAMES)) {
[17:42:19.420]                   name <- changed[[kk]]
[17:42:19.420]                   NAME <- NAMES[[kk]]
[17:42:19.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.420]                     next
[17:42:19.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.420]                 }
[17:42:19.420]                 NAMES <- toupper(added)
[17:42:19.420]                 for (kk in seq_along(NAMES)) {
[17:42:19.420]                   name <- added[[kk]]
[17:42:19.420]                   NAME <- NAMES[[kk]]
[17:42:19.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.420]                     next
[17:42:19.420]                   args[[name]] <- ""
[17:42:19.420]                 }
[17:42:19.420]                 NAMES <- toupper(removed)
[17:42:19.420]                 for (kk in seq_along(NAMES)) {
[17:42:19.420]                   name <- removed[[kk]]
[17:42:19.420]                   NAME <- NAMES[[kk]]
[17:42:19.420]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.420]                     next
[17:42:19.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.420]                 }
[17:42:19.420]                 if (length(args) > 0) 
[17:42:19.420]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.420]             }
[17:42:19.420]             else {
[17:42:19.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.420]             }
[17:42:19.420]             {
[17:42:19.420]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.420]                   0L) {
[17:42:19.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.420]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.420]                   base::options(opts)
[17:42:19.420]                 }
[17:42:19.420]                 {
[17:42:19.420]                   {
[17:42:19.420]                     NULL
[17:42:19.420]                     RNGkind("Mersenne-Twister")
[17:42:19.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.420]                       inherits = FALSE)
[17:42:19.420]                   }
[17:42:19.420]                   options(future.plan = NULL)
[17:42:19.420]                   if (is.na(NA_character_)) 
[17:42:19.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.420]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.420]                   {
[17:42:19.420]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.420]                     if (!future$lazy) 
[17:42:19.420]                       future <- run(future)
[17:42:19.420]                     invisible(future)
[17:42:19.420]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.420]                 }
[17:42:19.420]             }
[17:42:19.420]         }
[17:42:19.420]     })
[17:42:19.420]     if (TRUE) {
[17:42:19.420]         base::sink(type = "output", split = FALSE)
[17:42:19.420]         if (TRUE) {
[17:42:19.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.420]         }
[17:42:19.420]         else {
[17:42:19.420]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.420]         }
[17:42:19.420]         base::close(...future.stdout)
[17:42:19.420]         ...future.stdout <- NULL
[17:42:19.420]     }
[17:42:19.420]     ...future.result$conditions <- ...future.conditions
[17:42:19.420]     ...future.result$finished <- base::Sys.time()
[17:42:19.420]     ...future.result
[17:42:19.420] }
[17:42:19.421] plan(): Setting new future strategy stack:
[17:42:19.422] List of future strategies:
[17:42:19.422] 1. sequential:
[17:42:19.422]    - args: function (..., envir = parent.frame())
[17:42:19.422]    - tweaked: FALSE
[17:42:19.422]    - call: NULL
[17:42:19.422] plan(): nbrOfWorkers() = 1
[17:42:19.423] plan(): Setting new future strategy stack:
[17:42:19.423] List of future strategies:
[17:42:19.423] 1. sequential:
[17:42:19.423]    - args: function (..., envir = parent.frame())
[17:42:19.423]    - tweaked: FALSE
[17:42:19.423]    - call: plan(strategy)
[17:42:19.423] plan(): nbrOfWorkers() = 1
[17:42:19.423] SequentialFuture started (and completed)
[17:42:19.423] - Launch lazy future ... done
[17:42:19.423] run() for ‘SequentialFuture’ ... done
<environment: 0x55bef8481e18> 
<environment: 0x55bef82ed048> 
[17:42:19.425] resolved() for ‘SequentialFuture’ ...
[17:42:19.425] - state: ‘finished’
[17:42:19.425] - run: TRUE
[17:42:19.425] - result: ‘FutureResult’
[17:42:19.425] resolved() for ‘SequentialFuture’ ... done
[17:42:19.425] resolved() for ‘SequentialFuture’ ...
[17:42:19.425] - state: ‘finished’
[17:42:19.425] - run: TRUE
[17:42:19.425] - result: ‘FutureResult’
[17:42:19.426] resolved() for ‘SequentialFuture’ ... done
[17:42:19.426] resolved() for ‘SequentialFuture’ ...
[17:42:19.426] - state: ‘finished’
[17:42:19.426] - run: TRUE
[17:42:19.426] - result: ‘FutureResult’
[17:42:19.426] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:19.427] resolve() on environment ...
[17:42:19.427]  recursive: 0
[17:42:19.429]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:19.429] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.430] - nx: 4
[17:42:19.430] - relay: TRUE
[17:42:19.430] - stdout: TRUE
[17:42:19.430] - signal: TRUE
[17:42:19.430] - resignal: FALSE
[17:42:19.430] - force: TRUE
[17:42:19.430] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.430] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.430]  - until=2
[17:42:19.430]  - relaying element #2
[17:42:19.430] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.431] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.431] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.431]  length: 3 (resolved future 1)
[17:42:19.431] resolved() for ‘SequentialFuture’ ...
[17:42:19.431] - state: ‘finished’
[17:42:19.431] - run: TRUE
[17:42:19.431] - result: ‘FutureResult’
[17:42:19.431] resolved() for ‘SequentialFuture’ ... done
[17:42:19.431] Future #2
[17:42:19.432] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.432] - nx: 4
[17:42:19.432] - relay: TRUE
[17:42:19.432] - stdout: TRUE
[17:42:19.432] - signal: TRUE
[17:42:19.432] - resignal: FALSE
[17:42:19.432] - force: TRUE
[17:42:19.432] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.432] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.432]  - until=2
[17:42:19.432]  - relaying element #2
[17:42:19.433] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.433] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.433] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.433]  length: 2 (resolved future 2)
[17:42:19.433] resolved() for ‘SequentialFuture’ ...
[17:42:19.433] - state: ‘finished’
[17:42:19.433] - run: TRUE
[17:42:19.433] - result: ‘FutureResult’
[17:42:19.433] resolved() for ‘SequentialFuture’ ... done
[17:42:19.433] Future #3
[17:42:19.434] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.434] - nx: 4
[17:42:19.434] - relay: TRUE
[17:42:19.434] - stdout: TRUE
[17:42:19.434] - signal: TRUE
[17:42:19.434] - resignal: FALSE
[17:42:19.434] - force: TRUE
[17:42:19.434] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.434] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.434]  - until=3
[17:42:19.434]  - relaying element #3
[17:42:19.435] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.435] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.435] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.435]  length: 1 (resolved future 3)
[17:42:19.435] resolved() for ‘SequentialFuture’ ...
[17:42:19.435] - state: ‘finished’
[17:42:19.435] - run: TRUE
[17:42:19.435] - result: ‘FutureResult’
[17:42:19.435] resolved() for ‘SequentialFuture’ ... done
[17:42:19.436] Future #4
[17:42:19.436] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.436] - nx: 4
[17:42:19.436] - relay: TRUE
[17:42:19.436] - stdout: TRUE
[17:42:19.436] - signal: TRUE
[17:42:19.436] - resignal: FALSE
[17:42:19.436] - force: TRUE
[17:42:19.436] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.436] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.436]  - until=4
[17:42:19.437]  - relaying element #4
[17:42:19.437] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.437] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.437] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.437]  length: 0 (resolved future 4)
[17:42:19.437] Relaying remaining futures
[17:42:19.437] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.437] - nx: 4
[17:42:19.437] - relay: TRUE
[17:42:19.437] - stdout: TRUE
[17:42:19.438] - signal: TRUE
[17:42:19.438] - resignal: FALSE
[17:42:19.438] - force: TRUE
[17:42:19.438] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.438] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:19.438] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.438] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.438] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.438] resolve() on environment ... DONE
<environment: 0x55bef84b9b68> 
Dimensions: c(2, 1, 3, 1)
[17:42:19.439] getGlobalsAndPackages() ...
[17:42:19.439] Searching for globals...
[17:42:19.439] 
[17:42:19.439] Searching for globals ... DONE
[17:42:19.440] - globals: [0] <none>
[17:42:19.440] getGlobalsAndPackages() ... DONE
[17:42:19.440] run() for ‘Future’ ...
[17:42:19.440] - state: ‘created’
[17:42:19.440] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.440] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.441]   - Field: ‘label’
[17:42:19.441]   - Field: ‘local’
[17:42:19.441]   - Field: ‘owner’
[17:42:19.441]   - Field: ‘envir’
[17:42:19.441]   - Field: ‘packages’
[17:42:19.441]   - Field: ‘gc’
[17:42:19.441]   - Field: ‘conditions’
[17:42:19.441]   - Field: ‘expr’
[17:42:19.441]   - Field: ‘uuid’
[17:42:19.442]   - Field: ‘seed’
[17:42:19.442]   - Field: ‘version’
[17:42:19.442]   - Field: ‘result’
[17:42:19.442]   - Field: ‘asynchronous’
[17:42:19.442]   - Field: ‘calls’
[17:42:19.442]   - Field: ‘globals’
[17:42:19.442]   - Field: ‘stdout’
[17:42:19.442]   - Field: ‘earlySignal’
[17:42:19.442]   - Field: ‘lazy’
[17:42:19.442]   - Field: ‘state’
[17:42:19.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.443] - Launch lazy future ...
[17:42:19.443] Packages needed by the future expression (n = 0): <none>
[17:42:19.443] Packages needed by future strategies (n = 0): <none>
[17:42:19.443] {
[17:42:19.443]     {
[17:42:19.443]         {
[17:42:19.443]             ...future.startTime <- base::Sys.time()
[17:42:19.443]             {
[17:42:19.443]                 {
[17:42:19.443]                   {
[17:42:19.443]                     base::local({
[17:42:19.443]                       has_future <- base::requireNamespace("future", 
[17:42:19.443]                         quietly = TRUE)
[17:42:19.443]                       if (has_future) {
[17:42:19.443]                         ns <- base::getNamespace("future")
[17:42:19.443]                         version <- ns[[".package"]][["version"]]
[17:42:19.443]                         if (is.null(version)) 
[17:42:19.443]                           version <- utils::packageVersion("future")
[17:42:19.443]                       }
[17:42:19.443]                       else {
[17:42:19.443]                         version <- NULL
[17:42:19.443]                       }
[17:42:19.443]                       if (!has_future || version < "1.8.0") {
[17:42:19.443]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.443]                           "", base::R.version$version.string), 
[17:42:19.443]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.443]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.443]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.443]                             "release", "version")], collapse = " "), 
[17:42:19.443]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.443]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.443]                           info)
[17:42:19.443]                         info <- base::paste(info, collapse = "; ")
[17:42:19.443]                         if (!has_future) {
[17:42:19.443]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.443]                             info)
[17:42:19.443]                         }
[17:42:19.443]                         else {
[17:42:19.443]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.443]                             info, version)
[17:42:19.443]                         }
[17:42:19.443]                         base::stop(msg)
[17:42:19.443]                       }
[17:42:19.443]                     })
[17:42:19.443]                   }
[17:42:19.443]                   options(future.plan = NULL)
[17:42:19.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.443]                 }
[17:42:19.443]                 ...future.workdir <- getwd()
[17:42:19.443]             }
[17:42:19.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.443]         }
[17:42:19.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.443]             base::names(...future.oldOptions))
[17:42:19.443]     }
[17:42:19.443]     if (FALSE) {
[17:42:19.443]     }
[17:42:19.443]     else {
[17:42:19.443]         if (TRUE) {
[17:42:19.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.443]                 open = "w")
[17:42:19.443]         }
[17:42:19.443]         else {
[17:42:19.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.443]         }
[17:42:19.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.443]             base::sink(type = "output", split = FALSE)
[17:42:19.443]             base::close(...future.stdout)
[17:42:19.443]         }, add = TRUE)
[17:42:19.443]     }
[17:42:19.443]     ...future.frame <- base::sys.nframe()
[17:42:19.443]     ...future.conditions <- base::list()
[17:42:19.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.443]     if (FALSE) {
[17:42:19.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.443]     }
[17:42:19.443]     ...future.result <- base::tryCatch({
[17:42:19.443]         base::withCallingHandlers({
[17:42:19.443]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.443]             future::FutureResult(value = ...future.value$value, 
[17:42:19.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.443]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.443]                     ...future.globalenv.names))
[17:42:19.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.443]         }, condition = base::local({
[17:42:19.443]             c <- base::c
[17:42:19.443]             inherits <- base::inherits
[17:42:19.443]             invokeRestart <- base::invokeRestart
[17:42:19.443]             length <- base::length
[17:42:19.443]             list <- base::list
[17:42:19.443]             seq.int <- base::seq.int
[17:42:19.443]             signalCondition <- base::signalCondition
[17:42:19.443]             sys.calls <- base::sys.calls
[17:42:19.443]             `[[` <- base::`[[`
[17:42:19.443]             `+` <- base::`+`
[17:42:19.443]             `<<-` <- base::`<<-`
[17:42:19.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.443]                   3L)]
[17:42:19.443]             }
[17:42:19.443]             function(cond) {
[17:42:19.443]                 is_error <- inherits(cond, "error")
[17:42:19.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.443]                   NULL)
[17:42:19.443]                 if (is_error) {
[17:42:19.443]                   sessionInformation <- function() {
[17:42:19.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.443]                       search = base::search(), system = base::Sys.info())
[17:42:19.443]                   }
[17:42:19.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.443]                     cond$call), session = sessionInformation(), 
[17:42:19.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.443]                   signalCondition(cond)
[17:42:19.443]                 }
[17:42:19.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.443]                 "immediateCondition"))) {
[17:42:19.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.443]                   if (TRUE && !signal) {
[17:42:19.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.443]                     {
[17:42:19.443]                       inherits <- base::inherits
[17:42:19.443]                       invokeRestart <- base::invokeRestart
[17:42:19.443]                       is.null <- base::is.null
[17:42:19.443]                       muffled <- FALSE
[17:42:19.443]                       if (inherits(cond, "message")) {
[17:42:19.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.443]                         if (muffled) 
[17:42:19.443]                           invokeRestart("muffleMessage")
[17:42:19.443]                       }
[17:42:19.443]                       else if (inherits(cond, "warning")) {
[17:42:19.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.443]                         if (muffled) 
[17:42:19.443]                           invokeRestart("muffleWarning")
[17:42:19.443]                       }
[17:42:19.443]                       else if (inherits(cond, "condition")) {
[17:42:19.443]                         if (!is.null(pattern)) {
[17:42:19.443]                           computeRestarts <- base::computeRestarts
[17:42:19.443]                           grepl <- base::grepl
[17:42:19.443]                           restarts <- computeRestarts(cond)
[17:42:19.443]                           for (restart in restarts) {
[17:42:19.443]                             name <- restart$name
[17:42:19.443]                             if (is.null(name)) 
[17:42:19.443]                               next
[17:42:19.443]                             if (!grepl(pattern, name)) 
[17:42:19.443]                               next
[17:42:19.443]                             invokeRestart(restart)
[17:42:19.443]                             muffled <- TRUE
[17:42:19.443]                             break
[17:42:19.443]                           }
[17:42:19.443]                         }
[17:42:19.443]                       }
[17:42:19.443]                       invisible(muffled)
[17:42:19.443]                     }
[17:42:19.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.443]                   }
[17:42:19.443]                 }
[17:42:19.443]                 else {
[17:42:19.443]                   if (TRUE) {
[17:42:19.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.443]                     {
[17:42:19.443]                       inherits <- base::inherits
[17:42:19.443]                       invokeRestart <- base::invokeRestart
[17:42:19.443]                       is.null <- base::is.null
[17:42:19.443]                       muffled <- FALSE
[17:42:19.443]                       if (inherits(cond, "message")) {
[17:42:19.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.443]                         if (muffled) 
[17:42:19.443]                           invokeRestart("muffleMessage")
[17:42:19.443]                       }
[17:42:19.443]                       else if (inherits(cond, "warning")) {
[17:42:19.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.443]                         if (muffled) 
[17:42:19.443]                           invokeRestart("muffleWarning")
[17:42:19.443]                       }
[17:42:19.443]                       else if (inherits(cond, "condition")) {
[17:42:19.443]                         if (!is.null(pattern)) {
[17:42:19.443]                           computeRestarts <- base::computeRestarts
[17:42:19.443]                           grepl <- base::grepl
[17:42:19.443]                           restarts <- computeRestarts(cond)
[17:42:19.443]                           for (restart in restarts) {
[17:42:19.443]                             name <- restart$name
[17:42:19.443]                             if (is.null(name)) 
[17:42:19.443]                               next
[17:42:19.443]                             if (!grepl(pattern, name)) 
[17:42:19.443]                               next
[17:42:19.443]                             invokeRestart(restart)
[17:42:19.443]                             muffled <- TRUE
[17:42:19.443]                             break
[17:42:19.443]                           }
[17:42:19.443]                         }
[17:42:19.443]                       }
[17:42:19.443]                       invisible(muffled)
[17:42:19.443]                     }
[17:42:19.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.443]                   }
[17:42:19.443]                 }
[17:42:19.443]             }
[17:42:19.443]         }))
[17:42:19.443]     }, error = function(ex) {
[17:42:19.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.443]                 ...future.rng), started = ...future.startTime, 
[17:42:19.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.443]             version = "1.8"), class = "FutureResult")
[17:42:19.443]     }, finally = {
[17:42:19.443]         if (!identical(...future.workdir, getwd())) 
[17:42:19.443]             setwd(...future.workdir)
[17:42:19.443]         {
[17:42:19.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.443]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.443]             }
[17:42:19.443]             base::options(...future.oldOptions)
[17:42:19.443]             if (.Platform$OS.type == "windows") {
[17:42:19.443]                 old_names <- names(...future.oldEnvVars)
[17:42:19.443]                 envs <- base::Sys.getenv()
[17:42:19.443]                 names <- names(envs)
[17:42:19.443]                 common <- intersect(names, old_names)
[17:42:19.443]                 added <- setdiff(names, old_names)
[17:42:19.443]                 removed <- setdiff(old_names, names)
[17:42:19.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.443]                   envs[common]]
[17:42:19.443]                 NAMES <- toupper(changed)
[17:42:19.443]                 args <- list()
[17:42:19.443]                 for (kk in seq_along(NAMES)) {
[17:42:19.443]                   name <- changed[[kk]]
[17:42:19.443]                   NAME <- NAMES[[kk]]
[17:42:19.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.443]                     next
[17:42:19.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.443]                 }
[17:42:19.443]                 NAMES <- toupper(added)
[17:42:19.443]                 for (kk in seq_along(NAMES)) {
[17:42:19.443]                   name <- added[[kk]]
[17:42:19.443]                   NAME <- NAMES[[kk]]
[17:42:19.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.443]                     next
[17:42:19.443]                   args[[name]] <- ""
[17:42:19.443]                 }
[17:42:19.443]                 NAMES <- toupper(removed)
[17:42:19.443]                 for (kk in seq_along(NAMES)) {
[17:42:19.443]                   name <- removed[[kk]]
[17:42:19.443]                   NAME <- NAMES[[kk]]
[17:42:19.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.443]                     next
[17:42:19.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.443]                 }
[17:42:19.443]                 if (length(args) > 0) 
[17:42:19.443]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.443]             }
[17:42:19.443]             else {
[17:42:19.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.443]             }
[17:42:19.443]             {
[17:42:19.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.443]                   0L) {
[17:42:19.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.443]                   base::options(opts)
[17:42:19.443]                 }
[17:42:19.443]                 {
[17:42:19.443]                   {
[17:42:19.443]                     NULL
[17:42:19.443]                     RNGkind("Mersenne-Twister")
[17:42:19.443]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.443]                       inherits = FALSE)
[17:42:19.443]                   }
[17:42:19.443]                   options(future.plan = NULL)
[17:42:19.443]                   if (is.na(NA_character_)) 
[17:42:19.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.443]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.443]                   {
[17:42:19.443]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.443]                     if (!future$lazy) 
[17:42:19.443]                       future <- run(future)
[17:42:19.443]                     invisible(future)
[17:42:19.443]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.443]                 }
[17:42:19.443]             }
[17:42:19.443]         }
[17:42:19.443]     })
[17:42:19.443]     if (TRUE) {
[17:42:19.443]         base::sink(type = "output", split = FALSE)
[17:42:19.443]         if (TRUE) {
[17:42:19.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.443]         }
[17:42:19.443]         else {
[17:42:19.443]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.443]         }
[17:42:19.443]         base::close(...future.stdout)
[17:42:19.443]         ...future.stdout <- NULL
[17:42:19.443]     }
[17:42:19.443]     ...future.result$conditions <- ...future.conditions
[17:42:19.443]     ...future.result$finished <- base::Sys.time()
[17:42:19.443]     ...future.result
[17:42:19.443] }
[17:42:19.445] plan(): Setting new future strategy stack:
[17:42:19.445] List of future strategies:
[17:42:19.445] 1. sequential:
[17:42:19.445]    - args: function (..., envir = parent.frame())
[17:42:19.445]    - tweaked: FALSE
[17:42:19.445]    - call: NULL
[17:42:19.446] plan(): nbrOfWorkers() = 1
[17:42:19.446] plan(): Setting new future strategy stack:
[17:42:19.447] List of future strategies:
[17:42:19.447] 1. sequential:
[17:42:19.447]    - args: function (..., envir = parent.frame())
[17:42:19.447]    - tweaked: FALSE
[17:42:19.447]    - call: plan(strategy)
[17:42:19.447] plan(): nbrOfWorkers() = 1
[17:42:19.447] SequentialFuture started (and completed)
[17:42:19.447] - Launch lazy future ... done
[17:42:19.447] run() for ‘SequentialFuture’ ... done
[17:42:19.447] getGlobalsAndPackages() ...
[17:42:19.448] Searching for globals...
[17:42:19.448] 
[17:42:19.448] Searching for globals ... DONE
[17:42:19.448] - globals: [0] <none>
[17:42:19.448] getGlobalsAndPackages() ... DONE
[17:42:19.448] run() for ‘Future’ ...
[17:42:19.448] - state: ‘created’
[17:42:19.449] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.449] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.449]   - Field: ‘label’
[17:42:19.449]   - Field: ‘local’
[17:42:19.449]   - Field: ‘owner’
[17:42:19.449]   - Field: ‘envir’
[17:42:19.449]   - Field: ‘packages’
[17:42:19.449]   - Field: ‘gc’
[17:42:19.450]   - Field: ‘conditions’
[17:42:19.450]   - Field: ‘expr’
[17:42:19.450]   - Field: ‘uuid’
[17:42:19.450]   - Field: ‘seed’
[17:42:19.450]   - Field: ‘version’
[17:42:19.450]   - Field: ‘result’
[17:42:19.450]   - Field: ‘asynchronous’
[17:42:19.450]   - Field: ‘calls’
[17:42:19.450]   - Field: ‘globals’
[17:42:19.450]   - Field: ‘stdout’
[17:42:19.450]   - Field: ‘earlySignal’
[17:42:19.451]   - Field: ‘lazy’
[17:42:19.451]   - Field: ‘state’
[17:42:19.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.451] - Launch lazy future ...
[17:42:19.451] Packages needed by the future expression (n = 0): <none>
[17:42:19.451] Packages needed by future strategies (n = 0): <none>
[17:42:19.452] {
[17:42:19.452]     {
[17:42:19.452]         {
[17:42:19.452]             ...future.startTime <- base::Sys.time()
[17:42:19.452]             {
[17:42:19.452]                 {
[17:42:19.452]                   {
[17:42:19.452]                     base::local({
[17:42:19.452]                       has_future <- base::requireNamespace("future", 
[17:42:19.452]                         quietly = TRUE)
[17:42:19.452]                       if (has_future) {
[17:42:19.452]                         ns <- base::getNamespace("future")
[17:42:19.452]                         version <- ns[[".package"]][["version"]]
[17:42:19.452]                         if (is.null(version)) 
[17:42:19.452]                           version <- utils::packageVersion("future")
[17:42:19.452]                       }
[17:42:19.452]                       else {
[17:42:19.452]                         version <- NULL
[17:42:19.452]                       }
[17:42:19.452]                       if (!has_future || version < "1.8.0") {
[17:42:19.452]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.452]                           "", base::R.version$version.string), 
[17:42:19.452]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.452]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.452]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.452]                             "release", "version")], collapse = " "), 
[17:42:19.452]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.452]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.452]                           info)
[17:42:19.452]                         info <- base::paste(info, collapse = "; ")
[17:42:19.452]                         if (!has_future) {
[17:42:19.452]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.452]                             info)
[17:42:19.452]                         }
[17:42:19.452]                         else {
[17:42:19.452]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.452]                             info, version)
[17:42:19.452]                         }
[17:42:19.452]                         base::stop(msg)
[17:42:19.452]                       }
[17:42:19.452]                     })
[17:42:19.452]                   }
[17:42:19.452]                   options(future.plan = NULL)
[17:42:19.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.452]                 }
[17:42:19.452]                 ...future.workdir <- getwd()
[17:42:19.452]             }
[17:42:19.452]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.452]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.452]         }
[17:42:19.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.452]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.452]             base::names(...future.oldOptions))
[17:42:19.452]     }
[17:42:19.452]     if (FALSE) {
[17:42:19.452]     }
[17:42:19.452]     else {
[17:42:19.452]         if (TRUE) {
[17:42:19.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.452]                 open = "w")
[17:42:19.452]         }
[17:42:19.452]         else {
[17:42:19.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.452]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.452]         }
[17:42:19.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.452]             base::sink(type = "output", split = FALSE)
[17:42:19.452]             base::close(...future.stdout)
[17:42:19.452]         }, add = TRUE)
[17:42:19.452]     }
[17:42:19.452]     ...future.frame <- base::sys.nframe()
[17:42:19.452]     ...future.conditions <- base::list()
[17:42:19.452]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.452]     if (FALSE) {
[17:42:19.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.452]     }
[17:42:19.452]     ...future.result <- base::tryCatch({
[17:42:19.452]         base::withCallingHandlers({
[17:42:19.452]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.452]             future::FutureResult(value = ...future.value$value, 
[17:42:19.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.452]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.452]                     ...future.globalenv.names))
[17:42:19.452]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.452]         }, condition = base::local({
[17:42:19.452]             c <- base::c
[17:42:19.452]             inherits <- base::inherits
[17:42:19.452]             invokeRestart <- base::invokeRestart
[17:42:19.452]             length <- base::length
[17:42:19.452]             list <- base::list
[17:42:19.452]             seq.int <- base::seq.int
[17:42:19.452]             signalCondition <- base::signalCondition
[17:42:19.452]             sys.calls <- base::sys.calls
[17:42:19.452]             `[[` <- base::`[[`
[17:42:19.452]             `+` <- base::`+`
[17:42:19.452]             `<<-` <- base::`<<-`
[17:42:19.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.452]                   3L)]
[17:42:19.452]             }
[17:42:19.452]             function(cond) {
[17:42:19.452]                 is_error <- inherits(cond, "error")
[17:42:19.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.452]                   NULL)
[17:42:19.452]                 if (is_error) {
[17:42:19.452]                   sessionInformation <- function() {
[17:42:19.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.452]                       search = base::search(), system = base::Sys.info())
[17:42:19.452]                   }
[17:42:19.452]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.452]                     cond$call), session = sessionInformation(), 
[17:42:19.452]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.452]                   signalCondition(cond)
[17:42:19.452]                 }
[17:42:19.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.452]                 "immediateCondition"))) {
[17:42:19.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.452]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.452]                   if (TRUE && !signal) {
[17:42:19.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.452]                     {
[17:42:19.452]                       inherits <- base::inherits
[17:42:19.452]                       invokeRestart <- base::invokeRestart
[17:42:19.452]                       is.null <- base::is.null
[17:42:19.452]                       muffled <- FALSE
[17:42:19.452]                       if (inherits(cond, "message")) {
[17:42:19.452]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.452]                         if (muffled) 
[17:42:19.452]                           invokeRestart("muffleMessage")
[17:42:19.452]                       }
[17:42:19.452]                       else if (inherits(cond, "warning")) {
[17:42:19.452]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.452]                         if (muffled) 
[17:42:19.452]                           invokeRestart("muffleWarning")
[17:42:19.452]                       }
[17:42:19.452]                       else if (inherits(cond, "condition")) {
[17:42:19.452]                         if (!is.null(pattern)) {
[17:42:19.452]                           computeRestarts <- base::computeRestarts
[17:42:19.452]                           grepl <- base::grepl
[17:42:19.452]                           restarts <- computeRestarts(cond)
[17:42:19.452]                           for (restart in restarts) {
[17:42:19.452]                             name <- restart$name
[17:42:19.452]                             if (is.null(name)) 
[17:42:19.452]                               next
[17:42:19.452]                             if (!grepl(pattern, name)) 
[17:42:19.452]                               next
[17:42:19.452]                             invokeRestart(restart)
[17:42:19.452]                             muffled <- TRUE
[17:42:19.452]                             break
[17:42:19.452]                           }
[17:42:19.452]                         }
[17:42:19.452]                       }
[17:42:19.452]                       invisible(muffled)
[17:42:19.452]                     }
[17:42:19.452]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.452]                   }
[17:42:19.452]                 }
[17:42:19.452]                 else {
[17:42:19.452]                   if (TRUE) {
[17:42:19.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.452]                     {
[17:42:19.452]                       inherits <- base::inherits
[17:42:19.452]                       invokeRestart <- base::invokeRestart
[17:42:19.452]                       is.null <- base::is.null
[17:42:19.452]                       muffled <- FALSE
[17:42:19.452]                       if (inherits(cond, "message")) {
[17:42:19.452]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.452]                         if (muffled) 
[17:42:19.452]                           invokeRestart("muffleMessage")
[17:42:19.452]                       }
[17:42:19.452]                       else if (inherits(cond, "warning")) {
[17:42:19.452]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.452]                         if (muffled) 
[17:42:19.452]                           invokeRestart("muffleWarning")
[17:42:19.452]                       }
[17:42:19.452]                       else if (inherits(cond, "condition")) {
[17:42:19.452]                         if (!is.null(pattern)) {
[17:42:19.452]                           computeRestarts <- base::computeRestarts
[17:42:19.452]                           grepl <- base::grepl
[17:42:19.452]                           restarts <- computeRestarts(cond)
[17:42:19.452]                           for (restart in restarts) {
[17:42:19.452]                             name <- restart$name
[17:42:19.452]                             if (is.null(name)) 
[17:42:19.452]                               next
[17:42:19.452]                             if (!grepl(pattern, name)) 
[17:42:19.452]                               next
[17:42:19.452]                             invokeRestart(restart)
[17:42:19.452]                             muffled <- TRUE
[17:42:19.452]                             break
[17:42:19.452]                           }
[17:42:19.452]                         }
[17:42:19.452]                       }
[17:42:19.452]                       invisible(muffled)
[17:42:19.452]                     }
[17:42:19.452]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.452]                   }
[17:42:19.452]                 }
[17:42:19.452]             }
[17:42:19.452]         }))
[17:42:19.452]     }, error = function(ex) {
[17:42:19.452]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.452]                 ...future.rng), started = ...future.startTime, 
[17:42:19.452]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.452]             version = "1.8"), class = "FutureResult")
[17:42:19.452]     }, finally = {
[17:42:19.452]         if (!identical(...future.workdir, getwd())) 
[17:42:19.452]             setwd(...future.workdir)
[17:42:19.452]         {
[17:42:19.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.452]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.452]             }
[17:42:19.452]             base::options(...future.oldOptions)
[17:42:19.452]             if (.Platform$OS.type == "windows") {
[17:42:19.452]                 old_names <- names(...future.oldEnvVars)
[17:42:19.452]                 envs <- base::Sys.getenv()
[17:42:19.452]                 names <- names(envs)
[17:42:19.452]                 common <- intersect(names, old_names)
[17:42:19.452]                 added <- setdiff(names, old_names)
[17:42:19.452]                 removed <- setdiff(old_names, names)
[17:42:19.452]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.452]                   envs[common]]
[17:42:19.452]                 NAMES <- toupper(changed)
[17:42:19.452]                 args <- list()
[17:42:19.452]                 for (kk in seq_along(NAMES)) {
[17:42:19.452]                   name <- changed[[kk]]
[17:42:19.452]                   NAME <- NAMES[[kk]]
[17:42:19.452]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.452]                     next
[17:42:19.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.452]                 }
[17:42:19.452]                 NAMES <- toupper(added)
[17:42:19.452]                 for (kk in seq_along(NAMES)) {
[17:42:19.452]                   name <- added[[kk]]
[17:42:19.452]                   NAME <- NAMES[[kk]]
[17:42:19.452]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.452]                     next
[17:42:19.452]                   args[[name]] <- ""
[17:42:19.452]                 }
[17:42:19.452]                 NAMES <- toupper(removed)
[17:42:19.452]                 for (kk in seq_along(NAMES)) {
[17:42:19.452]                   name <- removed[[kk]]
[17:42:19.452]                   NAME <- NAMES[[kk]]
[17:42:19.452]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.452]                     next
[17:42:19.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.452]                 }
[17:42:19.452]                 if (length(args) > 0) 
[17:42:19.452]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.452]             }
[17:42:19.452]             else {
[17:42:19.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.452]             }
[17:42:19.452]             {
[17:42:19.452]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.452]                   0L) {
[17:42:19.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.452]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.452]                   base::options(opts)
[17:42:19.452]                 }
[17:42:19.452]                 {
[17:42:19.452]                   {
[17:42:19.452]                     NULL
[17:42:19.452]                     RNGkind("Mersenne-Twister")
[17:42:19.452]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.452]                       inherits = FALSE)
[17:42:19.452]                   }
[17:42:19.452]                   options(future.plan = NULL)
[17:42:19.452]                   if (is.na(NA_character_)) 
[17:42:19.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.452]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.452]                   {
[17:42:19.452]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.452]                     if (!future$lazy) 
[17:42:19.452]                       future <- run(future)
[17:42:19.452]                     invisible(future)
[17:42:19.452]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.452]                 }
[17:42:19.452]             }
[17:42:19.452]         }
[17:42:19.452]     })
[17:42:19.452]     if (TRUE) {
[17:42:19.452]         base::sink(type = "output", split = FALSE)
[17:42:19.452]         if (TRUE) {
[17:42:19.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.452]         }
[17:42:19.452]         else {
[17:42:19.452]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.452]         }
[17:42:19.452]         base::close(...future.stdout)
[17:42:19.452]         ...future.stdout <- NULL
[17:42:19.452]     }
[17:42:19.452]     ...future.result$conditions <- ...future.conditions
[17:42:19.452]     ...future.result$finished <- base::Sys.time()
[17:42:19.452]     ...future.result
[17:42:19.452] }
[17:42:19.453] plan(): Setting new future strategy stack:
[17:42:19.453] List of future strategies:
[17:42:19.453] 1. sequential:
[17:42:19.453]    - args: function (..., envir = parent.frame())
[17:42:19.453]    - tweaked: FALSE
[17:42:19.453]    - call: NULL
[17:42:19.454] plan(): nbrOfWorkers() = 1
[17:42:19.454] plan(): Setting new future strategy stack:
[17:42:19.455] List of future strategies:
[17:42:19.455] 1. sequential:
[17:42:19.455]    - args: function (..., envir = parent.frame())
[17:42:19.455]    - tweaked: FALSE
[17:42:19.455]    - call: plan(strategy)
[17:42:19.455] plan(): nbrOfWorkers() = 1
[17:42:19.455] SequentialFuture started (and completed)
[17:42:19.455] - Launch lazy future ... done
[17:42:19.455] run() for ‘SequentialFuture’ ... done
[17:42:19.458] getGlobalsAndPackages() ...
[17:42:19.458] Searching for globals...
[17:42:19.458] - globals found: [1] ‘{’
[17:42:19.459] Searching for globals ... DONE
[17:42:19.459] Resolving globals: FALSE
[17:42:19.459] 
[17:42:19.459] 
[17:42:19.459] getGlobalsAndPackages() ... DONE
[17:42:19.459] run() for ‘Future’ ...
[17:42:19.459] - state: ‘created’
[17:42:19.460] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.460]   - Field: ‘label’
[17:42:19.460]   - Field: ‘local’
[17:42:19.460]   - Field: ‘owner’
[17:42:19.460]   - Field: ‘envir’
[17:42:19.461]   - Field: ‘packages’
[17:42:19.461]   - Field: ‘gc’
[17:42:19.461]   - Field: ‘conditions’
[17:42:19.461]   - Field: ‘expr’
[17:42:19.461]   - Field: ‘uuid’
[17:42:19.461]   - Field: ‘seed’
[17:42:19.461]   - Field: ‘version’
[17:42:19.461]   - Field: ‘result’
[17:42:19.461]   - Field: ‘asynchronous’
[17:42:19.461]   - Field: ‘calls’
[17:42:19.461]   - Field: ‘globals’
[17:42:19.462]   - Field: ‘stdout’
[17:42:19.462]   - Field: ‘earlySignal’
[17:42:19.462]   - Field: ‘lazy’
[17:42:19.462]   - Field: ‘state’
[17:42:19.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.462] - Launch lazy future ...
[17:42:19.462] Packages needed by the future expression (n = 0): <none>
[17:42:19.462] Packages needed by future strategies (n = 0): <none>
[17:42:19.463] {
[17:42:19.463]     {
[17:42:19.463]         {
[17:42:19.463]             ...future.startTime <- base::Sys.time()
[17:42:19.463]             {
[17:42:19.463]                 {
[17:42:19.463]                   {
[17:42:19.463]                     base::local({
[17:42:19.463]                       has_future <- base::requireNamespace("future", 
[17:42:19.463]                         quietly = TRUE)
[17:42:19.463]                       if (has_future) {
[17:42:19.463]                         ns <- base::getNamespace("future")
[17:42:19.463]                         version <- ns[[".package"]][["version"]]
[17:42:19.463]                         if (is.null(version)) 
[17:42:19.463]                           version <- utils::packageVersion("future")
[17:42:19.463]                       }
[17:42:19.463]                       else {
[17:42:19.463]                         version <- NULL
[17:42:19.463]                       }
[17:42:19.463]                       if (!has_future || version < "1.8.0") {
[17:42:19.463]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.463]                           "", base::R.version$version.string), 
[17:42:19.463]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.463]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.463]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.463]                             "release", "version")], collapse = " "), 
[17:42:19.463]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.463]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.463]                           info)
[17:42:19.463]                         info <- base::paste(info, collapse = "; ")
[17:42:19.463]                         if (!has_future) {
[17:42:19.463]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.463]                             info)
[17:42:19.463]                         }
[17:42:19.463]                         else {
[17:42:19.463]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.463]                             info, version)
[17:42:19.463]                         }
[17:42:19.463]                         base::stop(msg)
[17:42:19.463]                       }
[17:42:19.463]                     })
[17:42:19.463]                   }
[17:42:19.463]                   options(future.plan = NULL)
[17:42:19.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.463]                 }
[17:42:19.463]                 ...future.workdir <- getwd()
[17:42:19.463]             }
[17:42:19.463]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.463]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.463]         }
[17:42:19.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.463]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.463]             base::names(...future.oldOptions))
[17:42:19.463]     }
[17:42:19.463]     if (FALSE) {
[17:42:19.463]     }
[17:42:19.463]     else {
[17:42:19.463]         if (TRUE) {
[17:42:19.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.463]                 open = "w")
[17:42:19.463]         }
[17:42:19.463]         else {
[17:42:19.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.463]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.463]         }
[17:42:19.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.463]             base::sink(type = "output", split = FALSE)
[17:42:19.463]             base::close(...future.stdout)
[17:42:19.463]         }, add = TRUE)
[17:42:19.463]     }
[17:42:19.463]     ...future.frame <- base::sys.nframe()
[17:42:19.463]     ...future.conditions <- base::list()
[17:42:19.463]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.463]     if (FALSE) {
[17:42:19.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.463]     }
[17:42:19.463]     ...future.result <- base::tryCatch({
[17:42:19.463]         base::withCallingHandlers({
[17:42:19.463]             ...future.value <- base::withVisible(base::local({
[17:42:19.463]                 4
[17:42:19.463]             }))
[17:42:19.463]             future::FutureResult(value = ...future.value$value, 
[17:42:19.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.463]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.463]                     ...future.globalenv.names))
[17:42:19.463]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.463]         }, condition = base::local({
[17:42:19.463]             c <- base::c
[17:42:19.463]             inherits <- base::inherits
[17:42:19.463]             invokeRestart <- base::invokeRestart
[17:42:19.463]             length <- base::length
[17:42:19.463]             list <- base::list
[17:42:19.463]             seq.int <- base::seq.int
[17:42:19.463]             signalCondition <- base::signalCondition
[17:42:19.463]             sys.calls <- base::sys.calls
[17:42:19.463]             `[[` <- base::`[[`
[17:42:19.463]             `+` <- base::`+`
[17:42:19.463]             `<<-` <- base::`<<-`
[17:42:19.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.463]                   3L)]
[17:42:19.463]             }
[17:42:19.463]             function(cond) {
[17:42:19.463]                 is_error <- inherits(cond, "error")
[17:42:19.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.463]                   NULL)
[17:42:19.463]                 if (is_error) {
[17:42:19.463]                   sessionInformation <- function() {
[17:42:19.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.463]                       search = base::search(), system = base::Sys.info())
[17:42:19.463]                   }
[17:42:19.463]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.463]                     cond$call), session = sessionInformation(), 
[17:42:19.463]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.463]                   signalCondition(cond)
[17:42:19.463]                 }
[17:42:19.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.463]                 "immediateCondition"))) {
[17:42:19.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.463]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.463]                   if (TRUE && !signal) {
[17:42:19.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.463]                     {
[17:42:19.463]                       inherits <- base::inherits
[17:42:19.463]                       invokeRestart <- base::invokeRestart
[17:42:19.463]                       is.null <- base::is.null
[17:42:19.463]                       muffled <- FALSE
[17:42:19.463]                       if (inherits(cond, "message")) {
[17:42:19.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.463]                         if (muffled) 
[17:42:19.463]                           invokeRestart("muffleMessage")
[17:42:19.463]                       }
[17:42:19.463]                       else if (inherits(cond, "warning")) {
[17:42:19.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.463]                         if (muffled) 
[17:42:19.463]                           invokeRestart("muffleWarning")
[17:42:19.463]                       }
[17:42:19.463]                       else if (inherits(cond, "condition")) {
[17:42:19.463]                         if (!is.null(pattern)) {
[17:42:19.463]                           computeRestarts <- base::computeRestarts
[17:42:19.463]                           grepl <- base::grepl
[17:42:19.463]                           restarts <- computeRestarts(cond)
[17:42:19.463]                           for (restart in restarts) {
[17:42:19.463]                             name <- restart$name
[17:42:19.463]                             if (is.null(name)) 
[17:42:19.463]                               next
[17:42:19.463]                             if (!grepl(pattern, name)) 
[17:42:19.463]                               next
[17:42:19.463]                             invokeRestart(restart)
[17:42:19.463]                             muffled <- TRUE
[17:42:19.463]                             break
[17:42:19.463]                           }
[17:42:19.463]                         }
[17:42:19.463]                       }
[17:42:19.463]                       invisible(muffled)
[17:42:19.463]                     }
[17:42:19.463]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.463]                   }
[17:42:19.463]                 }
[17:42:19.463]                 else {
[17:42:19.463]                   if (TRUE) {
[17:42:19.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.463]                     {
[17:42:19.463]                       inherits <- base::inherits
[17:42:19.463]                       invokeRestart <- base::invokeRestart
[17:42:19.463]                       is.null <- base::is.null
[17:42:19.463]                       muffled <- FALSE
[17:42:19.463]                       if (inherits(cond, "message")) {
[17:42:19.463]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.463]                         if (muffled) 
[17:42:19.463]                           invokeRestart("muffleMessage")
[17:42:19.463]                       }
[17:42:19.463]                       else if (inherits(cond, "warning")) {
[17:42:19.463]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.463]                         if (muffled) 
[17:42:19.463]                           invokeRestart("muffleWarning")
[17:42:19.463]                       }
[17:42:19.463]                       else if (inherits(cond, "condition")) {
[17:42:19.463]                         if (!is.null(pattern)) {
[17:42:19.463]                           computeRestarts <- base::computeRestarts
[17:42:19.463]                           grepl <- base::grepl
[17:42:19.463]                           restarts <- computeRestarts(cond)
[17:42:19.463]                           for (restart in restarts) {
[17:42:19.463]                             name <- restart$name
[17:42:19.463]                             if (is.null(name)) 
[17:42:19.463]                               next
[17:42:19.463]                             if (!grepl(pattern, name)) 
[17:42:19.463]                               next
[17:42:19.463]                             invokeRestart(restart)
[17:42:19.463]                             muffled <- TRUE
[17:42:19.463]                             break
[17:42:19.463]                           }
[17:42:19.463]                         }
[17:42:19.463]                       }
[17:42:19.463]                       invisible(muffled)
[17:42:19.463]                     }
[17:42:19.463]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.463]                   }
[17:42:19.463]                 }
[17:42:19.463]             }
[17:42:19.463]         }))
[17:42:19.463]     }, error = function(ex) {
[17:42:19.463]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.463]                 ...future.rng), started = ...future.startTime, 
[17:42:19.463]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.463]             version = "1.8"), class = "FutureResult")
[17:42:19.463]     }, finally = {
[17:42:19.463]         if (!identical(...future.workdir, getwd())) 
[17:42:19.463]             setwd(...future.workdir)
[17:42:19.463]         {
[17:42:19.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.463]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.463]             }
[17:42:19.463]             base::options(...future.oldOptions)
[17:42:19.463]             if (.Platform$OS.type == "windows") {
[17:42:19.463]                 old_names <- names(...future.oldEnvVars)
[17:42:19.463]                 envs <- base::Sys.getenv()
[17:42:19.463]                 names <- names(envs)
[17:42:19.463]                 common <- intersect(names, old_names)
[17:42:19.463]                 added <- setdiff(names, old_names)
[17:42:19.463]                 removed <- setdiff(old_names, names)
[17:42:19.463]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.463]                   envs[common]]
[17:42:19.463]                 NAMES <- toupper(changed)
[17:42:19.463]                 args <- list()
[17:42:19.463]                 for (kk in seq_along(NAMES)) {
[17:42:19.463]                   name <- changed[[kk]]
[17:42:19.463]                   NAME <- NAMES[[kk]]
[17:42:19.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.463]                     next
[17:42:19.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.463]                 }
[17:42:19.463]                 NAMES <- toupper(added)
[17:42:19.463]                 for (kk in seq_along(NAMES)) {
[17:42:19.463]                   name <- added[[kk]]
[17:42:19.463]                   NAME <- NAMES[[kk]]
[17:42:19.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.463]                     next
[17:42:19.463]                   args[[name]] <- ""
[17:42:19.463]                 }
[17:42:19.463]                 NAMES <- toupper(removed)
[17:42:19.463]                 for (kk in seq_along(NAMES)) {
[17:42:19.463]                   name <- removed[[kk]]
[17:42:19.463]                   NAME <- NAMES[[kk]]
[17:42:19.463]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.463]                     next
[17:42:19.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.463]                 }
[17:42:19.463]                 if (length(args) > 0) 
[17:42:19.463]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.463]             }
[17:42:19.463]             else {
[17:42:19.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.463]             }
[17:42:19.463]             {
[17:42:19.463]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.463]                   0L) {
[17:42:19.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.463]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.463]                   base::options(opts)
[17:42:19.463]                 }
[17:42:19.463]                 {
[17:42:19.463]                   {
[17:42:19.463]                     NULL
[17:42:19.463]                     RNGkind("Mersenne-Twister")
[17:42:19.463]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.463]                       inherits = FALSE)
[17:42:19.463]                   }
[17:42:19.463]                   options(future.plan = NULL)
[17:42:19.463]                   if (is.na(NA_character_)) 
[17:42:19.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.463]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.463]                   {
[17:42:19.463]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.463]                     if (!future$lazy) 
[17:42:19.463]                       future <- run(future)
[17:42:19.463]                     invisible(future)
[17:42:19.463]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.463]                 }
[17:42:19.463]             }
[17:42:19.463]         }
[17:42:19.463]     })
[17:42:19.463]     if (TRUE) {
[17:42:19.463]         base::sink(type = "output", split = FALSE)
[17:42:19.463]         if (TRUE) {
[17:42:19.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.463]         }
[17:42:19.463]         else {
[17:42:19.463]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.463]         }
[17:42:19.463]         base::close(...future.stdout)
[17:42:19.463]         ...future.stdout <- NULL
[17:42:19.463]     }
[17:42:19.463]     ...future.result$conditions <- ...future.conditions
[17:42:19.463]     ...future.result$finished <- base::Sys.time()
[17:42:19.463]     ...future.result
[17:42:19.463] }
[17:42:19.464] plan(): Setting new future strategy stack:
[17:42:19.465] List of future strategies:
[17:42:19.465] 1. sequential:
[17:42:19.465]    - args: function (..., envir = parent.frame())
[17:42:19.465]    - tweaked: FALSE
[17:42:19.465]    - call: NULL
[17:42:19.465] plan(): nbrOfWorkers() = 1
[17:42:19.466] plan(): Setting new future strategy stack:
[17:42:19.466] List of future strategies:
[17:42:19.466] 1. sequential:
[17:42:19.466]    - args: function (..., envir = parent.frame())
[17:42:19.466]    - tweaked: FALSE
[17:42:19.466]    - call: plan(strategy)
[17:42:19.466] plan(): nbrOfWorkers() = 1
[17:42:19.466] SequentialFuture started (and completed)
[17:42:19.466] - Launch lazy future ... done
[17:42:19.466] run() for ‘SequentialFuture’ ... done
<environment: 0x55bef7b1ec80> 
<environment: 0x55bef79499e0> 
[17:42:19.468] resolved() for ‘SequentialFuture’ ...
[17:42:19.468] - state: ‘finished’
[17:42:19.468] - run: TRUE
[17:42:19.468] - result: ‘FutureResult’
[17:42:19.468] resolved() for ‘SequentialFuture’ ... done
[17:42:19.468] resolved() for ‘SequentialFuture’ ...
[17:42:19.468] - state: ‘finished’
[17:42:19.468] - run: TRUE
[17:42:19.469] - result: ‘FutureResult’
[17:42:19.469] resolved() for ‘SequentialFuture’ ... done
[17:42:19.469] resolved() for ‘SequentialFuture’ ...
[17:42:19.469] - state: ‘finished’
[17:42:19.469] - run: TRUE
[17:42:19.469] - result: ‘FutureResult’
[17:42:19.469] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:19.470] resolve() on environment ...
[17:42:19.470]  recursive: 0
[17:42:19.471]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:19.471] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.471] - nx: 4
[17:42:19.471] - relay: TRUE
[17:42:19.471] - stdout: TRUE
[17:42:19.472] - signal: TRUE
[17:42:19.472] - resignal: FALSE
[17:42:19.472] - force: TRUE
[17:42:19.472] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.472] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.472]  - until=2
[17:42:19.472]  - relaying element #2
[17:42:19.472] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.472] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.472] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.472]  length: 3 (resolved future 1)
[17:42:19.472] resolved() for ‘SequentialFuture’ ...
[17:42:19.473] - state: ‘finished’
[17:42:19.473] - run: TRUE
[17:42:19.473] - result: ‘FutureResult’
[17:42:19.473] resolved() for ‘SequentialFuture’ ... done
[17:42:19.473] Future #2
[17:42:19.473] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.473] - nx: 4
[17:42:19.473] - relay: TRUE
[17:42:19.473] - stdout: TRUE
[17:42:19.473] - signal: TRUE
[17:42:19.474] - resignal: FALSE
[17:42:19.474] - force: TRUE
[17:42:19.474] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:19.474] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:19.474]  - until=2
[17:42:19.474]  - relaying element #2
[17:42:19.474] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.474] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.474] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.474]  length: 2 (resolved future 2)
[17:42:19.475] resolved() for ‘SequentialFuture’ ...
[17:42:19.475] - state: ‘finished’
[17:42:19.475] - run: TRUE
[17:42:19.475] - result: ‘FutureResult’
[17:42:19.475] resolved() for ‘SequentialFuture’ ... done
[17:42:19.475] Future #3
[17:42:19.475] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.475] - nx: 4
[17:42:19.475] - relay: TRUE
[17:42:19.475] - stdout: TRUE
[17:42:19.475] - signal: TRUE
[17:42:19.476] - resignal: FALSE
[17:42:19.476] - force: TRUE
[17:42:19.476] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:19.476] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:19.476]  - until=3
[17:42:19.476]  - relaying element #3
[17:42:19.476] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.476] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.476] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.476]  length: 1 (resolved future 3)
[17:42:19.477] resolved() for ‘SequentialFuture’ ...
[17:42:19.477] - state: ‘finished’
[17:42:19.477] - run: TRUE
[17:42:19.477] - result: ‘FutureResult’
[17:42:19.477] resolved() for ‘SequentialFuture’ ... done
[17:42:19.477] Future #4
[17:42:19.477] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.477] - nx: 4
[17:42:19.477] - relay: TRUE
[17:42:19.477] - stdout: TRUE
[17:42:19.477] - signal: TRUE
[17:42:19.478] - resignal: FALSE
[17:42:19.478] - force: TRUE
[17:42:19.478] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:19.478] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:19.478]  - until=4
[17:42:19.478]  - relaying element #4
[17:42:19.478] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.478] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.478] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.478]  length: 0 (resolved future 4)
[17:42:19.479] Relaying remaining futures
[17:42:19.479] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.479] - nx: 4
[17:42:19.479] - relay: TRUE
[17:42:19.479] - stdout: TRUE
[17:42:19.479] - signal: TRUE
[17:42:19.479] - resignal: FALSE
[17:42:19.479] - force: TRUE
[17:42:19.479] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.479] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:19.479] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:19.480] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:19.480] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.480] resolve() on environment ... DONE
<environment: 0x55bef7b9ffc8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[17:42:19.481] plan(): Setting new future strategy stack:
[17:42:19.481] List of future strategies:
[17:42:19.481] 1. sequential:
[17:42:19.481]    - args: function (..., envir = parent.frame())
[17:42:19.481]    - tweaked: FALSE
[17:42:19.481]    - call: plan(strategy)
[17:42:19.481] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[17:42:19.481] getGlobalsAndPackages() ...
[17:42:19.481] Searching for globals...
[17:42:19.484] 
[17:42:19.484] Searching for globals ... DONE
[17:42:19.484] - globals: [0] <none>
[17:42:19.484] getGlobalsAndPackages() ... DONE
[17:42:19.484] run() for ‘Future’ ...
[17:42:19.484] - state: ‘created’
[17:42:19.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.485] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.485] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.485]   - Field: ‘label’
[17:42:19.485]   - Field: ‘local’
[17:42:19.485]   - Field: ‘owner’
[17:42:19.485]   - Field: ‘envir’
[17:42:19.485]   - Field: ‘packages’
[17:42:19.485]   - Field: ‘gc’
[17:42:19.485]   - Field: ‘conditions’
[17:42:19.486]   - Field: ‘expr’
[17:42:19.486]   - Field: ‘uuid’
[17:42:19.486]   - Field: ‘seed’
[17:42:19.486]   - Field: ‘version’
[17:42:19.486]   - Field: ‘result’
[17:42:19.486]   - Field: ‘asynchronous’
[17:42:19.486]   - Field: ‘calls’
[17:42:19.486]   - Field: ‘globals’
[17:42:19.486]   - Field: ‘stdout’
[17:42:19.486]   - Field: ‘earlySignal’
[17:42:19.486]   - Field: ‘lazy’
[17:42:19.487]   - Field: ‘state’
[17:42:19.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.487] - Launch lazy future ...
[17:42:19.487] Packages needed by the future expression (n = 0): <none>
[17:42:19.487] Packages needed by future strategies (n = 0): <none>
[17:42:19.487] {
[17:42:19.487]     {
[17:42:19.487]         {
[17:42:19.487]             ...future.startTime <- base::Sys.time()
[17:42:19.487]             {
[17:42:19.487]                 {
[17:42:19.487]                   {
[17:42:19.487]                     base::local({
[17:42:19.487]                       has_future <- base::requireNamespace("future", 
[17:42:19.487]                         quietly = TRUE)
[17:42:19.487]                       if (has_future) {
[17:42:19.487]                         ns <- base::getNamespace("future")
[17:42:19.487]                         version <- ns[[".package"]][["version"]]
[17:42:19.487]                         if (is.null(version)) 
[17:42:19.487]                           version <- utils::packageVersion("future")
[17:42:19.487]                       }
[17:42:19.487]                       else {
[17:42:19.487]                         version <- NULL
[17:42:19.487]                       }
[17:42:19.487]                       if (!has_future || version < "1.8.0") {
[17:42:19.487]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.487]                           "", base::R.version$version.string), 
[17:42:19.487]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.487]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.487]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.487]                             "release", "version")], collapse = " "), 
[17:42:19.487]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.487]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.487]                           info)
[17:42:19.487]                         info <- base::paste(info, collapse = "; ")
[17:42:19.487]                         if (!has_future) {
[17:42:19.487]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.487]                             info)
[17:42:19.487]                         }
[17:42:19.487]                         else {
[17:42:19.487]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.487]                             info, version)
[17:42:19.487]                         }
[17:42:19.487]                         base::stop(msg)
[17:42:19.487]                       }
[17:42:19.487]                     })
[17:42:19.487]                   }
[17:42:19.487]                   options(future.plan = NULL)
[17:42:19.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.487]                 }
[17:42:19.487]                 ...future.workdir <- getwd()
[17:42:19.487]             }
[17:42:19.487]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.487]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.487]         }
[17:42:19.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.487]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.487]             base::names(...future.oldOptions))
[17:42:19.487]     }
[17:42:19.487]     if (FALSE) {
[17:42:19.487]     }
[17:42:19.487]     else {
[17:42:19.487]         if (TRUE) {
[17:42:19.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.487]                 open = "w")
[17:42:19.487]         }
[17:42:19.487]         else {
[17:42:19.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.487]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.487]         }
[17:42:19.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.487]             base::sink(type = "output", split = FALSE)
[17:42:19.487]             base::close(...future.stdout)
[17:42:19.487]         }, add = TRUE)
[17:42:19.487]     }
[17:42:19.487]     ...future.frame <- base::sys.nframe()
[17:42:19.487]     ...future.conditions <- base::list()
[17:42:19.487]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.487]     if (FALSE) {
[17:42:19.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.487]     }
[17:42:19.487]     ...future.result <- base::tryCatch({
[17:42:19.487]         base::withCallingHandlers({
[17:42:19.487]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.487]             future::FutureResult(value = ...future.value$value, 
[17:42:19.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.487]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.487]                     ...future.globalenv.names))
[17:42:19.487]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.487]         }, condition = base::local({
[17:42:19.487]             c <- base::c
[17:42:19.487]             inherits <- base::inherits
[17:42:19.487]             invokeRestart <- base::invokeRestart
[17:42:19.487]             length <- base::length
[17:42:19.487]             list <- base::list
[17:42:19.487]             seq.int <- base::seq.int
[17:42:19.487]             signalCondition <- base::signalCondition
[17:42:19.487]             sys.calls <- base::sys.calls
[17:42:19.487]             `[[` <- base::`[[`
[17:42:19.487]             `+` <- base::`+`
[17:42:19.487]             `<<-` <- base::`<<-`
[17:42:19.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.487]                   3L)]
[17:42:19.487]             }
[17:42:19.487]             function(cond) {
[17:42:19.487]                 is_error <- inherits(cond, "error")
[17:42:19.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.487]                   NULL)
[17:42:19.487]                 if (is_error) {
[17:42:19.487]                   sessionInformation <- function() {
[17:42:19.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.487]                       search = base::search(), system = base::Sys.info())
[17:42:19.487]                   }
[17:42:19.487]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.487]                     cond$call), session = sessionInformation(), 
[17:42:19.487]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.487]                   signalCondition(cond)
[17:42:19.487]                 }
[17:42:19.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.487]                 "immediateCondition"))) {
[17:42:19.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.487]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.487]                   if (TRUE && !signal) {
[17:42:19.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.487]                     {
[17:42:19.487]                       inherits <- base::inherits
[17:42:19.487]                       invokeRestart <- base::invokeRestart
[17:42:19.487]                       is.null <- base::is.null
[17:42:19.487]                       muffled <- FALSE
[17:42:19.487]                       if (inherits(cond, "message")) {
[17:42:19.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.487]                         if (muffled) 
[17:42:19.487]                           invokeRestart("muffleMessage")
[17:42:19.487]                       }
[17:42:19.487]                       else if (inherits(cond, "warning")) {
[17:42:19.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.487]                         if (muffled) 
[17:42:19.487]                           invokeRestart("muffleWarning")
[17:42:19.487]                       }
[17:42:19.487]                       else if (inherits(cond, "condition")) {
[17:42:19.487]                         if (!is.null(pattern)) {
[17:42:19.487]                           computeRestarts <- base::computeRestarts
[17:42:19.487]                           grepl <- base::grepl
[17:42:19.487]                           restarts <- computeRestarts(cond)
[17:42:19.487]                           for (restart in restarts) {
[17:42:19.487]                             name <- restart$name
[17:42:19.487]                             if (is.null(name)) 
[17:42:19.487]                               next
[17:42:19.487]                             if (!grepl(pattern, name)) 
[17:42:19.487]                               next
[17:42:19.487]                             invokeRestart(restart)
[17:42:19.487]                             muffled <- TRUE
[17:42:19.487]                             break
[17:42:19.487]                           }
[17:42:19.487]                         }
[17:42:19.487]                       }
[17:42:19.487]                       invisible(muffled)
[17:42:19.487]                     }
[17:42:19.487]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.487]                   }
[17:42:19.487]                 }
[17:42:19.487]                 else {
[17:42:19.487]                   if (TRUE) {
[17:42:19.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.487]                     {
[17:42:19.487]                       inherits <- base::inherits
[17:42:19.487]                       invokeRestart <- base::invokeRestart
[17:42:19.487]                       is.null <- base::is.null
[17:42:19.487]                       muffled <- FALSE
[17:42:19.487]                       if (inherits(cond, "message")) {
[17:42:19.487]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.487]                         if (muffled) 
[17:42:19.487]                           invokeRestart("muffleMessage")
[17:42:19.487]                       }
[17:42:19.487]                       else if (inherits(cond, "warning")) {
[17:42:19.487]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.487]                         if (muffled) 
[17:42:19.487]                           invokeRestart("muffleWarning")
[17:42:19.487]                       }
[17:42:19.487]                       else if (inherits(cond, "condition")) {
[17:42:19.487]                         if (!is.null(pattern)) {
[17:42:19.487]                           computeRestarts <- base::computeRestarts
[17:42:19.487]                           grepl <- base::grepl
[17:42:19.487]                           restarts <- computeRestarts(cond)
[17:42:19.487]                           for (restart in restarts) {
[17:42:19.487]                             name <- restart$name
[17:42:19.487]                             if (is.null(name)) 
[17:42:19.487]                               next
[17:42:19.487]                             if (!grepl(pattern, name)) 
[17:42:19.487]                               next
[17:42:19.487]                             invokeRestart(restart)
[17:42:19.487]                             muffled <- TRUE
[17:42:19.487]                             break
[17:42:19.487]                           }
[17:42:19.487]                         }
[17:42:19.487]                       }
[17:42:19.487]                       invisible(muffled)
[17:42:19.487]                     }
[17:42:19.487]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.487]                   }
[17:42:19.487]                 }
[17:42:19.487]             }
[17:42:19.487]         }))
[17:42:19.487]     }, error = function(ex) {
[17:42:19.487]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.487]                 ...future.rng), started = ...future.startTime, 
[17:42:19.487]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.487]             version = "1.8"), class = "FutureResult")
[17:42:19.487]     }, finally = {
[17:42:19.487]         if (!identical(...future.workdir, getwd())) 
[17:42:19.487]             setwd(...future.workdir)
[17:42:19.487]         {
[17:42:19.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.487]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.487]             }
[17:42:19.487]             base::options(...future.oldOptions)
[17:42:19.487]             if (.Platform$OS.type == "windows") {
[17:42:19.487]                 old_names <- names(...future.oldEnvVars)
[17:42:19.487]                 envs <- base::Sys.getenv()
[17:42:19.487]                 names <- names(envs)
[17:42:19.487]                 common <- intersect(names, old_names)
[17:42:19.487]                 added <- setdiff(names, old_names)
[17:42:19.487]                 removed <- setdiff(old_names, names)
[17:42:19.487]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.487]                   envs[common]]
[17:42:19.487]                 NAMES <- toupper(changed)
[17:42:19.487]                 args <- list()
[17:42:19.487]                 for (kk in seq_along(NAMES)) {
[17:42:19.487]                   name <- changed[[kk]]
[17:42:19.487]                   NAME <- NAMES[[kk]]
[17:42:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.487]                     next
[17:42:19.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.487]                 }
[17:42:19.487]                 NAMES <- toupper(added)
[17:42:19.487]                 for (kk in seq_along(NAMES)) {
[17:42:19.487]                   name <- added[[kk]]
[17:42:19.487]                   NAME <- NAMES[[kk]]
[17:42:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.487]                     next
[17:42:19.487]                   args[[name]] <- ""
[17:42:19.487]                 }
[17:42:19.487]                 NAMES <- toupper(removed)
[17:42:19.487]                 for (kk in seq_along(NAMES)) {
[17:42:19.487]                   name <- removed[[kk]]
[17:42:19.487]                   NAME <- NAMES[[kk]]
[17:42:19.487]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.487]                     next
[17:42:19.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.487]                 }
[17:42:19.487]                 if (length(args) > 0) 
[17:42:19.487]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.487]             }
[17:42:19.487]             else {
[17:42:19.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.487]             }
[17:42:19.487]             {
[17:42:19.487]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.487]                   0L) {
[17:42:19.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.487]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.487]                   base::options(opts)
[17:42:19.487]                 }
[17:42:19.487]                 {
[17:42:19.487]                   {
[17:42:19.487]                     NULL
[17:42:19.487]                     RNGkind("Mersenne-Twister")
[17:42:19.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.487]                       inherits = FALSE)
[17:42:19.487]                   }
[17:42:19.487]                   options(future.plan = NULL)
[17:42:19.487]                   if (is.na(NA_character_)) 
[17:42:19.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.487]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.487]                   {
[17:42:19.487]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.487]                     if (!future$lazy) 
[17:42:19.487]                       future <- run(future)
[17:42:19.487]                     invisible(future)
[17:42:19.487]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.487]                 }
[17:42:19.487]             }
[17:42:19.487]         }
[17:42:19.487]     })
[17:42:19.487]     if (TRUE) {
[17:42:19.487]         base::sink(type = "output", split = FALSE)
[17:42:19.487]         if (TRUE) {
[17:42:19.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.487]         }
[17:42:19.487]         else {
[17:42:19.487]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.487]         }
[17:42:19.487]         base::close(...future.stdout)
[17:42:19.487]         ...future.stdout <- NULL
[17:42:19.487]     }
[17:42:19.487]     ...future.result$conditions <- ...future.conditions
[17:42:19.487]     ...future.result$finished <- base::Sys.time()
[17:42:19.487]     ...future.result
[17:42:19.487] }
[17:42:19.489] plan(): Setting new future strategy stack:
[17:42:19.489] List of future strategies:
[17:42:19.489] 1. sequential:
[17:42:19.489]    - args: function (..., envir = parent.frame())
[17:42:19.489]    - tweaked: FALSE
[17:42:19.489]    - call: NULL
[17:42:19.490] plan(): nbrOfWorkers() = 1
[17:42:19.490] plan(): Setting new future strategy stack:
[17:42:19.491] List of future strategies:
[17:42:19.491] 1. sequential:
[17:42:19.491]    - args: function (..., envir = parent.frame())
[17:42:19.491]    - tweaked: FALSE
[17:42:19.491]    - call: plan(strategy)
[17:42:19.491] plan(): nbrOfWorkers() = 1
[17:42:19.491] SequentialFuture started (and completed)
[17:42:19.491] - Launch lazy future ... done
[17:42:19.491] run() for ‘SequentialFuture’ ... done
[17:42:19.491] getGlobalsAndPackages() ...
[17:42:19.492] Searching for globals...
[17:42:19.492] 
[17:42:19.492] Searching for globals ... DONE
[17:42:19.492] - globals: [0] <none>
[17:42:19.492] getGlobalsAndPackages() ... DONE
[17:42:19.492] run() for ‘Future’ ...
[17:42:19.492] - state: ‘created’
[17:42:19.493] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.493] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.493] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.493]   - Field: ‘label’
[17:42:19.493]   - Field: ‘local’
[17:42:19.493]   - Field: ‘owner’
[17:42:19.493]   - Field: ‘envir’
[17:42:19.493]   - Field: ‘packages’
[17:42:19.493]   - Field: ‘gc’
[17:42:19.494]   - Field: ‘conditions’
[17:42:19.494]   - Field: ‘expr’
[17:42:19.494]   - Field: ‘uuid’
[17:42:19.494]   - Field: ‘seed’
[17:42:19.494]   - Field: ‘version’
[17:42:19.494]   - Field: ‘result’
[17:42:19.494]   - Field: ‘asynchronous’
[17:42:19.494]   - Field: ‘calls’
[17:42:19.494]   - Field: ‘globals’
[17:42:19.494]   - Field: ‘stdout’
[17:42:19.494]   - Field: ‘earlySignal’
[17:42:19.495]   - Field: ‘lazy’
[17:42:19.495]   - Field: ‘state’
[17:42:19.495] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.495] - Launch lazy future ...
[17:42:19.495] Packages needed by the future expression (n = 0): <none>
[17:42:19.495] Packages needed by future strategies (n = 0): <none>
[17:42:19.495] {
[17:42:19.495]     {
[17:42:19.495]         {
[17:42:19.495]             ...future.startTime <- base::Sys.time()
[17:42:19.495]             {
[17:42:19.495]                 {
[17:42:19.495]                   {
[17:42:19.495]                     base::local({
[17:42:19.495]                       has_future <- base::requireNamespace("future", 
[17:42:19.495]                         quietly = TRUE)
[17:42:19.495]                       if (has_future) {
[17:42:19.495]                         ns <- base::getNamespace("future")
[17:42:19.495]                         version <- ns[[".package"]][["version"]]
[17:42:19.495]                         if (is.null(version)) 
[17:42:19.495]                           version <- utils::packageVersion("future")
[17:42:19.495]                       }
[17:42:19.495]                       else {
[17:42:19.495]                         version <- NULL
[17:42:19.495]                       }
[17:42:19.495]                       if (!has_future || version < "1.8.0") {
[17:42:19.495]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.495]                           "", base::R.version$version.string), 
[17:42:19.495]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.495]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.495]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.495]                             "release", "version")], collapse = " "), 
[17:42:19.495]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.495]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.495]                           info)
[17:42:19.495]                         info <- base::paste(info, collapse = "; ")
[17:42:19.495]                         if (!has_future) {
[17:42:19.495]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.495]                             info)
[17:42:19.495]                         }
[17:42:19.495]                         else {
[17:42:19.495]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.495]                             info, version)
[17:42:19.495]                         }
[17:42:19.495]                         base::stop(msg)
[17:42:19.495]                       }
[17:42:19.495]                     })
[17:42:19.495]                   }
[17:42:19.495]                   options(future.plan = NULL)
[17:42:19.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.495]                 }
[17:42:19.495]                 ...future.workdir <- getwd()
[17:42:19.495]             }
[17:42:19.495]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.495]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.495]         }
[17:42:19.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.495]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.495]             base::names(...future.oldOptions))
[17:42:19.495]     }
[17:42:19.495]     if (FALSE) {
[17:42:19.495]     }
[17:42:19.495]     else {
[17:42:19.495]         if (TRUE) {
[17:42:19.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.495]                 open = "w")
[17:42:19.495]         }
[17:42:19.495]         else {
[17:42:19.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.495]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.495]         }
[17:42:19.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.495]             base::sink(type = "output", split = FALSE)
[17:42:19.495]             base::close(...future.stdout)
[17:42:19.495]         }, add = TRUE)
[17:42:19.495]     }
[17:42:19.495]     ...future.frame <- base::sys.nframe()
[17:42:19.495]     ...future.conditions <- base::list()
[17:42:19.495]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.495]     if (FALSE) {
[17:42:19.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.495]     }
[17:42:19.495]     ...future.result <- base::tryCatch({
[17:42:19.495]         base::withCallingHandlers({
[17:42:19.495]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.495]             future::FutureResult(value = ...future.value$value, 
[17:42:19.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.495]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.495]                     ...future.globalenv.names))
[17:42:19.495]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.495]         }, condition = base::local({
[17:42:19.495]             c <- base::c
[17:42:19.495]             inherits <- base::inherits
[17:42:19.495]             invokeRestart <- base::invokeRestart
[17:42:19.495]             length <- base::length
[17:42:19.495]             list <- base::list
[17:42:19.495]             seq.int <- base::seq.int
[17:42:19.495]             signalCondition <- base::signalCondition
[17:42:19.495]             sys.calls <- base::sys.calls
[17:42:19.495]             `[[` <- base::`[[`
[17:42:19.495]             `+` <- base::`+`
[17:42:19.495]             `<<-` <- base::`<<-`
[17:42:19.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.495]                   3L)]
[17:42:19.495]             }
[17:42:19.495]             function(cond) {
[17:42:19.495]                 is_error <- inherits(cond, "error")
[17:42:19.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.495]                   NULL)
[17:42:19.495]                 if (is_error) {
[17:42:19.495]                   sessionInformation <- function() {
[17:42:19.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.495]                       search = base::search(), system = base::Sys.info())
[17:42:19.495]                   }
[17:42:19.495]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.495]                     cond$call), session = sessionInformation(), 
[17:42:19.495]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.495]                   signalCondition(cond)
[17:42:19.495]                 }
[17:42:19.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.495]                 "immediateCondition"))) {
[17:42:19.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.495]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.495]                   if (TRUE && !signal) {
[17:42:19.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.495]                     {
[17:42:19.495]                       inherits <- base::inherits
[17:42:19.495]                       invokeRestart <- base::invokeRestart
[17:42:19.495]                       is.null <- base::is.null
[17:42:19.495]                       muffled <- FALSE
[17:42:19.495]                       if (inherits(cond, "message")) {
[17:42:19.495]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.495]                         if (muffled) 
[17:42:19.495]                           invokeRestart("muffleMessage")
[17:42:19.495]                       }
[17:42:19.495]                       else if (inherits(cond, "warning")) {
[17:42:19.495]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.495]                         if (muffled) 
[17:42:19.495]                           invokeRestart("muffleWarning")
[17:42:19.495]                       }
[17:42:19.495]                       else if (inherits(cond, "condition")) {
[17:42:19.495]                         if (!is.null(pattern)) {
[17:42:19.495]                           computeRestarts <- base::computeRestarts
[17:42:19.495]                           grepl <- base::grepl
[17:42:19.495]                           restarts <- computeRestarts(cond)
[17:42:19.495]                           for (restart in restarts) {
[17:42:19.495]                             name <- restart$name
[17:42:19.495]                             if (is.null(name)) 
[17:42:19.495]                               next
[17:42:19.495]                             if (!grepl(pattern, name)) 
[17:42:19.495]                               next
[17:42:19.495]                             invokeRestart(restart)
[17:42:19.495]                             muffled <- TRUE
[17:42:19.495]                             break
[17:42:19.495]                           }
[17:42:19.495]                         }
[17:42:19.495]                       }
[17:42:19.495]                       invisible(muffled)
[17:42:19.495]                     }
[17:42:19.495]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.495]                   }
[17:42:19.495]                 }
[17:42:19.495]                 else {
[17:42:19.495]                   if (TRUE) {
[17:42:19.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.495]                     {
[17:42:19.495]                       inherits <- base::inherits
[17:42:19.495]                       invokeRestart <- base::invokeRestart
[17:42:19.495]                       is.null <- base::is.null
[17:42:19.495]                       muffled <- FALSE
[17:42:19.495]                       if (inherits(cond, "message")) {
[17:42:19.495]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.495]                         if (muffled) 
[17:42:19.495]                           invokeRestart("muffleMessage")
[17:42:19.495]                       }
[17:42:19.495]                       else if (inherits(cond, "warning")) {
[17:42:19.495]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.495]                         if (muffled) 
[17:42:19.495]                           invokeRestart("muffleWarning")
[17:42:19.495]                       }
[17:42:19.495]                       else if (inherits(cond, "condition")) {
[17:42:19.495]                         if (!is.null(pattern)) {
[17:42:19.495]                           computeRestarts <- base::computeRestarts
[17:42:19.495]                           grepl <- base::grepl
[17:42:19.495]                           restarts <- computeRestarts(cond)
[17:42:19.495]                           for (restart in restarts) {
[17:42:19.495]                             name <- restart$name
[17:42:19.495]                             if (is.null(name)) 
[17:42:19.495]                               next
[17:42:19.495]                             if (!grepl(pattern, name)) 
[17:42:19.495]                               next
[17:42:19.495]                             invokeRestart(restart)
[17:42:19.495]                             muffled <- TRUE
[17:42:19.495]                             break
[17:42:19.495]                           }
[17:42:19.495]                         }
[17:42:19.495]                       }
[17:42:19.495]                       invisible(muffled)
[17:42:19.495]                     }
[17:42:19.495]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.495]                   }
[17:42:19.495]                 }
[17:42:19.495]             }
[17:42:19.495]         }))
[17:42:19.495]     }, error = function(ex) {
[17:42:19.495]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.495]                 ...future.rng), started = ...future.startTime, 
[17:42:19.495]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.495]             version = "1.8"), class = "FutureResult")
[17:42:19.495]     }, finally = {
[17:42:19.495]         if (!identical(...future.workdir, getwd())) 
[17:42:19.495]             setwd(...future.workdir)
[17:42:19.495]         {
[17:42:19.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.495]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.495]             }
[17:42:19.495]             base::options(...future.oldOptions)
[17:42:19.495]             if (.Platform$OS.type == "windows") {
[17:42:19.495]                 old_names <- names(...future.oldEnvVars)
[17:42:19.495]                 envs <- base::Sys.getenv()
[17:42:19.495]                 names <- names(envs)
[17:42:19.495]                 common <- intersect(names, old_names)
[17:42:19.495]                 added <- setdiff(names, old_names)
[17:42:19.495]                 removed <- setdiff(old_names, names)
[17:42:19.495]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.495]                   envs[common]]
[17:42:19.495]                 NAMES <- toupper(changed)
[17:42:19.495]                 args <- list()
[17:42:19.495]                 for (kk in seq_along(NAMES)) {
[17:42:19.495]                   name <- changed[[kk]]
[17:42:19.495]                   NAME <- NAMES[[kk]]
[17:42:19.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.495]                     next
[17:42:19.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.495]                 }
[17:42:19.495]                 NAMES <- toupper(added)
[17:42:19.495]                 for (kk in seq_along(NAMES)) {
[17:42:19.495]                   name <- added[[kk]]
[17:42:19.495]                   NAME <- NAMES[[kk]]
[17:42:19.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.495]                     next
[17:42:19.495]                   args[[name]] <- ""
[17:42:19.495]                 }
[17:42:19.495]                 NAMES <- toupper(removed)
[17:42:19.495]                 for (kk in seq_along(NAMES)) {
[17:42:19.495]                   name <- removed[[kk]]
[17:42:19.495]                   NAME <- NAMES[[kk]]
[17:42:19.495]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.495]                     next
[17:42:19.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.495]                 }
[17:42:19.495]                 if (length(args) > 0) 
[17:42:19.495]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.495]             }
[17:42:19.495]             else {
[17:42:19.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.495]             }
[17:42:19.495]             {
[17:42:19.495]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.495]                   0L) {
[17:42:19.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.495]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.495]                   base::options(opts)
[17:42:19.495]                 }
[17:42:19.495]                 {
[17:42:19.495]                   {
[17:42:19.495]                     NULL
[17:42:19.495]                     RNGkind("Mersenne-Twister")
[17:42:19.495]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.495]                       inherits = FALSE)
[17:42:19.495]                   }
[17:42:19.495]                   options(future.plan = NULL)
[17:42:19.495]                   if (is.na(NA_character_)) 
[17:42:19.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.495]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.495]                   {
[17:42:19.495]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.495]                     if (!future$lazy) 
[17:42:19.495]                       future <- run(future)
[17:42:19.495]                     invisible(future)
[17:42:19.495]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.495]                 }
[17:42:19.495]             }
[17:42:19.495]         }
[17:42:19.495]     })
[17:42:19.495]     if (TRUE) {
[17:42:19.495]         base::sink(type = "output", split = FALSE)
[17:42:19.495]         if (TRUE) {
[17:42:19.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.495]         }
[17:42:19.495]         else {
[17:42:19.495]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.495]         }
[17:42:19.495]         base::close(...future.stdout)
[17:42:19.495]         ...future.stdout <- NULL
[17:42:19.495]     }
[17:42:19.495]     ...future.result$conditions <- ...future.conditions
[17:42:19.495]     ...future.result$finished <- base::Sys.time()
[17:42:19.495]     ...future.result
[17:42:19.495] }
[17:42:19.497] plan(): Setting new future strategy stack:
[17:42:19.497] List of future strategies:
[17:42:19.497] 1. sequential:
[17:42:19.497]    - args: function (..., envir = parent.frame())
[17:42:19.497]    - tweaked: FALSE
[17:42:19.497]    - call: NULL
[17:42:19.498] plan(): nbrOfWorkers() = 1
[17:42:19.498] plan(): Setting new future strategy stack:
[17:42:19.498] List of future strategies:
[17:42:19.498] 1. sequential:
[17:42:19.498]    - args: function (..., envir = parent.frame())
[17:42:19.498]    - tweaked: FALSE
[17:42:19.498]    - call: plan(strategy)
[17:42:19.499] plan(): nbrOfWorkers() = 1
[17:42:19.499] SequentialFuture started (and completed)
[17:42:19.499] - Launch lazy future ... done
[17:42:19.499] run() for ‘SequentialFuture’ ... done
[17:42:19.500] getGlobalsAndPackages() ...
[17:42:19.500] Searching for globals...
[17:42:19.500] - globals found: [1] ‘{’
[17:42:19.501] Searching for globals ... DONE
[17:42:19.501] Resolving globals: FALSE
[17:42:19.501] 
[17:42:19.501] 
[17:42:19.501] getGlobalsAndPackages() ... DONE
[17:42:19.501] run() for ‘Future’ ...
[17:42:19.501] - state: ‘created’
[17:42:19.502] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.502] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.502]   - Field: ‘label’
[17:42:19.502]   - Field: ‘local’
[17:42:19.502]   - Field: ‘owner’
[17:42:19.502]   - Field: ‘envir’
[17:42:19.503]   - Field: ‘packages’
[17:42:19.503]   - Field: ‘gc’
[17:42:19.503]   - Field: ‘conditions’
[17:42:19.503]   - Field: ‘expr’
[17:42:19.503]   - Field: ‘uuid’
[17:42:19.503]   - Field: ‘seed’
[17:42:19.503]   - Field: ‘version’
[17:42:19.503]   - Field: ‘result’
[17:42:19.504]   - Field: ‘asynchronous’
[17:42:19.504]   - Field: ‘calls’
[17:42:19.504]   - Field: ‘globals’
[17:42:19.504]   - Field: ‘stdout’
[17:42:19.504]   - Field: ‘earlySignal’
[17:42:19.504]   - Field: ‘lazy’
[17:42:19.504]   - Field: ‘state’
[17:42:19.504] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.504] - Launch lazy future ...
[17:42:19.504] Packages needed by the future expression (n = 0): <none>
[17:42:19.505] Packages needed by future strategies (n = 0): <none>
[17:42:19.505] {
[17:42:19.505]     {
[17:42:19.505]         {
[17:42:19.505]             ...future.startTime <- base::Sys.time()
[17:42:19.505]             {
[17:42:19.505]                 {
[17:42:19.505]                   {
[17:42:19.505]                     base::local({
[17:42:19.505]                       has_future <- base::requireNamespace("future", 
[17:42:19.505]                         quietly = TRUE)
[17:42:19.505]                       if (has_future) {
[17:42:19.505]                         ns <- base::getNamespace("future")
[17:42:19.505]                         version <- ns[[".package"]][["version"]]
[17:42:19.505]                         if (is.null(version)) 
[17:42:19.505]                           version <- utils::packageVersion("future")
[17:42:19.505]                       }
[17:42:19.505]                       else {
[17:42:19.505]                         version <- NULL
[17:42:19.505]                       }
[17:42:19.505]                       if (!has_future || version < "1.8.0") {
[17:42:19.505]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.505]                           "", base::R.version$version.string), 
[17:42:19.505]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.505]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.505]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.505]                             "release", "version")], collapse = " "), 
[17:42:19.505]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.505]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.505]                           info)
[17:42:19.505]                         info <- base::paste(info, collapse = "; ")
[17:42:19.505]                         if (!has_future) {
[17:42:19.505]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.505]                             info)
[17:42:19.505]                         }
[17:42:19.505]                         else {
[17:42:19.505]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.505]                             info, version)
[17:42:19.505]                         }
[17:42:19.505]                         base::stop(msg)
[17:42:19.505]                       }
[17:42:19.505]                     })
[17:42:19.505]                   }
[17:42:19.505]                   options(future.plan = NULL)
[17:42:19.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.505]                 }
[17:42:19.505]                 ...future.workdir <- getwd()
[17:42:19.505]             }
[17:42:19.505]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.505]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.505]         }
[17:42:19.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.505]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.505]             base::names(...future.oldOptions))
[17:42:19.505]     }
[17:42:19.505]     if (FALSE) {
[17:42:19.505]     }
[17:42:19.505]     else {
[17:42:19.505]         if (TRUE) {
[17:42:19.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.505]                 open = "w")
[17:42:19.505]         }
[17:42:19.505]         else {
[17:42:19.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.505]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.505]         }
[17:42:19.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.505]             base::sink(type = "output", split = FALSE)
[17:42:19.505]             base::close(...future.stdout)
[17:42:19.505]         }, add = TRUE)
[17:42:19.505]     }
[17:42:19.505]     ...future.frame <- base::sys.nframe()
[17:42:19.505]     ...future.conditions <- base::list()
[17:42:19.505]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.505]     if (FALSE) {
[17:42:19.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.505]     }
[17:42:19.505]     ...future.result <- base::tryCatch({
[17:42:19.505]         base::withCallingHandlers({
[17:42:19.505]             ...future.value <- base::withVisible(base::local({
[17:42:19.505]                 4
[17:42:19.505]             }))
[17:42:19.505]             future::FutureResult(value = ...future.value$value, 
[17:42:19.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.505]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.505]                     ...future.globalenv.names))
[17:42:19.505]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.505]         }, condition = base::local({
[17:42:19.505]             c <- base::c
[17:42:19.505]             inherits <- base::inherits
[17:42:19.505]             invokeRestart <- base::invokeRestart
[17:42:19.505]             length <- base::length
[17:42:19.505]             list <- base::list
[17:42:19.505]             seq.int <- base::seq.int
[17:42:19.505]             signalCondition <- base::signalCondition
[17:42:19.505]             sys.calls <- base::sys.calls
[17:42:19.505]             `[[` <- base::`[[`
[17:42:19.505]             `+` <- base::`+`
[17:42:19.505]             `<<-` <- base::`<<-`
[17:42:19.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.505]                   3L)]
[17:42:19.505]             }
[17:42:19.505]             function(cond) {
[17:42:19.505]                 is_error <- inherits(cond, "error")
[17:42:19.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.505]                   NULL)
[17:42:19.505]                 if (is_error) {
[17:42:19.505]                   sessionInformation <- function() {
[17:42:19.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.505]                       search = base::search(), system = base::Sys.info())
[17:42:19.505]                   }
[17:42:19.505]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.505]                     cond$call), session = sessionInformation(), 
[17:42:19.505]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.505]                   signalCondition(cond)
[17:42:19.505]                 }
[17:42:19.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.505]                 "immediateCondition"))) {
[17:42:19.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.505]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.505]                   if (TRUE && !signal) {
[17:42:19.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.505]                     {
[17:42:19.505]                       inherits <- base::inherits
[17:42:19.505]                       invokeRestart <- base::invokeRestart
[17:42:19.505]                       is.null <- base::is.null
[17:42:19.505]                       muffled <- FALSE
[17:42:19.505]                       if (inherits(cond, "message")) {
[17:42:19.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.505]                         if (muffled) 
[17:42:19.505]                           invokeRestart("muffleMessage")
[17:42:19.505]                       }
[17:42:19.505]                       else if (inherits(cond, "warning")) {
[17:42:19.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.505]                         if (muffled) 
[17:42:19.505]                           invokeRestart("muffleWarning")
[17:42:19.505]                       }
[17:42:19.505]                       else if (inherits(cond, "condition")) {
[17:42:19.505]                         if (!is.null(pattern)) {
[17:42:19.505]                           computeRestarts <- base::computeRestarts
[17:42:19.505]                           grepl <- base::grepl
[17:42:19.505]                           restarts <- computeRestarts(cond)
[17:42:19.505]                           for (restart in restarts) {
[17:42:19.505]                             name <- restart$name
[17:42:19.505]                             if (is.null(name)) 
[17:42:19.505]                               next
[17:42:19.505]                             if (!grepl(pattern, name)) 
[17:42:19.505]                               next
[17:42:19.505]                             invokeRestart(restart)
[17:42:19.505]                             muffled <- TRUE
[17:42:19.505]                             break
[17:42:19.505]                           }
[17:42:19.505]                         }
[17:42:19.505]                       }
[17:42:19.505]                       invisible(muffled)
[17:42:19.505]                     }
[17:42:19.505]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.505]                   }
[17:42:19.505]                 }
[17:42:19.505]                 else {
[17:42:19.505]                   if (TRUE) {
[17:42:19.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.505]                     {
[17:42:19.505]                       inherits <- base::inherits
[17:42:19.505]                       invokeRestart <- base::invokeRestart
[17:42:19.505]                       is.null <- base::is.null
[17:42:19.505]                       muffled <- FALSE
[17:42:19.505]                       if (inherits(cond, "message")) {
[17:42:19.505]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.505]                         if (muffled) 
[17:42:19.505]                           invokeRestart("muffleMessage")
[17:42:19.505]                       }
[17:42:19.505]                       else if (inherits(cond, "warning")) {
[17:42:19.505]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.505]                         if (muffled) 
[17:42:19.505]                           invokeRestart("muffleWarning")
[17:42:19.505]                       }
[17:42:19.505]                       else if (inherits(cond, "condition")) {
[17:42:19.505]                         if (!is.null(pattern)) {
[17:42:19.505]                           computeRestarts <- base::computeRestarts
[17:42:19.505]                           grepl <- base::grepl
[17:42:19.505]                           restarts <- computeRestarts(cond)
[17:42:19.505]                           for (restart in restarts) {
[17:42:19.505]                             name <- restart$name
[17:42:19.505]                             if (is.null(name)) 
[17:42:19.505]                               next
[17:42:19.505]                             if (!grepl(pattern, name)) 
[17:42:19.505]                               next
[17:42:19.505]                             invokeRestart(restart)
[17:42:19.505]                             muffled <- TRUE
[17:42:19.505]                             break
[17:42:19.505]                           }
[17:42:19.505]                         }
[17:42:19.505]                       }
[17:42:19.505]                       invisible(muffled)
[17:42:19.505]                     }
[17:42:19.505]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.505]                   }
[17:42:19.505]                 }
[17:42:19.505]             }
[17:42:19.505]         }))
[17:42:19.505]     }, error = function(ex) {
[17:42:19.505]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.505]                 ...future.rng), started = ...future.startTime, 
[17:42:19.505]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.505]             version = "1.8"), class = "FutureResult")
[17:42:19.505]     }, finally = {
[17:42:19.505]         if (!identical(...future.workdir, getwd())) 
[17:42:19.505]             setwd(...future.workdir)
[17:42:19.505]         {
[17:42:19.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.505]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.505]             }
[17:42:19.505]             base::options(...future.oldOptions)
[17:42:19.505]             if (.Platform$OS.type == "windows") {
[17:42:19.505]                 old_names <- names(...future.oldEnvVars)
[17:42:19.505]                 envs <- base::Sys.getenv()
[17:42:19.505]                 names <- names(envs)
[17:42:19.505]                 common <- intersect(names, old_names)
[17:42:19.505]                 added <- setdiff(names, old_names)
[17:42:19.505]                 removed <- setdiff(old_names, names)
[17:42:19.505]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.505]                   envs[common]]
[17:42:19.505]                 NAMES <- toupper(changed)
[17:42:19.505]                 args <- list()
[17:42:19.505]                 for (kk in seq_along(NAMES)) {
[17:42:19.505]                   name <- changed[[kk]]
[17:42:19.505]                   NAME <- NAMES[[kk]]
[17:42:19.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.505]                     next
[17:42:19.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.505]                 }
[17:42:19.505]                 NAMES <- toupper(added)
[17:42:19.505]                 for (kk in seq_along(NAMES)) {
[17:42:19.505]                   name <- added[[kk]]
[17:42:19.505]                   NAME <- NAMES[[kk]]
[17:42:19.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.505]                     next
[17:42:19.505]                   args[[name]] <- ""
[17:42:19.505]                 }
[17:42:19.505]                 NAMES <- toupper(removed)
[17:42:19.505]                 for (kk in seq_along(NAMES)) {
[17:42:19.505]                   name <- removed[[kk]]
[17:42:19.505]                   NAME <- NAMES[[kk]]
[17:42:19.505]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.505]                     next
[17:42:19.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.505]                 }
[17:42:19.505]                 if (length(args) > 0) 
[17:42:19.505]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.505]             }
[17:42:19.505]             else {
[17:42:19.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.505]             }
[17:42:19.505]             {
[17:42:19.505]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.505]                   0L) {
[17:42:19.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.505]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.505]                   base::options(opts)
[17:42:19.505]                 }
[17:42:19.505]                 {
[17:42:19.505]                   {
[17:42:19.505]                     NULL
[17:42:19.505]                     RNGkind("Mersenne-Twister")
[17:42:19.505]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.505]                       inherits = FALSE)
[17:42:19.505]                   }
[17:42:19.505]                   options(future.plan = NULL)
[17:42:19.505]                   if (is.na(NA_character_)) 
[17:42:19.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.505]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.505]                   {
[17:42:19.505]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.505]                     if (!future$lazy) 
[17:42:19.505]                       future <- run(future)
[17:42:19.505]                     invisible(future)
[17:42:19.505]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.505]                 }
[17:42:19.505]             }
[17:42:19.505]         }
[17:42:19.505]     })
[17:42:19.505]     if (TRUE) {
[17:42:19.505]         base::sink(type = "output", split = FALSE)
[17:42:19.505]         if (TRUE) {
[17:42:19.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.505]         }
[17:42:19.505]         else {
[17:42:19.505]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.505]         }
[17:42:19.505]         base::close(...future.stdout)
[17:42:19.505]         ...future.stdout <- NULL
[17:42:19.505]     }
[17:42:19.505]     ...future.result$conditions <- ...future.conditions
[17:42:19.505]     ...future.result$finished <- base::Sys.time()
[17:42:19.505]     ...future.result
[17:42:19.505] }
[17:42:19.507] plan(): Setting new future strategy stack:
[17:42:19.507] List of future strategies:
[17:42:19.507] 1. sequential:
[17:42:19.507]    - args: function (..., envir = parent.frame())
[17:42:19.507]    - tweaked: FALSE
[17:42:19.507]    - call: NULL
[17:42:19.508] plan(): nbrOfWorkers() = 1
[17:42:19.508] plan(): Setting new future strategy stack:
[17:42:19.508] List of future strategies:
[17:42:19.508] 1. sequential:
[17:42:19.508]    - args: function (..., envir = parent.frame())
[17:42:19.508]    - tweaked: FALSE
[17:42:19.508]    - call: plan(strategy)
[17:42:19.509] plan(): nbrOfWorkers() = 1
[17:42:19.509] SequentialFuture started (and completed)
[17:42:19.509] - Launch lazy future ... done
[17:42:19.509] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef84afa88> 
Classes 'listenv', 'environment' <environment: 0x55bef8408618> 
[17:42:19.515] resolved() for ‘SequentialFuture’ ...
[17:42:19.515] - state: ‘finished’
[17:42:19.515] - run: TRUE
[17:42:19.515] - result: ‘FutureResult’
[17:42:19.515] resolved() for ‘SequentialFuture’ ... done
[17:42:19.516] resolved() for ‘SequentialFuture’ ...
[17:42:19.516] - state: ‘finished’
[17:42:19.516] - run: TRUE
[17:42:19.516] - result: ‘FutureResult’
[17:42:19.516] resolved() for ‘SequentialFuture’ ... done
[17:42:19.516] resolved() for ‘SequentialFuture’ ...
[17:42:19.516] - state: ‘finished’
[17:42:19.516] - run: TRUE
[17:42:19.516] - result: ‘FutureResult’
[17:42:19.516] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:19.518] resolve() on list environment ...
[17:42:19.518]  recursive: 0
[17:42:19.519]  length: 6
[17:42:19.519]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:19.520] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.520] - nx: 6
[17:42:19.520] - relay: TRUE
[17:42:19.520] - stdout: TRUE
[17:42:19.520] - signal: TRUE
[17:42:19.520] - resignal: FALSE
[17:42:19.520] - force: TRUE
[17:42:19.520] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.520] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.520]  - until=2
[17:42:19.520]  - relaying element #2
[17:42:19.521] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.521] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.521] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.521]  length: 5 (resolved future 1)
[17:42:19.521] resolved() for ‘SequentialFuture’ ...
[17:42:19.521] - state: ‘finished’
[17:42:19.521] - run: TRUE
[17:42:19.521] - result: ‘FutureResult’
[17:42:19.521] resolved() for ‘SequentialFuture’ ... done
[17:42:19.521] Future #2
[17:42:19.522] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.522] - nx: 6
[17:42:19.522] - relay: TRUE
[17:42:19.522] - stdout: TRUE
[17:42:19.522] - signal: TRUE
[17:42:19.522] - resignal: FALSE
[17:42:19.522] - force: TRUE
[17:42:19.522] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.522] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.522]  - until=2
[17:42:19.522]  - relaying element #2
[17:42:19.523] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.523] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.523] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.523]  length: 4 (resolved future 2)
[17:42:19.523] resolved() for ‘SequentialFuture’ ...
[17:42:19.523] - state: ‘finished’
[17:42:19.523] - run: TRUE
[17:42:19.523] - result: ‘FutureResult’
[17:42:19.523] resolved() for ‘SequentialFuture’ ... done
[17:42:19.524] Future #3
[17:42:19.524] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.524] - nx: 6
[17:42:19.524] - relay: TRUE
[17:42:19.524] - stdout: TRUE
[17:42:19.524] - signal: TRUE
[17:42:19.524] - resignal: FALSE
[17:42:19.524] - force: TRUE
[17:42:19.524] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.524] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.524]  - until=3
[17:42:19.525]  - relaying element #3
[17:42:19.525] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.525] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.525] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.525]  length: 3 (resolved future 3)
[17:42:19.525] resolved() for ‘SequentialFuture’ ...
[17:42:19.525] - state: ‘finished’
[17:42:19.525] - run: TRUE
[17:42:19.525] - result: ‘FutureResult’
[17:42:19.526] resolved() for ‘SequentialFuture’ ... done
[17:42:19.526] Future #4
[17:42:19.526] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.526] - nx: 6
[17:42:19.526] - relay: TRUE
[17:42:19.526] - stdout: TRUE
[17:42:19.526] - signal: TRUE
[17:42:19.526] - resignal: FALSE
[17:42:19.526] - force: TRUE
[17:42:19.526] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.526] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.527]  - until=4
[17:42:19.527]  - relaying element #4
[17:42:19.527] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.527] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.527] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.527]  length: 2 (resolved future 4)
[17:42:19.527] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.527] - nx: 6
[17:42:19.527] - relay: TRUE
[17:42:19.528] - stdout: TRUE
[17:42:19.528] - signal: TRUE
[17:42:19.528] - resignal: FALSE
[17:42:19.528] - force: TRUE
[17:42:19.528] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.528] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.528]  - until=6
[17:42:19.528]  - relaying element #6
[17:42:19.528] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.528] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.528] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.528]  length: 1 (resolved future 5)
[17:42:19.529] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.529] - nx: 6
[17:42:19.529] - relay: TRUE
[17:42:19.529] - stdout: TRUE
[17:42:19.529] - signal: TRUE
[17:42:19.529] - resignal: FALSE
[17:42:19.529] - force: TRUE
[17:42:19.529] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.529] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.529]  - until=6
[17:42:19.529] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.529] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.530] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.530]  length: 0 (resolved future 6)
[17:42:19.530] Relaying remaining futures
[17:42:19.530] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.530] - nx: 6
[17:42:19.530] - relay: TRUE
[17:42:19.530] - stdout: TRUE
[17:42:19.530] - signal: TRUE
[17:42:19.530] - resignal: FALSE
[17:42:19.530] - force: TRUE
[17:42:19.530] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.530] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:19.531] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.531] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.531] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.531] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef674c2f8> 
Dimensions: c(1, 6)
[17:42:19.532] getGlobalsAndPackages() ...
[17:42:19.532] Searching for globals...
[17:42:19.532] 
[17:42:19.532] Searching for globals ... DONE
[17:42:19.532] - globals: [0] <none>
[17:42:19.532] getGlobalsAndPackages() ... DONE
[17:42:19.533] run() for ‘Future’ ...
[17:42:19.533] - state: ‘created’
[17:42:19.533] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.533] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.533]   - Field: ‘label’
[17:42:19.533]   - Field: ‘local’
[17:42:19.533]   - Field: ‘owner’
[17:42:19.534]   - Field: ‘envir’
[17:42:19.534]   - Field: ‘packages’
[17:42:19.534]   - Field: ‘gc’
[17:42:19.534]   - Field: ‘conditions’
[17:42:19.534]   - Field: ‘expr’
[17:42:19.534]   - Field: ‘uuid’
[17:42:19.534]   - Field: ‘seed’
[17:42:19.534]   - Field: ‘version’
[17:42:19.534]   - Field: ‘result’
[17:42:19.534]   - Field: ‘asynchronous’
[17:42:19.535]   - Field: ‘calls’
[17:42:19.535]   - Field: ‘globals’
[17:42:19.535]   - Field: ‘stdout’
[17:42:19.535]   - Field: ‘earlySignal’
[17:42:19.535]   - Field: ‘lazy’
[17:42:19.535]   - Field: ‘state’
[17:42:19.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.535] - Launch lazy future ...
[17:42:19.535] Packages needed by the future expression (n = 0): <none>
[17:42:19.535] Packages needed by future strategies (n = 0): <none>
[17:42:19.563] {
[17:42:19.563]     {
[17:42:19.563]         {
[17:42:19.563]             ...future.startTime <- base::Sys.time()
[17:42:19.563]             {
[17:42:19.563]                 {
[17:42:19.563]                   {
[17:42:19.563]                     base::local({
[17:42:19.563]                       has_future <- base::requireNamespace("future", 
[17:42:19.563]                         quietly = TRUE)
[17:42:19.563]                       if (has_future) {
[17:42:19.563]                         ns <- base::getNamespace("future")
[17:42:19.563]                         version <- ns[[".package"]][["version"]]
[17:42:19.563]                         if (is.null(version)) 
[17:42:19.563]                           version <- utils::packageVersion("future")
[17:42:19.563]                       }
[17:42:19.563]                       else {
[17:42:19.563]                         version <- NULL
[17:42:19.563]                       }
[17:42:19.563]                       if (!has_future || version < "1.8.0") {
[17:42:19.563]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.563]                           "", base::R.version$version.string), 
[17:42:19.563]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.563]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.563]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.563]                             "release", "version")], collapse = " "), 
[17:42:19.563]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.563]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.563]                           info)
[17:42:19.563]                         info <- base::paste(info, collapse = "; ")
[17:42:19.563]                         if (!has_future) {
[17:42:19.563]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.563]                             info)
[17:42:19.563]                         }
[17:42:19.563]                         else {
[17:42:19.563]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.563]                             info, version)
[17:42:19.563]                         }
[17:42:19.563]                         base::stop(msg)
[17:42:19.563]                       }
[17:42:19.563]                     })
[17:42:19.563]                   }
[17:42:19.563]                   options(future.plan = NULL)
[17:42:19.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.563]                 }
[17:42:19.563]                 ...future.workdir <- getwd()
[17:42:19.563]             }
[17:42:19.563]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.563]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.563]         }
[17:42:19.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.563]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.563]             base::names(...future.oldOptions))
[17:42:19.563]     }
[17:42:19.563]     if (FALSE) {
[17:42:19.563]     }
[17:42:19.563]     else {
[17:42:19.563]         if (TRUE) {
[17:42:19.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.563]                 open = "w")
[17:42:19.563]         }
[17:42:19.563]         else {
[17:42:19.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.563]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.563]         }
[17:42:19.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.563]             base::sink(type = "output", split = FALSE)
[17:42:19.563]             base::close(...future.stdout)
[17:42:19.563]         }, add = TRUE)
[17:42:19.563]     }
[17:42:19.563]     ...future.frame <- base::sys.nframe()
[17:42:19.563]     ...future.conditions <- base::list()
[17:42:19.563]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.563]     if (FALSE) {
[17:42:19.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.563]     }
[17:42:19.563]     ...future.result <- base::tryCatch({
[17:42:19.563]         base::withCallingHandlers({
[17:42:19.563]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.563]             future::FutureResult(value = ...future.value$value, 
[17:42:19.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.563]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.563]                     ...future.globalenv.names))
[17:42:19.563]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.563]         }, condition = base::local({
[17:42:19.563]             c <- base::c
[17:42:19.563]             inherits <- base::inherits
[17:42:19.563]             invokeRestart <- base::invokeRestart
[17:42:19.563]             length <- base::length
[17:42:19.563]             list <- base::list
[17:42:19.563]             seq.int <- base::seq.int
[17:42:19.563]             signalCondition <- base::signalCondition
[17:42:19.563]             sys.calls <- base::sys.calls
[17:42:19.563]             `[[` <- base::`[[`
[17:42:19.563]             `+` <- base::`+`
[17:42:19.563]             `<<-` <- base::`<<-`
[17:42:19.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.563]                   3L)]
[17:42:19.563]             }
[17:42:19.563]             function(cond) {
[17:42:19.563]                 is_error <- inherits(cond, "error")
[17:42:19.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.563]                   NULL)
[17:42:19.563]                 if (is_error) {
[17:42:19.563]                   sessionInformation <- function() {
[17:42:19.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.563]                       search = base::search(), system = base::Sys.info())
[17:42:19.563]                   }
[17:42:19.563]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.563]                     cond$call), session = sessionInformation(), 
[17:42:19.563]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.563]                   signalCondition(cond)
[17:42:19.563]                 }
[17:42:19.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.563]                 "immediateCondition"))) {
[17:42:19.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.563]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.563]                   if (TRUE && !signal) {
[17:42:19.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.563]                     {
[17:42:19.563]                       inherits <- base::inherits
[17:42:19.563]                       invokeRestart <- base::invokeRestart
[17:42:19.563]                       is.null <- base::is.null
[17:42:19.563]                       muffled <- FALSE
[17:42:19.563]                       if (inherits(cond, "message")) {
[17:42:19.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.563]                         if (muffled) 
[17:42:19.563]                           invokeRestart("muffleMessage")
[17:42:19.563]                       }
[17:42:19.563]                       else if (inherits(cond, "warning")) {
[17:42:19.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.563]                         if (muffled) 
[17:42:19.563]                           invokeRestart("muffleWarning")
[17:42:19.563]                       }
[17:42:19.563]                       else if (inherits(cond, "condition")) {
[17:42:19.563]                         if (!is.null(pattern)) {
[17:42:19.563]                           computeRestarts <- base::computeRestarts
[17:42:19.563]                           grepl <- base::grepl
[17:42:19.563]                           restarts <- computeRestarts(cond)
[17:42:19.563]                           for (restart in restarts) {
[17:42:19.563]                             name <- restart$name
[17:42:19.563]                             if (is.null(name)) 
[17:42:19.563]                               next
[17:42:19.563]                             if (!grepl(pattern, name)) 
[17:42:19.563]                               next
[17:42:19.563]                             invokeRestart(restart)
[17:42:19.563]                             muffled <- TRUE
[17:42:19.563]                             break
[17:42:19.563]                           }
[17:42:19.563]                         }
[17:42:19.563]                       }
[17:42:19.563]                       invisible(muffled)
[17:42:19.563]                     }
[17:42:19.563]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.563]                   }
[17:42:19.563]                 }
[17:42:19.563]                 else {
[17:42:19.563]                   if (TRUE) {
[17:42:19.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.563]                     {
[17:42:19.563]                       inherits <- base::inherits
[17:42:19.563]                       invokeRestart <- base::invokeRestart
[17:42:19.563]                       is.null <- base::is.null
[17:42:19.563]                       muffled <- FALSE
[17:42:19.563]                       if (inherits(cond, "message")) {
[17:42:19.563]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.563]                         if (muffled) 
[17:42:19.563]                           invokeRestart("muffleMessage")
[17:42:19.563]                       }
[17:42:19.563]                       else if (inherits(cond, "warning")) {
[17:42:19.563]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.563]                         if (muffled) 
[17:42:19.563]                           invokeRestart("muffleWarning")
[17:42:19.563]                       }
[17:42:19.563]                       else if (inherits(cond, "condition")) {
[17:42:19.563]                         if (!is.null(pattern)) {
[17:42:19.563]                           computeRestarts <- base::computeRestarts
[17:42:19.563]                           grepl <- base::grepl
[17:42:19.563]                           restarts <- computeRestarts(cond)
[17:42:19.563]                           for (restart in restarts) {
[17:42:19.563]                             name <- restart$name
[17:42:19.563]                             if (is.null(name)) 
[17:42:19.563]                               next
[17:42:19.563]                             if (!grepl(pattern, name)) 
[17:42:19.563]                               next
[17:42:19.563]                             invokeRestart(restart)
[17:42:19.563]                             muffled <- TRUE
[17:42:19.563]                             break
[17:42:19.563]                           }
[17:42:19.563]                         }
[17:42:19.563]                       }
[17:42:19.563]                       invisible(muffled)
[17:42:19.563]                     }
[17:42:19.563]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.563]                   }
[17:42:19.563]                 }
[17:42:19.563]             }
[17:42:19.563]         }))
[17:42:19.563]     }, error = function(ex) {
[17:42:19.563]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.563]                 ...future.rng), started = ...future.startTime, 
[17:42:19.563]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.563]             version = "1.8"), class = "FutureResult")
[17:42:19.563]     }, finally = {
[17:42:19.563]         if (!identical(...future.workdir, getwd())) 
[17:42:19.563]             setwd(...future.workdir)
[17:42:19.563]         {
[17:42:19.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.563]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.563]             }
[17:42:19.563]             base::options(...future.oldOptions)
[17:42:19.563]             if (.Platform$OS.type == "windows") {
[17:42:19.563]                 old_names <- names(...future.oldEnvVars)
[17:42:19.563]                 envs <- base::Sys.getenv()
[17:42:19.563]                 names <- names(envs)
[17:42:19.563]                 common <- intersect(names, old_names)
[17:42:19.563]                 added <- setdiff(names, old_names)
[17:42:19.563]                 removed <- setdiff(old_names, names)
[17:42:19.563]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.563]                   envs[common]]
[17:42:19.563]                 NAMES <- toupper(changed)
[17:42:19.563]                 args <- list()
[17:42:19.563]                 for (kk in seq_along(NAMES)) {
[17:42:19.563]                   name <- changed[[kk]]
[17:42:19.563]                   NAME <- NAMES[[kk]]
[17:42:19.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.563]                     next
[17:42:19.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.563]                 }
[17:42:19.563]                 NAMES <- toupper(added)
[17:42:19.563]                 for (kk in seq_along(NAMES)) {
[17:42:19.563]                   name <- added[[kk]]
[17:42:19.563]                   NAME <- NAMES[[kk]]
[17:42:19.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.563]                     next
[17:42:19.563]                   args[[name]] <- ""
[17:42:19.563]                 }
[17:42:19.563]                 NAMES <- toupper(removed)
[17:42:19.563]                 for (kk in seq_along(NAMES)) {
[17:42:19.563]                   name <- removed[[kk]]
[17:42:19.563]                   NAME <- NAMES[[kk]]
[17:42:19.563]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.563]                     next
[17:42:19.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.563]                 }
[17:42:19.563]                 if (length(args) > 0) 
[17:42:19.563]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.563]             }
[17:42:19.563]             else {
[17:42:19.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.563]             }
[17:42:19.563]             {
[17:42:19.563]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.563]                   0L) {
[17:42:19.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.563]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.563]                   base::options(opts)
[17:42:19.563]                 }
[17:42:19.563]                 {
[17:42:19.563]                   {
[17:42:19.563]                     NULL
[17:42:19.563]                     RNGkind("Mersenne-Twister")
[17:42:19.563]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.563]                       inherits = FALSE)
[17:42:19.563]                   }
[17:42:19.563]                   options(future.plan = NULL)
[17:42:19.563]                   if (is.na(NA_character_)) 
[17:42:19.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.563]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.563]                   {
[17:42:19.563]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.563]                     if (!future$lazy) 
[17:42:19.563]                       future <- run(future)
[17:42:19.563]                     invisible(future)
[17:42:19.563]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.563]                 }
[17:42:19.563]             }
[17:42:19.563]         }
[17:42:19.563]     })
[17:42:19.563]     if (TRUE) {
[17:42:19.563]         base::sink(type = "output", split = FALSE)
[17:42:19.563]         if (TRUE) {
[17:42:19.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.563]         }
[17:42:19.563]         else {
[17:42:19.563]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.563]         }
[17:42:19.563]         base::close(...future.stdout)
[17:42:19.563]         ...future.stdout <- NULL
[17:42:19.563]     }
[17:42:19.563]     ...future.result$conditions <- ...future.conditions
[17:42:19.563]     ...future.result$finished <- base::Sys.time()
[17:42:19.563]     ...future.result
[17:42:19.563] }
[17:42:19.565] plan(): Setting new future strategy stack:
[17:42:19.565] List of future strategies:
[17:42:19.565] 1. sequential:
[17:42:19.565]    - args: function (..., envir = parent.frame())
[17:42:19.565]    - tweaked: FALSE
[17:42:19.565]    - call: NULL
[17:42:19.566] plan(): nbrOfWorkers() = 1
[17:42:19.567] plan(): Setting new future strategy stack:
[17:42:19.567] List of future strategies:
[17:42:19.567] 1. sequential:
[17:42:19.567]    - args: function (..., envir = parent.frame())
[17:42:19.567]    - tweaked: FALSE
[17:42:19.567]    - call: plan(strategy)
[17:42:19.567] plan(): nbrOfWorkers() = 1
[17:42:19.568] SequentialFuture started (and completed)
[17:42:19.568] - Launch lazy future ... done
[17:42:19.568] run() for ‘SequentialFuture’ ... done
[17:42:19.568] getGlobalsAndPackages() ...
[17:42:19.568] Searching for globals...
[17:42:19.568] 
[17:42:19.569] Searching for globals ... DONE
[17:42:19.569] - globals: [0] <none>
[17:42:19.569] getGlobalsAndPackages() ... DONE
[17:42:19.569] run() for ‘Future’ ...
[17:42:19.569] - state: ‘created’
[17:42:19.569] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.570] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.570]   - Field: ‘label’
[17:42:19.570]   - Field: ‘local’
[17:42:19.570]   - Field: ‘owner’
[17:42:19.570]   - Field: ‘envir’
[17:42:19.570]   - Field: ‘packages’
[17:42:19.570]   - Field: ‘gc’
[17:42:19.571]   - Field: ‘conditions’
[17:42:19.571]   - Field: ‘expr’
[17:42:19.571]   - Field: ‘uuid’
[17:42:19.571]   - Field: ‘seed’
[17:42:19.571]   - Field: ‘version’
[17:42:19.571]   - Field: ‘result’
[17:42:19.571]   - Field: ‘asynchronous’
[17:42:19.571]   - Field: ‘calls’
[17:42:19.571]   - Field: ‘globals’
[17:42:19.571]   - Field: ‘stdout’
[17:42:19.572]   - Field: ‘earlySignal’
[17:42:19.572]   - Field: ‘lazy’
[17:42:19.572]   - Field: ‘state’
[17:42:19.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.572] - Launch lazy future ...
[17:42:19.572] Packages needed by the future expression (n = 0): <none>
[17:42:19.572] Packages needed by future strategies (n = 0): <none>
[17:42:19.573] {
[17:42:19.573]     {
[17:42:19.573]         {
[17:42:19.573]             ...future.startTime <- base::Sys.time()
[17:42:19.573]             {
[17:42:19.573]                 {
[17:42:19.573]                   {
[17:42:19.573]                     base::local({
[17:42:19.573]                       has_future <- base::requireNamespace("future", 
[17:42:19.573]                         quietly = TRUE)
[17:42:19.573]                       if (has_future) {
[17:42:19.573]                         ns <- base::getNamespace("future")
[17:42:19.573]                         version <- ns[[".package"]][["version"]]
[17:42:19.573]                         if (is.null(version)) 
[17:42:19.573]                           version <- utils::packageVersion("future")
[17:42:19.573]                       }
[17:42:19.573]                       else {
[17:42:19.573]                         version <- NULL
[17:42:19.573]                       }
[17:42:19.573]                       if (!has_future || version < "1.8.0") {
[17:42:19.573]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.573]                           "", base::R.version$version.string), 
[17:42:19.573]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.573]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.573]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.573]                             "release", "version")], collapse = " "), 
[17:42:19.573]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.573]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.573]                           info)
[17:42:19.573]                         info <- base::paste(info, collapse = "; ")
[17:42:19.573]                         if (!has_future) {
[17:42:19.573]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.573]                             info)
[17:42:19.573]                         }
[17:42:19.573]                         else {
[17:42:19.573]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.573]                             info, version)
[17:42:19.573]                         }
[17:42:19.573]                         base::stop(msg)
[17:42:19.573]                       }
[17:42:19.573]                     })
[17:42:19.573]                   }
[17:42:19.573]                   options(future.plan = NULL)
[17:42:19.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.573]                 }
[17:42:19.573]                 ...future.workdir <- getwd()
[17:42:19.573]             }
[17:42:19.573]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.573]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.573]         }
[17:42:19.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.573]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.573]             base::names(...future.oldOptions))
[17:42:19.573]     }
[17:42:19.573]     if (FALSE) {
[17:42:19.573]     }
[17:42:19.573]     else {
[17:42:19.573]         if (TRUE) {
[17:42:19.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.573]                 open = "w")
[17:42:19.573]         }
[17:42:19.573]         else {
[17:42:19.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.573]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.573]         }
[17:42:19.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.573]             base::sink(type = "output", split = FALSE)
[17:42:19.573]             base::close(...future.stdout)
[17:42:19.573]         }, add = TRUE)
[17:42:19.573]     }
[17:42:19.573]     ...future.frame <- base::sys.nframe()
[17:42:19.573]     ...future.conditions <- base::list()
[17:42:19.573]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.573]     if (FALSE) {
[17:42:19.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.573]     }
[17:42:19.573]     ...future.result <- base::tryCatch({
[17:42:19.573]         base::withCallingHandlers({
[17:42:19.573]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.573]             future::FutureResult(value = ...future.value$value, 
[17:42:19.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.573]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.573]                     ...future.globalenv.names))
[17:42:19.573]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.573]         }, condition = base::local({
[17:42:19.573]             c <- base::c
[17:42:19.573]             inherits <- base::inherits
[17:42:19.573]             invokeRestart <- base::invokeRestart
[17:42:19.573]             length <- base::length
[17:42:19.573]             list <- base::list
[17:42:19.573]             seq.int <- base::seq.int
[17:42:19.573]             signalCondition <- base::signalCondition
[17:42:19.573]             sys.calls <- base::sys.calls
[17:42:19.573]             `[[` <- base::`[[`
[17:42:19.573]             `+` <- base::`+`
[17:42:19.573]             `<<-` <- base::`<<-`
[17:42:19.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.573]                   3L)]
[17:42:19.573]             }
[17:42:19.573]             function(cond) {
[17:42:19.573]                 is_error <- inherits(cond, "error")
[17:42:19.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.573]                   NULL)
[17:42:19.573]                 if (is_error) {
[17:42:19.573]                   sessionInformation <- function() {
[17:42:19.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.573]                       search = base::search(), system = base::Sys.info())
[17:42:19.573]                   }
[17:42:19.573]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.573]                     cond$call), session = sessionInformation(), 
[17:42:19.573]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.573]                   signalCondition(cond)
[17:42:19.573]                 }
[17:42:19.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.573]                 "immediateCondition"))) {
[17:42:19.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.573]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.573]                   if (TRUE && !signal) {
[17:42:19.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.573]                     {
[17:42:19.573]                       inherits <- base::inherits
[17:42:19.573]                       invokeRestart <- base::invokeRestart
[17:42:19.573]                       is.null <- base::is.null
[17:42:19.573]                       muffled <- FALSE
[17:42:19.573]                       if (inherits(cond, "message")) {
[17:42:19.573]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.573]                         if (muffled) 
[17:42:19.573]                           invokeRestart("muffleMessage")
[17:42:19.573]                       }
[17:42:19.573]                       else if (inherits(cond, "warning")) {
[17:42:19.573]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.573]                         if (muffled) 
[17:42:19.573]                           invokeRestart("muffleWarning")
[17:42:19.573]                       }
[17:42:19.573]                       else if (inherits(cond, "condition")) {
[17:42:19.573]                         if (!is.null(pattern)) {
[17:42:19.573]                           computeRestarts <- base::computeRestarts
[17:42:19.573]                           grepl <- base::grepl
[17:42:19.573]                           restarts <- computeRestarts(cond)
[17:42:19.573]                           for (restart in restarts) {
[17:42:19.573]                             name <- restart$name
[17:42:19.573]                             if (is.null(name)) 
[17:42:19.573]                               next
[17:42:19.573]                             if (!grepl(pattern, name)) 
[17:42:19.573]                               next
[17:42:19.573]                             invokeRestart(restart)
[17:42:19.573]                             muffled <- TRUE
[17:42:19.573]                             break
[17:42:19.573]                           }
[17:42:19.573]                         }
[17:42:19.573]                       }
[17:42:19.573]                       invisible(muffled)
[17:42:19.573]                     }
[17:42:19.573]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.573]                   }
[17:42:19.573]                 }
[17:42:19.573]                 else {
[17:42:19.573]                   if (TRUE) {
[17:42:19.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.573]                     {
[17:42:19.573]                       inherits <- base::inherits
[17:42:19.573]                       invokeRestart <- base::invokeRestart
[17:42:19.573]                       is.null <- base::is.null
[17:42:19.573]                       muffled <- FALSE
[17:42:19.573]                       if (inherits(cond, "message")) {
[17:42:19.573]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.573]                         if (muffled) 
[17:42:19.573]                           invokeRestart("muffleMessage")
[17:42:19.573]                       }
[17:42:19.573]                       else if (inherits(cond, "warning")) {
[17:42:19.573]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.573]                         if (muffled) 
[17:42:19.573]                           invokeRestart("muffleWarning")
[17:42:19.573]                       }
[17:42:19.573]                       else if (inherits(cond, "condition")) {
[17:42:19.573]                         if (!is.null(pattern)) {
[17:42:19.573]                           computeRestarts <- base::computeRestarts
[17:42:19.573]                           grepl <- base::grepl
[17:42:19.573]                           restarts <- computeRestarts(cond)
[17:42:19.573]                           for (restart in restarts) {
[17:42:19.573]                             name <- restart$name
[17:42:19.573]                             if (is.null(name)) 
[17:42:19.573]                               next
[17:42:19.573]                             if (!grepl(pattern, name)) 
[17:42:19.573]                               next
[17:42:19.573]                             invokeRestart(restart)
[17:42:19.573]                             muffled <- TRUE
[17:42:19.573]                             break
[17:42:19.573]                           }
[17:42:19.573]                         }
[17:42:19.573]                       }
[17:42:19.573]                       invisible(muffled)
[17:42:19.573]                     }
[17:42:19.573]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.573]                   }
[17:42:19.573]                 }
[17:42:19.573]             }
[17:42:19.573]         }))
[17:42:19.573]     }, error = function(ex) {
[17:42:19.573]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.573]                 ...future.rng), started = ...future.startTime, 
[17:42:19.573]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.573]             version = "1.8"), class = "FutureResult")
[17:42:19.573]     }, finally = {
[17:42:19.573]         if (!identical(...future.workdir, getwd())) 
[17:42:19.573]             setwd(...future.workdir)
[17:42:19.573]         {
[17:42:19.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.573]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.573]             }
[17:42:19.573]             base::options(...future.oldOptions)
[17:42:19.573]             if (.Platform$OS.type == "windows") {
[17:42:19.573]                 old_names <- names(...future.oldEnvVars)
[17:42:19.573]                 envs <- base::Sys.getenv()
[17:42:19.573]                 names <- names(envs)
[17:42:19.573]                 common <- intersect(names, old_names)
[17:42:19.573]                 added <- setdiff(names, old_names)
[17:42:19.573]                 removed <- setdiff(old_names, names)
[17:42:19.573]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.573]                   envs[common]]
[17:42:19.573]                 NAMES <- toupper(changed)
[17:42:19.573]                 args <- list()
[17:42:19.573]                 for (kk in seq_along(NAMES)) {
[17:42:19.573]                   name <- changed[[kk]]
[17:42:19.573]                   NAME <- NAMES[[kk]]
[17:42:19.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.573]                     next
[17:42:19.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.573]                 }
[17:42:19.573]                 NAMES <- toupper(added)
[17:42:19.573]                 for (kk in seq_along(NAMES)) {
[17:42:19.573]                   name <- added[[kk]]
[17:42:19.573]                   NAME <- NAMES[[kk]]
[17:42:19.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.573]                     next
[17:42:19.573]                   args[[name]] <- ""
[17:42:19.573]                 }
[17:42:19.573]                 NAMES <- toupper(removed)
[17:42:19.573]                 for (kk in seq_along(NAMES)) {
[17:42:19.573]                   name <- removed[[kk]]
[17:42:19.573]                   NAME <- NAMES[[kk]]
[17:42:19.573]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.573]                     next
[17:42:19.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.573]                 }
[17:42:19.573]                 if (length(args) > 0) 
[17:42:19.573]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.573]             }
[17:42:19.573]             else {
[17:42:19.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.573]             }
[17:42:19.573]             {
[17:42:19.573]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.573]                   0L) {
[17:42:19.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.573]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.573]                   base::options(opts)
[17:42:19.573]                 }
[17:42:19.573]                 {
[17:42:19.573]                   {
[17:42:19.573]                     NULL
[17:42:19.573]                     RNGkind("Mersenne-Twister")
[17:42:19.573]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.573]                       inherits = FALSE)
[17:42:19.573]                   }
[17:42:19.573]                   options(future.plan = NULL)
[17:42:19.573]                   if (is.na(NA_character_)) 
[17:42:19.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.573]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.573]                   {
[17:42:19.573]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.573]                     if (!future$lazy) 
[17:42:19.573]                       future <- run(future)
[17:42:19.573]                     invisible(future)
[17:42:19.573]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.573]                 }
[17:42:19.573]             }
[17:42:19.573]         }
[17:42:19.573]     })
[17:42:19.573]     if (TRUE) {
[17:42:19.573]         base::sink(type = "output", split = FALSE)
[17:42:19.573]         if (TRUE) {
[17:42:19.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.573]         }
[17:42:19.573]         else {
[17:42:19.573]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.573]         }
[17:42:19.573]         base::close(...future.stdout)
[17:42:19.573]         ...future.stdout <- NULL
[17:42:19.573]     }
[17:42:19.573]     ...future.result$conditions <- ...future.conditions
[17:42:19.573]     ...future.result$finished <- base::Sys.time()
[17:42:19.573]     ...future.result
[17:42:19.573] }
[17:42:19.574] plan(): Setting new future strategy stack:
[17:42:19.575] List of future strategies:
[17:42:19.575] 1. sequential:
[17:42:19.575]    - args: function (..., envir = parent.frame())
[17:42:19.575]    - tweaked: FALSE
[17:42:19.575]    - call: NULL
[17:42:19.575] plan(): nbrOfWorkers() = 1
[17:42:19.576] plan(): Setting new future strategy stack:
[17:42:19.576] List of future strategies:
[17:42:19.576] 1. sequential:
[17:42:19.576]    - args: function (..., envir = parent.frame())
[17:42:19.576]    - tweaked: FALSE
[17:42:19.576]    - call: plan(strategy)
[17:42:19.576] plan(): nbrOfWorkers() = 1
[17:42:19.576] SequentialFuture started (and completed)
[17:42:19.577] - Launch lazy future ... done
[17:42:19.577] run() for ‘SequentialFuture’ ... done
[17:42:19.577] getGlobalsAndPackages() ...
[17:42:19.577] Searching for globals...
[17:42:19.578] - globals found: [1] ‘{’
[17:42:19.578] Searching for globals ... DONE
[17:42:19.578] Resolving globals: FALSE
[17:42:19.578] 
[17:42:19.578] 
[17:42:19.578] getGlobalsAndPackages() ... DONE
[17:42:19.579] run() for ‘Future’ ...
[17:42:19.579] - state: ‘created’
[17:42:19.579] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.579] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.579]   - Field: ‘label’
[17:42:19.580]   - Field: ‘local’
[17:42:19.580]   - Field: ‘owner’
[17:42:19.580]   - Field: ‘envir’
[17:42:19.580]   - Field: ‘packages’
[17:42:19.580]   - Field: ‘gc’
[17:42:19.580]   - Field: ‘conditions’
[17:42:19.580]   - Field: ‘expr’
[17:42:19.580]   - Field: ‘uuid’
[17:42:19.580]   - Field: ‘seed’
[17:42:19.580]   - Field: ‘version’
[17:42:19.580]   - Field: ‘result’
[17:42:19.581]   - Field: ‘asynchronous’
[17:42:19.581]   - Field: ‘calls’
[17:42:19.581]   - Field: ‘globals’
[17:42:19.581]   - Field: ‘stdout’
[17:42:19.581]   - Field: ‘earlySignal’
[17:42:19.581]   - Field: ‘lazy’
[17:42:19.581]   - Field: ‘state’
[17:42:19.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.581] - Launch lazy future ...
[17:42:19.582] Packages needed by the future expression (n = 0): <none>
[17:42:19.582] Packages needed by future strategies (n = 0): <none>
[17:42:19.582] {
[17:42:19.582]     {
[17:42:19.582]         {
[17:42:19.582]             ...future.startTime <- base::Sys.time()
[17:42:19.582]             {
[17:42:19.582]                 {
[17:42:19.582]                   {
[17:42:19.582]                     base::local({
[17:42:19.582]                       has_future <- base::requireNamespace("future", 
[17:42:19.582]                         quietly = TRUE)
[17:42:19.582]                       if (has_future) {
[17:42:19.582]                         ns <- base::getNamespace("future")
[17:42:19.582]                         version <- ns[[".package"]][["version"]]
[17:42:19.582]                         if (is.null(version)) 
[17:42:19.582]                           version <- utils::packageVersion("future")
[17:42:19.582]                       }
[17:42:19.582]                       else {
[17:42:19.582]                         version <- NULL
[17:42:19.582]                       }
[17:42:19.582]                       if (!has_future || version < "1.8.0") {
[17:42:19.582]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.582]                           "", base::R.version$version.string), 
[17:42:19.582]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.582]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.582]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.582]                             "release", "version")], collapse = " "), 
[17:42:19.582]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.582]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.582]                           info)
[17:42:19.582]                         info <- base::paste(info, collapse = "; ")
[17:42:19.582]                         if (!has_future) {
[17:42:19.582]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.582]                             info)
[17:42:19.582]                         }
[17:42:19.582]                         else {
[17:42:19.582]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.582]                             info, version)
[17:42:19.582]                         }
[17:42:19.582]                         base::stop(msg)
[17:42:19.582]                       }
[17:42:19.582]                     })
[17:42:19.582]                   }
[17:42:19.582]                   options(future.plan = NULL)
[17:42:19.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.582]                 }
[17:42:19.582]                 ...future.workdir <- getwd()
[17:42:19.582]             }
[17:42:19.582]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.582]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.582]         }
[17:42:19.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.582]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.582]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.582]             base::names(...future.oldOptions))
[17:42:19.582]     }
[17:42:19.582]     if (FALSE) {
[17:42:19.582]     }
[17:42:19.582]     else {
[17:42:19.582]         if (TRUE) {
[17:42:19.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.582]                 open = "w")
[17:42:19.582]         }
[17:42:19.582]         else {
[17:42:19.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.582]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.582]         }
[17:42:19.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.582]             base::sink(type = "output", split = FALSE)
[17:42:19.582]             base::close(...future.stdout)
[17:42:19.582]         }, add = TRUE)
[17:42:19.582]     }
[17:42:19.582]     ...future.frame <- base::sys.nframe()
[17:42:19.582]     ...future.conditions <- base::list()
[17:42:19.582]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.582]     if (FALSE) {
[17:42:19.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.582]     }
[17:42:19.582]     ...future.result <- base::tryCatch({
[17:42:19.582]         base::withCallingHandlers({
[17:42:19.582]             ...future.value <- base::withVisible(base::local({
[17:42:19.582]                 4
[17:42:19.582]             }))
[17:42:19.582]             future::FutureResult(value = ...future.value$value, 
[17:42:19.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.582]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.582]                     ...future.globalenv.names))
[17:42:19.582]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.582]         }, condition = base::local({
[17:42:19.582]             c <- base::c
[17:42:19.582]             inherits <- base::inherits
[17:42:19.582]             invokeRestart <- base::invokeRestart
[17:42:19.582]             length <- base::length
[17:42:19.582]             list <- base::list
[17:42:19.582]             seq.int <- base::seq.int
[17:42:19.582]             signalCondition <- base::signalCondition
[17:42:19.582]             sys.calls <- base::sys.calls
[17:42:19.582]             `[[` <- base::`[[`
[17:42:19.582]             `+` <- base::`+`
[17:42:19.582]             `<<-` <- base::`<<-`
[17:42:19.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.582]                   3L)]
[17:42:19.582]             }
[17:42:19.582]             function(cond) {
[17:42:19.582]                 is_error <- inherits(cond, "error")
[17:42:19.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.582]                   NULL)
[17:42:19.582]                 if (is_error) {
[17:42:19.582]                   sessionInformation <- function() {
[17:42:19.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.582]                       search = base::search(), system = base::Sys.info())
[17:42:19.582]                   }
[17:42:19.582]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.582]                     cond$call), session = sessionInformation(), 
[17:42:19.582]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.582]                   signalCondition(cond)
[17:42:19.582]                 }
[17:42:19.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.582]                 "immediateCondition"))) {
[17:42:19.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.582]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.582]                   if (TRUE && !signal) {
[17:42:19.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.582]                     {
[17:42:19.582]                       inherits <- base::inherits
[17:42:19.582]                       invokeRestart <- base::invokeRestart
[17:42:19.582]                       is.null <- base::is.null
[17:42:19.582]                       muffled <- FALSE
[17:42:19.582]                       if (inherits(cond, "message")) {
[17:42:19.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.582]                         if (muffled) 
[17:42:19.582]                           invokeRestart("muffleMessage")
[17:42:19.582]                       }
[17:42:19.582]                       else if (inherits(cond, "warning")) {
[17:42:19.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.582]                         if (muffled) 
[17:42:19.582]                           invokeRestart("muffleWarning")
[17:42:19.582]                       }
[17:42:19.582]                       else if (inherits(cond, "condition")) {
[17:42:19.582]                         if (!is.null(pattern)) {
[17:42:19.582]                           computeRestarts <- base::computeRestarts
[17:42:19.582]                           grepl <- base::grepl
[17:42:19.582]                           restarts <- computeRestarts(cond)
[17:42:19.582]                           for (restart in restarts) {
[17:42:19.582]                             name <- restart$name
[17:42:19.582]                             if (is.null(name)) 
[17:42:19.582]                               next
[17:42:19.582]                             if (!grepl(pattern, name)) 
[17:42:19.582]                               next
[17:42:19.582]                             invokeRestart(restart)
[17:42:19.582]                             muffled <- TRUE
[17:42:19.582]                             break
[17:42:19.582]                           }
[17:42:19.582]                         }
[17:42:19.582]                       }
[17:42:19.582]                       invisible(muffled)
[17:42:19.582]                     }
[17:42:19.582]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.582]                   }
[17:42:19.582]                 }
[17:42:19.582]                 else {
[17:42:19.582]                   if (TRUE) {
[17:42:19.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.582]                     {
[17:42:19.582]                       inherits <- base::inherits
[17:42:19.582]                       invokeRestart <- base::invokeRestart
[17:42:19.582]                       is.null <- base::is.null
[17:42:19.582]                       muffled <- FALSE
[17:42:19.582]                       if (inherits(cond, "message")) {
[17:42:19.582]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.582]                         if (muffled) 
[17:42:19.582]                           invokeRestart("muffleMessage")
[17:42:19.582]                       }
[17:42:19.582]                       else if (inherits(cond, "warning")) {
[17:42:19.582]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.582]                         if (muffled) 
[17:42:19.582]                           invokeRestart("muffleWarning")
[17:42:19.582]                       }
[17:42:19.582]                       else if (inherits(cond, "condition")) {
[17:42:19.582]                         if (!is.null(pattern)) {
[17:42:19.582]                           computeRestarts <- base::computeRestarts
[17:42:19.582]                           grepl <- base::grepl
[17:42:19.582]                           restarts <- computeRestarts(cond)
[17:42:19.582]                           for (restart in restarts) {
[17:42:19.582]                             name <- restart$name
[17:42:19.582]                             if (is.null(name)) 
[17:42:19.582]                               next
[17:42:19.582]                             if (!grepl(pattern, name)) 
[17:42:19.582]                               next
[17:42:19.582]                             invokeRestart(restart)
[17:42:19.582]                             muffled <- TRUE
[17:42:19.582]                             break
[17:42:19.582]                           }
[17:42:19.582]                         }
[17:42:19.582]                       }
[17:42:19.582]                       invisible(muffled)
[17:42:19.582]                     }
[17:42:19.582]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.582]                   }
[17:42:19.582]                 }
[17:42:19.582]             }
[17:42:19.582]         }))
[17:42:19.582]     }, error = function(ex) {
[17:42:19.582]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.582]                 ...future.rng), started = ...future.startTime, 
[17:42:19.582]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.582]             version = "1.8"), class = "FutureResult")
[17:42:19.582]     }, finally = {
[17:42:19.582]         if (!identical(...future.workdir, getwd())) 
[17:42:19.582]             setwd(...future.workdir)
[17:42:19.582]         {
[17:42:19.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.582]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.582]             }
[17:42:19.582]             base::options(...future.oldOptions)
[17:42:19.582]             if (.Platform$OS.type == "windows") {
[17:42:19.582]                 old_names <- names(...future.oldEnvVars)
[17:42:19.582]                 envs <- base::Sys.getenv()
[17:42:19.582]                 names <- names(envs)
[17:42:19.582]                 common <- intersect(names, old_names)
[17:42:19.582]                 added <- setdiff(names, old_names)
[17:42:19.582]                 removed <- setdiff(old_names, names)
[17:42:19.582]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.582]                   envs[common]]
[17:42:19.582]                 NAMES <- toupper(changed)
[17:42:19.582]                 args <- list()
[17:42:19.582]                 for (kk in seq_along(NAMES)) {
[17:42:19.582]                   name <- changed[[kk]]
[17:42:19.582]                   NAME <- NAMES[[kk]]
[17:42:19.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.582]                     next
[17:42:19.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.582]                 }
[17:42:19.582]                 NAMES <- toupper(added)
[17:42:19.582]                 for (kk in seq_along(NAMES)) {
[17:42:19.582]                   name <- added[[kk]]
[17:42:19.582]                   NAME <- NAMES[[kk]]
[17:42:19.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.582]                     next
[17:42:19.582]                   args[[name]] <- ""
[17:42:19.582]                 }
[17:42:19.582]                 NAMES <- toupper(removed)
[17:42:19.582]                 for (kk in seq_along(NAMES)) {
[17:42:19.582]                   name <- removed[[kk]]
[17:42:19.582]                   NAME <- NAMES[[kk]]
[17:42:19.582]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.582]                     next
[17:42:19.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.582]                 }
[17:42:19.582]                 if (length(args) > 0) 
[17:42:19.582]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.582]             }
[17:42:19.582]             else {
[17:42:19.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.582]             }
[17:42:19.582]             {
[17:42:19.582]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.582]                   0L) {
[17:42:19.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.582]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.582]                   base::options(opts)
[17:42:19.582]                 }
[17:42:19.582]                 {
[17:42:19.582]                   {
[17:42:19.582]                     NULL
[17:42:19.582]                     RNGkind("Mersenne-Twister")
[17:42:19.582]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.582]                       inherits = FALSE)
[17:42:19.582]                   }
[17:42:19.582]                   options(future.plan = NULL)
[17:42:19.582]                   if (is.na(NA_character_)) 
[17:42:19.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.582]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.582]                   {
[17:42:19.582]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.582]                     if (!future$lazy) 
[17:42:19.582]                       future <- run(future)
[17:42:19.582]                     invisible(future)
[17:42:19.582]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.582]                 }
[17:42:19.582]             }
[17:42:19.582]         }
[17:42:19.582]     })
[17:42:19.582]     if (TRUE) {
[17:42:19.582]         base::sink(type = "output", split = FALSE)
[17:42:19.582]         if (TRUE) {
[17:42:19.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.582]         }
[17:42:19.582]         else {
[17:42:19.582]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.582]         }
[17:42:19.582]         base::close(...future.stdout)
[17:42:19.582]         ...future.stdout <- NULL
[17:42:19.582]     }
[17:42:19.582]     ...future.result$conditions <- ...future.conditions
[17:42:19.582]     ...future.result$finished <- base::Sys.time()
[17:42:19.582]     ...future.result
[17:42:19.582] }
[17:42:19.584] plan(): Setting new future strategy stack:
[17:42:19.584] List of future strategies:
[17:42:19.584] 1. sequential:
[17:42:19.584]    - args: function (..., envir = parent.frame())
[17:42:19.584]    - tweaked: FALSE
[17:42:19.584]    - call: NULL
[17:42:19.584] plan(): nbrOfWorkers() = 1
[17:42:19.585] plan(): Setting new future strategy stack:
[17:42:19.585] List of future strategies:
[17:42:19.585] 1. sequential:
[17:42:19.585]    - args: function (..., envir = parent.frame())
[17:42:19.585]    - tweaked: FALSE
[17:42:19.585]    - call: plan(strategy)
[17:42:19.586] plan(): nbrOfWorkers() = 1
[17:42:19.586] SequentialFuture started (and completed)
[17:42:19.586] - Launch lazy future ... done
[17:42:19.586] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef826edd0> 
Classes 'listenv', 'environment' <environment: 0x55bef810eb70> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:42:19.590] resolved() for ‘SequentialFuture’ ...
[17:42:19.590] - state: ‘finished’
[17:42:19.590] - run: TRUE
[17:42:19.590] - result: ‘FutureResult’
[17:42:19.590] resolved() for ‘SequentialFuture’ ... done
[17:42:19.590] resolved() for ‘SequentialFuture’ ...
[17:42:19.590] - state: ‘finished’
[17:42:19.590] - run: TRUE
[17:42:19.590] - result: ‘FutureResult’
[17:42:19.591] resolved() for ‘SequentialFuture’ ... done
[17:42:19.591] resolved() for ‘SequentialFuture’ ...
[17:42:19.591] - state: ‘finished’
[17:42:19.591] - run: TRUE
[17:42:19.591] - result: ‘FutureResult’
[17:42:19.591] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:19.593] resolve() on list environment ...
[17:42:19.593]  recursive: 0
[17:42:19.597]  length: 6
[17:42:19.597]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:19.597] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.597] - nx: 6
[17:42:19.597] - relay: TRUE
[17:42:19.597] - stdout: TRUE
[17:42:19.597] - signal: TRUE
[17:42:19.597] - resignal: FALSE
[17:42:19.598] - force: TRUE
[17:42:19.598] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.598] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.598]  - until=2
[17:42:19.598]  - relaying element #2
[17:42:19.598] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.598] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.598] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.598]  length: 5 (resolved future 1)
[17:42:19.599] resolved() for ‘SequentialFuture’ ...
[17:42:19.599] - state: ‘finished’
[17:42:19.599] - run: TRUE
[17:42:19.599] - result: ‘FutureResult’
[17:42:19.599] resolved() for ‘SequentialFuture’ ... done
[17:42:19.599] Future #2
[17:42:19.599] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.599] - nx: 6
[17:42:19.599] - relay: TRUE
[17:42:19.599] - stdout: TRUE
[17:42:19.600] - signal: TRUE
[17:42:19.600] - resignal: FALSE
[17:42:19.600] - force: TRUE
[17:42:19.600] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.600] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.600]  - until=2
[17:42:19.600]  - relaying element #2
[17:42:19.600] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.600] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.600] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.601]  length: 4 (resolved future 2)
[17:42:19.601] resolved() for ‘SequentialFuture’ ...
[17:42:19.601] - state: ‘finished’
[17:42:19.601] - run: TRUE
[17:42:19.601] - result: ‘FutureResult’
[17:42:19.601] resolved() for ‘SequentialFuture’ ... done
[17:42:19.601] Future #3
[17:42:19.601] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.601] - nx: 6
[17:42:19.602] - relay: TRUE
[17:42:19.602] - stdout: TRUE
[17:42:19.602] - signal: TRUE
[17:42:19.602] - resignal: FALSE
[17:42:19.602] - force: TRUE
[17:42:19.602] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.602] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.602]  - until=3
[17:42:19.602]  - relaying element #3
[17:42:19.602] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.603] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.603] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.603]  length: 3 (resolved future 3)
[17:42:19.603] resolved() for ‘SequentialFuture’ ...
[17:42:19.603] - state: ‘finished’
[17:42:19.603] - run: TRUE
[17:42:19.603] - result: ‘FutureResult’
[17:42:19.603] resolved() for ‘SequentialFuture’ ... done
[17:42:19.603] Future #4
[17:42:19.604] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.604] - nx: 6
[17:42:19.604] - relay: TRUE
[17:42:19.604] - stdout: TRUE
[17:42:19.604] - signal: TRUE
[17:42:19.604] - resignal: FALSE
[17:42:19.604] - force: TRUE
[17:42:19.604] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.604] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.604]  - until=4
[17:42:19.604]  - relaying element #4
[17:42:19.605] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.605] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.605] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.605]  length: 2 (resolved future 4)
[17:42:19.605] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.605] - nx: 6
[17:42:19.605] - relay: TRUE
[17:42:19.605] - stdout: TRUE
[17:42:19.605] - signal: TRUE
[17:42:19.605] - resignal: FALSE
[17:42:19.605] - force: TRUE
[17:42:19.606] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.606] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.606]  - until=6
[17:42:19.606]  - relaying element #6
[17:42:19.606] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.606] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.606] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.606]  length: 1 (resolved future 5)
[17:42:19.606] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.606] - nx: 6
[17:42:19.606] - relay: TRUE
[17:42:19.607] - stdout: TRUE
[17:42:19.607] - signal: TRUE
[17:42:19.607] - resignal: FALSE
[17:42:19.607] - force: TRUE
[17:42:19.607] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.607] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.607]  - until=6
[17:42:19.607] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.607] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.607] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.607]  length: 0 (resolved future 6)
[17:42:19.608] Relaying remaining futures
[17:42:19.608] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.608] - nx: 6
[17:42:19.608] - relay: TRUE
[17:42:19.608] - stdout: TRUE
[17:42:19.608] - signal: TRUE
[17:42:19.608] - resignal: FALSE
[17:42:19.608] - force: TRUE
[17:42:19.608] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.608] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:19.608] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.609] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.609] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.609] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef858e1e0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:42:19.611] getGlobalsAndPackages() ...
[17:42:19.611] Searching for globals...
[17:42:19.611] 
[17:42:19.611] Searching for globals ... DONE
[17:42:19.612] - globals: [0] <none>
[17:42:19.612] getGlobalsAndPackages() ... DONE
[17:42:19.612] run() for ‘Future’ ...
[17:42:19.612] - state: ‘created’
[17:42:19.612] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.612] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.612] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.613]   - Field: ‘label’
[17:42:19.613]   - Field: ‘local’
[17:42:19.613]   - Field: ‘owner’
[17:42:19.613]   - Field: ‘envir’
[17:42:19.613]   - Field: ‘packages’
[17:42:19.613]   - Field: ‘gc’
[17:42:19.613]   - Field: ‘conditions’
[17:42:19.613]   - Field: ‘expr’
[17:42:19.613]   - Field: ‘uuid’
[17:42:19.613]   - Field: ‘seed’
[17:42:19.614]   - Field: ‘version’
[17:42:19.614]   - Field: ‘result’
[17:42:19.614]   - Field: ‘asynchronous’
[17:42:19.614]   - Field: ‘calls’
[17:42:19.614]   - Field: ‘globals’
[17:42:19.614]   - Field: ‘stdout’
[17:42:19.614]   - Field: ‘earlySignal’
[17:42:19.614]   - Field: ‘lazy’
[17:42:19.614]   - Field: ‘state’
[17:42:19.614] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.614] - Launch lazy future ...
[17:42:19.615] Packages needed by the future expression (n = 0): <none>
[17:42:19.615] Packages needed by future strategies (n = 0): <none>
[17:42:19.615] {
[17:42:19.615]     {
[17:42:19.615]         {
[17:42:19.615]             ...future.startTime <- base::Sys.time()
[17:42:19.615]             {
[17:42:19.615]                 {
[17:42:19.615]                   {
[17:42:19.615]                     base::local({
[17:42:19.615]                       has_future <- base::requireNamespace("future", 
[17:42:19.615]                         quietly = TRUE)
[17:42:19.615]                       if (has_future) {
[17:42:19.615]                         ns <- base::getNamespace("future")
[17:42:19.615]                         version <- ns[[".package"]][["version"]]
[17:42:19.615]                         if (is.null(version)) 
[17:42:19.615]                           version <- utils::packageVersion("future")
[17:42:19.615]                       }
[17:42:19.615]                       else {
[17:42:19.615]                         version <- NULL
[17:42:19.615]                       }
[17:42:19.615]                       if (!has_future || version < "1.8.0") {
[17:42:19.615]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.615]                           "", base::R.version$version.string), 
[17:42:19.615]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.615]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.615]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.615]                             "release", "version")], collapse = " "), 
[17:42:19.615]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.615]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.615]                           info)
[17:42:19.615]                         info <- base::paste(info, collapse = "; ")
[17:42:19.615]                         if (!has_future) {
[17:42:19.615]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.615]                             info)
[17:42:19.615]                         }
[17:42:19.615]                         else {
[17:42:19.615]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.615]                             info, version)
[17:42:19.615]                         }
[17:42:19.615]                         base::stop(msg)
[17:42:19.615]                       }
[17:42:19.615]                     })
[17:42:19.615]                   }
[17:42:19.615]                   options(future.plan = NULL)
[17:42:19.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.615]                 }
[17:42:19.615]                 ...future.workdir <- getwd()
[17:42:19.615]             }
[17:42:19.615]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.615]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.615]         }
[17:42:19.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.615]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.615]             base::names(...future.oldOptions))
[17:42:19.615]     }
[17:42:19.615]     if (FALSE) {
[17:42:19.615]     }
[17:42:19.615]     else {
[17:42:19.615]         if (TRUE) {
[17:42:19.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.615]                 open = "w")
[17:42:19.615]         }
[17:42:19.615]         else {
[17:42:19.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.615]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.615]         }
[17:42:19.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.615]             base::sink(type = "output", split = FALSE)
[17:42:19.615]             base::close(...future.stdout)
[17:42:19.615]         }, add = TRUE)
[17:42:19.615]     }
[17:42:19.615]     ...future.frame <- base::sys.nframe()
[17:42:19.615]     ...future.conditions <- base::list()
[17:42:19.615]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.615]     if (FALSE) {
[17:42:19.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.615]     }
[17:42:19.615]     ...future.result <- base::tryCatch({
[17:42:19.615]         base::withCallingHandlers({
[17:42:19.615]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.615]             future::FutureResult(value = ...future.value$value, 
[17:42:19.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.615]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.615]                     ...future.globalenv.names))
[17:42:19.615]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.615]         }, condition = base::local({
[17:42:19.615]             c <- base::c
[17:42:19.615]             inherits <- base::inherits
[17:42:19.615]             invokeRestart <- base::invokeRestart
[17:42:19.615]             length <- base::length
[17:42:19.615]             list <- base::list
[17:42:19.615]             seq.int <- base::seq.int
[17:42:19.615]             signalCondition <- base::signalCondition
[17:42:19.615]             sys.calls <- base::sys.calls
[17:42:19.615]             `[[` <- base::`[[`
[17:42:19.615]             `+` <- base::`+`
[17:42:19.615]             `<<-` <- base::`<<-`
[17:42:19.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.615]                   3L)]
[17:42:19.615]             }
[17:42:19.615]             function(cond) {
[17:42:19.615]                 is_error <- inherits(cond, "error")
[17:42:19.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.615]                   NULL)
[17:42:19.615]                 if (is_error) {
[17:42:19.615]                   sessionInformation <- function() {
[17:42:19.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.615]                       search = base::search(), system = base::Sys.info())
[17:42:19.615]                   }
[17:42:19.615]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.615]                     cond$call), session = sessionInformation(), 
[17:42:19.615]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.615]                   signalCondition(cond)
[17:42:19.615]                 }
[17:42:19.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.615]                 "immediateCondition"))) {
[17:42:19.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.615]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.615]                   if (TRUE && !signal) {
[17:42:19.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.615]                     {
[17:42:19.615]                       inherits <- base::inherits
[17:42:19.615]                       invokeRestart <- base::invokeRestart
[17:42:19.615]                       is.null <- base::is.null
[17:42:19.615]                       muffled <- FALSE
[17:42:19.615]                       if (inherits(cond, "message")) {
[17:42:19.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.615]                         if (muffled) 
[17:42:19.615]                           invokeRestart("muffleMessage")
[17:42:19.615]                       }
[17:42:19.615]                       else if (inherits(cond, "warning")) {
[17:42:19.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.615]                         if (muffled) 
[17:42:19.615]                           invokeRestart("muffleWarning")
[17:42:19.615]                       }
[17:42:19.615]                       else if (inherits(cond, "condition")) {
[17:42:19.615]                         if (!is.null(pattern)) {
[17:42:19.615]                           computeRestarts <- base::computeRestarts
[17:42:19.615]                           grepl <- base::grepl
[17:42:19.615]                           restarts <- computeRestarts(cond)
[17:42:19.615]                           for (restart in restarts) {
[17:42:19.615]                             name <- restart$name
[17:42:19.615]                             if (is.null(name)) 
[17:42:19.615]                               next
[17:42:19.615]                             if (!grepl(pattern, name)) 
[17:42:19.615]                               next
[17:42:19.615]                             invokeRestart(restart)
[17:42:19.615]                             muffled <- TRUE
[17:42:19.615]                             break
[17:42:19.615]                           }
[17:42:19.615]                         }
[17:42:19.615]                       }
[17:42:19.615]                       invisible(muffled)
[17:42:19.615]                     }
[17:42:19.615]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.615]                   }
[17:42:19.615]                 }
[17:42:19.615]                 else {
[17:42:19.615]                   if (TRUE) {
[17:42:19.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.615]                     {
[17:42:19.615]                       inherits <- base::inherits
[17:42:19.615]                       invokeRestart <- base::invokeRestart
[17:42:19.615]                       is.null <- base::is.null
[17:42:19.615]                       muffled <- FALSE
[17:42:19.615]                       if (inherits(cond, "message")) {
[17:42:19.615]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.615]                         if (muffled) 
[17:42:19.615]                           invokeRestart("muffleMessage")
[17:42:19.615]                       }
[17:42:19.615]                       else if (inherits(cond, "warning")) {
[17:42:19.615]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.615]                         if (muffled) 
[17:42:19.615]                           invokeRestart("muffleWarning")
[17:42:19.615]                       }
[17:42:19.615]                       else if (inherits(cond, "condition")) {
[17:42:19.615]                         if (!is.null(pattern)) {
[17:42:19.615]                           computeRestarts <- base::computeRestarts
[17:42:19.615]                           grepl <- base::grepl
[17:42:19.615]                           restarts <- computeRestarts(cond)
[17:42:19.615]                           for (restart in restarts) {
[17:42:19.615]                             name <- restart$name
[17:42:19.615]                             if (is.null(name)) 
[17:42:19.615]                               next
[17:42:19.615]                             if (!grepl(pattern, name)) 
[17:42:19.615]                               next
[17:42:19.615]                             invokeRestart(restart)
[17:42:19.615]                             muffled <- TRUE
[17:42:19.615]                             break
[17:42:19.615]                           }
[17:42:19.615]                         }
[17:42:19.615]                       }
[17:42:19.615]                       invisible(muffled)
[17:42:19.615]                     }
[17:42:19.615]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.615]                   }
[17:42:19.615]                 }
[17:42:19.615]             }
[17:42:19.615]         }))
[17:42:19.615]     }, error = function(ex) {
[17:42:19.615]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.615]                 ...future.rng), started = ...future.startTime, 
[17:42:19.615]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.615]             version = "1.8"), class = "FutureResult")
[17:42:19.615]     }, finally = {
[17:42:19.615]         if (!identical(...future.workdir, getwd())) 
[17:42:19.615]             setwd(...future.workdir)
[17:42:19.615]         {
[17:42:19.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.615]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.615]             }
[17:42:19.615]             base::options(...future.oldOptions)
[17:42:19.615]             if (.Platform$OS.type == "windows") {
[17:42:19.615]                 old_names <- names(...future.oldEnvVars)
[17:42:19.615]                 envs <- base::Sys.getenv()
[17:42:19.615]                 names <- names(envs)
[17:42:19.615]                 common <- intersect(names, old_names)
[17:42:19.615]                 added <- setdiff(names, old_names)
[17:42:19.615]                 removed <- setdiff(old_names, names)
[17:42:19.615]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.615]                   envs[common]]
[17:42:19.615]                 NAMES <- toupper(changed)
[17:42:19.615]                 args <- list()
[17:42:19.615]                 for (kk in seq_along(NAMES)) {
[17:42:19.615]                   name <- changed[[kk]]
[17:42:19.615]                   NAME <- NAMES[[kk]]
[17:42:19.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.615]                     next
[17:42:19.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.615]                 }
[17:42:19.615]                 NAMES <- toupper(added)
[17:42:19.615]                 for (kk in seq_along(NAMES)) {
[17:42:19.615]                   name <- added[[kk]]
[17:42:19.615]                   NAME <- NAMES[[kk]]
[17:42:19.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.615]                     next
[17:42:19.615]                   args[[name]] <- ""
[17:42:19.615]                 }
[17:42:19.615]                 NAMES <- toupper(removed)
[17:42:19.615]                 for (kk in seq_along(NAMES)) {
[17:42:19.615]                   name <- removed[[kk]]
[17:42:19.615]                   NAME <- NAMES[[kk]]
[17:42:19.615]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.615]                     next
[17:42:19.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.615]                 }
[17:42:19.615]                 if (length(args) > 0) 
[17:42:19.615]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.615]             }
[17:42:19.615]             else {
[17:42:19.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.615]             }
[17:42:19.615]             {
[17:42:19.615]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.615]                   0L) {
[17:42:19.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.615]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.615]                   base::options(opts)
[17:42:19.615]                 }
[17:42:19.615]                 {
[17:42:19.615]                   {
[17:42:19.615]                     NULL
[17:42:19.615]                     RNGkind("Mersenne-Twister")
[17:42:19.615]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.615]                       inherits = FALSE)
[17:42:19.615]                   }
[17:42:19.615]                   options(future.plan = NULL)
[17:42:19.615]                   if (is.na(NA_character_)) 
[17:42:19.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.615]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.615]                   {
[17:42:19.615]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.615]                     if (!future$lazy) 
[17:42:19.615]                       future <- run(future)
[17:42:19.615]                     invisible(future)
[17:42:19.615]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.615]                 }
[17:42:19.615]             }
[17:42:19.615]         }
[17:42:19.615]     })
[17:42:19.615]     if (TRUE) {
[17:42:19.615]         base::sink(type = "output", split = FALSE)
[17:42:19.615]         if (TRUE) {
[17:42:19.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.615]         }
[17:42:19.615]         else {
[17:42:19.615]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.615]         }
[17:42:19.615]         base::close(...future.stdout)
[17:42:19.615]         ...future.stdout <- NULL
[17:42:19.615]     }
[17:42:19.615]     ...future.result$conditions <- ...future.conditions
[17:42:19.615]     ...future.result$finished <- base::Sys.time()
[17:42:19.615]     ...future.result
[17:42:19.615] }
[17:42:19.617] plan(): Setting new future strategy stack:
[17:42:19.617] List of future strategies:
[17:42:19.617] 1. sequential:
[17:42:19.617]    - args: function (..., envir = parent.frame())
[17:42:19.617]    - tweaked: FALSE
[17:42:19.617]    - call: NULL
[17:42:19.618] plan(): nbrOfWorkers() = 1
[17:42:19.618] plan(): Setting new future strategy stack:
[17:42:19.618] List of future strategies:
[17:42:19.618] 1. sequential:
[17:42:19.618]    - args: function (..., envir = parent.frame())
[17:42:19.618]    - tweaked: FALSE
[17:42:19.618]    - call: plan(strategy)
[17:42:19.619] plan(): nbrOfWorkers() = 1
[17:42:19.619] SequentialFuture started (and completed)
[17:42:19.619] - Launch lazy future ... done
[17:42:19.619] run() for ‘SequentialFuture’ ... done
[17:42:19.619] getGlobalsAndPackages() ...
[17:42:19.619] Searching for globals...
[17:42:19.620] 
[17:42:19.620] Searching for globals ... DONE
[17:42:19.620] - globals: [0] <none>
[17:42:19.620] getGlobalsAndPackages() ... DONE
[17:42:19.620] run() for ‘Future’ ...
[17:42:19.620] - state: ‘created’
[17:42:19.620] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.621] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.621] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.621]   - Field: ‘label’
[17:42:19.621]   - Field: ‘local’
[17:42:19.621]   - Field: ‘owner’
[17:42:19.621]   - Field: ‘envir’
[17:42:19.621]   - Field: ‘packages’
[17:42:19.621]   - Field: ‘gc’
[17:42:19.622]   - Field: ‘conditions’
[17:42:19.622]   - Field: ‘expr’
[17:42:19.622]   - Field: ‘uuid’
[17:42:19.622]   - Field: ‘seed’
[17:42:19.622]   - Field: ‘version’
[17:42:19.622]   - Field: ‘result’
[17:42:19.622]   - Field: ‘asynchronous’
[17:42:19.622]   - Field: ‘calls’
[17:42:19.622]   - Field: ‘globals’
[17:42:19.622]   - Field: ‘stdout’
[17:42:19.623]   - Field: ‘earlySignal’
[17:42:19.623]   - Field: ‘lazy’
[17:42:19.623]   - Field: ‘state’
[17:42:19.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.623] - Launch lazy future ...
[17:42:19.623] Packages needed by the future expression (n = 0): <none>
[17:42:19.623] Packages needed by future strategies (n = 0): <none>
[17:42:19.625] {
[17:42:19.625]     {
[17:42:19.625]         {
[17:42:19.625]             ...future.startTime <- base::Sys.time()
[17:42:19.625]             {
[17:42:19.625]                 {
[17:42:19.625]                   {
[17:42:19.625]                     base::local({
[17:42:19.625]                       has_future <- base::requireNamespace("future", 
[17:42:19.625]                         quietly = TRUE)
[17:42:19.625]                       if (has_future) {
[17:42:19.625]                         ns <- base::getNamespace("future")
[17:42:19.625]                         version <- ns[[".package"]][["version"]]
[17:42:19.625]                         if (is.null(version)) 
[17:42:19.625]                           version <- utils::packageVersion("future")
[17:42:19.625]                       }
[17:42:19.625]                       else {
[17:42:19.625]                         version <- NULL
[17:42:19.625]                       }
[17:42:19.625]                       if (!has_future || version < "1.8.0") {
[17:42:19.625]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.625]                           "", base::R.version$version.string), 
[17:42:19.625]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.625]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.625]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.625]                             "release", "version")], collapse = " "), 
[17:42:19.625]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.625]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.625]                           info)
[17:42:19.625]                         info <- base::paste(info, collapse = "; ")
[17:42:19.625]                         if (!has_future) {
[17:42:19.625]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.625]                             info)
[17:42:19.625]                         }
[17:42:19.625]                         else {
[17:42:19.625]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.625]                             info, version)
[17:42:19.625]                         }
[17:42:19.625]                         base::stop(msg)
[17:42:19.625]                       }
[17:42:19.625]                     })
[17:42:19.625]                   }
[17:42:19.625]                   options(future.plan = NULL)
[17:42:19.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.625]                 }
[17:42:19.625]                 ...future.workdir <- getwd()
[17:42:19.625]             }
[17:42:19.625]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.625]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.625]         }
[17:42:19.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.625]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.625]             base::names(...future.oldOptions))
[17:42:19.625]     }
[17:42:19.625]     if (FALSE) {
[17:42:19.625]     }
[17:42:19.625]     else {
[17:42:19.625]         if (TRUE) {
[17:42:19.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.625]                 open = "w")
[17:42:19.625]         }
[17:42:19.625]         else {
[17:42:19.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.625]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.625]         }
[17:42:19.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.625]             base::sink(type = "output", split = FALSE)
[17:42:19.625]             base::close(...future.stdout)
[17:42:19.625]         }, add = TRUE)
[17:42:19.625]     }
[17:42:19.625]     ...future.frame <- base::sys.nframe()
[17:42:19.625]     ...future.conditions <- base::list()
[17:42:19.625]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.625]     if (FALSE) {
[17:42:19.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.625]     }
[17:42:19.625]     ...future.result <- base::tryCatch({
[17:42:19.625]         base::withCallingHandlers({
[17:42:19.625]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.625]             future::FutureResult(value = ...future.value$value, 
[17:42:19.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.625]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.625]                     ...future.globalenv.names))
[17:42:19.625]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.625]         }, condition = base::local({
[17:42:19.625]             c <- base::c
[17:42:19.625]             inherits <- base::inherits
[17:42:19.625]             invokeRestart <- base::invokeRestart
[17:42:19.625]             length <- base::length
[17:42:19.625]             list <- base::list
[17:42:19.625]             seq.int <- base::seq.int
[17:42:19.625]             signalCondition <- base::signalCondition
[17:42:19.625]             sys.calls <- base::sys.calls
[17:42:19.625]             `[[` <- base::`[[`
[17:42:19.625]             `+` <- base::`+`
[17:42:19.625]             `<<-` <- base::`<<-`
[17:42:19.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.625]                   3L)]
[17:42:19.625]             }
[17:42:19.625]             function(cond) {
[17:42:19.625]                 is_error <- inherits(cond, "error")
[17:42:19.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.625]                   NULL)
[17:42:19.625]                 if (is_error) {
[17:42:19.625]                   sessionInformation <- function() {
[17:42:19.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.625]                       search = base::search(), system = base::Sys.info())
[17:42:19.625]                   }
[17:42:19.625]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.625]                     cond$call), session = sessionInformation(), 
[17:42:19.625]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.625]                   signalCondition(cond)
[17:42:19.625]                 }
[17:42:19.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.625]                 "immediateCondition"))) {
[17:42:19.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.625]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.625]                   if (TRUE && !signal) {
[17:42:19.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.625]                     {
[17:42:19.625]                       inherits <- base::inherits
[17:42:19.625]                       invokeRestart <- base::invokeRestart
[17:42:19.625]                       is.null <- base::is.null
[17:42:19.625]                       muffled <- FALSE
[17:42:19.625]                       if (inherits(cond, "message")) {
[17:42:19.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.625]                         if (muffled) 
[17:42:19.625]                           invokeRestart("muffleMessage")
[17:42:19.625]                       }
[17:42:19.625]                       else if (inherits(cond, "warning")) {
[17:42:19.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.625]                         if (muffled) 
[17:42:19.625]                           invokeRestart("muffleWarning")
[17:42:19.625]                       }
[17:42:19.625]                       else if (inherits(cond, "condition")) {
[17:42:19.625]                         if (!is.null(pattern)) {
[17:42:19.625]                           computeRestarts <- base::computeRestarts
[17:42:19.625]                           grepl <- base::grepl
[17:42:19.625]                           restarts <- computeRestarts(cond)
[17:42:19.625]                           for (restart in restarts) {
[17:42:19.625]                             name <- restart$name
[17:42:19.625]                             if (is.null(name)) 
[17:42:19.625]                               next
[17:42:19.625]                             if (!grepl(pattern, name)) 
[17:42:19.625]                               next
[17:42:19.625]                             invokeRestart(restart)
[17:42:19.625]                             muffled <- TRUE
[17:42:19.625]                             break
[17:42:19.625]                           }
[17:42:19.625]                         }
[17:42:19.625]                       }
[17:42:19.625]                       invisible(muffled)
[17:42:19.625]                     }
[17:42:19.625]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.625]                   }
[17:42:19.625]                 }
[17:42:19.625]                 else {
[17:42:19.625]                   if (TRUE) {
[17:42:19.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.625]                     {
[17:42:19.625]                       inherits <- base::inherits
[17:42:19.625]                       invokeRestart <- base::invokeRestart
[17:42:19.625]                       is.null <- base::is.null
[17:42:19.625]                       muffled <- FALSE
[17:42:19.625]                       if (inherits(cond, "message")) {
[17:42:19.625]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.625]                         if (muffled) 
[17:42:19.625]                           invokeRestart("muffleMessage")
[17:42:19.625]                       }
[17:42:19.625]                       else if (inherits(cond, "warning")) {
[17:42:19.625]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.625]                         if (muffled) 
[17:42:19.625]                           invokeRestart("muffleWarning")
[17:42:19.625]                       }
[17:42:19.625]                       else if (inherits(cond, "condition")) {
[17:42:19.625]                         if (!is.null(pattern)) {
[17:42:19.625]                           computeRestarts <- base::computeRestarts
[17:42:19.625]                           grepl <- base::grepl
[17:42:19.625]                           restarts <- computeRestarts(cond)
[17:42:19.625]                           for (restart in restarts) {
[17:42:19.625]                             name <- restart$name
[17:42:19.625]                             if (is.null(name)) 
[17:42:19.625]                               next
[17:42:19.625]                             if (!grepl(pattern, name)) 
[17:42:19.625]                               next
[17:42:19.625]                             invokeRestart(restart)
[17:42:19.625]                             muffled <- TRUE
[17:42:19.625]                             break
[17:42:19.625]                           }
[17:42:19.625]                         }
[17:42:19.625]                       }
[17:42:19.625]                       invisible(muffled)
[17:42:19.625]                     }
[17:42:19.625]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.625]                   }
[17:42:19.625]                 }
[17:42:19.625]             }
[17:42:19.625]         }))
[17:42:19.625]     }, error = function(ex) {
[17:42:19.625]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.625]                 ...future.rng), started = ...future.startTime, 
[17:42:19.625]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.625]             version = "1.8"), class = "FutureResult")
[17:42:19.625]     }, finally = {
[17:42:19.625]         if (!identical(...future.workdir, getwd())) 
[17:42:19.625]             setwd(...future.workdir)
[17:42:19.625]         {
[17:42:19.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.625]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.625]             }
[17:42:19.625]             base::options(...future.oldOptions)
[17:42:19.625]             if (.Platform$OS.type == "windows") {
[17:42:19.625]                 old_names <- names(...future.oldEnvVars)
[17:42:19.625]                 envs <- base::Sys.getenv()
[17:42:19.625]                 names <- names(envs)
[17:42:19.625]                 common <- intersect(names, old_names)
[17:42:19.625]                 added <- setdiff(names, old_names)
[17:42:19.625]                 removed <- setdiff(old_names, names)
[17:42:19.625]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.625]                   envs[common]]
[17:42:19.625]                 NAMES <- toupper(changed)
[17:42:19.625]                 args <- list()
[17:42:19.625]                 for (kk in seq_along(NAMES)) {
[17:42:19.625]                   name <- changed[[kk]]
[17:42:19.625]                   NAME <- NAMES[[kk]]
[17:42:19.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.625]                     next
[17:42:19.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.625]                 }
[17:42:19.625]                 NAMES <- toupper(added)
[17:42:19.625]                 for (kk in seq_along(NAMES)) {
[17:42:19.625]                   name <- added[[kk]]
[17:42:19.625]                   NAME <- NAMES[[kk]]
[17:42:19.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.625]                     next
[17:42:19.625]                   args[[name]] <- ""
[17:42:19.625]                 }
[17:42:19.625]                 NAMES <- toupper(removed)
[17:42:19.625]                 for (kk in seq_along(NAMES)) {
[17:42:19.625]                   name <- removed[[kk]]
[17:42:19.625]                   NAME <- NAMES[[kk]]
[17:42:19.625]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.625]                     next
[17:42:19.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.625]                 }
[17:42:19.625]                 if (length(args) > 0) 
[17:42:19.625]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.625]             }
[17:42:19.625]             else {
[17:42:19.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.625]             }
[17:42:19.625]             {
[17:42:19.625]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.625]                   0L) {
[17:42:19.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.625]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.625]                   base::options(opts)
[17:42:19.625]                 }
[17:42:19.625]                 {
[17:42:19.625]                   {
[17:42:19.625]                     NULL
[17:42:19.625]                     RNGkind("Mersenne-Twister")
[17:42:19.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.625]                       inherits = FALSE)
[17:42:19.625]                   }
[17:42:19.625]                   options(future.plan = NULL)
[17:42:19.625]                   if (is.na(NA_character_)) 
[17:42:19.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.625]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.625]                   {
[17:42:19.625]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.625]                     if (!future$lazy) 
[17:42:19.625]                       future <- run(future)
[17:42:19.625]                     invisible(future)
[17:42:19.625]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.625]                 }
[17:42:19.625]             }
[17:42:19.625]         }
[17:42:19.625]     })
[17:42:19.625]     if (TRUE) {
[17:42:19.625]         base::sink(type = "output", split = FALSE)
[17:42:19.625]         if (TRUE) {
[17:42:19.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.625]         }
[17:42:19.625]         else {
[17:42:19.625]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.625]         }
[17:42:19.625]         base::close(...future.stdout)
[17:42:19.625]         ...future.stdout <- NULL
[17:42:19.625]     }
[17:42:19.625]     ...future.result$conditions <- ...future.conditions
[17:42:19.625]     ...future.result$finished <- base::Sys.time()
[17:42:19.625]     ...future.result
[17:42:19.625] }
[17:42:19.627] plan(): Setting new future strategy stack:
[17:42:19.627] List of future strategies:
[17:42:19.627] 1. sequential:
[17:42:19.627]    - args: function (..., envir = parent.frame())
[17:42:19.627]    - tweaked: FALSE
[17:42:19.627]    - call: NULL
[17:42:19.628] plan(): nbrOfWorkers() = 1
[17:42:19.629] plan(): Setting new future strategy stack:
[17:42:19.629] List of future strategies:
[17:42:19.629] 1. sequential:
[17:42:19.629]    - args: function (..., envir = parent.frame())
[17:42:19.629]    - tweaked: FALSE
[17:42:19.629]    - call: plan(strategy)
[17:42:19.629] plan(): nbrOfWorkers() = 1
[17:42:19.630] SequentialFuture started (and completed)
[17:42:19.630] - Launch lazy future ... done
[17:42:19.630] run() for ‘SequentialFuture’ ... done
[17:42:19.630] getGlobalsAndPackages() ...
[17:42:19.630] Searching for globals...
[17:42:19.631] - globals found: [1] ‘{’
[17:42:19.631] Searching for globals ... DONE
[17:42:19.631] Resolving globals: FALSE
[17:42:19.631] 
[17:42:19.632] 
[17:42:19.632] getGlobalsAndPackages() ... DONE
[17:42:19.632] run() for ‘Future’ ...
[17:42:19.632] - state: ‘created’
[17:42:19.632] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.633] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.633]   - Field: ‘label’
[17:42:19.633]   - Field: ‘local’
[17:42:19.633]   - Field: ‘owner’
[17:42:19.633]   - Field: ‘envir’
[17:42:19.633]   - Field: ‘packages’
[17:42:19.633]   - Field: ‘gc’
[17:42:19.633]   - Field: ‘conditions’
[17:42:19.633]   - Field: ‘expr’
[17:42:19.633]   - Field: ‘uuid’
[17:42:19.634]   - Field: ‘seed’
[17:42:19.634]   - Field: ‘version’
[17:42:19.634]   - Field: ‘result’
[17:42:19.634]   - Field: ‘asynchronous’
[17:42:19.634]   - Field: ‘calls’
[17:42:19.634]   - Field: ‘globals’
[17:42:19.634]   - Field: ‘stdout’
[17:42:19.634]   - Field: ‘earlySignal’
[17:42:19.634]   - Field: ‘lazy’
[17:42:19.634]   - Field: ‘state’
[17:42:19.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.635] - Launch lazy future ...
[17:42:19.635] Packages needed by the future expression (n = 0): <none>
[17:42:19.635] Packages needed by future strategies (n = 0): <none>
[17:42:19.635] {
[17:42:19.635]     {
[17:42:19.635]         {
[17:42:19.635]             ...future.startTime <- base::Sys.time()
[17:42:19.635]             {
[17:42:19.635]                 {
[17:42:19.635]                   {
[17:42:19.635]                     base::local({
[17:42:19.635]                       has_future <- base::requireNamespace("future", 
[17:42:19.635]                         quietly = TRUE)
[17:42:19.635]                       if (has_future) {
[17:42:19.635]                         ns <- base::getNamespace("future")
[17:42:19.635]                         version <- ns[[".package"]][["version"]]
[17:42:19.635]                         if (is.null(version)) 
[17:42:19.635]                           version <- utils::packageVersion("future")
[17:42:19.635]                       }
[17:42:19.635]                       else {
[17:42:19.635]                         version <- NULL
[17:42:19.635]                       }
[17:42:19.635]                       if (!has_future || version < "1.8.0") {
[17:42:19.635]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.635]                           "", base::R.version$version.string), 
[17:42:19.635]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.635]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.635]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.635]                             "release", "version")], collapse = " "), 
[17:42:19.635]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.635]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.635]                           info)
[17:42:19.635]                         info <- base::paste(info, collapse = "; ")
[17:42:19.635]                         if (!has_future) {
[17:42:19.635]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.635]                             info)
[17:42:19.635]                         }
[17:42:19.635]                         else {
[17:42:19.635]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.635]                             info, version)
[17:42:19.635]                         }
[17:42:19.635]                         base::stop(msg)
[17:42:19.635]                       }
[17:42:19.635]                     })
[17:42:19.635]                   }
[17:42:19.635]                   options(future.plan = NULL)
[17:42:19.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.635]                 }
[17:42:19.635]                 ...future.workdir <- getwd()
[17:42:19.635]             }
[17:42:19.635]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.635]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.635]         }
[17:42:19.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.635]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.635]             base::names(...future.oldOptions))
[17:42:19.635]     }
[17:42:19.635]     if (FALSE) {
[17:42:19.635]     }
[17:42:19.635]     else {
[17:42:19.635]         if (TRUE) {
[17:42:19.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.635]                 open = "w")
[17:42:19.635]         }
[17:42:19.635]         else {
[17:42:19.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.635]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.635]         }
[17:42:19.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.635]             base::sink(type = "output", split = FALSE)
[17:42:19.635]             base::close(...future.stdout)
[17:42:19.635]         }, add = TRUE)
[17:42:19.635]     }
[17:42:19.635]     ...future.frame <- base::sys.nframe()
[17:42:19.635]     ...future.conditions <- base::list()
[17:42:19.635]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.635]     if (FALSE) {
[17:42:19.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.635]     }
[17:42:19.635]     ...future.result <- base::tryCatch({
[17:42:19.635]         base::withCallingHandlers({
[17:42:19.635]             ...future.value <- base::withVisible(base::local({
[17:42:19.635]                 4
[17:42:19.635]             }))
[17:42:19.635]             future::FutureResult(value = ...future.value$value, 
[17:42:19.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.635]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.635]                     ...future.globalenv.names))
[17:42:19.635]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.635]         }, condition = base::local({
[17:42:19.635]             c <- base::c
[17:42:19.635]             inherits <- base::inherits
[17:42:19.635]             invokeRestart <- base::invokeRestart
[17:42:19.635]             length <- base::length
[17:42:19.635]             list <- base::list
[17:42:19.635]             seq.int <- base::seq.int
[17:42:19.635]             signalCondition <- base::signalCondition
[17:42:19.635]             sys.calls <- base::sys.calls
[17:42:19.635]             `[[` <- base::`[[`
[17:42:19.635]             `+` <- base::`+`
[17:42:19.635]             `<<-` <- base::`<<-`
[17:42:19.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.635]                   3L)]
[17:42:19.635]             }
[17:42:19.635]             function(cond) {
[17:42:19.635]                 is_error <- inherits(cond, "error")
[17:42:19.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.635]                   NULL)
[17:42:19.635]                 if (is_error) {
[17:42:19.635]                   sessionInformation <- function() {
[17:42:19.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.635]                       search = base::search(), system = base::Sys.info())
[17:42:19.635]                   }
[17:42:19.635]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.635]                     cond$call), session = sessionInformation(), 
[17:42:19.635]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.635]                   signalCondition(cond)
[17:42:19.635]                 }
[17:42:19.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.635]                 "immediateCondition"))) {
[17:42:19.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.635]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.635]                   if (TRUE && !signal) {
[17:42:19.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.635]                     {
[17:42:19.635]                       inherits <- base::inherits
[17:42:19.635]                       invokeRestart <- base::invokeRestart
[17:42:19.635]                       is.null <- base::is.null
[17:42:19.635]                       muffled <- FALSE
[17:42:19.635]                       if (inherits(cond, "message")) {
[17:42:19.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.635]                         if (muffled) 
[17:42:19.635]                           invokeRestart("muffleMessage")
[17:42:19.635]                       }
[17:42:19.635]                       else if (inherits(cond, "warning")) {
[17:42:19.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.635]                         if (muffled) 
[17:42:19.635]                           invokeRestart("muffleWarning")
[17:42:19.635]                       }
[17:42:19.635]                       else if (inherits(cond, "condition")) {
[17:42:19.635]                         if (!is.null(pattern)) {
[17:42:19.635]                           computeRestarts <- base::computeRestarts
[17:42:19.635]                           grepl <- base::grepl
[17:42:19.635]                           restarts <- computeRestarts(cond)
[17:42:19.635]                           for (restart in restarts) {
[17:42:19.635]                             name <- restart$name
[17:42:19.635]                             if (is.null(name)) 
[17:42:19.635]                               next
[17:42:19.635]                             if (!grepl(pattern, name)) 
[17:42:19.635]                               next
[17:42:19.635]                             invokeRestart(restart)
[17:42:19.635]                             muffled <- TRUE
[17:42:19.635]                             break
[17:42:19.635]                           }
[17:42:19.635]                         }
[17:42:19.635]                       }
[17:42:19.635]                       invisible(muffled)
[17:42:19.635]                     }
[17:42:19.635]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.635]                   }
[17:42:19.635]                 }
[17:42:19.635]                 else {
[17:42:19.635]                   if (TRUE) {
[17:42:19.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.635]                     {
[17:42:19.635]                       inherits <- base::inherits
[17:42:19.635]                       invokeRestart <- base::invokeRestart
[17:42:19.635]                       is.null <- base::is.null
[17:42:19.635]                       muffled <- FALSE
[17:42:19.635]                       if (inherits(cond, "message")) {
[17:42:19.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.635]                         if (muffled) 
[17:42:19.635]                           invokeRestart("muffleMessage")
[17:42:19.635]                       }
[17:42:19.635]                       else if (inherits(cond, "warning")) {
[17:42:19.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.635]                         if (muffled) 
[17:42:19.635]                           invokeRestart("muffleWarning")
[17:42:19.635]                       }
[17:42:19.635]                       else if (inherits(cond, "condition")) {
[17:42:19.635]                         if (!is.null(pattern)) {
[17:42:19.635]                           computeRestarts <- base::computeRestarts
[17:42:19.635]                           grepl <- base::grepl
[17:42:19.635]                           restarts <- computeRestarts(cond)
[17:42:19.635]                           for (restart in restarts) {
[17:42:19.635]                             name <- restart$name
[17:42:19.635]                             if (is.null(name)) 
[17:42:19.635]                               next
[17:42:19.635]                             if (!grepl(pattern, name)) 
[17:42:19.635]                               next
[17:42:19.635]                             invokeRestart(restart)
[17:42:19.635]                             muffled <- TRUE
[17:42:19.635]                             break
[17:42:19.635]                           }
[17:42:19.635]                         }
[17:42:19.635]                       }
[17:42:19.635]                       invisible(muffled)
[17:42:19.635]                     }
[17:42:19.635]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.635]                   }
[17:42:19.635]                 }
[17:42:19.635]             }
[17:42:19.635]         }))
[17:42:19.635]     }, error = function(ex) {
[17:42:19.635]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.635]                 ...future.rng), started = ...future.startTime, 
[17:42:19.635]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.635]             version = "1.8"), class = "FutureResult")
[17:42:19.635]     }, finally = {
[17:42:19.635]         if (!identical(...future.workdir, getwd())) 
[17:42:19.635]             setwd(...future.workdir)
[17:42:19.635]         {
[17:42:19.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.635]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.635]             }
[17:42:19.635]             base::options(...future.oldOptions)
[17:42:19.635]             if (.Platform$OS.type == "windows") {
[17:42:19.635]                 old_names <- names(...future.oldEnvVars)
[17:42:19.635]                 envs <- base::Sys.getenv()
[17:42:19.635]                 names <- names(envs)
[17:42:19.635]                 common <- intersect(names, old_names)
[17:42:19.635]                 added <- setdiff(names, old_names)
[17:42:19.635]                 removed <- setdiff(old_names, names)
[17:42:19.635]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.635]                   envs[common]]
[17:42:19.635]                 NAMES <- toupper(changed)
[17:42:19.635]                 args <- list()
[17:42:19.635]                 for (kk in seq_along(NAMES)) {
[17:42:19.635]                   name <- changed[[kk]]
[17:42:19.635]                   NAME <- NAMES[[kk]]
[17:42:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.635]                     next
[17:42:19.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.635]                 }
[17:42:19.635]                 NAMES <- toupper(added)
[17:42:19.635]                 for (kk in seq_along(NAMES)) {
[17:42:19.635]                   name <- added[[kk]]
[17:42:19.635]                   NAME <- NAMES[[kk]]
[17:42:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.635]                     next
[17:42:19.635]                   args[[name]] <- ""
[17:42:19.635]                 }
[17:42:19.635]                 NAMES <- toupper(removed)
[17:42:19.635]                 for (kk in seq_along(NAMES)) {
[17:42:19.635]                   name <- removed[[kk]]
[17:42:19.635]                   NAME <- NAMES[[kk]]
[17:42:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.635]                     next
[17:42:19.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.635]                 }
[17:42:19.635]                 if (length(args) > 0) 
[17:42:19.635]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.635]             }
[17:42:19.635]             else {
[17:42:19.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.635]             }
[17:42:19.635]             {
[17:42:19.635]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.635]                   0L) {
[17:42:19.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.635]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.635]                   base::options(opts)
[17:42:19.635]                 }
[17:42:19.635]                 {
[17:42:19.635]                   {
[17:42:19.635]                     NULL
[17:42:19.635]                     RNGkind("Mersenne-Twister")
[17:42:19.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.635]                       inherits = FALSE)
[17:42:19.635]                   }
[17:42:19.635]                   options(future.plan = NULL)
[17:42:19.635]                   if (is.na(NA_character_)) 
[17:42:19.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.635]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.635]                   {
[17:42:19.635]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.635]                     if (!future$lazy) 
[17:42:19.635]                       future <- run(future)
[17:42:19.635]                     invisible(future)
[17:42:19.635]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.635]                 }
[17:42:19.635]             }
[17:42:19.635]         }
[17:42:19.635]     })
[17:42:19.635]     if (TRUE) {
[17:42:19.635]         base::sink(type = "output", split = FALSE)
[17:42:19.635]         if (TRUE) {
[17:42:19.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.635]         }
[17:42:19.635]         else {
[17:42:19.635]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.635]         }
[17:42:19.635]         base::close(...future.stdout)
[17:42:19.635]         ...future.stdout <- NULL
[17:42:19.635]     }
[17:42:19.635]     ...future.result$conditions <- ...future.conditions
[17:42:19.635]     ...future.result$finished <- base::Sys.time()
[17:42:19.635]     ...future.result
[17:42:19.635] }
[17:42:19.637] plan(): Setting new future strategy stack:
[17:42:19.637] List of future strategies:
[17:42:19.637] 1. sequential:
[17:42:19.637]    - args: function (..., envir = parent.frame())
[17:42:19.637]    - tweaked: FALSE
[17:42:19.637]    - call: NULL
[17:42:19.638] plan(): nbrOfWorkers() = 1
[17:42:19.638] plan(): Setting new future strategy stack:
[17:42:19.639] List of future strategies:
[17:42:19.639] 1. sequential:
[17:42:19.639]    - args: function (..., envir = parent.frame())
[17:42:19.639]    - tweaked: FALSE
[17:42:19.639]    - call: plan(strategy)
[17:42:19.639] plan(): nbrOfWorkers() = 1
[17:42:19.639] SequentialFuture started (and completed)
[17:42:19.639] - Launch lazy future ... done
[17:42:19.639] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef7f3a3e8> 
Classes 'listenv', 'environment' <environment: 0x55bef7acda48> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:42:19.643] resolved() for ‘SequentialFuture’ ...
[17:42:19.643] - state: ‘finished’
[17:42:19.643] - run: TRUE
[17:42:19.643] - result: ‘FutureResult’
[17:42:19.643] resolved() for ‘SequentialFuture’ ... done
[17:42:19.644] resolved() for ‘SequentialFuture’ ...
[17:42:19.644] - state: ‘finished’
[17:42:19.644] - run: TRUE
[17:42:19.644] - result: ‘FutureResult’
[17:42:19.644] resolved() for ‘SequentialFuture’ ... done
[17:42:19.644] resolved() for ‘SequentialFuture’ ...
[17:42:19.644] - state: ‘finished’
[17:42:19.644] - run: TRUE
[17:42:19.644] - result: ‘FutureResult’
[17:42:19.644] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:19.647] resolve() on list environment ...
[17:42:19.647]  recursive: 0
[17:42:19.648]  length: 6
[17:42:19.648]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:19.648] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.648] - nx: 6
[17:42:19.648] - relay: TRUE
[17:42:19.648] - stdout: TRUE
[17:42:19.648] - signal: TRUE
[17:42:19.648] - resignal: FALSE
[17:42:19.648] - force: TRUE
[17:42:19.649] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.649] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.649]  - until=2
[17:42:19.649]  - relaying element #2
[17:42:19.649] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.649] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.649] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.649]  length: 5 (resolved future 1)
[17:42:19.649] resolved() for ‘SequentialFuture’ ...
[17:42:19.649] - state: ‘finished’
[17:42:19.650] - run: TRUE
[17:42:19.650] - result: ‘FutureResult’
[17:42:19.650] resolved() for ‘SequentialFuture’ ... done
[17:42:19.650] Future #2
[17:42:19.650] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.650] - nx: 6
[17:42:19.650] - relay: TRUE
[17:42:19.650] - stdout: TRUE
[17:42:19.650] - signal: TRUE
[17:42:19.650] - resignal: FALSE
[17:42:19.650] - force: TRUE
[17:42:19.651] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.651] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.651]  - until=2
[17:42:19.651]  - relaying element #2
[17:42:19.651] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.651] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.651] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.651]  length: 4 (resolved future 2)
[17:42:19.652] resolved() for ‘SequentialFuture’ ...
[17:42:19.652] - state: ‘finished’
[17:42:19.652] - run: TRUE
[17:42:19.652] - result: ‘FutureResult’
[17:42:19.652] resolved() for ‘SequentialFuture’ ... done
[17:42:19.652] Future #3
[17:42:19.652] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.652] - nx: 6
[17:42:19.652] - relay: TRUE
[17:42:19.652] - stdout: TRUE
[17:42:19.652] - signal: TRUE
[17:42:19.653] - resignal: FALSE
[17:42:19.653] - force: TRUE
[17:42:19.653] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.653] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.653]  - until=3
[17:42:19.653]  - relaying element #3
[17:42:19.653] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.653] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.655] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.655]  length: 3 (resolved future 3)
[17:42:19.655] resolved() for ‘SequentialFuture’ ...
[17:42:19.655] - state: ‘finished’
[17:42:19.656] - run: TRUE
[17:42:19.656] - result: ‘FutureResult’
[17:42:19.656] resolved() for ‘SequentialFuture’ ... done
[17:42:19.656] Future #4
[17:42:19.656] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.656] - nx: 6
[17:42:19.656] - relay: TRUE
[17:42:19.656] - stdout: TRUE
[17:42:19.657] - signal: TRUE
[17:42:19.657] - resignal: FALSE
[17:42:19.657] - force: TRUE
[17:42:19.657] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.657] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.657]  - until=4
[17:42:19.657]  - relaying element #4
[17:42:19.657] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.657] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.657] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.658]  length: 2 (resolved future 4)
[17:42:19.658] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.658] - nx: 6
[17:42:19.658] - relay: TRUE
[17:42:19.658] - stdout: TRUE
[17:42:19.658] - signal: TRUE
[17:42:19.658] - resignal: FALSE
[17:42:19.658] - force: TRUE
[17:42:19.658] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.658] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.658]  - until=6
[17:42:19.659]  - relaying element #6
[17:42:19.659] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.659] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.659] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.659]  length: 1 (resolved future 5)
[17:42:19.659] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.659] - nx: 6
[17:42:19.659] - relay: TRUE
[17:42:19.659] - stdout: TRUE
[17:42:19.659] - signal: TRUE
[17:42:19.659] - resignal: FALSE
[17:42:19.660] - force: TRUE
[17:42:19.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.660] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.660]  - until=6
[17:42:19.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.660] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.660] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.660]  length: 0 (resolved future 6)
[17:42:19.660] Relaying remaining futures
[17:42:19.660] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.660] - nx: 6
[17:42:19.661] - relay: TRUE
[17:42:19.661] - stdout: TRUE
[17:42:19.661] - signal: TRUE
[17:42:19.661] - resignal: FALSE
[17:42:19.661] - force: TRUE
[17:42:19.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.661] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:19.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.661] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.661] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.661] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef8137350> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:42:19.663] getGlobalsAndPackages() ...
[17:42:19.664] Searching for globals...
[17:42:19.664] 
[17:42:19.664] Searching for globals ... DONE
[17:42:19.664] - globals: [0] <none>
[17:42:19.664] getGlobalsAndPackages() ... DONE
[17:42:19.664] run() for ‘Future’ ...
[17:42:19.664] - state: ‘created’
[17:42:19.665] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.665] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.665]   - Field: ‘label’
[17:42:19.665]   - Field: ‘local’
[17:42:19.665]   - Field: ‘owner’
[17:42:19.665]   - Field: ‘envir’
[17:42:19.665]   - Field: ‘packages’
[17:42:19.666]   - Field: ‘gc’
[17:42:19.666]   - Field: ‘conditions’
[17:42:19.666]   - Field: ‘expr’
[17:42:19.666]   - Field: ‘uuid’
[17:42:19.666]   - Field: ‘seed’
[17:42:19.666]   - Field: ‘version’
[17:42:19.666]   - Field: ‘result’
[17:42:19.666]   - Field: ‘asynchronous’
[17:42:19.666]   - Field: ‘calls’
[17:42:19.666]   - Field: ‘globals’
[17:42:19.666]   - Field: ‘stdout’
[17:42:19.667]   - Field: ‘earlySignal’
[17:42:19.667]   - Field: ‘lazy’
[17:42:19.667]   - Field: ‘state’
[17:42:19.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.667] - Launch lazy future ...
[17:42:19.667] Packages needed by the future expression (n = 0): <none>
[17:42:19.667] Packages needed by future strategies (n = 0): <none>
[17:42:19.668] {
[17:42:19.668]     {
[17:42:19.668]         {
[17:42:19.668]             ...future.startTime <- base::Sys.time()
[17:42:19.668]             {
[17:42:19.668]                 {
[17:42:19.668]                   {
[17:42:19.668]                     base::local({
[17:42:19.668]                       has_future <- base::requireNamespace("future", 
[17:42:19.668]                         quietly = TRUE)
[17:42:19.668]                       if (has_future) {
[17:42:19.668]                         ns <- base::getNamespace("future")
[17:42:19.668]                         version <- ns[[".package"]][["version"]]
[17:42:19.668]                         if (is.null(version)) 
[17:42:19.668]                           version <- utils::packageVersion("future")
[17:42:19.668]                       }
[17:42:19.668]                       else {
[17:42:19.668]                         version <- NULL
[17:42:19.668]                       }
[17:42:19.668]                       if (!has_future || version < "1.8.0") {
[17:42:19.668]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.668]                           "", base::R.version$version.string), 
[17:42:19.668]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.668]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.668]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.668]                             "release", "version")], collapse = " "), 
[17:42:19.668]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.668]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.668]                           info)
[17:42:19.668]                         info <- base::paste(info, collapse = "; ")
[17:42:19.668]                         if (!has_future) {
[17:42:19.668]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.668]                             info)
[17:42:19.668]                         }
[17:42:19.668]                         else {
[17:42:19.668]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.668]                             info, version)
[17:42:19.668]                         }
[17:42:19.668]                         base::stop(msg)
[17:42:19.668]                       }
[17:42:19.668]                     })
[17:42:19.668]                   }
[17:42:19.668]                   options(future.plan = NULL)
[17:42:19.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.668]                 }
[17:42:19.668]                 ...future.workdir <- getwd()
[17:42:19.668]             }
[17:42:19.668]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.668]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.668]         }
[17:42:19.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.668]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.668]             base::names(...future.oldOptions))
[17:42:19.668]     }
[17:42:19.668]     if (FALSE) {
[17:42:19.668]     }
[17:42:19.668]     else {
[17:42:19.668]         if (TRUE) {
[17:42:19.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.668]                 open = "w")
[17:42:19.668]         }
[17:42:19.668]         else {
[17:42:19.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.668]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.668]         }
[17:42:19.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.668]             base::sink(type = "output", split = FALSE)
[17:42:19.668]             base::close(...future.stdout)
[17:42:19.668]         }, add = TRUE)
[17:42:19.668]     }
[17:42:19.668]     ...future.frame <- base::sys.nframe()
[17:42:19.668]     ...future.conditions <- base::list()
[17:42:19.668]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.668]     if (FALSE) {
[17:42:19.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.668]     }
[17:42:19.668]     ...future.result <- base::tryCatch({
[17:42:19.668]         base::withCallingHandlers({
[17:42:19.668]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.668]             future::FutureResult(value = ...future.value$value, 
[17:42:19.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.668]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.668]                     ...future.globalenv.names))
[17:42:19.668]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.668]         }, condition = base::local({
[17:42:19.668]             c <- base::c
[17:42:19.668]             inherits <- base::inherits
[17:42:19.668]             invokeRestart <- base::invokeRestart
[17:42:19.668]             length <- base::length
[17:42:19.668]             list <- base::list
[17:42:19.668]             seq.int <- base::seq.int
[17:42:19.668]             signalCondition <- base::signalCondition
[17:42:19.668]             sys.calls <- base::sys.calls
[17:42:19.668]             `[[` <- base::`[[`
[17:42:19.668]             `+` <- base::`+`
[17:42:19.668]             `<<-` <- base::`<<-`
[17:42:19.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.668]                   3L)]
[17:42:19.668]             }
[17:42:19.668]             function(cond) {
[17:42:19.668]                 is_error <- inherits(cond, "error")
[17:42:19.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.668]                   NULL)
[17:42:19.668]                 if (is_error) {
[17:42:19.668]                   sessionInformation <- function() {
[17:42:19.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.668]                       search = base::search(), system = base::Sys.info())
[17:42:19.668]                   }
[17:42:19.668]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.668]                     cond$call), session = sessionInformation(), 
[17:42:19.668]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.668]                   signalCondition(cond)
[17:42:19.668]                 }
[17:42:19.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.668]                 "immediateCondition"))) {
[17:42:19.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.668]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.668]                   if (TRUE && !signal) {
[17:42:19.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.668]                     {
[17:42:19.668]                       inherits <- base::inherits
[17:42:19.668]                       invokeRestart <- base::invokeRestart
[17:42:19.668]                       is.null <- base::is.null
[17:42:19.668]                       muffled <- FALSE
[17:42:19.668]                       if (inherits(cond, "message")) {
[17:42:19.668]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.668]                         if (muffled) 
[17:42:19.668]                           invokeRestart("muffleMessage")
[17:42:19.668]                       }
[17:42:19.668]                       else if (inherits(cond, "warning")) {
[17:42:19.668]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.668]                         if (muffled) 
[17:42:19.668]                           invokeRestart("muffleWarning")
[17:42:19.668]                       }
[17:42:19.668]                       else if (inherits(cond, "condition")) {
[17:42:19.668]                         if (!is.null(pattern)) {
[17:42:19.668]                           computeRestarts <- base::computeRestarts
[17:42:19.668]                           grepl <- base::grepl
[17:42:19.668]                           restarts <- computeRestarts(cond)
[17:42:19.668]                           for (restart in restarts) {
[17:42:19.668]                             name <- restart$name
[17:42:19.668]                             if (is.null(name)) 
[17:42:19.668]                               next
[17:42:19.668]                             if (!grepl(pattern, name)) 
[17:42:19.668]                               next
[17:42:19.668]                             invokeRestart(restart)
[17:42:19.668]                             muffled <- TRUE
[17:42:19.668]                             break
[17:42:19.668]                           }
[17:42:19.668]                         }
[17:42:19.668]                       }
[17:42:19.668]                       invisible(muffled)
[17:42:19.668]                     }
[17:42:19.668]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.668]                   }
[17:42:19.668]                 }
[17:42:19.668]                 else {
[17:42:19.668]                   if (TRUE) {
[17:42:19.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.668]                     {
[17:42:19.668]                       inherits <- base::inherits
[17:42:19.668]                       invokeRestart <- base::invokeRestart
[17:42:19.668]                       is.null <- base::is.null
[17:42:19.668]                       muffled <- FALSE
[17:42:19.668]                       if (inherits(cond, "message")) {
[17:42:19.668]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.668]                         if (muffled) 
[17:42:19.668]                           invokeRestart("muffleMessage")
[17:42:19.668]                       }
[17:42:19.668]                       else if (inherits(cond, "warning")) {
[17:42:19.668]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.668]                         if (muffled) 
[17:42:19.668]                           invokeRestart("muffleWarning")
[17:42:19.668]                       }
[17:42:19.668]                       else if (inherits(cond, "condition")) {
[17:42:19.668]                         if (!is.null(pattern)) {
[17:42:19.668]                           computeRestarts <- base::computeRestarts
[17:42:19.668]                           grepl <- base::grepl
[17:42:19.668]                           restarts <- computeRestarts(cond)
[17:42:19.668]                           for (restart in restarts) {
[17:42:19.668]                             name <- restart$name
[17:42:19.668]                             if (is.null(name)) 
[17:42:19.668]                               next
[17:42:19.668]                             if (!grepl(pattern, name)) 
[17:42:19.668]                               next
[17:42:19.668]                             invokeRestart(restart)
[17:42:19.668]                             muffled <- TRUE
[17:42:19.668]                             break
[17:42:19.668]                           }
[17:42:19.668]                         }
[17:42:19.668]                       }
[17:42:19.668]                       invisible(muffled)
[17:42:19.668]                     }
[17:42:19.668]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.668]                   }
[17:42:19.668]                 }
[17:42:19.668]             }
[17:42:19.668]         }))
[17:42:19.668]     }, error = function(ex) {
[17:42:19.668]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.668]                 ...future.rng), started = ...future.startTime, 
[17:42:19.668]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.668]             version = "1.8"), class = "FutureResult")
[17:42:19.668]     }, finally = {
[17:42:19.668]         if (!identical(...future.workdir, getwd())) 
[17:42:19.668]             setwd(...future.workdir)
[17:42:19.668]         {
[17:42:19.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.668]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.668]             }
[17:42:19.668]             base::options(...future.oldOptions)
[17:42:19.668]             if (.Platform$OS.type == "windows") {
[17:42:19.668]                 old_names <- names(...future.oldEnvVars)
[17:42:19.668]                 envs <- base::Sys.getenv()
[17:42:19.668]                 names <- names(envs)
[17:42:19.668]                 common <- intersect(names, old_names)
[17:42:19.668]                 added <- setdiff(names, old_names)
[17:42:19.668]                 removed <- setdiff(old_names, names)
[17:42:19.668]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.668]                   envs[common]]
[17:42:19.668]                 NAMES <- toupper(changed)
[17:42:19.668]                 args <- list()
[17:42:19.668]                 for (kk in seq_along(NAMES)) {
[17:42:19.668]                   name <- changed[[kk]]
[17:42:19.668]                   NAME <- NAMES[[kk]]
[17:42:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.668]                     next
[17:42:19.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.668]                 }
[17:42:19.668]                 NAMES <- toupper(added)
[17:42:19.668]                 for (kk in seq_along(NAMES)) {
[17:42:19.668]                   name <- added[[kk]]
[17:42:19.668]                   NAME <- NAMES[[kk]]
[17:42:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.668]                     next
[17:42:19.668]                   args[[name]] <- ""
[17:42:19.668]                 }
[17:42:19.668]                 NAMES <- toupper(removed)
[17:42:19.668]                 for (kk in seq_along(NAMES)) {
[17:42:19.668]                   name <- removed[[kk]]
[17:42:19.668]                   NAME <- NAMES[[kk]]
[17:42:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.668]                     next
[17:42:19.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.668]                 }
[17:42:19.668]                 if (length(args) > 0) 
[17:42:19.668]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.668]             }
[17:42:19.668]             else {
[17:42:19.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.668]             }
[17:42:19.668]             {
[17:42:19.668]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.668]                   0L) {
[17:42:19.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.668]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.668]                   base::options(opts)
[17:42:19.668]                 }
[17:42:19.668]                 {
[17:42:19.668]                   {
[17:42:19.668]                     NULL
[17:42:19.668]                     RNGkind("Mersenne-Twister")
[17:42:19.668]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.668]                       inherits = FALSE)
[17:42:19.668]                   }
[17:42:19.668]                   options(future.plan = NULL)
[17:42:19.668]                   if (is.na(NA_character_)) 
[17:42:19.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.668]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.668]                   {
[17:42:19.668]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.668]                     if (!future$lazy) 
[17:42:19.668]                       future <- run(future)
[17:42:19.668]                     invisible(future)
[17:42:19.668]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.668]                 }
[17:42:19.668]             }
[17:42:19.668]         }
[17:42:19.668]     })
[17:42:19.668]     if (TRUE) {
[17:42:19.668]         base::sink(type = "output", split = FALSE)
[17:42:19.668]         if (TRUE) {
[17:42:19.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.668]         }
[17:42:19.668]         else {
[17:42:19.668]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.668]         }
[17:42:19.668]         base::close(...future.stdout)
[17:42:19.668]         ...future.stdout <- NULL
[17:42:19.668]     }
[17:42:19.668]     ...future.result$conditions <- ...future.conditions
[17:42:19.668]     ...future.result$finished <- base::Sys.time()
[17:42:19.668]     ...future.result
[17:42:19.668] }
[17:42:19.669] plan(): Setting new future strategy stack:
[17:42:19.669] List of future strategies:
[17:42:19.669] 1. sequential:
[17:42:19.669]    - args: function (..., envir = parent.frame())
[17:42:19.669]    - tweaked: FALSE
[17:42:19.669]    - call: NULL
[17:42:19.670] plan(): nbrOfWorkers() = 1
[17:42:19.671] plan(): Setting new future strategy stack:
[17:42:19.671] List of future strategies:
[17:42:19.671] 1. sequential:
[17:42:19.671]    - args: function (..., envir = parent.frame())
[17:42:19.671]    - tweaked: FALSE
[17:42:19.671]    - call: plan(strategy)
[17:42:19.671] plan(): nbrOfWorkers() = 1
[17:42:19.671] SequentialFuture started (and completed)
[17:42:19.671] - Launch lazy future ... done
[17:42:19.671] run() for ‘SequentialFuture’ ... done
[17:42:19.672] getGlobalsAndPackages() ...
[17:42:19.672] Searching for globals...
[17:42:19.672] 
[17:42:19.672] Searching for globals ... DONE
[17:42:19.672] - globals: [0] <none>
[17:42:19.672] getGlobalsAndPackages() ... DONE
[17:42:19.672] run() for ‘Future’ ...
[17:42:19.672] - state: ‘created’
[17:42:19.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.673]   - Field: ‘label’
[17:42:19.673]   - Field: ‘local’
[17:42:19.673]   - Field: ‘owner’
[17:42:19.673]   - Field: ‘envir’
[17:42:19.673]   - Field: ‘packages’
[17:42:19.674]   - Field: ‘gc’
[17:42:19.674]   - Field: ‘conditions’
[17:42:19.674]   - Field: ‘expr’
[17:42:19.674]   - Field: ‘uuid’
[17:42:19.674]   - Field: ‘seed’
[17:42:19.674]   - Field: ‘version’
[17:42:19.674]   - Field: ‘result’
[17:42:19.674]   - Field: ‘asynchronous’
[17:42:19.674]   - Field: ‘calls’
[17:42:19.674]   - Field: ‘globals’
[17:42:19.674]   - Field: ‘stdout’
[17:42:19.675]   - Field: ‘earlySignal’
[17:42:19.675]   - Field: ‘lazy’
[17:42:19.675]   - Field: ‘state’
[17:42:19.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.675] - Launch lazy future ...
[17:42:19.675] Packages needed by the future expression (n = 0): <none>
[17:42:19.675] Packages needed by future strategies (n = 0): <none>
[17:42:19.676] {
[17:42:19.676]     {
[17:42:19.676]         {
[17:42:19.676]             ...future.startTime <- base::Sys.time()
[17:42:19.676]             {
[17:42:19.676]                 {
[17:42:19.676]                   {
[17:42:19.676]                     base::local({
[17:42:19.676]                       has_future <- base::requireNamespace("future", 
[17:42:19.676]                         quietly = TRUE)
[17:42:19.676]                       if (has_future) {
[17:42:19.676]                         ns <- base::getNamespace("future")
[17:42:19.676]                         version <- ns[[".package"]][["version"]]
[17:42:19.676]                         if (is.null(version)) 
[17:42:19.676]                           version <- utils::packageVersion("future")
[17:42:19.676]                       }
[17:42:19.676]                       else {
[17:42:19.676]                         version <- NULL
[17:42:19.676]                       }
[17:42:19.676]                       if (!has_future || version < "1.8.0") {
[17:42:19.676]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.676]                           "", base::R.version$version.string), 
[17:42:19.676]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.676]                             "release", "version")], collapse = " "), 
[17:42:19.676]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.676]                           info)
[17:42:19.676]                         info <- base::paste(info, collapse = "; ")
[17:42:19.676]                         if (!has_future) {
[17:42:19.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.676]                             info)
[17:42:19.676]                         }
[17:42:19.676]                         else {
[17:42:19.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.676]                             info, version)
[17:42:19.676]                         }
[17:42:19.676]                         base::stop(msg)
[17:42:19.676]                       }
[17:42:19.676]                     })
[17:42:19.676]                   }
[17:42:19.676]                   options(future.plan = NULL)
[17:42:19.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.676]                 }
[17:42:19.676]                 ...future.workdir <- getwd()
[17:42:19.676]             }
[17:42:19.676]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.676]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.676]         }
[17:42:19.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.676]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.676]             base::names(...future.oldOptions))
[17:42:19.676]     }
[17:42:19.676]     if (FALSE) {
[17:42:19.676]     }
[17:42:19.676]     else {
[17:42:19.676]         if (TRUE) {
[17:42:19.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.676]                 open = "w")
[17:42:19.676]         }
[17:42:19.676]         else {
[17:42:19.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.676]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.676]         }
[17:42:19.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.676]             base::sink(type = "output", split = FALSE)
[17:42:19.676]             base::close(...future.stdout)
[17:42:19.676]         }, add = TRUE)
[17:42:19.676]     }
[17:42:19.676]     ...future.frame <- base::sys.nframe()
[17:42:19.676]     ...future.conditions <- base::list()
[17:42:19.676]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.676]     if (FALSE) {
[17:42:19.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.676]     }
[17:42:19.676]     ...future.result <- base::tryCatch({
[17:42:19.676]         base::withCallingHandlers({
[17:42:19.676]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.676]             future::FutureResult(value = ...future.value$value, 
[17:42:19.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.676]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.676]                     ...future.globalenv.names))
[17:42:19.676]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.676]         }, condition = base::local({
[17:42:19.676]             c <- base::c
[17:42:19.676]             inherits <- base::inherits
[17:42:19.676]             invokeRestart <- base::invokeRestart
[17:42:19.676]             length <- base::length
[17:42:19.676]             list <- base::list
[17:42:19.676]             seq.int <- base::seq.int
[17:42:19.676]             signalCondition <- base::signalCondition
[17:42:19.676]             sys.calls <- base::sys.calls
[17:42:19.676]             `[[` <- base::`[[`
[17:42:19.676]             `+` <- base::`+`
[17:42:19.676]             `<<-` <- base::`<<-`
[17:42:19.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.676]                   3L)]
[17:42:19.676]             }
[17:42:19.676]             function(cond) {
[17:42:19.676]                 is_error <- inherits(cond, "error")
[17:42:19.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.676]                   NULL)
[17:42:19.676]                 if (is_error) {
[17:42:19.676]                   sessionInformation <- function() {
[17:42:19.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.676]                       search = base::search(), system = base::Sys.info())
[17:42:19.676]                   }
[17:42:19.676]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.676]                     cond$call), session = sessionInformation(), 
[17:42:19.676]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.676]                   signalCondition(cond)
[17:42:19.676]                 }
[17:42:19.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.676]                 "immediateCondition"))) {
[17:42:19.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.676]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.676]                   if (TRUE && !signal) {
[17:42:19.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.676]                     {
[17:42:19.676]                       inherits <- base::inherits
[17:42:19.676]                       invokeRestart <- base::invokeRestart
[17:42:19.676]                       is.null <- base::is.null
[17:42:19.676]                       muffled <- FALSE
[17:42:19.676]                       if (inherits(cond, "message")) {
[17:42:19.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.676]                         if (muffled) 
[17:42:19.676]                           invokeRestart("muffleMessage")
[17:42:19.676]                       }
[17:42:19.676]                       else if (inherits(cond, "warning")) {
[17:42:19.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.676]                         if (muffled) 
[17:42:19.676]                           invokeRestart("muffleWarning")
[17:42:19.676]                       }
[17:42:19.676]                       else if (inherits(cond, "condition")) {
[17:42:19.676]                         if (!is.null(pattern)) {
[17:42:19.676]                           computeRestarts <- base::computeRestarts
[17:42:19.676]                           grepl <- base::grepl
[17:42:19.676]                           restarts <- computeRestarts(cond)
[17:42:19.676]                           for (restart in restarts) {
[17:42:19.676]                             name <- restart$name
[17:42:19.676]                             if (is.null(name)) 
[17:42:19.676]                               next
[17:42:19.676]                             if (!grepl(pattern, name)) 
[17:42:19.676]                               next
[17:42:19.676]                             invokeRestart(restart)
[17:42:19.676]                             muffled <- TRUE
[17:42:19.676]                             break
[17:42:19.676]                           }
[17:42:19.676]                         }
[17:42:19.676]                       }
[17:42:19.676]                       invisible(muffled)
[17:42:19.676]                     }
[17:42:19.676]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.676]                   }
[17:42:19.676]                 }
[17:42:19.676]                 else {
[17:42:19.676]                   if (TRUE) {
[17:42:19.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.676]                     {
[17:42:19.676]                       inherits <- base::inherits
[17:42:19.676]                       invokeRestart <- base::invokeRestart
[17:42:19.676]                       is.null <- base::is.null
[17:42:19.676]                       muffled <- FALSE
[17:42:19.676]                       if (inherits(cond, "message")) {
[17:42:19.676]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.676]                         if (muffled) 
[17:42:19.676]                           invokeRestart("muffleMessage")
[17:42:19.676]                       }
[17:42:19.676]                       else if (inherits(cond, "warning")) {
[17:42:19.676]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.676]                         if (muffled) 
[17:42:19.676]                           invokeRestart("muffleWarning")
[17:42:19.676]                       }
[17:42:19.676]                       else if (inherits(cond, "condition")) {
[17:42:19.676]                         if (!is.null(pattern)) {
[17:42:19.676]                           computeRestarts <- base::computeRestarts
[17:42:19.676]                           grepl <- base::grepl
[17:42:19.676]                           restarts <- computeRestarts(cond)
[17:42:19.676]                           for (restart in restarts) {
[17:42:19.676]                             name <- restart$name
[17:42:19.676]                             if (is.null(name)) 
[17:42:19.676]                               next
[17:42:19.676]                             if (!grepl(pattern, name)) 
[17:42:19.676]                               next
[17:42:19.676]                             invokeRestart(restart)
[17:42:19.676]                             muffled <- TRUE
[17:42:19.676]                             break
[17:42:19.676]                           }
[17:42:19.676]                         }
[17:42:19.676]                       }
[17:42:19.676]                       invisible(muffled)
[17:42:19.676]                     }
[17:42:19.676]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.676]                   }
[17:42:19.676]                 }
[17:42:19.676]             }
[17:42:19.676]         }))
[17:42:19.676]     }, error = function(ex) {
[17:42:19.676]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.676]                 ...future.rng), started = ...future.startTime, 
[17:42:19.676]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.676]             version = "1.8"), class = "FutureResult")
[17:42:19.676]     }, finally = {
[17:42:19.676]         if (!identical(...future.workdir, getwd())) 
[17:42:19.676]             setwd(...future.workdir)
[17:42:19.676]         {
[17:42:19.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.676]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.676]             }
[17:42:19.676]             base::options(...future.oldOptions)
[17:42:19.676]             if (.Platform$OS.type == "windows") {
[17:42:19.676]                 old_names <- names(...future.oldEnvVars)
[17:42:19.676]                 envs <- base::Sys.getenv()
[17:42:19.676]                 names <- names(envs)
[17:42:19.676]                 common <- intersect(names, old_names)
[17:42:19.676]                 added <- setdiff(names, old_names)
[17:42:19.676]                 removed <- setdiff(old_names, names)
[17:42:19.676]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.676]                   envs[common]]
[17:42:19.676]                 NAMES <- toupper(changed)
[17:42:19.676]                 args <- list()
[17:42:19.676]                 for (kk in seq_along(NAMES)) {
[17:42:19.676]                   name <- changed[[kk]]
[17:42:19.676]                   NAME <- NAMES[[kk]]
[17:42:19.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.676]                     next
[17:42:19.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.676]                 }
[17:42:19.676]                 NAMES <- toupper(added)
[17:42:19.676]                 for (kk in seq_along(NAMES)) {
[17:42:19.676]                   name <- added[[kk]]
[17:42:19.676]                   NAME <- NAMES[[kk]]
[17:42:19.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.676]                     next
[17:42:19.676]                   args[[name]] <- ""
[17:42:19.676]                 }
[17:42:19.676]                 NAMES <- toupper(removed)
[17:42:19.676]                 for (kk in seq_along(NAMES)) {
[17:42:19.676]                   name <- removed[[kk]]
[17:42:19.676]                   NAME <- NAMES[[kk]]
[17:42:19.676]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.676]                     next
[17:42:19.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.676]                 }
[17:42:19.676]                 if (length(args) > 0) 
[17:42:19.676]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.676]             }
[17:42:19.676]             else {
[17:42:19.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.676]             }
[17:42:19.676]             {
[17:42:19.676]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.676]                   0L) {
[17:42:19.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.676]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.676]                   base::options(opts)
[17:42:19.676]                 }
[17:42:19.676]                 {
[17:42:19.676]                   {
[17:42:19.676]                     NULL
[17:42:19.676]                     RNGkind("Mersenne-Twister")
[17:42:19.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.676]                       inherits = FALSE)
[17:42:19.676]                   }
[17:42:19.676]                   options(future.plan = NULL)
[17:42:19.676]                   if (is.na(NA_character_)) 
[17:42:19.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.676]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.676]                   {
[17:42:19.676]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.676]                     if (!future$lazy) 
[17:42:19.676]                       future <- run(future)
[17:42:19.676]                     invisible(future)
[17:42:19.676]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.676]                 }
[17:42:19.676]             }
[17:42:19.676]         }
[17:42:19.676]     })
[17:42:19.676]     if (TRUE) {
[17:42:19.676]         base::sink(type = "output", split = FALSE)
[17:42:19.676]         if (TRUE) {
[17:42:19.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.676]         }
[17:42:19.676]         else {
[17:42:19.676]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.676]         }
[17:42:19.676]         base::close(...future.stdout)
[17:42:19.676]         ...future.stdout <- NULL
[17:42:19.676]     }
[17:42:19.676]     ...future.result$conditions <- ...future.conditions
[17:42:19.676]     ...future.result$finished <- base::Sys.time()
[17:42:19.676]     ...future.result
[17:42:19.676] }
[17:42:19.677] plan(): Setting new future strategy stack:
[17:42:19.677] List of future strategies:
[17:42:19.677] 1. sequential:
[17:42:19.677]    - args: function (..., envir = parent.frame())
[17:42:19.677]    - tweaked: FALSE
[17:42:19.677]    - call: NULL
[17:42:19.678] plan(): nbrOfWorkers() = 1
[17:42:19.678] plan(): Setting new future strategy stack:
[17:42:19.679] List of future strategies:
[17:42:19.679] 1. sequential:
[17:42:19.679]    - args: function (..., envir = parent.frame())
[17:42:19.679]    - tweaked: FALSE
[17:42:19.679]    - call: plan(strategy)
[17:42:19.679] plan(): nbrOfWorkers() = 1
[17:42:19.679] SequentialFuture started (and completed)
[17:42:19.679] - Launch lazy future ... done
[17:42:19.679] run() for ‘SequentialFuture’ ... done
[17:42:19.680] getGlobalsAndPackages() ...
[17:42:19.680] Searching for globals...
[17:42:19.680] - globals found: [1] ‘{’
[17:42:19.680] Searching for globals ... DONE
[17:42:19.681] Resolving globals: FALSE
[17:42:19.681] 
[17:42:19.681] 
[17:42:19.681] getGlobalsAndPackages() ... DONE
[17:42:19.681] run() for ‘Future’ ...
[17:42:19.681] - state: ‘created’
[17:42:19.681] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.682] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.682]   - Field: ‘label’
[17:42:19.682]   - Field: ‘local’
[17:42:19.682]   - Field: ‘owner’
[17:42:19.682]   - Field: ‘envir’
[17:42:19.682]   - Field: ‘packages’
[17:42:19.682]   - Field: ‘gc’
[17:42:19.682]   - Field: ‘conditions’
[17:42:19.683]   - Field: ‘expr’
[17:42:19.684]   - Field: ‘uuid’
[17:42:19.684]   - Field: ‘seed’
[17:42:19.684]   - Field: ‘version’
[17:42:19.685]   - Field: ‘result’
[17:42:19.685]   - Field: ‘asynchronous’
[17:42:19.685]   - Field: ‘calls’
[17:42:19.685]   - Field: ‘globals’
[17:42:19.685]   - Field: ‘stdout’
[17:42:19.685]   - Field: ‘earlySignal’
[17:42:19.685]   - Field: ‘lazy’
[17:42:19.685]   - Field: ‘state’
[17:42:19.685] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.686] - Launch lazy future ...
[17:42:19.686] Packages needed by the future expression (n = 0): <none>
[17:42:19.686] Packages needed by future strategies (n = 0): <none>
[17:42:19.687] {
[17:42:19.687]     {
[17:42:19.687]         {
[17:42:19.687]             ...future.startTime <- base::Sys.time()
[17:42:19.687]             {
[17:42:19.687]                 {
[17:42:19.687]                   {
[17:42:19.687]                     base::local({
[17:42:19.687]                       has_future <- base::requireNamespace("future", 
[17:42:19.687]                         quietly = TRUE)
[17:42:19.687]                       if (has_future) {
[17:42:19.687]                         ns <- base::getNamespace("future")
[17:42:19.687]                         version <- ns[[".package"]][["version"]]
[17:42:19.687]                         if (is.null(version)) 
[17:42:19.687]                           version <- utils::packageVersion("future")
[17:42:19.687]                       }
[17:42:19.687]                       else {
[17:42:19.687]                         version <- NULL
[17:42:19.687]                       }
[17:42:19.687]                       if (!has_future || version < "1.8.0") {
[17:42:19.687]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.687]                           "", base::R.version$version.string), 
[17:42:19.687]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.687]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.687]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.687]                             "release", "version")], collapse = " "), 
[17:42:19.687]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.687]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.687]                           info)
[17:42:19.687]                         info <- base::paste(info, collapse = "; ")
[17:42:19.687]                         if (!has_future) {
[17:42:19.687]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.687]                             info)
[17:42:19.687]                         }
[17:42:19.687]                         else {
[17:42:19.687]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.687]                             info, version)
[17:42:19.687]                         }
[17:42:19.687]                         base::stop(msg)
[17:42:19.687]                       }
[17:42:19.687]                     })
[17:42:19.687]                   }
[17:42:19.687]                   options(future.plan = NULL)
[17:42:19.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.687]                 }
[17:42:19.687]                 ...future.workdir <- getwd()
[17:42:19.687]             }
[17:42:19.687]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.687]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.687]         }
[17:42:19.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.687]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.687]             base::names(...future.oldOptions))
[17:42:19.687]     }
[17:42:19.687]     if (FALSE) {
[17:42:19.687]     }
[17:42:19.687]     else {
[17:42:19.687]         if (TRUE) {
[17:42:19.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.687]                 open = "w")
[17:42:19.687]         }
[17:42:19.687]         else {
[17:42:19.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.687]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.687]         }
[17:42:19.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.687]             base::sink(type = "output", split = FALSE)
[17:42:19.687]             base::close(...future.stdout)
[17:42:19.687]         }, add = TRUE)
[17:42:19.687]     }
[17:42:19.687]     ...future.frame <- base::sys.nframe()
[17:42:19.687]     ...future.conditions <- base::list()
[17:42:19.687]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.687]     if (FALSE) {
[17:42:19.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.687]     }
[17:42:19.687]     ...future.result <- base::tryCatch({
[17:42:19.687]         base::withCallingHandlers({
[17:42:19.687]             ...future.value <- base::withVisible(base::local({
[17:42:19.687]                 4
[17:42:19.687]             }))
[17:42:19.687]             future::FutureResult(value = ...future.value$value, 
[17:42:19.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.687]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.687]                     ...future.globalenv.names))
[17:42:19.687]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.687]         }, condition = base::local({
[17:42:19.687]             c <- base::c
[17:42:19.687]             inherits <- base::inherits
[17:42:19.687]             invokeRestart <- base::invokeRestart
[17:42:19.687]             length <- base::length
[17:42:19.687]             list <- base::list
[17:42:19.687]             seq.int <- base::seq.int
[17:42:19.687]             signalCondition <- base::signalCondition
[17:42:19.687]             sys.calls <- base::sys.calls
[17:42:19.687]             `[[` <- base::`[[`
[17:42:19.687]             `+` <- base::`+`
[17:42:19.687]             `<<-` <- base::`<<-`
[17:42:19.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.687]                   3L)]
[17:42:19.687]             }
[17:42:19.687]             function(cond) {
[17:42:19.687]                 is_error <- inherits(cond, "error")
[17:42:19.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.687]                   NULL)
[17:42:19.687]                 if (is_error) {
[17:42:19.687]                   sessionInformation <- function() {
[17:42:19.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.687]                       search = base::search(), system = base::Sys.info())
[17:42:19.687]                   }
[17:42:19.687]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.687]                     cond$call), session = sessionInformation(), 
[17:42:19.687]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.687]                   signalCondition(cond)
[17:42:19.687]                 }
[17:42:19.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.687]                 "immediateCondition"))) {
[17:42:19.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.687]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.687]                   if (TRUE && !signal) {
[17:42:19.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.687]                     {
[17:42:19.687]                       inherits <- base::inherits
[17:42:19.687]                       invokeRestart <- base::invokeRestart
[17:42:19.687]                       is.null <- base::is.null
[17:42:19.687]                       muffled <- FALSE
[17:42:19.687]                       if (inherits(cond, "message")) {
[17:42:19.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.687]                         if (muffled) 
[17:42:19.687]                           invokeRestart("muffleMessage")
[17:42:19.687]                       }
[17:42:19.687]                       else if (inherits(cond, "warning")) {
[17:42:19.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.687]                         if (muffled) 
[17:42:19.687]                           invokeRestart("muffleWarning")
[17:42:19.687]                       }
[17:42:19.687]                       else if (inherits(cond, "condition")) {
[17:42:19.687]                         if (!is.null(pattern)) {
[17:42:19.687]                           computeRestarts <- base::computeRestarts
[17:42:19.687]                           grepl <- base::grepl
[17:42:19.687]                           restarts <- computeRestarts(cond)
[17:42:19.687]                           for (restart in restarts) {
[17:42:19.687]                             name <- restart$name
[17:42:19.687]                             if (is.null(name)) 
[17:42:19.687]                               next
[17:42:19.687]                             if (!grepl(pattern, name)) 
[17:42:19.687]                               next
[17:42:19.687]                             invokeRestart(restart)
[17:42:19.687]                             muffled <- TRUE
[17:42:19.687]                             break
[17:42:19.687]                           }
[17:42:19.687]                         }
[17:42:19.687]                       }
[17:42:19.687]                       invisible(muffled)
[17:42:19.687]                     }
[17:42:19.687]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.687]                   }
[17:42:19.687]                 }
[17:42:19.687]                 else {
[17:42:19.687]                   if (TRUE) {
[17:42:19.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.687]                     {
[17:42:19.687]                       inherits <- base::inherits
[17:42:19.687]                       invokeRestart <- base::invokeRestart
[17:42:19.687]                       is.null <- base::is.null
[17:42:19.687]                       muffled <- FALSE
[17:42:19.687]                       if (inherits(cond, "message")) {
[17:42:19.687]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.687]                         if (muffled) 
[17:42:19.687]                           invokeRestart("muffleMessage")
[17:42:19.687]                       }
[17:42:19.687]                       else if (inherits(cond, "warning")) {
[17:42:19.687]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.687]                         if (muffled) 
[17:42:19.687]                           invokeRestart("muffleWarning")
[17:42:19.687]                       }
[17:42:19.687]                       else if (inherits(cond, "condition")) {
[17:42:19.687]                         if (!is.null(pattern)) {
[17:42:19.687]                           computeRestarts <- base::computeRestarts
[17:42:19.687]                           grepl <- base::grepl
[17:42:19.687]                           restarts <- computeRestarts(cond)
[17:42:19.687]                           for (restart in restarts) {
[17:42:19.687]                             name <- restart$name
[17:42:19.687]                             if (is.null(name)) 
[17:42:19.687]                               next
[17:42:19.687]                             if (!grepl(pattern, name)) 
[17:42:19.687]                               next
[17:42:19.687]                             invokeRestart(restart)
[17:42:19.687]                             muffled <- TRUE
[17:42:19.687]                             break
[17:42:19.687]                           }
[17:42:19.687]                         }
[17:42:19.687]                       }
[17:42:19.687]                       invisible(muffled)
[17:42:19.687]                     }
[17:42:19.687]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.687]                   }
[17:42:19.687]                 }
[17:42:19.687]             }
[17:42:19.687]         }))
[17:42:19.687]     }, error = function(ex) {
[17:42:19.687]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.687]                 ...future.rng), started = ...future.startTime, 
[17:42:19.687]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.687]             version = "1.8"), class = "FutureResult")
[17:42:19.687]     }, finally = {
[17:42:19.687]         if (!identical(...future.workdir, getwd())) 
[17:42:19.687]             setwd(...future.workdir)
[17:42:19.687]         {
[17:42:19.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.687]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.687]             }
[17:42:19.687]             base::options(...future.oldOptions)
[17:42:19.687]             if (.Platform$OS.type == "windows") {
[17:42:19.687]                 old_names <- names(...future.oldEnvVars)
[17:42:19.687]                 envs <- base::Sys.getenv()
[17:42:19.687]                 names <- names(envs)
[17:42:19.687]                 common <- intersect(names, old_names)
[17:42:19.687]                 added <- setdiff(names, old_names)
[17:42:19.687]                 removed <- setdiff(old_names, names)
[17:42:19.687]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.687]                   envs[common]]
[17:42:19.687]                 NAMES <- toupper(changed)
[17:42:19.687]                 args <- list()
[17:42:19.687]                 for (kk in seq_along(NAMES)) {
[17:42:19.687]                   name <- changed[[kk]]
[17:42:19.687]                   NAME <- NAMES[[kk]]
[17:42:19.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.687]                     next
[17:42:19.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.687]                 }
[17:42:19.687]                 NAMES <- toupper(added)
[17:42:19.687]                 for (kk in seq_along(NAMES)) {
[17:42:19.687]                   name <- added[[kk]]
[17:42:19.687]                   NAME <- NAMES[[kk]]
[17:42:19.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.687]                     next
[17:42:19.687]                   args[[name]] <- ""
[17:42:19.687]                 }
[17:42:19.687]                 NAMES <- toupper(removed)
[17:42:19.687]                 for (kk in seq_along(NAMES)) {
[17:42:19.687]                   name <- removed[[kk]]
[17:42:19.687]                   NAME <- NAMES[[kk]]
[17:42:19.687]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.687]                     next
[17:42:19.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.687]                 }
[17:42:19.687]                 if (length(args) > 0) 
[17:42:19.687]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.687]             }
[17:42:19.687]             else {
[17:42:19.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.687]             }
[17:42:19.687]             {
[17:42:19.687]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.687]                   0L) {
[17:42:19.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.687]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.687]                   base::options(opts)
[17:42:19.687]                 }
[17:42:19.687]                 {
[17:42:19.687]                   {
[17:42:19.687]                     NULL
[17:42:19.687]                     RNGkind("Mersenne-Twister")
[17:42:19.687]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.687]                       inherits = FALSE)
[17:42:19.687]                   }
[17:42:19.687]                   options(future.plan = NULL)
[17:42:19.687]                   if (is.na(NA_character_)) 
[17:42:19.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.687]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.687]                   {
[17:42:19.687]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.687]                     if (!future$lazy) 
[17:42:19.687]                       future <- run(future)
[17:42:19.687]                     invisible(future)
[17:42:19.687]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.687]                 }
[17:42:19.687]             }
[17:42:19.687]         }
[17:42:19.687]     })
[17:42:19.687]     if (TRUE) {
[17:42:19.687]         base::sink(type = "output", split = FALSE)
[17:42:19.687]         if (TRUE) {
[17:42:19.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.687]         }
[17:42:19.687]         else {
[17:42:19.687]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.687]         }
[17:42:19.687]         base::close(...future.stdout)
[17:42:19.687]         ...future.stdout <- NULL
[17:42:19.687]     }
[17:42:19.687]     ...future.result$conditions <- ...future.conditions
[17:42:19.687]     ...future.result$finished <- base::Sys.time()
[17:42:19.687]     ...future.result
[17:42:19.687] }
[17:42:19.689] plan(): Setting new future strategy stack:
[17:42:19.689] List of future strategies:
[17:42:19.689] 1. sequential:
[17:42:19.689]    - args: function (..., envir = parent.frame())
[17:42:19.689]    - tweaked: FALSE
[17:42:19.689]    - call: NULL
[17:42:19.689] plan(): nbrOfWorkers() = 1
[17:42:19.690] plan(): Setting new future strategy stack:
[17:42:19.690] List of future strategies:
[17:42:19.690] 1. sequential:
[17:42:19.690]    - args: function (..., envir = parent.frame())
[17:42:19.690]    - tweaked: FALSE
[17:42:19.690]    - call: plan(strategy)
[17:42:19.690] plan(): nbrOfWorkers() = 1
[17:42:19.690] SequentialFuture started (and completed)
[17:42:19.691] - Launch lazy future ... done
[17:42:19.691] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef5ffea08> 
Classes 'listenv', 'environment' <environment: 0x55bef6424e08> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:19.695] resolved() for ‘SequentialFuture’ ...
[17:42:19.695] - state: ‘finished’
[17:42:19.695] - run: TRUE
[17:42:19.695] - result: ‘FutureResult’
[17:42:19.695] resolved() for ‘SequentialFuture’ ... done
[17:42:19.695] resolved() for ‘SequentialFuture’ ...
[17:42:19.695] - state: ‘finished’
[17:42:19.695] - run: TRUE
[17:42:19.695] - result: ‘FutureResult’
[17:42:19.695] resolved() for ‘SequentialFuture’ ... done
[17:42:19.696] resolved() for ‘SequentialFuture’ ...
[17:42:19.696] - state: ‘finished’
[17:42:19.696] - run: TRUE
[17:42:19.696] - result: ‘FutureResult’
[17:42:19.696] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:19.698] resolve() on list environment ...
[17:42:19.699]  recursive: 0
[17:42:19.699]  length: 6
[17:42:19.700]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:19.700] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.700] - nx: 6
[17:42:19.700] - relay: TRUE
[17:42:19.700] - stdout: TRUE
[17:42:19.700] - signal: TRUE
[17:42:19.700] - resignal: FALSE
[17:42:19.700] - force: TRUE
[17:42:19.700] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.700] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.701]  - until=2
[17:42:19.701]  - relaying element #2
[17:42:19.701] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.701] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.701] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.701]  length: 5 (resolved future 1)
[17:42:19.701] resolved() for ‘SequentialFuture’ ...
[17:42:19.701] - state: ‘finished’
[17:42:19.701] - run: TRUE
[17:42:19.701] - result: ‘FutureResult’
[17:42:19.702] resolved() for ‘SequentialFuture’ ... done
[17:42:19.702] Future #2
[17:42:19.702] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.702] - nx: 6
[17:42:19.702] - relay: TRUE
[17:42:19.702] - stdout: TRUE
[17:42:19.702] - signal: TRUE
[17:42:19.702] - resignal: FALSE
[17:42:19.702] - force: TRUE
[17:42:19.702] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.702] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.703]  - until=2
[17:42:19.703]  - relaying element #2
[17:42:19.703] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.703] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.703] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.703]  length: 4 (resolved future 2)
[17:42:19.703] resolved() for ‘SequentialFuture’ ...
[17:42:19.703] - state: ‘finished’
[17:42:19.704] - run: TRUE
[17:42:19.704] - result: ‘FutureResult’
[17:42:19.704] resolved() for ‘SequentialFuture’ ... done
[17:42:19.704] Future #3
[17:42:19.704] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.704] - nx: 6
[17:42:19.704] - relay: TRUE
[17:42:19.704] - stdout: TRUE
[17:42:19.704] - signal: TRUE
[17:42:19.704] - resignal: FALSE
[17:42:19.704] - force: TRUE
[17:42:19.705] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.705] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.705]  - until=3
[17:42:19.705]  - relaying element #3
[17:42:19.705] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.705] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.705] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.705]  length: 3 (resolved future 3)
[17:42:19.705] resolved() for ‘SequentialFuture’ ...
[17:42:19.706] - state: ‘finished’
[17:42:19.706] - run: TRUE
[17:42:19.706] - result: ‘FutureResult’
[17:42:19.706] resolved() for ‘SequentialFuture’ ... done
[17:42:19.706] Future #4
[17:42:19.706] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.706] - nx: 6
[17:42:19.706] - relay: TRUE
[17:42:19.706] - stdout: TRUE
[17:42:19.706] - signal: TRUE
[17:42:19.706] - resignal: FALSE
[17:42:19.707] - force: TRUE
[17:42:19.707] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.707] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.707]  - until=4
[17:42:19.707]  - relaying element #4
[17:42:19.707] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.707] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.707] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.707]  length: 2 (resolved future 4)
[17:42:19.708] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.708] - nx: 6
[17:42:19.708] - relay: TRUE
[17:42:19.708] - stdout: TRUE
[17:42:19.708] - signal: TRUE
[17:42:19.708] - resignal: FALSE
[17:42:19.708] - force: TRUE
[17:42:19.708] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.708] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.708]  - until=6
[17:42:19.708]  - relaying element #6
[17:42:19.708] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.709] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.709] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.709]  length: 1 (resolved future 5)
[17:42:19.709] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.709] - nx: 6
[17:42:19.709] - relay: TRUE
[17:42:19.709] - stdout: TRUE
[17:42:19.709] - signal: TRUE
[17:42:19.709] - resignal: FALSE
[17:42:19.709] - force: TRUE
[17:42:19.709] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.710] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.710]  - until=6
[17:42:19.712] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.712] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.712] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.712]  length: 0 (resolved future 6)
[17:42:19.712] Relaying remaining futures
[17:42:19.712] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.712] - nx: 6
[17:42:19.712] - relay: TRUE
[17:42:19.713] - stdout: TRUE
[17:42:19.713] - signal: TRUE
[17:42:19.713] - resignal: FALSE
[17:42:19.713] - force: TRUE
[17:42:19.713] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.713] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:19.713] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.713] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.713] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.714] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef7bd9fa0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:42:19.716] getGlobalsAndPackages() ...
[17:42:19.716] Searching for globals...
[17:42:19.716] 
[17:42:19.717] Searching for globals ... DONE
[17:42:19.717] - globals: [0] <none>
[17:42:19.717] getGlobalsAndPackages() ... DONE
[17:42:19.717] run() for ‘Future’ ...
[17:42:19.717] - state: ‘created’
[17:42:19.717] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.718] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.718]   - Field: ‘label’
[17:42:19.718]   - Field: ‘local’
[17:42:19.718]   - Field: ‘owner’
[17:42:19.718]   - Field: ‘envir’
[17:42:19.718]   - Field: ‘packages’
[17:42:19.718]   - Field: ‘gc’
[17:42:19.718]   - Field: ‘conditions’
[17:42:19.718]   - Field: ‘expr’
[17:42:19.719]   - Field: ‘uuid’
[17:42:19.719]   - Field: ‘seed’
[17:42:19.719]   - Field: ‘version’
[17:42:19.719]   - Field: ‘result’
[17:42:19.719]   - Field: ‘asynchronous’
[17:42:19.719]   - Field: ‘calls’
[17:42:19.719]   - Field: ‘globals’
[17:42:19.719]   - Field: ‘stdout’
[17:42:19.719]   - Field: ‘earlySignal’
[17:42:19.720]   - Field: ‘lazy’
[17:42:19.720]   - Field: ‘state’
[17:42:19.720] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.720] - Launch lazy future ...
[17:42:19.720] Packages needed by the future expression (n = 0): <none>
[17:42:19.720] Packages needed by future strategies (n = 0): <none>
[17:42:19.721] {
[17:42:19.721]     {
[17:42:19.721]         {
[17:42:19.721]             ...future.startTime <- base::Sys.time()
[17:42:19.721]             {
[17:42:19.721]                 {
[17:42:19.721]                   {
[17:42:19.721]                     base::local({
[17:42:19.721]                       has_future <- base::requireNamespace("future", 
[17:42:19.721]                         quietly = TRUE)
[17:42:19.721]                       if (has_future) {
[17:42:19.721]                         ns <- base::getNamespace("future")
[17:42:19.721]                         version <- ns[[".package"]][["version"]]
[17:42:19.721]                         if (is.null(version)) 
[17:42:19.721]                           version <- utils::packageVersion("future")
[17:42:19.721]                       }
[17:42:19.721]                       else {
[17:42:19.721]                         version <- NULL
[17:42:19.721]                       }
[17:42:19.721]                       if (!has_future || version < "1.8.0") {
[17:42:19.721]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.721]                           "", base::R.version$version.string), 
[17:42:19.721]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.721]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.721]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.721]                             "release", "version")], collapse = " "), 
[17:42:19.721]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.721]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.721]                           info)
[17:42:19.721]                         info <- base::paste(info, collapse = "; ")
[17:42:19.721]                         if (!has_future) {
[17:42:19.721]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.721]                             info)
[17:42:19.721]                         }
[17:42:19.721]                         else {
[17:42:19.721]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.721]                             info, version)
[17:42:19.721]                         }
[17:42:19.721]                         base::stop(msg)
[17:42:19.721]                       }
[17:42:19.721]                     })
[17:42:19.721]                   }
[17:42:19.721]                   options(future.plan = NULL)
[17:42:19.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.721]                 }
[17:42:19.721]                 ...future.workdir <- getwd()
[17:42:19.721]             }
[17:42:19.721]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.721]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.721]         }
[17:42:19.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.721]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.721]             base::names(...future.oldOptions))
[17:42:19.721]     }
[17:42:19.721]     if (FALSE) {
[17:42:19.721]     }
[17:42:19.721]     else {
[17:42:19.721]         if (TRUE) {
[17:42:19.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.721]                 open = "w")
[17:42:19.721]         }
[17:42:19.721]         else {
[17:42:19.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.721]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.721]         }
[17:42:19.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.721]             base::sink(type = "output", split = FALSE)
[17:42:19.721]             base::close(...future.stdout)
[17:42:19.721]         }, add = TRUE)
[17:42:19.721]     }
[17:42:19.721]     ...future.frame <- base::sys.nframe()
[17:42:19.721]     ...future.conditions <- base::list()
[17:42:19.721]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.721]     if (FALSE) {
[17:42:19.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.721]     }
[17:42:19.721]     ...future.result <- base::tryCatch({
[17:42:19.721]         base::withCallingHandlers({
[17:42:19.721]             ...future.value <- base::withVisible(base::local(2))
[17:42:19.721]             future::FutureResult(value = ...future.value$value, 
[17:42:19.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.721]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.721]                     ...future.globalenv.names))
[17:42:19.721]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.721]         }, condition = base::local({
[17:42:19.721]             c <- base::c
[17:42:19.721]             inherits <- base::inherits
[17:42:19.721]             invokeRestart <- base::invokeRestart
[17:42:19.721]             length <- base::length
[17:42:19.721]             list <- base::list
[17:42:19.721]             seq.int <- base::seq.int
[17:42:19.721]             signalCondition <- base::signalCondition
[17:42:19.721]             sys.calls <- base::sys.calls
[17:42:19.721]             `[[` <- base::`[[`
[17:42:19.721]             `+` <- base::`+`
[17:42:19.721]             `<<-` <- base::`<<-`
[17:42:19.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.721]                   3L)]
[17:42:19.721]             }
[17:42:19.721]             function(cond) {
[17:42:19.721]                 is_error <- inherits(cond, "error")
[17:42:19.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.721]                   NULL)
[17:42:19.721]                 if (is_error) {
[17:42:19.721]                   sessionInformation <- function() {
[17:42:19.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.721]                       search = base::search(), system = base::Sys.info())
[17:42:19.721]                   }
[17:42:19.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.721]                     cond$call), session = sessionInformation(), 
[17:42:19.721]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.721]                   signalCondition(cond)
[17:42:19.721]                 }
[17:42:19.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.721]                 "immediateCondition"))) {
[17:42:19.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.721]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.721]                   if (TRUE && !signal) {
[17:42:19.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.721]                     {
[17:42:19.721]                       inherits <- base::inherits
[17:42:19.721]                       invokeRestart <- base::invokeRestart
[17:42:19.721]                       is.null <- base::is.null
[17:42:19.721]                       muffled <- FALSE
[17:42:19.721]                       if (inherits(cond, "message")) {
[17:42:19.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.721]                         if (muffled) 
[17:42:19.721]                           invokeRestart("muffleMessage")
[17:42:19.721]                       }
[17:42:19.721]                       else if (inherits(cond, "warning")) {
[17:42:19.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.721]                         if (muffled) 
[17:42:19.721]                           invokeRestart("muffleWarning")
[17:42:19.721]                       }
[17:42:19.721]                       else if (inherits(cond, "condition")) {
[17:42:19.721]                         if (!is.null(pattern)) {
[17:42:19.721]                           computeRestarts <- base::computeRestarts
[17:42:19.721]                           grepl <- base::grepl
[17:42:19.721]                           restarts <- computeRestarts(cond)
[17:42:19.721]                           for (restart in restarts) {
[17:42:19.721]                             name <- restart$name
[17:42:19.721]                             if (is.null(name)) 
[17:42:19.721]                               next
[17:42:19.721]                             if (!grepl(pattern, name)) 
[17:42:19.721]                               next
[17:42:19.721]                             invokeRestart(restart)
[17:42:19.721]                             muffled <- TRUE
[17:42:19.721]                             break
[17:42:19.721]                           }
[17:42:19.721]                         }
[17:42:19.721]                       }
[17:42:19.721]                       invisible(muffled)
[17:42:19.721]                     }
[17:42:19.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.721]                   }
[17:42:19.721]                 }
[17:42:19.721]                 else {
[17:42:19.721]                   if (TRUE) {
[17:42:19.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.721]                     {
[17:42:19.721]                       inherits <- base::inherits
[17:42:19.721]                       invokeRestart <- base::invokeRestart
[17:42:19.721]                       is.null <- base::is.null
[17:42:19.721]                       muffled <- FALSE
[17:42:19.721]                       if (inherits(cond, "message")) {
[17:42:19.721]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.721]                         if (muffled) 
[17:42:19.721]                           invokeRestart("muffleMessage")
[17:42:19.721]                       }
[17:42:19.721]                       else if (inherits(cond, "warning")) {
[17:42:19.721]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.721]                         if (muffled) 
[17:42:19.721]                           invokeRestart("muffleWarning")
[17:42:19.721]                       }
[17:42:19.721]                       else if (inherits(cond, "condition")) {
[17:42:19.721]                         if (!is.null(pattern)) {
[17:42:19.721]                           computeRestarts <- base::computeRestarts
[17:42:19.721]                           grepl <- base::grepl
[17:42:19.721]                           restarts <- computeRestarts(cond)
[17:42:19.721]                           for (restart in restarts) {
[17:42:19.721]                             name <- restart$name
[17:42:19.721]                             if (is.null(name)) 
[17:42:19.721]                               next
[17:42:19.721]                             if (!grepl(pattern, name)) 
[17:42:19.721]                               next
[17:42:19.721]                             invokeRestart(restart)
[17:42:19.721]                             muffled <- TRUE
[17:42:19.721]                             break
[17:42:19.721]                           }
[17:42:19.721]                         }
[17:42:19.721]                       }
[17:42:19.721]                       invisible(muffled)
[17:42:19.721]                     }
[17:42:19.721]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.721]                   }
[17:42:19.721]                 }
[17:42:19.721]             }
[17:42:19.721]         }))
[17:42:19.721]     }, error = function(ex) {
[17:42:19.721]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.721]                 ...future.rng), started = ...future.startTime, 
[17:42:19.721]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.721]             version = "1.8"), class = "FutureResult")
[17:42:19.721]     }, finally = {
[17:42:19.721]         if (!identical(...future.workdir, getwd())) 
[17:42:19.721]             setwd(...future.workdir)
[17:42:19.721]         {
[17:42:19.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.721]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.721]             }
[17:42:19.721]             base::options(...future.oldOptions)
[17:42:19.721]             if (.Platform$OS.type == "windows") {
[17:42:19.721]                 old_names <- names(...future.oldEnvVars)
[17:42:19.721]                 envs <- base::Sys.getenv()
[17:42:19.721]                 names <- names(envs)
[17:42:19.721]                 common <- intersect(names, old_names)
[17:42:19.721]                 added <- setdiff(names, old_names)
[17:42:19.721]                 removed <- setdiff(old_names, names)
[17:42:19.721]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.721]                   envs[common]]
[17:42:19.721]                 NAMES <- toupper(changed)
[17:42:19.721]                 args <- list()
[17:42:19.721]                 for (kk in seq_along(NAMES)) {
[17:42:19.721]                   name <- changed[[kk]]
[17:42:19.721]                   NAME <- NAMES[[kk]]
[17:42:19.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.721]                     next
[17:42:19.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.721]                 }
[17:42:19.721]                 NAMES <- toupper(added)
[17:42:19.721]                 for (kk in seq_along(NAMES)) {
[17:42:19.721]                   name <- added[[kk]]
[17:42:19.721]                   NAME <- NAMES[[kk]]
[17:42:19.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.721]                     next
[17:42:19.721]                   args[[name]] <- ""
[17:42:19.721]                 }
[17:42:19.721]                 NAMES <- toupper(removed)
[17:42:19.721]                 for (kk in seq_along(NAMES)) {
[17:42:19.721]                   name <- removed[[kk]]
[17:42:19.721]                   NAME <- NAMES[[kk]]
[17:42:19.721]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.721]                     next
[17:42:19.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.721]                 }
[17:42:19.721]                 if (length(args) > 0) 
[17:42:19.721]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.721]             }
[17:42:19.721]             else {
[17:42:19.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.721]             }
[17:42:19.721]             {
[17:42:19.721]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.721]                   0L) {
[17:42:19.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.721]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.721]                   base::options(opts)
[17:42:19.721]                 }
[17:42:19.721]                 {
[17:42:19.721]                   {
[17:42:19.721]                     NULL
[17:42:19.721]                     RNGkind("Mersenne-Twister")
[17:42:19.721]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.721]                       inherits = FALSE)
[17:42:19.721]                   }
[17:42:19.721]                   options(future.plan = NULL)
[17:42:19.721]                   if (is.na(NA_character_)) 
[17:42:19.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.721]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.721]                   {
[17:42:19.721]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.721]                     if (!future$lazy) 
[17:42:19.721]                       future <- run(future)
[17:42:19.721]                     invisible(future)
[17:42:19.721]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.721]                 }
[17:42:19.721]             }
[17:42:19.721]         }
[17:42:19.721]     })
[17:42:19.721]     if (TRUE) {
[17:42:19.721]         base::sink(type = "output", split = FALSE)
[17:42:19.721]         if (TRUE) {
[17:42:19.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.721]         }
[17:42:19.721]         else {
[17:42:19.721]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.721]         }
[17:42:19.721]         base::close(...future.stdout)
[17:42:19.721]         ...future.stdout <- NULL
[17:42:19.721]     }
[17:42:19.721]     ...future.result$conditions <- ...future.conditions
[17:42:19.721]     ...future.result$finished <- base::Sys.time()
[17:42:19.721]     ...future.result
[17:42:19.721] }
[17:42:19.723] plan(): Setting new future strategy stack:
[17:42:19.723] List of future strategies:
[17:42:19.723] 1. sequential:
[17:42:19.723]    - args: function (..., envir = parent.frame())
[17:42:19.723]    - tweaked: FALSE
[17:42:19.723]    - call: NULL
[17:42:19.723] plan(): nbrOfWorkers() = 1
[17:42:19.724] plan(): Setting new future strategy stack:
[17:42:19.724] List of future strategies:
[17:42:19.724] 1. sequential:
[17:42:19.724]    - args: function (..., envir = parent.frame())
[17:42:19.724]    - tweaked: FALSE
[17:42:19.724]    - call: plan(strategy)
[17:42:19.724] plan(): nbrOfWorkers() = 1
[17:42:19.725] SequentialFuture started (and completed)
[17:42:19.725] - Launch lazy future ... done
[17:42:19.725] run() for ‘SequentialFuture’ ... done
[17:42:19.725] getGlobalsAndPackages() ...
[17:42:19.725] Searching for globals...
[17:42:19.725] 
[17:42:19.725] Searching for globals ... DONE
[17:42:19.726] - globals: [0] <none>
[17:42:19.726] getGlobalsAndPackages() ... DONE
[17:42:19.726] run() for ‘Future’ ...
[17:42:19.726] - state: ‘created’
[17:42:19.726] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.726] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.727]   - Field: ‘label’
[17:42:19.727]   - Field: ‘local’
[17:42:19.727]   - Field: ‘owner’
[17:42:19.727]   - Field: ‘envir’
[17:42:19.727]   - Field: ‘packages’
[17:42:19.727]   - Field: ‘gc’
[17:42:19.727]   - Field: ‘conditions’
[17:42:19.727]   - Field: ‘expr’
[17:42:19.727]   - Field: ‘uuid’
[17:42:19.727]   - Field: ‘seed’
[17:42:19.728]   - Field: ‘version’
[17:42:19.728]   - Field: ‘result’
[17:42:19.728]   - Field: ‘asynchronous’
[17:42:19.728]   - Field: ‘calls’
[17:42:19.728]   - Field: ‘globals’
[17:42:19.728]   - Field: ‘stdout’
[17:42:19.728]   - Field: ‘earlySignal’
[17:42:19.728]   - Field: ‘lazy’
[17:42:19.728]   - Field: ‘state’
[17:42:19.728] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.728] - Launch lazy future ...
[17:42:19.729] Packages needed by the future expression (n = 0): <none>
[17:42:19.729] Packages needed by future strategies (n = 0): <none>
[17:42:19.729] {
[17:42:19.729]     {
[17:42:19.729]         {
[17:42:19.729]             ...future.startTime <- base::Sys.time()
[17:42:19.729]             {
[17:42:19.729]                 {
[17:42:19.729]                   {
[17:42:19.729]                     base::local({
[17:42:19.729]                       has_future <- base::requireNamespace("future", 
[17:42:19.729]                         quietly = TRUE)
[17:42:19.729]                       if (has_future) {
[17:42:19.729]                         ns <- base::getNamespace("future")
[17:42:19.729]                         version <- ns[[".package"]][["version"]]
[17:42:19.729]                         if (is.null(version)) 
[17:42:19.729]                           version <- utils::packageVersion("future")
[17:42:19.729]                       }
[17:42:19.729]                       else {
[17:42:19.729]                         version <- NULL
[17:42:19.729]                       }
[17:42:19.729]                       if (!has_future || version < "1.8.0") {
[17:42:19.729]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.729]                           "", base::R.version$version.string), 
[17:42:19.729]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.729]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.729]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.729]                             "release", "version")], collapse = " "), 
[17:42:19.729]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.729]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.729]                           info)
[17:42:19.729]                         info <- base::paste(info, collapse = "; ")
[17:42:19.729]                         if (!has_future) {
[17:42:19.729]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.729]                             info)
[17:42:19.729]                         }
[17:42:19.729]                         else {
[17:42:19.729]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.729]                             info, version)
[17:42:19.729]                         }
[17:42:19.729]                         base::stop(msg)
[17:42:19.729]                       }
[17:42:19.729]                     })
[17:42:19.729]                   }
[17:42:19.729]                   options(future.plan = NULL)
[17:42:19.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.729]                 }
[17:42:19.729]                 ...future.workdir <- getwd()
[17:42:19.729]             }
[17:42:19.729]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.729]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.729]         }
[17:42:19.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.729]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.729]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.729]             base::names(...future.oldOptions))
[17:42:19.729]     }
[17:42:19.729]     if (FALSE) {
[17:42:19.729]     }
[17:42:19.729]     else {
[17:42:19.729]         if (TRUE) {
[17:42:19.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.729]                 open = "w")
[17:42:19.729]         }
[17:42:19.729]         else {
[17:42:19.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.729]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.729]         }
[17:42:19.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.729]             base::sink(type = "output", split = FALSE)
[17:42:19.729]             base::close(...future.stdout)
[17:42:19.729]         }, add = TRUE)
[17:42:19.729]     }
[17:42:19.729]     ...future.frame <- base::sys.nframe()
[17:42:19.729]     ...future.conditions <- base::list()
[17:42:19.729]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.729]     if (FALSE) {
[17:42:19.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.729]     }
[17:42:19.729]     ...future.result <- base::tryCatch({
[17:42:19.729]         base::withCallingHandlers({
[17:42:19.729]             ...future.value <- base::withVisible(base::local(NULL))
[17:42:19.729]             future::FutureResult(value = ...future.value$value, 
[17:42:19.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.729]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.729]                     ...future.globalenv.names))
[17:42:19.729]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.729]         }, condition = base::local({
[17:42:19.729]             c <- base::c
[17:42:19.729]             inherits <- base::inherits
[17:42:19.729]             invokeRestart <- base::invokeRestart
[17:42:19.729]             length <- base::length
[17:42:19.729]             list <- base::list
[17:42:19.729]             seq.int <- base::seq.int
[17:42:19.729]             signalCondition <- base::signalCondition
[17:42:19.729]             sys.calls <- base::sys.calls
[17:42:19.729]             `[[` <- base::`[[`
[17:42:19.729]             `+` <- base::`+`
[17:42:19.729]             `<<-` <- base::`<<-`
[17:42:19.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.729]                   3L)]
[17:42:19.729]             }
[17:42:19.729]             function(cond) {
[17:42:19.729]                 is_error <- inherits(cond, "error")
[17:42:19.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.729]                   NULL)
[17:42:19.729]                 if (is_error) {
[17:42:19.729]                   sessionInformation <- function() {
[17:42:19.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.729]                       search = base::search(), system = base::Sys.info())
[17:42:19.729]                   }
[17:42:19.729]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.729]                     cond$call), session = sessionInformation(), 
[17:42:19.729]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.729]                   signalCondition(cond)
[17:42:19.729]                 }
[17:42:19.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.729]                 "immediateCondition"))) {
[17:42:19.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.729]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.729]                   if (TRUE && !signal) {
[17:42:19.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.729]                     {
[17:42:19.729]                       inherits <- base::inherits
[17:42:19.729]                       invokeRestart <- base::invokeRestart
[17:42:19.729]                       is.null <- base::is.null
[17:42:19.729]                       muffled <- FALSE
[17:42:19.729]                       if (inherits(cond, "message")) {
[17:42:19.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.729]                         if (muffled) 
[17:42:19.729]                           invokeRestart("muffleMessage")
[17:42:19.729]                       }
[17:42:19.729]                       else if (inherits(cond, "warning")) {
[17:42:19.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.729]                         if (muffled) 
[17:42:19.729]                           invokeRestart("muffleWarning")
[17:42:19.729]                       }
[17:42:19.729]                       else if (inherits(cond, "condition")) {
[17:42:19.729]                         if (!is.null(pattern)) {
[17:42:19.729]                           computeRestarts <- base::computeRestarts
[17:42:19.729]                           grepl <- base::grepl
[17:42:19.729]                           restarts <- computeRestarts(cond)
[17:42:19.729]                           for (restart in restarts) {
[17:42:19.729]                             name <- restart$name
[17:42:19.729]                             if (is.null(name)) 
[17:42:19.729]                               next
[17:42:19.729]                             if (!grepl(pattern, name)) 
[17:42:19.729]                               next
[17:42:19.729]                             invokeRestart(restart)
[17:42:19.729]                             muffled <- TRUE
[17:42:19.729]                             break
[17:42:19.729]                           }
[17:42:19.729]                         }
[17:42:19.729]                       }
[17:42:19.729]                       invisible(muffled)
[17:42:19.729]                     }
[17:42:19.729]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.729]                   }
[17:42:19.729]                 }
[17:42:19.729]                 else {
[17:42:19.729]                   if (TRUE) {
[17:42:19.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.729]                     {
[17:42:19.729]                       inherits <- base::inherits
[17:42:19.729]                       invokeRestart <- base::invokeRestart
[17:42:19.729]                       is.null <- base::is.null
[17:42:19.729]                       muffled <- FALSE
[17:42:19.729]                       if (inherits(cond, "message")) {
[17:42:19.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.729]                         if (muffled) 
[17:42:19.729]                           invokeRestart("muffleMessage")
[17:42:19.729]                       }
[17:42:19.729]                       else if (inherits(cond, "warning")) {
[17:42:19.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.729]                         if (muffled) 
[17:42:19.729]                           invokeRestart("muffleWarning")
[17:42:19.729]                       }
[17:42:19.729]                       else if (inherits(cond, "condition")) {
[17:42:19.729]                         if (!is.null(pattern)) {
[17:42:19.729]                           computeRestarts <- base::computeRestarts
[17:42:19.729]                           grepl <- base::grepl
[17:42:19.729]                           restarts <- computeRestarts(cond)
[17:42:19.729]                           for (restart in restarts) {
[17:42:19.729]                             name <- restart$name
[17:42:19.729]                             if (is.null(name)) 
[17:42:19.729]                               next
[17:42:19.729]                             if (!grepl(pattern, name)) 
[17:42:19.729]                               next
[17:42:19.729]                             invokeRestart(restart)
[17:42:19.729]                             muffled <- TRUE
[17:42:19.729]                             break
[17:42:19.729]                           }
[17:42:19.729]                         }
[17:42:19.729]                       }
[17:42:19.729]                       invisible(muffled)
[17:42:19.729]                     }
[17:42:19.729]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.729]                   }
[17:42:19.729]                 }
[17:42:19.729]             }
[17:42:19.729]         }))
[17:42:19.729]     }, error = function(ex) {
[17:42:19.729]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.729]                 ...future.rng), started = ...future.startTime, 
[17:42:19.729]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.729]             version = "1.8"), class = "FutureResult")
[17:42:19.729]     }, finally = {
[17:42:19.729]         if (!identical(...future.workdir, getwd())) 
[17:42:19.729]             setwd(...future.workdir)
[17:42:19.729]         {
[17:42:19.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.729]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.729]             }
[17:42:19.729]             base::options(...future.oldOptions)
[17:42:19.729]             if (.Platform$OS.type == "windows") {
[17:42:19.729]                 old_names <- names(...future.oldEnvVars)
[17:42:19.729]                 envs <- base::Sys.getenv()
[17:42:19.729]                 names <- names(envs)
[17:42:19.729]                 common <- intersect(names, old_names)
[17:42:19.729]                 added <- setdiff(names, old_names)
[17:42:19.729]                 removed <- setdiff(old_names, names)
[17:42:19.729]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.729]                   envs[common]]
[17:42:19.729]                 NAMES <- toupper(changed)
[17:42:19.729]                 args <- list()
[17:42:19.729]                 for (kk in seq_along(NAMES)) {
[17:42:19.729]                   name <- changed[[kk]]
[17:42:19.729]                   NAME <- NAMES[[kk]]
[17:42:19.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.729]                     next
[17:42:19.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.729]                 }
[17:42:19.729]                 NAMES <- toupper(added)
[17:42:19.729]                 for (kk in seq_along(NAMES)) {
[17:42:19.729]                   name <- added[[kk]]
[17:42:19.729]                   NAME <- NAMES[[kk]]
[17:42:19.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.729]                     next
[17:42:19.729]                   args[[name]] <- ""
[17:42:19.729]                 }
[17:42:19.729]                 NAMES <- toupper(removed)
[17:42:19.729]                 for (kk in seq_along(NAMES)) {
[17:42:19.729]                   name <- removed[[kk]]
[17:42:19.729]                   NAME <- NAMES[[kk]]
[17:42:19.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.729]                     next
[17:42:19.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.729]                 }
[17:42:19.729]                 if (length(args) > 0) 
[17:42:19.729]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.729]             }
[17:42:19.729]             else {
[17:42:19.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.729]             }
[17:42:19.729]             {
[17:42:19.729]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.729]                   0L) {
[17:42:19.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.729]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.729]                   base::options(opts)
[17:42:19.729]                 }
[17:42:19.729]                 {
[17:42:19.729]                   {
[17:42:19.729]                     NULL
[17:42:19.729]                     RNGkind("Mersenne-Twister")
[17:42:19.729]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.729]                       inherits = FALSE)
[17:42:19.729]                   }
[17:42:19.729]                   options(future.plan = NULL)
[17:42:19.729]                   if (is.na(NA_character_)) 
[17:42:19.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.729]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.729]                   {
[17:42:19.729]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.729]                     if (!future$lazy) 
[17:42:19.729]                       future <- run(future)
[17:42:19.729]                     invisible(future)
[17:42:19.729]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.729]                 }
[17:42:19.729]             }
[17:42:19.729]         }
[17:42:19.729]     })
[17:42:19.729]     if (TRUE) {
[17:42:19.729]         base::sink(type = "output", split = FALSE)
[17:42:19.729]         if (TRUE) {
[17:42:19.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.729]         }
[17:42:19.729]         else {
[17:42:19.729]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.729]         }
[17:42:19.729]         base::close(...future.stdout)
[17:42:19.729]         ...future.stdout <- NULL
[17:42:19.729]     }
[17:42:19.729]     ...future.result$conditions <- ...future.conditions
[17:42:19.729]     ...future.result$finished <- base::Sys.time()
[17:42:19.729]     ...future.result
[17:42:19.729] }
[17:42:19.731] plan(): Setting new future strategy stack:
[17:42:19.731] List of future strategies:
[17:42:19.731] 1. sequential:
[17:42:19.731]    - args: function (..., envir = parent.frame())
[17:42:19.731]    - tweaked: FALSE
[17:42:19.731]    - call: NULL
[17:42:19.731] plan(): nbrOfWorkers() = 1
[17:42:19.732] plan(): Setting new future strategy stack:
[17:42:19.732] List of future strategies:
[17:42:19.732] 1. sequential:
[17:42:19.732]    - args: function (..., envir = parent.frame())
[17:42:19.732]    - tweaked: FALSE
[17:42:19.732]    - call: plan(strategy)
[17:42:19.733] plan(): nbrOfWorkers() = 1
[17:42:19.733] SequentialFuture started (and completed)
[17:42:19.733] - Launch lazy future ... done
[17:42:19.733] run() for ‘SequentialFuture’ ... done
[17:42:19.734] getGlobalsAndPackages() ...
[17:42:19.734] Searching for globals...
[17:42:19.734] - globals found: [1] ‘{’
[17:42:19.734] Searching for globals ... DONE
[17:42:19.734] Resolving globals: FALSE
[17:42:19.735] 
[17:42:19.735] 
[17:42:19.735] getGlobalsAndPackages() ... DONE
[17:42:19.735] run() for ‘Future’ ...
[17:42:19.735] - state: ‘created’
[17:42:19.735] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:42:19.736] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:42:19.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:42:19.736]   - Field: ‘label’
[17:42:19.736]   - Field: ‘local’
[17:42:19.736]   - Field: ‘owner’
[17:42:19.736]   - Field: ‘envir’
[17:42:19.736]   - Field: ‘packages’
[17:42:19.736]   - Field: ‘gc’
[17:42:19.737]   - Field: ‘conditions’
[17:42:19.737]   - Field: ‘expr’
[17:42:19.737]   - Field: ‘uuid’
[17:42:19.737]   - Field: ‘seed’
[17:42:19.737]   - Field: ‘version’
[17:42:19.737]   - Field: ‘result’
[17:42:19.737]   - Field: ‘asynchronous’
[17:42:19.737]   - Field: ‘calls’
[17:42:19.737]   - Field: ‘globals’
[17:42:19.737]   - Field: ‘stdout’
[17:42:19.737]   - Field: ‘earlySignal’
[17:42:19.738]   - Field: ‘lazy’
[17:42:19.738]   - Field: ‘state’
[17:42:19.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:42:19.738] - Launch lazy future ...
[17:42:19.738] Packages needed by the future expression (n = 0): <none>
[17:42:19.738] Packages needed by future strategies (n = 0): <none>
[17:42:19.739] {
[17:42:19.739]     {
[17:42:19.739]         {
[17:42:19.739]             ...future.startTime <- base::Sys.time()
[17:42:19.739]             {
[17:42:19.739]                 {
[17:42:19.739]                   {
[17:42:19.739]                     base::local({
[17:42:19.739]                       has_future <- base::requireNamespace("future", 
[17:42:19.739]                         quietly = TRUE)
[17:42:19.739]                       if (has_future) {
[17:42:19.739]                         ns <- base::getNamespace("future")
[17:42:19.739]                         version <- ns[[".package"]][["version"]]
[17:42:19.739]                         if (is.null(version)) 
[17:42:19.739]                           version <- utils::packageVersion("future")
[17:42:19.739]                       }
[17:42:19.739]                       else {
[17:42:19.739]                         version <- NULL
[17:42:19.739]                       }
[17:42:19.739]                       if (!has_future || version < "1.8.0") {
[17:42:19.739]                         info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.739]                           "", base::R.version$version.string), 
[17:42:19.739]                           platform = base::sprintf("%s (%s-bit)", 
[17:42:19.739]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.739]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.739]                             "release", "version")], collapse = " "), 
[17:42:19.739]                           hostname = base::Sys.info()[["nodename"]])
[17:42:19.739]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.739]                           info)
[17:42:19.739]                         info <- base::paste(info, collapse = "; ")
[17:42:19.739]                         if (!has_future) {
[17:42:19.739]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.739]                             info)
[17:42:19.739]                         }
[17:42:19.739]                         else {
[17:42:19.739]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.739]                             info, version)
[17:42:19.739]                         }
[17:42:19.739]                         base::stop(msg)
[17:42:19.739]                       }
[17:42:19.739]                     })
[17:42:19.739]                   }
[17:42:19.739]                   options(future.plan = NULL)
[17:42:19.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.739]                 }
[17:42:19.739]                 ...future.workdir <- getwd()
[17:42:19.739]             }
[17:42:19.739]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.739]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.739]         }
[17:42:19.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.739]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.739]             base::names(...future.oldOptions))
[17:42:19.739]     }
[17:42:19.739]     if (FALSE) {
[17:42:19.739]     }
[17:42:19.739]     else {
[17:42:19.739]         if (TRUE) {
[17:42:19.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.739]                 open = "w")
[17:42:19.739]         }
[17:42:19.739]         else {
[17:42:19.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.739]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.739]         }
[17:42:19.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.739]             base::sink(type = "output", split = FALSE)
[17:42:19.739]             base::close(...future.stdout)
[17:42:19.739]         }, add = TRUE)
[17:42:19.739]     }
[17:42:19.739]     ...future.frame <- base::sys.nframe()
[17:42:19.739]     ...future.conditions <- base::list()
[17:42:19.739]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.739]     if (FALSE) {
[17:42:19.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.739]     }
[17:42:19.739]     ...future.result <- base::tryCatch({
[17:42:19.739]         base::withCallingHandlers({
[17:42:19.739]             ...future.value <- base::withVisible(base::local({
[17:42:19.739]                 4
[17:42:19.739]             }))
[17:42:19.739]             future::FutureResult(value = ...future.value$value, 
[17:42:19.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.739]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.739]                     ...future.globalenv.names))
[17:42:19.739]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.739]         }, condition = base::local({
[17:42:19.739]             c <- base::c
[17:42:19.739]             inherits <- base::inherits
[17:42:19.739]             invokeRestart <- base::invokeRestart
[17:42:19.739]             length <- base::length
[17:42:19.739]             list <- base::list
[17:42:19.739]             seq.int <- base::seq.int
[17:42:19.739]             signalCondition <- base::signalCondition
[17:42:19.739]             sys.calls <- base::sys.calls
[17:42:19.739]             `[[` <- base::`[[`
[17:42:19.739]             `+` <- base::`+`
[17:42:19.739]             `<<-` <- base::`<<-`
[17:42:19.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.739]                   3L)]
[17:42:19.739]             }
[17:42:19.739]             function(cond) {
[17:42:19.739]                 is_error <- inherits(cond, "error")
[17:42:19.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.739]                   NULL)
[17:42:19.739]                 if (is_error) {
[17:42:19.739]                   sessionInformation <- function() {
[17:42:19.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.739]                       search = base::search(), system = base::Sys.info())
[17:42:19.739]                   }
[17:42:19.739]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.739]                     cond$call), session = sessionInformation(), 
[17:42:19.739]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.739]                   signalCondition(cond)
[17:42:19.739]                 }
[17:42:19.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.739]                 "immediateCondition"))) {
[17:42:19.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.739]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.739]                   if (TRUE && !signal) {
[17:42:19.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.739]                     {
[17:42:19.739]                       inherits <- base::inherits
[17:42:19.739]                       invokeRestart <- base::invokeRestart
[17:42:19.739]                       is.null <- base::is.null
[17:42:19.739]                       muffled <- FALSE
[17:42:19.739]                       if (inherits(cond, "message")) {
[17:42:19.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.739]                         if (muffled) 
[17:42:19.739]                           invokeRestart("muffleMessage")
[17:42:19.739]                       }
[17:42:19.739]                       else if (inherits(cond, "warning")) {
[17:42:19.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.739]                         if (muffled) 
[17:42:19.739]                           invokeRestart("muffleWarning")
[17:42:19.739]                       }
[17:42:19.739]                       else if (inherits(cond, "condition")) {
[17:42:19.739]                         if (!is.null(pattern)) {
[17:42:19.739]                           computeRestarts <- base::computeRestarts
[17:42:19.739]                           grepl <- base::grepl
[17:42:19.739]                           restarts <- computeRestarts(cond)
[17:42:19.739]                           for (restart in restarts) {
[17:42:19.739]                             name <- restart$name
[17:42:19.739]                             if (is.null(name)) 
[17:42:19.739]                               next
[17:42:19.739]                             if (!grepl(pattern, name)) 
[17:42:19.739]                               next
[17:42:19.739]                             invokeRestart(restart)
[17:42:19.739]                             muffled <- TRUE
[17:42:19.739]                             break
[17:42:19.739]                           }
[17:42:19.739]                         }
[17:42:19.739]                       }
[17:42:19.739]                       invisible(muffled)
[17:42:19.739]                     }
[17:42:19.739]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.739]                   }
[17:42:19.739]                 }
[17:42:19.739]                 else {
[17:42:19.739]                   if (TRUE) {
[17:42:19.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.739]                     {
[17:42:19.739]                       inherits <- base::inherits
[17:42:19.739]                       invokeRestart <- base::invokeRestart
[17:42:19.739]                       is.null <- base::is.null
[17:42:19.739]                       muffled <- FALSE
[17:42:19.739]                       if (inherits(cond, "message")) {
[17:42:19.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.739]                         if (muffled) 
[17:42:19.739]                           invokeRestart("muffleMessage")
[17:42:19.739]                       }
[17:42:19.739]                       else if (inherits(cond, "warning")) {
[17:42:19.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.739]                         if (muffled) 
[17:42:19.739]                           invokeRestart("muffleWarning")
[17:42:19.739]                       }
[17:42:19.739]                       else if (inherits(cond, "condition")) {
[17:42:19.739]                         if (!is.null(pattern)) {
[17:42:19.739]                           computeRestarts <- base::computeRestarts
[17:42:19.739]                           grepl <- base::grepl
[17:42:19.739]                           restarts <- computeRestarts(cond)
[17:42:19.739]                           for (restart in restarts) {
[17:42:19.739]                             name <- restart$name
[17:42:19.739]                             if (is.null(name)) 
[17:42:19.739]                               next
[17:42:19.739]                             if (!grepl(pattern, name)) 
[17:42:19.739]                               next
[17:42:19.739]                             invokeRestart(restart)
[17:42:19.739]                             muffled <- TRUE
[17:42:19.739]                             break
[17:42:19.739]                           }
[17:42:19.739]                         }
[17:42:19.739]                       }
[17:42:19.739]                       invisible(muffled)
[17:42:19.739]                     }
[17:42:19.739]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.739]                   }
[17:42:19.739]                 }
[17:42:19.739]             }
[17:42:19.739]         }))
[17:42:19.739]     }, error = function(ex) {
[17:42:19.739]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.739]                 ...future.rng), started = ...future.startTime, 
[17:42:19.739]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.739]             version = "1.8"), class = "FutureResult")
[17:42:19.739]     }, finally = {
[17:42:19.739]         if (!identical(...future.workdir, getwd())) 
[17:42:19.739]             setwd(...future.workdir)
[17:42:19.739]         {
[17:42:19.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.739]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.739]             }
[17:42:19.739]             base::options(...future.oldOptions)
[17:42:19.739]             if (.Platform$OS.type == "windows") {
[17:42:19.739]                 old_names <- names(...future.oldEnvVars)
[17:42:19.739]                 envs <- base::Sys.getenv()
[17:42:19.739]                 names <- names(envs)
[17:42:19.739]                 common <- intersect(names, old_names)
[17:42:19.739]                 added <- setdiff(names, old_names)
[17:42:19.739]                 removed <- setdiff(old_names, names)
[17:42:19.739]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.739]                   envs[common]]
[17:42:19.739]                 NAMES <- toupper(changed)
[17:42:19.739]                 args <- list()
[17:42:19.739]                 for (kk in seq_along(NAMES)) {
[17:42:19.739]                   name <- changed[[kk]]
[17:42:19.739]                   NAME <- NAMES[[kk]]
[17:42:19.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.739]                     next
[17:42:19.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.739]                 }
[17:42:19.739]                 NAMES <- toupper(added)
[17:42:19.739]                 for (kk in seq_along(NAMES)) {
[17:42:19.739]                   name <- added[[kk]]
[17:42:19.739]                   NAME <- NAMES[[kk]]
[17:42:19.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.739]                     next
[17:42:19.739]                   args[[name]] <- ""
[17:42:19.739]                 }
[17:42:19.739]                 NAMES <- toupper(removed)
[17:42:19.739]                 for (kk in seq_along(NAMES)) {
[17:42:19.739]                   name <- removed[[kk]]
[17:42:19.739]                   NAME <- NAMES[[kk]]
[17:42:19.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.739]                     next
[17:42:19.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.739]                 }
[17:42:19.739]                 if (length(args) > 0) 
[17:42:19.739]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.739]             }
[17:42:19.739]             else {
[17:42:19.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.739]             }
[17:42:19.739]             {
[17:42:19.739]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.739]                   0L) {
[17:42:19.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.739]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.739]                   base::options(opts)
[17:42:19.739]                 }
[17:42:19.739]                 {
[17:42:19.739]                   {
[17:42:19.739]                     NULL
[17:42:19.739]                     RNGkind("Mersenne-Twister")
[17:42:19.739]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:42:19.739]                       inherits = FALSE)
[17:42:19.739]                   }
[17:42:19.739]                   options(future.plan = NULL)
[17:42:19.739]                   if (is.na(NA_character_)) 
[17:42:19.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.739]                   future::plan(list(function (..., envir = parent.frame()) 
[17:42:19.739]                   {
[17:42:19.739]                     future <- SequentialFuture(..., envir = envir)
[17:42:19.739]                     if (!future$lazy) 
[17:42:19.739]                       future <- run(future)
[17:42:19.739]                     invisible(future)
[17:42:19.739]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.739]                 }
[17:42:19.739]             }
[17:42:19.739]         }
[17:42:19.739]     })
[17:42:19.739]     if (TRUE) {
[17:42:19.739]         base::sink(type = "output", split = FALSE)
[17:42:19.739]         if (TRUE) {
[17:42:19.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.739]         }
[17:42:19.739]         else {
[17:42:19.739]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.739]         }
[17:42:19.739]         base::close(...future.stdout)
[17:42:19.739]         ...future.stdout <- NULL
[17:42:19.739]     }
[17:42:19.739]     ...future.result$conditions <- ...future.conditions
[17:42:19.739]     ...future.result$finished <- base::Sys.time()
[17:42:19.739]     ...future.result
[17:42:19.739] }
[17:42:19.741] plan(): Setting new future strategy stack:
[17:42:19.741] List of future strategies:
[17:42:19.741] 1. sequential:
[17:42:19.741]    - args: function (..., envir = parent.frame())
[17:42:19.741]    - tweaked: FALSE
[17:42:19.741]    - call: NULL
[17:42:19.742] plan(): nbrOfWorkers() = 1
[17:42:19.743] plan(): Setting new future strategy stack:
[17:42:19.743] List of future strategies:
[17:42:19.743] 1. sequential:
[17:42:19.743]    - args: function (..., envir = parent.frame())
[17:42:19.743]    - tweaked: FALSE
[17:42:19.743]    - call: plan(strategy)
[17:42:19.743] plan(): nbrOfWorkers() = 1
[17:42:19.744] SequentialFuture started (and completed)
[17:42:19.744] - Launch lazy future ... done
[17:42:19.744] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef6af60a0> 
Classes 'listenv', 'environment' <environment: 0x55bef5f639e8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:19.751] resolved() for ‘SequentialFuture’ ...
[17:42:19.751] - state: ‘finished’
[17:42:19.751] - run: TRUE
[17:42:19.751] - result: ‘FutureResult’
[17:42:19.751] resolved() for ‘SequentialFuture’ ... done
[17:42:19.751] resolved() for ‘SequentialFuture’ ...
[17:42:19.751] - state: ‘finished’
[17:42:19.751] - run: TRUE
[17:42:19.752] - result: ‘FutureResult’
[17:42:19.752] resolved() for ‘SequentialFuture’ ... done
[17:42:19.752] resolved() for ‘SequentialFuture’ ...
[17:42:19.752] - state: ‘finished’
[17:42:19.752] - run: TRUE
[17:42:19.752] - result: ‘FutureResult’
[17:42:19.752] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:19.755] resolve() on list environment ...
[17:42:19.755]  recursive: 0
[17:42:19.756]  length: 6
[17:42:19.756]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:19.756] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.757] - nx: 6
[17:42:19.757] - relay: TRUE
[17:42:19.757] - stdout: TRUE
[17:42:19.757] - signal: TRUE
[17:42:19.757] - resignal: FALSE
[17:42:19.757] - force: TRUE
[17:42:19.757] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.757] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.757]  - until=2
[17:42:19.757]  - relaying element #2
[17:42:19.757] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.758] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.758] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.758]  length: 5 (resolved future 1)
[17:42:19.758] resolved() for ‘SequentialFuture’ ...
[17:42:19.758] - state: ‘finished’
[17:42:19.758] - run: TRUE
[17:42:19.758] - result: ‘FutureResult’
[17:42:19.758] resolved() for ‘SequentialFuture’ ... done
[17:42:19.758] Future #2
[17:42:19.758] signalConditionsASAP(SequentialFuture, pos=2) ...
[17:42:19.759] - nx: 6
[17:42:19.759] - relay: TRUE
[17:42:19.759] - stdout: TRUE
[17:42:19.759] - signal: TRUE
[17:42:19.759] - resignal: FALSE
[17:42:19.759] - force: TRUE
[17:42:19.759] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.759] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.759]  - until=2
[17:42:19.759]  - relaying element #2
[17:42:19.760] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.760] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.760] signalConditionsASAP(SequentialFuture, pos=2) ... done
[17:42:19.760]  length: 4 (resolved future 2)
[17:42:19.760] resolved() for ‘SequentialFuture’ ...
[17:42:19.760] - state: ‘finished’
[17:42:19.760] - run: TRUE
[17:42:19.760] - result: ‘FutureResult’
[17:42:19.760] resolved() for ‘SequentialFuture’ ... done
[17:42:19.760] Future #3
[17:42:19.761] signalConditionsASAP(SequentialFuture, pos=3) ...
[17:42:19.761] - nx: 6
[17:42:19.761] - relay: TRUE
[17:42:19.761] - stdout: TRUE
[17:42:19.761] - signal: TRUE
[17:42:19.761] - resignal: FALSE
[17:42:19.761] - force: TRUE
[17:42:19.761] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.761] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.761]  - until=3
[17:42:19.762]  - relaying element #3
[17:42:19.762] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.762] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.762] signalConditionsASAP(SequentialFuture, pos=3) ... done
[17:42:19.762]  length: 3 (resolved future 3)
[17:42:19.762] resolved() for ‘SequentialFuture’ ...
[17:42:19.762] - state: ‘finished’
[17:42:19.762] - run: TRUE
[17:42:19.762] - result: ‘FutureResult’
[17:42:19.762] resolved() for ‘SequentialFuture’ ... done
[17:42:19.763] Future #4
[17:42:19.763] signalConditionsASAP(SequentialFuture, pos=4) ...
[17:42:19.763] - nx: 6
[17:42:19.763] - relay: TRUE
[17:42:19.763] - stdout: TRUE
[17:42:19.763] - signal: TRUE
[17:42:19.763] - resignal: FALSE
[17:42:19.763] - force: TRUE
[17:42:19.763] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.763] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.764]  - until=4
[17:42:19.764]  - relaying element #4
[17:42:19.764] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.764] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.764] signalConditionsASAP(SequentialFuture, pos=4) ... done
[17:42:19.764]  length: 2 (resolved future 4)
[17:42:19.764] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.764] - nx: 6
[17:42:19.764] - relay: TRUE
[17:42:19.764] - stdout: TRUE
[17:42:19.765] - signal: TRUE
[17:42:19.765] - resignal: FALSE
[17:42:19.765] - force: TRUE
[17:42:19.765] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.765] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.765]  - until=6
[17:42:19.765]  - relaying element #6
[17:42:19.765] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.765] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.765] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.765]  length: 1 (resolved future 5)
[17:42:19.765] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.766] - nx: 6
[17:42:19.766] - relay: TRUE
[17:42:19.766] - stdout: TRUE
[17:42:19.766] - signal: TRUE
[17:42:19.766] - resignal: FALSE
[17:42:19.766] - force: TRUE
[17:42:19.766] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.766] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.766]  - until=6
[17:42:19.766] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.766] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.767] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.767]  length: 0 (resolved future 6)
[17:42:19.767] Relaying remaining futures
[17:42:19.767] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.767] - nx: 6
[17:42:19.767] - relay: TRUE
[17:42:19.767] - stdout: TRUE
[17:42:19.767] - signal: TRUE
[17:42:19.767] - resignal: FALSE
[17:42:19.767] - force: TRUE
[17:42:19.767] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.768] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:19.768] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.768] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.768] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.768] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef791df20> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[17:42:19.773] plan(): Setting new future strategy stack:
[17:42:19.773] List of future strategies:
[17:42:19.773] 1. multicore:
[17:42:19.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.773]    - tweaked: FALSE
[17:42:19.773]    - call: plan(strategy)
[17:42:19.778] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:42:19.778] getGlobalsAndPackages() ...
[17:42:19.778] Searching for globals...
[17:42:19.778] 
[17:42:19.778] Searching for globals ... DONE
[17:42:19.779] - globals: [0] <none>
[17:42:19.779] getGlobalsAndPackages() ... DONE
[17:42:19.779] run() for ‘Future’ ...
[17:42:19.779] - state: ‘created’
[17:42:19.779] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:19.783] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:19.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:19.783]   - Field: ‘label’
[17:42:19.783]   - Field: ‘local’
[17:42:19.783]   - Field: ‘owner’
[17:42:19.783]   - Field: ‘envir’
[17:42:19.784]   - Field: ‘workers’
[17:42:19.784]   - Field: ‘packages’
[17:42:19.784]   - Field: ‘gc’
[17:42:19.784]   - Field: ‘job’
[17:42:19.784]   - Field: ‘conditions’
[17:42:19.784]   - Field: ‘expr’
[17:42:19.784]   - Field: ‘uuid’
[17:42:19.784]   - Field: ‘seed’
[17:42:19.784]   - Field: ‘version’
[17:42:19.784]   - Field: ‘result’
[17:42:19.785]   - Field: ‘asynchronous’
[17:42:19.785]   - Field: ‘calls’
[17:42:19.785]   - Field: ‘globals’
[17:42:19.785]   - Field: ‘stdout’
[17:42:19.785]   - Field: ‘earlySignal’
[17:42:19.785]   - Field: ‘lazy’
[17:42:19.785]   - Field: ‘state’
[17:42:19.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:19.785] - Launch lazy future ...
[17:42:19.786] Packages needed by the future expression (n = 0): <none>
[17:42:19.786] Packages needed by future strategies (n = 0): <none>
[17:42:19.787] {
[17:42:19.787]     {
[17:42:19.787]         {
[17:42:19.787]             ...future.startTime <- base::Sys.time()
[17:42:19.787]             {
[17:42:19.787]                 {
[17:42:19.787]                   {
[17:42:19.787]                     {
[17:42:19.787]                       base::local({
[17:42:19.787]                         has_future <- base::requireNamespace("future", 
[17:42:19.787]                           quietly = TRUE)
[17:42:19.787]                         if (has_future) {
[17:42:19.787]                           ns <- base::getNamespace("future")
[17:42:19.787]                           version <- ns[[".package"]][["version"]]
[17:42:19.787]                           if (is.null(version)) 
[17:42:19.787]                             version <- utils::packageVersion("future")
[17:42:19.787]                         }
[17:42:19.787]                         else {
[17:42:19.787]                           version <- NULL
[17:42:19.787]                         }
[17:42:19.787]                         if (!has_future || version < "1.8.0") {
[17:42:19.787]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.787]                             "", base::R.version$version.string), 
[17:42:19.787]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:19.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.787]                               "release", "version")], collapse = " "), 
[17:42:19.787]                             hostname = base::Sys.info()[["nodename"]])
[17:42:19.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.787]                             info)
[17:42:19.787]                           info <- base::paste(info, collapse = "; ")
[17:42:19.787]                           if (!has_future) {
[17:42:19.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.787]                               info)
[17:42:19.787]                           }
[17:42:19.787]                           else {
[17:42:19.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.787]                               info, version)
[17:42:19.787]                           }
[17:42:19.787]                           base::stop(msg)
[17:42:19.787]                         }
[17:42:19.787]                       })
[17:42:19.787]                     }
[17:42:19.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:19.787]                     base::options(mc.cores = 1L)
[17:42:19.787]                   }
[17:42:19.787]                   options(future.plan = NULL)
[17:42:19.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.787]                 }
[17:42:19.787]                 ...future.workdir <- getwd()
[17:42:19.787]             }
[17:42:19.787]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.787]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.787]         }
[17:42:19.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.787]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.787]             base::names(...future.oldOptions))
[17:42:19.787]     }
[17:42:19.787]     if (FALSE) {
[17:42:19.787]     }
[17:42:19.787]     else {
[17:42:19.787]         if (TRUE) {
[17:42:19.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.787]                 open = "w")
[17:42:19.787]         }
[17:42:19.787]         else {
[17:42:19.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.787]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.787]         }
[17:42:19.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.787]             base::sink(type = "output", split = FALSE)
[17:42:19.787]             base::close(...future.stdout)
[17:42:19.787]         }, add = TRUE)
[17:42:19.787]     }
[17:42:19.787]     ...future.frame <- base::sys.nframe()
[17:42:19.787]     ...future.conditions <- base::list()
[17:42:19.787]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.787]     if (FALSE) {
[17:42:19.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.787]     }
[17:42:19.787]     ...future.result <- base::tryCatch({
[17:42:19.787]         base::withCallingHandlers({
[17:42:19.787]             ...future.value <- base::withVisible(base::local({
[17:42:19.787]                 withCallingHandlers({
[17:42:19.787]                   2
[17:42:19.787]                 }, immediateCondition = function(cond) {
[17:42:19.787]                   save_rds <- function (object, pathname, ...) 
[17:42:19.787]                   {
[17:42:19.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:19.787]                     if (file_test("-f", pathname_tmp)) {
[17:42:19.787]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:19.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.787]                         fi_tmp[["mtime"]])
[17:42:19.787]                     }
[17:42:19.787]                     tryCatch({
[17:42:19.787]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:19.787]                     }, error = function(ex) {
[17:42:19.787]                       msg <- conditionMessage(ex)
[17:42:19.787]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:19.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.787]                         fi_tmp[["mtime"]], msg)
[17:42:19.787]                       ex$message <- msg
[17:42:19.787]                       stop(ex)
[17:42:19.787]                     })
[17:42:19.787]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:19.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:19.787]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:19.787]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.787]                       fi <- file.info(pathname)
[17:42:19.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:19.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:19.787]                         fi[["size"]], fi[["mtime"]])
[17:42:19.787]                       stop(msg)
[17:42:19.787]                     }
[17:42:19.787]                     invisible(pathname)
[17:42:19.787]                   }
[17:42:19.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:19.787]                     rootPath = tempdir()) 
[17:42:19.787]                   {
[17:42:19.787]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:19.787]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:19.787]                       tmpdir = path, fileext = ".rds")
[17:42:19.787]                     save_rds(obj, file)
[17:42:19.787]                   }
[17:42:19.787]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:19.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.787]                   {
[17:42:19.787]                     inherits <- base::inherits
[17:42:19.787]                     invokeRestart <- base::invokeRestart
[17:42:19.787]                     is.null <- base::is.null
[17:42:19.787]                     muffled <- FALSE
[17:42:19.787]                     if (inherits(cond, "message")) {
[17:42:19.787]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:19.787]                       if (muffled) 
[17:42:19.787]                         invokeRestart("muffleMessage")
[17:42:19.787]                     }
[17:42:19.787]                     else if (inherits(cond, "warning")) {
[17:42:19.787]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:19.787]                       if (muffled) 
[17:42:19.787]                         invokeRestart("muffleWarning")
[17:42:19.787]                     }
[17:42:19.787]                     else if (inherits(cond, "condition")) {
[17:42:19.787]                       if (!is.null(pattern)) {
[17:42:19.787]                         computeRestarts <- base::computeRestarts
[17:42:19.787]                         grepl <- base::grepl
[17:42:19.787]                         restarts <- computeRestarts(cond)
[17:42:19.787]                         for (restart in restarts) {
[17:42:19.787]                           name <- restart$name
[17:42:19.787]                           if (is.null(name)) 
[17:42:19.787]                             next
[17:42:19.787]                           if (!grepl(pattern, name)) 
[17:42:19.787]                             next
[17:42:19.787]                           invokeRestart(restart)
[17:42:19.787]                           muffled <- TRUE
[17:42:19.787]                           break
[17:42:19.787]                         }
[17:42:19.787]                       }
[17:42:19.787]                     }
[17:42:19.787]                     invisible(muffled)
[17:42:19.787]                   }
[17:42:19.787]                   muffleCondition(cond)
[17:42:19.787]                 })
[17:42:19.787]             }))
[17:42:19.787]             future::FutureResult(value = ...future.value$value, 
[17:42:19.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.787]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.787]                     ...future.globalenv.names))
[17:42:19.787]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.787]         }, condition = base::local({
[17:42:19.787]             c <- base::c
[17:42:19.787]             inherits <- base::inherits
[17:42:19.787]             invokeRestart <- base::invokeRestart
[17:42:19.787]             length <- base::length
[17:42:19.787]             list <- base::list
[17:42:19.787]             seq.int <- base::seq.int
[17:42:19.787]             signalCondition <- base::signalCondition
[17:42:19.787]             sys.calls <- base::sys.calls
[17:42:19.787]             `[[` <- base::`[[`
[17:42:19.787]             `+` <- base::`+`
[17:42:19.787]             `<<-` <- base::`<<-`
[17:42:19.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.787]                   3L)]
[17:42:19.787]             }
[17:42:19.787]             function(cond) {
[17:42:19.787]                 is_error <- inherits(cond, "error")
[17:42:19.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.787]                   NULL)
[17:42:19.787]                 if (is_error) {
[17:42:19.787]                   sessionInformation <- function() {
[17:42:19.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.787]                       search = base::search(), system = base::Sys.info())
[17:42:19.787]                   }
[17:42:19.787]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.787]                     cond$call), session = sessionInformation(), 
[17:42:19.787]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.787]                   signalCondition(cond)
[17:42:19.787]                 }
[17:42:19.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.787]                 "immediateCondition"))) {
[17:42:19.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.787]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.787]                   if (TRUE && !signal) {
[17:42:19.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.787]                     {
[17:42:19.787]                       inherits <- base::inherits
[17:42:19.787]                       invokeRestart <- base::invokeRestart
[17:42:19.787]                       is.null <- base::is.null
[17:42:19.787]                       muffled <- FALSE
[17:42:19.787]                       if (inherits(cond, "message")) {
[17:42:19.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.787]                         if (muffled) 
[17:42:19.787]                           invokeRestart("muffleMessage")
[17:42:19.787]                       }
[17:42:19.787]                       else if (inherits(cond, "warning")) {
[17:42:19.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.787]                         if (muffled) 
[17:42:19.787]                           invokeRestart("muffleWarning")
[17:42:19.787]                       }
[17:42:19.787]                       else if (inherits(cond, "condition")) {
[17:42:19.787]                         if (!is.null(pattern)) {
[17:42:19.787]                           computeRestarts <- base::computeRestarts
[17:42:19.787]                           grepl <- base::grepl
[17:42:19.787]                           restarts <- computeRestarts(cond)
[17:42:19.787]                           for (restart in restarts) {
[17:42:19.787]                             name <- restart$name
[17:42:19.787]                             if (is.null(name)) 
[17:42:19.787]                               next
[17:42:19.787]                             if (!grepl(pattern, name)) 
[17:42:19.787]                               next
[17:42:19.787]                             invokeRestart(restart)
[17:42:19.787]                             muffled <- TRUE
[17:42:19.787]                             break
[17:42:19.787]                           }
[17:42:19.787]                         }
[17:42:19.787]                       }
[17:42:19.787]                       invisible(muffled)
[17:42:19.787]                     }
[17:42:19.787]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.787]                   }
[17:42:19.787]                 }
[17:42:19.787]                 else {
[17:42:19.787]                   if (TRUE) {
[17:42:19.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.787]                     {
[17:42:19.787]                       inherits <- base::inherits
[17:42:19.787]                       invokeRestart <- base::invokeRestart
[17:42:19.787]                       is.null <- base::is.null
[17:42:19.787]                       muffled <- FALSE
[17:42:19.787]                       if (inherits(cond, "message")) {
[17:42:19.787]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.787]                         if (muffled) 
[17:42:19.787]                           invokeRestart("muffleMessage")
[17:42:19.787]                       }
[17:42:19.787]                       else if (inherits(cond, "warning")) {
[17:42:19.787]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.787]                         if (muffled) 
[17:42:19.787]                           invokeRestart("muffleWarning")
[17:42:19.787]                       }
[17:42:19.787]                       else if (inherits(cond, "condition")) {
[17:42:19.787]                         if (!is.null(pattern)) {
[17:42:19.787]                           computeRestarts <- base::computeRestarts
[17:42:19.787]                           grepl <- base::grepl
[17:42:19.787]                           restarts <- computeRestarts(cond)
[17:42:19.787]                           for (restart in restarts) {
[17:42:19.787]                             name <- restart$name
[17:42:19.787]                             if (is.null(name)) 
[17:42:19.787]                               next
[17:42:19.787]                             if (!grepl(pattern, name)) 
[17:42:19.787]                               next
[17:42:19.787]                             invokeRestart(restart)
[17:42:19.787]                             muffled <- TRUE
[17:42:19.787]                             break
[17:42:19.787]                           }
[17:42:19.787]                         }
[17:42:19.787]                       }
[17:42:19.787]                       invisible(muffled)
[17:42:19.787]                     }
[17:42:19.787]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.787]                   }
[17:42:19.787]                 }
[17:42:19.787]             }
[17:42:19.787]         }))
[17:42:19.787]     }, error = function(ex) {
[17:42:19.787]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.787]                 ...future.rng), started = ...future.startTime, 
[17:42:19.787]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.787]             version = "1.8"), class = "FutureResult")
[17:42:19.787]     }, finally = {
[17:42:19.787]         if (!identical(...future.workdir, getwd())) 
[17:42:19.787]             setwd(...future.workdir)
[17:42:19.787]         {
[17:42:19.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.787]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.787]             }
[17:42:19.787]             base::options(...future.oldOptions)
[17:42:19.787]             if (.Platform$OS.type == "windows") {
[17:42:19.787]                 old_names <- names(...future.oldEnvVars)
[17:42:19.787]                 envs <- base::Sys.getenv()
[17:42:19.787]                 names <- names(envs)
[17:42:19.787]                 common <- intersect(names, old_names)
[17:42:19.787]                 added <- setdiff(names, old_names)
[17:42:19.787]                 removed <- setdiff(old_names, names)
[17:42:19.787]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.787]                   envs[common]]
[17:42:19.787]                 NAMES <- toupper(changed)
[17:42:19.787]                 args <- list()
[17:42:19.787]                 for (kk in seq_along(NAMES)) {
[17:42:19.787]                   name <- changed[[kk]]
[17:42:19.787]                   NAME <- NAMES[[kk]]
[17:42:19.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.787]                     next
[17:42:19.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.787]                 }
[17:42:19.787]                 NAMES <- toupper(added)
[17:42:19.787]                 for (kk in seq_along(NAMES)) {
[17:42:19.787]                   name <- added[[kk]]
[17:42:19.787]                   NAME <- NAMES[[kk]]
[17:42:19.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.787]                     next
[17:42:19.787]                   args[[name]] <- ""
[17:42:19.787]                 }
[17:42:19.787]                 NAMES <- toupper(removed)
[17:42:19.787]                 for (kk in seq_along(NAMES)) {
[17:42:19.787]                   name <- removed[[kk]]
[17:42:19.787]                   NAME <- NAMES[[kk]]
[17:42:19.787]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.787]                     next
[17:42:19.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.787]                 }
[17:42:19.787]                 if (length(args) > 0) 
[17:42:19.787]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.787]             }
[17:42:19.787]             else {
[17:42:19.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.787]             }
[17:42:19.787]             {
[17:42:19.787]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.787]                   0L) {
[17:42:19.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.787]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.787]                   base::options(opts)
[17:42:19.787]                 }
[17:42:19.787]                 {
[17:42:19.787]                   {
[17:42:19.787]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:19.787]                     NULL
[17:42:19.787]                   }
[17:42:19.787]                   options(future.plan = NULL)
[17:42:19.787]                   if (is.na(NA_character_)) 
[17:42:19.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:19.787]                     envir = parent.frame()) 
[17:42:19.787]                   {
[17:42:19.787]                     default_workers <- missing(workers)
[17:42:19.787]                     if (is.function(workers)) 
[17:42:19.787]                       workers <- workers()
[17:42:19.787]                     workers <- structure(as.integer(workers), 
[17:42:19.787]                       class = class(workers))
[17:42:19.787]                     stop_if_not(is.finite(workers), workers >= 
[17:42:19.787]                       1L)
[17:42:19.787]                     if ((workers == 1L && !inherits(workers, 
[17:42:19.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:19.787]                       if (default_workers) 
[17:42:19.787]                         supportsMulticore(warn = TRUE)
[17:42:19.787]                       return(sequential(..., envir = envir))
[17:42:19.787]                     }
[17:42:19.787]                     oopts <- options(mc.cores = workers)
[17:42:19.787]                     on.exit(options(oopts))
[17:42:19.787]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:19.787]                       envir = envir)
[17:42:19.787]                     if (!future$lazy) 
[17:42:19.787]                       future <- run(future)
[17:42:19.787]                     invisible(future)
[17:42:19.787]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.787]                 }
[17:42:19.787]             }
[17:42:19.787]         }
[17:42:19.787]     })
[17:42:19.787]     if (TRUE) {
[17:42:19.787]         base::sink(type = "output", split = FALSE)
[17:42:19.787]         if (TRUE) {
[17:42:19.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.787]         }
[17:42:19.787]         else {
[17:42:19.787]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.787]         }
[17:42:19.787]         base::close(...future.stdout)
[17:42:19.787]         ...future.stdout <- NULL
[17:42:19.787]     }
[17:42:19.787]     ...future.result$conditions <- ...future.conditions
[17:42:19.787]     ...future.result$finished <- base::Sys.time()
[17:42:19.787]     ...future.result
[17:42:19.787] }
[17:42:19.789] requestCore(): workers = 2
[17:42:19.792] MulticoreFuture started
[17:42:19.793] - Launch lazy future ... done
[17:42:19.793] plan(): Setting new future strategy stack:
[17:42:19.793] run() for ‘MulticoreFuture’ ... done
[17:42:19.794] getGlobalsAndPackages() ...
[17:42:19.794] Searching for globals...
[17:42:19.793] List of future strategies:
[17:42:19.793] 1. sequential:
[17:42:19.793]    - args: function (..., envir = parent.frame())
[17:42:19.793]    - tweaked: FALSE
[17:42:19.793]    - call: NULL
[17:42:19.794] plan(): nbrOfWorkers() = 1
[17:42:19.795] 
[17:42:19.795] Searching for globals ... DONE
[17:42:19.795] - globals: [0] <none>
[17:42:19.796] getGlobalsAndPackages() ... DONE
[17:42:19.796] plan(): Setting new future strategy stack:
[17:42:19.796] run() for ‘Future’ ...
[17:42:19.796] - state: ‘created’
[17:42:19.796] List of future strategies:
[17:42:19.796] 1. multicore:
[17:42:19.796]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.796]    - tweaked: FALSE
[17:42:19.796]    - call: plan(strategy)
[17:42:19.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:19.801] plan(): nbrOfWorkers() = 2
[17:42:19.801] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:19.802] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:19.802]   - Field: ‘label’
[17:42:19.802]   - Field: ‘local’
[17:42:19.802]   - Field: ‘owner’
[17:42:19.802]   - Field: ‘envir’
[17:42:19.803]   - Field: ‘workers’
[17:42:19.803]   - Field: ‘packages’
[17:42:19.803]   - Field: ‘gc’
[17:42:19.803]   - Field: ‘job’
[17:42:19.804]   - Field: ‘conditions’
[17:42:19.804]   - Field: ‘expr’
[17:42:19.804]   - Field: ‘uuid’
[17:42:19.804]   - Field: ‘seed’
[17:42:19.804]   - Field: ‘version’
[17:42:19.805]   - Field: ‘result’
[17:42:19.805]   - Field: ‘asynchronous’
[17:42:19.805]   - Field: ‘calls’
[17:42:19.805]   - Field: ‘globals’
[17:42:19.805]   - Field: ‘stdout’
[17:42:19.805]   - Field: ‘earlySignal’
[17:42:19.806]   - Field: ‘lazy’
[17:42:19.806]   - Field: ‘state’
[17:42:19.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:19.806] - Launch lazy future ...
[17:42:19.807] Packages needed by the future expression (n = 0): <none>
[17:42:19.807] Packages needed by future strategies (n = 0): <none>
[17:42:19.808] {
[17:42:19.808]     {
[17:42:19.808]         {
[17:42:19.808]             ...future.startTime <- base::Sys.time()
[17:42:19.808]             {
[17:42:19.808]                 {
[17:42:19.808]                   {
[17:42:19.808]                     {
[17:42:19.808]                       base::local({
[17:42:19.808]                         has_future <- base::requireNamespace("future", 
[17:42:19.808]                           quietly = TRUE)
[17:42:19.808]                         if (has_future) {
[17:42:19.808]                           ns <- base::getNamespace("future")
[17:42:19.808]                           version <- ns[[".package"]][["version"]]
[17:42:19.808]                           if (is.null(version)) 
[17:42:19.808]                             version <- utils::packageVersion("future")
[17:42:19.808]                         }
[17:42:19.808]                         else {
[17:42:19.808]                           version <- NULL
[17:42:19.808]                         }
[17:42:19.808]                         if (!has_future || version < "1.8.0") {
[17:42:19.808]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.808]                             "", base::R.version$version.string), 
[17:42:19.808]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:19.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.808]                               "release", "version")], collapse = " "), 
[17:42:19.808]                             hostname = base::Sys.info()[["nodename"]])
[17:42:19.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.808]                             info)
[17:42:19.808]                           info <- base::paste(info, collapse = "; ")
[17:42:19.808]                           if (!has_future) {
[17:42:19.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.808]                               info)
[17:42:19.808]                           }
[17:42:19.808]                           else {
[17:42:19.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.808]                               info, version)
[17:42:19.808]                           }
[17:42:19.808]                           base::stop(msg)
[17:42:19.808]                         }
[17:42:19.808]                       })
[17:42:19.808]                     }
[17:42:19.808]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:19.808]                     base::options(mc.cores = 1L)
[17:42:19.808]                   }
[17:42:19.808]                   options(future.plan = NULL)
[17:42:19.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.808]                 }
[17:42:19.808]                 ...future.workdir <- getwd()
[17:42:19.808]             }
[17:42:19.808]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.808]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.808]         }
[17:42:19.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.808]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.808]             base::names(...future.oldOptions))
[17:42:19.808]     }
[17:42:19.808]     if (FALSE) {
[17:42:19.808]     }
[17:42:19.808]     else {
[17:42:19.808]         if (TRUE) {
[17:42:19.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.808]                 open = "w")
[17:42:19.808]         }
[17:42:19.808]         else {
[17:42:19.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.808]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.808]         }
[17:42:19.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.808]             base::sink(type = "output", split = FALSE)
[17:42:19.808]             base::close(...future.stdout)
[17:42:19.808]         }, add = TRUE)
[17:42:19.808]     }
[17:42:19.808]     ...future.frame <- base::sys.nframe()
[17:42:19.808]     ...future.conditions <- base::list()
[17:42:19.808]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.808]     if (FALSE) {
[17:42:19.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.808]     }
[17:42:19.808]     ...future.result <- base::tryCatch({
[17:42:19.808]         base::withCallingHandlers({
[17:42:19.808]             ...future.value <- base::withVisible(base::local({
[17:42:19.808]                 withCallingHandlers({
[17:42:19.808]                   NULL
[17:42:19.808]                 }, immediateCondition = function(cond) {
[17:42:19.808]                   save_rds <- function (object, pathname, ...) 
[17:42:19.808]                   {
[17:42:19.808]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:19.808]                     if (file_test("-f", pathname_tmp)) {
[17:42:19.808]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.808]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:19.808]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.808]                         fi_tmp[["mtime"]])
[17:42:19.808]                     }
[17:42:19.808]                     tryCatch({
[17:42:19.808]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:19.808]                     }, error = function(ex) {
[17:42:19.808]                       msg <- conditionMessage(ex)
[17:42:19.808]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.808]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:19.808]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.808]                         fi_tmp[["mtime"]], msg)
[17:42:19.808]                       ex$message <- msg
[17:42:19.808]                       stop(ex)
[17:42:19.808]                     })
[17:42:19.808]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:19.808]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:19.808]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:19.808]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.808]                       fi <- file.info(pathname)
[17:42:19.808]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:19.808]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.808]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:19.808]                         fi[["size"]], fi[["mtime"]])
[17:42:19.808]                       stop(msg)
[17:42:19.808]                     }
[17:42:19.808]                     invisible(pathname)
[17:42:19.808]                   }
[17:42:19.808]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:19.808]                     rootPath = tempdir()) 
[17:42:19.808]                   {
[17:42:19.808]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:19.808]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:19.808]                       tmpdir = path, fileext = ".rds")
[17:42:19.808]                     save_rds(obj, file)
[17:42:19.808]                   }
[17:42:19.808]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:19.808]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.808]                   {
[17:42:19.808]                     inherits <- base::inherits
[17:42:19.808]                     invokeRestart <- base::invokeRestart
[17:42:19.808]                     is.null <- base::is.null
[17:42:19.808]                     muffled <- FALSE
[17:42:19.808]                     if (inherits(cond, "message")) {
[17:42:19.808]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:19.808]                       if (muffled) 
[17:42:19.808]                         invokeRestart("muffleMessage")
[17:42:19.808]                     }
[17:42:19.808]                     else if (inherits(cond, "warning")) {
[17:42:19.808]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:19.808]                       if (muffled) 
[17:42:19.808]                         invokeRestart("muffleWarning")
[17:42:19.808]                     }
[17:42:19.808]                     else if (inherits(cond, "condition")) {
[17:42:19.808]                       if (!is.null(pattern)) {
[17:42:19.808]                         computeRestarts <- base::computeRestarts
[17:42:19.808]                         grepl <- base::grepl
[17:42:19.808]                         restarts <- computeRestarts(cond)
[17:42:19.808]                         for (restart in restarts) {
[17:42:19.808]                           name <- restart$name
[17:42:19.808]                           if (is.null(name)) 
[17:42:19.808]                             next
[17:42:19.808]                           if (!grepl(pattern, name)) 
[17:42:19.808]                             next
[17:42:19.808]                           invokeRestart(restart)
[17:42:19.808]                           muffled <- TRUE
[17:42:19.808]                           break
[17:42:19.808]                         }
[17:42:19.808]                       }
[17:42:19.808]                     }
[17:42:19.808]                     invisible(muffled)
[17:42:19.808]                   }
[17:42:19.808]                   muffleCondition(cond)
[17:42:19.808]                 })
[17:42:19.808]             }))
[17:42:19.808]             future::FutureResult(value = ...future.value$value, 
[17:42:19.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.808]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.808]                     ...future.globalenv.names))
[17:42:19.808]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.808]         }, condition = base::local({
[17:42:19.808]             c <- base::c
[17:42:19.808]             inherits <- base::inherits
[17:42:19.808]             invokeRestart <- base::invokeRestart
[17:42:19.808]             length <- base::length
[17:42:19.808]             list <- base::list
[17:42:19.808]             seq.int <- base::seq.int
[17:42:19.808]             signalCondition <- base::signalCondition
[17:42:19.808]             sys.calls <- base::sys.calls
[17:42:19.808]             `[[` <- base::`[[`
[17:42:19.808]             `+` <- base::`+`
[17:42:19.808]             `<<-` <- base::`<<-`
[17:42:19.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.808]                   3L)]
[17:42:19.808]             }
[17:42:19.808]             function(cond) {
[17:42:19.808]                 is_error <- inherits(cond, "error")
[17:42:19.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.808]                   NULL)
[17:42:19.808]                 if (is_error) {
[17:42:19.808]                   sessionInformation <- function() {
[17:42:19.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.808]                       search = base::search(), system = base::Sys.info())
[17:42:19.808]                   }
[17:42:19.808]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.808]                     cond$call), session = sessionInformation(), 
[17:42:19.808]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.808]                   signalCondition(cond)
[17:42:19.808]                 }
[17:42:19.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.808]                 "immediateCondition"))) {
[17:42:19.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.808]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.808]                   if (TRUE && !signal) {
[17:42:19.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.808]                     {
[17:42:19.808]                       inherits <- base::inherits
[17:42:19.808]                       invokeRestart <- base::invokeRestart
[17:42:19.808]                       is.null <- base::is.null
[17:42:19.808]                       muffled <- FALSE
[17:42:19.808]                       if (inherits(cond, "message")) {
[17:42:19.808]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.808]                         if (muffled) 
[17:42:19.808]                           invokeRestart("muffleMessage")
[17:42:19.808]                       }
[17:42:19.808]                       else if (inherits(cond, "warning")) {
[17:42:19.808]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.808]                         if (muffled) 
[17:42:19.808]                           invokeRestart("muffleWarning")
[17:42:19.808]                       }
[17:42:19.808]                       else if (inherits(cond, "condition")) {
[17:42:19.808]                         if (!is.null(pattern)) {
[17:42:19.808]                           computeRestarts <- base::computeRestarts
[17:42:19.808]                           grepl <- base::grepl
[17:42:19.808]                           restarts <- computeRestarts(cond)
[17:42:19.808]                           for (restart in restarts) {
[17:42:19.808]                             name <- restart$name
[17:42:19.808]                             if (is.null(name)) 
[17:42:19.808]                               next
[17:42:19.808]                             if (!grepl(pattern, name)) 
[17:42:19.808]                               next
[17:42:19.808]                             invokeRestart(restart)
[17:42:19.808]                             muffled <- TRUE
[17:42:19.808]                             break
[17:42:19.808]                           }
[17:42:19.808]                         }
[17:42:19.808]                       }
[17:42:19.808]                       invisible(muffled)
[17:42:19.808]                     }
[17:42:19.808]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.808]                   }
[17:42:19.808]                 }
[17:42:19.808]                 else {
[17:42:19.808]                   if (TRUE) {
[17:42:19.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.808]                     {
[17:42:19.808]                       inherits <- base::inherits
[17:42:19.808]                       invokeRestart <- base::invokeRestart
[17:42:19.808]                       is.null <- base::is.null
[17:42:19.808]                       muffled <- FALSE
[17:42:19.808]                       if (inherits(cond, "message")) {
[17:42:19.808]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.808]                         if (muffled) 
[17:42:19.808]                           invokeRestart("muffleMessage")
[17:42:19.808]                       }
[17:42:19.808]                       else if (inherits(cond, "warning")) {
[17:42:19.808]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.808]                         if (muffled) 
[17:42:19.808]                           invokeRestart("muffleWarning")
[17:42:19.808]                       }
[17:42:19.808]                       else if (inherits(cond, "condition")) {
[17:42:19.808]                         if (!is.null(pattern)) {
[17:42:19.808]                           computeRestarts <- base::computeRestarts
[17:42:19.808]                           grepl <- base::grepl
[17:42:19.808]                           restarts <- computeRestarts(cond)
[17:42:19.808]                           for (restart in restarts) {
[17:42:19.808]                             name <- restart$name
[17:42:19.808]                             if (is.null(name)) 
[17:42:19.808]                               next
[17:42:19.808]                             if (!grepl(pattern, name)) 
[17:42:19.808]                               next
[17:42:19.808]                             invokeRestart(restart)
[17:42:19.808]                             muffled <- TRUE
[17:42:19.808]                             break
[17:42:19.808]                           }
[17:42:19.808]                         }
[17:42:19.808]                       }
[17:42:19.808]                       invisible(muffled)
[17:42:19.808]                     }
[17:42:19.808]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.808]                   }
[17:42:19.808]                 }
[17:42:19.808]             }
[17:42:19.808]         }))
[17:42:19.808]     }, error = function(ex) {
[17:42:19.808]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.808]                 ...future.rng), started = ...future.startTime, 
[17:42:19.808]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.808]             version = "1.8"), class = "FutureResult")
[17:42:19.808]     }, finally = {
[17:42:19.808]         if (!identical(...future.workdir, getwd())) 
[17:42:19.808]             setwd(...future.workdir)
[17:42:19.808]         {
[17:42:19.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.808]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.808]             }
[17:42:19.808]             base::options(...future.oldOptions)
[17:42:19.808]             if (.Platform$OS.type == "windows") {
[17:42:19.808]                 old_names <- names(...future.oldEnvVars)
[17:42:19.808]                 envs <- base::Sys.getenv()
[17:42:19.808]                 names <- names(envs)
[17:42:19.808]                 common <- intersect(names, old_names)
[17:42:19.808]                 added <- setdiff(names, old_names)
[17:42:19.808]                 removed <- setdiff(old_names, names)
[17:42:19.808]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.808]                   envs[common]]
[17:42:19.808]                 NAMES <- toupper(changed)
[17:42:19.808]                 args <- list()
[17:42:19.808]                 for (kk in seq_along(NAMES)) {
[17:42:19.808]                   name <- changed[[kk]]
[17:42:19.808]                   NAME <- NAMES[[kk]]
[17:42:19.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.808]                     next
[17:42:19.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.808]                 }
[17:42:19.808]                 NAMES <- toupper(added)
[17:42:19.808]                 for (kk in seq_along(NAMES)) {
[17:42:19.808]                   name <- added[[kk]]
[17:42:19.808]                   NAME <- NAMES[[kk]]
[17:42:19.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.808]                     next
[17:42:19.808]                   args[[name]] <- ""
[17:42:19.808]                 }
[17:42:19.808]                 NAMES <- toupper(removed)
[17:42:19.808]                 for (kk in seq_along(NAMES)) {
[17:42:19.808]                   name <- removed[[kk]]
[17:42:19.808]                   NAME <- NAMES[[kk]]
[17:42:19.808]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.808]                     next
[17:42:19.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.808]                 }
[17:42:19.808]                 if (length(args) > 0) 
[17:42:19.808]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.808]             }
[17:42:19.808]             else {
[17:42:19.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.808]             }
[17:42:19.808]             {
[17:42:19.808]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.808]                   0L) {
[17:42:19.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.808]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.808]                   base::options(opts)
[17:42:19.808]                 }
[17:42:19.808]                 {
[17:42:19.808]                   {
[17:42:19.808]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:19.808]                     NULL
[17:42:19.808]                   }
[17:42:19.808]                   options(future.plan = NULL)
[17:42:19.808]                   if (is.na(NA_character_)) 
[17:42:19.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.808]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:19.808]                     envir = parent.frame()) 
[17:42:19.808]                   {
[17:42:19.808]                     default_workers <- missing(workers)
[17:42:19.808]                     if (is.function(workers)) 
[17:42:19.808]                       workers <- workers()
[17:42:19.808]                     workers <- structure(as.integer(workers), 
[17:42:19.808]                       class = class(workers))
[17:42:19.808]                     stop_if_not(is.finite(workers), workers >= 
[17:42:19.808]                       1L)
[17:42:19.808]                     if ((workers == 1L && !inherits(workers, 
[17:42:19.808]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:19.808]                       if (default_workers) 
[17:42:19.808]                         supportsMulticore(warn = TRUE)
[17:42:19.808]                       return(sequential(..., envir = envir))
[17:42:19.808]                     }
[17:42:19.808]                     oopts <- options(mc.cores = workers)
[17:42:19.808]                     on.exit(options(oopts))
[17:42:19.808]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:19.808]                       envir = envir)
[17:42:19.808]                     if (!future$lazy) 
[17:42:19.808]                       future <- run(future)
[17:42:19.808]                     invisible(future)
[17:42:19.808]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.808]                 }
[17:42:19.808]             }
[17:42:19.808]         }
[17:42:19.808]     })
[17:42:19.808]     if (TRUE) {
[17:42:19.808]         base::sink(type = "output", split = FALSE)
[17:42:19.808]         if (TRUE) {
[17:42:19.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.808]         }
[17:42:19.808]         else {
[17:42:19.808]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.808]         }
[17:42:19.808]         base::close(...future.stdout)
[17:42:19.808]         ...future.stdout <- NULL
[17:42:19.808]     }
[17:42:19.808]     ...future.result$conditions <- ...future.conditions
[17:42:19.808]     ...future.result$finished <- base::Sys.time()
[17:42:19.808]     ...future.result
[17:42:19.808] }
[17:42:19.813] requestCore(): workers = 2
[17:42:19.820] MulticoreFuture started
[17:42:19.821] - Launch lazy future ... done
[17:42:19.821] run() for ‘MulticoreFuture’ ... done
[17:42:19.821] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:42:19.821] List of future strategies:
[17:42:19.821] 1. sequential:
[17:42:19.821]    - args: function (..., envir = parent.frame())
[17:42:19.821]    - tweaked: FALSE
[17:42:19.821]    - call: NULL
[17:42:19.822] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef6b277e0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7ac08b8> 
 $  :[17:42:19.824] plan(): Setting new future strategy stack:
 NULL
 $  :[17:42:19.824] List of future strategies:
[17:42:19.824] 1. multicore:
[17:42:19.824]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.824]    - tweaked: FALSE
[17:42:19.824]    - call: plan(strategy)
 NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef6b277e0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7ac08b8> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:42:19.829] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.832] resolve() on list ...
[17:42:19.832]  recursive: 0
[17:42:19.832]  length: 6
[17:42:19.832]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.838] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.838] - nx: 6
[17:42:19.839] - relay: TRUE
[17:42:19.839] - stdout: TRUE
[17:42:19.839] - signal: TRUE
[17:42:19.839] - resignal: FALSE
[17:42:19.840] - force: TRUE
[17:42:19.840] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.840] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.840]  - until=2
[17:42:19.841]  - relaying element #2
[17:42:19.841] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.841] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.841] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.842]  length: 5 (resolved future 1)
[17:42:19.842] Future #2
[17:42:19.845] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:19.845] - nx: 6
[17:42:19.845] - relay: TRUE
[17:42:19.845] - stdout: TRUE
[17:42:19.845] - signal: TRUE
[17:42:19.845] - resignal: FALSE
[17:42:19.846] - force: TRUE
[17:42:19.846] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.846] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.846]  - until=2
[17:42:19.846]  - relaying element #2
[17:42:19.846] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.847] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.847] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:19.847]  length: 4 (resolved future 2)
[17:42:19.847] Future #3
[17:42:19.849] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:19.849] - nx: 6
[17:42:19.849] - relay: TRUE
[17:42:19.849] - stdout: TRUE
[17:42:19.849] - signal: TRUE
[17:42:19.849] - resignal: FALSE
[17:42:19.849] - force: TRUE
[17:42:19.849] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.850] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.850]  - until=3
[17:42:19.850]  - relaying element #3
[17:42:19.850] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.850] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.850] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:19.850]  length: 3 (resolved future 3)
[17:42:19.851] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.851] - nx: 6
[17:42:19.851] - relay: TRUE
[17:42:19.851] - stdout: TRUE
[17:42:19.851] - signal: TRUE
[17:42:19.851] - resignal: FALSE
[17:42:19.851] - force: TRUE
[17:42:19.851] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.851] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.852]  - until=5
[17:42:19.852]  - relaying element #5
[17:42:19.852] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.852] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.852] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.852]  length: 2 (resolved future 4)
[17:42:19.852] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.852] - nx: 6
[17:42:19.852] - relay: TRUE
[17:42:19.853] - stdout: TRUE
[17:42:19.853] - signal: TRUE
[17:42:19.853] - resignal: FALSE
[17:42:19.853] - force: TRUE
[17:42:19.853] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.853] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.853]  - until=6
[17:42:19.853]  - relaying element #6
[17:42:19.853] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.853] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.854] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.854]  length: 1 (resolved future 5)
[17:42:19.854] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.854] - nx: 6
[17:42:19.854] - relay: TRUE
[17:42:19.854] - stdout: TRUE
[17:42:19.854] - signal: TRUE
[17:42:19.854] - resignal: FALSE
[17:42:19.854] - force: TRUE
[17:42:19.854] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.855] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.855]  - until=6
[17:42:19.855] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.855] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.855] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.855]  length: 0 (resolved future 6)
[17:42:19.855] Relaying remaining futures
[17:42:19.855] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.855] - nx: 6
[17:42:19.856] - relay: TRUE
[17:42:19.856] - stdout: TRUE
[17:42:19.856] - signal: TRUE
[17:42:19.856] - resignal: FALSE
[17:42:19.856] - force: TRUE
[17:42:19.856] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.856] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.856] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.856] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.856] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.857] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:42:19.859] getGlobalsAndPackages() ...
[17:42:19.859] Searching for globals...
[17:42:19.860] 
[17:42:19.860] Searching for globals ... DONE
[17:42:19.860] - globals: [0] <none>
[17:42:19.860] getGlobalsAndPackages() ... DONE
[17:42:19.860] run() for ‘Future’ ...
[17:42:19.860] - state: ‘created’
[17:42:19.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:19.865] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:19.865] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:19.865]   - Field: ‘label’
[17:42:19.865]   - Field: ‘local’
[17:42:19.865]   - Field: ‘owner’
[17:42:19.865]   - Field: ‘envir’
[17:42:19.866]   - Field: ‘workers’
[17:42:19.866]   - Field: ‘packages’
[17:42:19.866]   - Field: ‘gc’
[17:42:19.866]   - Field: ‘job’
[17:42:19.866]   - Field: ‘conditions’
[17:42:19.866]   - Field: ‘expr’
[17:42:19.866]   - Field: ‘uuid’
[17:42:19.866]   - Field: ‘seed’
[17:42:19.866]   - Field: ‘version’
[17:42:19.866]   - Field: ‘result’
[17:42:19.867]   - Field: ‘asynchronous’
[17:42:19.867]   - Field: ‘calls’
[17:42:19.867]   - Field: ‘globals’
[17:42:19.867]   - Field: ‘stdout’
[17:42:19.867]   - Field: ‘earlySignal’
[17:42:19.867]   - Field: ‘lazy’
[17:42:19.867]   - Field: ‘state’
[17:42:19.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:19.867] - Launch lazy future ...
[17:42:19.868] Packages needed by the future expression (n = 0): <none>
[17:42:19.868] Packages needed by future strategies (n = 0): <none>
[17:42:19.868] {
[17:42:19.868]     {
[17:42:19.868]         {
[17:42:19.868]             ...future.startTime <- base::Sys.time()
[17:42:19.868]             {
[17:42:19.868]                 {
[17:42:19.868]                   {
[17:42:19.868]                     {
[17:42:19.868]                       base::local({
[17:42:19.868]                         has_future <- base::requireNamespace("future", 
[17:42:19.868]                           quietly = TRUE)
[17:42:19.868]                         if (has_future) {
[17:42:19.868]                           ns <- base::getNamespace("future")
[17:42:19.868]                           version <- ns[[".package"]][["version"]]
[17:42:19.868]                           if (is.null(version)) 
[17:42:19.868]                             version <- utils::packageVersion("future")
[17:42:19.868]                         }
[17:42:19.868]                         else {
[17:42:19.868]                           version <- NULL
[17:42:19.868]                         }
[17:42:19.868]                         if (!has_future || version < "1.8.0") {
[17:42:19.868]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.868]                             "", base::R.version$version.string), 
[17:42:19.868]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:19.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.868]                               "release", "version")], collapse = " "), 
[17:42:19.868]                             hostname = base::Sys.info()[["nodename"]])
[17:42:19.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.868]                             info)
[17:42:19.868]                           info <- base::paste(info, collapse = "; ")
[17:42:19.868]                           if (!has_future) {
[17:42:19.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.868]                               info)
[17:42:19.868]                           }
[17:42:19.868]                           else {
[17:42:19.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.868]                               info, version)
[17:42:19.868]                           }
[17:42:19.868]                           base::stop(msg)
[17:42:19.868]                         }
[17:42:19.868]                       })
[17:42:19.868]                     }
[17:42:19.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:19.868]                     base::options(mc.cores = 1L)
[17:42:19.868]                   }
[17:42:19.868]                   options(future.plan = NULL)
[17:42:19.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.868]                 }
[17:42:19.868]                 ...future.workdir <- getwd()
[17:42:19.868]             }
[17:42:19.868]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.868]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.868]         }
[17:42:19.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.868]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.868]             base::names(...future.oldOptions))
[17:42:19.868]     }
[17:42:19.868]     if (FALSE) {
[17:42:19.868]     }
[17:42:19.868]     else {
[17:42:19.868]         if (TRUE) {
[17:42:19.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.868]                 open = "w")
[17:42:19.868]         }
[17:42:19.868]         else {
[17:42:19.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.868]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.868]         }
[17:42:19.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.868]             base::sink(type = "output", split = FALSE)
[17:42:19.868]             base::close(...future.stdout)
[17:42:19.868]         }, add = TRUE)
[17:42:19.868]     }
[17:42:19.868]     ...future.frame <- base::sys.nframe()
[17:42:19.868]     ...future.conditions <- base::list()
[17:42:19.868]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.868]     if (FALSE) {
[17:42:19.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.868]     }
[17:42:19.868]     ...future.result <- base::tryCatch({
[17:42:19.868]         base::withCallingHandlers({
[17:42:19.868]             ...future.value <- base::withVisible(base::local({
[17:42:19.868]                 withCallingHandlers({
[17:42:19.868]                   2
[17:42:19.868]                 }, immediateCondition = function(cond) {
[17:42:19.868]                   save_rds <- function (object, pathname, ...) 
[17:42:19.868]                   {
[17:42:19.868]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:19.868]                     if (file_test("-f", pathname_tmp)) {
[17:42:19.868]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.868]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:19.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.868]                         fi_tmp[["mtime"]])
[17:42:19.868]                     }
[17:42:19.868]                     tryCatch({
[17:42:19.868]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:19.868]                     }, error = function(ex) {
[17:42:19.868]                       msg <- conditionMessage(ex)
[17:42:19.868]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.868]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:19.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.868]                         fi_tmp[["mtime"]], msg)
[17:42:19.868]                       ex$message <- msg
[17:42:19.868]                       stop(ex)
[17:42:19.868]                     })
[17:42:19.868]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:19.868]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:19.868]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:19.868]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.868]                       fi <- file.info(pathname)
[17:42:19.868]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:19.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.868]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:19.868]                         fi[["size"]], fi[["mtime"]])
[17:42:19.868]                       stop(msg)
[17:42:19.868]                     }
[17:42:19.868]                     invisible(pathname)
[17:42:19.868]                   }
[17:42:19.868]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:19.868]                     rootPath = tempdir()) 
[17:42:19.868]                   {
[17:42:19.868]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:19.868]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:19.868]                       tmpdir = path, fileext = ".rds")
[17:42:19.868]                     save_rds(obj, file)
[17:42:19.868]                   }
[17:42:19.868]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:19.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.868]                   {
[17:42:19.868]                     inherits <- base::inherits
[17:42:19.868]                     invokeRestart <- base::invokeRestart
[17:42:19.868]                     is.null <- base::is.null
[17:42:19.868]                     muffled <- FALSE
[17:42:19.868]                     if (inherits(cond, "message")) {
[17:42:19.868]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:19.868]                       if (muffled) 
[17:42:19.868]                         invokeRestart("muffleMessage")
[17:42:19.868]                     }
[17:42:19.868]                     else if (inherits(cond, "warning")) {
[17:42:19.868]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:19.868]                       if (muffled) 
[17:42:19.868]                         invokeRestart("muffleWarning")
[17:42:19.868]                     }
[17:42:19.868]                     else if (inherits(cond, "condition")) {
[17:42:19.868]                       if (!is.null(pattern)) {
[17:42:19.868]                         computeRestarts <- base::computeRestarts
[17:42:19.868]                         grepl <- base::grepl
[17:42:19.868]                         restarts <- computeRestarts(cond)
[17:42:19.868]                         for (restart in restarts) {
[17:42:19.868]                           name <- restart$name
[17:42:19.868]                           if (is.null(name)) 
[17:42:19.868]                             next
[17:42:19.868]                           if (!grepl(pattern, name)) 
[17:42:19.868]                             next
[17:42:19.868]                           invokeRestart(restart)
[17:42:19.868]                           muffled <- TRUE
[17:42:19.868]                           break
[17:42:19.868]                         }
[17:42:19.868]                       }
[17:42:19.868]                     }
[17:42:19.868]                     invisible(muffled)
[17:42:19.868]                   }
[17:42:19.868]                   muffleCondition(cond)
[17:42:19.868]                 })
[17:42:19.868]             }))
[17:42:19.868]             future::FutureResult(value = ...future.value$value, 
[17:42:19.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.868]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.868]                     ...future.globalenv.names))
[17:42:19.868]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.868]         }, condition = base::local({
[17:42:19.868]             c <- base::c
[17:42:19.868]             inherits <- base::inherits
[17:42:19.868]             invokeRestart <- base::invokeRestart
[17:42:19.868]             length <- base::length
[17:42:19.868]             list <- base::list
[17:42:19.868]             seq.int <- base::seq.int
[17:42:19.868]             signalCondition <- base::signalCondition
[17:42:19.868]             sys.calls <- base::sys.calls
[17:42:19.868]             `[[` <- base::`[[`
[17:42:19.868]             `+` <- base::`+`
[17:42:19.868]             `<<-` <- base::`<<-`
[17:42:19.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.868]                   3L)]
[17:42:19.868]             }
[17:42:19.868]             function(cond) {
[17:42:19.868]                 is_error <- inherits(cond, "error")
[17:42:19.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.868]                   NULL)
[17:42:19.868]                 if (is_error) {
[17:42:19.868]                   sessionInformation <- function() {
[17:42:19.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.868]                       search = base::search(), system = base::Sys.info())
[17:42:19.868]                   }
[17:42:19.868]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.868]                     cond$call), session = sessionInformation(), 
[17:42:19.868]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.868]                   signalCondition(cond)
[17:42:19.868]                 }
[17:42:19.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.868]                 "immediateCondition"))) {
[17:42:19.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.868]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.868]                   if (TRUE && !signal) {
[17:42:19.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.868]                     {
[17:42:19.868]                       inherits <- base::inherits
[17:42:19.868]                       invokeRestart <- base::invokeRestart
[17:42:19.868]                       is.null <- base::is.null
[17:42:19.868]                       muffled <- FALSE
[17:42:19.868]                       if (inherits(cond, "message")) {
[17:42:19.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.868]                         if (muffled) 
[17:42:19.868]                           invokeRestart("muffleMessage")
[17:42:19.868]                       }
[17:42:19.868]                       else if (inherits(cond, "warning")) {
[17:42:19.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.868]                         if (muffled) 
[17:42:19.868]                           invokeRestart("muffleWarning")
[17:42:19.868]                       }
[17:42:19.868]                       else if (inherits(cond, "condition")) {
[17:42:19.868]                         if (!is.null(pattern)) {
[17:42:19.868]                           computeRestarts <- base::computeRestarts
[17:42:19.868]                           grepl <- base::grepl
[17:42:19.868]                           restarts <- computeRestarts(cond)
[17:42:19.868]                           for (restart in restarts) {
[17:42:19.868]                             name <- restart$name
[17:42:19.868]                             if (is.null(name)) 
[17:42:19.868]                               next
[17:42:19.868]                             if (!grepl(pattern, name)) 
[17:42:19.868]                               next
[17:42:19.868]                             invokeRestart(restart)
[17:42:19.868]                             muffled <- TRUE
[17:42:19.868]                             break
[17:42:19.868]                           }
[17:42:19.868]                         }
[17:42:19.868]                       }
[17:42:19.868]                       invisible(muffled)
[17:42:19.868]                     }
[17:42:19.868]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.868]                   }
[17:42:19.868]                 }
[17:42:19.868]                 else {
[17:42:19.868]                   if (TRUE) {
[17:42:19.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.868]                     {
[17:42:19.868]                       inherits <- base::inherits
[17:42:19.868]                       invokeRestart <- base::invokeRestart
[17:42:19.868]                       is.null <- base::is.null
[17:42:19.868]                       muffled <- FALSE
[17:42:19.868]                       if (inherits(cond, "message")) {
[17:42:19.868]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.868]                         if (muffled) 
[17:42:19.868]                           invokeRestart("muffleMessage")
[17:42:19.868]                       }
[17:42:19.868]                       else if (inherits(cond, "warning")) {
[17:42:19.868]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.868]                         if (muffled) 
[17:42:19.868]                           invokeRestart("muffleWarning")
[17:42:19.868]                       }
[17:42:19.868]                       else if (inherits(cond, "condition")) {
[17:42:19.868]                         if (!is.null(pattern)) {
[17:42:19.868]                           computeRestarts <- base::computeRestarts
[17:42:19.868]                           grepl <- base::grepl
[17:42:19.868]                           restarts <- computeRestarts(cond)
[17:42:19.868]                           for (restart in restarts) {
[17:42:19.868]                             name <- restart$name
[17:42:19.868]                             if (is.null(name)) 
[17:42:19.868]                               next
[17:42:19.868]                             if (!grepl(pattern, name)) 
[17:42:19.868]                               next
[17:42:19.868]                             invokeRestart(restart)
[17:42:19.868]                             muffled <- TRUE
[17:42:19.868]                             break
[17:42:19.868]                           }
[17:42:19.868]                         }
[17:42:19.868]                       }
[17:42:19.868]                       invisible(muffled)
[17:42:19.868]                     }
[17:42:19.868]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.868]                   }
[17:42:19.868]                 }
[17:42:19.868]             }
[17:42:19.868]         }))
[17:42:19.868]     }, error = function(ex) {
[17:42:19.868]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.868]                 ...future.rng), started = ...future.startTime, 
[17:42:19.868]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.868]             version = "1.8"), class = "FutureResult")
[17:42:19.868]     }, finally = {
[17:42:19.868]         if (!identical(...future.workdir, getwd())) 
[17:42:19.868]             setwd(...future.workdir)
[17:42:19.868]         {
[17:42:19.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.868]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.868]             }
[17:42:19.868]             base::options(...future.oldOptions)
[17:42:19.868]             if (.Platform$OS.type == "windows") {
[17:42:19.868]                 old_names <- names(...future.oldEnvVars)
[17:42:19.868]                 envs <- base::Sys.getenv()
[17:42:19.868]                 names <- names(envs)
[17:42:19.868]                 common <- intersect(names, old_names)
[17:42:19.868]                 added <- setdiff(names, old_names)
[17:42:19.868]                 removed <- setdiff(old_names, names)
[17:42:19.868]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.868]                   envs[common]]
[17:42:19.868]                 NAMES <- toupper(changed)
[17:42:19.868]                 args <- list()
[17:42:19.868]                 for (kk in seq_along(NAMES)) {
[17:42:19.868]                   name <- changed[[kk]]
[17:42:19.868]                   NAME <- NAMES[[kk]]
[17:42:19.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.868]                     next
[17:42:19.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.868]                 }
[17:42:19.868]                 NAMES <- toupper(added)
[17:42:19.868]                 for (kk in seq_along(NAMES)) {
[17:42:19.868]                   name <- added[[kk]]
[17:42:19.868]                   NAME <- NAMES[[kk]]
[17:42:19.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.868]                     next
[17:42:19.868]                   args[[name]] <- ""
[17:42:19.868]                 }
[17:42:19.868]                 NAMES <- toupper(removed)
[17:42:19.868]                 for (kk in seq_along(NAMES)) {
[17:42:19.868]                   name <- removed[[kk]]
[17:42:19.868]                   NAME <- NAMES[[kk]]
[17:42:19.868]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.868]                     next
[17:42:19.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.868]                 }
[17:42:19.868]                 if (length(args) > 0) 
[17:42:19.868]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.868]             }
[17:42:19.868]             else {
[17:42:19.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.868]             }
[17:42:19.868]             {
[17:42:19.868]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.868]                   0L) {
[17:42:19.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.868]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.868]                   base::options(opts)
[17:42:19.868]                 }
[17:42:19.868]                 {
[17:42:19.868]                   {
[17:42:19.868]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:19.868]                     NULL
[17:42:19.868]                   }
[17:42:19.868]                   options(future.plan = NULL)
[17:42:19.868]                   if (is.na(NA_character_)) 
[17:42:19.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.868]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:19.868]                     envir = parent.frame()) 
[17:42:19.868]                   {
[17:42:19.868]                     default_workers <- missing(workers)
[17:42:19.868]                     if (is.function(workers)) 
[17:42:19.868]                       workers <- workers()
[17:42:19.868]                     workers <- structure(as.integer(workers), 
[17:42:19.868]                       class = class(workers))
[17:42:19.868]                     stop_if_not(is.finite(workers), workers >= 
[17:42:19.868]                       1L)
[17:42:19.868]                     if ((workers == 1L && !inherits(workers, 
[17:42:19.868]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:19.868]                       if (default_workers) 
[17:42:19.868]                         supportsMulticore(warn = TRUE)
[17:42:19.868]                       return(sequential(..., envir = envir))
[17:42:19.868]                     }
[17:42:19.868]                     oopts <- options(mc.cores = workers)
[17:42:19.868]                     on.exit(options(oopts))
[17:42:19.868]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:19.868]                       envir = envir)
[17:42:19.868]                     if (!future$lazy) 
[17:42:19.868]                       future <- run(future)
[17:42:19.868]                     invisible(future)
[17:42:19.868]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.868]                 }
[17:42:19.868]             }
[17:42:19.868]         }
[17:42:19.868]     })
[17:42:19.868]     if (TRUE) {
[17:42:19.868]         base::sink(type = "output", split = FALSE)
[17:42:19.868]         if (TRUE) {
[17:42:19.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.868]         }
[17:42:19.868]         else {
[17:42:19.868]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.868]         }
[17:42:19.868]         base::close(...future.stdout)
[17:42:19.868]         ...future.stdout <- NULL
[17:42:19.868]     }
[17:42:19.868]     ...future.result$conditions <- ...future.conditions
[17:42:19.868]     ...future.result$finished <- base::Sys.time()
[17:42:19.868]     ...future.result
[17:42:19.868] }
[17:42:19.871] requestCore(): workers = 2
[17:42:19.873] MulticoreFuture started
[17:42:19.874] - Launch lazy future ... done
[17:42:19.874] run() for ‘MulticoreFuture’ ... done
[17:42:19.874] getGlobalsAndPackages() ...
[17:42:19.874] Searching for globals...
[17:42:19.874] plan(): Setting new future strategy stack:
[17:42:19.875] 
[17:42:19.875] List of future strategies:
[17:42:19.875] 1. sequential:
[17:42:19.875]    - args: function (..., envir = parent.frame())
[17:42:19.875]    - tweaked: FALSE
[17:42:19.875]    - call: NULL
[17:42:19.875] Searching for globals ... DONE
[17:42:19.875] - globals: [0] <none>
[17:42:19.876] plan(): nbrOfWorkers() = 1
[17:42:19.876] getGlobalsAndPackages() ... DONE
[17:42:19.876] run() for ‘Future’ ...
[17:42:19.876] - state: ‘created’
[17:42:19.877] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:19.877] plan(): Setting new future strategy stack:
[17:42:19.878] List of future strategies:
[17:42:19.878] 1. multicore:
[17:42:19.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.878]    - tweaked: FALSE
[17:42:19.878]    - call: plan(strategy)
[17:42:19.882] plan(): nbrOfWorkers() = 2
[17:42:19.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:19.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:19.883]   - Field: ‘label’
[17:42:19.883]   - Field: ‘local’
[17:42:19.883]   - Field: ‘owner’
[17:42:19.883]   - Field: ‘envir’
[17:42:19.883]   - Field: ‘workers’
[17:42:19.883]   - Field: ‘packages’
[17:42:19.884]   - Field: ‘gc’
[17:42:19.884]   - Field: ‘job’
[17:42:19.884]   - Field: ‘conditions’
[17:42:19.888]   - Field: ‘expr’
[17:42:19.888]   - Field: ‘uuid’
[17:42:19.889]   - Field: ‘seed’
[17:42:19.889]   - Field: ‘version’
[17:42:19.889]   - Field: ‘result’
[17:42:19.889]   - Field: ‘asynchronous’
[17:42:19.890]   - Field: ‘calls’
[17:42:19.890]   - Field: ‘globals’
[17:42:19.890]   - Field: ‘stdout’
[17:42:19.890]   - Field: ‘earlySignal’
[17:42:19.891]   - Field: ‘lazy’
[17:42:19.891]   - Field: ‘state’
[17:42:19.891] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:19.892] - Launch lazy future ...
[17:42:19.892] Packages needed by the future expression (n = 0): <none>
[17:42:19.892] Packages needed by future strategies (n = 0): <none>
[17:42:19.893] {
[17:42:19.893]     {
[17:42:19.893]         {
[17:42:19.893]             ...future.startTime <- base::Sys.time()
[17:42:19.893]             {
[17:42:19.893]                 {
[17:42:19.893]                   {
[17:42:19.893]                     {
[17:42:19.893]                       base::local({
[17:42:19.893]                         has_future <- base::requireNamespace("future", 
[17:42:19.893]                           quietly = TRUE)
[17:42:19.893]                         if (has_future) {
[17:42:19.893]                           ns <- base::getNamespace("future")
[17:42:19.893]                           version <- ns[[".package"]][["version"]]
[17:42:19.893]                           if (is.null(version)) 
[17:42:19.893]                             version <- utils::packageVersion("future")
[17:42:19.893]                         }
[17:42:19.893]                         else {
[17:42:19.893]                           version <- NULL
[17:42:19.893]                         }
[17:42:19.893]                         if (!has_future || version < "1.8.0") {
[17:42:19.893]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.893]                             "", base::R.version$version.string), 
[17:42:19.893]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:19.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.893]                               "release", "version")], collapse = " "), 
[17:42:19.893]                             hostname = base::Sys.info()[["nodename"]])
[17:42:19.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.893]                             info)
[17:42:19.893]                           info <- base::paste(info, collapse = "; ")
[17:42:19.893]                           if (!has_future) {
[17:42:19.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.893]                               info)
[17:42:19.893]                           }
[17:42:19.893]                           else {
[17:42:19.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.893]                               info, version)
[17:42:19.893]                           }
[17:42:19.893]                           base::stop(msg)
[17:42:19.893]                         }
[17:42:19.893]                       })
[17:42:19.893]                     }
[17:42:19.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:19.893]                     base::options(mc.cores = 1L)
[17:42:19.893]                   }
[17:42:19.893]                   options(future.plan = NULL)
[17:42:19.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.893]                 }
[17:42:19.893]                 ...future.workdir <- getwd()
[17:42:19.893]             }
[17:42:19.893]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.893]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.893]         }
[17:42:19.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.893]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.893]             base::names(...future.oldOptions))
[17:42:19.893]     }
[17:42:19.893]     if (FALSE) {
[17:42:19.893]     }
[17:42:19.893]     else {
[17:42:19.893]         if (TRUE) {
[17:42:19.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.893]                 open = "w")
[17:42:19.893]         }
[17:42:19.893]         else {
[17:42:19.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.893]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.893]         }
[17:42:19.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.893]             base::sink(type = "output", split = FALSE)
[17:42:19.893]             base::close(...future.stdout)
[17:42:19.893]         }, add = TRUE)
[17:42:19.893]     }
[17:42:19.893]     ...future.frame <- base::sys.nframe()
[17:42:19.893]     ...future.conditions <- base::list()
[17:42:19.893]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.893]     if (FALSE) {
[17:42:19.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.893]     }
[17:42:19.893]     ...future.result <- base::tryCatch({
[17:42:19.893]         base::withCallingHandlers({
[17:42:19.893]             ...future.value <- base::withVisible(base::local({
[17:42:19.893]                 withCallingHandlers({
[17:42:19.893]                   NULL
[17:42:19.893]                 }, immediateCondition = function(cond) {
[17:42:19.893]                   save_rds <- function (object, pathname, ...) 
[17:42:19.893]                   {
[17:42:19.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:19.893]                     if (file_test("-f", pathname_tmp)) {
[17:42:19.893]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:19.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.893]                         fi_tmp[["mtime"]])
[17:42:19.893]                     }
[17:42:19.893]                     tryCatch({
[17:42:19.893]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:19.893]                     }, error = function(ex) {
[17:42:19.893]                       msg <- conditionMessage(ex)
[17:42:19.893]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:19.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.893]                         fi_tmp[["mtime"]], msg)
[17:42:19.893]                       ex$message <- msg
[17:42:19.893]                       stop(ex)
[17:42:19.893]                     })
[17:42:19.893]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:19.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:19.893]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:19.893]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.893]                       fi <- file.info(pathname)
[17:42:19.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:19.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:19.893]                         fi[["size"]], fi[["mtime"]])
[17:42:19.893]                       stop(msg)
[17:42:19.893]                     }
[17:42:19.893]                     invisible(pathname)
[17:42:19.893]                   }
[17:42:19.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:19.893]                     rootPath = tempdir()) 
[17:42:19.893]                   {
[17:42:19.893]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:19.893]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:19.893]                       tmpdir = path, fileext = ".rds")
[17:42:19.893]                     save_rds(obj, file)
[17:42:19.893]                   }
[17:42:19.893]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:19.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.893]                   {
[17:42:19.893]                     inherits <- base::inherits
[17:42:19.893]                     invokeRestart <- base::invokeRestart
[17:42:19.893]                     is.null <- base::is.null
[17:42:19.893]                     muffled <- FALSE
[17:42:19.893]                     if (inherits(cond, "message")) {
[17:42:19.893]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:19.893]                       if (muffled) 
[17:42:19.893]                         invokeRestart("muffleMessage")
[17:42:19.893]                     }
[17:42:19.893]                     else if (inherits(cond, "warning")) {
[17:42:19.893]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:19.893]                       if (muffled) 
[17:42:19.893]                         invokeRestart("muffleWarning")
[17:42:19.893]                     }
[17:42:19.893]                     else if (inherits(cond, "condition")) {
[17:42:19.893]                       if (!is.null(pattern)) {
[17:42:19.893]                         computeRestarts <- base::computeRestarts
[17:42:19.893]                         grepl <- base::grepl
[17:42:19.893]                         restarts <- computeRestarts(cond)
[17:42:19.893]                         for (restart in restarts) {
[17:42:19.893]                           name <- restart$name
[17:42:19.893]                           if (is.null(name)) 
[17:42:19.893]                             next
[17:42:19.893]                           if (!grepl(pattern, name)) 
[17:42:19.893]                             next
[17:42:19.893]                           invokeRestart(restart)
[17:42:19.893]                           muffled <- TRUE
[17:42:19.893]                           break
[17:42:19.893]                         }
[17:42:19.893]                       }
[17:42:19.893]                     }
[17:42:19.893]                     invisible(muffled)
[17:42:19.893]                   }
[17:42:19.893]                   muffleCondition(cond)
[17:42:19.893]                 })
[17:42:19.893]             }))
[17:42:19.893]             future::FutureResult(value = ...future.value$value, 
[17:42:19.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.893]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.893]                     ...future.globalenv.names))
[17:42:19.893]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.893]         }, condition = base::local({
[17:42:19.893]             c <- base::c
[17:42:19.893]             inherits <- base::inherits
[17:42:19.893]             invokeRestart <- base::invokeRestart
[17:42:19.893]             length <- base::length
[17:42:19.893]             list <- base::list
[17:42:19.893]             seq.int <- base::seq.int
[17:42:19.893]             signalCondition <- base::signalCondition
[17:42:19.893]             sys.calls <- base::sys.calls
[17:42:19.893]             `[[` <- base::`[[`
[17:42:19.893]             `+` <- base::`+`
[17:42:19.893]             `<<-` <- base::`<<-`
[17:42:19.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.893]                   3L)]
[17:42:19.893]             }
[17:42:19.893]             function(cond) {
[17:42:19.893]                 is_error <- inherits(cond, "error")
[17:42:19.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.893]                   NULL)
[17:42:19.893]                 if (is_error) {
[17:42:19.893]                   sessionInformation <- function() {
[17:42:19.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.893]                       search = base::search(), system = base::Sys.info())
[17:42:19.893]                   }
[17:42:19.893]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.893]                     cond$call), session = sessionInformation(), 
[17:42:19.893]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.893]                   signalCondition(cond)
[17:42:19.893]                 }
[17:42:19.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.893]                 "immediateCondition"))) {
[17:42:19.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.893]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.893]                   if (TRUE && !signal) {
[17:42:19.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.893]                     {
[17:42:19.893]                       inherits <- base::inherits
[17:42:19.893]                       invokeRestart <- base::invokeRestart
[17:42:19.893]                       is.null <- base::is.null
[17:42:19.893]                       muffled <- FALSE
[17:42:19.893]                       if (inherits(cond, "message")) {
[17:42:19.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.893]                         if (muffled) 
[17:42:19.893]                           invokeRestart("muffleMessage")
[17:42:19.893]                       }
[17:42:19.893]                       else if (inherits(cond, "warning")) {
[17:42:19.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.893]                         if (muffled) 
[17:42:19.893]                           invokeRestart("muffleWarning")
[17:42:19.893]                       }
[17:42:19.893]                       else if (inherits(cond, "condition")) {
[17:42:19.893]                         if (!is.null(pattern)) {
[17:42:19.893]                           computeRestarts <- base::computeRestarts
[17:42:19.893]                           grepl <- base::grepl
[17:42:19.893]                           restarts <- computeRestarts(cond)
[17:42:19.893]                           for (restart in restarts) {
[17:42:19.893]                             name <- restart$name
[17:42:19.893]                             if (is.null(name)) 
[17:42:19.893]                               next
[17:42:19.893]                             if (!grepl(pattern, name)) 
[17:42:19.893]                               next
[17:42:19.893]                             invokeRestart(restart)
[17:42:19.893]                             muffled <- TRUE
[17:42:19.893]                             break
[17:42:19.893]                           }
[17:42:19.893]                         }
[17:42:19.893]                       }
[17:42:19.893]                       invisible(muffled)
[17:42:19.893]                     }
[17:42:19.893]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.893]                   }
[17:42:19.893]                 }
[17:42:19.893]                 else {
[17:42:19.893]                   if (TRUE) {
[17:42:19.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.893]                     {
[17:42:19.893]                       inherits <- base::inherits
[17:42:19.893]                       invokeRestart <- base::invokeRestart
[17:42:19.893]                       is.null <- base::is.null
[17:42:19.893]                       muffled <- FALSE
[17:42:19.893]                       if (inherits(cond, "message")) {
[17:42:19.893]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.893]                         if (muffled) 
[17:42:19.893]                           invokeRestart("muffleMessage")
[17:42:19.893]                       }
[17:42:19.893]                       else if (inherits(cond, "warning")) {
[17:42:19.893]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.893]                         if (muffled) 
[17:42:19.893]                           invokeRestart("muffleWarning")
[17:42:19.893]                       }
[17:42:19.893]                       else if (inherits(cond, "condition")) {
[17:42:19.893]                         if (!is.null(pattern)) {
[17:42:19.893]                           computeRestarts <- base::computeRestarts
[17:42:19.893]                           grepl <- base::grepl
[17:42:19.893]                           restarts <- computeRestarts(cond)
[17:42:19.893]                           for (restart in restarts) {
[17:42:19.893]                             name <- restart$name
[17:42:19.893]                             if (is.null(name)) 
[17:42:19.893]                               next
[17:42:19.893]                             if (!grepl(pattern, name)) 
[17:42:19.893]                               next
[17:42:19.893]                             invokeRestart(restart)
[17:42:19.893]                             muffled <- TRUE
[17:42:19.893]                             break
[17:42:19.893]                           }
[17:42:19.893]                         }
[17:42:19.893]                       }
[17:42:19.893]                       invisible(muffled)
[17:42:19.893]                     }
[17:42:19.893]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.893]                   }
[17:42:19.893]                 }
[17:42:19.893]             }
[17:42:19.893]         }))
[17:42:19.893]     }, error = function(ex) {
[17:42:19.893]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.893]                 ...future.rng), started = ...future.startTime, 
[17:42:19.893]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.893]             version = "1.8"), class = "FutureResult")
[17:42:19.893]     }, finally = {
[17:42:19.893]         if (!identical(...future.workdir, getwd())) 
[17:42:19.893]             setwd(...future.workdir)
[17:42:19.893]         {
[17:42:19.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.893]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.893]             }
[17:42:19.893]             base::options(...future.oldOptions)
[17:42:19.893]             if (.Platform$OS.type == "windows") {
[17:42:19.893]                 old_names <- names(...future.oldEnvVars)
[17:42:19.893]                 envs <- base::Sys.getenv()
[17:42:19.893]                 names <- names(envs)
[17:42:19.893]                 common <- intersect(names, old_names)
[17:42:19.893]                 added <- setdiff(names, old_names)
[17:42:19.893]                 removed <- setdiff(old_names, names)
[17:42:19.893]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.893]                   envs[common]]
[17:42:19.893]                 NAMES <- toupper(changed)
[17:42:19.893]                 args <- list()
[17:42:19.893]                 for (kk in seq_along(NAMES)) {
[17:42:19.893]                   name <- changed[[kk]]
[17:42:19.893]                   NAME <- NAMES[[kk]]
[17:42:19.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.893]                     next
[17:42:19.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.893]                 }
[17:42:19.893]                 NAMES <- toupper(added)
[17:42:19.893]                 for (kk in seq_along(NAMES)) {
[17:42:19.893]                   name <- added[[kk]]
[17:42:19.893]                   NAME <- NAMES[[kk]]
[17:42:19.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.893]                     next
[17:42:19.893]                   args[[name]] <- ""
[17:42:19.893]                 }
[17:42:19.893]                 NAMES <- toupper(removed)
[17:42:19.893]                 for (kk in seq_along(NAMES)) {
[17:42:19.893]                   name <- removed[[kk]]
[17:42:19.893]                   NAME <- NAMES[[kk]]
[17:42:19.893]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.893]                     next
[17:42:19.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.893]                 }
[17:42:19.893]                 if (length(args) > 0) 
[17:42:19.893]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.893]             }
[17:42:19.893]             else {
[17:42:19.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.893]             }
[17:42:19.893]             {
[17:42:19.893]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.893]                   0L) {
[17:42:19.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.893]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.893]                   base::options(opts)
[17:42:19.893]                 }
[17:42:19.893]                 {
[17:42:19.893]                   {
[17:42:19.893]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:19.893]                     NULL
[17:42:19.893]                   }
[17:42:19.893]                   options(future.plan = NULL)
[17:42:19.893]                   if (is.na(NA_character_)) 
[17:42:19.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.893]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:19.893]                     envir = parent.frame()) 
[17:42:19.893]                   {
[17:42:19.893]                     default_workers <- missing(workers)
[17:42:19.893]                     if (is.function(workers)) 
[17:42:19.893]                       workers <- workers()
[17:42:19.893]                     workers <- structure(as.integer(workers), 
[17:42:19.893]                       class = class(workers))
[17:42:19.893]                     stop_if_not(is.finite(workers), workers >= 
[17:42:19.893]                       1L)
[17:42:19.893]                     if ((workers == 1L && !inherits(workers, 
[17:42:19.893]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:19.893]                       if (default_workers) 
[17:42:19.893]                         supportsMulticore(warn = TRUE)
[17:42:19.893]                       return(sequential(..., envir = envir))
[17:42:19.893]                     }
[17:42:19.893]                     oopts <- options(mc.cores = workers)
[17:42:19.893]                     on.exit(options(oopts))
[17:42:19.893]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:19.893]                       envir = envir)
[17:42:19.893]                     if (!future$lazy) 
[17:42:19.893]                       future <- run(future)
[17:42:19.893]                     invisible(future)
[17:42:19.893]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.893]                 }
[17:42:19.893]             }
[17:42:19.893]         }
[17:42:19.893]     })
[17:42:19.893]     if (TRUE) {
[17:42:19.893]         base::sink(type = "output", split = FALSE)
[17:42:19.893]         if (TRUE) {
[17:42:19.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.893]         }
[17:42:19.893]         else {
[17:42:19.893]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.893]         }
[17:42:19.893]         base::close(...future.stdout)
[17:42:19.893]         ...future.stdout <- NULL
[17:42:19.893]     }
[17:42:19.893]     ...future.result$conditions <- ...future.conditions
[17:42:19.893]     ...future.result$finished <- base::Sys.time()
[17:42:19.893]     ...future.result
[17:42:19.893] }
[17:42:19.896] requestCore(): workers = 2
[17:42:19.899] MulticoreFuture started
[17:42:19.899] - Launch lazy future ... done
[17:42:19.899] run() for ‘MulticoreFuture’ ... done
List of 6
[17:42:19.900] plan(): Setting new future strategy stack:
 $ a:[17:42:19.900] List of future strategies:
[17:42:19.900] 1. sequential:
[17:42:19.900]    - args: function (..., envir = parent.frame())
[17:42:19.900]    - tweaked: FALSE
[17:42:19.900]    - call: NULL
 num 1
 $ b:[17:42:19.901] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7f66058> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef83687b0> 
 $  : NULL
 $  : NULL
 $  :[17:42:19.904] plan(): Setting new future strategy stack:
 num 6
[17:42:19.904] List of future strategies:
[17:42:19.904] 1. multicore:
[17:42:19.904]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.904]    - tweaked: FALSE
[17:42:19.904]    - call: plan(strategy)
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7f66058> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef83687b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ :[17:42:19.910] plan(): nbrOfWorkers() = 2
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.914] resolve() on list ...
[17:42:19.914]  recursive: 0
[17:42:19.914]  length: 6
[17:42:19.915]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.915] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.915] - nx: 6
[17:42:19.915] - relay: TRUE
[17:42:19.915] - stdout: TRUE
[17:42:19.915] - signal: TRUE
[17:42:19.915] - resignal: FALSE
[17:42:19.916] - force: TRUE
[17:42:19.916] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.916] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.916]  - until=2
[17:42:19.916]  - relaying element #2
[17:42:19.916] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.916] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.917] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.917]  length: 5 (resolved future 1)
[17:42:19.917] Future #2
[17:42:19.918] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:19.918] - nx: 6
[17:42:19.918] - relay: TRUE
[17:42:19.919] - stdout: TRUE
[17:42:19.919] - signal: TRUE
[17:42:19.919] - resignal: FALSE
[17:42:19.919] - force: TRUE
[17:42:19.919] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.919] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.919]  - until=2
[17:42:19.920]  - relaying element #2
[17:42:19.920] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.920] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.920] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:19.920]  length: 4 (resolved future 2)
[17:42:19.921] Future #3
[17:42:19.922] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:19.922] - nx: 6
[17:42:19.922] - relay: TRUE
[17:42:19.922] - stdout: TRUE
[17:42:19.922] - signal: TRUE
[17:42:19.922] - resignal: FALSE
[17:42:19.922] - force: TRUE
[17:42:19.922] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.923] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.923]  - until=3
[17:42:19.923]  - relaying element #3
[17:42:19.923] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.923] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.923] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:19.923]  length: 3 (resolved future 3)
[17:42:19.924] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.924] - nx: 6
[17:42:19.924] - relay: TRUE
[17:42:19.924] - stdout: TRUE
[17:42:19.924] - signal: TRUE
[17:42:19.924] - resignal: FALSE
[17:42:19.924] - force: TRUE
[17:42:19.924] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.924] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.925]  - until=5
[17:42:19.925]  - relaying element #5
[17:42:19.925] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.925] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.925] signalConditionsASAP(NULL, pos=4) ... done
[17:42:19.925]  length: 2 (resolved future 4)
[17:42:19.925] signalConditionsASAP(NULL, pos=5) ...
[17:42:19.925] - nx: 6
[17:42:19.925] - relay: TRUE
[17:42:19.926] - stdout: TRUE
[17:42:19.926] - signal: TRUE
[17:42:19.926] - resignal: FALSE
[17:42:19.926] - force: TRUE
[17:42:19.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:19.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.926]  - until=6
[17:42:19.926]  - relaying element #6
[17:42:19.926] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.926] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.927] signalConditionsASAP(NULL, pos=5) ... done
[17:42:19.927]  length: 1 (resolved future 5)
[17:42:19.927] signalConditionsASAP(numeric, pos=6) ...
[17:42:19.927] - nx: 6
[17:42:19.927] - relay: TRUE
[17:42:19.927] - stdout: TRUE
[17:42:19.927] - signal: TRUE
[17:42:19.927] - resignal: FALSE
[17:42:19.927] - force: TRUE
[17:42:19.927] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:19.928] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.928]  - until=6
[17:42:19.928] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.928] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.928] signalConditionsASAP(numeric, pos=6) ... done
[17:42:19.928]  length: 0 (resolved future 6)
[17:42:19.928] Relaying remaining futures
[17:42:19.928] signalConditionsASAP(NULL, pos=0) ...
[17:42:19.928] - nx: 6
[17:42:19.928] - relay: TRUE
[17:42:19.929] - stdout: TRUE
[17:42:19.929] - signal: TRUE
[17:42:19.929] - resignal: FALSE
[17:42:19.929] - force: TRUE
[17:42:19.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.929] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:19.929] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:19.929] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.929] signalConditionsASAP(NULL, pos=0) ... done
[17:42:19.930] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:42:19.937] getGlobalsAndPackages() ...
[17:42:19.937] Searching for globals...
[17:42:19.937] 
[17:42:19.938] Searching for globals ... DONE
[17:42:19.938] - globals: [0] <none>
[17:42:19.938] getGlobalsAndPackages() ... DONE
[17:42:19.938] run() for ‘Future’ ...
[17:42:19.938] - state: ‘created’
[17:42:19.938] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:19.942] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:19.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:19.943]   - Field: ‘label’
[17:42:19.943]   - Field: ‘local’
[17:42:19.943]   - Field: ‘owner’
[17:42:19.943]   - Field: ‘envir’
[17:42:19.943]   - Field: ‘workers’
[17:42:19.943]   - Field: ‘packages’
[17:42:19.943]   - Field: ‘gc’
[17:42:19.944]   - Field: ‘job’
[17:42:19.944]   - Field: ‘conditions’
[17:42:19.944]   - Field: ‘expr’
[17:42:19.944]   - Field: ‘uuid’
[17:42:19.944]   - Field: ‘seed’
[17:42:19.944]   - Field: ‘version’
[17:42:19.944]   - Field: ‘result’
[17:42:19.944]   - Field: ‘asynchronous’
[17:42:19.944]   - Field: ‘calls’
[17:42:19.944]   - Field: ‘globals’
[17:42:19.945]   - Field: ‘stdout’
[17:42:19.945]   - Field: ‘earlySignal’
[17:42:19.945]   - Field: ‘lazy’
[17:42:19.945]   - Field: ‘state’
[17:42:19.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:19.945] - Launch lazy future ...
[17:42:19.945] Packages needed by the future expression (n = 0): <none>
[17:42:19.945] Packages needed by future strategies (n = 0): <none>
[17:42:19.946] {
[17:42:19.946]     {
[17:42:19.946]         {
[17:42:19.946]             ...future.startTime <- base::Sys.time()
[17:42:19.946]             {
[17:42:19.946]                 {
[17:42:19.946]                   {
[17:42:19.946]                     {
[17:42:19.946]                       base::local({
[17:42:19.946]                         has_future <- base::requireNamespace("future", 
[17:42:19.946]                           quietly = TRUE)
[17:42:19.946]                         if (has_future) {
[17:42:19.946]                           ns <- base::getNamespace("future")
[17:42:19.946]                           version <- ns[[".package"]][["version"]]
[17:42:19.946]                           if (is.null(version)) 
[17:42:19.946]                             version <- utils::packageVersion("future")
[17:42:19.946]                         }
[17:42:19.946]                         else {
[17:42:19.946]                           version <- NULL
[17:42:19.946]                         }
[17:42:19.946]                         if (!has_future || version < "1.8.0") {
[17:42:19.946]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.946]                             "", base::R.version$version.string), 
[17:42:19.946]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:19.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.946]                               "release", "version")], collapse = " "), 
[17:42:19.946]                             hostname = base::Sys.info()[["nodename"]])
[17:42:19.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.946]                             info)
[17:42:19.946]                           info <- base::paste(info, collapse = "; ")
[17:42:19.946]                           if (!has_future) {
[17:42:19.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.946]                               info)
[17:42:19.946]                           }
[17:42:19.946]                           else {
[17:42:19.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.946]                               info, version)
[17:42:19.946]                           }
[17:42:19.946]                           base::stop(msg)
[17:42:19.946]                         }
[17:42:19.946]                       })
[17:42:19.946]                     }
[17:42:19.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:19.946]                     base::options(mc.cores = 1L)
[17:42:19.946]                   }
[17:42:19.946]                   options(future.plan = NULL)
[17:42:19.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.946]                 }
[17:42:19.946]                 ...future.workdir <- getwd()
[17:42:19.946]             }
[17:42:19.946]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.946]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.946]         }
[17:42:19.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.946]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.946]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.946]             base::names(...future.oldOptions))
[17:42:19.946]     }
[17:42:19.946]     if (FALSE) {
[17:42:19.946]     }
[17:42:19.946]     else {
[17:42:19.946]         if (TRUE) {
[17:42:19.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.946]                 open = "w")
[17:42:19.946]         }
[17:42:19.946]         else {
[17:42:19.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.946]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.946]         }
[17:42:19.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.946]             base::sink(type = "output", split = FALSE)
[17:42:19.946]             base::close(...future.stdout)
[17:42:19.946]         }, add = TRUE)
[17:42:19.946]     }
[17:42:19.946]     ...future.frame <- base::sys.nframe()
[17:42:19.946]     ...future.conditions <- base::list()
[17:42:19.946]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.946]     if (FALSE) {
[17:42:19.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.946]     }
[17:42:19.946]     ...future.result <- base::tryCatch({
[17:42:19.946]         base::withCallingHandlers({
[17:42:19.946]             ...future.value <- base::withVisible(base::local({
[17:42:19.946]                 withCallingHandlers({
[17:42:19.946]                   2
[17:42:19.946]                 }, immediateCondition = function(cond) {
[17:42:19.946]                   save_rds <- function (object, pathname, ...) 
[17:42:19.946]                   {
[17:42:19.946]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:19.946]                     if (file_test("-f", pathname_tmp)) {
[17:42:19.946]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.946]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:19.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.946]                         fi_tmp[["mtime"]])
[17:42:19.946]                     }
[17:42:19.946]                     tryCatch({
[17:42:19.946]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:19.946]                     }, error = function(ex) {
[17:42:19.946]                       msg <- conditionMessage(ex)
[17:42:19.946]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.946]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:19.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.946]                         fi_tmp[["mtime"]], msg)
[17:42:19.946]                       ex$message <- msg
[17:42:19.946]                       stop(ex)
[17:42:19.946]                     })
[17:42:19.946]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:19.946]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:19.946]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:19.946]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.946]                       fi <- file.info(pathname)
[17:42:19.946]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:19.946]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.946]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:19.946]                         fi[["size"]], fi[["mtime"]])
[17:42:19.946]                       stop(msg)
[17:42:19.946]                     }
[17:42:19.946]                     invisible(pathname)
[17:42:19.946]                   }
[17:42:19.946]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:19.946]                     rootPath = tempdir()) 
[17:42:19.946]                   {
[17:42:19.946]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:19.946]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:19.946]                       tmpdir = path, fileext = ".rds")
[17:42:19.946]                     save_rds(obj, file)
[17:42:19.946]                   }
[17:42:19.946]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:19.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.946]                   {
[17:42:19.946]                     inherits <- base::inherits
[17:42:19.946]                     invokeRestart <- base::invokeRestart
[17:42:19.946]                     is.null <- base::is.null
[17:42:19.946]                     muffled <- FALSE
[17:42:19.946]                     if (inherits(cond, "message")) {
[17:42:19.946]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:19.946]                       if (muffled) 
[17:42:19.946]                         invokeRestart("muffleMessage")
[17:42:19.946]                     }
[17:42:19.946]                     else if (inherits(cond, "warning")) {
[17:42:19.946]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:19.946]                       if (muffled) 
[17:42:19.946]                         invokeRestart("muffleWarning")
[17:42:19.946]                     }
[17:42:19.946]                     else if (inherits(cond, "condition")) {
[17:42:19.946]                       if (!is.null(pattern)) {
[17:42:19.946]                         computeRestarts <- base::computeRestarts
[17:42:19.946]                         grepl <- base::grepl
[17:42:19.946]                         restarts <- computeRestarts(cond)
[17:42:19.946]                         for (restart in restarts) {
[17:42:19.946]                           name <- restart$name
[17:42:19.946]                           if (is.null(name)) 
[17:42:19.946]                             next
[17:42:19.946]                           if (!grepl(pattern, name)) 
[17:42:19.946]                             next
[17:42:19.946]                           invokeRestart(restart)
[17:42:19.946]                           muffled <- TRUE
[17:42:19.946]                           break
[17:42:19.946]                         }
[17:42:19.946]                       }
[17:42:19.946]                     }
[17:42:19.946]                     invisible(muffled)
[17:42:19.946]                   }
[17:42:19.946]                   muffleCondition(cond)
[17:42:19.946]                 })
[17:42:19.946]             }))
[17:42:19.946]             future::FutureResult(value = ...future.value$value, 
[17:42:19.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.946]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.946]                     ...future.globalenv.names))
[17:42:19.946]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.946]         }, condition = base::local({
[17:42:19.946]             c <- base::c
[17:42:19.946]             inherits <- base::inherits
[17:42:19.946]             invokeRestart <- base::invokeRestart
[17:42:19.946]             length <- base::length
[17:42:19.946]             list <- base::list
[17:42:19.946]             seq.int <- base::seq.int
[17:42:19.946]             signalCondition <- base::signalCondition
[17:42:19.946]             sys.calls <- base::sys.calls
[17:42:19.946]             `[[` <- base::`[[`
[17:42:19.946]             `+` <- base::`+`
[17:42:19.946]             `<<-` <- base::`<<-`
[17:42:19.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.946]                   3L)]
[17:42:19.946]             }
[17:42:19.946]             function(cond) {
[17:42:19.946]                 is_error <- inherits(cond, "error")
[17:42:19.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.946]                   NULL)
[17:42:19.946]                 if (is_error) {
[17:42:19.946]                   sessionInformation <- function() {
[17:42:19.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.946]                       search = base::search(), system = base::Sys.info())
[17:42:19.946]                   }
[17:42:19.946]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.946]                     cond$call), session = sessionInformation(), 
[17:42:19.946]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.946]                   signalCondition(cond)
[17:42:19.946]                 }
[17:42:19.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.946]                 "immediateCondition"))) {
[17:42:19.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.946]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.946]                   if (TRUE && !signal) {
[17:42:19.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.946]                     {
[17:42:19.946]                       inherits <- base::inherits
[17:42:19.946]                       invokeRestart <- base::invokeRestart
[17:42:19.946]                       is.null <- base::is.null
[17:42:19.946]                       muffled <- FALSE
[17:42:19.946]                       if (inherits(cond, "message")) {
[17:42:19.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.946]                         if (muffled) 
[17:42:19.946]                           invokeRestart("muffleMessage")
[17:42:19.946]                       }
[17:42:19.946]                       else if (inherits(cond, "warning")) {
[17:42:19.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.946]                         if (muffled) 
[17:42:19.946]                           invokeRestart("muffleWarning")
[17:42:19.946]                       }
[17:42:19.946]                       else if (inherits(cond, "condition")) {
[17:42:19.946]                         if (!is.null(pattern)) {
[17:42:19.946]                           computeRestarts <- base::computeRestarts
[17:42:19.946]                           grepl <- base::grepl
[17:42:19.946]                           restarts <- computeRestarts(cond)
[17:42:19.946]                           for (restart in restarts) {
[17:42:19.946]                             name <- restart$name
[17:42:19.946]                             if (is.null(name)) 
[17:42:19.946]                               next
[17:42:19.946]                             if (!grepl(pattern, name)) 
[17:42:19.946]                               next
[17:42:19.946]                             invokeRestart(restart)
[17:42:19.946]                             muffled <- TRUE
[17:42:19.946]                             break
[17:42:19.946]                           }
[17:42:19.946]                         }
[17:42:19.946]                       }
[17:42:19.946]                       invisible(muffled)
[17:42:19.946]                     }
[17:42:19.946]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.946]                   }
[17:42:19.946]                 }
[17:42:19.946]                 else {
[17:42:19.946]                   if (TRUE) {
[17:42:19.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.946]                     {
[17:42:19.946]                       inherits <- base::inherits
[17:42:19.946]                       invokeRestart <- base::invokeRestart
[17:42:19.946]                       is.null <- base::is.null
[17:42:19.946]                       muffled <- FALSE
[17:42:19.946]                       if (inherits(cond, "message")) {
[17:42:19.946]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.946]                         if (muffled) 
[17:42:19.946]                           invokeRestart("muffleMessage")
[17:42:19.946]                       }
[17:42:19.946]                       else if (inherits(cond, "warning")) {
[17:42:19.946]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.946]                         if (muffled) 
[17:42:19.946]                           invokeRestart("muffleWarning")
[17:42:19.946]                       }
[17:42:19.946]                       else if (inherits(cond, "condition")) {
[17:42:19.946]                         if (!is.null(pattern)) {
[17:42:19.946]                           computeRestarts <- base::computeRestarts
[17:42:19.946]                           grepl <- base::grepl
[17:42:19.946]                           restarts <- computeRestarts(cond)
[17:42:19.946]                           for (restart in restarts) {
[17:42:19.946]                             name <- restart$name
[17:42:19.946]                             if (is.null(name)) 
[17:42:19.946]                               next
[17:42:19.946]                             if (!grepl(pattern, name)) 
[17:42:19.946]                               next
[17:42:19.946]                             invokeRestart(restart)
[17:42:19.946]                             muffled <- TRUE
[17:42:19.946]                             break
[17:42:19.946]                           }
[17:42:19.946]                         }
[17:42:19.946]                       }
[17:42:19.946]                       invisible(muffled)
[17:42:19.946]                     }
[17:42:19.946]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.946]                   }
[17:42:19.946]                 }
[17:42:19.946]             }
[17:42:19.946]         }))
[17:42:19.946]     }, error = function(ex) {
[17:42:19.946]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.946]                 ...future.rng), started = ...future.startTime, 
[17:42:19.946]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.946]             version = "1.8"), class = "FutureResult")
[17:42:19.946]     }, finally = {
[17:42:19.946]         if (!identical(...future.workdir, getwd())) 
[17:42:19.946]             setwd(...future.workdir)
[17:42:19.946]         {
[17:42:19.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.946]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.946]             }
[17:42:19.946]             base::options(...future.oldOptions)
[17:42:19.946]             if (.Platform$OS.type == "windows") {
[17:42:19.946]                 old_names <- names(...future.oldEnvVars)
[17:42:19.946]                 envs <- base::Sys.getenv()
[17:42:19.946]                 names <- names(envs)
[17:42:19.946]                 common <- intersect(names, old_names)
[17:42:19.946]                 added <- setdiff(names, old_names)
[17:42:19.946]                 removed <- setdiff(old_names, names)
[17:42:19.946]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.946]                   envs[common]]
[17:42:19.946]                 NAMES <- toupper(changed)
[17:42:19.946]                 args <- list()
[17:42:19.946]                 for (kk in seq_along(NAMES)) {
[17:42:19.946]                   name <- changed[[kk]]
[17:42:19.946]                   NAME <- NAMES[[kk]]
[17:42:19.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.946]                     next
[17:42:19.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.946]                 }
[17:42:19.946]                 NAMES <- toupper(added)
[17:42:19.946]                 for (kk in seq_along(NAMES)) {
[17:42:19.946]                   name <- added[[kk]]
[17:42:19.946]                   NAME <- NAMES[[kk]]
[17:42:19.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.946]                     next
[17:42:19.946]                   args[[name]] <- ""
[17:42:19.946]                 }
[17:42:19.946]                 NAMES <- toupper(removed)
[17:42:19.946]                 for (kk in seq_along(NAMES)) {
[17:42:19.946]                   name <- removed[[kk]]
[17:42:19.946]                   NAME <- NAMES[[kk]]
[17:42:19.946]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.946]                     next
[17:42:19.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.946]                 }
[17:42:19.946]                 if (length(args) > 0) 
[17:42:19.946]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.946]             }
[17:42:19.946]             else {
[17:42:19.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.946]             }
[17:42:19.946]             {
[17:42:19.946]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.946]                   0L) {
[17:42:19.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.946]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.946]                   base::options(opts)
[17:42:19.946]                 }
[17:42:19.946]                 {
[17:42:19.946]                   {
[17:42:19.946]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:19.946]                     NULL
[17:42:19.946]                   }
[17:42:19.946]                   options(future.plan = NULL)
[17:42:19.946]                   if (is.na(NA_character_)) 
[17:42:19.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.946]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:19.946]                     envir = parent.frame()) 
[17:42:19.946]                   {
[17:42:19.946]                     default_workers <- missing(workers)
[17:42:19.946]                     if (is.function(workers)) 
[17:42:19.946]                       workers <- workers()
[17:42:19.946]                     workers <- structure(as.integer(workers), 
[17:42:19.946]                       class = class(workers))
[17:42:19.946]                     stop_if_not(is.finite(workers), workers >= 
[17:42:19.946]                       1L)
[17:42:19.946]                     if ((workers == 1L && !inherits(workers, 
[17:42:19.946]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:19.946]                       if (default_workers) 
[17:42:19.946]                         supportsMulticore(warn = TRUE)
[17:42:19.946]                       return(sequential(..., envir = envir))
[17:42:19.946]                     }
[17:42:19.946]                     oopts <- options(mc.cores = workers)
[17:42:19.946]                     on.exit(options(oopts))
[17:42:19.946]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:19.946]                       envir = envir)
[17:42:19.946]                     if (!future$lazy) 
[17:42:19.946]                       future <- run(future)
[17:42:19.946]                     invisible(future)
[17:42:19.946]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.946]                 }
[17:42:19.946]             }
[17:42:19.946]         }
[17:42:19.946]     })
[17:42:19.946]     if (TRUE) {
[17:42:19.946]         base::sink(type = "output", split = FALSE)
[17:42:19.946]         if (TRUE) {
[17:42:19.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.946]         }
[17:42:19.946]         else {
[17:42:19.946]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.946]         }
[17:42:19.946]         base::close(...future.stdout)
[17:42:19.946]         ...future.stdout <- NULL
[17:42:19.946]     }
[17:42:19.946]     ...future.result$conditions <- ...future.conditions
[17:42:19.946]     ...future.result$finished <- base::Sys.time()
[17:42:19.946]     ...future.result
[17:42:19.946] }
[17:42:19.948] requestCore(): workers = 2
[17:42:19.950] MulticoreFuture started
[17:42:19.951] - Launch lazy future ... done
[17:42:19.951] run() for ‘MulticoreFuture’ ... done
[17:42:19.951] getGlobalsAndPackages() ...
[17:42:19.952] Searching for globals...
[17:42:19.952] plan(): Setting new future strategy stack:
[17:42:19.953] 
[17:42:19.952] List of future strategies:
[17:42:19.952] 1. sequential:
[17:42:19.952]    - args: function (..., envir = parent.frame())
[17:42:19.952]    - tweaked: FALSE
[17:42:19.952]    - call: NULL
[17:42:19.953] Searching for globals ... DONE
[17:42:19.953] - globals: [0] <none>
[17:42:19.953] plan(): nbrOfWorkers() = 1
[17:42:19.953] getGlobalsAndPackages() ... DONE
[17:42:19.954] run() for ‘Future’ ...
[17:42:19.954] - state: ‘created’
[17:42:19.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:19.955] plan(): Setting new future strategy stack:
[17:42:19.955] List of future strategies:
[17:42:19.955] 1. multicore:
[17:42:19.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.955]    - tweaked: FALSE
[17:42:19.955]    - call: plan(strategy)
[17:42:19.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:19.960] plan(): nbrOfWorkers() = 2
[17:42:19.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:19.960]   - Field: ‘label’
[17:42:19.960]   - Field: ‘local’
[17:42:19.960]   - Field: ‘owner’
[17:42:19.960]   - Field: ‘envir’
[17:42:19.961]   - Field: ‘workers’
[17:42:19.961]   - Field: ‘packages’
[17:42:19.961]   - Field: ‘gc’
[17:42:19.961]   - Field: ‘job’
[17:42:19.961]   - Field: ‘conditions’
[17:42:19.961]   - Field: ‘expr’
[17:42:19.961]   - Field: ‘uuid’
[17:42:19.962]   - Field: ‘seed’
[17:42:19.962]   - Field: ‘version’
[17:42:19.962]   - Field: ‘result’
[17:42:19.962]   - Field: ‘asynchronous’
[17:42:19.962]   - Field: ‘calls’
[17:42:19.962]   - Field: ‘globals’
[17:42:19.963]   - Field: ‘stdout’
[17:42:19.963]   - Field: ‘earlySignal’
[17:42:19.963]   - Field: ‘lazy’
[17:42:19.963]   - Field: ‘state’
[17:42:19.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:19.963] - Launch lazy future ...
[17:42:19.964] Packages needed by the future expression (n = 0): <none>
[17:42:19.964] Packages needed by future strategies (n = 0): <none>
[17:42:19.965] {
[17:42:19.965]     {
[17:42:19.965]         {
[17:42:19.965]             ...future.startTime <- base::Sys.time()
[17:42:19.965]             {
[17:42:19.965]                 {
[17:42:19.965]                   {
[17:42:19.965]                     {
[17:42:19.965]                       base::local({
[17:42:19.965]                         has_future <- base::requireNamespace("future", 
[17:42:19.965]                           quietly = TRUE)
[17:42:19.965]                         if (has_future) {
[17:42:19.965]                           ns <- base::getNamespace("future")
[17:42:19.965]                           version <- ns[[".package"]][["version"]]
[17:42:19.965]                           if (is.null(version)) 
[17:42:19.965]                             version <- utils::packageVersion("future")
[17:42:19.965]                         }
[17:42:19.965]                         else {
[17:42:19.965]                           version <- NULL
[17:42:19.965]                         }
[17:42:19.965]                         if (!has_future || version < "1.8.0") {
[17:42:19.965]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:19.965]                             "", base::R.version$version.string), 
[17:42:19.965]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:19.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:19.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:19.965]                               "release", "version")], collapse = " "), 
[17:42:19.965]                             hostname = base::Sys.info()[["nodename"]])
[17:42:19.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:19.965]                             info)
[17:42:19.965]                           info <- base::paste(info, collapse = "; ")
[17:42:19.965]                           if (!has_future) {
[17:42:19.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:19.965]                               info)
[17:42:19.965]                           }
[17:42:19.965]                           else {
[17:42:19.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:19.965]                               info, version)
[17:42:19.965]                           }
[17:42:19.965]                           base::stop(msg)
[17:42:19.965]                         }
[17:42:19.965]                       })
[17:42:19.965]                     }
[17:42:19.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:19.965]                     base::options(mc.cores = 1L)
[17:42:19.965]                   }
[17:42:19.965]                   options(future.plan = NULL)
[17:42:19.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:19.965]                 }
[17:42:19.965]                 ...future.workdir <- getwd()
[17:42:19.965]             }
[17:42:19.965]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:19.965]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:19.965]         }
[17:42:19.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:19.965]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:19.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:19.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:19.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:19.965]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:19.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:19.965]             base::names(...future.oldOptions))
[17:42:19.965]     }
[17:42:19.965]     if (FALSE) {
[17:42:19.965]     }
[17:42:19.965]     else {
[17:42:19.965]         if (TRUE) {
[17:42:19.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:19.965]                 open = "w")
[17:42:19.965]         }
[17:42:19.965]         else {
[17:42:19.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:19.965]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:19.965]         }
[17:42:19.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:19.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:19.965]             base::sink(type = "output", split = FALSE)
[17:42:19.965]             base::close(...future.stdout)
[17:42:19.965]         }, add = TRUE)
[17:42:19.965]     }
[17:42:19.965]     ...future.frame <- base::sys.nframe()
[17:42:19.965]     ...future.conditions <- base::list()
[17:42:19.965]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:19.965]     if (FALSE) {
[17:42:19.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:19.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:19.965]     }
[17:42:19.965]     ...future.result <- base::tryCatch({
[17:42:19.965]         base::withCallingHandlers({
[17:42:19.965]             ...future.value <- base::withVisible(base::local({
[17:42:19.965]                 withCallingHandlers({
[17:42:19.965]                   NULL
[17:42:19.965]                 }, immediateCondition = function(cond) {
[17:42:19.965]                   save_rds <- function (object, pathname, ...) 
[17:42:19.965]                   {
[17:42:19.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:19.965]                     if (file_test("-f", pathname_tmp)) {
[17:42:19.965]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:19.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.965]                         fi_tmp[["mtime"]])
[17:42:19.965]                     }
[17:42:19.965]                     tryCatch({
[17:42:19.965]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:19.965]                     }, error = function(ex) {
[17:42:19.965]                       msg <- conditionMessage(ex)
[17:42:19.965]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:19.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.965]                         fi_tmp[["mtime"]], msg)
[17:42:19.965]                       ex$message <- msg
[17:42:19.965]                       stop(ex)
[17:42:19.965]                     })
[17:42:19.965]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:19.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:19.965]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:19.965]                       fi_tmp <- file.info(pathname_tmp)
[17:42:19.965]                       fi <- file.info(pathname)
[17:42:19.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:19.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:19.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:19.965]                         fi[["size"]], fi[["mtime"]])
[17:42:19.965]                       stop(msg)
[17:42:19.965]                     }
[17:42:19.965]                     invisible(pathname)
[17:42:19.965]                   }
[17:42:19.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:19.965]                     rootPath = tempdir()) 
[17:42:19.965]                   {
[17:42:19.965]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:19.965]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:19.965]                       tmpdir = path, fileext = ".rds")
[17:42:19.965]                     save_rds(obj, file)
[17:42:19.965]                   }
[17:42:19.965]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:19.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.965]                   {
[17:42:19.965]                     inherits <- base::inherits
[17:42:19.965]                     invokeRestart <- base::invokeRestart
[17:42:19.965]                     is.null <- base::is.null
[17:42:19.965]                     muffled <- FALSE
[17:42:19.965]                     if (inherits(cond, "message")) {
[17:42:19.965]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:19.965]                       if (muffled) 
[17:42:19.965]                         invokeRestart("muffleMessage")
[17:42:19.965]                     }
[17:42:19.965]                     else if (inherits(cond, "warning")) {
[17:42:19.965]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:19.965]                       if (muffled) 
[17:42:19.965]                         invokeRestart("muffleWarning")
[17:42:19.965]                     }
[17:42:19.965]                     else if (inherits(cond, "condition")) {
[17:42:19.965]                       if (!is.null(pattern)) {
[17:42:19.965]                         computeRestarts <- base::computeRestarts
[17:42:19.965]                         grepl <- base::grepl
[17:42:19.965]                         restarts <- computeRestarts(cond)
[17:42:19.965]                         for (restart in restarts) {
[17:42:19.965]                           name <- restart$name
[17:42:19.965]                           if (is.null(name)) 
[17:42:19.965]                             next
[17:42:19.965]                           if (!grepl(pattern, name)) 
[17:42:19.965]                             next
[17:42:19.965]                           invokeRestart(restart)
[17:42:19.965]                           muffled <- TRUE
[17:42:19.965]                           break
[17:42:19.965]                         }
[17:42:19.965]                       }
[17:42:19.965]                     }
[17:42:19.965]                     invisible(muffled)
[17:42:19.965]                   }
[17:42:19.965]                   muffleCondition(cond)
[17:42:19.965]                 })
[17:42:19.965]             }))
[17:42:19.965]             future::FutureResult(value = ...future.value$value, 
[17:42:19.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.965]                   ...future.rng), globalenv = if (FALSE) 
[17:42:19.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:19.965]                     ...future.globalenv.names))
[17:42:19.965]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:19.965]         }, condition = base::local({
[17:42:19.965]             c <- base::c
[17:42:19.965]             inherits <- base::inherits
[17:42:19.965]             invokeRestart <- base::invokeRestart
[17:42:19.965]             length <- base::length
[17:42:19.965]             list <- base::list
[17:42:19.965]             seq.int <- base::seq.int
[17:42:19.965]             signalCondition <- base::signalCondition
[17:42:19.965]             sys.calls <- base::sys.calls
[17:42:19.965]             `[[` <- base::`[[`
[17:42:19.965]             `+` <- base::`+`
[17:42:19.965]             `<<-` <- base::`<<-`
[17:42:19.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:19.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:19.965]                   3L)]
[17:42:19.965]             }
[17:42:19.965]             function(cond) {
[17:42:19.965]                 is_error <- inherits(cond, "error")
[17:42:19.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:19.965]                   NULL)
[17:42:19.965]                 if (is_error) {
[17:42:19.965]                   sessionInformation <- function() {
[17:42:19.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:19.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:19.965]                       search = base::search(), system = base::Sys.info())
[17:42:19.965]                   }
[17:42:19.965]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:19.965]                     cond$call), session = sessionInformation(), 
[17:42:19.965]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:19.965]                   signalCondition(cond)
[17:42:19.965]                 }
[17:42:19.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:19.965]                 "immediateCondition"))) {
[17:42:19.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:19.965]                   ...future.conditions[[length(...future.conditions) + 
[17:42:19.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:19.965]                   if (TRUE && !signal) {
[17:42:19.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.965]                     {
[17:42:19.965]                       inherits <- base::inherits
[17:42:19.965]                       invokeRestart <- base::invokeRestart
[17:42:19.965]                       is.null <- base::is.null
[17:42:19.965]                       muffled <- FALSE
[17:42:19.965]                       if (inherits(cond, "message")) {
[17:42:19.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.965]                         if (muffled) 
[17:42:19.965]                           invokeRestart("muffleMessage")
[17:42:19.965]                       }
[17:42:19.965]                       else if (inherits(cond, "warning")) {
[17:42:19.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.965]                         if (muffled) 
[17:42:19.965]                           invokeRestart("muffleWarning")
[17:42:19.965]                       }
[17:42:19.965]                       else if (inherits(cond, "condition")) {
[17:42:19.965]                         if (!is.null(pattern)) {
[17:42:19.965]                           computeRestarts <- base::computeRestarts
[17:42:19.965]                           grepl <- base::grepl
[17:42:19.965]                           restarts <- computeRestarts(cond)
[17:42:19.965]                           for (restart in restarts) {
[17:42:19.965]                             name <- restart$name
[17:42:19.965]                             if (is.null(name)) 
[17:42:19.965]                               next
[17:42:19.965]                             if (!grepl(pattern, name)) 
[17:42:19.965]                               next
[17:42:19.965]                             invokeRestart(restart)
[17:42:19.965]                             muffled <- TRUE
[17:42:19.965]                             break
[17:42:19.965]                           }
[17:42:19.965]                         }
[17:42:19.965]                       }
[17:42:19.965]                       invisible(muffled)
[17:42:19.965]                     }
[17:42:19.965]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.965]                   }
[17:42:19.965]                 }
[17:42:19.965]                 else {
[17:42:19.965]                   if (TRUE) {
[17:42:19.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:19.965]                     {
[17:42:19.965]                       inherits <- base::inherits
[17:42:19.965]                       invokeRestart <- base::invokeRestart
[17:42:19.965]                       is.null <- base::is.null
[17:42:19.965]                       muffled <- FALSE
[17:42:19.965]                       if (inherits(cond, "message")) {
[17:42:19.965]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:19.965]                         if (muffled) 
[17:42:19.965]                           invokeRestart("muffleMessage")
[17:42:19.965]                       }
[17:42:19.965]                       else if (inherits(cond, "warning")) {
[17:42:19.965]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:19.965]                         if (muffled) 
[17:42:19.965]                           invokeRestart("muffleWarning")
[17:42:19.965]                       }
[17:42:19.965]                       else if (inherits(cond, "condition")) {
[17:42:19.965]                         if (!is.null(pattern)) {
[17:42:19.965]                           computeRestarts <- base::computeRestarts
[17:42:19.965]                           grepl <- base::grepl
[17:42:19.965]                           restarts <- computeRestarts(cond)
[17:42:19.965]                           for (restart in restarts) {
[17:42:19.965]                             name <- restart$name
[17:42:19.965]                             if (is.null(name)) 
[17:42:19.965]                               next
[17:42:19.965]                             if (!grepl(pattern, name)) 
[17:42:19.965]                               next
[17:42:19.965]                             invokeRestart(restart)
[17:42:19.965]                             muffled <- TRUE
[17:42:19.965]                             break
[17:42:19.965]                           }
[17:42:19.965]                         }
[17:42:19.965]                       }
[17:42:19.965]                       invisible(muffled)
[17:42:19.965]                     }
[17:42:19.965]                     muffleCondition(cond, pattern = "^muffle")
[17:42:19.965]                   }
[17:42:19.965]                 }
[17:42:19.965]             }
[17:42:19.965]         }))
[17:42:19.965]     }, error = function(ex) {
[17:42:19.965]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:19.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:19.965]                 ...future.rng), started = ...future.startTime, 
[17:42:19.965]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:19.965]             version = "1.8"), class = "FutureResult")
[17:42:19.965]     }, finally = {
[17:42:19.965]         if (!identical(...future.workdir, getwd())) 
[17:42:19.965]             setwd(...future.workdir)
[17:42:19.965]         {
[17:42:19.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:19.965]                 ...future.oldOptions$nwarnings <- NULL
[17:42:19.965]             }
[17:42:19.965]             base::options(...future.oldOptions)
[17:42:19.965]             if (.Platform$OS.type == "windows") {
[17:42:19.965]                 old_names <- names(...future.oldEnvVars)
[17:42:19.965]                 envs <- base::Sys.getenv()
[17:42:19.965]                 names <- names(envs)
[17:42:19.965]                 common <- intersect(names, old_names)
[17:42:19.965]                 added <- setdiff(names, old_names)
[17:42:19.965]                 removed <- setdiff(old_names, names)
[17:42:19.965]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:19.965]                   envs[common]]
[17:42:19.965]                 NAMES <- toupper(changed)
[17:42:19.965]                 args <- list()
[17:42:19.965]                 for (kk in seq_along(NAMES)) {
[17:42:19.965]                   name <- changed[[kk]]
[17:42:19.965]                   NAME <- NAMES[[kk]]
[17:42:19.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.965]                     next
[17:42:19.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.965]                 }
[17:42:19.965]                 NAMES <- toupper(added)
[17:42:19.965]                 for (kk in seq_along(NAMES)) {
[17:42:19.965]                   name <- added[[kk]]
[17:42:19.965]                   NAME <- NAMES[[kk]]
[17:42:19.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.965]                     next
[17:42:19.965]                   args[[name]] <- ""
[17:42:19.965]                 }
[17:42:19.965]                 NAMES <- toupper(removed)
[17:42:19.965]                 for (kk in seq_along(NAMES)) {
[17:42:19.965]                   name <- removed[[kk]]
[17:42:19.965]                   NAME <- NAMES[[kk]]
[17:42:19.965]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:19.965]                     next
[17:42:19.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:19.965]                 }
[17:42:19.965]                 if (length(args) > 0) 
[17:42:19.965]                   base::do.call(base::Sys.setenv, args = args)
[17:42:19.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:19.965]             }
[17:42:19.965]             else {
[17:42:19.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:19.965]             }
[17:42:19.965]             {
[17:42:19.965]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:19.965]                   0L) {
[17:42:19.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:19.965]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:19.965]                   base::options(opts)
[17:42:19.965]                 }
[17:42:19.965]                 {
[17:42:19.965]                   {
[17:42:19.965]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:19.965]                     NULL
[17:42:19.965]                   }
[17:42:19.965]                   options(future.plan = NULL)
[17:42:19.965]                   if (is.na(NA_character_)) 
[17:42:19.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:19.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:19.965]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:19.965]                     envir = parent.frame()) 
[17:42:19.965]                   {
[17:42:19.965]                     default_workers <- missing(workers)
[17:42:19.965]                     if (is.function(workers)) 
[17:42:19.965]                       workers <- workers()
[17:42:19.965]                     workers <- structure(as.integer(workers), 
[17:42:19.965]                       class = class(workers))
[17:42:19.965]                     stop_if_not(is.finite(workers), workers >= 
[17:42:19.965]                       1L)
[17:42:19.965]                     if ((workers == 1L && !inherits(workers, 
[17:42:19.965]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:19.965]                       if (default_workers) 
[17:42:19.965]                         supportsMulticore(warn = TRUE)
[17:42:19.965]                       return(sequential(..., envir = envir))
[17:42:19.965]                     }
[17:42:19.965]                     oopts <- options(mc.cores = workers)
[17:42:19.965]                     on.exit(options(oopts))
[17:42:19.965]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:19.965]                       envir = envir)
[17:42:19.965]                     if (!future$lazy) 
[17:42:19.965]                       future <- run(future)
[17:42:19.965]                     invisible(future)
[17:42:19.965]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:19.965]                 }
[17:42:19.965]             }
[17:42:19.965]         }
[17:42:19.965]     })
[17:42:19.965]     if (TRUE) {
[17:42:19.965]         base::sink(type = "output", split = FALSE)
[17:42:19.965]         if (TRUE) {
[17:42:19.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:19.965]         }
[17:42:19.965]         else {
[17:42:19.965]             ...future.result["stdout"] <- base::list(NULL)
[17:42:19.965]         }
[17:42:19.965]         base::close(...future.stdout)
[17:42:19.965]         ...future.stdout <- NULL
[17:42:19.965]     }
[17:42:19.965]     ...future.result$conditions <- ...future.conditions
[17:42:19.965]     ...future.result$finished <- base::Sys.time()
[17:42:19.965]     ...future.result
[17:42:19.965] }
[17:42:19.969] requestCore(): workers = 2
[17:42:19.971] MulticoreFuture started
[17:42:19.972] - Launch lazy future ... done
[17:42:19.972] run() for ‘MulticoreFuture’ ... done
List of 6
[17:42:19.973] plan(): Setting new future strategy stack:
 $ a:[17:42:19.973] List of future strategies:
[17:42:19.973] 1. sequential:
[17:42:19.973]    - args: function (..., envir = parent.frame())
[17:42:19.973]    - tweaked: FALSE
[17:42:19.973]    - call: NULL
 num 1
 $ b:[17:42:19.974] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7581778> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7908b60> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:42:19.976] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:42:19.976] List of future strategies:
[17:42:19.976] 1. multicore:
[17:42:19.976]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:19.976]    - tweaked: FALSE
[17:42:19.976]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7581778> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7908b60> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:42:19.981] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:19.984] resolve() on list ...
[17:42:19.984]  recursive: 0
[17:42:19.984]  length: 6
[17:42:19.984]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:19.984] signalConditionsASAP(numeric, pos=1) ...
[17:42:19.985] - nx: 6
[17:42:19.985] - relay: TRUE
[17:42:19.985] - stdout: TRUE
[17:42:19.985] - signal: TRUE
[17:42:19.985] - resignal: FALSE
[17:42:19.985] - force: TRUE
[17:42:19.985] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.985] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.986]  - until=2
[17:42:19.986]  - relaying element #2
[17:42:19.986] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.986] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.986] signalConditionsASAP(NULL, pos=1) ... done
[17:42:19.986]  length: 5 (resolved future 1)
[17:42:19.987] Future #2
[17:42:19.988] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:19.988] - nx: 6
[17:42:19.992] - relay: TRUE
[17:42:19.992] - stdout: TRUE
[17:42:19.992] - signal: TRUE
[17:42:19.992] - resignal: FALSE
[17:42:19.993] - force: TRUE
[17:42:19.993] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.993] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:19.993]  - until=2
[17:42:19.993]  - relaying element #2
[17:42:19.994] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.994] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.994] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:19.995]  length: 4 (resolved future 2)
[17:42:19.995] Future #3
[17:42:19.996] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:19.996] - nx: 6
[17:42:19.996] - relay: TRUE
[17:42:19.997] - stdout: TRUE
[17:42:19.997] - signal: TRUE
[17:42:19.997] - resignal: FALSE
[17:42:19.997] - force: TRUE
[17:42:19.997] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.997] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:19.997]  - until=3
[17:42:19.997]  - relaying element #3
[17:42:19.998] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.998] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.998] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:19.998]  length: 3 (resolved future 3)
[17:42:19.998] signalConditionsASAP(NULL, pos=4) ...
[17:42:19.998] - nx: 6
[17:42:19.998] - relay: TRUE
[17:42:19.999] - stdout: TRUE
[17:42:19.999] - signal: TRUE
[17:42:19.999] - resignal: FALSE
[17:42:19.999] - force: TRUE
[17:42:19.999] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.999] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:19.999]  - until=5
[17:42:20.000]  - relaying element #5
[17:42:20.000] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.000] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.000] signalConditionsASAP(NULL, pos=4) ... done
[17:42:20.000]  length: 2 (resolved future 4)
[17:42:20.000] signalConditionsASAP(NULL, pos=5) ...
[17:42:20.000] - nx: 6
[17:42:20.000] - relay: TRUE
[17:42:20.000] - stdout: TRUE
[17:42:20.001] - signal: TRUE
[17:42:20.001] - resignal: FALSE
[17:42:20.001] - force: TRUE
[17:42:20.001] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.001] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.001]  - until=6
[17:42:20.001]  - relaying element #6
[17:42:20.001] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.001] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.002] signalConditionsASAP(NULL, pos=5) ... done
[17:42:20.002]  length: 1 (resolved future 5)
[17:42:20.002] signalConditionsASAP(numeric, pos=6) ...
[17:42:20.002] - nx: 6
[17:42:20.002] - relay: TRUE
[17:42:20.002] - stdout: TRUE
[17:42:20.002] - signal: TRUE
[17:42:20.002] - resignal: FALSE
[17:42:20.002] - force: TRUE
[17:42:20.002] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.003]  - until=6
[17:42:20.003] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.003] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.003] signalConditionsASAP(numeric, pos=6) ... done
[17:42:20.003]  length: 0 (resolved future 6)
[17:42:20.003] Relaying remaining futures
[17:42:20.003] signalConditionsASAP(NULL, pos=0) ...
[17:42:20.003] - nx: 6
[17:42:20.004] - relay: TRUE
[17:42:20.004] - stdout: TRUE
[17:42:20.004] - signal: TRUE
[17:42:20.004] - resignal: FALSE
[17:42:20.004] - force: TRUE
[17:42:20.004] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.004] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:20.004] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.004] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.005] signalConditionsASAP(NULL, pos=0) ... done
[17:42:20.005] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:42:20.009] getGlobalsAndPackages() ...
[17:42:20.009] Searching for globals...
[17:42:20.009] 
[17:42:20.009] Searching for globals ... DONE
[17:42:20.009] - globals: [0] <none>
[17:42:20.009] getGlobalsAndPackages() ... DONE
[17:42:20.010] run() for ‘Future’ ...
[17:42:20.010] - state: ‘created’
[17:42:20.010] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.015] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:20.015]   - Field: ‘label’
[17:42:20.015]   - Field: ‘local’
[17:42:20.015]   - Field: ‘owner’
[17:42:20.015]   - Field: ‘envir’
[17:42:20.015]   - Field: ‘workers’
[17:42:20.015]   - Field: ‘packages’
[17:42:20.016]   - Field: ‘gc’
[17:42:20.016]   - Field: ‘job’
[17:42:20.016]   - Field: ‘conditions’
[17:42:20.016]   - Field: ‘expr’
[17:42:20.016]   - Field: ‘uuid’
[17:42:20.016]   - Field: ‘seed’
[17:42:20.016]   - Field: ‘version’
[17:42:20.016]   - Field: ‘result’
[17:42:20.016]   - Field: ‘asynchronous’
[17:42:20.016]   - Field: ‘calls’
[17:42:20.017]   - Field: ‘globals’
[17:42:20.017]   - Field: ‘stdout’
[17:42:20.017]   - Field: ‘earlySignal’
[17:42:20.017]   - Field: ‘lazy’
[17:42:20.017]   - Field: ‘state’
[17:42:20.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:20.017] - Launch lazy future ...
[17:42:20.017] Packages needed by the future expression (n = 0): <none>
[17:42:20.018] Packages needed by future strategies (n = 0): <none>
[17:42:20.018] {
[17:42:20.018]     {
[17:42:20.018]         {
[17:42:20.018]             ...future.startTime <- base::Sys.time()
[17:42:20.018]             {
[17:42:20.018]                 {
[17:42:20.018]                   {
[17:42:20.018]                     {
[17:42:20.018]                       base::local({
[17:42:20.018]                         has_future <- base::requireNamespace("future", 
[17:42:20.018]                           quietly = TRUE)
[17:42:20.018]                         if (has_future) {
[17:42:20.018]                           ns <- base::getNamespace("future")
[17:42:20.018]                           version <- ns[[".package"]][["version"]]
[17:42:20.018]                           if (is.null(version)) 
[17:42:20.018]                             version <- utils::packageVersion("future")
[17:42:20.018]                         }
[17:42:20.018]                         else {
[17:42:20.018]                           version <- NULL
[17:42:20.018]                         }
[17:42:20.018]                         if (!has_future || version < "1.8.0") {
[17:42:20.018]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.018]                             "", base::R.version$version.string), 
[17:42:20.018]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.018]                               "release", "version")], collapse = " "), 
[17:42:20.018]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.018]                             info)
[17:42:20.018]                           info <- base::paste(info, collapse = "; ")
[17:42:20.018]                           if (!has_future) {
[17:42:20.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.018]                               info)
[17:42:20.018]                           }
[17:42:20.018]                           else {
[17:42:20.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.018]                               info, version)
[17:42:20.018]                           }
[17:42:20.018]                           base::stop(msg)
[17:42:20.018]                         }
[17:42:20.018]                       })
[17:42:20.018]                     }
[17:42:20.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.018]                     base::options(mc.cores = 1L)
[17:42:20.018]                   }
[17:42:20.018]                   options(future.plan = NULL)
[17:42:20.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.018]                 }
[17:42:20.018]                 ...future.workdir <- getwd()
[17:42:20.018]             }
[17:42:20.018]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.018]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.018]         }
[17:42:20.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.018]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.018]             base::names(...future.oldOptions))
[17:42:20.018]     }
[17:42:20.018]     if (FALSE) {
[17:42:20.018]     }
[17:42:20.018]     else {
[17:42:20.018]         if (TRUE) {
[17:42:20.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.018]                 open = "w")
[17:42:20.018]         }
[17:42:20.018]         else {
[17:42:20.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.018]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.018]         }
[17:42:20.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.018]             base::sink(type = "output", split = FALSE)
[17:42:20.018]             base::close(...future.stdout)
[17:42:20.018]         }, add = TRUE)
[17:42:20.018]     }
[17:42:20.018]     ...future.frame <- base::sys.nframe()
[17:42:20.018]     ...future.conditions <- base::list()
[17:42:20.018]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.018]     if (FALSE) {
[17:42:20.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.018]     }
[17:42:20.018]     ...future.result <- base::tryCatch({
[17:42:20.018]         base::withCallingHandlers({
[17:42:20.018]             ...future.value <- base::withVisible(base::local({
[17:42:20.018]                 withCallingHandlers({
[17:42:20.018]                   2
[17:42:20.018]                 }, immediateCondition = function(cond) {
[17:42:20.018]                   save_rds <- function (object, pathname, ...) 
[17:42:20.018]                   {
[17:42:20.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:20.018]                     if (file_test("-f", pathname_tmp)) {
[17:42:20.018]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:20.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.018]                         fi_tmp[["mtime"]])
[17:42:20.018]                     }
[17:42:20.018]                     tryCatch({
[17:42:20.018]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:20.018]                     }, error = function(ex) {
[17:42:20.018]                       msg <- conditionMessage(ex)
[17:42:20.018]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:20.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.018]                         fi_tmp[["mtime"]], msg)
[17:42:20.018]                       ex$message <- msg
[17:42:20.018]                       stop(ex)
[17:42:20.018]                     })
[17:42:20.018]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:20.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:20.018]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:20.018]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.018]                       fi <- file.info(pathname)
[17:42:20.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:20.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:20.018]                         fi[["size"]], fi[["mtime"]])
[17:42:20.018]                       stop(msg)
[17:42:20.018]                     }
[17:42:20.018]                     invisible(pathname)
[17:42:20.018]                   }
[17:42:20.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:20.018]                     rootPath = tempdir()) 
[17:42:20.018]                   {
[17:42:20.018]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:20.018]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:20.018]                       tmpdir = path, fileext = ".rds")
[17:42:20.018]                     save_rds(obj, file)
[17:42:20.018]                   }
[17:42:20.018]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:20.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.018]                   {
[17:42:20.018]                     inherits <- base::inherits
[17:42:20.018]                     invokeRestart <- base::invokeRestart
[17:42:20.018]                     is.null <- base::is.null
[17:42:20.018]                     muffled <- FALSE
[17:42:20.018]                     if (inherits(cond, "message")) {
[17:42:20.018]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.018]                       if (muffled) 
[17:42:20.018]                         invokeRestart("muffleMessage")
[17:42:20.018]                     }
[17:42:20.018]                     else if (inherits(cond, "warning")) {
[17:42:20.018]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.018]                       if (muffled) 
[17:42:20.018]                         invokeRestart("muffleWarning")
[17:42:20.018]                     }
[17:42:20.018]                     else if (inherits(cond, "condition")) {
[17:42:20.018]                       if (!is.null(pattern)) {
[17:42:20.018]                         computeRestarts <- base::computeRestarts
[17:42:20.018]                         grepl <- base::grepl
[17:42:20.018]                         restarts <- computeRestarts(cond)
[17:42:20.018]                         for (restart in restarts) {
[17:42:20.018]                           name <- restart$name
[17:42:20.018]                           if (is.null(name)) 
[17:42:20.018]                             next
[17:42:20.018]                           if (!grepl(pattern, name)) 
[17:42:20.018]                             next
[17:42:20.018]                           invokeRestart(restart)
[17:42:20.018]                           muffled <- TRUE
[17:42:20.018]                           break
[17:42:20.018]                         }
[17:42:20.018]                       }
[17:42:20.018]                     }
[17:42:20.018]                     invisible(muffled)
[17:42:20.018]                   }
[17:42:20.018]                   muffleCondition(cond)
[17:42:20.018]                 })
[17:42:20.018]             }))
[17:42:20.018]             future::FutureResult(value = ...future.value$value, 
[17:42:20.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.018]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.018]                     ...future.globalenv.names))
[17:42:20.018]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.018]         }, condition = base::local({
[17:42:20.018]             c <- base::c
[17:42:20.018]             inherits <- base::inherits
[17:42:20.018]             invokeRestart <- base::invokeRestart
[17:42:20.018]             length <- base::length
[17:42:20.018]             list <- base::list
[17:42:20.018]             seq.int <- base::seq.int
[17:42:20.018]             signalCondition <- base::signalCondition
[17:42:20.018]             sys.calls <- base::sys.calls
[17:42:20.018]             `[[` <- base::`[[`
[17:42:20.018]             `+` <- base::`+`
[17:42:20.018]             `<<-` <- base::`<<-`
[17:42:20.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.018]                   3L)]
[17:42:20.018]             }
[17:42:20.018]             function(cond) {
[17:42:20.018]                 is_error <- inherits(cond, "error")
[17:42:20.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.018]                   NULL)
[17:42:20.018]                 if (is_error) {
[17:42:20.018]                   sessionInformation <- function() {
[17:42:20.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.018]                       search = base::search(), system = base::Sys.info())
[17:42:20.018]                   }
[17:42:20.018]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.018]                     cond$call), session = sessionInformation(), 
[17:42:20.018]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.018]                   signalCondition(cond)
[17:42:20.018]                 }
[17:42:20.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.018]                 "immediateCondition"))) {
[17:42:20.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.018]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.018]                   if (TRUE && !signal) {
[17:42:20.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.018]                     {
[17:42:20.018]                       inherits <- base::inherits
[17:42:20.018]                       invokeRestart <- base::invokeRestart
[17:42:20.018]                       is.null <- base::is.null
[17:42:20.018]                       muffled <- FALSE
[17:42:20.018]                       if (inherits(cond, "message")) {
[17:42:20.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.018]                         if (muffled) 
[17:42:20.018]                           invokeRestart("muffleMessage")
[17:42:20.018]                       }
[17:42:20.018]                       else if (inherits(cond, "warning")) {
[17:42:20.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.018]                         if (muffled) 
[17:42:20.018]                           invokeRestart("muffleWarning")
[17:42:20.018]                       }
[17:42:20.018]                       else if (inherits(cond, "condition")) {
[17:42:20.018]                         if (!is.null(pattern)) {
[17:42:20.018]                           computeRestarts <- base::computeRestarts
[17:42:20.018]                           grepl <- base::grepl
[17:42:20.018]                           restarts <- computeRestarts(cond)
[17:42:20.018]                           for (restart in restarts) {
[17:42:20.018]                             name <- restart$name
[17:42:20.018]                             if (is.null(name)) 
[17:42:20.018]                               next
[17:42:20.018]                             if (!grepl(pattern, name)) 
[17:42:20.018]                               next
[17:42:20.018]                             invokeRestart(restart)
[17:42:20.018]                             muffled <- TRUE
[17:42:20.018]                             break
[17:42:20.018]                           }
[17:42:20.018]                         }
[17:42:20.018]                       }
[17:42:20.018]                       invisible(muffled)
[17:42:20.018]                     }
[17:42:20.018]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.018]                   }
[17:42:20.018]                 }
[17:42:20.018]                 else {
[17:42:20.018]                   if (TRUE) {
[17:42:20.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.018]                     {
[17:42:20.018]                       inherits <- base::inherits
[17:42:20.018]                       invokeRestart <- base::invokeRestart
[17:42:20.018]                       is.null <- base::is.null
[17:42:20.018]                       muffled <- FALSE
[17:42:20.018]                       if (inherits(cond, "message")) {
[17:42:20.018]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.018]                         if (muffled) 
[17:42:20.018]                           invokeRestart("muffleMessage")
[17:42:20.018]                       }
[17:42:20.018]                       else if (inherits(cond, "warning")) {
[17:42:20.018]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.018]                         if (muffled) 
[17:42:20.018]                           invokeRestart("muffleWarning")
[17:42:20.018]                       }
[17:42:20.018]                       else if (inherits(cond, "condition")) {
[17:42:20.018]                         if (!is.null(pattern)) {
[17:42:20.018]                           computeRestarts <- base::computeRestarts
[17:42:20.018]                           grepl <- base::grepl
[17:42:20.018]                           restarts <- computeRestarts(cond)
[17:42:20.018]                           for (restart in restarts) {
[17:42:20.018]                             name <- restart$name
[17:42:20.018]                             if (is.null(name)) 
[17:42:20.018]                               next
[17:42:20.018]                             if (!grepl(pattern, name)) 
[17:42:20.018]                               next
[17:42:20.018]                             invokeRestart(restart)
[17:42:20.018]                             muffled <- TRUE
[17:42:20.018]                             break
[17:42:20.018]                           }
[17:42:20.018]                         }
[17:42:20.018]                       }
[17:42:20.018]                       invisible(muffled)
[17:42:20.018]                     }
[17:42:20.018]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.018]                   }
[17:42:20.018]                 }
[17:42:20.018]             }
[17:42:20.018]         }))
[17:42:20.018]     }, error = function(ex) {
[17:42:20.018]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.018]                 ...future.rng), started = ...future.startTime, 
[17:42:20.018]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.018]             version = "1.8"), class = "FutureResult")
[17:42:20.018]     }, finally = {
[17:42:20.018]         if (!identical(...future.workdir, getwd())) 
[17:42:20.018]             setwd(...future.workdir)
[17:42:20.018]         {
[17:42:20.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.018]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.018]             }
[17:42:20.018]             base::options(...future.oldOptions)
[17:42:20.018]             if (.Platform$OS.type == "windows") {
[17:42:20.018]                 old_names <- names(...future.oldEnvVars)
[17:42:20.018]                 envs <- base::Sys.getenv()
[17:42:20.018]                 names <- names(envs)
[17:42:20.018]                 common <- intersect(names, old_names)
[17:42:20.018]                 added <- setdiff(names, old_names)
[17:42:20.018]                 removed <- setdiff(old_names, names)
[17:42:20.018]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.018]                   envs[common]]
[17:42:20.018]                 NAMES <- toupper(changed)
[17:42:20.018]                 args <- list()
[17:42:20.018]                 for (kk in seq_along(NAMES)) {
[17:42:20.018]                   name <- changed[[kk]]
[17:42:20.018]                   NAME <- NAMES[[kk]]
[17:42:20.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.018]                     next
[17:42:20.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.018]                 }
[17:42:20.018]                 NAMES <- toupper(added)
[17:42:20.018]                 for (kk in seq_along(NAMES)) {
[17:42:20.018]                   name <- added[[kk]]
[17:42:20.018]                   NAME <- NAMES[[kk]]
[17:42:20.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.018]                     next
[17:42:20.018]                   args[[name]] <- ""
[17:42:20.018]                 }
[17:42:20.018]                 NAMES <- toupper(removed)
[17:42:20.018]                 for (kk in seq_along(NAMES)) {
[17:42:20.018]                   name <- removed[[kk]]
[17:42:20.018]                   NAME <- NAMES[[kk]]
[17:42:20.018]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.018]                     next
[17:42:20.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.018]                 }
[17:42:20.018]                 if (length(args) > 0) 
[17:42:20.018]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.018]             }
[17:42:20.018]             else {
[17:42:20.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.018]             }
[17:42:20.018]             {
[17:42:20.018]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.018]                   0L) {
[17:42:20.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.018]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.018]                   base::options(opts)
[17:42:20.018]                 }
[17:42:20.018]                 {
[17:42:20.018]                   {
[17:42:20.018]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.018]                     NULL
[17:42:20.018]                   }
[17:42:20.018]                   options(future.plan = NULL)
[17:42:20.018]                   if (is.na(NA_character_)) 
[17:42:20.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.018]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:20.018]                     envir = parent.frame()) 
[17:42:20.018]                   {
[17:42:20.018]                     default_workers <- missing(workers)
[17:42:20.018]                     if (is.function(workers)) 
[17:42:20.018]                       workers <- workers()
[17:42:20.018]                     workers <- structure(as.integer(workers), 
[17:42:20.018]                       class = class(workers))
[17:42:20.018]                     stop_if_not(is.finite(workers), workers >= 
[17:42:20.018]                       1L)
[17:42:20.018]                     if ((workers == 1L && !inherits(workers, 
[17:42:20.018]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:20.018]                       if (default_workers) 
[17:42:20.018]                         supportsMulticore(warn = TRUE)
[17:42:20.018]                       return(sequential(..., envir = envir))
[17:42:20.018]                     }
[17:42:20.018]                     oopts <- options(mc.cores = workers)
[17:42:20.018]                     on.exit(options(oopts))
[17:42:20.018]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:20.018]                       envir = envir)
[17:42:20.018]                     if (!future$lazy) 
[17:42:20.018]                       future <- run(future)
[17:42:20.018]                     invisible(future)
[17:42:20.018]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.018]                 }
[17:42:20.018]             }
[17:42:20.018]         }
[17:42:20.018]     })
[17:42:20.018]     if (TRUE) {
[17:42:20.018]         base::sink(type = "output", split = FALSE)
[17:42:20.018]         if (TRUE) {
[17:42:20.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.018]         }
[17:42:20.018]         else {
[17:42:20.018]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.018]         }
[17:42:20.018]         base::close(...future.stdout)
[17:42:20.018]         ...future.stdout <- NULL
[17:42:20.018]     }
[17:42:20.018]     ...future.result$conditions <- ...future.conditions
[17:42:20.018]     ...future.result$finished <- base::Sys.time()
[17:42:20.018]     ...future.result
[17:42:20.018] }
[17:42:20.020] requestCore(): workers = 2
[17:42:20.022] MulticoreFuture started
[17:42:20.023] - Launch lazy future ... done
[17:42:20.023] run() for ‘MulticoreFuture’ ... done
[17:42:20.023] getGlobalsAndPackages() ...
[17:42:20.024] Searching for globals...
[17:42:20.024] plan(): Setting new future strategy stack:
[17:42:20.024] 
[17:42:20.024] List of future strategies:
[17:42:20.024] 1. sequential:
[17:42:20.024]    - args: function (..., envir = parent.frame())
[17:42:20.024]    - tweaked: FALSE
[17:42:20.024]    - call: NULL
[17:42:20.025] Searching for globals ... DONE
[17:42:20.025] - globals: [0] <none>
[17:42:20.025] plan(): nbrOfWorkers() = 1
[17:42:20.025] getGlobalsAndPackages() ... DONE
[17:42:20.025] run() for ‘Future’ ...
[17:42:20.026] - state: ‘created’
[17:42:20.026] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.027] plan(): Setting new future strategy stack:
[17:42:20.027] List of future strategies:
[17:42:20.027] 1. multicore:
[17:42:20.027]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:20.027]    - tweaked: FALSE
[17:42:20.027]    - call: plan(strategy)
[17:42:20.032] plan(): nbrOfWorkers() = 2
[17:42:20.032] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.032] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:20.032]   - Field: ‘label’
[17:42:20.032]   - Field: ‘local’
[17:42:20.032]   - Field: ‘owner’
[17:42:20.033]   - Field: ‘envir’
[17:42:20.033]   - Field: ‘workers’
[17:42:20.033]   - Field: ‘packages’
[17:42:20.033]   - Field: ‘gc’
[17:42:20.033]   - Field: ‘job’
[17:42:20.033]   - Field: ‘conditions’
[17:42:20.033]   - Field: ‘expr’
[17:42:20.034]   - Field: ‘uuid’
[17:42:20.034]   - Field: ‘seed’
[17:42:20.034]   - Field: ‘version’
[17:42:20.034]   - Field: ‘result’
[17:42:20.034]   - Field: ‘asynchronous’
[17:42:20.034]   - Field: ‘calls’
[17:42:20.038]   - Field: ‘globals’
[17:42:20.039]   - Field: ‘stdout’
[17:42:20.039]   - Field: ‘earlySignal’
[17:42:20.039]   - Field: ‘lazy’
[17:42:20.040]   - Field: ‘state’
[17:42:20.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:20.040] - Launch lazy future ...
[17:42:20.041] Packages needed by the future expression (n = 0): <none>
[17:42:20.041] Packages needed by future strategies (n = 0): <none>
[17:42:20.043] {
[17:42:20.043]     {
[17:42:20.043]         {
[17:42:20.043]             ...future.startTime <- base::Sys.time()
[17:42:20.043]             {
[17:42:20.043]                 {
[17:42:20.043]                   {
[17:42:20.043]                     {
[17:42:20.043]                       base::local({
[17:42:20.043]                         has_future <- base::requireNamespace("future", 
[17:42:20.043]                           quietly = TRUE)
[17:42:20.043]                         if (has_future) {
[17:42:20.043]                           ns <- base::getNamespace("future")
[17:42:20.043]                           version <- ns[[".package"]][["version"]]
[17:42:20.043]                           if (is.null(version)) 
[17:42:20.043]                             version <- utils::packageVersion("future")
[17:42:20.043]                         }
[17:42:20.043]                         else {
[17:42:20.043]                           version <- NULL
[17:42:20.043]                         }
[17:42:20.043]                         if (!has_future || version < "1.8.0") {
[17:42:20.043]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.043]                             "", base::R.version$version.string), 
[17:42:20.043]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.043]                               "release", "version")], collapse = " "), 
[17:42:20.043]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.043]                             info)
[17:42:20.043]                           info <- base::paste(info, collapse = "; ")
[17:42:20.043]                           if (!has_future) {
[17:42:20.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.043]                               info)
[17:42:20.043]                           }
[17:42:20.043]                           else {
[17:42:20.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.043]                               info, version)
[17:42:20.043]                           }
[17:42:20.043]                           base::stop(msg)
[17:42:20.043]                         }
[17:42:20.043]                       })
[17:42:20.043]                     }
[17:42:20.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.043]                     base::options(mc.cores = 1L)
[17:42:20.043]                   }
[17:42:20.043]                   options(future.plan = NULL)
[17:42:20.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.043]                 }
[17:42:20.043]                 ...future.workdir <- getwd()
[17:42:20.043]             }
[17:42:20.043]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.043]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.043]         }
[17:42:20.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.043]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.043]             base::names(...future.oldOptions))
[17:42:20.043]     }
[17:42:20.043]     if (FALSE) {
[17:42:20.043]     }
[17:42:20.043]     else {
[17:42:20.043]         if (TRUE) {
[17:42:20.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.043]                 open = "w")
[17:42:20.043]         }
[17:42:20.043]         else {
[17:42:20.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.043]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.043]         }
[17:42:20.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.043]             base::sink(type = "output", split = FALSE)
[17:42:20.043]             base::close(...future.stdout)
[17:42:20.043]         }, add = TRUE)
[17:42:20.043]     }
[17:42:20.043]     ...future.frame <- base::sys.nframe()
[17:42:20.043]     ...future.conditions <- base::list()
[17:42:20.043]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.043]     if (FALSE) {
[17:42:20.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.043]     }
[17:42:20.043]     ...future.result <- base::tryCatch({
[17:42:20.043]         base::withCallingHandlers({
[17:42:20.043]             ...future.value <- base::withVisible(base::local({
[17:42:20.043]                 withCallingHandlers({
[17:42:20.043]                   NULL
[17:42:20.043]                 }, immediateCondition = function(cond) {
[17:42:20.043]                   save_rds <- function (object, pathname, ...) 
[17:42:20.043]                   {
[17:42:20.043]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:20.043]                     if (file_test("-f", pathname_tmp)) {
[17:42:20.043]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.043]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:20.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.043]                         fi_tmp[["mtime"]])
[17:42:20.043]                     }
[17:42:20.043]                     tryCatch({
[17:42:20.043]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:20.043]                     }, error = function(ex) {
[17:42:20.043]                       msg <- conditionMessage(ex)
[17:42:20.043]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.043]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:20.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.043]                         fi_tmp[["mtime"]], msg)
[17:42:20.043]                       ex$message <- msg
[17:42:20.043]                       stop(ex)
[17:42:20.043]                     })
[17:42:20.043]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:20.043]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:20.043]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:20.043]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.043]                       fi <- file.info(pathname)
[17:42:20.043]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:20.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.043]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:20.043]                         fi[["size"]], fi[["mtime"]])
[17:42:20.043]                       stop(msg)
[17:42:20.043]                     }
[17:42:20.043]                     invisible(pathname)
[17:42:20.043]                   }
[17:42:20.043]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:20.043]                     rootPath = tempdir()) 
[17:42:20.043]                   {
[17:42:20.043]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:20.043]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:20.043]                       tmpdir = path, fileext = ".rds")
[17:42:20.043]                     save_rds(obj, file)
[17:42:20.043]                   }
[17:42:20.043]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:20.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.043]                   {
[17:42:20.043]                     inherits <- base::inherits
[17:42:20.043]                     invokeRestart <- base::invokeRestart
[17:42:20.043]                     is.null <- base::is.null
[17:42:20.043]                     muffled <- FALSE
[17:42:20.043]                     if (inherits(cond, "message")) {
[17:42:20.043]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.043]                       if (muffled) 
[17:42:20.043]                         invokeRestart("muffleMessage")
[17:42:20.043]                     }
[17:42:20.043]                     else if (inherits(cond, "warning")) {
[17:42:20.043]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.043]                       if (muffled) 
[17:42:20.043]                         invokeRestart("muffleWarning")
[17:42:20.043]                     }
[17:42:20.043]                     else if (inherits(cond, "condition")) {
[17:42:20.043]                       if (!is.null(pattern)) {
[17:42:20.043]                         computeRestarts <- base::computeRestarts
[17:42:20.043]                         grepl <- base::grepl
[17:42:20.043]                         restarts <- computeRestarts(cond)
[17:42:20.043]                         for (restart in restarts) {
[17:42:20.043]                           name <- restart$name
[17:42:20.043]                           if (is.null(name)) 
[17:42:20.043]                             next
[17:42:20.043]                           if (!grepl(pattern, name)) 
[17:42:20.043]                             next
[17:42:20.043]                           invokeRestart(restart)
[17:42:20.043]                           muffled <- TRUE
[17:42:20.043]                           break
[17:42:20.043]                         }
[17:42:20.043]                       }
[17:42:20.043]                     }
[17:42:20.043]                     invisible(muffled)
[17:42:20.043]                   }
[17:42:20.043]                   muffleCondition(cond)
[17:42:20.043]                 })
[17:42:20.043]             }))
[17:42:20.043]             future::FutureResult(value = ...future.value$value, 
[17:42:20.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.043]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.043]                     ...future.globalenv.names))
[17:42:20.043]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.043]         }, condition = base::local({
[17:42:20.043]             c <- base::c
[17:42:20.043]             inherits <- base::inherits
[17:42:20.043]             invokeRestart <- base::invokeRestart
[17:42:20.043]             length <- base::length
[17:42:20.043]             list <- base::list
[17:42:20.043]             seq.int <- base::seq.int
[17:42:20.043]             signalCondition <- base::signalCondition
[17:42:20.043]             sys.calls <- base::sys.calls
[17:42:20.043]             `[[` <- base::`[[`
[17:42:20.043]             `+` <- base::`+`
[17:42:20.043]             `<<-` <- base::`<<-`
[17:42:20.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.043]                   3L)]
[17:42:20.043]             }
[17:42:20.043]             function(cond) {
[17:42:20.043]                 is_error <- inherits(cond, "error")
[17:42:20.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.043]                   NULL)
[17:42:20.043]                 if (is_error) {
[17:42:20.043]                   sessionInformation <- function() {
[17:42:20.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.043]                       search = base::search(), system = base::Sys.info())
[17:42:20.043]                   }
[17:42:20.043]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.043]                     cond$call), session = sessionInformation(), 
[17:42:20.043]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.043]                   signalCondition(cond)
[17:42:20.043]                 }
[17:42:20.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.043]                 "immediateCondition"))) {
[17:42:20.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.043]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.043]                   if (TRUE && !signal) {
[17:42:20.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.043]                     {
[17:42:20.043]                       inherits <- base::inherits
[17:42:20.043]                       invokeRestart <- base::invokeRestart
[17:42:20.043]                       is.null <- base::is.null
[17:42:20.043]                       muffled <- FALSE
[17:42:20.043]                       if (inherits(cond, "message")) {
[17:42:20.043]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.043]                         if (muffled) 
[17:42:20.043]                           invokeRestart("muffleMessage")
[17:42:20.043]                       }
[17:42:20.043]                       else if (inherits(cond, "warning")) {
[17:42:20.043]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.043]                         if (muffled) 
[17:42:20.043]                           invokeRestart("muffleWarning")
[17:42:20.043]                       }
[17:42:20.043]                       else if (inherits(cond, "condition")) {
[17:42:20.043]                         if (!is.null(pattern)) {
[17:42:20.043]                           computeRestarts <- base::computeRestarts
[17:42:20.043]                           grepl <- base::grepl
[17:42:20.043]                           restarts <- computeRestarts(cond)
[17:42:20.043]                           for (restart in restarts) {
[17:42:20.043]                             name <- restart$name
[17:42:20.043]                             if (is.null(name)) 
[17:42:20.043]                               next
[17:42:20.043]                             if (!grepl(pattern, name)) 
[17:42:20.043]                               next
[17:42:20.043]                             invokeRestart(restart)
[17:42:20.043]                             muffled <- TRUE
[17:42:20.043]                             break
[17:42:20.043]                           }
[17:42:20.043]                         }
[17:42:20.043]                       }
[17:42:20.043]                       invisible(muffled)
[17:42:20.043]                     }
[17:42:20.043]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.043]                   }
[17:42:20.043]                 }
[17:42:20.043]                 else {
[17:42:20.043]                   if (TRUE) {
[17:42:20.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.043]                     {
[17:42:20.043]                       inherits <- base::inherits
[17:42:20.043]                       invokeRestart <- base::invokeRestart
[17:42:20.043]                       is.null <- base::is.null
[17:42:20.043]                       muffled <- FALSE
[17:42:20.043]                       if (inherits(cond, "message")) {
[17:42:20.043]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.043]                         if (muffled) 
[17:42:20.043]                           invokeRestart("muffleMessage")
[17:42:20.043]                       }
[17:42:20.043]                       else if (inherits(cond, "warning")) {
[17:42:20.043]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.043]                         if (muffled) 
[17:42:20.043]                           invokeRestart("muffleWarning")
[17:42:20.043]                       }
[17:42:20.043]                       else if (inherits(cond, "condition")) {
[17:42:20.043]                         if (!is.null(pattern)) {
[17:42:20.043]                           computeRestarts <- base::computeRestarts
[17:42:20.043]                           grepl <- base::grepl
[17:42:20.043]                           restarts <- computeRestarts(cond)
[17:42:20.043]                           for (restart in restarts) {
[17:42:20.043]                             name <- restart$name
[17:42:20.043]                             if (is.null(name)) 
[17:42:20.043]                               next
[17:42:20.043]                             if (!grepl(pattern, name)) 
[17:42:20.043]                               next
[17:42:20.043]                             invokeRestart(restart)
[17:42:20.043]                             muffled <- TRUE
[17:42:20.043]                             break
[17:42:20.043]                           }
[17:42:20.043]                         }
[17:42:20.043]                       }
[17:42:20.043]                       invisible(muffled)
[17:42:20.043]                     }
[17:42:20.043]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.043]                   }
[17:42:20.043]                 }
[17:42:20.043]             }
[17:42:20.043]         }))
[17:42:20.043]     }, error = function(ex) {
[17:42:20.043]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.043]                 ...future.rng), started = ...future.startTime, 
[17:42:20.043]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.043]             version = "1.8"), class = "FutureResult")
[17:42:20.043]     }, finally = {
[17:42:20.043]         if (!identical(...future.workdir, getwd())) 
[17:42:20.043]             setwd(...future.workdir)
[17:42:20.043]         {
[17:42:20.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.043]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.043]             }
[17:42:20.043]             base::options(...future.oldOptions)
[17:42:20.043]             if (.Platform$OS.type == "windows") {
[17:42:20.043]                 old_names <- names(...future.oldEnvVars)
[17:42:20.043]                 envs <- base::Sys.getenv()
[17:42:20.043]                 names <- names(envs)
[17:42:20.043]                 common <- intersect(names, old_names)
[17:42:20.043]                 added <- setdiff(names, old_names)
[17:42:20.043]                 removed <- setdiff(old_names, names)
[17:42:20.043]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.043]                   envs[common]]
[17:42:20.043]                 NAMES <- toupper(changed)
[17:42:20.043]                 args <- list()
[17:42:20.043]                 for (kk in seq_along(NAMES)) {
[17:42:20.043]                   name <- changed[[kk]]
[17:42:20.043]                   NAME <- NAMES[[kk]]
[17:42:20.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.043]                     next
[17:42:20.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.043]                 }
[17:42:20.043]                 NAMES <- toupper(added)
[17:42:20.043]                 for (kk in seq_along(NAMES)) {
[17:42:20.043]                   name <- added[[kk]]
[17:42:20.043]                   NAME <- NAMES[[kk]]
[17:42:20.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.043]                     next
[17:42:20.043]                   args[[name]] <- ""
[17:42:20.043]                 }
[17:42:20.043]                 NAMES <- toupper(removed)
[17:42:20.043]                 for (kk in seq_along(NAMES)) {
[17:42:20.043]                   name <- removed[[kk]]
[17:42:20.043]                   NAME <- NAMES[[kk]]
[17:42:20.043]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.043]                     next
[17:42:20.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.043]                 }
[17:42:20.043]                 if (length(args) > 0) 
[17:42:20.043]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.043]             }
[17:42:20.043]             else {
[17:42:20.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.043]             }
[17:42:20.043]             {
[17:42:20.043]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.043]                   0L) {
[17:42:20.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.043]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.043]                   base::options(opts)
[17:42:20.043]                 }
[17:42:20.043]                 {
[17:42:20.043]                   {
[17:42:20.043]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.043]                     NULL
[17:42:20.043]                   }
[17:42:20.043]                   options(future.plan = NULL)
[17:42:20.043]                   if (is.na(NA_character_)) 
[17:42:20.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.043]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:20.043]                     envir = parent.frame()) 
[17:42:20.043]                   {
[17:42:20.043]                     default_workers <- missing(workers)
[17:42:20.043]                     if (is.function(workers)) 
[17:42:20.043]                       workers <- workers()
[17:42:20.043]                     workers <- structure(as.integer(workers), 
[17:42:20.043]                       class = class(workers))
[17:42:20.043]                     stop_if_not(is.finite(workers), workers >= 
[17:42:20.043]                       1L)
[17:42:20.043]                     if ((workers == 1L && !inherits(workers, 
[17:42:20.043]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:20.043]                       if (default_workers) 
[17:42:20.043]                         supportsMulticore(warn = TRUE)
[17:42:20.043]                       return(sequential(..., envir = envir))
[17:42:20.043]                     }
[17:42:20.043]                     oopts <- options(mc.cores = workers)
[17:42:20.043]                     on.exit(options(oopts))
[17:42:20.043]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:20.043]                       envir = envir)
[17:42:20.043]                     if (!future$lazy) 
[17:42:20.043]                       future <- run(future)
[17:42:20.043]                     invisible(future)
[17:42:20.043]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.043]                 }
[17:42:20.043]             }
[17:42:20.043]         }
[17:42:20.043]     })
[17:42:20.043]     if (TRUE) {
[17:42:20.043]         base::sink(type = "output", split = FALSE)
[17:42:20.043]         if (TRUE) {
[17:42:20.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.043]         }
[17:42:20.043]         else {
[17:42:20.043]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.043]         }
[17:42:20.043]         base::close(...future.stdout)
[17:42:20.043]         ...future.stdout <- NULL
[17:42:20.043]     }
[17:42:20.043]     ...future.result$conditions <- ...future.conditions
[17:42:20.043]     ...future.result$finished <- base::Sys.time()
[17:42:20.043]     ...future.result
[17:42:20.043] }
[17:42:20.046] requestCore(): workers = 2
[17:42:20.048] MulticoreFuture started
[17:42:20.049] - Launch lazy future ... done
[17:42:20.049] run() for ‘MulticoreFuture’ ... done
[17:42:20.050] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:42:20.050] List of future strategies:
[17:42:20.050] 1. sequential:
[17:42:20.050]    - args: function (..., envir = parent.frame())
[17:42:20.050]    - tweaked: FALSE
[17:42:20.050]    - call: NULL
[17:42:20.051] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7eda9f8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef82c3118> 
 $  : NULL
 $  : NULL
 $  :[17:42:20.053] plan(): Setting new future strategy stack:
[17:42:20.053] List of future strategies:
[17:42:20.053] 1. multicore:
[17:42:20.053]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:20.053]    - tweaked: FALSE
[17:42:20.053]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7eda9f8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef82c3118> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=[17:42:20.059] plan(): nbrOfWorkers() = 2
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:20.065] resolve() on list ...
[17:42:20.065]  recursive: 0
[17:42:20.065]  length: 6
[17:42:20.065]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:20.065] signalConditionsASAP(numeric, pos=1) ...
[17:42:20.066] - nx: 6
[17:42:20.066] - relay: TRUE
[17:42:20.066] - stdout: TRUE
[17:42:20.066] - signal: TRUE
[17:42:20.066] - resignal: FALSE
[17:42:20.066] - force: TRUE
[17:42:20.066] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.067] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.067]  - until=2
[17:42:20.067]  - relaying element #2
[17:42:20.067] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.067] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.067] signalConditionsASAP(NULL, pos=1) ... done
[17:42:20.068]  length: 5 (resolved future 1)
[17:42:20.068] Future #2
[17:42:20.069] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:20.069] - nx: 6
[17:42:20.069] - relay: TRUE
[17:42:20.069] - stdout: TRUE
[17:42:20.070] - signal: TRUE
[17:42:20.070] - resignal: FALSE
[17:42:20.070] - force: TRUE
[17:42:20.070] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.070] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.070]  - until=2
[17:42:20.070]  - relaying element #2
[17:42:20.071] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.071] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.071] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:20.071]  length: 4 (resolved future 2)
[17:42:20.072] Future #3
[17:42:20.072] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:20.073] - nx: 6
[17:42:20.073] - relay: TRUE
[17:42:20.073] - stdout: TRUE
[17:42:20.073] - signal: TRUE
[17:42:20.073] - resignal: FALSE
[17:42:20.073] - force: TRUE
[17:42:20.073] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.073] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.074]  - until=3
[17:42:20.074]  - relaying element #3
[17:42:20.074] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.074] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.074] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:20.074]  length: 3 (resolved future 3)
[17:42:20.074] signalConditionsASAP(NULL, pos=4) ...
[17:42:20.075] - nx: 6
[17:42:20.075] - relay: TRUE
[17:42:20.075] - stdout: TRUE
[17:42:20.075] - signal: TRUE
[17:42:20.075] - resignal: FALSE
[17:42:20.075] - force: TRUE
[17:42:20.075] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.075] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.075]  - until=5
[17:42:20.076]  - relaying element #5
[17:42:20.076] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.076] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.076] signalConditionsASAP(NULL, pos=4) ... done
[17:42:20.076]  length: 2 (resolved future 4)
[17:42:20.076] signalConditionsASAP(NULL, pos=5) ...
[17:42:20.076] - nx: 6
[17:42:20.076] - relay: TRUE
[17:42:20.076] - stdout: TRUE
[17:42:20.077] - signal: TRUE
[17:42:20.077] - resignal: FALSE
[17:42:20.077] - force: TRUE
[17:42:20.077] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.077] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.077]  - until=6
[17:42:20.077]  - relaying element #6
[17:42:20.077] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.077] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.078] signalConditionsASAP(NULL, pos=5) ... done
[17:42:20.078]  length: 1 (resolved future 5)
[17:42:20.078] signalConditionsASAP(numeric, pos=6) ...
[17:42:20.078] - nx: 6
[17:42:20.078] - relay: TRUE
[17:42:20.078] - stdout: TRUE
[17:42:20.078] - signal: TRUE
[17:42:20.078] - resignal: FALSE
[17:42:20.078] - force: TRUE
[17:42:20.078] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.079] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.079]  - until=6
[17:42:20.079] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.079] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.079] signalConditionsASAP(numeric, pos=6) ... done
[17:42:20.079]  length: 0 (resolved future 6)
[17:42:20.079] Relaying remaining futures
[17:42:20.079] signalConditionsASAP(NULL, pos=0) ...
[17:42:20.079] - nx: 6
[17:42:20.079] - relay: TRUE
[17:42:20.080] - stdout: TRUE
[17:42:20.080] - signal: TRUE
[17:42:20.080] - resignal: FALSE
[17:42:20.080] - force: TRUE
[17:42:20.080] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.080] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:20.080] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.080] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.080] signalConditionsASAP(NULL, pos=0) ... done
[17:42:20.081] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:42:20.088] getGlobalsAndPackages() ...
[17:42:20.088] Searching for globals...
[17:42:20.088] 
[17:42:20.088] Searching for globals ... DONE
[17:42:20.088] - globals: [0] <none>
[17:42:20.088] getGlobalsAndPackages() ... DONE
[17:42:20.089] run() for ‘Future’ ...
[17:42:20.089] - state: ‘created’
[17:42:20.089] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.093] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:20.093]   - Field: ‘label’
[17:42:20.093]   - Field: ‘local’
[17:42:20.094]   - Field: ‘owner’
[17:42:20.094]   - Field: ‘envir’
[17:42:20.094]   - Field: ‘workers’
[17:42:20.094]   - Field: ‘packages’
[17:42:20.094]   - Field: ‘gc’
[17:42:20.094]   - Field: ‘job’
[17:42:20.094]   - Field: ‘conditions’
[17:42:20.094]   - Field: ‘expr’
[17:42:20.094]   - Field: ‘uuid’
[17:42:20.094]   - Field: ‘seed’
[17:42:20.095]   - Field: ‘version’
[17:42:20.095]   - Field: ‘result’
[17:42:20.095]   - Field: ‘asynchronous’
[17:42:20.095]   - Field: ‘calls’
[17:42:20.095]   - Field: ‘globals’
[17:42:20.095]   - Field: ‘stdout’
[17:42:20.095]   - Field: ‘earlySignal’
[17:42:20.095]   - Field: ‘lazy’
[17:42:20.095]   - Field: ‘state’
[17:42:20.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:20.096] - Launch lazy future ...
[17:42:20.096] Packages needed by the future expression (n = 0): <none>
[17:42:20.096] Packages needed by future strategies (n = 0): <none>
[17:42:20.097] {
[17:42:20.097]     {
[17:42:20.097]         {
[17:42:20.097]             ...future.startTime <- base::Sys.time()
[17:42:20.097]             {
[17:42:20.097]                 {
[17:42:20.097]                   {
[17:42:20.097]                     {
[17:42:20.097]                       base::local({
[17:42:20.097]                         has_future <- base::requireNamespace("future", 
[17:42:20.097]                           quietly = TRUE)
[17:42:20.097]                         if (has_future) {
[17:42:20.097]                           ns <- base::getNamespace("future")
[17:42:20.097]                           version <- ns[[".package"]][["version"]]
[17:42:20.097]                           if (is.null(version)) 
[17:42:20.097]                             version <- utils::packageVersion("future")
[17:42:20.097]                         }
[17:42:20.097]                         else {
[17:42:20.097]                           version <- NULL
[17:42:20.097]                         }
[17:42:20.097]                         if (!has_future || version < "1.8.0") {
[17:42:20.097]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.097]                             "", base::R.version$version.string), 
[17:42:20.097]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.097]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.097]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.097]                               "release", "version")], collapse = " "), 
[17:42:20.097]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.097]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.097]                             info)
[17:42:20.097]                           info <- base::paste(info, collapse = "; ")
[17:42:20.097]                           if (!has_future) {
[17:42:20.097]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.097]                               info)
[17:42:20.097]                           }
[17:42:20.097]                           else {
[17:42:20.097]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.097]                               info, version)
[17:42:20.097]                           }
[17:42:20.097]                           base::stop(msg)
[17:42:20.097]                         }
[17:42:20.097]                       })
[17:42:20.097]                     }
[17:42:20.097]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.097]                     base::options(mc.cores = 1L)
[17:42:20.097]                   }
[17:42:20.097]                   options(future.plan = NULL)
[17:42:20.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.097]                 }
[17:42:20.097]                 ...future.workdir <- getwd()
[17:42:20.097]             }
[17:42:20.097]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.097]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.097]         }
[17:42:20.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.097]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.097]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.097]             base::names(...future.oldOptions))
[17:42:20.097]     }
[17:42:20.097]     if (FALSE) {
[17:42:20.097]     }
[17:42:20.097]     else {
[17:42:20.097]         if (TRUE) {
[17:42:20.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.097]                 open = "w")
[17:42:20.097]         }
[17:42:20.097]         else {
[17:42:20.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.097]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.097]         }
[17:42:20.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.097]             base::sink(type = "output", split = FALSE)
[17:42:20.097]             base::close(...future.stdout)
[17:42:20.097]         }, add = TRUE)
[17:42:20.097]     }
[17:42:20.097]     ...future.frame <- base::sys.nframe()
[17:42:20.097]     ...future.conditions <- base::list()
[17:42:20.097]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.097]     if (FALSE) {
[17:42:20.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.097]     }
[17:42:20.097]     ...future.result <- base::tryCatch({
[17:42:20.097]         base::withCallingHandlers({
[17:42:20.097]             ...future.value <- base::withVisible(base::local({
[17:42:20.097]                 withCallingHandlers({
[17:42:20.097]                   2
[17:42:20.097]                 }, immediateCondition = function(cond) {
[17:42:20.097]                   save_rds <- function (object, pathname, ...) 
[17:42:20.097]                   {
[17:42:20.097]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:20.097]                     if (file_test("-f", pathname_tmp)) {
[17:42:20.097]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.097]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:20.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.097]                         fi_tmp[["mtime"]])
[17:42:20.097]                     }
[17:42:20.097]                     tryCatch({
[17:42:20.097]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:20.097]                     }, error = function(ex) {
[17:42:20.097]                       msg <- conditionMessage(ex)
[17:42:20.097]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.097]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:20.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.097]                         fi_tmp[["mtime"]], msg)
[17:42:20.097]                       ex$message <- msg
[17:42:20.097]                       stop(ex)
[17:42:20.097]                     })
[17:42:20.097]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:20.097]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:20.097]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:20.097]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.097]                       fi <- file.info(pathname)
[17:42:20.097]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:20.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.097]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:20.097]                         fi[["size"]], fi[["mtime"]])
[17:42:20.097]                       stop(msg)
[17:42:20.097]                     }
[17:42:20.097]                     invisible(pathname)
[17:42:20.097]                   }
[17:42:20.097]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:20.097]                     rootPath = tempdir()) 
[17:42:20.097]                   {
[17:42:20.097]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:20.097]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:20.097]                       tmpdir = path, fileext = ".rds")
[17:42:20.097]                     save_rds(obj, file)
[17:42:20.097]                   }
[17:42:20.097]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:20.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.097]                   {
[17:42:20.097]                     inherits <- base::inherits
[17:42:20.097]                     invokeRestart <- base::invokeRestart
[17:42:20.097]                     is.null <- base::is.null
[17:42:20.097]                     muffled <- FALSE
[17:42:20.097]                     if (inherits(cond, "message")) {
[17:42:20.097]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.097]                       if (muffled) 
[17:42:20.097]                         invokeRestart("muffleMessage")
[17:42:20.097]                     }
[17:42:20.097]                     else if (inherits(cond, "warning")) {
[17:42:20.097]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.097]                       if (muffled) 
[17:42:20.097]                         invokeRestart("muffleWarning")
[17:42:20.097]                     }
[17:42:20.097]                     else if (inherits(cond, "condition")) {
[17:42:20.097]                       if (!is.null(pattern)) {
[17:42:20.097]                         computeRestarts <- base::computeRestarts
[17:42:20.097]                         grepl <- base::grepl
[17:42:20.097]                         restarts <- computeRestarts(cond)
[17:42:20.097]                         for (restart in restarts) {
[17:42:20.097]                           name <- restart$name
[17:42:20.097]                           if (is.null(name)) 
[17:42:20.097]                             next
[17:42:20.097]                           if (!grepl(pattern, name)) 
[17:42:20.097]                             next
[17:42:20.097]                           invokeRestart(restart)
[17:42:20.097]                           muffled <- TRUE
[17:42:20.097]                           break
[17:42:20.097]                         }
[17:42:20.097]                       }
[17:42:20.097]                     }
[17:42:20.097]                     invisible(muffled)
[17:42:20.097]                   }
[17:42:20.097]                   muffleCondition(cond)
[17:42:20.097]                 })
[17:42:20.097]             }))
[17:42:20.097]             future::FutureResult(value = ...future.value$value, 
[17:42:20.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.097]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.097]                     ...future.globalenv.names))
[17:42:20.097]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.097]         }, condition = base::local({
[17:42:20.097]             c <- base::c
[17:42:20.097]             inherits <- base::inherits
[17:42:20.097]             invokeRestart <- base::invokeRestart
[17:42:20.097]             length <- base::length
[17:42:20.097]             list <- base::list
[17:42:20.097]             seq.int <- base::seq.int
[17:42:20.097]             signalCondition <- base::signalCondition
[17:42:20.097]             sys.calls <- base::sys.calls
[17:42:20.097]             `[[` <- base::`[[`
[17:42:20.097]             `+` <- base::`+`
[17:42:20.097]             `<<-` <- base::`<<-`
[17:42:20.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.097]                   3L)]
[17:42:20.097]             }
[17:42:20.097]             function(cond) {
[17:42:20.097]                 is_error <- inherits(cond, "error")
[17:42:20.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.097]                   NULL)
[17:42:20.097]                 if (is_error) {
[17:42:20.097]                   sessionInformation <- function() {
[17:42:20.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.097]                       search = base::search(), system = base::Sys.info())
[17:42:20.097]                   }
[17:42:20.097]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.097]                     cond$call), session = sessionInformation(), 
[17:42:20.097]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.097]                   signalCondition(cond)
[17:42:20.097]                 }
[17:42:20.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.097]                 "immediateCondition"))) {
[17:42:20.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.097]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.097]                   if (TRUE && !signal) {
[17:42:20.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.097]                     {
[17:42:20.097]                       inherits <- base::inherits
[17:42:20.097]                       invokeRestart <- base::invokeRestart
[17:42:20.097]                       is.null <- base::is.null
[17:42:20.097]                       muffled <- FALSE
[17:42:20.097]                       if (inherits(cond, "message")) {
[17:42:20.097]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.097]                         if (muffled) 
[17:42:20.097]                           invokeRestart("muffleMessage")
[17:42:20.097]                       }
[17:42:20.097]                       else if (inherits(cond, "warning")) {
[17:42:20.097]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.097]                         if (muffled) 
[17:42:20.097]                           invokeRestart("muffleWarning")
[17:42:20.097]                       }
[17:42:20.097]                       else if (inherits(cond, "condition")) {
[17:42:20.097]                         if (!is.null(pattern)) {
[17:42:20.097]                           computeRestarts <- base::computeRestarts
[17:42:20.097]                           grepl <- base::grepl
[17:42:20.097]                           restarts <- computeRestarts(cond)
[17:42:20.097]                           for (restart in restarts) {
[17:42:20.097]                             name <- restart$name
[17:42:20.097]                             if (is.null(name)) 
[17:42:20.097]                               next
[17:42:20.097]                             if (!grepl(pattern, name)) 
[17:42:20.097]                               next
[17:42:20.097]                             invokeRestart(restart)
[17:42:20.097]                             muffled <- TRUE
[17:42:20.097]                             break
[17:42:20.097]                           }
[17:42:20.097]                         }
[17:42:20.097]                       }
[17:42:20.097]                       invisible(muffled)
[17:42:20.097]                     }
[17:42:20.097]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.097]                   }
[17:42:20.097]                 }
[17:42:20.097]                 else {
[17:42:20.097]                   if (TRUE) {
[17:42:20.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.097]                     {
[17:42:20.097]                       inherits <- base::inherits
[17:42:20.097]                       invokeRestart <- base::invokeRestart
[17:42:20.097]                       is.null <- base::is.null
[17:42:20.097]                       muffled <- FALSE
[17:42:20.097]                       if (inherits(cond, "message")) {
[17:42:20.097]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.097]                         if (muffled) 
[17:42:20.097]                           invokeRestart("muffleMessage")
[17:42:20.097]                       }
[17:42:20.097]                       else if (inherits(cond, "warning")) {
[17:42:20.097]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.097]                         if (muffled) 
[17:42:20.097]                           invokeRestart("muffleWarning")
[17:42:20.097]                       }
[17:42:20.097]                       else if (inherits(cond, "condition")) {
[17:42:20.097]                         if (!is.null(pattern)) {
[17:42:20.097]                           computeRestarts <- base::computeRestarts
[17:42:20.097]                           grepl <- base::grepl
[17:42:20.097]                           restarts <- computeRestarts(cond)
[17:42:20.097]                           for (restart in restarts) {
[17:42:20.097]                             name <- restart$name
[17:42:20.097]                             if (is.null(name)) 
[17:42:20.097]                               next
[17:42:20.097]                             if (!grepl(pattern, name)) 
[17:42:20.097]                               next
[17:42:20.097]                             invokeRestart(restart)
[17:42:20.097]                             muffled <- TRUE
[17:42:20.097]                             break
[17:42:20.097]                           }
[17:42:20.097]                         }
[17:42:20.097]                       }
[17:42:20.097]                       invisible(muffled)
[17:42:20.097]                     }
[17:42:20.097]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.097]                   }
[17:42:20.097]                 }
[17:42:20.097]             }
[17:42:20.097]         }))
[17:42:20.097]     }, error = function(ex) {
[17:42:20.097]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.097]                 ...future.rng), started = ...future.startTime, 
[17:42:20.097]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.097]             version = "1.8"), class = "FutureResult")
[17:42:20.097]     }, finally = {
[17:42:20.097]         if (!identical(...future.workdir, getwd())) 
[17:42:20.097]             setwd(...future.workdir)
[17:42:20.097]         {
[17:42:20.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.097]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.097]             }
[17:42:20.097]             base::options(...future.oldOptions)
[17:42:20.097]             if (.Platform$OS.type == "windows") {
[17:42:20.097]                 old_names <- names(...future.oldEnvVars)
[17:42:20.097]                 envs <- base::Sys.getenv()
[17:42:20.097]                 names <- names(envs)
[17:42:20.097]                 common <- intersect(names, old_names)
[17:42:20.097]                 added <- setdiff(names, old_names)
[17:42:20.097]                 removed <- setdiff(old_names, names)
[17:42:20.097]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.097]                   envs[common]]
[17:42:20.097]                 NAMES <- toupper(changed)
[17:42:20.097]                 args <- list()
[17:42:20.097]                 for (kk in seq_along(NAMES)) {
[17:42:20.097]                   name <- changed[[kk]]
[17:42:20.097]                   NAME <- NAMES[[kk]]
[17:42:20.097]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.097]                     next
[17:42:20.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.097]                 }
[17:42:20.097]                 NAMES <- toupper(added)
[17:42:20.097]                 for (kk in seq_along(NAMES)) {
[17:42:20.097]                   name <- added[[kk]]
[17:42:20.097]                   NAME <- NAMES[[kk]]
[17:42:20.097]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.097]                     next
[17:42:20.097]                   args[[name]] <- ""
[17:42:20.097]                 }
[17:42:20.097]                 NAMES <- toupper(removed)
[17:42:20.097]                 for (kk in seq_along(NAMES)) {
[17:42:20.097]                   name <- removed[[kk]]
[17:42:20.097]                   NAME <- NAMES[[kk]]
[17:42:20.097]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.097]                     next
[17:42:20.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.097]                 }
[17:42:20.097]                 if (length(args) > 0) 
[17:42:20.097]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.097]             }
[17:42:20.097]             else {
[17:42:20.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.097]             }
[17:42:20.097]             {
[17:42:20.097]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.097]                   0L) {
[17:42:20.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.097]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.097]                   base::options(opts)
[17:42:20.097]                 }
[17:42:20.097]                 {
[17:42:20.097]                   {
[17:42:20.097]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.097]                     NULL
[17:42:20.097]                   }
[17:42:20.097]                   options(future.plan = NULL)
[17:42:20.097]                   if (is.na(NA_character_)) 
[17:42:20.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.097]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:20.097]                     envir = parent.frame()) 
[17:42:20.097]                   {
[17:42:20.097]                     default_workers <- missing(workers)
[17:42:20.097]                     if (is.function(workers)) 
[17:42:20.097]                       workers <- workers()
[17:42:20.097]                     workers <- structure(as.integer(workers), 
[17:42:20.097]                       class = class(workers))
[17:42:20.097]                     stop_if_not(is.finite(workers), workers >= 
[17:42:20.097]                       1L)
[17:42:20.097]                     if ((workers == 1L && !inherits(workers, 
[17:42:20.097]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:20.097]                       if (default_workers) 
[17:42:20.097]                         supportsMulticore(warn = TRUE)
[17:42:20.097]                       return(sequential(..., envir = envir))
[17:42:20.097]                     }
[17:42:20.097]                     oopts <- options(mc.cores = workers)
[17:42:20.097]                     on.exit(options(oopts))
[17:42:20.097]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:20.097]                       envir = envir)
[17:42:20.097]                     if (!future$lazy) 
[17:42:20.097]                       future <- run(future)
[17:42:20.097]                     invisible(future)
[17:42:20.097]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.097]                 }
[17:42:20.097]             }
[17:42:20.097]         }
[17:42:20.097]     })
[17:42:20.097]     if (TRUE) {
[17:42:20.097]         base::sink(type = "output", split = FALSE)
[17:42:20.097]         if (TRUE) {
[17:42:20.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.097]         }
[17:42:20.097]         else {
[17:42:20.097]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.097]         }
[17:42:20.097]         base::close(...future.stdout)
[17:42:20.097]         ...future.stdout <- NULL
[17:42:20.097]     }
[17:42:20.097]     ...future.result$conditions <- ...future.conditions
[17:42:20.097]     ...future.result$finished <- base::Sys.time()
[17:42:20.097]     ...future.result
[17:42:20.097] }
[17:42:20.099] requestCore(): workers = 2
[17:42:20.101] MulticoreFuture started
[17:42:20.102] - Launch lazy future ... done
[17:42:20.102] run() for ‘MulticoreFuture’ ... done
[17:42:20.102] getGlobalsAndPackages() ...
[17:42:20.102] Searching for globals...
[17:42:20.102] plan(): Setting new future strategy stack:
[17:42:20.103] List of future strategies:
[17:42:20.103] 1. sequential:
[17:42:20.103]    - args: function (..., envir = parent.frame())
[17:42:20.103]    - tweaked: FALSE
[17:42:20.103]    - call: NULL
[17:42:20.103] 
[17:42:20.104] Searching for globals ... DONE
[17:42:20.104] plan(): nbrOfWorkers() = 1
[17:42:20.104] - globals: [0] <none>
[17:42:20.104] getGlobalsAndPackages() ... DONE
[17:42:20.105] run() for ‘Future’ ...
[17:42:20.105] - state: ‘created’
[17:42:20.105] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.106] plan(): Setting new future strategy stack:
[17:42:20.106] List of future strategies:
[17:42:20.106] 1. multicore:
[17:42:20.106]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:20.106]    - tweaked: FALSE
[17:42:20.106]    - call: plan(strategy)
[17:42:20.111] plan(): nbrOfWorkers() = 2
[17:42:20.111] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:20.111]   - Field: ‘label’
[17:42:20.111]   - Field: ‘local’
[17:42:20.112]   - Field: ‘owner’
[17:42:20.112]   - Field: ‘envir’
[17:42:20.112]   - Field: ‘workers’
[17:42:20.112]   - Field: ‘packages’
[17:42:20.112]   - Field: ‘gc’
[17:42:20.112]   - Field: ‘job’
[17:42:20.113]   - Field: ‘conditions’
[17:42:20.113]   - Field: ‘expr’
[17:42:20.113]   - Field: ‘uuid’
[17:42:20.113]   - Field: ‘seed’
[17:42:20.113]   - Field: ‘version’
[17:42:20.113]   - Field: ‘result’
[17:42:20.114]   - Field: ‘asynchronous’
[17:42:20.114]   - Field: ‘calls’
[17:42:20.114]   - Field: ‘globals’
[17:42:20.114]   - Field: ‘stdout’
[17:42:20.114]   - Field: ‘earlySignal’
[17:42:20.114]   - Field: ‘lazy’
[17:42:20.114]   - Field: ‘state’
[17:42:20.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:20.115] - Launch lazy future ...
[17:42:20.115] Packages needed by the future expression (n = 0): <none>
[17:42:20.115] Packages needed by future strategies (n = 0): <none>
[17:42:20.116] {
[17:42:20.116]     {
[17:42:20.116]         {
[17:42:20.116]             ...future.startTime <- base::Sys.time()
[17:42:20.116]             {
[17:42:20.116]                 {
[17:42:20.116]                   {
[17:42:20.116]                     {
[17:42:20.116]                       base::local({
[17:42:20.116]                         has_future <- base::requireNamespace("future", 
[17:42:20.116]                           quietly = TRUE)
[17:42:20.116]                         if (has_future) {
[17:42:20.116]                           ns <- base::getNamespace("future")
[17:42:20.116]                           version <- ns[[".package"]][["version"]]
[17:42:20.116]                           if (is.null(version)) 
[17:42:20.116]                             version <- utils::packageVersion("future")
[17:42:20.116]                         }
[17:42:20.116]                         else {
[17:42:20.116]                           version <- NULL
[17:42:20.116]                         }
[17:42:20.116]                         if (!has_future || version < "1.8.0") {
[17:42:20.116]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.116]                             "", base::R.version$version.string), 
[17:42:20.116]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.116]                               "release", "version")], collapse = " "), 
[17:42:20.116]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.116]                             info)
[17:42:20.116]                           info <- base::paste(info, collapse = "; ")
[17:42:20.116]                           if (!has_future) {
[17:42:20.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.116]                               info)
[17:42:20.116]                           }
[17:42:20.116]                           else {
[17:42:20.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.116]                               info, version)
[17:42:20.116]                           }
[17:42:20.116]                           base::stop(msg)
[17:42:20.116]                         }
[17:42:20.116]                       })
[17:42:20.116]                     }
[17:42:20.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.116]                     base::options(mc.cores = 1L)
[17:42:20.116]                   }
[17:42:20.116]                   options(future.plan = NULL)
[17:42:20.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.116]                 }
[17:42:20.116]                 ...future.workdir <- getwd()
[17:42:20.116]             }
[17:42:20.116]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.116]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.116]         }
[17:42:20.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.116]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.116]             base::names(...future.oldOptions))
[17:42:20.116]     }
[17:42:20.116]     if (FALSE) {
[17:42:20.116]     }
[17:42:20.116]     else {
[17:42:20.116]         if (TRUE) {
[17:42:20.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.116]                 open = "w")
[17:42:20.116]         }
[17:42:20.116]         else {
[17:42:20.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.116]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.116]         }
[17:42:20.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.116]             base::sink(type = "output", split = FALSE)
[17:42:20.116]             base::close(...future.stdout)
[17:42:20.116]         }, add = TRUE)
[17:42:20.116]     }
[17:42:20.116]     ...future.frame <- base::sys.nframe()
[17:42:20.116]     ...future.conditions <- base::list()
[17:42:20.116]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.116]     if (FALSE) {
[17:42:20.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.116]     }
[17:42:20.116]     ...future.result <- base::tryCatch({
[17:42:20.116]         base::withCallingHandlers({
[17:42:20.116]             ...future.value <- base::withVisible(base::local({
[17:42:20.116]                 withCallingHandlers({
[17:42:20.116]                   NULL
[17:42:20.116]                 }, immediateCondition = function(cond) {
[17:42:20.116]                   save_rds <- function (object, pathname, ...) 
[17:42:20.116]                   {
[17:42:20.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:20.116]                     if (file_test("-f", pathname_tmp)) {
[17:42:20.116]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:20.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.116]                         fi_tmp[["mtime"]])
[17:42:20.116]                     }
[17:42:20.116]                     tryCatch({
[17:42:20.116]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:20.116]                     }, error = function(ex) {
[17:42:20.116]                       msg <- conditionMessage(ex)
[17:42:20.116]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:20.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.116]                         fi_tmp[["mtime"]], msg)
[17:42:20.116]                       ex$message <- msg
[17:42:20.116]                       stop(ex)
[17:42:20.116]                     })
[17:42:20.116]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:20.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:20.116]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:20.116]                       fi_tmp <- file.info(pathname_tmp)
[17:42:20.116]                       fi <- file.info(pathname)
[17:42:20.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:20.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:20.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:20.116]                         fi[["size"]], fi[["mtime"]])
[17:42:20.116]                       stop(msg)
[17:42:20.116]                     }
[17:42:20.116]                     invisible(pathname)
[17:42:20.116]                   }
[17:42:20.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:20.116]                     rootPath = tempdir()) 
[17:42:20.116]                   {
[17:42:20.116]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:20.116]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:20.116]                       tmpdir = path, fileext = ".rds")
[17:42:20.116]                     save_rds(obj, file)
[17:42:20.116]                   }
[17:42:20.116]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:20.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.116]                   {
[17:42:20.116]                     inherits <- base::inherits
[17:42:20.116]                     invokeRestart <- base::invokeRestart
[17:42:20.116]                     is.null <- base::is.null
[17:42:20.116]                     muffled <- FALSE
[17:42:20.116]                     if (inherits(cond, "message")) {
[17:42:20.116]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.116]                       if (muffled) 
[17:42:20.116]                         invokeRestart("muffleMessage")
[17:42:20.116]                     }
[17:42:20.116]                     else if (inherits(cond, "warning")) {
[17:42:20.116]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.116]                       if (muffled) 
[17:42:20.116]                         invokeRestart("muffleWarning")
[17:42:20.116]                     }
[17:42:20.116]                     else if (inherits(cond, "condition")) {
[17:42:20.116]                       if (!is.null(pattern)) {
[17:42:20.116]                         computeRestarts <- base::computeRestarts
[17:42:20.116]                         grepl <- base::grepl
[17:42:20.116]                         restarts <- computeRestarts(cond)
[17:42:20.116]                         for (restart in restarts) {
[17:42:20.116]                           name <- restart$name
[17:42:20.116]                           if (is.null(name)) 
[17:42:20.116]                             next
[17:42:20.116]                           if (!grepl(pattern, name)) 
[17:42:20.116]                             next
[17:42:20.116]                           invokeRestart(restart)
[17:42:20.116]                           muffled <- TRUE
[17:42:20.116]                           break
[17:42:20.116]                         }
[17:42:20.116]                       }
[17:42:20.116]                     }
[17:42:20.116]                     invisible(muffled)
[17:42:20.116]                   }
[17:42:20.116]                   muffleCondition(cond)
[17:42:20.116]                 })
[17:42:20.116]             }))
[17:42:20.116]             future::FutureResult(value = ...future.value$value, 
[17:42:20.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.116]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.116]                     ...future.globalenv.names))
[17:42:20.116]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.116]         }, condition = base::local({
[17:42:20.116]             c <- base::c
[17:42:20.116]             inherits <- base::inherits
[17:42:20.116]             invokeRestart <- base::invokeRestart
[17:42:20.116]             length <- base::length
[17:42:20.116]             list <- base::list
[17:42:20.116]             seq.int <- base::seq.int
[17:42:20.116]             signalCondition <- base::signalCondition
[17:42:20.116]             sys.calls <- base::sys.calls
[17:42:20.116]             `[[` <- base::`[[`
[17:42:20.116]             `+` <- base::`+`
[17:42:20.116]             `<<-` <- base::`<<-`
[17:42:20.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.116]                   3L)]
[17:42:20.116]             }
[17:42:20.116]             function(cond) {
[17:42:20.116]                 is_error <- inherits(cond, "error")
[17:42:20.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.116]                   NULL)
[17:42:20.116]                 if (is_error) {
[17:42:20.116]                   sessionInformation <- function() {
[17:42:20.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.116]                       search = base::search(), system = base::Sys.info())
[17:42:20.116]                   }
[17:42:20.116]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.116]                     cond$call), session = sessionInformation(), 
[17:42:20.116]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.116]                   signalCondition(cond)
[17:42:20.116]                 }
[17:42:20.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.116]                 "immediateCondition"))) {
[17:42:20.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.116]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.116]                   if (TRUE && !signal) {
[17:42:20.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.116]                     {
[17:42:20.116]                       inherits <- base::inherits
[17:42:20.116]                       invokeRestart <- base::invokeRestart
[17:42:20.116]                       is.null <- base::is.null
[17:42:20.116]                       muffled <- FALSE
[17:42:20.116]                       if (inherits(cond, "message")) {
[17:42:20.116]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.116]                         if (muffled) 
[17:42:20.116]                           invokeRestart("muffleMessage")
[17:42:20.116]                       }
[17:42:20.116]                       else if (inherits(cond, "warning")) {
[17:42:20.116]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.116]                         if (muffled) 
[17:42:20.116]                           invokeRestart("muffleWarning")
[17:42:20.116]                       }
[17:42:20.116]                       else if (inherits(cond, "condition")) {
[17:42:20.116]                         if (!is.null(pattern)) {
[17:42:20.116]                           computeRestarts <- base::computeRestarts
[17:42:20.116]                           grepl <- base::grepl
[17:42:20.116]                           restarts <- computeRestarts(cond)
[17:42:20.116]                           for (restart in restarts) {
[17:42:20.116]                             name <- restart$name
[17:42:20.116]                             if (is.null(name)) 
[17:42:20.116]                               next
[17:42:20.116]                             if (!grepl(pattern, name)) 
[17:42:20.116]                               next
[17:42:20.116]                             invokeRestart(restart)
[17:42:20.116]                             muffled <- TRUE
[17:42:20.116]                             break
[17:42:20.116]                           }
[17:42:20.116]                         }
[17:42:20.116]                       }
[17:42:20.116]                       invisible(muffled)
[17:42:20.116]                     }
[17:42:20.116]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.116]                   }
[17:42:20.116]                 }
[17:42:20.116]                 else {
[17:42:20.116]                   if (TRUE) {
[17:42:20.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.116]                     {
[17:42:20.116]                       inherits <- base::inherits
[17:42:20.116]                       invokeRestart <- base::invokeRestart
[17:42:20.116]                       is.null <- base::is.null
[17:42:20.116]                       muffled <- FALSE
[17:42:20.116]                       if (inherits(cond, "message")) {
[17:42:20.116]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.116]                         if (muffled) 
[17:42:20.116]                           invokeRestart("muffleMessage")
[17:42:20.116]                       }
[17:42:20.116]                       else if (inherits(cond, "warning")) {
[17:42:20.116]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.116]                         if (muffled) 
[17:42:20.116]                           invokeRestart("muffleWarning")
[17:42:20.116]                       }
[17:42:20.116]                       else if (inherits(cond, "condition")) {
[17:42:20.116]                         if (!is.null(pattern)) {
[17:42:20.116]                           computeRestarts <- base::computeRestarts
[17:42:20.116]                           grepl <- base::grepl
[17:42:20.116]                           restarts <- computeRestarts(cond)
[17:42:20.116]                           for (restart in restarts) {
[17:42:20.116]                             name <- restart$name
[17:42:20.116]                             if (is.null(name)) 
[17:42:20.116]                               next
[17:42:20.116]                             if (!grepl(pattern, name)) 
[17:42:20.116]                               next
[17:42:20.116]                             invokeRestart(restart)
[17:42:20.116]                             muffled <- TRUE
[17:42:20.116]                             break
[17:42:20.116]                           }
[17:42:20.116]                         }
[17:42:20.116]                       }
[17:42:20.116]                       invisible(muffled)
[17:42:20.116]                     }
[17:42:20.116]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.116]                   }
[17:42:20.116]                 }
[17:42:20.116]             }
[17:42:20.116]         }))
[17:42:20.116]     }, error = function(ex) {
[17:42:20.116]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.116]                 ...future.rng), started = ...future.startTime, 
[17:42:20.116]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.116]             version = "1.8"), class = "FutureResult")
[17:42:20.116]     }, finally = {
[17:42:20.116]         if (!identical(...future.workdir, getwd())) 
[17:42:20.116]             setwd(...future.workdir)
[17:42:20.116]         {
[17:42:20.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.116]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.116]             }
[17:42:20.116]             base::options(...future.oldOptions)
[17:42:20.116]             if (.Platform$OS.type == "windows") {
[17:42:20.116]                 old_names <- names(...future.oldEnvVars)
[17:42:20.116]                 envs <- base::Sys.getenv()
[17:42:20.116]                 names <- names(envs)
[17:42:20.116]                 common <- intersect(names, old_names)
[17:42:20.116]                 added <- setdiff(names, old_names)
[17:42:20.116]                 removed <- setdiff(old_names, names)
[17:42:20.116]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.116]                   envs[common]]
[17:42:20.116]                 NAMES <- toupper(changed)
[17:42:20.116]                 args <- list()
[17:42:20.116]                 for (kk in seq_along(NAMES)) {
[17:42:20.116]                   name <- changed[[kk]]
[17:42:20.116]                   NAME <- NAMES[[kk]]
[17:42:20.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.116]                     next
[17:42:20.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.116]                 }
[17:42:20.116]                 NAMES <- toupper(added)
[17:42:20.116]                 for (kk in seq_along(NAMES)) {
[17:42:20.116]                   name <- added[[kk]]
[17:42:20.116]                   NAME <- NAMES[[kk]]
[17:42:20.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.116]                     next
[17:42:20.116]                   args[[name]] <- ""
[17:42:20.116]                 }
[17:42:20.116]                 NAMES <- toupper(removed)
[17:42:20.116]                 for (kk in seq_along(NAMES)) {
[17:42:20.116]                   name <- removed[[kk]]
[17:42:20.116]                   NAME <- NAMES[[kk]]
[17:42:20.116]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.116]                     next
[17:42:20.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.116]                 }
[17:42:20.116]                 if (length(args) > 0) 
[17:42:20.116]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.116]             }
[17:42:20.116]             else {
[17:42:20.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.116]             }
[17:42:20.116]             {
[17:42:20.116]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.116]                   0L) {
[17:42:20.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.116]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.116]                   base::options(opts)
[17:42:20.116]                 }
[17:42:20.116]                 {
[17:42:20.116]                   {
[17:42:20.116]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.116]                     NULL
[17:42:20.116]                   }
[17:42:20.116]                   options(future.plan = NULL)
[17:42:20.116]                   if (is.na(NA_character_)) 
[17:42:20.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.116]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:20.116]                     envir = parent.frame()) 
[17:42:20.116]                   {
[17:42:20.116]                     default_workers <- missing(workers)
[17:42:20.116]                     if (is.function(workers)) 
[17:42:20.116]                       workers <- workers()
[17:42:20.116]                     workers <- structure(as.integer(workers), 
[17:42:20.116]                       class = class(workers))
[17:42:20.116]                     stop_if_not(is.finite(workers), workers >= 
[17:42:20.116]                       1L)
[17:42:20.116]                     if ((workers == 1L && !inherits(workers, 
[17:42:20.116]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:20.116]                       if (default_workers) 
[17:42:20.116]                         supportsMulticore(warn = TRUE)
[17:42:20.116]                       return(sequential(..., envir = envir))
[17:42:20.116]                     }
[17:42:20.116]                     oopts <- options(mc.cores = workers)
[17:42:20.116]                     on.exit(options(oopts))
[17:42:20.116]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:20.116]                       envir = envir)
[17:42:20.116]                     if (!future$lazy) 
[17:42:20.116]                       future <- run(future)
[17:42:20.116]                     invisible(future)
[17:42:20.116]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.116]                 }
[17:42:20.116]             }
[17:42:20.116]         }
[17:42:20.116]     })
[17:42:20.116]     if (TRUE) {
[17:42:20.116]         base::sink(type = "output", split = FALSE)
[17:42:20.116]         if (TRUE) {
[17:42:20.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.116]         }
[17:42:20.116]         else {
[17:42:20.116]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.116]         }
[17:42:20.116]         base::close(...future.stdout)
[17:42:20.116]         ...future.stdout <- NULL
[17:42:20.116]     }
[17:42:20.116]     ...future.result$conditions <- ...future.conditions
[17:42:20.116]     ...future.result$finished <- base::Sys.time()
[17:42:20.116]     ...future.result
[17:42:20.116] }
[17:42:20.120] requestCore(): workers = 2
[17:42:20.122] MulticoreFuture started
[17:42:20.123] - Launch lazy future ... done
[17:42:20.123] run() for ‘MulticoreFuture’ ... done
List of 6
[17:42:20.124] plan(): Setting new future strategy stack:
 $ a:[17:42:20.124] List of future strategies:
[17:42:20.124] 1. sequential:
[17:42:20.124]    - args: function (..., envir = parent.frame())
[17:42:20.124]    - tweaked: FALSE
[17:42:20.124]    - call: NULL
 num 1
 $ b:[17:42:20.125] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef72490a0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7965ec0> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:42:20.127] plan(): Setting new future strategy stack:
List of 6
 $ a:[17:42:20.127] List of future strategies:
[17:42:20.127] 1. multicore:
[17:42:20.127]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:20.127]    - tweaked: FALSE
[17:42:20.127]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef72490a0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7965ec0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ :[17:42:20.132] plan(): nbrOfWorkers() = 2
 chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:20.135] resolve() on list ...
[17:42:20.136]  recursive: 0
[17:42:20.136]  length: 6
[17:42:20.136]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:20.140] signalConditionsASAP(numeric, pos=1) ...
[17:42:20.140] - nx: 6
[17:42:20.140] - relay: TRUE
[17:42:20.141] - stdout: TRUE
[17:42:20.141] - signal: TRUE
[17:42:20.141] - resignal: FALSE
[17:42:20.141] - force: TRUE
[17:42:20.142] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.142] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.142]  - until=2
[17:42:20.142]  - relaying element #2
[17:42:20.143] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.143] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.143] signalConditionsASAP(NULL, pos=1) ... done
[17:42:20.144]  length: 5 (resolved future 1)
[17:42:20.144] Future #2
[17:42:20.145] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:20.145] - nx: 6
[17:42:20.145] - relay: TRUE
[17:42:20.145] - stdout: TRUE
[17:42:20.146] - signal: TRUE
[17:42:20.146] - resignal: FALSE
[17:42:20.146] - force: TRUE
[17:42:20.146] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.146] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.146]  - until=2
[17:42:20.147]  - relaying element #2
[17:42:20.147] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.147] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.147] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:20.147]  length: 4 (resolved future 2)
[17:42:20.148] Future #3
[17:42:20.149] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:20.149] - nx: 6
[17:42:20.150] - relay: TRUE
[17:42:20.150] - stdout: TRUE
[17:42:20.150] - signal: TRUE
[17:42:20.150] - resignal: FALSE
[17:42:20.150] - force: TRUE
[17:42:20.150] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.150] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.150]  - until=3
[17:42:20.151]  - relaying element #3
[17:42:20.151] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.151] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.151] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:20.151]  length: 3 (resolved future 3)
[17:42:20.151] signalConditionsASAP(NULL, pos=4) ...
[17:42:20.152] - nx: 6
[17:42:20.152] - relay: TRUE
[17:42:20.152] - stdout: TRUE
[17:42:20.152] - signal: TRUE
[17:42:20.152] - resignal: FALSE
[17:42:20.152] - force: TRUE
[17:42:20.152] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.152] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.152]  - until=5
[17:42:20.153]  - relaying element #5
[17:42:20.153] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.153] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.153] signalConditionsASAP(NULL, pos=4) ... done
[17:42:20.153]  length: 2 (resolved future 4)
[17:42:20.153] signalConditionsASAP(NULL, pos=5) ...
[17:42:20.153] - nx: 6
[17:42:20.153] - relay: TRUE
[17:42:20.153] - stdout: TRUE
[17:42:20.153] - signal: TRUE
[17:42:20.154] - resignal: FALSE
[17:42:20.154] - force: TRUE
[17:42:20.154] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.154] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.154]  - until=6
[17:42:20.154]  - relaying element #6
[17:42:20.154] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.154] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.154] signalConditionsASAP(NULL, pos=5) ... done
[17:42:20.154]  length: 1 (resolved future 5)
[17:42:20.155] signalConditionsASAP(numeric, pos=6) ...
[17:42:20.155] - nx: 6
[17:42:20.155] - relay: TRUE
[17:42:20.155] - stdout: TRUE
[17:42:20.155] - signal: TRUE
[17:42:20.155] - resignal: FALSE
[17:42:20.155] - force: TRUE
[17:42:20.155] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.155] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.156]  - until=6
[17:42:20.156] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.156] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.156] signalConditionsASAP(numeric, pos=6) ... done
[17:42:20.156]  length: 0 (resolved future 6)
[17:42:20.156] Relaying remaining futures
[17:42:20.156] signalConditionsASAP(NULL, pos=0) ...
[17:42:20.156] - nx: 6
[17:42:20.156] - relay: TRUE
[17:42:20.156] - stdout: TRUE
[17:42:20.157] - signal: TRUE
[17:42:20.157] - resignal: FALSE
[17:42:20.157] - force: TRUE
[17:42:20.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.157] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:20.157] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.157] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.157] signalConditionsASAP(NULL, pos=0) ... done
[17:42:20.157] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:42:20.162] plan(): Setting new future strategy stack:
[17:42:20.162] List of future strategies:
[17:42:20.162] 1. multisession:
[17:42:20.162]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:20.162]    - tweaked: FALSE
[17:42:20.162]    - call: plan(strategy)
[17:42:20.162] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:20.163] multisession:
[17:42:20.163] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:20.163] - tweaked: FALSE
[17:42:20.163] - call: plan(strategy)
[17:42:20.169] getGlobalsAndPackages() ...
[17:42:20.169] Not searching for globals
[17:42:20.169] - globals: [0] <none>
[17:42:20.169] getGlobalsAndPackages() ... DONE
[17:42:20.170] [local output] makeClusterPSOCK() ...
[17:42:20.211] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:20.217] [local output] Base port: 11666
[17:42:20.217] [local output] Getting setup options for 2 cluster nodes ...
[17:42:20.217] [local output]  - Node 1 of 2 ...
[17:42:20.218] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:20.218] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec77ea96e35.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec77ea96e35.pid")'’
[17:42:20.409] - Possible to infer worker's PID: TRUE
[17:42:20.409] [local output] Rscript port: 11666

[17:42:20.409] [local output]  - Node 2 of 2 ...
[17:42:20.410] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:20.411] [local output] Rscript port: 11666

[17:42:20.411] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:20.411] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:20.412] [local output] Setting up PSOCK nodes in parallel
[17:42:20.412] List of 36
[17:42:20.412]  $ worker          : chr "localhost"
[17:42:20.412]   ..- attr(*, "localhost")= logi TRUE
[17:42:20.412]  $ master          : chr "localhost"
[17:42:20.412]  $ port            : int 11666
[17:42:20.412]  $ connectTimeout  : num 120
[17:42:20.412]  $ timeout         : num 2592000
[17:42:20.412]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:20.412]  $ homogeneous     : logi TRUE
[17:42:20.412]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:20.412]  $ rscript_envs    : NULL
[17:42:20.412]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:20.412]  $ rscript_startup : NULL
[17:42:20.412]  $ rscript_sh      : chr "sh"
[17:42:20.412]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:20.412]  $ methods         : logi TRUE
[17:42:20.412]  $ socketOptions   : chr "no-delay"
[17:42:20.412]  $ useXDR          : logi FALSE
[17:42:20.412]  $ outfile         : chr "/dev/null"
[17:42:20.412]  $ renice          : int NA
[17:42:20.412]  $ rshcmd          : NULL
[17:42:20.412]  $ user            : chr(0) 
[17:42:20.412]  $ revtunnel       : logi FALSE
[17:42:20.412]  $ rshlogfile      : NULL
[17:42:20.412]  $ rshopts         : chr(0) 
[17:42:20.412]  $ rank            : int 1
[17:42:20.412]  $ manual          : logi FALSE
[17:42:20.412]  $ dryrun          : logi FALSE
[17:42:20.412]  $ quiet           : logi FALSE
[17:42:20.412]  $ setup_strategy  : chr "parallel"
[17:42:20.412]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:20.412]  $ pidfile         : chr "/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec77ea96e35.pid"
[17:42:20.412]  $ rshcmd_label    : NULL
[17:42:20.412]  $ rsh_call        : NULL
[17:42:20.412]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:20.412]  $ localMachine    : logi TRUE
[17:42:20.412]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:20.412]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:20.412]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:20.412]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:20.412]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:20.412]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:20.412]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:20.412]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:20.412]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:20.412]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:20.412]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:20.412]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:20.412]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:20.412]  $ arguments       :List of 28
[17:42:20.412]   ..$ worker          : chr "localhost"
[17:42:20.412]   ..$ master          : NULL
[17:42:20.412]   ..$ port            : int 11666
[17:42:20.412]   ..$ connectTimeout  : num 120
[17:42:20.412]   ..$ timeout         : num 2592000
[17:42:20.412]   ..$ rscript         : NULL
[17:42:20.412]   ..$ homogeneous     : NULL
[17:42:20.412]   ..$ rscript_args    : NULL
[17:42:20.412]   ..$ rscript_envs    : NULL
[17:42:20.412]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:20.412]   ..$ rscript_startup : NULL
[17:42:20.412]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:20.412]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:20.412]   ..$ methods         : logi TRUE
[17:42:20.412]   ..$ socketOptions   : chr "no-delay"
[17:42:20.412]   ..$ useXDR          : logi FALSE
[17:42:20.412]   ..$ outfile         : chr "/dev/null"
[17:42:20.412]   ..$ renice          : int NA
[17:42:20.412]   ..$ rshcmd          : NULL
[17:42:20.412]   ..$ user            : NULL
[17:42:20.412]   ..$ revtunnel       : logi NA
[17:42:20.412]   ..$ rshlogfile      : NULL
[17:42:20.412]   ..$ rshopts         : NULL
[17:42:20.412]   ..$ rank            : int 1
[17:42:20.412]   ..$ manual          : logi FALSE
[17:42:20.412]   ..$ dryrun          : logi FALSE
[17:42:20.412]   ..$ quiet           : logi FALSE
[17:42:20.412]   ..$ setup_strategy  : chr "parallel"
[17:42:20.412]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:20.429] [local output] System call to launch all workers:
[17:42:20.429] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec77ea96e35.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11666 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:20.429] [local output] Starting PSOCK main server
[17:42:20.431] [local output] Workers launched
[17:42:20.431] [local output] Waiting for workers to connect back
[17:42:20.431]  - [local output] 0 workers out of 2 ready
[17:42:20.677]  - [local output] 0 workers out of 2 ready
[17:42:20.677]  - [local output] 1 workers out of 2 ready
[17:42:20.678]  - [local output] 2 workers out of 2 ready
[17:42:20.678] [local output] Launching of workers completed
[17:42:20.678] [local output] Collecting session information from workers
[17:42:20.679] [local output]  - Worker #1 of 2
[17:42:20.679] [local output]  - Worker #2 of 2
[17:42:20.679] [local output] makeClusterPSOCK() ... done
[17:42:20.691] Packages needed by the future expression (n = 0): <none>
[17:42:20.692] Packages needed by future strategies (n = 0): <none>
[17:42:20.692] {
[17:42:20.692]     {
[17:42:20.692]         {
[17:42:20.692]             ...future.startTime <- base::Sys.time()
[17:42:20.692]             {
[17:42:20.692]                 {
[17:42:20.692]                   {
[17:42:20.692]                     {
[17:42:20.692]                       base::local({
[17:42:20.692]                         has_future <- base::requireNamespace("future", 
[17:42:20.692]                           quietly = TRUE)
[17:42:20.692]                         if (has_future) {
[17:42:20.692]                           ns <- base::getNamespace("future")
[17:42:20.692]                           version <- ns[[".package"]][["version"]]
[17:42:20.692]                           if (is.null(version)) 
[17:42:20.692]                             version <- utils::packageVersion("future")
[17:42:20.692]                         }
[17:42:20.692]                         else {
[17:42:20.692]                           version <- NULL
[17:42:20.692]                         }
[17:42:20.692]                         if (!has_future || version < "1.8.0") {
[17:42:20.692]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.692]                             "", base::R.version$version.string), 
[17:42:20.692]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.692]                               "release", "version")], collapse = " "), 
[17:42:20.692]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.692]                             info)
[17:42:20.692]                           info <- base::paste(info, collapse = "; ")
[17:42:20.692]                           if (!has_future) {
[17:42:20.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.692]                               info)
[17:42:20.692]                           }
[17:42:20.692]                           else {
[17:42:20.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.692]                               info, version)
[17:42:20.692]                           }
[17:42:20.692]                           base::stop(msg)
[17:42:20.692]                         }
[17:42:20.692]                       })
[17:42:20.692]                     }
[17:42:20.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.692]                     base::options(mc.cores = 1L)
[17:42:20.692]                   }
[17:42:20.692]                   options(future.plan = NULL)
[17:42:20.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.692]                 }
[17:42:20.692]                 ...future.workdir <- getwd()
[17:42:20.692]             }
[17:42:20.692]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.692]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.692]         }
[17:42:20.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.692]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.692]             base::names(...future.oldOptions))
[17:42:20.692]     }
[17:42:20.692]     if (FALSE) {
[17:42:20.692]     }
[17:42:20.692]     else {
[17:42:20.692]         if (TRUE) {
[17:42:20.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.692]                 open = "w")
[17:42:20.692]         }
[17:42:20.692]         else {
[17:42:20.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.692]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.692]         }
[17:42:20.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.692]             base::sink(type = "output", split = FALSE)
[17:42:20.692]             base::close(...future.stdout)
[17:42:20.692]         }, add = TRUE)
[17:42:20.692]     }
[17:42:20.692]     ...future.frame <- base::sys.nframe()
[17:42:20.692]     ...future.conditions <- base::list()
[17:42:20.692]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.692]     if (FALSE) {
[17:42:20.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.692]     }
[17:42:20.692]     ...future.result <- base::tryCatch({
[17:42:20.692]         base::withCallingHandlers({
[17:42:20.692]             ...future.value <- base::withVisible(base::local({
[17:42:20.692]                 ...future.makeSendCondition <- local({
[17:42:20.692]                   sendCondition <- NULL
[17:42:20.692]                   function(frame = 1L) {
[17:42:20.692]                     if (is.function(sendCondition)) 
[17:42:20.692]                       return(sendCondition)
[17:42:20.692]                     ns <- getNamespace("parallel")
[17:42:20.692]                     if (exists("sendData", mode = "function", 
[17:42:20.692]                       envir = ns)) {
[17:42:20.692]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:20.692]                         envir = ns)
[17:42:20.692]                       envir <- sys.frame(frame)
[17:42:20.692]                       master <- NULL
[17:42:20.692]                       while (!identical(envir, .GlobalEnv) && 
[17:42:20.692]                         !identical(envir, emptyenv())) {
[17:42:20.692]                         if (exists("master", mode = "list", envir = envir, 
[17:42:20.692]                           inherits = FALSE)) {
[17:42:20.692]                           master <- get("master", mode = "list", 
[17:42:20.692]                             envir = envir, inherits = FALSE)
[17:42:20.692]                           if (inherits(master, c("SOCKnode", 
[17:42:20.692]                             "SOCK0node"))) {
[17:42:20.692]                             sendCondition <<- function(cond) {
[17:42:20.692]                               data <- list(type = "VALUE", value = cond, 
[17:42:20.692]                                 success = TRUE)
[17:42:20.692]                               parallel_sendData(master, data)
[17:42:20.692]                             }
[17:42:20.692]                             return(sendCondition)
[17:42:20.692]                           }
[17:42:20.692]                         }
[17:42:20.692]                         frame <- frame + 1L
[17:42:20.692]                         envir <- sys.frame(frame)
[17:42:20.692]                       }
[17:42:20.692]                     }
[17:42:20.692]                     sendCondition <<- function(cond) NULL
[17:42:20.692]                   }
[17:42:20.692]                 })
[17:42:20.692]                 withCallingHandlers({
[17:42:20.692]                   NA
[17:42:20.692]                 }, immediateCondition = function(cond) {
[17:42:20.692]                   sendCondition <- ...future.makeSendCondition()
[17:42:20.692]                   sendCondition(cond)
[17:42:20.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.692]                   {
[17:42:20.692]                     inherits <- base::inherits
[17:42:20.692]                     invokeRestart <- base::invokeRestart
[17:42:20.692]                     is.null <- base::is.null
[17:42:20.692]                     muffled <- FALSE
[17:42:20.692]                     if (inherits(cond, "message")) {
[17:42:20.692]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.692]                       if (muffled) 
[17:42:20.692]                         invokeRestart("muffleMessage")
[17:42:20.692]                     }
[17:42:20.692]                     else if (inherits(cond, "warning")) {
[17:42:20.692]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.692]                       if (muffled) 
[17:42:20.692]                         invokeRestart("muffleWarning")
[17:42:20.692]                     }
[17:42:20.692]                     else if (inherits(cond, "condition")) {
[17:42:20.692]                       if (!is.null(pattern)) {
[17:42:20.692]                         computeRestarts <- base::computeRestarts
[17:42:20.692]                         grepl <- base::grepl
[17:42:20.692]                         restarts <- computeRestarts(cond)
[17:42:20.692]                         for (restart in restarts) {
[17:42:20.692]                           name <- restart$name
[17:42:20.692]                           if (is.null(name)) 
[17:42:20.692]                             next
[17:42:20.692]                           if (!grepl(pattern, name)) 
[17:42:20.692]                             next
[17:42:20.692]                           invokeRestart(restart)
[17:42:20.692]                           muffled <- TRUE
[17:42:20.692]                           break
[17:42:20.692]                         }
[17:42:20.692]                       }
[17:42:20.692]                     }
[17:42:20.692]                     invisible(muffled)
[17:42:20.692]                   }
[17:42:20.692]                   muffleCondition(cond)
[17:42:20.692]                 })
[17:42:20.692]             }))
[17:42:20.692]             future::FutureResult(value = ...future.value$value, 
[17:42:20.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.692]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.692]                     ...future.globalenv.names))
[17:42:20.692]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.692]         }, condition = base::local({
[17:42:20.692]             c <- base::c
[17:42:20.692]             inherits <- base::inherits
[17:42:20.692]             invokeRestart <- base::invokeRestart
[17:42:20.692]             length <- base::length
[17:42:20.692]             list <- base::list
[17:42:20.692]             seq.int <- base::seq.int
[17:42:20.692]             signalCondition <- base::signalCondition
[17:42:20.692]             sys.calls <- base::sys.calls
[17:42:20.692]             `[[` <- base::`[[`
[17:42:20.692]             `+` <- base::`+`
[17:42:20.692]             `<<-` <- base::`<<-`
[17:42:20.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.692]                   3L)]
[17:42:20.692]             }
[17:42:20.692]             function(cond) {
[17:42:20.692]                 is_error <- inherits(cond, "error")
[17:42:20.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.692]                   NULL)
[17:42:20.692]                 if (is_error) {
[17:42:20.692]                   sessionInformation <- function() {
[17:42:20.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.692]                       search = base::search(), system = base::Sys.info())
[17:42:20.692]                   }
[17:42:20.692]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.692]                     cond$call), session = sessionInformation(), 
[17:42:20.692]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.692]                   signalCondition(cond)
[17:42:20.692]                 }
[17:42:20.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.692]                 "immediateCondition"))) {
[17:42:20.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.692]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.692]                   if (TRUE && !signal) {
[17:42:20.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.692]                     {
[17:42:20.692]                       inherits <- base::inherits
[17:42:20.692]                       invokeRestart <- base::invokeRestart
[17:42:20.692]                       is.null <- base::is.null
[17:42:20.692]                       muffled <- FALSE
[17:42:20.692]                       if (inherits(cond, "message")) {
[17:42:20.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.692]                         if (muffled) 
[17:42:20.692]                           invokeRestart("muffleMessage")
[17:42:20.692]                       }
[17:42:20.692]                       else if (inherits(cond, "warning")) {
[17:42:20.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.692]                         if (muffled) 
[17:42:20.692]                           invokeRestart("muffleWarning")
[17:42:20.692]                       }
[17:42:20.692]                       else if (inherits(cond, "condition")) {
[17:42:20.692]                         if (!is.null(pattern)) {
[17:42:20.692]                           computeRestarts <- base::computeRestarts
[17:42:20.692]                           grepl <- base::grepl
[17:42:20.692]                           restarts <- computeRestarts(cond)
[17:42:20.692]                           for (restart in restarts) {
[17:42:20.692]                             name <- restart$name
[17:42:20.692]                             if (is.null(name)) 
[17:42:20.692]                               next
[17:42:20.692]                             if (!grepl(pattern, name)) 
[17:42:20.692]                               next
[17:42:20.692]                             invokeRestart(restart)
[17:42:20.692]                             muffled <- TRUE
[17:42:20.692]                             break
[17:42:20.692]                           }
[17:42:20.692]                         }
[17:42:20.692]                       }
[17:42:20.692]                       invisible(muffled)
[17:42:20.692]                     }
[17:42:20.692]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.692]                   }
[17:42:20.692]                 }
[17:42:20.692]                 else {
[17:42:20.692]                   if (TRUE) {
[17:42:20.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.692]                     {
[17:42:20.692]                       inherits <- base::inherits
[17:42:20.692]                       invokeRestart <- base::invokeRestart
[17:42:20.692]                       is.null <- base::is.null
[17:42:20.692]                       muffled <- FALSE
[17:42:20.692]                       if (inherits(cond, "message")) {
[17:42:20.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.692]                         if (muffled) 
[17:42:20.692]                           invokeRestart("muffleMessage")
[17:42:20.692]                       }
[17:42:20.692]                       else if (inherits(cond, "warning")) {
[17:42:20.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.692]                         if (muffled) 
[17:42:20.692]                           invokeRestart("muffleWarning")
[17:42:20.692]                       }
[17:42:20.692]                       else if (inherits(cond, "condition")) {
[17:42:20.692]                         if (!is.null(pattern)) {
[17:42:20.692]                           computeRestarts <- base::computeRestarts
[17:42:20.692]                           grepl <- base::grepl
[17:42:20.692]                           restarts <- computeRestarts(cond)
[17:42:20.692]                           for (restart in restarts) {
[17:42:20.692]                             name <- restart$name
[17:42:20.692]                             if (is.null(name)) 
[17:42:20.692]                               next
[17:42:20.692]                             if (!grepl(pattern, name)) 
[17:42:20.692]                               next
[17:42:20.692]                             invokeRestart(restart)
[17:42:20.692]                             muffled <- TRUE
[17:42:20.692]                             break
[17:42:20.692]                           }
[17:42:20.692]                         }
[17:42:20.692]                       }
[17:42:20.692]                       invisible(muffled)
[17:42:20.692]                     }
[17:42:20.692]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.692]                   }
[17:42:20.692]                 }
[17:42:20.692]             }
[17:42:20.692]         }))
[17:42:20.692]     }, error = function(ex) {
[17:42:20.692]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.692]                 ...future.rng), started = ...future.startTime, 
[17:42:20.692]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.692]             version = "1.8"), class = "FutureResult")
[17:42:20.692]     }, finally = {
[17:42:20.692]         if (!identical(...future.workdir, getwd())) 
[17:42:20.692]             setwd(...future.workdir)
[17:42:20.692]         {
[17:42:20.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.692]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.692]             }
[17:42:20.692]             base::options(...future.oldOptions)
[17:42:20.692]             if (.Platform$OS.type == "windows") {
[17:42:20.692]                 old_names <- names(...future.oldEnvVars)
[17:42:20.692]                 envs <- base::Sys.getenv()
[17:42:20.692]                 names <- names(envs)
[17:42:20.692]                 common <- intersect(names, old_names)
[17:42:20.692]                 added <- setdiff(names, old_names)
[17:42:20.692]                 removed <- setdiff(old_names, names)
[17:42:20.692]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.692]                   envs[common]]
[17:42:20.692]                 NAMES <- toupper(changed)
[17:42:20.692]                 args <- list()
[17:42:20.692]                 for (kk in seq_along(NAMES)) {
[17:42:20.692]                   name <- changed[[kk]]
[17:42:20.692]                   NAME <- NAMES[[kk]]
[17:42:20.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.692]                     next
[17:42:20.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.692]                 }
[17:42:20.692]                 NAMES <- toupper(added)
[17:42:20.692]                 for (kk in seq_along(NAMES)) {
[17:42:20.692]                   name <- added[[kk]]
[17:42:20.692]                   NAME <- NAMES[[kk]]
[17:42:20.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.692]                     next
[17:42:20.692]                   args[[name]] <- ""
[17:42:20.692]                 }
[17:42:20.692]                 NAMES <- toupper(removed)
[17:42:20.692]                 for (kk in seq_along(NAMES)) {
[17:42:20.692]                   name <- removed[[kk]]
[17:42:20.692]                   NAME <- NAMES[[kk]]
[17:42:20.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.692]                     next
[17:42:20.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.692]                 }
[17:42:20.692]                 if (length(args) > 0) 
[17:42:20.692]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.692]             }
[17:42:20.692]             else {
[17:42:20.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.692]             }
[17:42:20.692]             {
[17:42:20.692]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.692]                   0L) {
[17:42:20.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.692]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.692]                   base::options(opts)
[17:42:20.692]                 }
[17:42:20.692]                 {
[17:42:20.692]                   {
[17:42:20.692]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.692]                     NULL
[17:42:20.692]                   }
[17:42:20.692]                   options(future.plan = NULL)
[17:42:20.692]                   if (is.na(NA_character_)) 
[17:42:20.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.692]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:20.692]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:20.692]                     envir = parent.frame()) 
[17:42:20.692]                   {
[17:42:20.692]                     if (is.function(workers)) 
[17:42:20.692]                       workers <- workers()
[17:42:20.692]                     workers <- structure(as.integer(workers), 
[17:42:20.692]                       class = class(workers))
[17:42:20.692]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:20.692]                       workers >= 1)
[17:42:20.692]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:20.692]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:20.692]                     }
[17:42:20.692]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:20.692]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:20.692]                       envir = envir)
[17:42:20.692]                     if (!future$lazy) 
[17:42:20.692]                       future <- run(future)
[17:42:20.692]                     invisible(future)
[17:42:20.692]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.692]                 }
[17:42:20.692]             }
[17:42:20.692]         }
[17:42:20.692]     })
[17:42:20.692]     if (TRUE) {
[17:42:20.692]         base::sink(type = "output", split = FALSE)
[17:42:20.692]         if (TRUE) {
[17:42:20.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.692]         }
[17:42:20.692]         else {
[17:42:20.692]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.692]         }
[17:42:20.692]         base::close(...future.stdout)
[17:42:20.692]         ...future.stdout <- NULL
[17:42:20.692]     }
[17:42:20.692]     ...future.result$conditions <- ...future.conditions
[17:42:20.692]     ...future.result$finished <- base::Sys.time()
[17:42:20.692]     ...future.result
[17:42:20.692] }
[17:42:20.766] MultisessionFuture started
[17:42:20.767] result() for ClusterFuture ...
[17:42:20.768] receiveMessageFromWorker() for ClusterFuture ...
[17:42:20.768] - Validating connection of MultisessionFuture
[17:42:20.801] - received message: FutureResult
[17:42:20.801] - Received FutureResult
[17:42:20.801] - Erased future from FutureRegistry
[17:42:20.802] result() for ClusterFuture ...
[17:42:20.802] - result already collected: FutureResult
[17:42:20.802] result() for ClusterFuture ... done
[17:42:20.802] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:20.802] result() for ClusterFuture ... done
[17:42:20.802] result() for ClusterFuture ...
[17:42:20.802] - result already collected: FutureResult
[17:42:20.802] result() for ClusterFuture ... done
[17:42:20.803] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:20.807] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:42:20.807] getGlobalsAndPackages() ...
[17:42:20.807] Searching for globals...
[17:42:20.807] 
[17:42:20.808] Searching for globals ... DONE
[17:42:20.808] - globals: [0] <none>
[17:42:20.808] getGlobalsAndPackages() ... DONE
[17:42:20.808] run() for ‘Future’ ...
[17:42:20.808] - state: ‘created’
[17:42:20.808] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.823] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:20.824]   - Field: ‘node’
[17:42:20.824]   - Field: ‘label’
[17:42:20.824]   - Field: ‘local’
[17:42:20.824]   - Field: ‘owner’
[17:42:20.824]   - Field: ‘envir’
[17:42:20.824]   - Field: ‘workers’
[17:42:20.824]   - Field: ‘packages’
[17:42:20.824]   - Field: ‘gc’
[17:42:20.824]   - Field: ‘conditions’
[17:42:20.824]   - Field: ‘persistent’
[17:42:20.825]   - Field: ‘expr’
[17:42:20.825]   - Field: ‘uuid’
[17:42:20.825]   - Field: ‘seed’
[17:42:20.825]   - Field: ‘version’
[17:42:20.825]   - Field: ‘result’
[17:42:20.825]   - Field: ‘asynchronous’
[17:42:20.825]   - Field: ‘calls’
[17:42:20.825]   - Field: ‘globals’
[17:42:20.826]   - Field: ‘stdout’
[17:42:20.826]   - Field: ‘earlySignal’
[17:42:20.826]   - Field: ‘lazy’
[17:42:20.826]   - Field: ‘state’
[17:42:20.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:20.826] - Launch lazy future ...
[17:42:20.826] Packages needed by the future expression (n = 0): <none>
[17:42:20.827] Packages needed by future strategies (n = 0): <none>
[17:42:20.827] {
[17:42:20.827]     {
[17:42:20.827]         {
[17:42:20.827]             ...future.startTime <- base::Sys.time()
[17:42:20.827]             {
[17:42:20.827]                 {
[17:42:20.827]                   {
[17:42:20.827]                     {
[17:42:20.827]                       base::local({
[17:42:20.827]                         has_future <- base::requireNamespace("future", 
[17:42:20.827]                           quietly = TRUE)
[17:42:20.827]                         if (has_future) {
[17:42:20.827]                           ns <- base::getNamespace("future")
[17:42:20.827]                           version <- ns[[".package"]][["version"]]
[17:42:20.827]                           if (is.null(version)) 
[17:42:20.827]                             version <- utils::packageVersion("future")
[17:42:20.827]                         }
[17:42:20.827]                         else {
[17:42:20.827]                           version <- NULL
[17:42:20.827]                         }
[17:42:20.827]                         if (!has_future || version < "1.8.0") {
[17:42:20.827]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.827]                             "", base::R.version$version.string), 
[17:42:20.827]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.827]                               "release", "version")], collapse = " "), 
[17:42:20.827]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.827]                             info)
[17:42:20.827]                           info <- base::paste(info, collapse = "; ")
[17:42:20.827]                           if (!has_future) {
[17:42:20.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.827]                               info)
[17:42:20.827]                           }
[17:42:20.827]                           else {
[17:42:20.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.827]                               info, version)
[17:42:20.827]                           }
[17:42:20.827]                           base::stop(msg)
[17:42:20.827]                         }
[17:42:20.827]                       })
[17:42:20.827]                     }
[17:42:20.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.827]                     base::options(mc.cores = 1L)
[17:42:20.827]                   }
[17:42:20.827]                   options(future.plan = NULL)
[17:42:20.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.827]                 }
[17:42:20.827]                 ...future.workdir <- getwd()
[17:42:20.827]             }
[17:42:20.827]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.827]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.827]         }
[17:42:20.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.827]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.827]             base::names(...future.oldOptions))
[17:42:20.827]     }
[17:42:20.827]     if (FALSE) {
[17:42:20.827]     }
[17:42:20.827]     else {
[17:42:20.827]         if (TRUE) {
[17:42:20.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.827]                 open = "w")
[17:42:20.827]         }
[17:42:20.827]         else {
[17:42:20.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.827]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.827]         }
[17:42:20.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.827]             base::sink(type = "output", split = FALSE)
[17:42:20.827]             base::close(...future.stdout)
[17:42:20.827]         }, add = TRUE)
[17:42:20.827]     }
[17:42:20.827]     ...future.frame <- base::sys.nframe()
[17:42:20.827]     ...future.conditions <- base::list()
[17:42:20.827]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.827]     if (FALSE) {
[17:42:20.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.827]     }
[17:42:20.827]     ...future.result <- base::tryCatch({
[17:42:20.827]         base::withCallingHandlers({
[17:42:20.827]             ...future.value <- base::withVisible(base::local({
[17:42:20.827]                 ...future.makeSendCondition <- local({
[17:42:20.827]                   sendCondition <- NULL
[17:42:20.827]                   function(frame = 1L) {
[17:42:20.827]                     if (is.function(sendCondition)) 
[17:42:20.827]                       return(sendCondition)
[17:42:20.827]                     ns <- getNamespace("parallel")
[17:42:20.827]                     if (exists("sendData", mode = "function", 
[17:42:20.827]                       envir = ns)) {
[17:42:20.827]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:20.827]                         envir = ns)
[17:42:20.827]                       envir <- sys.frame(frame)
[17:42:20.827]                       master <- NULL
[17:42:20.827]                       while (!identical(envir, .GlobalEnv) && 
[17:42:20.827]                         !identical(envir, emptyenv())) {
[17:42:20.827]                         if (exists("master", mode = "list", envir = envir, 
[17:42:20.827]                           inherits = FALSE)) {
[17:42:20.827]                           master <- get("master", mode = "list", 
[17:42:20.827]                             envir = envir, inherits = FALSE)
[17:42:20.827]                           if (inherits(master, c("SOCKnode", 
[17:42:20.827]                             "SOCK0node"))) {
[17:42:20.827]                             sendCondition <<- function(cond) {
[17:42:20.827]                               data <- list(type = "VALUE", value = cond, 
[17:42:20.827]                                 success = TRUE)
[17:42:20.827]                               parallel_sendData(master, data)
[17:42:20.827]                             }
[17:42:20.827]                             return(sendCondition)
[17:42:20.827]                           }
[17:42:20.827]                         }
[17:42:20.827]                         frame <- frame + 1L
[17:42:20.827]                         envir <- sys.frame(frame)
[17:42:20.827]                       }
[17:42:20.827]                     }
[17:42:20.827]                     sendCondition <<- function(cond) NULL
[17:42:20.827]                   }
[17:42:20.827]                 })
[17:42:20.827]                 withCallingHandlers({
[17:42:20.827]                   2
[17:42:20.827]                 }, immediateCondition = function(cond) {
[17:42:20.827]                   sendCondition <- ...future.makeSendCondition()
[17:42:20.827]                   sendCondition(cond)
[17:42:20.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.827]                   {
[17:42:20.827]                     inherits <- base::inherits
[17:42:20.827]                     invokeRestart <- base::invokeRestart
[17:42:20.827]                     is.null <- base::is.null
[17:42:20.827]                     muffled <- FALSE
[17:42:20.827]                     if (inherits(cond, "message")) {
[17:42:20.827]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.827]                       if (muffled) 
[17:42:20.827]                         invokeRestart("muffleMessage")
[17:42:20.827]                     }
[17:42:20.827]                     else if (inherits(cond, "warning")) {
[17:42:20.827]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.827]                       if (muffled) 
[17:42:20.827]                         invokeRestart("muffleWarning")
[17:42:20.827]                     }
[17:42:20.827]                     else if (inherits(cond, "condition")) {
[17:42:20.827]                       if (!is.null(pattern)) {
[17:42:20.827]                         computeRestarts <- base::computeRestarts
[17:42:20.827]                         grepl <- base::grepl
[17:42:20.827]                         restarts <- computeRestarts(cond)
[17:42:20.827]                         for (restart in restarts) {
[17:42:20.827]                           name <- restart$name
[17:42:20.827]                           if (is.null(name)) 
[17:42:20.827]                             next
[17:42:20.827]                           if (!grepl(pattern, name)) 
[17:42:20.827]                             next
[17:42:20.827]                           invokeRestart(restart)
[17:42:20.827]                           muffled <- TRUE
[17:42:20.827]                           break
[17:42:20.827]                         }
[17:42:20.827]                       }
[17:42:20.827]                     }
[17:42:20.827]                     invisible(muffled)
[17:42:20.827]                   }
[17:42:20.827]                   muffleCondition(cond)
[17:42:20.827]                 })
[17:42:20.827]             }))
[17:42:20.827]             future::FutureResult(value = ...future.value$value, 
[17:42:20.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.827]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.827]                     ...future.globalenv.names))
[17:42:20.827]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.827]         }, condition = base::local({
[17:42:20.827]             c <- base::c
[17:42:20.827]             inherits <- base::inherits
[17:42:20.827]             invokeRestart <- base::invokeRestart
[17:42:20.827]             length <- base::length
[17:42:20.827]             list <- base::list
[17:42:20.827]             seq.int <- base::seq.int
[17:42:20.827]             signalCondition <- base::signalCondition
[17:42:20.827]             sys.calls <- base::sys.calls
[17:42:20.827]             `[[` <- base::`[[`
[17:42:20.827]             `+` <- base::`+`
[17:42:20.827]             `<<-` <- base::`<<-`
[17:42:20.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.827]                   3L)]
[17:42:20.827]             }
[17:42:20.827]             function(cond) {
[17:42:20.827]                 is_error <- inherits(cond, "error")
[17:42:20.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.827]                   NULL)
[17:42:20.827]                 if (is_error) {
[17:42:20.827]                   sessionInformation <- function() {
[17:42:20.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.827]                       search = base::search(), system = base::Sys.info())
[17:42:20.827]                   }
[17:42:20.827]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.827]                     cond$call), session = sessionInformation(), 
[17:42:20.827]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.827]                   signalCondition(cond)
[17:42:20.827]                 }
[17:42:20.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.827]                 "immediateCondition"))) {
[17:42:20.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.827]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.827]                   if (TRUE && !signal) {
[17:42:20.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.827]                     {
[17:42:20.827]                       inherits <- base::inherits
[17:42:20.827]                       invokeRestart <- base::invokeRestart
[17:42:20.827]                       is.null <- base::is.null
[17:42:20.827]                       muffled <- FALSE
[17:42:20.827]                       if (inherits(cond, "message")) {
[17:42:20.827]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.827]                         if (muffled) 
[17:42:20.827]                           invokeRestart("muffleMessage")
[17:42:20.827]                       }
[17:42:20.827]                       else if (inherits(cond, "warning")) {
[17:42:20.827]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.827]                         if (muffled) 
[17:42:20.827]                           invokeRestart("muffleWarning")
[17:42:20.827]                       }
[17:42:20.827]                       else if (inherits(cond, "condition")) {
[17:42:20.827]                         if (!is.null(pattern)) {
[17:42:20.827]                           computeRestarts <- base::computeRestarts
[17:42:20.827]                           grepl <- base::grepl
[17:42:20.827]                           restarts <- computeRestarts(cond)
[17:42:20.827]                           for (restart in restarts) {
[17:42:20.827]                             name <- restart$name
[17:42:20.827]                             if (is.null(name)) 
[17:42:20.827]                               next
[17:42:20.827]                             if (!grepl(pattern, name)) 
[17:42:20.827]                               next
[17:42:20.827]                             invokeRestart(restart)
[17:42:20.827]                             muffled <- TRUE
[17:42:20.827]                             break
[17:42:20.827]                           }
[17:42:20.827]                         }
[17:42:20.827]                       }
[17:42:20.827]                       invisible(muffled)
[17:42:20.827]                     }
[17:42:20.827]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.827]                   }
[17:42:20.827]                 }
[17:42:20.827]                 else {
[17:42:20.827]                   if (TRUE) {
[17:42:20.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.827]                     {
[17:42:20.827]                       inherits <- base::inherits
[17:42:20.827]                       invokeRestart <- base::invokeRestart
[17:42:20.827]                       is.null <- base::is.null
[17:42:20.827]                       muffled <- FALSE
[17:42:20.827]                       if (inherits(cond, "message")) {
[17:42:20.827]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.827]                         if (muffled) 
[17:42:20.827]                           invokeRestart("muffleMessage")
[17:42:20.827]                       }
[17:42:20.827]                       else if (inherits(cond, "warning")) {
[17:42:20.827]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.827]                         if (muffled) 
[17:42:20.827]                           invokeRestart("muffleWarning")
[17:42:20.827]                       }
[17:42:20.827]                       else if (inherits(cond, "condition")) {
[17:42:20.827]                         if (!is.null(pattern)) {
[17:42:20.827]                           computeRestarts <- base::computeRestarts
[17:42:20.827]                           grepl <- base::grepl
[17:42:20.827]                           restarts <- computeRestarts(cond)
[17:42:20.827]                           for (restart in restarts) {
[17:42:20.827]                             name <- restart$name
[17:42:20.827]                             if (is.null(name)) 
[17:42:20.827]                               next
[17:42:20.827]                             if (!grepl(pattern, name)) 
[17:42:20.827]                               next
[17:42:20.827]                             invokeRestart(restart)
[17:42:20.827]                             muffled <- TRUE
[17:42:20.827]                             break
[17:42:20.827]                           }
[17:42:20.827]                         }
[17:42:20.827]                       }
[17:42:20.827]                       invisible(muffled)
[17:42:20.827]                     }
[17:42:20.827]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.827]                   }
[17:42:20.827]                 }
[17:42:20.827]             }
[17:42:20.827]         }))
[17:42:20.827]     }, error = function(ex) {
[17:42:20.827]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.827]                 ...future.rng), started = ...future.startTime, 
[17:42:20.827]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.827]             version = "1.8"), class = "FutureResult")
[17:42:20.827]     }, finally = {
[17:42:20.827]         if (!identical(...future.workdir, getwd())) 
[17:42:20.827]             setwd(...future.workdir)
[17:42:20.827]         {
[17:42:20.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.827]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.827]             }
[17:42:20.827]             base::options(...future.oldOptions)
[17:42:20.827]             if (.Platform$OS.type == "windows") {
[17:42:20.827]                 old_names <- names(...future.oldEnvVars)
[17:42:20.827]                 envs <- base::Sys.getenv()
[17:42:20.827]                 names <- names(envs)
[17:42:20.827]                 common <- intersect(names, old_names)
[17:42:20.827]                 added <- setdiff(names, old_names)
[17:42:20.827]                 removed <- setdiff(old_names, names)
[17:42:20.827]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.827]                   envs[common]]
[17:42:20.827]                 NAMES <- toupper(changed)
[17:42:20.827]                 args <- list()
[17:42:20.827]                 for (kk in seq_along(NAMES)) {
[17:42:20.827]                   name <- changed[[kk]]
[17:42:20.827]                   NAME <- NAMES[[kk]]
[17:42:20.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.827]                     next
[17:42:20.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.827]                 }
[17:42:20.827]                 NAMES <- toupper(added)
[17:42:20.827]                 for (kk in seq_along(NAMES)) {
[17:42:20.827]                   name <- added[[kk]]
[17:42:20.827]                   NAME <- NAMES[[kk]]
[17:42:20.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.827]                     next
[17:42:20.827]                   args[[name]] <- ""
[17:42:20.827]                 }
[17:42:20.827]                 NAMES <- toupper(removed)
[17:42:20.827]                 for (kk in seq_along(NAMES)) {
[17:42:20.827]                   name <- removed[[kk]]
[17:42:20.827]                   NAME <- NAMES[[kk]]
[17:42:20.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.827]                     next
[17:42:20.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.827]                 }
[17:42:20.827]                 if (length(args) > 0) 
[17:42:20.827]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.827]             }
[17:42:20.827]             else {
[17:42:20.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.827]             }
[17:42:20.827]             {
[17:42:20.827]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.827]                   0L) {
[17:42:20.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.827]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.827]                   base::options(opts)
[17:42:20.827]                 }
[17:42:20.827]                 {
[17:42:20.827]                   {
[17:42:20.827]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.827]                     NULL
[17:42:20.827]                   }
[17:42:20.827]                   options(future.plan = NULL)
[17:42:20.827]                   if (is.na(NA_character_)) 
[17:42:20.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.827]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:20.827]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:20.827]                     envir = parent.frame()) 
[17:42:20.827]                   {
[17:42:20.827]                     if (is.function(workers)) 
[17:42:20.827]                       workers <- workers()
[17:42:20.827]                     workers <- structure(as.integer(workers), 
[17:42:20.827]                       class = class(workers))
[17:42:20.827]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:20.827]                       workers >= 1)
[17:42:20.827]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:20.827]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:20.827]                     }
[17:42:20.827]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:20.827]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:20.827]                       envir = envir)
[17:42:20.827]                     if (!future$lazy) 
[17:42:20.827]                       future <- run(future)
[17:42:20.827]                     invisible(future)
[17:42:20.827]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.827]                 }
[17:42:20.827]             }
[17:42:20.827]         }
[17:42:20.827]     })
[17:42:20.827]     if (TRUE) {
[17:42:20.827]         base::sink(type = "output", split = FALSE)
[17:42:20.827]         if (TRUE) {
[17:42:20.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.827]         }
[17:42:20.827]         else {
[17:42:20.827]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.827]         }
[17:42:20.827]         base::close(...future.stdout)
[17:42:20.827]         ...future.stdout <- NULL
[17:42:20.827]     }
[17:42:20.827]     ...future.result$conditions <- ...future.conditions
[17:42:20.827]     ...future.result$finished <- base::Sys.time()
[17:42:20.827]     ...future.result
[17:42:20.827] }
[17:42:20.831] MultisessionFuture started
[17:42:20.831] - Launch lazy future ... done
[17:42:20.831] run() for ‘MultisessionFuture’ ... done
[17:42:20.831] getGlobalsAndPackages() ...
[17:42:20.831] Searching for globals...
[17:42:20.832] 
[17:42:20.832] Searching for globals ... DONE
[17:42:20.832] - globals: [0] <none>
[17:42:20.832] getGlobalsAndPackages() ... DONE
[17:42:20.832] run() for ‘Future’ ...
[17:42:20.832] - state: ‘created’
[17:42:20.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.848] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:20.848]   - Field: ‘node’
[17:42:20.848]   - Field: ‘label’
[17:42:20.849]   - Field: ‘local’
[17:42:20.849]   - Field: ‘owner’
[17:42:20.849]   - Field: ‘envir’
[17:42:20.849]   - Field: ‘workers’
[17:42:20.849]   - Field: ‘packages’
[17:42:20.849]   - Field: ‘gc’
[17:42:20.849]   - Field: ‘conditions’
[17:42:20.849]   - Field: ‘persistent’
[17:42:20.849]   - Field: ‘expr’
[17:42:20.850]   - Field: ‘uuid’
[17:42:20.850]   - Field: ‘seed’
[17:42:20.850]   - Field: ‘version’
[17:42:20.850]   - Field: ‘result’
[17:42:20.850]   - Field: ‘asynchronous’
[17:42:20.850]   - Field: ‘calls’
[17:42:20.850]   - Field: ‘globals’
[17:42:20.850]   - Field: ‘stdout’
[17:42:20.850]   - Field: ‘earlySignal’
[17:42:20.851]   - Field: ‘lazy’
[17:42:20.851]   - Field: ‘state’
[17:42:20.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:20.851] - Launch lazy future ...
[17:42:20.851] Packages needed by the future expression (n = 0): <none>
[17:42:20.851] Packages needed by future strategies (n = 0): <none>
[17:42:20.852] {
[17:42:20.852]     {
[17:42:20.852]         {
[17:42:20.852]             ...future.startTime <- base::Sys.time()
[17:42:20.852]             {
[17:42:20.852]                 {
[17:42:20.852]                   {
[17:42:20.852]                     {
[17:42:20.852]                       base::local({
[17:42:20.852]                         has_future <- base::requireNamespace("future", 
[17:42:20.852]                           quietly = TRUE)
[17:42:20.852]                         if (has_future) {
[17:42:20.852]                           ns <- base::getNamespace("future")
[17:42:20.852]                           version <- ns[[".package"]][["version"]]
[17:42:20.852]                           if (is.null(version)) 
[17:42:20.852]                             version <- utils::packageVersion("future")
[17:42:20.852]                         }
[17:42:20.852]                         else {
[17:42:20.852]                           version <- NULL
[17:42:20.852]                         }
[17:42:20.852]                         if (!has_future || version < "1.8.0") {
[17:42:20.852]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.852]                             "", base::R.version$version.string), 
[17:42:20.852]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.852]                               "release", "version")], collapse = " "), 
[17:42:20.852]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.852]                             info)
[17:42:20.852]                           info <- base::paste(info, collapse = "; ")
[17:42:20.852]                           if (!has_future) {
[17:42:20.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.852]                               info)
[17:42:20.852]                           }
[17:42:20.852]                           else {
[17:42:20.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.852]                               info, version)
[17:42:20.852]                           }
[17:42:20.852]                           base::stop(msg)
[17:42:20.852]                         }
[17:42:20.852]                       })
[17:42:20.852]                     }
[17:42:20.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.852]                     base::options(mc.cores = 1L)
[17:42:20.852]                   }
[17:42:20.852]                   options(future.plan = NULL)
[17:42:20.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.852]                 }
[17:42:20.852]                 ...future.workdir <- getwd()
[17:42:20.852]             }
[17:42:20.852]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.852]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.852]         }
[17:42:20.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.852]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.852]             base::names(...future.oldOptions))
[17:42:20.852]     }
[17:42:20.852]     if (FALSE) {
[17:42:20.852]     }
[17:42:20.852]     else {
[17:42:20.852]         if (TRUE) {
[17:42:20.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.852]                 open = "w")
[17:42:20.852]         }
[17:42:20.852]         else {
[17:42:20.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.852]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.852]         }
[17:42:20.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.852]             base::sink(type = "output", split = FALSE)
[17:42:20.852]             base::close(...future.stdout)
[17:42:20.852]         }, add = TRUE)
[17:42:20.852]     }
[17:42:20.852]     ...future.frame <- base::sys.nframe()
[17:42:20.852]     ...future.conditions <- base::list()
[17:42:20.852]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.852]     if (FALSE) {
[17:42:20.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.852]     }
[17:42:20.852]     ...future.result <- base::tryCatch({
[17:42:20.852]         base::withCallingHandlers({
[17:42:20.852]             ...future.value <- base::withVisible(base::local({
[17:42:20.852]                 ...future.makeSendCondition <- local({
[17:42:20.852]                   sendCondition <- NULL
[17:42:20.852]                   function(frame = 1L) {
[17:42:20.852]                     if (is.function(sendCondition)) 
[17:42:20.852]                       return(sendCondition)
[17:42:20.852]                     ns <- getNamespace("parallel")
[17:42:20.852]                     if (exists("sendData", mode = "function", 
[17:42:20.852]                       envir = ns)) {
[17:42:20.852]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:20.852]                         envir = ns)
[17:42:20.852]                       envir <- sys.frame(frame)
[17:42:20.852]                       master <- NULL
[17:42:20.852]                       while (!identical(envir, .GlobalEnv) && 
[17:42:20.852]                         !identical(envir, emptyenv())) {
[17:42:20.852]                         if (exists("master", mode = "list", envir = envir, 
[17:42:20.852]                           inherits = FALSE)) {
[17:42:20.852]                           master <- get("master", mode = "list", 
[17:42:20.852]                             envir = envir, inherits = FALSE)
[17:42:20.852]                           if (inherits(master, c("SOCKnode", 
[17:42:20.852]                             "SOCK0node"))) {
[17:42:20.852]                             sendCondition <<- function(cond) {
[17:42:20.852]                               data <- list(type = "VALUE", value = cond, 
[17:42:20.852]                                 success = TRUE)
[17:42:20.852]                               parallel_sendData(master, data)
[17:42:20.852]                             }
[17:42:20.852]                             return(sendCondition)
[17:42:20.852]                           }
[17:42:20.852]                         }
[17:42:20.852]                         frame <- frame + 1L
[17:42:20.852]                         envir <- sys.frame(frame)
[17:42:20.852]                       }
[17:42:20.852]                     }
[17:42:20.852]                     sendCondition <<- function(cond) NULL
[17:42:20.852]                   }
[17:42:20.852]                 })
[17:42:20.852]                 withCallingHandlers({
[17:42:20.852]                   NULL
[17:42:20.852]                 }, immediateCondition = function(cond) {
[17:42:20.852]                   sendCondition <- ...future.makeSendCondition()
[17:42:20.852]                   sendCondition(cond)
[17:42:20.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.852]                   {
[17:42:20.852]                     inherits <- base::inherits
[17:42:20.852]                     invokeRestart <- base::invokeRestart
[17:42:20.852]                     is.null <- base::is.null
[17:42:20.852]                     muffled <- FALSE
[17:42:20.852]                     if (inherits(cond, "message")) {
[17:42:20.852]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.852]                       if (muffled) 
[17:42:20.852]                         invokeRestart("muffleMessage")
[17:42:20.852]                     }
[17:42:20.852]                     else if (inherits(cond, "warning")) {
[17:42:20.852]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.852]                       if (muffled) 
[17:42:20.852]                         invokeRestart("muffleWarning")
[17:42:20.852]                     }
[17:42:20.852]                     else if (inherits(cond, "condition")) {
[17:42:20.852]                       if (!is.null(pattern)) {
[17:42:20.852]                         computeRestarts <- base::computeRestarts
[17:42:20.852]                         grepl <- base::grepl
[17:42:20.852]                         restarts <- computeRestarts(cond)
[17:42:20.852]                         for (restart in restarts) {
[17:42:20.852]                           name <- restart$name
[17:42:20.852]                           if (is.null(name)) 
[17:42:20.852]                             next
[17:42:20.852]                           if (!grepl(pattern, name)) 
[17:42:20.852]                             next
[17:42:20.852]                           invokeRestart(restart)
[17:42:20.852]                           muffled <- TRUE
[17:42:20.852]                           break
[17:42:20.852]                         }
[17:42:20.852]                       }
[17:42:20.852]                     }
[17:42:20.852]                     invisible(muffled)
[17:42:20.852]                   }
[17:42:20.852]                   muffleCondition(cond)
[17:42:20.852]                 })
[17:42:20.852]             }))
[17:42:20.852]             future::FutureResult(value = ...future.value$value, 
[17:42:20.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.852]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.852]                     ...future.globalenv.names))
[17:42:20.852]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.852]         }, condition = base::local({
[17:42:20.852]             c <- base::c
[17:42:20.852]             inherits <- base::inherits
[17:42:20.852]             invokeRestart <- base::invokeRestart
[17:42:20.852]             length <- base::length
[17:42:20.852]             list <- base::list
[17:42:20.852]             seq.int <- base::seq.int
[17:42:20.852]             signalCondition <- base::signalCondition
[17:42:20.852]             sys.calls <- base::sys.calls
[17:42:20.852]             `[[` <- base::`[[`
[17:42:20.852]             `+` <- base::`+`
[17:42:20.852]             `<<-` <- base::`<<-`
[17:42:20.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.852]                   3L)]
[17:42:20.852]             }
[17:42:20.852]             function(cond) {
[17:42:20.852]                 is_error <- inherits(cond, "error")
[17:42:20.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.852]                   NULL)
[17:42:20.852]                 if (is_error) {
[17:42:20.852]                   sessionInformation <- function() {
[17:42:20.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.852]                       search = base::search(), system = base::Sys.info())
[17:42:20.852]                   }
[17:42:20.852]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.852]                     cond$call), session = sessionInformation(), 
[17:42:20.852]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.852]                   signalCondition(cond)
[17:42:20.852]                 }
[17:42:20.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.852]                 "immediateCondition"))) {
[17:42:20.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.852]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.852]                   if (TRUE && !signal) {
[17:42:20.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.852]                     {
[17:42:20.852]                       inherits <- base::inherits
[17:42:20.852]                       invokeRestart <- base::invokeRestart
[17:42:20.852]                       is.null <- base::is.null
[17:42:20.852]                       muffled <- FALSE
[17:42:20.852]                       if (inherits(cond, "message")) {
[17:42:20.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.852]                         if (muffled) 
[17:42:20.852]                           invokeRestart("muffleMessage")
[17:42:20.852]                       }
[17:42:20.852]                       else if (inherits(cond, "warning")) {
[17:42:20.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.852]                         if (muffled) 
[17:42:20.852]                           invokeRestart("muffleWarning")
[17:42:20.852]                       }
[17:42:20.852]                       else if (inherits(cond, "condition")) {
[17:42:20.852]                         if (!is.null(pattern)) {
[17:42:20.852]                           computeRestarts <- base::computeRestarts
[17:42:20.852]                           grepl <- base::grepl
[17:42:20.852]                           restarts <- computeRestarts(cond)
[17:42:20.852]                           for (restart in restarts) {
[17:42:20.852]                             name <- restart$name
[17:42:20.852]                             if (is.null(name)) 
[17:42:20.852]                               next
[17:42:20.852]                             if (!grepl(pattern, name)) 
[17:42:20.852]                               next
[17:42:20.852]                             invokeRestart(restart)
[17:42:20.852]                             muffled <- TRUE
[17:42:20.852]                             break
[17:42:20.852]                           }
[17:42:20.852]                         }
[17:42:20.852]                       }
[17:42:20.852]                       invisible(muffled)
[17:42:20.852]                     }
[17:42:20.852]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.852]                   }
[17:42:20.852]                 }
[17:42:20.852]                 else {
[17:42:20.852]                   if (TRUE) {
[17:42:20.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.852]                     {
[17:42:20.852]                       inherits <- base::inherits
[17:42:20.852]                       invokeRestart <- base::invokeRestart
[17:42:20.852]                       is.null <- base::is.null
[17:42:20.852]                       muffled <- FALSE
[17:42:20.852]                       if (inherits(cond, "message")) {
[17:42:20.852]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.852]                         if (muffled) 
[17:42:20.852]                           invokeRestart("muffleMessage")
[17:42:20.852]                       }
[17:42:20.852]                       else if (inherits(cond, "warning")) {
[17:42:20.852]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.852]                         if (muffled) 
[17:42:20.852]                           invokeRestart("muffleWarning")
[17:42:20.852]                       }
[17:42:20.852]                       else if (inherits(cond, "condition")) {
[17:42:20.852]                         if (!is.null(pattern)) {
[17:42:20.852]                           computeRestarts <- base::computeRestarts
[17:42:20.852]                           grepl <- base::grepl
[17:42:20.852]                           restarts <- computeRestarts(cond)
[17:42:20.852]                           for (restart in restarts) {
[17:42:20.852]                             name <- restart$name
[17:42:20.852]                             if (is.null(name)) 
[17:42:20.852]                               next
[17:42:20.852]                             if (!grepl(pattern, name)) 
[17:42:20.852]                               next
[17:42:20.852]                             invokeRestart(restart)
[17:42:20.852]                             muffled <- TRUE
[17:42:20.852]                             break
[17:42:20.852]                           }
[17:42:20.852]                         }
[17:42:20.852]                       }
[17:42:20.852]                       invisible(muffled)
[17:42:20.852]                     }
[17:42:20.852]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.852]                   }
[17:42:20.852]                 }
[17:42:20.852]             }
[17:42:20.852]         }))
[17:42:20.852]     }, error = function(ex) {
[17:42:20.852]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.852]                 ...future.rng), started = ...future.startTime, 
[17:42:20.852]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.852]             version = "1.8"), class = "FutureResult")
[17:42:20.852]     }, finally = {
[17:42:20.852]         if (!identical(...future.workdir, getwd())) 
[17:42:20.852]             setwd(...future.workdir)
[17:42:20.852]         {
[17:42:20.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.852]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.852]             }
[17:42:20.852]             base::options(...future.oldOptions)
[17:42:20.852]             if (.Platform$OS.type == "windows") {
[17:42:20.852]                 old_names <- names(...future.oldEnvVars)
[17:42:20.852]                 envs <- base::Sys.getenv()
[17:42:20.852]                 names <- names(envs)
[17:42:20.852]                 common <- intersect(names, old_names)
[17:42:20.852]                 added <- setdiff(names, old_names)
[17:42:20.852]                 removed <- setdiff(old_names, names)
[17:42:20.852]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.852]                   envs[common]]
[17:42:20.852]                 NAMES <- toupper(changed)
[17:42:20.852]                 args <- list()
[17:42:20.852]                 for (kk in seq_along(NAMES)) {
[17:42:20.852]                   name <- changed[[kk]]
[17:42:20.852]                   NAME <- NAMES[[kk]]
[17:42:20.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.852]                     next
[17:42:20.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.852]                 }
[17:42:20.852]                 NAMES <- toupper(added)
[17:42:20.852]                 for (kk in seq_along(NAMES)) {
[17:42:20.852]                   name <- added[[kk]]
[17:42:20.852]                   NAME <- NAMES[[kk]]
[17:42:20.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.852]                     next
[17:42:20.852]                   args[[name]] <- ""
[17:42:20.852]                 }
[17:42:20.852]                 NAMES <- toupper(removed)
[17:42:20.852]                 for (kk in seq_along(NAMES)) {
[17:42:20.852]                   name <- removed[[kk]]
[17:42:20.852]                   NAME <- NAMES[[kk]]
[17:42:20.852]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.852]                     next
[17:42:20.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.852]                 }
[17:42:20.852]                 if (length(args) > 0) 
[17:42:20.852]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.852]             }
[17:42:20.852]             else {
[17:42:20.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.852]             }
[17:42:20.852]             {
[17:42:20.852]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.852]                   0L) {
[17:42:20.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.852]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.852]                   base::options(opts)
[17:42:20.852]                 }
[17:42:20.852]                 {
[17:42:20.852]                   {
[17:42:20.852]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.852]                     NULL
[17:42:20.852]                   }
[17:42:20.852]                   options(future.plan = NULL)
[17:42:20.852]                   if (is.na(NA_character_)) 
[17:42:20.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.852]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:20.852]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:20.852]                     envir = parent.frame()) 
[17:42:20.852]                   {
[17:42:20.852]                     if (is.function(workers)) 
[17:42:20.852]                       workers <- workers()
[17:42:20.852]                     workers <- structure(as.integer(workers), 
[17:42:20.852]                       class = class(workers))
[17:42:20.852]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:20.852]                       workers >= 1)
[17:42:20.852]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:20.852]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:20.852]                     }
[17:42:20.852]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:20.852]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:20.852]                       envir = envir)
[17:42:20.852]                     if (!future$lazy) 
[17:42:20.852]                       future <- run(future)
[17:42:20.852]                     invisible(future)
[17:42:20.852]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.852]                 }
[17:42:20.852]             }
[17:42:20.852]         }
[17:42:20.852]     })
[17:42:20.852]     if (TRUE) {
[17:42:20.852]         base::sink(type = "output", split = FALSE)
[17:42:20.852]         if (TRUE) {
[17:42:20.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.852]         }
[17:42:20.852]         else {
[17:42:20.852]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.852]         }
[17:42:20.852]         base::close(...future.stdout)
[17:42:20.852]         ...future.stdout <- NULL
[17:42:20.852]     }
[17:42:20.852]     ...future.result$conditions <- ...future.conditions
[17:42:20.852]     ...future.result$finished <- base::Sys.time()
[17:42:20.852]     ...future.result
[17:42:20.852] }
[17:42:20.926] MultisessionFuture started
[17:42:20.927] - Launch lazy future ... done
[17:42:20.927] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef9119ad0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef9582600> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef9119ad0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef9582600> 
 $  : NULL
 $  : NULL
 $  : num 6
[17:42:20.932] receiveMessageFromWorker() for ClusterFuture ...
[17:42:20.933] - Validating connection of MultisessionFuture
[17:42:20.933] - received message: FutureResult
[17:42:20.933] - Received FutureResult
[17:42:20.933] - Erased future from FutureRegistry
[17:42:20.933] result() for ClusterFuture ...
[17:42:20.933] - result already collected: FutureResult
[17:42:20.933] result() for ClusterFuture ... done
[17:42:20.934] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:20.945] resolve() on list ...
[17:42:20.945]  recursive: 0
[17:42:20.946]  length: 6
[17:42:20.946]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:20.946] signalConditionsASAP(numeric, pos=1) ...
[17:42:20.946] - nx: 6
[17:42:20.946] - relay: TRUE
[17:42:20.946] - stdout: TRUE
[17:42:20.946] - signal: TRUE
[17:42:20.946] - resignal: FALSE
[17:42:20.946] - force: TRUE
[17:42:20.947] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.947] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.947]  - until=2
[17:42:20.947]  - relaying element #2
[17:42:20.947] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.947] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.947] signalConditionsASAP(NULL, pos=1) ... done
[17:42:20.947]  length: 5 (resolved future 1)
[17:42:20.948] Future #2
[17:42:20.948] result() for ClusterFuture ...
[17:42:20.948] - result already collected: FutureResult
[17:42:20.948] result() for ClusterFuture ... done
[17:42:20.948] result() for ClusterFuture ...
[17:42:20.948] - result already collected: FutureResult
[17:42:20.948] result() for ClusterFuture ... done
[17:42:20.948] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:20.949] - nx: 6
[17:42:20.949] - relay: TRUE
[17:42:20.949] - stdout: TRUE
[17:42:20.949] - signal: TRUE
[17:42:20.949] - resignal: FALSE
[17:42:20.949] - force: TRUE
[17:42:20.949] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.949] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:20.950]  - until=2
[17:42:20.950]  - relaying element #2
[17:42:20.950] result() for ClusterFuture ...
[17:42:20.950] - result already collected: FutureResult
[17:42:20.950] result() for ClusterFuture ... done
[17:42:20.950] result() for ClusterFuture ...
[17:42:20.950] - result already collected: FutureResult
[17:42:20.950] result() for ClusterFuture ... done
[17:42:20.951] result() for ClusterFuture ...
[17:42:20.951] - result already collected: FutureResult
[17:42:20.951] result() for ClusterFuture ... done
[17:42:20.951] result() for ClusterFuture ...
[17:42:20.951] - result already collected: FutureResult
[17:42:20.951] result() for ClusterFuture ... done
[17:42:20.951] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.951] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.952] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:20.952]  length: 4 (resolved future 2)
[17:42:20.959] receiveMessageFromWorker() for ClusterFuture ...
[17:42:20.960] - Validating connection of MultisessionFuture
[17:42:20.960] - received message: FutureResult
[17:42:20.960] - Received FutureResult
[17:42:20.960] - Erased future from FutureRegistry
[17:42:20.960] result() for ClusterFuture ...
[17:42:20.960] - result already collected: FutureResult
[17:42:20.961] result() for ClusterFuture ... done
[17:42:20.961] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:20.961] Future #3
[17:42:20.961] result() for ClusterFuture ...
[17:42:20.961] - result already collected: FutureResult
[17:42:20.961] result() for ClusterFuture ... done
[17:42:20.961] result() for ClusterFuture ...
[17:42:20.961] - result already collected: FutureResult
[17:42:20.961] result() for ClusterFuture ... done
[17:42:20.962] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:20.962] - nx: 6
[17:42:20.962] - relay: TRUE
[17:42:20.962] - stdout: TRUE
[17:42:20.962] - signal: TRUE
[17:42:20.962] - resignal: FALSE
[17:42:20.962] - force: TRUE
[17:42:20.962] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.962] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:20.963]  - until=3
[17:42:20.963]  - relaying element #3
[17:42:20.963] result() for ClusterFuture ...
[17:42:20.963] - result already collected: FutureResult
[17:42:20.963] result() for ClusterFuture ... done
[17:42:20.963] result() for ClusterFuture ...
[17:42:20.963] - result already collected: FutureResult
[17:42:20.963] result() for ClusterFuture ... done
[17:42:20.964] result() for ClusterFuture ...
[17:42:20.964] - result already collected: FutureResult
[17:42:20.964] result() for ClusterFuture ... done
[17:42:20.964] result() for ClusterFuture ...
[17:42:20.964] - result already collected: FutureResult
[17:42:20.964] result() for ClusterFuture ... done
[17:42:20.964] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.964] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.964] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:20.965]  length: 3 (resolved future 3)
[17:42:20.965] signalConditionsASAP(NULL, pos=4) ...
[17:42:20.965] - nx: 6
[17:42:20.965] - relay: TRUE
[17:42:20.965] - stdout: TRUE
[17:42:20.965] - signal: TRUE
[17:42:20.965] - resignal: FALSE
[17:42:20.965] - force: TRUE
[17:42:20.965] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.966] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.966]  - until=5
[17:42:20.966]  - relaying element #5
[17:42:20.966] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.966] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.966] signalConditionsASAP(NULL, pos=4) ... done
[17:42:20.966]  length: 2 (resolved future 4)
[17:42:20.966] signalConditionsASAP(NULL, pos=5) ...
[17:42:20.966] - nx: 6
[17:42:20.967] - relay: TRUE
[17:42:20.967] - stdout: TRUE
[17:42:20.967] - signal: TRUE
[17:42:20.967] - resignal: FALSE
[17:42:20.967] - force: TRUE
[17:42:20.967] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:20.967] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.968]  - until=6
[17:42:20.968]  - relaying element #6
[17:42:20.968] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.968] signalConditionsASAP(NULL, pos=5) ... done
[17:42:20.968]  length: 1 (resolved future 5)
[17:42:20.968] signalConditionsASAP(numeric, pos=6) ...
[17:42:20.968] - nx: 6
[17:42:20.968] - relay: TRUE
[17:42:20.969] - stdout: TRUE
[17:42:20.969] - signal: TRUE
[17:42:20.969] - resignal: FALSE
[17:42:20.969] - force: TRUE
[17:42:20.969] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:20.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.969]  - until=6
[17:42:20.969] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.970] signalConditionsASAP(numeric, pos=6) ... done
[17:42:20.970]  length: 0 (resolved future 6)
[17:42:20.970] Relaying remaining futures
[17:42:20.970] signalConditionsASAP(NULL, pos=0) ...
[17:42:20.970] - nx: 6
[17:42:20.970] - relay: TRUE
[17:42:20.970] - stdout: TRUE
[17:42:20.970] - signal: TRUE
[17:42:20.970] - resignal: FALSE
[17:42:20.973] - force: TRUE
[17:42:20.973] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.973] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:20.973] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:20.973] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:20.973] signalConditionsASAP(NULL, pos=0) ... done
[17:42:20.973] resolve() on list ... DONE
[17:42:20.973] result() for ClusterFuture ...
[17:42:20.974] - result already collected: FutureResult
[17:42:20.974] result() for ClusterFuture ... done
[17:42:20.974] result() for ClusterFuture ...
[17:42:20.974] - result already collected: FutureResult
[17:42:20.974] result() for ClusterFuture ... done
[17:42:20.974] result() for ClusterFuture ...
[17:42:20.974] - result already collected: FutureResult
[17:42:20.974] result() for ClusterFuture ... done
[17:42:20.974] result() for ClusterFuture ...
[17:42:20.974] - result already collected: FutureResult
[17:42:20.974] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[17:42:20.977] getGlobalsAndPackages() ...
[17:42:20.977] Searching for globals...
[17:42:20.977] 
[17:42:20.977] Searching for globals ... DONE
[17:42:20.977] - globals: [0] <none>
[17:42:20.977] getGlobalsAndPackages() ... DONE
[17:42:20.978] run() for ‘Future’ ...
[17:42:20.978] - state: ‘created’
[17:42:20.978] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:20.992] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:20.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:20.992]   - Field: ‘node’
[17:42:20.993]   - Field: ‘label’
[17:42:20.993]   - Field: ‘local’
[17:42:20.993]   - Field: ‘owner’
[17:42:20.993]   - Field: ‘envir’
[17:42:20.993]   - Field: ‘workers’
[17:42:20.993]   - Field: ‘packages’
[17:42:20.993]   - Field: ‘gc’
[17:42:20.993]   - Field: ‘conditions’
[17:42:20.993]   - Field: ‘persistent’
[17:42:20.993]   - Field: ‘expr’
[17:42:20.993]   - Field: ‘uuid’
[17:42:20.994]   - Field: ‘seed’
[17:42:20.994]   - Field: ‘version’
[17:42:20.994]   - Field: ‘result’
[17:42:20.994]   - Field: ‘asynchronous’
[17:42:20.994]   - Field: ‘calls’
[17:42:20.994]   - Field: ‘globals’
[17:42:20.994]   - Field: ‘stdout’
[17:42:20.994]   - Field: ‘earlySignal’
[17:42:20.994]   - Field: ‘lazy’
[17:42:20.994]   - Field: ‘state’
[17:42:20.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:20.995] - Launch lazy future ...
[17:42:20.995] Packages needed by the future expression (n = 0): <none>
[17:42:20.995] Packages needed by future strategies (n = 0): <none>
[17:42:20.995] {
[17:42:20.995]     {
[17:42:20.995]         {
[17:42:20.995]             ...future.startTime <- base::Sys.time()
[17:42:20.995]             {
[17:42:20.995]                 {
[17:42:20.995]                   {
[17:42:20.995]                     {
[17:42:20.995]                       base::local({
[17:42:20.995]                         has_future <- base::requireNamespace("future", 
[17:42:20.995]                           quietly = TRUE)
[17:42:20.995]                         if (has_future) {
[17:42:20.995]                           ns <- base::getNamespace("future")
[17:42:20.995]                           version <- ns[[".package"]][["version"]]
[17:42:20.995]                           if (is.null(version)) 
[17:42:20.995]                             version <- utils::packageVersion("future")
[17:42:20.995]                         }
[17:42:20.995]                         else {
[17:42:20.995]                           version <- NULL
[17:42:20.995]                         }
[17:42:20.995]                         if (!has_future || version < "1.8.0") {
[17:42:20.995]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:20.995]                             "", base::R.version$version.string), 
[17:42:20.995]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:20.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:20.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:20.995]                               "release", "version")], collapse = " "), 
[17:42:20.995]                             hostname = base::Sys.info()[["nodename"]])
[17:42:20.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:20.995]                             info)
[17:42:20.995]                           info <- base::paste(info, collapse = "; ")
[17:42:20.995]                           if (!has_future) {
[17:42:20.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:20.995]                               info)
[17:42:20.995]                           }
[17:42:20.995]                           else {
[17:42:20.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:20.995]                               info, version)
[17:42:20.995]                           }
[17:42:20.995]                           base::stop(msg)
[17:42:20.995]                         }
[17:42:20.995]                       })
[17:42:20.995]                     }
[17:42:20.995]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:20.995]                     base::options(mc.cores = 1L)
[17:42:20.995]                   }
[17:42:20.995]                   options(future.plan = NULL)
[17:42:20.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:20.995]                 }
[17:42:20.995]                 ...future.workdir <- getwd()
[17:42:20.995]             }
[17:42:20.995]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:20.995]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:20.995]         }
[17:42:20.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:20.995]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:20.995]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:20.995]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:20.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:20.995]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:20.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:20.995]             base::names(...future.oldOptions))
[17:42:20.995]     }
[17:42:20.995]     if (FALSE) {
[17:42:20.995]     }
[17:42:20.995]     else {
[17:42:20.995]         if (TRUE) {
[17:42:20.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:20.995]                 open = "w")
[17:42:20.995]         }
[17:42:20.995]         else {
[17:42:20.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:20.995]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:20.995]         }
[17:42:20.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:20.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:20.995]             base::sink(type = "output", split = FALSE)
[17:42:20.995]             base::close(...future.stdout)
[17:42:20.995]         }, add = TRUE)
[17:42:20.995]     }
[17:42:20.995]     ...future.frame <- base::sys.nframe()
[17:42:20.995]     ...future.conditions <- base::list()
[17:42:20.995]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:20.995]     if (FALSE) {
[17:42:20.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:20.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:20.995]     }
[17:42:20.995]     ...future.result <- base::tryCatch({
[17:42:20.995]         base::withCallingHandlers({
[17:42:20.995]             ...future.value <- base::withVisible(base::local({
[17:42:20.995]                 ...future.makeSendCondition <- local({
[17:42:20.995]                   sendCondition <- NULL
[17:42:20.995]                   function(frame = 1L) {
[17:42:20.995]                     if (is.function(sendCondition)) 
[17:42:20.995]                       return(sendCondition)
[17:42:20.995]                     ns <- getNamespace("parallel")
[17:42:20.995]                     if (exists("sendData", mode = "function", 
[17:42:20.995]                       envir = ns)) {
[17:42:20.995]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:20.995]                         envir = ns)
[17:42:20.995]                       envir <- sys.frame(frame)
[17:42:20.995]                       master <- NULL
[17:42:20.995]                       while (!identical(envir, .GlobalEnv) && 
[17:42:20.995]                         !identical(envir, emptyenv())) {
[17:42:20.995]                         if (exists("master", mode = "list", envir = envir, 
[17:42:20.995]                           inherits = FALSE)) {
[17:42:20.995]                           master <- get("master", mode = "list", 
[17:42:20.995]                             envir = envir, inherits = FALSE)
[17:42:20.995]                           if (inherits(master, c("SOCKnode", 
[17:42:20.995]                             "SOCK0node"))) {
[17:42:20.995]                             sendCondition <<- function(cond) {
[17:42:20.995]                               data <- list(type = "VALUE", value = cond, 
[17:42:20.995]                                 success = TRUE)
[17:42:20.995]                               parallel_sendData(master, data)
[17:42:20.995]                             }
[17:42:20.995]                             return(sendCondition)
[17:42:20.995]                           }
[17:42:20.995]                         }
[17:42:20.995]                         frame <- frame + 1L
[17:42:20.995]                         envir <- sys.frame(frame)
[17:42:20.995]                       }
[17:42:20.995]                     }
[17:42:20.995]                     sendCondition <<- function(cond) NULL
[17:42:20.995]                   }
[17:42:20.995]                 })
[17:42:20.995]                 withCallingHandlers({
[17:42:20.995]                   2
[17:42:20.995]                 }, immediateCondition = function(cond) {
[17:42:20.995]                   sendCondition <- ...future.makeSendCondition()
[17:42:20.995]                   sendCondition(cond)
[17:42:20.995]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.995]                   {
[17:42:20.995]                     inherits <- base::inherits
[17:42:20.995]                     invokeRestart <- base::invokeRestart
[17:42:20.995]                     is.null <- base::is.null
[17:42:20.995]                     muffled <- FALSE
[17:42:20.995]                     if (inherits(cond, "message")) {
[17:42:20.995]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:20.995]                       if (muffled) 
[17:42:20.995]                         invokeRestart("muffleMessage")
[17:42:20.995]                     }
[17:42:20.995]                     else if (inherits(cond, "warning")) {
[17:42:20.995]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:20.995]                       if (muffled) 
[17:42:20.995]                         invokeRestart("muffleWarning")
[17:42:20.995]                     }
[17:42:20.995]                     else if (inherits(cond, "condition")) {
[17:42:20.995]                       if (!is.null(pattern)) {
[17:42:20.995]                         computeRestarts <- base::computeRestarts
[17:42:20.995]                         grepl <- base::grepl
[17:42:20.995]                         restarts <- computeRestarts(cond)
[17:42:20.995]                         for (restart in restarts) {
[17:42:20.995]                           name <- restart$name
[17:42:20.995]                           if (is.null(name)) 
[17:42:20.995]                             next
[17:42:20.995]                           if (!grepl(pattern, name)) 
[17:42:20.995]                             next
[17:42:20.995]                           invokeRestart(restart)
[17:42:20.995]                           muffled <- TRUE
[17:42:20.995]                           break
[17:42:20.995]                         }
[17:42:20.995]                       }
[17:42:20.995]                     }
[17:42:20.995]                     invisible(muffled)
[17:42:20.995]                   }
[17:42:20.995]                   muffleCondition(cond)
[17:42:20.995]                 })
[17:42:20.995]             }))
[17:42:20.995]             future::FutureResult(value = ...future.value$value, 
[17:42:20.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.995]                   ...future.rng), globalenv = if (FALSE) 
[17:42:20.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:20.995]                     ...future.globalenv.names))
[17:42:20.995]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:20.995]         }, condition = base::local({
[17:42:20.995]             c <- base::c
[17:42:20.995]             inherits <- base::inherits
[17:42:20.995]             invokeRestart <- base::invokeRestart
[17:42:20.995]             length <- base::length
[17:42:20.995]             list <- base::list
[17:42:20.995]             seq.int <- base::seq.int
[17:42:20.995]             signalCondition <- base::signalCondition
[17:42:20.995]             sys.calls <- base::sys.calls
[17:42:20.995]             `[[` <- base::`[[`
[17:42:20.995]             `+` <- base::`+`
[17:42:20.995]             `<<-` <- base::`<<-`
[17:42:20.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:20.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:20.995]                   3L)]
[17:42:20.995]             }
[17:42:20.995]             function(cond) {
[17:42:20.995]                 is_error <- inherits(cond, "error")
[17:42:20.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:20.995]                   NULL)
[17:42:20.995]                 if (is_error) {
[17:42:20.995]                   sessionInformation <- function() {
[17:42:20.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:20.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:20.995]                       search = base::search(), system = base::Sys.info())
[17:42:20.995]                   }
[17:42:20.995]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:20.995]                     cond$call), session = sessionInformation(), 
[17:42:20.995]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:20.995]                   signalCondition(cond)
[17:42:20.995]                 }
[17:42:20.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:20.995]                 "immediateCondition"))) {
[17:42:20.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:20.995]                   ...future.conditions[[length(...future.conditions) + 
[17:42:20.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:20.995]                   if (TRUE && !signal) {
[17:42:20.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.995]                     {
[17:42:20.995]                       inherits <- base::inherits
[17:42:20.995]                       invokeRestart <- base::invokeRestart
[17:42:20.995]                       is.null <- base::is.null
[17:42:20.995]                       muffled <- FALSE
[17:42:20.995]                       if (inherits(cond, "message")) {
[17:42:20.995]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.995]                         if (muffled) 
[17:42:20.995]                           invokeRestart("muffleMessage")
[17:42:20.995]                       }
[17:42:20.995]                       else if (inherits(cond, "warning")) {
[17:42:20.995]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.995]                         if (muffled) 
[17:42:20.995]                           invokeRestart("muffleWarning")
[17:42:20.995]                       }
[17:42:20.995]                       else if (inherits(cond, "condition")) {
[17:42:20.995]                         if (!is.null(pattern)) {
[17:42:20.995]                           computeRestarts <- base::computeRestarts
[17:42:20.995]                           grepl <- base::grepl
[17:42:20.995]                           restarts <- computeRestarts(cond)
[17:42:20.995]                           for (restart in restarts) {
[17:42:20.995]                             name <- restart$name
[17:42:20.995]                             if (is.null(name)) 
[17:42:20.995]                               next
[17:42:20.995]                             if (!grepl(pattern, name)) 
[17:42:20.995]                               next
[17:42:20.995]                             invokeRestart(restart)
[17:42:20.995]                             muffled <- TRUE
[17:42:20.995]                             break
[17:42:20.995]                           }
[17:42:20.995]                         }
[17:42:20.995]                       }
[17:42:20.995]                       invisible(muffled)
[17:42:20.995]                     }
[17:42:20.995]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.995]                   }
[17:42:20.995]                 }
[17:42:20.995]                 else {
[17:42:20.995]                   if (TRUE) {
[17:42:20.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:20.995]                     {
[17:42:20.995]                       inherits <- base::inherits
[17:42:20.995]                       invokeRestart <- base::invokeRestart
[17:42:20.995]                       is.null <- base::is.null
[17:42:20.995]                       muffled <- FALSE
[17:42:20.995]                       if (inherits(cond, "message")) {
[17:42:20.995]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:20.995]                         if (muffled) 
[17:42:20.995]                           invokeRestart("muffleMessage")
[17:42:20.995]                       }
[17:42:20.995]                       else if (inherits(cond, "warning")) {
[17:42:20.995]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:20.995]                         if (muffled) 
[17:42:20.995]                           invokeRestart("muffleWarning")
[17:42:20.995]                       }
[17:42:20.995]                       else if (inherits(cond, "condition")) {
[17:42:20.995]                         if (!is.null(pattern)) {
[17:42:20.995]                           computeRestarts <- base::computeRestarts
[17:42:20.995]                           grepl <- base::grepl
[17:42:20.995]                           restarts <- computeRestarts(cond)
[17:42:20.995]                           for (restart in restarts) {
[17:42:20.995]                             name <- restart$name
[17:42:20.995]                             if (is.null(name)) 
[17:42:20.995]                               next
[17:42:20.995]                             if (!grepl(pattern, name)) 
[17:42:20.995]                               next
[17:42:20.995]                             invokeRestart(restart)
[17:42:20.995]                             muffled <- TRUE
[17:42:20.995]                             break
[17:42:20.995]                           }
[17:42:20.995]                         }
[17:42:20.995]                       }
[17:42:20.995]                       invisible(muffled)
[17:42:20.995]                     }
[17:42:20.995]                     muffleCondition(cond, pattern = "^muffle")
[17:42:20.995]                   }
[17:42:20.995]                 }
[17:42:20.995]             }
[17:42:20.995]         }))
[17:42:20.995]     }, error = function(ex) {
[17:42:20.995]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:20.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:20.995]                 ...future.rng), started = ...future.startTime, 
[17:42:20.995]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:20.995]             version = "1.8"), class = "FutureResult")
[17:42:20.995]     }, finally = {
[17:42:20.995]         if (!identical(...future.workdir, getwd())) 
[17:42:20.995]             setwd(...future.workdir)
[17:42:20.995]         {
[17:42:20.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:20.995]                 ...future.oldOptions$nwarnings <- NULL
[17:42:20.995]             }
[17:42:20.995]             base::options(...future.oldOptions)
[17:42:20.995]             if (.Platform$OS.type == "windows") {
[17:42:20.995]                 old_names <- names(...future.oldEnvVars)
[17:42:20.995]                 envs <- base::Sys.getenv()
[17:42:20.995]                 names <- names(envs)
[17:42:20.995]                 common <- intersect(names, old_names)
[17:42:20.995]                 added <- setdiff(names, old_names)
[17:42:20.995]                 removed <- setdiff(old_names, names)
[17:42:20.995]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:20.995]                   envs[common]]
[17:42:20.995]                 NAMES <- toupper(changed)
[17:42:20.995]                 args <- list()
[17:42:20.995]                 for (kk in seq_along(NAMES)) {
[17:42:20.995]                   name <- changed[[kk]]
[17:42:20.995]                   NAME <- NAMES[[kk]]
[17:42:20.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.995]                     next
[17:42:20.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.995]                 }
[17:42:20.995]                 NAMES <- toupper(added)
[17:42:20.995]                 for (kk in seq_along(NAMES)) {
[17:42:20.995]                   name <- added[[kk]]
[17:42:20.995]                   NAME <- NAMES[[kk]]
[17:42:20.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.995]                     next
[17:42:20.995]                   args[[name]] <- ""
[17:42:20.995]                 }
[17:42:20.995]                 NAMES <- toupper(removed)
[17:42:20.995]                 for (kk in seq_along(NAMES)) {
[17:42:20.995]                   name <- removed[[kk]]
[17:42:20.995]                   NAME <- NAMES[[kk]]
[17:42:20.995]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:20.995]                     next
[17:42:20.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:20.995]                 }
[17:42:20.995]                 if (length(args) > 0) 
[17:42:20.995]                   base::do.call(base::Sys.setenv, args = args)
[17:42:20.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:20.995]             }
[17:42:20.995]             else {
[17:42:20.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:20.995]             }
[17:42:20.995]             {
[17:42:20.995]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:20.995]                   0L) {
[17:42:20.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:20.995]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:20.995]                   base::options(opts)
[17:42:20.995]                 }
[17:42:20.995]                 {
[17:42:20.995]                   {
[17:42:20.995]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:20.995]                     NULL
[17:42:20.995]                   }
[17:42:20.995]                   options(future.plan = NULL)
[17:42:20.995]                   if (is.na(NA_character_)) 
[17:42:20.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:20.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:20.995]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:20.995]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:20.995]                     envir = parent.frame()) 
[17:42:20.995]                   {
[17:42:20.995]                     if (is.function(workers)) 
[17:42:20.995]                       workers <- workers()
[17:42:20.995]                     workers <- structure(as.integer(workers), 
[17:42:20.995]                       class = class(workers))
[17:42:20.995]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:20.995]                       workers >= 1)
[17:42:20.995]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:20.995]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:20.995]                     }
[17:42:20.995]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:20.995]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:20.995]                       envir = envir)
[17:42:20.995]                     if (!future$lazy) 
[17:42:20.995]                       future <- run(future)
[17:42:20.995]                     invisible(future)
[17:42:20.995]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:20.995]                 }
[17:42:20.995]             }
[17:42:20.995]         }
[17:42:20.995]     })
[17:42:20.995]     if (TRUE) {
[17:42:20.995]         base::sink(type = "output", split = FALSE)
[17:42:20.995]         if (TRUE) {
[17:42:20.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:20.995]         }
[17:42:20.995]         else {
[17:42:20.995]             ...future.result["stdout"] <- base::list(NULL)
[17:42:20.995]         }
[17:42:20.995]         base::close(...future.stdout)
[17:42:20.995]         ...future.stdout <- NULL
[17:42:20.995]     }
[17:42:20.995]     ...future.result$conditions <- ...future.conditions
[17:42:20.995]     ...future.result$finished <- base::Sys.time()
[17:42:20.995]     ...future.result
[17:42:20.995] }
[17:42:20.998] MultisessionFuture started
[17:42:20.999] - Launch lazy future ... done
[17:42:20.999] run() for ‘MultisessionFuture’ ... done
[17:42:20.999] getGlobalsAndPackages() ...
[17:42:20.999] Searching for globals...
[17:42:20.999] 
[17:42:20.999] Searching for globals ... DONE
[17:42:20.999] - globals: [0] <none>
[17:42:20.999] getGlobalsAndPackages() ... DONE
[17:42:21.000] run() for ‘Future’ ...
[17:42:21.000] - state: ‘created’
[17:42:21.000] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.014] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.014]   - Field: ‘node’
[17:42:21.014]   - Field: ‘label’
[17:42:21.014]   - Field: ‘local’
[17:42:21.015]   - Field: ‘owner’
[17:42:21.015]   - Field: ‘envir’
[17:42:21.015]   - Field: ‘workers’
[17:42:21.015]   - Field: ‘packages’
[17:42:21.015]   - Field: ‘gc’
[17:42:21.015]   - Field: ‘conditions’
[17:42:21.015]   - Field: ‘persistent’
[17:42:21.015]   - Field: ‘expr’
[17:42:21.015]   - Field: ‘uuid’
[17:42:21.015]   - Field: ‘seed’
[17:42:21.016]   - Field: ‘version’
[17:42:21.016]   - Field: ‘result’
[17:42:21.016]   - Field: ‘asynchronous’
[17:42:21.016]   - Field: ‘calls’
[17:42:21.016]   - Field: ‘globals’
[17:42:21.016]   - Field: ‘stdout’
[17:42:21.016]   - Field: ‘earlySignal’
[17:42:21.016]   - Field: ‘lazy’
[17:42:21.016]   - Field: ‘state’
[17:42:21.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.016] - Launch lazy future ...
[17:42:21.017] Packages needed by the future expression (n = 0): <none>
[17:42:21.017] Packages needed by future strategies (n = 0): <none>
[17:42:21.017] {
[17:42:21.017]     {
[17:42:21.017]         {
[17:42:21.017]             ...future.startTime <- base::Sys.time()
[17:42:21.017]             {
[17:42:21.017]                 {
[17:42:21.017]                   {
[17:42:21.017]                     {
[17:42:21.017]                       base::local({
[17:42:21.017]                         has_future <- base::requireNamespace("future", 
[17:42:21.017]                           quietly = TRUE)
[17:42:21.017]                         if (has_future) {
[17:42:21.017]                           ns <- base::getNamespace("future")
[17:42:21.017]                           version <- ns[[".package"]][["version"]]
[17:42:21.017]                           if (is.null(version)) 
[17:42:21.017]                             version <- utils::packageVersion("future")
[17:42:21.017]                         }
[17:42:21.017]                         else {
[17:42:21.017]                           version <- NULL
[17:42:21.017]                         }
[17:42:21.017]                         if (!has_future || version < "1.8.0") {
[17:42:21.017]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.017]                             "", base::R.version$version.string), 
[17:42:21.017]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.017]                               "release", "version")], collapse = " "), 
[17:42:21.017]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.017]                             info)
[17:42:21.017]                           info <- base::paste(info, collapse = "; ")
[17:42:21.017]                           if (!has_future) {
[17:42:21.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.017]                               info)
[17:42:21.017]                           }
[17:42:21.017]                           else {
[17:42:21.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.017]                               info, version)
[17:42:21.017]                           }
[17:42:21.017]                           base::stop(msg)
[17:42:21.017]                         }
[17:42:21.017]                       })
[17:42:21.017]                     }
[17:42:21.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.017]                     base::options(mc.cores = 1L)
[17:42:21.017]                   }
[17:42:21.017]                   options(future.plan = NULL)
[17:42:21.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.017]                 }
[17:42:21.017]                 ...future.workdir <- getwd()
[17:42:21.017]             }
[17:42:21.017]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.017]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.017]         }
[17:42:21.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.017]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.017]             base::names(...future.oldOptions))
[17:42:21.017]     }
[17:42:21.017]     if (FALSE) {
[17:42:21.017]     }
[17:42:21.017]     else {
[17:42:21.017]         if (TRUE) {
[17:42:21.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.017]                 open = "w")
[17:42:21.017]         }
[17:42:21.017]         else {
[17:42:21.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.017]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.017]         }
[17:42:21.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.017]             base::sink(type = "output", split = FALSE)
[17:42:21.017]             base::close(...future.stdout)
[17:42:21.017]         }, add = TRUE)
[17:42:21.017]     }
[17:42:21.017]     ...future.frame <- base::sys.nframe()
[17:42:21.017]     ...future.conditions <- base::list()
[17:42:21.017]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.017]     if (FALSE) {
[17:42:21.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.017]     }
[17:42:21.017]     ...future.result <- base::tryCatch({
[17:42:21.017]         base::withCallingHandlers({
[17:42:21.017]             ...future.value <- base::withVisible(base::local({
[17:42:21.017]                 ...future.makeSendCondition <- local({
[17:42:21.017]                   sendCondition <- NULL
[17:42:21.017]                   function(frame = 1L) {
[17:42:21.017]                     if (is.function(sendCondition)) 
[17:42:21.017]                       return(sendCondition)
[17:42:21.017]                     ns <- getNamespace("parallel")
[17:42:21.017]                     if (exists("sendData", mode = "function", 
[17:42:21.017]                       envir = ns)) {
[17:42:21.017]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.017]                         envir = ns)
[17:42:21.017]                       envir <- sys.frame(frame)
[17:42:21.017]                       master <- NULL
[17:42:21.017]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.017]                         !identical(envir, emptyenv())) {
[17:42:21.017]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.017]                           inherits = FALSE)) {
[17:42:21.017]                           master <- get("master", mode = "list", 
[17:42:21.017]                             envir = envir, inherits = FALSE)
[17:42:21.017]                           if (inherits(master, c("SOCKnode", 
[17:42:21.017]                             "SOCK0node"))) {
[17:42:21.017]                             sendCondition <<- function(cond) {
[17:42:21.017]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.017]                                 success = TRUE)
[17:42:21.017]                               parallel_sendData(master, data)
[17:42:21.017]                             }
[17:42:21.017]                             return(sendCondition)
[17:42:21.017]                           }
[17:42:21.017]                         }
[17:42:21.017]                         frame <- frame + 1L
[17:42:21.017]                         envir <- sys.frame(frame)
[17:42:21.017]                       }
[17:42:21.017]                     }
[17:42:21.017]                     sendCondition <<- function(cond) NULL
[17:42:21.017]                   }
[17:42:21.017]                 })
[17:42:21.017]                 withCallingHandlers({
[17:42:21.017]                   NULL
[17:42:21.017]                 }, immediateCondition = function(cond) {
[17:42:21.017]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.017]                   sendCondition(cond)
[17:42:21.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.017]                   {
[17:42:21.017]                     inherits <- base::inherits
[17:42:21.017]                     invokeRestart <- base::invokeRestart
[17:42:21.017]                     is.null <- base::is.null
[17:42:21.017]                     muffled <- FALSE
[17:42:21.017]                     if (inherits(cond, "message")) {
[17:42:21.017]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.017]                       if (muffled) 
[17:42:21.017]                         invokeRestart("muffleMessage")
[17:42:21.017]                     }
[17:42:21.017]                     else if (inherits(cond, "warning")) {
[17:42:21.017]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.017]                       if (muffled) 
[17:42:21.017]                         invokeRestart("muffleWarning")
[17:42:21.017]                     }
[17:42:21.017]                     else if (inherits(cond, "condition")) {
[17:42:21.017]                       if (!is.null(pattern)) {
[17:42:21.017]                         computeRestarts <- base::computeRestarts
[17:42:21.017]                         grepl <- base::grepl
[17:42:21.017]                         restarts <- computeRestarts(cond)
[17:42:21.017]                         for (restart in restarts) {
[17:42:21.017]                           name <- restart$name
[17:42:21.017]                           if (is.null(name)) 
[17:42:21.017]                             next
[17:42:21.017]                           if (!grepl(pattern, name)) 
[17:42:21.017]                             next
[17:42:21.017]                           invokeRestart(restart)
[17:42:21.017]                           muffled <- TRUE
[17:42:21.017]                           break
[17:42:21.017]                         }
[17:42:21.017]                       }
[17:42:21.017]                     }
[17:42:21.017]                     invisible(muffled)
[17:42:21.017]                   }
[17:42:21.017]                   muffleCondition(cond)
[17:42:21.017]                 })
[17:42:21.017]             }))
[17:42:21.017]             future::FutureResult(value = ...future.value$value, 
[17:42:21.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.017]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.017]                     ...future.globalenv.names))
[17:42:21.017]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.017]         }, condition = base::local({
[17:42:21.017]             c <- base::c
[17:42:21.017]             inherits <- base::inherits
[17:42:21.017]             invokeRestart <- base::invokeRestart
[17:42:21.017]             length <- base::length
[17:42:21.017]             list <- base::list
[17:42:21.017]             seq.int <- base::seq.int
[17:42:21.017]             signalCondition <- base::signalCondition
[17:42:21.017]             sys.calls <- base::sys.calls
[17:42:21.017]             `[[` <- base::`[[`
[17:42:21.017]             `+` <- base::`+`
[17:42:21.017]             `<<-` <- base::`<<-`
[17:42:21.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.017]                   3L)]
[17:42:21.017]             }
[17:42:21.017]             function(cond) {
[17:42:21.017]                 is_error <- inherits(cond, "error")
[17:42:21.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.017]                   NULL)
[17:42:21.017]                 if (is_error) {
[17:42:21.017]                   sessionInformation <- function() {
[17:42:21.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.017]                       search = base::search(), system = base::Sys.info())
[17:42:21.017]                   }
[17:42:21.017]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.017]                     cond$call), session = sessionInformation(), 
[17:42:21.017]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.017]                   signalCondition(cond)
[17:42:21.017]                 }
[17:42:21.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.017]                 "immediateCondition"))) {
[17:42:21.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.017]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.017]                   if (TRUE && !signal) {
[17:42:21.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.017]                     {
[17:42:21.017]                       inherits <- base::inherits
[17:42:21.017]                       invokeRestart <- base::invokeRestart
[17:42:21.017]                       is.null <- base::is.null
[17:42:21.017]                       muffled <- FALSE
[17:42:21.017]                       if (inherits(cond, "message")) {
[17:42:21.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.017]                         if (muffled) 
[17:42:21.017]                           invokeRestart("muffleMessage")
[17:42:21.017]                       }
[17:42:21.017]                       else if (inherits(cond, "warning")) {
[17:42:21.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.017]                         if (muffled) 
[17:42:21.017]                           invokeRestart("muffleWarning")
[17:42:21.017]                       }
[17:42:21.017]                       else if (inherits(cond, "condition")) {
[17:42:21.017]                         if (!is.null(pattern)) {
[17:42:21.017]                           computeRestarts <- base::computeRestarts
[17:42:21.017]                           grepl <- base::grepl
[17:42:21.017]                           restarts <- computeRestarts(cond)
[17:42:21.017]                           for (restart in restarts) {
[17:42:21.017]                             name <- restart$name
[17:42:21.017]                             if (is.null(name)) 
[17:42:21.017]                               next
[17:42:21.017]                             if (!grepl(pattern, name)) 
[17:42:21.017]                               next
[17:42:21.017]                             invokeRestart(restart)
[17:42:21.017]                             muffled <- TRUE
[17:42:21.017]                             break
[17:42:21.017]                           }
[17:42:21.017]                         }
[17:42:21.017]                       }
[17:42:21.017]                       invisible(muffled)
[17:42:21.017]                     }
[17:42:21.017]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.017]                   }
[17:42:21.017]                 }
[17:42:21.017]                 else {
[17:42:21.017]                   if (TRUE) {
[17:42:21.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.017]                     {
[17:42:21.017]                       inherits <- base::inherits
[17:42:21.017]                       invokeRestart <- base::invokeRestart
[17:42:21.017]                       is.null <- base::is.null
[17:42:21.017]                       muffled <- FALSE
[17:42:21.017]                       if (inherits(cond, "message")) {
[17:42:21.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.017]                         if (muffled) 
[17:42:21.017]                           invokeRestart("muffleMessage")
[17:42:21.017]                       }
[17:42:21.017]                       else if (inherits(cond, "warning")) {
[17:42:21.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.017]                         if (muffled) 
[17:42:21.017]                           invokeRestart("muffleWarning")
[17:42:21.017]                       }
[17:42:21.017]                       else if (inherits(cond, "condition")) {
[17:42:21.017]                         if (!is.null(pattern)) {
[17:42:21.017]                           computeRestarts <- base::computeRestarts
[17:42:21.017]                           grepl <- base::grepl
[17:42:21.017]                           restarts <- computeRestarts(cond)
[17:42:21.017]                           for (restart in restarts) {
[17:42:21.017]                             name <- restart$name
[17:42:21.017]                             if (is.null(name)) 
[17:42:21.017]                               next
[17:42:21.017]                             if (!grepl(pattern, name)) 
[17:42:21.017]                               next
[17:42:21.017]                             invokeRestart(restart)
[17:42:21.017]                             muffled <- TRUE
[17:42:21.017]                             break
[17:42:21.017]                           }
[17:42:21.017]                         }
[17:42:21.017]                       }
[17:42:21.017]                       invisible(muffled)
[17:42:21.017]                     }
[17:42:21.017]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.017]                   }
[17:42:21.017]                 }
[17:42:21.017]             }
[17:42:21.017]         }))
[17:42:21.017]     }, error = function(ex) {
[17:42:21.017]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.017]                 ...future.rng), started = ...future.startTime, 
[17:42:21.017]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.017]             version = "1.8"), class = "FutureResult")
[17:42:21.017]     }, finally = {
[17:42:21.017]         if (!identical(...future.workdir, getwd())) 
[17:42:21.017]             setwd(...future.workdir)
[17:42:21.017]         {
[17:42:21.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.017]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.017]             }
[17:42:21.017]             base::options(...future.oldOptions)
[17:42:21.017]             if (.Platform$OS.type == "windows") {
[17:42:21.017]                 old_names <- names(...future.oldEnvVars)
[17:42:21.017]                 envs <- base::Sys.getenv()
[17:42:21.017]                 names <- names(envs)
[17:42:21.017]                 common <- intersect(names, old_names)
[17:42:21.017]                 added <- setdiff(names, old_names)
[17:42:21.017]                 removed <- setdiff(old_names, names)
[17:42:21.017]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.017]                   envs[common]]
[17:42:21.017]                 NAMES <- toupper(changed)
[17:42:21.017]                 args <- list()
[17:42:21.017]                 for (kk in seq_along(NAMES)) {
[17:42:21.017]                   name <- changed[[kk]]
[17:42:21.017]                   NAME <- NAMES[[kk]]
[17:42:21.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.017]                     next
[17:42:21.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.017]                 }
[17:42:21.017]                 NAMES <- toupper(added)
[17:42:21.017]                 for (kk in seq_along(NAMES)) {
[17:42:21.017]                   name <- added[[kk]]
[17:42:21.017]                   NAME <- NAMES[[kk]]
[17:42:21.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.017]                     next
[17:42:21.017]                   args[[name]] <- ""
[17:42:21.017]                 }
[17:42:21.017]                 NAMES <- toupper(removed)
[17:42:21.017]                 for (kk in seq_along(NAMES)) {
[17:42:21.017]                   name <- removed[[kk]]
[17:42:21.017]                   NAME <- NAMES[[kk]]
[17:42:21.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.017]                     next
[17:42:21.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.017]                 }
[17:42:21.017]                 if (length(args) > 0) 
[17:42:21.017]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.017]             }
[17:42:21.017]             else {
[17:42:21.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.017]             }
[17:42:21.017]             {
[17:42:21.017]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.017]                   0L) {
[17:42:21.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.017]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.017]                   base::options(opts)
[17:42:21.017]                 }
[17:42:21.017]                 {
[17:42:21.017]                   {
[17:42:21.017]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.017]                     NULL
[17:42:21.017]                   }
[17:42:21.017]                   options(future.plan = NULL)
[17:42:21.017]                   if (is.na(NA_character_)) 
[17:42:21.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.017]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.017]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.017]                     envir = parent.frame()) 
[17:42:21.017]                   {
[17:42:21.017]                     if (is.function(workers)) 
[17:42:21.017]                       workers <- workers()
[17:42:21.017]                     workers <- structure(as.integer(workers), 
[17:42:21.017]                       class = class(workers))
[17:42:21.017]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.017]                       workers >= 1)
[17:42:21.017]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.017]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.017]                     }
[17:42:21.017]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.017]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.017]                       envir = envir)
[17:42:21.017]                     if (!future$lazy) 
[17:42:21.017]                       future <- run(future)
[17:42:21.017]                     invisible(future)
[17:42:21.017]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.017]                 }
[17:42:21.017]             }
[17:42:21.017]         }
[17:42:21.017]     })
[17:42:21.017]     if (TRUE) {
[17:42:21.017]         base::sink(type = "output", split = FALSE)
[17:42:21.017]         if (TRUE) {
[17:42:21.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.017]         }
[17:42:21.017]         else {
[17:42:21.017]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.017]         }
[17:42:21.017]         base::close(...future.stdout)
[17:42:21.017]         ...future.stdout <- NULL
[17:42:21.017]     }
[17:42:21.017]     ...future.result$conditions <- ...future.conditions
[17:42:21.017]     ...future.result$finished <- base::Sys.time()
[17:42:21.017]     ...future.result
[17:42:21.017] }
[17:42:21.020] MultisessionFuture started
[17:42:21.020] - Launch lazy future ... done
[17:42:21.021] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef8466860> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7ecf548> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef8466860> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef7ecf548> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:21.048] resolve() on list ...
[17:42:21.049]  recursive: 0
[17:42:21.049]  length: 6
[17:42:21.049]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:21.049] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.049] - nx: 6
[17:42:21.049] - relay: TRUE
[17:42:21.049] - stdout: TRUE
[17:42:21.049] - signal: TRUE
[17:42:21.049] - resignal: FALSE
[17:42:21.049] - force: TRUE
[17:42:21.049] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.050] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.050]  - until=2
[17:42:21.050]  - relaying element #2
[17:42:21.050] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.050] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.050] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.050]  length: 5 (resolved future 1)
[17:42:21.051] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.051] - Validating connection of MultisessionFuture
[17:42:21.051] - received message: FutureResult
[17:42:21.051] - Received FutureResult
[17:42:21.051] - Erased future from FutureRegistry
[17:42:21.051] result() for ClusterFuture ...
[17:42:21.051] - result already collected: FutureResult
[17:42:21.051] result() for ClusterFuture ... done
[17:42:21.052] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.052] Future #2
[17:42:21.052] result() for ClusterFuture ...
[17:42:21.052] - result already collected: FutureResult
[17:42:21.052] result() for ClusterFuture ... done
[17:42:21.052] result() for ClusterFuture ...
[17:42:21.052] - result already collected: FutureResult
[17:42:21.052] result() for ClusterFuture ... done
[17:42:21.052] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:21.052] - nx: 6
[17:42:21.052] - relay: TRUE
[17:42:21.053] - stdout: TRUE
[17:42:21.053] - signal: TRUE
[17:42:21.053] - resignal: FALSE
[17:42:21.053] - force: TRUE
[17:42:21.053] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.053] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.053]  - until=2
[17:42:21.053]  - relaying element #2
[17:42:21.053] result() for ClusterFuture ...
[17:42:21.053] - result already collected: FutureResult
[17:42:21.053] result() for ClusterFuture ... done
[17:42:21.054] result() for ClusterFuture ...
[17:42:21.054] - result already collected: FutureResult
[17:42:21.054] result() for ClusterFuture ... done
[17:42:21.054] result() for ClusterFuture ...
[17:42:21.054] - result already collected: FutureResult
[17:42:21.054] result() for ClusterFuture ... done
[17:42:21.054] result() for ClusterFuture ...
[17:42:21.054] - result already collected: FutureResult
[17:42:21.054] result() for ClusterFuture ... done
[17:42:21.054] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.054] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.055] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:21.055]  length: 4 (resolved future 2)
[17:42:21.065] signalConditionsASAP(NULL, pos=4) ...
[17:42:21.065] - nx: 6
[17:42:21.065] - relay: TRUE
[17:42:21.066] - stdout: TRUE
[17:42:21.066] - signal: TRUE
[17:42:21.066] - resignal: FALSE
[17:42:21.066] - force: TRUE
[17:42:21.066] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.066] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.066]  - until=5
[17:42:21.066]  - relaying element #3
[17:42:21.066]  - relaying element #5
[17:42:21.066] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.066] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.067] signalConditionsASAP(NULL, pos=4) ... done
[17:42:21.067]  length: 3 (resolved future 4)
[17:42:21.067] signalConditionsASAP(NULL, pos=5) ...
[17:42:21.067] - nx: 6
[17:42:21.067] - relay: TRUE
[17:42:21.067] - stdout: TRUE
[17:42:21.068] - signal: TRUE
[17:42:21.068] - resignal: FALSE
[17:42:21.068] - force: TRUE
[17:42:21.068] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.068] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.068]  - until=6
[17:42:21.068]  - relaying element #3
[17:42:21.069]  - relaying element #6
[17:42:21.069] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.069] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.069] signalConditionsASAP(NULL, pos=5) ... done
[17:42:21.069]  length: 2 (resolved future 5)
[17:42:21.069] signalConditionsASAP(numeric, pos=6) ...
[17:42:21.069] - nx: 6
[17:42:21.069] - relay: TRUE
[17:42:21.069] - stdout: TRUE
[17:42:21.069] - signal: TRUE
[17:42:21.069] - resignal: FALSE
[17:42:21.069] - force: TRUE
[17:42:21.070] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.070] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.070]  - until=6
[17:42:21.070]  - relaying element #3
[17:42:21.070] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.070] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.070] signalConditionsASAP(NULL, pos=6) ... done
[17:42:21.070]  length: 1 (resolved future 6)
[17:42:21.081] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.081] - Validating connection of MultisessionFuture
[17:42:21.081] - received message: FutureResult
[17:42:21.082] - Received FutureResult
[17:42:21.082] - Erased future from FutureRegistry
[17:42:21.082] result() for ClusterFuture ...
[17:42:21.082] - result already collected: FutureResult
[17:42:21.082] result() for ClusterFuture ... done
[17:42:21.082] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.082] Future #3
[17:42:21.082] result() for ClusterFuture ...
[17:42:21.082] - result already collected: FutureResult
[17:42:21.083] result() for ClusterFuture ... done
[17:42:21.083] result() for ClusterFuture ...
[17:42:21.083] - result already collected: FutureResult
[17:42:21.083] result() for ClusterFuture ... done
[17:42:21.083] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:21.083] - nx: 6
[17:42:21.083] - relay: TRUE
[17:42:21.083] - stdout: TRUE
[17:42:21.083] - signal: TRUE
[17:42:21.083] - resignal: FALSE
[17:42:21.083] - force: TRUE
[17:42:21.084] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.084] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.084]  - until=6
[17:42:21.084]  - relaying element #3
[17:42:21.084] result() for ClusterFuture ...
[17:42:21.084] - result already collected: FutureResult
[17:42:21.084] result() for ClusterFuture ... done
[17:42:21.084] result() for ClusterFuture ...
[17:42:21.084] - result already collected: FutureResult
[17:42:21.084] result() for ClusterFuture ... done
[17:42:21.085] result() for ClusterFuture ...
[17:42:21.085] - result already collected: FutureResult
[17:42:21.085] result() for ClusterFuture ... done
[17:42:21.085] result() for ClusterFuture ...
[17:42:21.085] - result already collected: FutureResult
[17:42:21.085] result() for ClusterFuture ... done
[17:42:21.085] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.085] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.085] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:21.085]  length: 0 (resolved future 3)
[17:42:21.085] Relaying remaining futures
[17:42:21.086] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.086] - nx: 6
[17:42:21.086] - relay: TRUE
[17:42:21.086] - stdout: TRUE
[17:42:21.086] - signal: TRUE
[17:42:21.086] - resignal: FALSE
[17:42:21.086] - force: TRUE
[17:42:21.086] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.086] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:21.086] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.086] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.087] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.087] resolve() on list ... DONE
[17:42:21.087] result() for ClusterFuture ...
[17:42:21.087] - result already collected: FutureResult
[17:42:21.087] result() for ClusterFuture ... done
[17:42:21.087] result() for ClusterFuture ...
[17:42:21.087] - result already collected: FutureResult
[17:42:21.087] result() for ClusterFuture ... done
[17:42:21.087] result() for ClusterFuture ...
[17:42:21.087] - result already collected: FutureResult
[17:42:21.088] result() for ClusterFuture ... done
[17:42:21.088] result() for ClusterFuture ...
[17:42:21.088] - result already collected: FutureResult
[17:42:21.088] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:42:21.091] getGlobalsAndPackages() ...
[17:42:21.091] Searching for globals...
[17:42:21.091] 
[17:42:21.092] Searching for globals ... DONE
[17:42:21.092] - globals: [0] <none>
[17:42:21.092] getGlobalsAndPackages() ... DONE
[17:42:21.092] run() for ‘Future’ ...
[17:42:21.092] - state: ‘created’
[17:42:21.092] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.107]   - Field: ‘node’
[17:42:21.107]   - Field: ‘label’
[17:42:21.107]   - Field: ‘local’
[17:42:21.107]   - Field: ‘owner’
[17:42:21.108]   - Field: ‘envir’
[17:42:21.108]   - Field: ‘workers’
[17:42:21.108]   - Field: ‘packages’
[17:42:21.108]   - Field: ‘gc’
[17:42:21.108]   - Field: ‘conditions’
[17:42:21.108]   - Field: ‘persistent’
[17:42:21.108]   - Field: ‘expr’
[17:42:21.108]   - Field: ‘uuid’
[17:42:21.108]   - Field: ‘seed’
[17:42:21.108]   - Field: ‘version’
[17:42:21.108]   - Field: ‘result’
[17:42:21.109]   - Field: ‘asynchronous’
[17:42:21.109]   - Field: ‘calls’
[17:42:21.109]   - Field: ‘globals’
[17:42:21.109]   - Field: ‘stdout’
[17:42:21.109]   - Field: ‘earlySignal’
[17:42:21.109]   - Field: ‘lazy’
[17:42:21.109]   - Field: ‘state’
[17:42:21.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.109] - Launch lazy future ...
[17:42:21.110] Packages needed by the future expression (n = 0): <none>
[17:42:21.110] Packages needed by future strategies (n = 0): <none>
[17:42:21.110] {
[17:42:21.110]     {
[17:42:21.110]         {
[17:42:21.110]             ...future.startTime <- base::Sys.time()
[17:42:21.110]             {
[17:42:21.110]                 {
[17:42:21.110]                   {
[17:42:21.110]                     {
[17:42:21.110]                       base::local({
[17:42:21.110]                         has_future <- base::requireNamespace("future", 
[17:42:21.110]                           quietly = TRUE)
[17:42:21.110]                         if (has_future) {
[17:42:21.110]                           ns <- base::getNamespace("future")
[17:42:21.110]                           version <- ns[[".package"]][["version"]]
[17:42:21.110]                           if (is.null(version)) 
[17:42:21.110]                             version <- utils::packageVersion("future")
[17:42:21.110]                         }
[17:42:21.110]                         else {
[17:42:21.110]                           version <- NULL
[17:42:21.110]                         }
[17:42:21.110]                         if (!has_future || version < "1.8.0") {
[17:42:21.110]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.110]                             "", base::R.version$version.string), 
[17:42:21.110]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.110]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.110]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.110]                               "release", "version")], collapse = " "), 
[17:42:21.110]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.110]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.110]                             info)
[17:42:21.110]                           info <- base::paste(info, collapse = "; ")
[17:42:21.110]                           if (!has_future) {
[17:42:21.110]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.110]                               info)
[17:42:21.110]                           }
[17:42:21.110]                           else {
[17:42:21.110]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.110]                               info, version)
[17:42:21.110]                           }
[17:42:21.110]                           base::stop(msg)
[17:42:21.110]                         }
[17:42:21.110]                       })
[17:42:21.110]                     }
[17:42:21.110]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.110]                     base::options(mc.cores = 1L)
[17:42:21.110]                   }
[17:42:21.110]                   options(future.plan = NULL)
[17:42:21.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.110]                 }
[17:42:21.110]                 ...future.workdir <- getwd()
[17:42:21.110]             }
[17:42:21.110]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.110]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.110]         }
[17:42:21.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.110]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.110]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.110]             base::names(...future.oldOptions))
[17:42:21.110]     }
[17:42:21.110]     if (FALSE) {
[17:42:21.110]     }
[17:42:21.110]     else {
[17:42:21.110]         if (TRUE) {
[17:42:21.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.110]                 open = "w")
[17:42:21.110]         }
[17:42:21.110]         else {
[17:42:21.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.110]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.110]         }
[17:42:21.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.110]             base::sink(type = "output", split = FALSE)
[17:42:21.110]             base::close(...future.stdout)
[17:42:21.110]         }, add = TRUE)
[17:42:21.110]     }
[17:42:21.110]     ...future.frame <- base::sys.nframe()
[17:42:21.110]     ...future.conditions <- base::list()
[17:42:21.110]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.110]     if (FALSE) {
[17:42:21.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.110]     }
[17:42:21.110]     ...future.result <- base::tryCatch({
[17:42:21.110]         base::withCallingHandlers({
[17:42:21.110]             ...future.value <- base::withVisible(base::local({
[17:42:21.110]                 ...future.makeSendCondition <- local({
[17:42:21.110]                   sendCondition <- NULL
[17:42:21.110]                   function(frame = 1L) {
[17:42:21.110]                     if (is.function(sendCondition)) 
[17:42:21.110]                       return(sendCondition)
[17:42:21.110]                     ns <- getNamespace("parallel")
[17:42:21.110]                     if (exists("sendData", mode = "function", 
[17:42:21.110]                       envir = ns)) {
[17:42:21.110]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.110]                         envir = ns)
[17:42:21.110]                       envir <- sys.frame(frame)
[17:42:21.110]                       master <- NULL
[17:42:21.110]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.110]                         !identical(envir, emptyenv())) {
[17:42:21.110]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.110]                           inherits = FALSE)) {
[17:42:21.110]                           master <- get("master", mode = "list", 
[17:42:21.110]                             envir = envir, inherits = FALSE)
[17:42:21.110]                           if (inherits(master, c("SOCKnode", 
[17:42:21.110]                             "SOCK0node"))) {
[17:42:21.110]                             sendCondition <<- function(cond) {
[17:42:21.110]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.110]                                 success = TRUE)
[17:42:21.110]                               parallel_sendData(master, data)
[17:42:21.110]                             }
[17:42:21.110]                             return(sendCondition)
[17:42:21.110]                           }
[17:42:21.110]                         }
[17:42:21.110]                         frame <- frame + 1L
[17:42:21.110]                         envir <- sys.frame(frame)
[17:42:21.110]                       }
[17:42:21.110]                     }
[17:42:21.110]                     sendCondition <<- function(cond) NULL
[17:42:21.110]                   }
[17:42:21.110]                 })
[17:42:21.110]                 withCallingHandlers({
[17:42:21.110]                   2
[17:42:21.110]                 }, immediateCondition = function(cond) {
[17:42:21.110]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.110]                   sendCondition(cond)
[17:42:21.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.110]                   {
[17:42:21.110]                     inherits <- base::inherits
[17:42:21.110]                     invokeRestart <- base::invokeRestart
[17:42:21.110]                     is.null <- base::is.null
[17:42:21.110]                     muffled <- FALSE
[17:42:21.110]                     if (inherits(cond, "message")) {
[17:42:21.110]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.110]                       if (muffled) 
[17:42:21.110]                         invokeRestart("muffleMessage")
[17:42:21.110]                     }
[17:42:21.110]                     else if (inherits(cond, "warning")) {
[17:42:21.110]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.110]                       if (muffled) 
[17:42:21.110]                         invokeRestart("muffleWarning")
[17:42:21.110]                     }
[17:42:21.110]                     else if (inherits(cond, "condition")) {
[17:42:21.110]                       if (!is.null(pattern)) {
[17:42:21.110]                         computeRestarts <- base::computeRestarts
[17:42:21.110]                         grepl <- base::grepl
[17:42:21.110]                         restarts <- computeRestarts(cond)
[17:42:21.110]                         for (restart in restarts) {
[17:42:21.110]                           name <- restart$name
[17:42:21.110]                           if (is.null(name)) 
[17:42:21.110]                             next
[17:42:21.110]                           if (!grepl(pattern, name)) 
[17:42:21.110]                             next
[17:42:21.110]                           invokeRestart(restart)
[17:42:21.110]                           muffled <- TRUE
[17:42:21.110]                           break
[17:42:21.110]                         }
[17:42:21.110]                       }
[17:42:21.110]                     }
[17:42:21.110]                     invisible(muffled)
[17:42:21.110]                   }
[17:42:21.110]                   muffleCondition(cond)
[17:42:21.110]                 })
[17:42:21.110]             }))
[17:42:21.110]             future::FutureResult(value = ...future.value$value, 
[17:42:21.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.110]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.110]                     ...future.globalenv.names))
[17:42:21.110]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.110]         }, condition = base::local({
[17:42:21.110]             c <- base::c
[17:42:21.110]             inherits <- base::inherits
[17:42:21.110]             invokeRestart <- base::invokeRestart
[17:42:21.110]             length <- base::length
[17:42:21.110]             list <- base::list
[17:42:21.110]             seq.int <- base::seq.int
[17:42:21.110]             signalCondition <- base::signalCondition
[17:42:21.110]             sys.calls <- base::sys.calls
[17:42:21.110]             `[[` <- base::`[[`
[17:42:21.110]             `+` <- base::`+`
[17:42:21.110]             `<<-` <- base::`<<-`
[17:42:21.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.110]                   3L)]
[17:42:21.110]             }
[17:42:21.110]             function(cond) {
[17:42:21.110]                 is_error <- inherits(cond, "error")
[17:42:21.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.110]                   NULL)
[17:42:21.110]                 if (is_error) {
[17:42:21.110]                   sessionInformation <- function() {
[17:42:21.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.110]                       search = base::search(), system = base::Sys.info())
[17:42:21.110]                   }
[17:42:21.110]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.110]                     cond$call), session = sessionInformation(), 
[17:42:21.110]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.110]                   signalCondition(cond)
[17:42:21.110]                 }
[17:42:21.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.110]                 "immediateCondition"))) {
[17:42:21.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.110]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.110]                   if (TRUE && !signal) {
[17:42:21.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.110]                     {
[17:42:21.110]                       inherits <- base::inherits
[17:42:21.110]                       invokeRestart <- base::invokeRestart
[17:42:21.110]                       is.null <- base::is.null
[17:42:21.110]                       muffled <- FALSE
[17:42:21.110]                       if (inherits(cond, "message")) {
[17:42:21.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.110]                         if (muffled) 
[17:42:21.110]                           invokeRestart("muffleMessage")
[17:42:21.110]                       }
[17:42:21.110]                       else if (inherits(cond, "warning")) {
[17:42:21.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.110]                         if (muffled) 
[17:42:21.110]                           invokeRestart("muffleWarning")
[17:42:21.110]                       }
[17:42:21.110]                       else if (inherits(cond, "condition")) {
[17:42:21.110]                         if (!is.null(pattern)) {
[17:42:21.110]                           computeRestarts <- base::computeRestarts
[17:42:21.110]                           grepl <- base::grepl
[17:42:21.110]                           restarts <- computeRestarts(cond)
[17:42:21.110]                           for (restart in restarts) {
[17:42:21.110]                             name <- restart$name
[17:42:21.110]                             if (is.null(name)) 
[17:42:21.110]                               next
[17:42:21.110]                             if (!grepl(pattern, name)) 
[17:42:21.110]                               next
[17:42:21.110]                             invokeRestart(restart)
[17:42:21.110]                             muffled <- TRUE
[17:42:21.110]                             break
[17:42:21.110]                           }
[17:42:21.110]                         }
[17:42:21.110]                       }
[17:42:21.110]                       invisible(muffled)
[17:42:21.110]                     }
[17:42:21.110]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.110]                   }
[17:42:21.110]                 }
[17:42:21.110]                 else {
[17:42:21.110]                   if (TRUE) {
[17:42:21.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.110]                     {
[17:42:21.110]                       inherits <- base::inherits
[17:42:21.110]                       invokeRestart <- base::invokeRestart
[17:42:21.110]                       is.null <- base::is.null
[17:42:21.110]                       muffled <- FALSE
[17:42:21.110]                       if (inherits(cond, "message")) {
[17:42:21.110]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.110]                         if (muffled) 
[17:42:21.110]                           invokeRestart("muffleMessage")
[17:42:21.110]                       }
[17:42:21.110]                       else if (inherits(cond, "warning")) {
[17:42:21.110]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.110]                         if (muffled) 
[17:42:21.110]                           invokeRestart("muffleWarning")
[17:42:21.110]                       }
[17:42:21.110]                       else if (inherits(cond, "condition")) {
[17:42:21.110]                         if (!is.null(pattern)) {
[17:42:21.110]                           computeRestarts <- base::computeRestarts
[17:42:21.110]                           grepl <- base::grepl
[17:42:21.110]                           restarts <- computeRestarts(cond)
[17:42:21.110]                           for (restart in restarts) {
[17:42:21.110]                             name <- restart$name
[17:42:21.110]                             if (is.null(name)) 
[17:42:21.110]                               next
[17:42:21.110]                             if (!grepl(pattern, name)) 
[17:42:21.110]                               next
[17:42:21.110]                             invokeRestart(restart)
[17:42:21.110]                             muffled <- TRUE
[17:42:21.110]                             break
[17:42:21.110]                           }
[17:42:21.110]                         }
[17:42:21.110]                       }
[17:42:21.110]                       invisible(muffled)
[17:42:21.110]                     }
[17:42:21.110]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.110]                   }
[17:42:21.110]                 }
[17:42:21.110]             }
[17:42:21.110]         }))
[17:42:21.110]     }, error = function(ex) {
[17:42:21.110]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.110]                 ...future.rng), started = ...future.startTime, 
[17:42:21.110]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.110]             version = "1.8"), class = "FutureResult")
[17:42:21.110]     }, finally = {
[17:42:21.110]         if (!identical(...future.workdir, getwd())) 
[17:42:21.110]             setwd(...future.workdir)
[17:42:21.110]         {
[17:42:21.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.110]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.110]             }
[17:42:21.110]             base::options(...future.oldOptions)
[17:42:21.110]             if (.Platform$OS.type == "windows") {
[17:42:21.110]                 old_names <- names(...future.oldEnvVars)
[17:42:21.110]                 envs <- base::Sys.getenv()
[17:42:21.110]                 names <- names(envs)
[17:42:21.110]                 common <- intersect(names, old_names)
[17:42:21.110]                 added <- setdiff(names, old_names)
[17:42:21.110]                 removed <- setdiff(old_names, names)
[17:42:21.110]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.110]                   envs[common]]
[17:42:21.110]                 NAMES <- toupper(changed)
[17:42:21.110]                 args <- list()
[17:42:21.110]                 for (kk in seq_along(NAMES)) {
[17:42:21.110]                   name <- changed[[kk]]
[17:42:21.110]                   NAME <- NAMES[[kk]]
[17:42:21.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.110]                     next
[17:42:21.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.110]                 }
[17:42:21.110]                 NAMES <- toupper(added)
[17:42:21.110]                 for (kk in seq_along(NAMES)) {
[17:42:21.110]                   name <- added[[kk]]
[17:42:21.110]                   NAME <- NAMES[[kk]]
[17:42:21.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.110]                     next
[17:42:21.110]                   args[[name]] <- ""
[17:42:21.110]                 }
[17:42:21.110]                 NAMES <- toupper(removed)
[17:42:21.110]                 for (kk in seq_along(NAMES)) {
[17:42:21.110]                   name <- removed[[kk]]
[17:42:21.110]                   NAME <- NAMES[[kk]]
[17:42:21.110]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.110]                     next
[17:42:21.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.110]                 }
[17:42:21.110]                 if (length(args) > 0) 
[17:42:21.110]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.110]             }
[17:42:21.110]             else {
[17:42:21.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.110]             }
[17:42:21.110]             {
[17:42:21.110]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.110]                   0L) {
[17:42:21.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.110]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.110]                   base::options(opts)
[17:42:21.110]                 }
[17:42:21.110]                 {
[17:42:21.110]                   {
[17:42:21.110]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.110]                     NULL
[17:42:21.110]                   }
[17:42:21.110]                   options(future.plan = NULL)
[17:42:21.110]                   if (is.na(NA_character_)) 
[17:42:21.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.110]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.110]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.110]                     envir = parent.frame()) 
[17:42:21.110]                   {
[17:42:21.110]                     if (is.function(workers)) 
[17:42:21.110]                       workers <- workers()
[17:42:21.110]                     workers <- structure(as.integer(workers), 
[17:42:21.110]                       class = class(workers))
[17:42:21.110]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.110]                       workers >= 1)
[17:42:21.110]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.110]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.110]                     }
[17:42:21.110]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.110]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.110]                       envir = envir)
[17:42:21.110]                     if (!future$lazy) 
[17:42:21.110]                       future <- run(future)
[17:42:21.110]                     invisible(future)
[17:42:21.110]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.110]                 }
[17:42:21.110]             }
[17:42:21.110]         }
[17:42:21.110]     })
[17:42:21.110]     if (TRUE) {
[17:42:21.110]         base::sink(type = "output", split = FALSE)
[17:42:21.110]         if (TRUE) {
[17:42:21.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.110]         }
[17:42:21.110]         else {
[17:42:21.110]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.110]         }
[17:42:21.110]         base::close(...future.stdout)
[17:42:21.110]         ...future.stdout <- NULL
[17:42:21.110]     }
[17:42:21.110]     ...future.result$conditions <- ...future.conditions
[17:42:21.110]     ...future.result$finished <- base::Sys.time()
[17:42:21.110]     ...future.result
[17:42:21.110] }
[17:42:21.113] MultisessionFuture started
[17:42:21.113] - Launch lazy future ... done
[17:42:21.113] run() for ‘MultisessionFuture’ ... done
[17:42:21.114] getGlobalsAndPackages() ...
[17:42:21.114] Searching for globals...
[17:42:21.114] 
[17:42:21.114] Searching for globals ... DONE
[17:42:21.114] - globals: [0] <none>
[17:42:21.114] getGlobalsAndPackages() ... DONE
[17:42:21.114] run() for ‘Future’ ...
[17:42:21.115] - state: ‘created’
[17:42:21.115] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.129]   - Field: ‘node’
[17:42:21.130]   - Field: ‘label’
[17:42:21.130]   - Field: ‘local’
[17:42:21.130]   - Field: ‘owner’
[17:42:21.130]   - Field: ‘envir’
[17:42:21.130]   - Field: ‘workers’
[17:42:21.130]   - Field: ‘packages’
[17:42:21.130]   - Field: ‘gc’
[17:42:21.130]   - Field: ‘conditions’
[17:42:21.130]   - Field: ‘persistent’
[17:42:21.130]   - Field: ‘expr’
[17:42:21.131]   - Field: ‘uuid’
[17:42:21.131]   - Field: ‘seed’
[17:42:21.131]   - Field: ‘version’
[17:42:21.131]   - Field: ‘result’
[17:42:21.131]   - Field: ‘asynchronous’
[17:42:21.131]   - Field: ‘calls’
[17:42:21.131]   - Field: ‘globals’
[17:42:21.131]   - Field: ‘stdout’
[17:42:21.131]   - Field: ‘earlySignal’
[17:42:21.131]   - Field: ‘lazy’
[17:42:21.131]   - Field: ‘state’
[17:42:21.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.132] - Launch lazy future ...
[17:42:21.132] Packages needed by the future expression (n = 0): <none>
[17:42:21.132] Packages needed by future strategies (n = 0): <none>
[17:42:21.132] {
[17:42:21.132]     {
[17:42:21.132]         {
[17:42:21.132]             ...future.startTime <- base::Sys.time()
[17:42:21.132]             {
[17:42:21.132]                 {
[17:42:21.132]                   {
[17:42:21.132]                     {
[17:42:21.132]                       base::local({
[17:42:21.132]                         has_future <- base::requireNamespace("future", 
[17:42:21.132]                           quietly = TRUE)
[17:42:21.132]                         if (has_future) {
[17:42:21.132]                           ns <- base::getNamespace("future")
[17:42:21.132]                           version <- ns[[".package"]][["version"]]
[17:42:21.132]                           if (is.null(version)) 
[17:42:21.132]                             version <- utils::packageVersion("future")
[17:42:21.132]                         }
[17:42:21.132]                         else {
[17:42:21.132]                           version <- NULL
[17:42:21.132]                         }
[17:42:21.132]                         if (!has_future || version < "1.8.0") {
[17:42:21.132]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.132]                             "", base::R.version$version.string), 
[17:42:21.132]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.132]                               "release", "version")], collapse = " "), 
[17:42:21.132]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.132]                             info)
[17:42:21.132]                           info <- base::paste(info, collapse = "; ")
[17:42:21.132]                           if (!has_future) {
[17:42:21.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.132]                               info)
[17:42:21.132]                           }
[17:42:21.132]                           else {
[17:42:21.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.132]                               info, version)
[17:42:21.132]                           }
[17:42:21.132]                           base::stop(msg)
[17:42:21.132]                         }
[17:42:21.132]                       })
[17:42:21.132]                     }
[17:42:21.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.132]                     base::options(mc.cores = 1L)
[17:42:21.132]                   }
[17:42:21.132]                   options(future.plan = NULL)
[17:42:21.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.132]                 }
[17:42:21.132]                 ...future.workdir <- getwd()
[17:42:21.132]             }
[17:42:21.132]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.132]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.132]         }
[17:42:21.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.132]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.132]             base::names(...future.oldOptions))
[17:42:21.132]     }
[17:42:21.132]     if (FALSE) {
[17:42:21.132]     }
[17:42:21.132]     else {
[17:42:21.132]         if (TRUE) {
[17:42:21.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.132]                 open = "w")
[17:42:21.132]         }
[17:42:21.132]         else {
[17:42:21.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.132]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.132]         }
[17:42:21.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.132]             base::sink(type = "output", split = FALSE)
[17:42:21.132]             base::close(...future.stdout)
[17:42:21.132]         }, add = TRUE)
[17:42:21.132]     }
[17:42:21.132]     ...future.frame <- base::sys.nframe()
[17:42:21.132]     ...future.conditions <- base::list()
[17:42:21.132]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.132]     if (FALSE) {
[17:42:21.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.132]     }
[17:42:21.132]     ...future.result <- base::tryCatch({
[17:42:21.132]         base::withCallingHandlers({
[17:42:21.132]             ...future.value <- base::withVisible(base::local({
[17:42:21.132]                 ...future.makeSendCondition <- local({
[17:42:21.132]                   sendCondition <- NULL
[17:42:21.132]                   function(frame = 1L) {
[17:42:21.132]                     if (is.function(sendCondition)) 
[17:42:21.132]                       return(sendCondition)
[17:42:21.132]                     ns <- getNamespace("parallel")
[17:42:21.132]                     if (exists("sendData", mode = "function", 
[17:42:21.132]                       envir = ns)) {
[17:42:21.132]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.132]                         envir = ns)
[17:42:21.132]                       envir <- sys.frame(frame)
[17:42:21.132]                       master <- NULL
[17:42:21.132]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.132]                         !identical(envir, emptyenv())) {
[17:42:21.132]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.132]                           inherits = FALSE)) {
[17:42:21.132]                           master <- get("master", mode = "list", 
[17:42:21.132]                             envir = envir, inherits = FALSE)
[17:42:21.132]                           if (inherits(master, c("SOCKnode", 
[17:42:21.132]                             "SOCK0node"))) {
[17:42:21.132]                             sendCondition <<- function(cond) {
[17:42:21.132]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.132]                                 success = TRUE)
[17:42:21.132]                               parallel_sendData(master, data)
[17:42:21.132]                             }
[17:42:21.132]                             return(sendCondition)
[17:42:21.132]                           }
[17:42:21.132]                         }
[17:42:21.132]                         frame <- frame + 1L
[17:42:21.132]                         envir <- sys.frame(frame)
[17:42:21.132]                       }
[17:42:21.132]                     }
[17:42:21.132]                     sendCondition <<- function(cond) NULL
[17:42:21.132]                   }
[17:42:21.132]                 })
[17:42:21.132]                 withCallingHandlers({
[17:42:21.132]                   NULL
[17:42:21.132]                 }, immediateCondition = function(cond) {
[17:42:21.132]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.132]                   sendCondition(cond)
[17:42:21.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.132]                   {
[17:42:21.132]                     inherits <- base::inherits
[17:42:21.132]                     invokeRestart <- base::invokeRestart
[17:42:21.132]                     is.null <- base::is.null
[17:42:21.132]                     muffled <- FALSE
[17:42:21.132]                     if (inherits(cond, "message")) {
[17:42:21.132]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.132]                       if (muffled) 
[17:42:21.132]                         invokeRestart("muffleMessage")
[17:42:21.132]                     }
[17:42:21.132]                     else if (inherits(cond, "warning")) {
[17:42:21.132]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.132]                       if (muffled) 
[17:42:21.132]                         invokeRestart("muffleWarning")
[17:42:21.132]                     }
[17:42:21.132]                     else if (inherits(cond, "condition")) {
[17:42:21.132]                       if (!is.null(pattern)) {
[17:42:21.132]                         computeRestarts <- base::computeRestarts
[17:42:21.132]                         grepl <- base::grepl
[17:42:21.132]                         restarts <- computeRestarts(cond)
[17:42:21.132]                         for (restart in restarts) {
[17:42:21.132]                           name <- restart$name
[17:42:21.132]                           if (is.null(name)) 
[17:42:21.132]                             next
[17:42:21.132]                           if (!grepl(pattern, name)) 
[17:42:21.132]                             next
[17:42:21.132]                           invokeRestart(restart)
[17:42:21.132]                           muffled <- TRUE
[17:42:21.132]                           break
[17:42:21.132]                         }
[17:42:21.132]                       }
[17:42:21.132]                     }
[17:42:21.132]                     invisible(muffled)
[17:42:21.132]                   }
[17:42:21.132]                   muffleCondition(cond)
[17:42:21.132]                 })
[17:42:21.132]             }))
[17:42:21.132]             future::FutureResult(value = ...future.value$value, 
[17:42:21.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.132]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.132]                     ...future.globalenv.names))
[17:42:21.132]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.132]         }, condition = base::local({
[17:42:21.132]             c <- base::c
[17:42:21.132]             inherits <- base::inherits
[17:42:21.132]             invokeRestart <- base::invokeRestart
[17:42:21.132]             length <- base::length
[17:42:21.132]             list <- base::list
[17:42:21.132]             seq.int <- base::seq.int
[17:42:21.132]             signalCondition <- base::signalCondition
[17:42:21.132]             sys.calls <- base::sys.calls
[17:42:21.132]             `[[` <- base::`[[`
[17:42:21.132]             `+` <- base::`+`
[17:42:21.132]             `<<-` <- base::`<<-`
[17:42:21.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.132]                   3L)]
[17:42:21.132]             }
[17:42:21.132]             function(cond) {
[17:42:21.132]                 is_error <- inherits(cond, "error")
[17:42:21.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.132]                   NULL)
[17:42:21.132]                 if (is_error) {
[17:42:21.132]                   sessionInformation <- function() {
[17:42:21.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.132]                       search = base::search(), system = base::Sys.info())
[17:42:21.132]                   }
[17:42:21.132]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.132]                     cond$call), session = sessionInformation(), 
[17:42:21.132]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.132]                   signalCondition(cond)
[17:42:21.132]                 }
[17:42:21.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.132]                 "immediateCondition"))) {
[17:42:21.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.132]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.132]                   if (TRUE && !signal) {
[17:42:21.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.132]                     {
[17:42:21.132]                       inherits <- base::inherits
[17:42:21.132]                       invokeRestart <- base::invokeRestart
[17:42:21.132]                       is.null <- base::is.null
[17:42:21.132]                       muffled <- FALSE
[17:42:21.132]                       if (inherits(cond, "message")) {
[17:42:21.132]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.132]                         if (muffled) 
[17:42:21.132]                           invokeRestart("muffleMessage")
[17:42:21.132]                       }
[17:42:21.132]                       else if (inherits(cond, "warning")) {
[17:42:21.132]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.132]                         if (muffled) 
[17:42:21.132]                           invokeRestart("muffleWarning")
[17:42:21.132]                       }
[17:42:21.132]                       else if (inherits(cond, "condition")) {
[17:42:21.132]                         if (!is.null(pattern)) {
[17:42:21.132]                           computeRestarts <- base::computeRestarts
[17:42:21.132]                           grepl <- base::grepl
[17:42:21.132]                           restarts <- computeRestarts(cond)
[17:42:21.132]                           for (restart in restarts) {
[17:42:21.132]                             name <- restart$name
[17:42:21.132]                             if (is.null(name)) 
[17:42:21.132]                               next
[17:42:21.132]                             if (!grepl(pattern, name)) 
[17:42:21.132]                               next
[17:42:21.132]                             invokeRestart(restart)
[17:42:21.132]                             muffled <- TRUE
[17:42:21.132]                             break
[17:42:21.132]                           }
[17:42:21.132]                         }
[17:42:21.132]                       }
[17:42:21.132]                       invisible(muffled)
[17:42:21.132]                     }
[17:42:21.132]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.132]                   }
[17:42:21.132]                 }
[17:42:21.132]                 else {
[17:42:21.132]                   if (TRUE) {
[17:42:21.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.132]                     {
[17:42:21.132]                       inherits <- base::inherits
[17:42:21.132]                       invokeRestart <- base::invokeRestart
[17:42:21.132]                       is.null <- base::is.null
[17:42:21.132]                       muffled <- FALSE
[17:42:21.132]                       if (inherits(cond, "message")) {
[17:42:21.132]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.132]                         if (muffled) 
[17:42:21.132]                           invokeRestart("muffleMessage")
[17:42:21.132]                       }
[17:42:21.132]                       else if (inherits(cond, "warning")) {
[17:42:21.132]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.132]                         if (muffled) 
[17:42:21.132]                           invokeRestart("muffleWarning")
[17:42:21.132]                       }
[17:42:21.132]                       else if (inherits(cond, "condition")) {
[17:42:21.132]                         if (!is.null(pattern)) {
[17:42:21.132]                           computeRestarts <- base::computeRestarts
[17:42:21.132]                           grepl <- base::grepl
[17:42:21.132]                           restarts <- computeRestarts(cond)
[17:42:21.132]                           for (restart in restarts) {
[17:42:21.132]                             name <- restart$name
[17:42:21.132]                             if (is.null(name)) 
[17:42:21.132]                               next
[17:42:21.132]                             if (!grepl(pattern, name)) 
[17:42:21.132]                               next
[17:42:21.132]                             invokeRestart(restart)
[17:42:21.132]                             muffled <- TRUE
[17:42:21.132]                             break
[17:42:21.132]                           }
[17:42:21.132]                         }
[17:42:21.132]                       }
[17:42:21.132]                       invisible(muffled)
[17:42:21.132]                     }
[17:42:21.132]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.132]                   }
[17:42:21.132]                 }
[17:42:21.132]             }
[17:42:21.132]         }))
[17:42:21.132]     }, error = function(ex) {
[17:42:21.132]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.132]                 ...future.rng), started = ...future.startTime, 
[17:42:21.132]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.132]             version = "1.8"), class = "FutureResult")
[17:42:21.132]     }, finally = {
[17:42:21.132]         if (!identical(...future.workdir, getwd())) 
[17:42:21.132]             setwd(...future.workdir)
[17:42:21.132]         {
[17:42:21.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.132]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.132]             }
[17:42:21.132]             base::options(...future.oldOptions)
[17:42:21.132]             if (.Platform$OS.type == "windows") {
[17:42:21.132]                 old_names <- names(...future.oldEnvVars)
[17:42:21.132]                 envs <- base::Sys.getenv()
[17:42:21.132]                 names <- names(envs)
[17:42:21.132]                 common <- intersect(names, old_names)
[17:42:21.132]                 added <- setdiff(names, old_names)
[17:42:21.132]                 removed <- setdiff(old_names, names)
[17:42:21.132]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.132]                   envs[common]]
[17:42:21.132]                 NAMES <- toupper(changed)
[17:42:21.132]                 args <- list()
[17:42:21.132]                 for (kk in seq_along(NAMES)) {
[17:42:21.132]                   name <- changed[[kk]]
[17:42:21.132]                   NAME <- NAMES[[kk]]
[17:42:21.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.132]                     next
[17:42:21.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.132]                 }
[17:42:21.132]                 NAMES <- toupper(added)
[17:42:21.132]                 for (kk in seq_along(NAMES)) {
[17:42:21.132]                   name <- added[[kk]]
[17:42:21.132]                   NAME <- NAMES[[kk]]
[17:42:21.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.132]                     next
[17:42:21.132]                   args[[name]] <- ""
[17:42:21.132]                 }
[17:42:21.132]                 NAMES <- toupper(removed)
[17:42:21.132]                 for (kk in seq_along(NAMES)) {
[17:42:21.132]                   name <- removed[[kk]]
[17:42:21.132]                   NAME <- NAMES[[kk]]
[17:42:21.132]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.132]                     next
[17:42:21.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.132]                 }
[17:42:21.132]                 if (length(args) > 0) 
[17:42:21.132]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.132]             }
[17:42:21.132]             else {
[17:42:21.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.132]             }
[17:42:21.132]             {
[17:42:21.132]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.132]                   0L) {
[17:42:21.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.132]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.132]                   base::options(opts)
[17:42:21.132]                 }
[17:42:21.132]                 {
[17:42:21.132]                   {
[17:42:21.132]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.132]                     NULL
[17:42:21.132]                   }
[17:42:21.132]                   options(future.plan = NULL)
[17:42:21.132]                   if (is.na(NA_character_)) 
[17:42:21.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.132]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.132]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.132]                     envir = parent.frame()) 
[17:42:21.132]                   {
[17:42:21.132]                     if (is.function(workers)) 
[17:42:21.132]                       workers <- workers()
[17:42:21.132]                     workers <- structure(as.integer(workers), 
[17:42:21.132]                       class = class(workers))
[17:42:21.132]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.132]                       workers >= 1)
[17:42:21.132]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.132]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.132]                     }
[17:42:21.132]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.132]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.132]                       envir = envir)
[17:42:21.132]                     if (!future$lazy) 
[17:42:21.132]                       future <- run(future)
[17:42:21.132]                     invisible(future)
[17:42:21.132]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.132]                 }
[17:42:21.132]             }
[17:42:21.132]         }
[17:42:21.132]     })
[17:42:21.132]     if (TRUE) {
[17:42:21.132]         base::sink(type = "output", split = FALSE)
[17:42:21.132]         if (TRUE) {
[17:42:21.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.132]         }
[17:42:21.132]         else {
[17:42:21.132]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.132]         }
[17:42:21.132]         base::close(...future.stdout)
[17:42:21.132]         ...future.stdout <- NULL
[17:42:21.132]     }
[17:42:21.132]     ...future.result$conditions <- ...future.conditions
[17:42:21.132]     ...future.result$finished <- base::Sys.time()
[17:42:21.132]     ...future.result
[17:42:21.132] }
[17:42:21.136] MultisessionFuture started
[17:42:21.136] - Launch lazy future ... done
[17:42:21.136] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef99acfe0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef9d16860> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef99acfe0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef9d16860> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:21.165] resolve() on list ...
[17:42:21.166]  recursive: 0
[17:42:21.166]  length: 6
[17:42:21.166]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:21.166] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.166] - nx: 6
[17:42:21.166] - relay: TRUE
[17:42:21.166] - stdout: TRUE
[17:42:21.166] - signal: TRUE
[17:42:21.166] - resignal: FALSE
[17:42:21.166] - force: TRUE
[17:42:21.166] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.166] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.167]  - until=2
[17:42:21.167]  - relaying element #2
[17:42:21.167] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.167] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.167] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.167]  length: 5 (resolved future 1)
[17:42:21.168] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.168] - Validating connection of MultisessionFuture
[17:42:21.168] - received message: FutureResult
[17:42:21.168] - Received FutureResult
[17:42:21.168] - Erased future from FutureRegistry
[17:42:21.168] result() for ClusterFuture ...
[17:42:21.168] - result already collected: FutureResult
[17:42:21.168] result() for ClusterFuture ... done
[17:42:21.169] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.169] Future #2
[17:42:21.169] result() for ClusterFuture ...
[17:42:21.169] - result already collected: FutureResult
[17:42:21.169] result() for ClusterFuture ... done
[17:42:21.169] result() for ClusterFuture ...
[17:42:21.169] - result already collected: FutureResult
[17:42:21.169] result() for ClusterFuture ... done
[17:42:21.169] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:21.169] - nx: 6
[17:42:21.169] - relay: TRUE
[17:42:21.169] - stdout: TRUE
[17:42:21.170] - signal: TRUE
[17:42:21.170] - resignal: FALSE
[17:42:21.170] - force: TRUE
[17:42:21.170] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.170] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.170]  - until=2
[17:42:21.170]  - relaying element #2
[17:42:21.170] result() for ClusterFuture ...
[17:42:21.170] - result already collected: FutureResult
[17:42:21.170] result() for ClusterFuture ... done
[17:42:21.170] result() for ClusterFuture ...
[17:42:21.171] - result already collected: FutureResult
[17:42:21.171] result() for ClusterFuture ... done
[17:42:21.171] result() for ClusterFuture ...
[17:42:21.171] - result already collected: FutureResult
[17:42:21.171] result() for ClusterFuture ... done
[17:42:21.171] result() for ClusterFuture ...
[17:42:21.171] - result already collected: FutureResult
[17:42:21.171] result() for ClusterFuture ... done
[17:42:21.171] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.171] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.172] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:21.172]  length: 4 (resolved future 2)
[17:42:21.182] signalConditionsASAP(NULL, pos=4) ...
[17:42:21.182] - nx: 6
[17:42:21.183] - relay: TRUE
[17:42:21.183] - stdout: TRUE
[17:42:21.183] - signal: TRUE
[17:42:21.183] - resignal: FALSE
[17:42:21.183] - force: TRUE
[17:42:21.183] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.183] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.183]  - until=5
[17:42:21.183]  - relaying element #3
[17:42:21.184]  - relaying element #5
[17:42:21.184] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.184] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.184] signalConditionsASAP(NULL, pos=4) ... done
[17:42:21.184]  length: 3 (resolved future 4)
[17:42:21.184] signalConditionsASAP(NULL, pos=5) ...
[17:42:21.184] - nx: 6
[17:42:21.184] - relay: TRUE
[17:42:21.184] - stdout: TRUE
[17:42:21.184] - signal: TRUE
[17:42:21.184] - resignal: FALSE
[17:42:21.184] - force: TRUE
[17:42:21.185] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.185] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.185]  - until=6
[17:42:21.185]  - relaying element #3
[17:42:21.185]  - relaying element #6
[17:42:21.185] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.185] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.185] signalConditionsASAP(NULL, pos=5) ... done
[17:42:21.185]  length: 2 (resolved future 5)
[17:42:21.185] signalConditionsASAP(numeric, pos=6) ...
[17:42:21.185] - nx: 6
[17:42:21.186] - relay: TRUE
[17:42:21.186] - stdout: TRUE
[17:42:21.186] - signal: TRUE
[17:42:21.186] - resignal: FALSE
[17:42:21.186] - force: TRUE
[17:42:21.186] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.186] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.186]  - until=6
[17:42:21.186]  - relaying element #3
[17:42:21.186] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.186] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.186] signalConditionsASAP(NULL, pos=6) ... done
[17:42:21.187]  length: 1 (resolved future 6)
[17:42:21.197] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.197] - Validating connection of MultisessionFuture
[17:42:21.197] - received message: FutureResult
[17:42:21.198] - Received FutureResult
[17:42:21.198] - Erased future from FutureRegistry
[17:42:21.198] result() for ClusterFuture ...
[17:42:21.198] - result already collected: FutureResult
[17:42:21.198] result() for ClusterFuture ... done
[17:42:21.198] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.198] Future #3
[17:42:21.198] result() for ClusterFuture ...
[17:42:21.198] - result already collected: FutureResult
[17:42:21.198] result() for ClusterFuture ... done
[17:42:21.199] result() for ClusterFuture ...
[17:42:21.199] - result already collected: FutureResult
[17:42:21.199] result() for ClusterFuture ... done
[17:42:21.199] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:21.199] - nx: 6
[17:42:21.199] - relay: TRUE
[17:42:21.199] - stdout: TRUE
[17:42:21.199] - signal: TRUE
[17:42:21.199] - resignal: FALSE
[17:42:21.199] - force: TRUE
[17:42:21.199] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.200] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.200]  - until=6
[17:42:21.200]  - relaying element #3
[17:42:21.200] result() for ClusterFuture ...
[17:42:21.200] - result already collected: FutureResult
[17:42:21.200] result() for ClusterFuture ... done
[17:42:21.200] result() for ClusterFuture ...
[17:42:21.200] - result already collected: FutureResult
[17:42:21.200] result() for ClusterFuture ... done
[17:42:21.200] result() for ClusterFuture ...
[17:42:21.200] - result already collected: FutureResult
[17:42:21.201] result() for ClusterFuture ... done
[17:42:21.201] result() for ClusterFuture ...
[17:42:21.201] - result already collected: FutureResult
[17:42:21.201] result() for ClusterFuture ... done
[17:42:21.201] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.201] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.201] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:21.201]  length: 0 (resolved future 3)
[17:42:21.201] Relaying remaining futures
[17:42:21.201] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.201] - nx: 6
[17:42:21.201] - relay: TRUE
[17:42:21.202] - stdout: TRUE
[17:42:21.202] - signal: TRUE
[17:42:21.202] - resignal: FALSE
[17:42:21.202] - force: TRUE
[17:42:21.202] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:21.202] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.202] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.202] resolve() on list ... DONE
[17:42:21.202] result() for ClusterFuture ...
[17:42:21.203] - result already collected: FutureResult
[17:42:21.203] result() for ClusterFuture ... done
[17:42:21.203] result() for ClusterFuture ...
[17:42:21.203] - result already collected: FutureResult
[17:42:21.203] result() for ClusterFuture ... done
[17:42:21.203] result() for ClusterFuture ...
[17:42:21.203] - result already collected: FutureResult
[17:42:21.203] result() for ClusterFuture ... done
[17:42:21.203] result() for ClusterFuture ...
[17:42:21.203] - result already collected: FutureResult
[17:42:21.204] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:42:21.207] getGlobalsAndPackages() ...
[17:42:21.207] Searching for globals...
[17:42:21.207] 
[17:42:21.207] Searching for globals ... DONE
[17:42:21.207] - globals: [0] <none>
[17:42:21.208] getGlobalsAndPackages() ... DONE
[17:42:21.208] run() for ‘Future’ ...
[17:42:21.208] - state: ‘created’
[17:42:21.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.223]   - Field: ‘node’
[17:42:21.223]   - Field: ‘label’
[17:42:21.223]   - Field: ‘local’
[17:42:21.223]   - Field: ‘owner’
[17:42:21.223]   - Field: ‘envir’
[17:42:21.223]   - Field: ‘workers’
[17:42:21.223]   - Field: ‘packages’
[17:42:21.223]   - Field: ‘gc’
[17:42:21.224]   - Field: ‘conditions’
[17:42:21.224]   - Field: ‘persistent’
[17:42:21.224]   - Field: ‘expr’
[17:42:21.224]   - Field: ‘uuid’
[17:42:21.224]   - Field: ‘seed’
[17:42:21.224]   - Field: ‘version’
[17:42:21.224]   - Field: ‘result’
[17:42:21.224]   - Field: ‘asynchronous’
[17:42:21.224]   - Field: ‘calls’
[17:42:21.224]   - Field: ‘globals’
[17:42:21.224]   - Field: ‘stdout’
[17:42:21.225]   - Field: ‘earlySignal’
[17:42:21.225]   - Field: ‘lazy’
[17:42:21.225]   - Field: ‘state’
[17:42:21.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.225] - Launch lazy future ...
[17:42:21.225] Packages needed by the future expression (n = 0): <none>
[17:42:21.226] Packages needed by future strategies (n = 0): <none>
[17:42:21.226] {
[17:42:21.226]     {
[17:42:21.226]         {
[17:42:21.226]             ...future.startTime <- base::Sys.time()
[17:42:21.226]             {
[17:42:21.226]                 {
[17:42:21.226]                   {
[17:42:21.226]                     {
[17:42:21.226]                       base::local({
[17:42:21.226]                         has_future <- base::requireNamespace("future", 
[17:42:21.226]                           quietly = TRUE)
[17:42:21.226]                         if (has_future) {
[17:42:21.226]                           ns <- base::getNamespace("future")
[17:42:21.226]                           version <- ns[[".package"]][["version"]]
[17:42:21.226]                           if (is.null(version)) 
[17:42:21.226]                             version <- utils::packageVersion("future")
[17:42:21.226]                         }
[17:42:21.226]                         else {
[17:42:21.226]                           version <- NULL
[17:42:21.226]                         }
[17:42:21.226]                         if (!has_future || version < "1.8.0") {
[17:42:21.226]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.226]                             "", base::R.version$version.string), 
[17:42:21.226]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.226]                               "release", "version")], collapse = " "), 
[17:42:21.226]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.226]                             info)
[17:42:21.226]                           info <- base::paste(info, collapse = "; ")
[17:42:21.226]                           if (!has_future) {
[17:42:21.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.226]                               info)
[17:42:21.226]                           }
[17:42:21.226]                           else {
[17:42:21.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.226]                               info, version)
[17:42:21.226]                           }
[17:42:21.226]                           base::stop(msg)
[17:42:21.226]                         }
[17:42:21.226]                       })
[17:42:21.226]                     }
[17:42:21.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.226]                     base::options(mc.cores = 1L)
[17:42:21.226]                   }
[17:42:21.226]                   options(future.plan = NULL)
[17:42:21.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.226]                 }
[17:42:21.226]                 ...future.workdir <- getwd()
[17:42:21.226]             }
[17:42:21.226]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.226]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.226]         }
[17:42:21.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.226]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.226]             base::names(...future.oldOptions))
[17:42:21.226]     }
[17:42:21.226]     if (FALSE) {
[17:42:21.226]     }
[17:42:21.226]     else {
[17:42:21.226]         if (TRUE) {
[17:42:21.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.226]                 open = "w")
[17:42:21.226]         }
[17:42:21.226]         else {
[17:42:21.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.226]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.226]         }
[17:42:21.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.226]             base::sink(type = "output", split = FALSE)
[17:42:21.226]             base::close(...future.stdout)
[17:42:21.226]         }, add = TRUE)
[17:42:21.226]     }
[17:42:21.226]     ...future.frame <- base::sys.nframe()
[17:42:21.226]     ...future.conditions <- base::list()
[17:42:21.226]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.226]     if (FALSE) {
[17:42:21.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.226]     }
[17:42:21.226]     ...future.result <- base::tryCatch({
[17:42:21.226]         base::withCallingHandlers({
[17:42:21.226]             ...future.value <- base::withVisible(base::local({
[17:42:21.226]                 ...future.makeSendCondition <- local({
[17:42:21.226]                   sendCondition <- NULL
[17:42:21.226]                   function(frame = 1L) {
[17:42:21.226]                     if (is.function(sendCondition)) 
[17:42:21.226]                       return(sendCondition)
[17:42:21.226]                     ns <- getNamespace("parallel")
[17:42:21.226]                     if (exists("sendData", mode = "function", 
[17:42:21.226]                       envir = ns)) {
[17:42:21.226]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.226]                         envir = ns)
[17:42:21.226]                       envir <- sys.frame(frame)
[17:42:21.226]                       master <- NULL
[17:42:21.226]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.226]                         !identical(envir, emptyenv())) {
[17:42:21.226]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.226]                           inherits = FALSE)) {
[17:42:21.226]                           master <- get("master", mode = "list", 
[17:42:21.226]                             envir = envir, inherits = FALSE)
[17:42:21.226]                           if (inherits(master, c("SOCKnode", 
[17:42:21.226]                             "SOCK0node"))) {
[17:42:21.226]                             sendCondition <<- function(cond) {
[17:42:21.226]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.226]                                 success = TRUE)
[17:42:21.226]                               parallel_sendData(master, data)
[17:42:21.226]                             }
[17:42:21.226]                             return(sendCondition)
[17:42:21.226]                           }
[17:42:21.226]                         }
[17:42:21.226]                         frame <- frame + 1L
[17:42:21.226]                         envir <- sys.frame(frame)
[17:42:21.226]                       }
[17:42:21.226]                     }
[17:42:21.226]                     sendCondition <<- function(cond) NULL
[17:42:21.226]                   }
[17:42:21.226]                 })
[17:42:21.226]                 withCallingHandlers({
[17:42:21.226]                   2
[17:42:21.226]                 }, immediateCondition = function(cond) {
[17:42:21.226]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.226]                   sendCondition(cond)
[17:42:21.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.226]                   {
[17:42:21.226]                     inherits <- base::inherits
[17:42:21.226]                     invokeRestart <- base::invokeRestart
[17:42:21.226]                     is.null <- base::is.null
[17:42:21.226]                     muffled <- FALSE
[17:42:21.226]                     if (inherits(cond, "message")) {
[17:42:21.226]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.226]                       if (muffled) 
[17:42:21.226]                         invokeRestart("muffleMessage")
[17:42:21.226]                     }
[17:42:21.226]                     else if (inherits(cond, "warning")) {
[17:42:21.226]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.226]                       if (muffled) 
[17:42:21.226]                         invokeRestart("muffleWarning")
[17:42:21.226]                     }
[17:42:21.226]                     else if (inherits(cond, "condition")) {
[17:42:21.226]                       if (!is.null(pattern)) {
[17:42:21.226]                         computeRestarts <- base::computeRestarts
[17:42:21.226]                         grepl <- base::grepl
[17:42:21.226]                         restarts <- computeRestarts(cond)
[17:42:21.226]                         for (restart in restarts) {
[17:42:21.226]                           name <- restart$name
[17:42:21.226]                           if (is.null(name)) 
[17:42:21.226]                             next
[17:42:21.226]                           if (!grepl(pattern, name)) 
[17:42:21.226]                             next
[17:42:21.226]                           invokeRestart(restart)
[17:42:21.226]                           muffled <- TRUE
[17:42:21.226]                           break
[17:42:21.226]                         }
[17:42:21.226]                       }
[17:42:21.226]                     }
[17:42:21.226]                     invisible(muffled)
[17:42:21.226]                   }
[17:42:21.226]                   muffleCondition(cond)
[17:42:21.226]                 })
[17:42:21.226]             }))
[17:42:21.226]             future::FutureResult(value = ...future.value$value, 
[17:42:21.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.226]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.226]                     ...future.globalenv.names))
[17:42:21.226]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.226]         }, condition = base::local({
[17:42:21.226]             c <- base::c
[17:42:21.226]             inherits <- base::inherits
[17:42:21.226]             invokeRestart <- base::invokeRestart
[17:42:21.226]             length <- base::length
[17:42:21.226]             list <- base::list
[17:42:21.226]             seq.int <- base::seq.int
[17:42:21.226]             signalCondition <- base::signalCondition
[17:42:21.226]             sys.calls <- base::sys.calls
[17:42:21.226]             `[[` <- base::`[[`
[17:42:21.226]             `+` <- base::`+`
[17:42:21.226]             `<<-` <- base::`<<-`
[17:42:21.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.226]                   3L)]
[17:42:21.226]             }
[17:42:21.226]             function(cond) {
[17:42:21.226]                 is_error <- inherits(cond, "error")
[17:42:21.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.226]                   NULL)
[17:42:21.226]                 if (is_error) {
[17:42:21.226]                   sessionInformation <- function() {
[17:42:21.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.226]                       search = base::search(), system = base::Sys.info())
[17:42:21.226]                   }
[17:42:21.226]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.226]                     cond$call), session = sessionInformation(), 
[17:42:21.226]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.226]                   signalCondition(cond)
[17:42:21.226]                 }
[17:42:21.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.226]                 "immediateCondition"))) {
[17:42:21.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.226]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.226]                   if (TRUE && !signal) {
[17:42:21.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.226]                     {
[17:42:21.226]                       inherits <- base::inherits
[17:42:21.226]                       invokeRestart <- base::invokeRestart
[17:42:21.226]                       is.null <- base::is.null
[17:42:21.226]                       muffled <- FALSE
[17:42:21.226]                       if (inherits(cond, "message")) {
[17:42:21.226]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.226]                         if (muffled) 
[17:42:21.226]                           invokeRestart("muffleMessage")
[17:42:21.226]                       }
[17:42:21.226]                       else if (inherits(cond, "warning")) {
[17:42:21.226]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.226]                         if (muffled) 
[17:42:21.226]                           invokeRestart("muffleWarning")
[17:42:21.226]                       }
[17:42:21.226]                       else if (inherits(cond, "condition")) {
[17:42:21.226]                         if (!is.null(pattern)) {
[17:42:21.226]                           computeRestarts <- base::computeRestarts
[17:42:21.226]                           grepl <- base::grepl
[17:42:21.226]                           restarts <- computeRestarts(cond)
[17:42:21.226]                           for (restart in restarts) {
[17:42:21.226]                             name <- restart$name
[17:42:21.226]                             if (is.null(name)) 
[17:42:21.226]                               next
[17:42:21.226]                             if (!grepl(pattern, name)) 
[17:42:21.226]                               next
[17:42:21.226]                             invokeRestart(restart)
[17:42:21.226]                             muffled <- TRUE
[17:42:21.226]                             break
[17:42:21.226]                           }
[17:42:21.226]                         }
[17:42:21.226]                       }
[17:42:21.226]                       invisible(muffled)
[17:42:21.226]                     }
[17:42:21.226]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.226]                   }
[17:42:21.226]                 }
[17:42:21.226]                 else {
[17:42:21.226]                   if (TRUE) {
[17:42:21.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.226]                     {
[17:42:21.226]                       inherits <- base::inherits
[17:42:21.226]                       invokeRestart <- base::invokeRestart
[17:42:21.226]                       is.null <- base::is.null
[17:42:21.226]                       muffled <- FALSE
[17:42:21.226]                       if (inherits(cond, "message")) {
[17:42:21.226]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.226]                         if (muffled) 
[17:42:21.226]                           invokeRestart("muffleMessage")
[17:42:21.226]                       }
[17:42:21.226]                       else if (inherits(cond, "warning")) {
[17:42:21.226]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.226]                         if (muffled) 
[17:42:21.226]                           invokeRestart("muffleWarning")
[17:42:21.226]                       }
[17:42:21.226]                       else if (inherits(cond, "condition")) {
[17:42:21.226]                         if (!is.null(pattern)) {
[17:42:21.226]                           computeRestarts <- base::computeRestarts
[17:42:21.226]                           grepl <- base::grepl
[17:42:21.226]                           restarts <- computeRestarts(cond)
[17:42:21.226]                           for (restart in restarts) {
[17:42:21.226]                             name <- restart$name
[17:42:21.226]                             if (is.null(name)) 
[17:42:21.226]                               next
[17:42:21.226]                             if (!grepl(pattern, name)) 
[17:42:21.226]                               next
[17:42:21.226]                             invokeRestart(restart)
[17:42:21.226]                             muffled <- TRUE
[17:42:21.226]                             break
[17:42:21.226]                           }
[17:42:21.226]                         }
[17:42:21.226]                       }
[17:42:21.226]                       invisible(muffled)
[17:42:21.226]                     }
[17:42:21.226]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.226]                   }
[17:42:21.226]                 }
[17:42:21.226]             }
[17:42:21.226]         }))
[17:42:21.226]     }, error = function(ex) {
[17:42:21.226]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.226]                 ...future.rng), started = ...future.startTime, 
[17:42:21.226]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.226]             version = "1.8"), class = "FutureResult")
[17:42:21.226]     }, finally = {
[17:42:21.226]         if (!identical(...future.workdir, getwd())) 
[17:42:21.226]             setwd(...future.workdir)
[17:42:21.226]         {
[17:42:21.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.226]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.226]             }
[17:42:21.226]             base::options(...future.oldOptions)
[17:42:21.226]             if (.Platform$OS.type == "windows") {
[17:42:21.226]                 old_names <- names(...future.oldEnvVars)
[17:42:21.226]                 envs <- base::Sys.getenv()
[17:42:21.226]                 names <- names(envs)
[17:42:21.226]                 common <- intersect(names, old_names)
[17:42:21.226]                 added <- setdiff(names, old_names)
[17:42:21.226]                 removed <- setdiff(old_names, names)
[17:42:21.226]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.226]                   envs[common]]
[17:42:21.226]                 NAMES <- toupper(changed)
[17:42:21.226]                 args <- list()
[17:42:21.226]                 for (kk in seq_along(NAMES)) {
[17:42:21.226]                   name <- changed[[kk]]
[17:42:21.226]                   NAME <- NAMES[[kk]]
[17:42:21.226]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.226]                     next
[17:42:21.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.226]                 }
[17:42:21.226]                 NAMES <- toupper(added)
[17:42:21.226]                 for (kk in seq_along(NAMES)) {
[17:42:21.226]                   name <- added[[kk]]
[17:42:21.226]                   NAME <- NAMES[[kk]]
[17:42:21.226]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.226]                     next
[17:42:21.226]                   args[[name]] <- ""
[17:42:21.226]                 }
[17:42:21.226]                 NAMES <- toupper(removed)
[17:42:21.226]                 for (kk in seq_along(NAMES)) {
[17:42:21.226]                   name <- removed[[kk]]
[17:42:21.226]                   NAME <- NAMES[[kk]]
[17:42:21.226]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.226]                     next
[17:42:21.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.226]                 }
[17:42:21.226]                 if (length(args) > 0) 
[17:42:21.226]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.226]             }
[17:42:21.226]             else {
[17:42:21.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.226]             }
[17:42:21.226]             {
[17:42:21.226]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.226]                   0L) {
[17:42:21.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.226]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.226]                   base::options(opts)
[17:42:21.226]                 }
[17:42:21.226]                 {
[17:42:21.226]                   {
[17:42:21.226]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.226]                     NULL
[17:42:21.226]                   }
[17:42:21.226]                   options(future.plan = NULL)
[17:42:21.226]                   if (is.na(NA_character_)) 
[17:42:21.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.226]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.226]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.226]                     envir = parent.frame()) 
[17:42:21.226]                   {
[17:42:21.226]                     if (is.function(workers)) 
[17:42:21.226]                       workers <- workers()
[17:42:21.226]                     workers <- structure(as.integer(workers), 
[17:42:21.226]                       class = class(workers))
[17:42:21.226]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.226]                       workers >= 1)
[17:42:21.226]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.226]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.226]                     }
[17:42:21.226]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.226]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.226]                       envir = envir)
[17:42:21.226]                     if (!future$lazy) 
[17:42:21.226]                       future <- run(future)
[17:42:21.226]                     invisible(future)
[17:42:21.226]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.226]                 }
[17:42:21.226]             }
[17:42:21.226]         }
[17:42:21.226]     })
[17:42:21.226]     if (TRUE) {
[17:42:21.226]         base::sink(type = "output", split = FALSE)
[17:42:21.226]         if (TRUE) {
[17:42:21.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.226]         }
[17:42:21.226]         else {
[17:42:21.226]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.226]         }
[17:42:21.226]         base::close(...future.stdout)
[17:42:21.226]         ...future.stdout <- NULL
[17:42:21.226]     }
[17:42:21.226]     ...future.result$conditions <- ...future.conditions
[17:42:21.226]     ...future.result$finished <- base::Sys.time()
[17:42:21.226]     ...future.result
[17:42:21.226] }
[17:42:21.229] MultisessionFuture started
[17:42:21.230] - Launch lazy future ... done
[17:42:21.230] run() for ‘MultisessionFuture’ ... done
[17:42:21.230] getGlobalsAndPackages() ...
[17:42:21.230] Searching for globals...
[17:42:21.230] 
[17:42:21.230] Searching for globals ... DONE
[17:42:21.230] - globals: [0] <none>
[17:42:21.230] getGlobalsAndPackages() ... DONE
[17:42:21.231] run() for ‘Future’ ...
[17:42:21.231] - state: ‘created’
[17:42:21.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.246] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.246]   - Field: ‘node’
[17:42:21.246]   - Field: ‘label’
[17:42:21.246]   - Field: ‘local’
[17:42:21.246]   - Field: ‘owner’
[17:42:21.246]   - Field: ‘envir’
[17:42:21.246]   - Field: ‘workers’
[17:42:21.246]   - Field: ‘packages’
[17:42:21.247]   - Field: ‘gc’
[17:42:21.247]   - Field: ‘conditions’
[17:42:21.247]   - Field: ‘persistent’
[17:42:21.247]   - Field: ‘expr’
[17:42:21.247]   - Field: ‘uuid’
[17:42:21.247]   - Field: ‘seed’
[17:42:21.247]   - Field: ‘version’
[17:42:21.247]   - Field: ‘result’
[17:42:21.247]   - Field: ‘asynchronous’
[17:42:21.247]   - Field: ‘calls’
[17:42:21.247]   - Field: ‘globals’
[17:42:21.248]   - Field: ‘stdout’
[17:42:21.248]   - Field: ‘earlySignal’
[17:42:21.248]   - Field: ‘lazy’
[17:42:21.248]   - Field: ‘state’
[17:42:21.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.248] - Launch lazy future ...
[17:42:21.248] Packages needed by the future expression (n = 0): <none>
[17:42:21.249] Packages needed by future strategies (n = 0): <none>
[17:42:21.249] {
[17:42:21.249]     {
[17:42:21.249]         {
[17:42:21.249]             ...future.startTime <- base::Sys.time()
[17:42:21.249]             {
[17:42:21.249]                 {
[17:42:21.249]                   {
[17:42:21.249]                     {
[17:42:21.249]                       base::local({
[17:42:21.249]                         has_future <- base::requireNamespace("future", 
[17:42:21.249]                           quietly = TRUE)
[17:42:21.249]                         if (has_future) {
[17:42:21.249]                           ns <- base::getNamespace("future")
[17:42:21.249]                           version <- ns[[".package"]][["version"]]
[17:42:21.249]                           if (is.null(version)) 
[17:42:21.249]                             version <- utils::packageVersion("future")
[17:42:21.249]                         }
[17:42:21.249]                         else {
[17:42:21.249]                           version <- NULL
[17:42:21.249]                         }
[17:42:21.249]                         if (!has_future || version < "1.8.0") {
[17:42:21.249]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.249]                             "", base::R.version$version.string), 
[17:42:21.249]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.249]                               "release", "version")], collapse = " "), 
[17:42:21.249]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.249]                             info)
[17:42:21.249]                           info <- base::paste(info, collapse = "; ")
[17:42:21.249]                           if (!has_future) {
[17:42:21.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.249]                               info)
[17:42:21.249]                           }
[17:42:21.249]                           else {
[17:42:21.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.249]                               info, version)
[17:42:21.249]                           }
[17:42:21.249]                           base::stop(msg)
[17:42:21.249]                         }
[17:42:21.249]                       })
[17:42:21.249]                     }
[17:42:21.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.249]                     base::options(mc.cores = 1L)
[17:42:21.249]                   }
[17:42:21.249]                   options(future.plan = NULL)
[17:42:21.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.249]                 }
[17:42:21.249]                 ...future.workdir <- getwd()
[17:42:21.249]             }
[17:42:21.249]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.249]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.249]         }
[17:42:21.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.249]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.249]             base::names(...future.oldOptions))
[17:42:21.249]     }
[17:42:21.249]     if (FALSE) {
[17:42:21.249]     }
[17:42:21.249]     else {
[17:42:21.249]         if (TRUE) {
[17:42:21.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.249]                 open = "w")
[17:42:21.249]         }
[17:42:21.249]         else {
[17:42:21.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.249]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.249]         }
[17:42:21.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.249]             base::sink(type = "output", split = FALSE)
[17:42:21.249]             base::close(...future.stdout)
[17:42:21.249]         }, add = TRUE)
[17:42:21.249]     }
[17:42:21.249]     ...future.frame <- base::sys.nframe()
[17:42:21.249]     ...future.conditions <- base::list()
[17:42:21.249]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.249]     if (FALSE) {
[17:42:21.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.249]     }
[17:42:21.249]     ...future.result <- base::tryCatch({
[17:42:21.249]         base::withCallingHandlers({
[17:42:21.249]             ...future.value <- base::withVisible(base::local({
[17:42:21.249]                 ...future.makeSendCondition <- local({
[17:42:21.249]                   sendCondition <- NULL
[17:42:21.249]                   function(frame = 1L) {
[17:42:21.249]                     if (is.function(sendCondition)) 
[17:42:21.249]                       return(sendCondition)
[17:42:21.249]                     ns <- getNamespace("parallel")
[17:42:21.249]                     if (exists("sendData", mode = "function", 
[17:42:21.249]                       envir = ns)) {
[17:42:21.249]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.249]                         envir = ns)
[17:42:21.249]                       envir <- sys.frame(frame)
[17:42:21.249]                       master <- NULL
[17:42:21.249]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.249]                         !identical(envir, emptyenv())) {
[17:42:21.249]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.249]                           inherits = FALSE)) {
[17:42:21.249]                           master <- get("master", mode = "list", 
[17:42:21.249]                             envir = envir, inherits = FALSE)
[17:42:21.249]                           if (inherits(master, c("SOCKnode", 
[17:42:21.249]                             "SOCK0node"))) {
[17:42:21.249]                             sendCondition <<- function(cond) {
[17:42:21.249]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.249]                                 success = TRUE)
[17:42:21.249]                               parallel_sendData(master, data)
[17:42:21.249]                             }
[17:42:21.249]                             return(sendCondition)
[17:42:21.249]                           }
[17:42:21.249]                         }
[17:42:21.249]                         frame <- frame + 1L
[17:42:21.249]                         envir <- sys.frame(frame)
[17:42:21.249]                       }
[17:42:21.249]                     }
[17:42:21.249]                     sendCondition <<- function(cond) NULL
[17:42:21.249]                   }
[17:42:21.249]                 })
[17:42:21.249]                 withCallingHandlers({
[17:42:21.249]                   NULL
[17:42:21.249]                 }, immediateCondition = function(cond) {
[17:42:21.249]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.249]                   sendCondition(cond)
[17:42:21.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.249]                   {
[17:42:21.249]                     inherits <- base::inherits
[17:42:21.249]                     invokeRestart <- base::invokeRestart
[17:42:21.249]                     is.null <- base::is.null
[17:42:21.249]                     muffled <- FALSE
[17:42:21.249]                     if (inherits(cond, "message")) {
[17:42:21.249]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.249]                       if (muffled) 
[17:42:21.249]                         invokeRestart("muffleMessage")
[17:42:21.249]                     }
[17:42:21.249]                     else if (inherits(cond, "warning")) {
[17:42:21.249]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.249]                       if (muffled) 
[17:42:21.249]                         invokeRestart("muffleWarning")
[17:42:21.249]                     }
[17:42:21.249]                     else if (inherits(cond, "condition")) {
[17:42:21.249]                       if (!is.null(pattern)) {
[17:42:21.249]                         computeRestarts <- base::computeRestarts
[17:42:21.249]                         grepl <- base::grepl
[17:42:21.249]                         restarts <- computeRestarts(cond)
[17:42:21.249]                         for (restart in restarts) {
[17:42:21.249]                           name <- restart$name
[17:42:21.249]                           if (is.null(name)) 
[17:42:21.249]                             next
[17:42:21.249]                           if (!grepl(pattern, name)) 
[17:42:21.249]                             next
[17:42:21.249]                           invokeRestart(restart)
[17:42:21.249]                           muffled <- TRUE
[17:42:21.249]                           break
[17:42:21.249]                         }
[17:42:21.249]                       }
[17:42:21.249]                     }
[17:42:21.249]                     invisible(muffled)
[17:42:21.249]                   }
[17:42:21.249]                   muffleCondition(cond)
[17:42:21.249]                 })
[17:42:21.249]             }))
[17:42:21.249]             future::FutureResult(value = ...future.value$value, 
[17:42:21.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.249]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.249]                     ...future.globalenv.names))
[17:42:21.249]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.249]         }, condition = base::local({
[17:42:21.249]             c <- base::c
[17:42:21.249]             inherits <- base::inherits
[17:42:21.249]             invokeRestart <- base::invokeRestart
[17:42:21.249]             length <- base::length
[17:42:21.249]             list <- base::list
[17:42:21.249]             seq.int <- base::seq.int
[17:42:21.249]             signalCondition <- base::signalCondition
[17:42:21.249]             sys.calls <- base::sys.calls
[17:42:21.249]             `[[` <- base::`[[`
[17:42:21.249]             `+` <- base::`+`
[17:42:21.249]             `<<-` <- base::`<<-`
[17:42:21.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.249]                   3L)]
[17:42:21.249]             }
[17:42:21.249]             function(cond) {
[17:42:21.249]                 is_error <- inherits(cond, "error")
[17:42:21.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.249]                   NULL)
[17:42:21.249]                 if (is_error) {
[17:42:21.249]                   sessionInformation <- function() {
[17:42:21.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.249]                       search = base::search(), system = base::Sys.info())
[17:42:21.249]                   }
[17:42:21.249]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.249]                     cond$call), session = sessionInformation(), 
[17:42:21.249]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.249]                   signalCondition(cond)
[17:42:21.249]                 }
[17:42:21.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.249]                 "immediateCondition"))) {
[17:42:21.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.249]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.249]                   if (TRUE && !signal) {
[17:42:21.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.249]                     {
[17:42:21.249]                       inherits <- base::inherits
[17:42:21.249]                       invokeRestart <- base::invokeRestart
[17:42:21.249]                       is.null <- base::is.null
[17:42:21.249]                       muffled <- FALSE
[17:42:21.249]                       if (inherits(cond, "message")) {
[17:42:21.249]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.249]                         if (muffled) 
[17:42:21.249]                           invokeRestart("muffleMessage")
[17:42:21.249]                       }
[17:42:21.249]                       else if (inherits(cond, "warning")) {
[17:42:21.249]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.249]                         if (muffled) 
[17:42:21.249]                           invokeRestart("muffleWarning")
[17:42:21.249]                       }
[17:42:21.249]                       else if (inherits(cond, "condition")) {
[17:42:21.249]                         if (!is.null(pattern)) {
[17:42:21.249]                           computeRestarts <- base::computeRestarts
[17:42:21.249]                           grepl <- base::grepl
[17:42:21.249]                           restarts <- computeRestarts(cond)
[17:42:21.249]                           for (restart in restarts) {
[17:42:21.249]                             name <- restart$name
[17:42:21.249]                             if (is.null(name)) 
[17:42:21.249]                               next
[17:42:21.249]                             if (!grepl(pattern, name)) 
[17:42:21.249]                               next
[17:42:21.249]                             invokeRestart(restart)
[17:42:21.249]                             muffled <- TRUE
[17:42:21.249]                             break
[17:42:21.249]                           }
[17:42:21.249]                         }
[17:42:21.249]                       }
[17:42:21.249]                       invisible(muffled)
[17:42:21.249]                     }
[17:42:21.249]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.249]                   }
[17:42:21.249]                 }
[17:42:21.249]                 else {
[17:42:21.249]                   if (TRUE) {
[17:42:21.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.249]                     {
[17:42:21.249]                       inherits <- base::inherits
[17:42:21.249]                       invokeRestart <- base::invokeRestart
[17:42:21.249]                       is.null <- base::is.null
[17:42:21.249]                       muffled <- FALSE
[17:42:21.249]                       if (inherits(cond, "message")) {
[17:42:21.249]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.249]                         if (muffled) 
[17:42:21.249]                           invokeRestart("muffleMessage")
[17:42:21.249]                       }
[17:42:21.249]                       else if (inherits(cond, "warning")) {
[17:42:21.249]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.249]                         if (muffled) 
[17:42:21.249]                           invokeRestart("muffleWarning")
[17:42:21.249]                       }
[17:42:21.249]                       else if (inherits(cond, "condition")) {
[17:42:21.249]                         if (!is.null(pattern)) {
[17:42:21.249]                           computeRestarts <- base::computeRestarts
[17:42:21.249]                           grepl <- base::grepl
[17:42:21.249]                           restarts <- computeRestarts(cond)
[17:42:21.249]                           for (restart in restarts) {
[17:42:21.249]                             name <- restart$name
[17:42:21.249]                             if (is.null(name)) 
[17:42:21.249]                               next
[17:42:21.249]                             if (!grepl(pattern, name)) 
[17:42:21.249]                               next
[17:42:21.249]                             invokeRestart(restart)
[17:42:21.249]                             muffled <- TRUE
[17:42:21.249]                             break
[17:42:21.249]                           }
[17:42:21.249]                         }
[17:42:21.249]                       }
[17:42:21.249]                       invisible(muffled)
[17:42:21.249]                     }
[17:42:21.249]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.249]                   }
[17:42:21.249]                 }
[17:42:21.249]             }
[17:42:21.249]         }))
[17:42:21.249]     }, error = function(ex) {
[17:42:21.249]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.249]                 ...future.rng), started = ...future.startTime, 
[17:42:21.249]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.249]             version = "1.8"), class = "FutureResult")
[17:42:21.249]     }, finally = {
[17:42:21.249]         if (!identical(...future.workdir, getwd())) 
[17:42:21.249]             setwd(...future.workdir)
[17:42:21.249]         {
[17:42:21.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.249]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.249]             }
[17:42:21.249]             base::options(...future.oldOptions)
[17:42:21.249]             if (.Platform$OS.type == "windows") {
[17:42:21.249]                 old_names <- names(...future.oldEnvVars)
[17:42:21.249]                 envs <- base::Sys.getenv()
[17:42:21.249]                 names <- names(envs)
[17:42:21.249]                 common <- intersect(names, old_names)
[17:42:21.249]                 added <- setdiff(names, old_names)
[17:42:21.249]                 removed <- setdiff(old_names, names)
[17:42:21.249]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.249]                   envs[common]]
[17:42:21.249]                 NAMES <- toupper(changed)
[17:42:21.249]                 args <- list()
[17:42:21.249]                 for (kk in seq_along(NAMES)) {
[17:42:21.249]                   name <- changed[[kk]]
[17:42:21.249]                   NAME <- NAMES[[kk]]
[17:42:21.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.249]                     next
[17:42:21.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.249]                 }
[17:42:21.249]                 NAMES <- toupper(added)
[17:42:21.249]                 for (kk in seq_along(NAMES)) {
[17:42:21.249]                   name <- added[[kk]]
[17:42:21.249]                   NAME <- NAMES[[kk]]
[17:42:21.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.249]                     next
[17:42:21.249]                   args[[name]] <- ""
[17:42:21.249]                 }
[17:42:21.249]                 NAMES <- toupper(removed)
[17:42:21.249]                 for (kk in seq_along(NAMES)) {
[17:42:21.249]                   name <- removed[[kk]]
[17:42:21.249]                   NAME <- NAMES[[kk]]
[17:42:21.249]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.249]                     next
[17:42:21.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.249]                 }
[17:42:21.249]                 if (length(args) > 0) 
[17:42:21.249]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.249]             }
[17:42:21.249]             else {
[17:42:21.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.249]             }
[17:42:21.249]             {
[17:42:21.249]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.249]                   0L) {
[17:42:21.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.249]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.249]                   base::options(opts)
[17:42:21.249]                 }
[17:42:21.249]                 {
[17:42:21.249]                   {
[17:42:21.249]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.249]                     NULL
[17:42:21.249]                   }
[17:42:21.249]                   options(future.plan = NULL)
[17:42:21.249]                   if (is.na(NA_character_)) 
[17:42:21.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.249]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.249]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.249]                     envir = parent.frame()) 
[17:42:21.249]                   {
[17:42:21.249]                     if (is.function(workers)) 
[17:42:21.249]                       workers <- workers()
[17:42:21.249]                     workers <- structure(as.integer(workers), 
[17:42:21.249]                       class = class(workers))
[17:42:21.249]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.249]                       workers >= 1)
[17:42:21.249]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.249]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.249]                     }
[17:42:21.249]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.249]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.249]                       envir = envir)
[17:42:21.249]                     if (!future$lazy) 
[17:42:21.249]                       future <- run(future)
[17:42:21.249]                     invisible(future)
[17:42:21.249]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.249]                 }
[17:42:21.249]             }
[17:42:21.249]         }
[17:42:21.249]     })
[17:42:21.249]     if (TRUE) {
[17:42:21.249]         base::sink(type = "output", split = FALSE)
[17:42:21.249]         if (TRUE) {
[17:42:21.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.249]         }
[17:42:21.249]         else {
[17:42:21.249]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.249]         }
[17:42:21.249]         base::close(...future.stdout)
[17:42:21.249]         ...future.stdout <- NULL
[17:42:21.249]     }
[17:42:21.249]     ...future.result$conditions <- ...future.conditions
[17:42:21.249]     ...future.result$finished <- base::Sys.time()
[17:42:21.249]     ...future.result
[17:42:21.249] }
[17:42:21.252] MultisessionFuture started
[17:42:21.252] - Launch lazy future ... done
[17:42:21.252] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef5e6d290> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef90437c0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef5e6d290> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef90437c0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:21.281] resolve() on list ...
[17:42:21.281]  recursive: 0
[17:42:21.281]  length: 6
[17:42:21.281]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:21.281] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.281] - nx: 6
[17:42:21.281] - relay: TRUE
[17:42:21.281] - stdout: TRUE
[17:42:21.282] - signal: TRUE
[17:42:21.282] - resignal: FALSE
[17:42:21.282] - force: TRUE
[17:42:21.282] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.282] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.282]  - until=2
[17:42:21.282]  - relaying element #2
[17:42:21.282] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.282] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.282] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.282]  length: 5 (resolved future 1)
[17:42:21.283] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.283] - Validating connection of MultisessionFuture
[17:42:21.283] - received message: FutureResult
[17:42:21.283] - Received FutureResult
[17:42:21.284] - Erased future from FutureRegistry
[17:42:21.284] result() for ClusterFuture ...
[17:42:21.284] - result already collected: FutureResult
[17:42:21.284] result() for ClusterFuture ... done
[17:42:21.284] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.284] Future #2
[17:42:21.284] result() for ClusterFuture ...
[17:42:21.284] - result already collected: FutureResult
[17:42:21.284] result() for ClusterFuture ... done
[17:42:21.284] result() for ClusterFuture ...
[17:42:21.284] - result already collected: FutureResult
[17:42:21.285] result() for ClusterFuture ... done
[17:42:21.285] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:21.285] - nx: 6
[17:42:21.285] - relay: TRUE
[17:42:21.285] - stdout: TRUE
[17:42:21.285] - signal: TRUE
[17:42:21.285] - resignal: FALSE
[17:42:21.285] - force: TRUE
[17:42:21.285] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.285] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.285]  - until=2
[17:42:21.285]  - relaying element #2
[17:42:21.286] result() for ClusterFuture ...
[17:42:21.286] - result already collected: FutureResult
[17:42:21.286] result() for ClusterFuture ... done
[17:42:21.286] result() for ClusterFuture ...
[17:42:21.286] - result already collected: FutureResult
[17:42:21.286] result() for ClusterFuture ... done
[17:42:21.286] result() for ClusterFuture ...
[17:42:21.286] - result already collected: FutureResult
[17:42:21.286] result() for ClusterFuture ... done
[17:42:21.286] result() for ClusterFuture ...
[17:42:21.286] - result already collected: FutureResult
[17:42:21.287] result() for ClusterFuture ... done
[17:42:21.287] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.287] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.287] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:21.287]  length: 4 (resolved future 2)
[17:42:21.298] signalConditionsASAP(NULL, pos=4) ...
[17:42:21.298] - nx: 6
[17:42:21.298] - relay: TRUE
[17:42:21.298] - stdout: TRUE
[17:42:21.298] - signal: TRUE
[17:42:21.298] - resignal: FALSE
[17:42:21.298] - force: TRUE
[17:42:21.298] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.298] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.298]  - until=5
[17:42:21.299]  - relaying element #3
[17:42:21.299]  - relaying element #5
[17:42:21.299] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.299] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.299] signalConditionsASAP(NULL, pos=4) ... done
[17:42:21.299]  length: 3 (resolved future 4)
[17:42:21.299] signalConditionsASAP(NULL, pos=5) ...
[17:42:21.299] - nx: 6
[17:42:21.299] - relay: TRUE
[17:42:21.299] - stdout: TRUE
[17:42:21.299] - signal: TRUE
[17:42:21.300] - resignal: FALSE
[17:42:21.300] - force: TRUE
[17:42:21.300] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.300] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.300]  - until=6
[17:42:21.300]  - relaying element #3
[17:42:21.300]  - relaying element #6
[17:42:21.300] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.300] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.300] signalConditionsASAP(NULL, pos=5) ... done
[17:42:21.300]  length: 2 (resolved future 5)
[17:42:21.301] signalConditionsASAP(numeric, pos=6) ...
[17:42:21.301] - nx: 6
[17:42:21.301] - relay: TRUE
[17:42:21.301] - stdout: TRUE
[17:42:21.301] - signal: TRUE
[17:42:21.301] - resignal: FALSE
[17:42:21.301] - force: TRUE
[17:42:21.301] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.301] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.301]  - until=6
[17:42:21.301]  - relaying element #3
[17:42:21.301] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.302] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.302] signalConditionsASAP(NULL, pos=6) ... done
[17:42:21.302]  length: 1 (resolved future 6)
[17:42:21.312] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.313] - Validating connection of MultisessionFuture
[17:42:21.313] - received message: FutureResult
[17:42:21.313] - Received FutureResult
[17:42:21.313] - Erased future from FutureRegistry
[17:42:21.313] result() for ClusterFuture ...
[17:42:21.313] - result already collected: FutureResult
[17:42:21.313] result() for ClusterFuture ... done
[17:42:21.313] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.314] Future #3
[17:42:21.314] result() for ClusterFuture ...
[17:42:21.314] - result already collected: FutureResult
[17:42:21.314] result() for ClusterFuture ... done
[17:42:21.314] result() for ClusterFuture ...
[17:42:21.314] - result already collected: FutureResult
[17:42:21.314] result() for ClusterFuture ... done
[17:42:21.314] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:21.314] - nx: 6
[17:42:21.314] - relay: TRUE
[17:42:21.314] - stdout: TRUE
[17:42:21.315] - signal: TRUE
[17:42:21.315] - resignal: FALSE
[17:42:21.315] - force: TRUE
[17:42:21.315] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.315] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.315]  - until=6
[17:42:21.315]  - relaying element #3
[17:42:21.315] result() for ClusterFuture ...
[17:42:21.315] - result already collected: FutureResult
[17:42:21.315] result() for ClusterFuture ... done
[17:42:21.315] result() for ClusterFuture ...
[17:42:21.316] - result already collected: FutureResult
[17:42:21.316] result() for ClusterFuture ... done
[17:42:21.316] result() for ClusterFuture ...
[17:42:21.316] - result already collected: FutureResult
[17:42:21.316] result() for ClusterFuture ... done
[17:42:21.316] result() for ClusterFuture ...
[17:42:21.316] - result already collected: FutureResult
[17:42:21.316] result() for ClusterFuture ... done
[17:42:21.316] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.316] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.316] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:21.317]  length: 0 (resolved future 3)
[17:42:21.317] Relaying remaining futures
[17:42:21.317] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.317] - nx: 6
[17:42:21.317] - relay: TRUE
[17:42:21.317] - stdout: TRUE
[17:42:21.317] - signal: TRUE
[17:42:21.317] - resignal: FALSE
[17:42:21.317] - force: TRUE
[17:42:21.317] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.317] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:21.318] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.318] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.318] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.318] resolve() on list ... DONE
[17:42:21.318] result() for ClusterFuture ...
[17:42:21.318] - result already collected: FutureResult
[17:42:21.318] result() for ClusterFuture ... done
[17:42:21.318] result() for ClusterFuture ...
[17:42:21.318] - result already collected: FutureResult
[17:42:21.318] result() for ClusterFuture ... done
[17:42:21.318] result() for ClusterFuture ...
[17:42:21.318] - result already collected: FutureResult
[17:42:21.319] result() for ClusterFuture ... done
[17:42:21.319] result() for ClusterFuture ...
[17:42:21.319] - result already collected: FutureResult
[17:42:21.319] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:42:21.324] getGlobalsAndPackages() ...
[17:42:21.324] Searching for globals...
[17:42:21.325] 
[17:42:21.325] Searching for globals ... DONE
[17:42:21.325] - globals: [0] <none>
[17:42:21.325] getGlobalsAndPackages() ... DONE
[17:42:21.325] run() for ‘Future’ ...
[17:42:21.325] - state: ‘created’
[17:42:21.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.340] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.340] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.340]   - Field: ‘node’
[17:42:21.340]   - Field: ‘label’
[17:42:21.340]   - Field: ‘local’
[17:42:21.340]   - Field: ‘owner’
[17:42:21.341]   - Field: ‘envir’
[17:42:21.341]   - Field: ‘workers’
[17:42:21.341]   - Field: ‘packages’
[17:42:21.341]   - Field: ‘gc’
[17:42:21.341]   - Field: ‘conditions’
[17:42:21.341]   - Field: ‘persistent’
[17:42:21.341]   - Field: ‘expr’
[17:42:21.341]   - Field: ‘uuid’
[17:42:21.341]   - Field: ‘seed’
[17:42:21.341]   - Field: ‘version’
[17:42:21.341]   - Field: ‘result’
[17:42:21.342]   - Field: ‘asynchronous’
[17:42:21.342]   - Field: ‘calls’
[17:42:21.342]   - Field: ‘globals’
[17:42:21.342]   - Field: ‘stdout’
[17:42:21.342]   - Field: ‘earlySignal’
[17:42:21.342]   - Field: ‘lazy’
[17:42:21.342]   - Field: ‘state’
[17:42:21.342] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.342] - Launch lazy future ...
[17:42:21.343] Packages needed by the future expression (n = 0): <none>
[17:42:21.343] Packages needed by future strategies (n = 0): <none>
[17:42:21.343] {
[17:42:21.343]     {
[17:42:21.343]         {
[17:42:21.343]             ...future.startTime <- base::Sys.time()
[17:42:21.343]             {
[17:42:21.343]                 {
[17:42:21.343]                   {
[17:42:21.343]                     {
[17:42:21.343]                       base::local({
[17:42:21.343]                         has_future <- base::requireNamespace("future", 
[17:42:21.343]                           quietly = TRUE)
[17:42:21.343]                         if (has_future) {
[17:42:21.343]                           ns <- base::getNamespace("future")
[17:42:21.343]                           version <- ns[[".package"]][["version"]]
[17:42:21.343]                           if (is.null(version)) 
[17:42:21.343]                             version <- utils::packageVersion("future")
[17:42:21.343]                         }
[17:42:21.343]                         else {
[17:42:21.343]                           version <- NULL
[17:42:21.343]                         }
[17:42:21.343]                         if (!has_future || version < "1.8.0") {
[17:42:21.343]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.343]                             "", base::R.version$version.string), 
[17:42:21.343]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.343]                               "release", "version")], collapse = " "), 
[17:42:21.343]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.343]                             info)
[17:42:21.343]                           info <- base::paste(info, collapse = "; ")
[17:42:21.343]                           if (!has_future) {
[17:42:21.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.343]                               info)
[17:42:21.343]                           }
[17:42:21.343]                           else {
[17:42:21.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.343]                               info, version)
[17:42:21.343]                           }
[17:42:21.343]                           base::stop(msg)
[17:42:21.343]                         }
[17:42:21.343]                       })
[17:42:21.343]                     }
[17:42:21.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.343]                     base::options(mc.cores = 1L)
[17:42:21.343]                   }
[17:42:21.343]                   options(future.plan = NULL)
[17:42:21.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.343]                 }
[17:42:21.343]                 ...future.workdir <- getwd()
[17:42:21.343]             }
[17:42:21.343]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.343]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.343]         }
[17:42:21.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.343]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.343]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.343]             base::names(...future.oldOptions))
[17:42:21.343]     }
[17:42:21.343]     if (FALSE) {
[17:42:21.343]     }
[17:42:21.343]     else {
[17:42:21.343]         if (TRUE) {
[17:42:21.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.343]                 open = "w")
[17:42:21.343]         }
[17:42:21.343]         else {
[17:42:21.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.343]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.343]         }
[17:42:21.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.343]             base::sink(type = "output", split = FALSE)
[17:42:21.343]             base::close(...future.stdout)
[17:42:21.343]         }, add = TRUE)
[17:42:21.343]     }
[17:42:21.343]     ...future.frame <- base::sys.nframe()
[17:42:21.343]     ...future.conditions <- base::list()
[17:42:21.343]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.343]     if (FALSE) {
[17:42:21.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.343]     }
[17:42:21.343]     ...future.result <- base::tryCatch({
[17:42:21.343]         base::withCallingHandlers({
[17:42:21.343]             ...future.value <- base::withVisible(base::local({
[17:42:21.343]                 ...future.makeSendCondition <- local({
[17:42:21.343]                   sendCondition <- NULL
[17:42:21.343]                   function(frame = 1L) {
[17:42:21.343]                     if (is.function(sendCondition)) 
[17:42:21.343]                       return(sendCondition)
[17:42:21.343]                     ns <- getNamespace("parallel")
[17:42:21.343]                     if (exists("sendData", mode = "function", 
[17:42:21.343]                       envir = ns)) {
[17:42:21.343]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.343]                         envir = ns)
[17:42:21.343]                       envir <- sys.frame(frame)
[17:42:21.343]                       master <- NULL
[17:42:21.343]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.343]                         !identical(envir, emptyenv())) {
[17:42:21.343]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.343]                           inherits = FALSE)) {
[17:42:21.343]                           master <- get("master", mode = "list", 
[17:42:21.343]                             envir = envir, inherits = FALSE)
[17:42:21.343]                           if (inherits(master, c("SOCKnode", 
[17:42:21.343]                             "SOCK0node"))) {
[17:42:21.343]                             sendCondition <<- function(cond) {
[17:42:21.343]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.343]                                 success = TRUE)
[17:42:21.343]                               parallel_sendData(master, data)
[17:42:21.343]                             }
[17:42:21.343]                             return(sendCondition)
[17:42:21.343]                           }
[17:42:21.343]                         }
[17:42:21.343]                         frame <- frame + 1L
[17:42:21.343]                         envir <- sys.frame(frame)
[17:42:21.343]                       }
[17:42:21.343]                     }
[17:42:21.343]                     sendCondition <<- function(cond) NULL
[17:42:21.343]                   }
[17:42:21.343]                 })
[17:42:21.343]                 withCallingHandlers({
[17:42:21.343]                   2
[17:42:21.343]                 }, immediateCondition = function(cond) {
[17:42:21.343]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.343]                   sendCondition(cond)
[17:42:21.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.343]                   {
[17:42:21.343]                     inherits <- base::inherits
[17:42:21.343]                     invokeRestart <- base::invokeRestart
[17:42:21.343]                     is.null <- base::is.null
[17:42:21.343]                     muffled <- FALSE
[17:42:21.343]                     if (inherits(cond, "message")) {
[17:42:21.343]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.343]                       if (muffled) 
[17:42:21.343]                         invokeRestart("muffleMessage")
[17:42:21.343]                     }
[17:42:21.343]                     else if (inherits(cond, "warning")) {
[17:42:21.343]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.343]                       if (muffled) 
[17:42:21.343]                         invokeRestart("muffleWarning")
[17:42:21.343]                     }
[17:42:21.343]                     else if (inherits(cond, "condition")) {
[17:42:21.343]                       if (!is.null(pattern)) {
[17:42:21.343]                         computeRestarts <- base::computeRestarts
[17:42:21.343]                         grepl <- base::grepl
[17:42:21.343]                         restarts <- computeRestarts(cond)
[17:42:21.343]                         for (restart in restarts) {
[17:42:21.343]                           name <- restart$name
[17:42:21.343]                           if (is.null(name)) 
[17:42:21.343]                             next
[17:42:21.343]                           if (!grepl(pattern, name)) 
[17:42:21.343]                             next
[17:42:21.343]                           invokeRestart(restart)
[17:42:21.343]                           muffled <- TRUE
[17:42:21.343]                           break
[17:42:21.343]                         }
[17:42:21.343]                       }
[17:42:21.343]                     }
[17:42:21.343]                     invisible(muffled)
[17:42:21.343]                   }
[17:42:21.343]                   muffleCondition(cond)
[17:42:21.343]                 })
[17:42:21.343]             }))
[17:42:21.343]             future::FutureResult(value = ...future.value$value, 
[17:42:21.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.343]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.343]                     ...future.globalenv.names))
[17:42:21.343]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.343]         }, condition = base::local({
[17:42:21.343]             c <- base::c
[17:42:21.343]             inherits <- base::inherits
[17:42:21.343]             invokeRestart <- base::invokeRestart
[17:42:21.343]             length <- base::length
[17:42:21.343]             list <- base::list
[17:42:21.343]             seq.int <- base::seq.int
[17:42:21.343]             signalCondition <- base::signalCondition
[17:42:21.343]             sys.calls <- base::sys.calls
[17:42:21.343]             `[[` <- base::`[[`
[17:42:21.343]             `+` <- base::`+`
[17:42:21.343]             `<<-` <- base::`<<-`
[17:42:21.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.343]                   3L)]
[17:42:21.343]             }
[17:42:21.343]             function(cond) {
[17:42:21.343]                 is_error <- inherits(cond, "error")
[17:42:21.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.343]                   NULL)
[17:42:21.343]                 if (is_error) {
[17:42:21.343]                   sessionInformation <- function() {
[17:42:21.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.343]                       search = base::search(), system = base::Sys.info())
[17:42:21.343]                   }
[17:42:21.343]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.343]                     cond$call), session = sessionInformation(), 
[17:42:21.343]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.343]                   signalCondition(cond)
[17:42:21.343]                 }
[17:42:21.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.343]                 "immediateCondition"))) {
[17:42:21.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.343]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.343]                   if (TRUE && !signal) {
[17:42:21.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.343]                     {
[17:42:21.343]                       inherits <- base::inherits
[17:42:21.343]                       invokeRestart <- base::invokeRestart
[17:42:21.343]                       is.null <- base::is.null
[17:42:21.343]                       muffled <- FALSE
[17:42:21.343]                       if (inherits(cond, "message")) {
[17:42:21.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.343]                         if (muffled) 
[17:42:21.343]                           invokeRestart("muffleMessage")
[17:42:21.343]                       }
[17:42:21.343]                       else if (inherits(cond, "warning")) {
[17:42:21.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.343]                         if (muffled) 
[17:42:21.343]                           invokeRestart("muffleWarning")
[17:42:21.343]                       }
[17:42:21.343]                       else if (inherits(cond, "condition")) {
[17:42:21.343]                         if (!is.null(pattern)) {
[17:42:21.343]                           computeRestarts <- base::computeRestarts
[17:42:21.343]                           grepl <- base::grepl
[17:42:21.343]                           restarts <- computeRestarts(cond)
[17:42:21.343]                           for (restart in restarts) {
[17:42:21.343]                             name <- restart$name
[17:42:21.343]                             if (is.null(name)) 
[17:42:21.343]                               next
[17:42:21.343]                             if (!grepl(pattern, name)) 
[17:42:21.343]                               next
[17:42:21.343]                             invokeRestart(restart)
[17:42:21.343]                             muffled <- TRUE
[17:42:21.343]                             break
[17:42:21.343]                           }
[17:42:21.343]                         }
[17:42:21.343]                       }
[17:42:21.343]                       invisible(muffled)
[17:42:21.343]                     }
[17:42:21.343]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.343]                   }
[17:42:21.343]                 }
[17:42:21.343]                 else {
[17:42:21.343]                   if (TRUE) {
[17:42:21.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.343]                     {
[17:42:21.343]                       inherits <- base::inherits
[17:42:21.343]                       invokeRestart <- base::invokeRestart
[17:42:21.343]                       is.null <- base::is.null
[17:42:21.343]                       muffled <- FALSE
[17:42:21.343]                       if (inherits(cond, "message")) {
[17:42:21.343]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.343]                         if (muffled) 
[17:42:21.343]                           invokeRestart("muffleMessage")
[17:42:21.343]                       }
[17:42:21.343]                       else if (inherits(cond, "warning")) {
[17:42:21.343]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.343]                         if (muffled) 
[17:42:21.343]                           invokeRestart("muffleWarning")
[17:42:21.343]                       }
[17:42:21.343]                       else if (inherits(cond, "condition")) {
[17:42:21.343]                         if (!is.null(pattern)) {
[17:42:21.343]                           computeRestarts <- base::computeRestarts
[17:42:21.343]                           grepl <- base::grepl
[17:42:21.343]                           restarts <- computeRestarts(cond)
[17:42:21.343]                           for (restart in restarts) {
[17:42:21.343]                             name <- restart$name
[17:42:21.343]                             if (is.null(name)) 
[17:42:21.343]                               next
[17:42:21.343]                             if (!grepl(pattern, name)) 
[17:42:21.343]                               next
[17:42:21.343]                             invokeRestart(restart)
[17:42:21.343]                             muffled <- TRUE
[17:42:21.343]                             break
[17:42:21.343]                           }
[17:42:21.343]                         }
[17:42:21.343]                       }
[17:42:21.343]                       invisible(muffled)
[17:42:21.343]                     }
[17:42:21.343]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.343]                   }
[17:42:21.343]                 }
[17:42:21.343]             }
[17:42:21.343]         }))
[17:42:21.343]     }, error = function(ex) {
[17:42:21.343]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.343]                 ...future.rng), started = ...future.startTime, 
[17:42:21.343]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.343]             version = "1.8"), class = "FutureResult")
[17:42:21.343]     }, finally = {
[17:42:21.343]         if (!identical(...future.workdir, getwd())) 
[17:42:21.343]             setwd(...future.workdir)
[17:42:21.343]         {
[17:42:21.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.343]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.343]             }
[17:42:21.343]             base::options(...future.oldOptions)
[17:42:21.343]             if (.Platform$OS.type == "windows") {
[17:42:21.343]                 old_names <- names(...future.oldEnvVars)
[17:42:21.343]                 envs <- base::Sys.getenv()
[17:42:21.343]                 names <- names(envs)
[17:42:21.343]                 common <- intersect(names, old_names)
[17:42:21.343]                 added <- setdiff(names, old_names)
[17:42:21.343]                 removed <- setdiff(old_names, names)
[17:42:21.343]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.343]                   envs[common]]
[17:42:21.343]                 NAMES <- toupper(changed)
[17:42:21.343]                 args <- list()
[17:42:21.343]                 for (kk in seq_along(NAMES)) {
[17:42:21.343]                   name <- changed[[kk]]
[17:42:21.343]                   NAME <- NAMES[[kk]]
[17:42:21.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.343]                     next
[17:42:21.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.343]                 }
[17:42:21.343]                 NAMES <- toupper(added)
[17:42:21.343]                 for (kk in seq_along(NAMES)) {
[17:42:21.343]                   name <- added[[kk]]
[17:42:21.343]                   NAME <- NAMES[[kk]]
[17:42:21.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.343]                     next
[17:42:21.343]                   args[[name]] <- ""
[17:42:21.343]                 }
[17:42:21.343]                 NAMES <- toupper(removed)
[17:42:21.343]                 for (kk in seq_along(NAMES)) {
[17:42:21.343]                   name <- removed[[kk]]
[17:42:21.343]                   NAME <- NAMES[[kk]]
[17:42:21.343]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.343]                     next
[17:42:21.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.343]                 }
[17:42:21.343]                 if (length(args) > 0) 
[17:42:21.343]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.343]             }
[17:42:21.343]             else {
[17:42:21.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.343]             }
[17:42:21.343]             {
[17:42:21.343]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.343]                   0L) {
[17:42:21.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.343]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.343]                   base::options(opts)
[17:42:21.343]                 }
[17:42:21.343]                 {
[17:42:21.343]                   {
[17:42:21.343]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.343]                     NULL
[17:42:21.343]                   }
[17:42:21.343]                   options(future.plan = NULL)
[17:42:21.343]                   if (is.na(NA_character_)) 
[17:42:21.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.343]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.343]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.343]                     envir = parent.frame()) 
[17:42:21.343]                   {
[17:42:21.343]                     if (is.function(workers)) 
[17:42:21.343]                       workers <- workers()
[17:42:21.343]                     workers <- structure(as.integer(workers), 
[17:42:21.343]                       class = class(workers))
[17:42:21.343]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.343]                       workers >= 1)
[17:42:21.343]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.343]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.343]                     }
[17:42:21.343]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.343]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.343]                       envir = envir)
[17:42:21.343]                     if (!future$lazy) 
[17:42:21.343]                       future <- run(future)
[17:42:21.343]                     invisible(future)
[17:42:21.343]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.343]                 }
[17:42:21.343]             }
[17:42:21.343]         }
[17:42:21.343]     })
[17:42:21.343]     if (TRUE) {
[17:42:21.343]         base::sink(type = "output", split = FALSE)
[17:42:21.343]         if (TRUE) {
[17:42:21.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.343]         }
[17:42:21.343]         else {
[17:42:21.343]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.343]         }
[17:42:21.343]         base::close(...future.stdout)
[17:42:21.343]         ...future.stdout <- NULL
[17:42:21.343]     }
[17:42:21.343]     ...future.result$conditions <- ...future.conditions
[17:42:21.343]     ...future.result$finished <- base::Sys.time()
[17:42:21.343]     ...future.result
[17:42:21.343] }
[17:42:21.346] MultisessionFuture started
[17:42:21.346] - Launch lazy future ... done
[17:42:21.346] run() for ‘MultisessionFuture’ ... done
[17:42:21.347] getGlobalsAndPackages() ...
[17:42:21.347] Searching for globals...
[17:42:21.347] 
[17:42:21.347] Searching for globals ... DONE
[17:42:21.347] - globals: [0] <none>
[17:42:21.347] getGlobalsAndPackages() ... DONE
[17:42:21.348] run() for ‘Future’ ...
[17:42:21.348] - state: ‘created’
[17:42:21.348] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:21.362]   - Field: ‘node’
[17:42:21.363]   - Field: ‘label’
[17:42:21.363]   - Field: ‘local’
[17:42:21.363]   - Field: ‘owner’
[17:42:21.363]   - Field: ‘envir’
[17:42:21.363]   - Field: ‘workers’
[17:42:21.363]   - Field: ‘packages’
[17:42:21.363]   - Field: ‘gc’
[17:42:21.363]   - Field: ‘conditions’
[17:42:21.363]   - Field: ‘persistent’
[17:42:21.363]   - Field: ‘expr’
[17:42:21.364]   - Field: ‘uuid’
[17:42:21.364]   - Field: ‘seed’
[17:42:21.364]   - Field: ‘version’
[17:42:21.364]   - Field: ‘result’
[17:42:21.364]   - Field: ‘asynchronous’
[17:42:21.364]   - Field: ‘calls’
[17:42:21.364]   - Field: ‘globals’
[17:42:21.364]   - Field: ‘stdout’
[17:42:21.364]   - Field: ‘earlySignal’
[17:42:21.364]   - Field: ‘lazy’
[17:42:21.364]   - Field: ‘state’
[17:42:21.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:21.365] - Launch lazy future ...
[17:42:21.365] Packages needed by the future expression (n = 0): <none>
[17:42:21.365] Packages needed by future strategies (n = 0): <none>
[17:42:21.365] {
[17:42:21.365]     {
[17:42:21.365]         {
[17:42:21.365]             ...future.startTime <- base::Sys.time()
[17:42:21.365]             {
[17:42:21.365]                 {
[17:42:21.365]                   {
[17:42:21.365]                     {
[17:42:21.365]                       base::local({
[17:42:21.365]                         has_future <- base::requireNamespace("future", 
[17:42:21.365]                           quietly = TRUE)
[17:42:21.365]                         if (has_future) {
[17:42:21.365]                           ns <- base::getNamespace("future")
[17:42:21.365]                           version <- ns[[".package"]][["version"]]
[17:42:21.365]                           if (is.null(version)) 
[17:42:21.365]                             version <- utils::packageVersion("future")
[17:42:21.365]                         }
[17:42:21.365]                         else {
[17:42:21.365]                           version <- NULL
[17:42:21.365]                         }
[17:42:21.365]                         if (!has_future || version < "1.8.0") {
[17:42:21.365]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.365]                             "", base::R.version$version.string), 
[17:42:21.365]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.365]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.365]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.365]                               "release", "version")], collapse = " "), 
[17:42:21.365]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.365]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.365]                             info)
[17:42:21.365]                           info <- base::paste(info, collapse = "; ")
[17:42:21.365]                           if (!has_future) {
[17:42:21.365]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.365]                               info)
[17:42:21.365]                           }
[17:42:21.365]                           else {
[17:42:21.365]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.365]                               info, version)
[17:42:21.365]                           }
[17:42:21.365]                           base::stop(msg)
[17:42:21.365]                         }
[17:42:21.365]                       })
[17:42:21.365]                     }
[17:42:21.365]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.365]                     base::options(mc.cores = 1L)
[17:42:21.365]                   }
[17:42:21.365]                   options(future.plan = NULL)
[17:42:21.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.365]                 }
[17:42:21.365]                 ...future.workdir <- getwd()
[17:42:21.365]             }
[17:42:21.365]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.365]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.365]         }
[17:42:21.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.365]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.365]             base::names(...future.oldOptions))
[17:42:21.365]     }
[17:42:21.365]     if (FALSE) {
[17:42:21.365]     }
[17:42:21.365]     else {
[17:42:21.365]         if (TRUE) {
[17:42:21.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.365]                 open = "w")
[17:42:21.365]         }
[17:42:21.365]         else {
[17:42:21.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.365]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.365]         }
[17:42:21.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.365]             base::sink(type = "output", split = FALSE)
[17:42:21.365]             base::close(...future.stdout)
[17:42:21.365]         }, add = TRUE)
[17:42:21.365]     }
[17:42:21.365]     ...future.frame <- base::sys.nframe()
[17:42:21.365]     ...future.conditions <- base::list()
[17:42:21.365]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.365]     if (FALSE) {
[17:42:21.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.365]     }
[17:42:21.365]     ...future.result <- base::tryCatch({
[17:42:21.365]         base::withCallingHandlers({
[17:42:21.365]             ...future.value <- base::withVisible(base::local({
[17:42:21.365]                 ...future.makeSendCondition <- local({
[17:42:21.365]                   sendCondition <- NULL
[17:42:21.365]                   function(frame = 1L) {
[17:42:21.365]                     if (is.function(sendCondition)) 
[17:42:21.365]                       return(sendCondition)
[17:42:21.365]                     ns <- getNamespace("parallel")
[17:42:21.365]                     if (exists("sendData", mode = "function", 
[17:42:21.365]                       envir = ns)) {
[17:42:21.365]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:21.365]                         envir = ns)
[17:42:21.365]                       envir <- sys.frame(frame)
[17:42:21.365]                       master <- NULL
[17:42:21.365]                       while (!identical(envir, .GlobalEnv) && 
[17:42:21.365]                         !identical(envir, emptyenv())) {
[17:42:21.365]                         if (exists("master", mode = "list", envir = envir, 
[17:42:21.365]                           inherits = FALSE)) {
[17:42:21.365]                           master <- get("master", mode = "list", 
[17:42:21.365]                             envir = envir, inherits = FALSE)
[17:42:21.365]                           if (inherits(master, c("SOCKnode", 
[17:42:21.365]                             "SOCK0node"))) {
[17:42:21.365]                             sendCondition <<- function(cond) {
[17:42:21.365]                               data <- list(type = "VALUE", value = cond, 
[17:42:21.365]                                 success = TRUE)
[17:42:21.365]                               parallel_sendData(master, data)
[17:42:21.365]                             }
[17:42:21.365]                             return(sendCondition)
[17:42:21.365]                           }
[17:42:21.365]                         }
[17:42:21.365]                         frame <- frame + 1L
[17:42:21.365]                         envir <- sys.frame(frame)
[17:42:21.365]                       }
[17:42:21.365]                     }
[17:42:21.365]                     sendCondition <<- function(cond) NULL
[17:42:21.365]                   }
[17:42:21.365]                 })
[17:42:21.365]                 withCallingHandlers({
[17:42:21.365]                   NULL
[17:42:21.365]                 }, immediateCondition = function(cond) {
[17:42:21.365]                   sendCondition <- ...future.makeSendCondition()
[17:42:21.365]                   sendCondition(cond)
[17:42:21.365]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.365]                   {
[17:42:21.365]                     inherits <- base::inherits
[17:42:21.365]                     invokeRestart <- base::invokeRestart
[17:42:21.365]                     is.null <- base::is.null
[17:42:21.365]                     muffled <- FALSE
[17:42:21.365]                     if (inherits(cond, "message")) {
[17:42:21.365]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.365]                       if (muffled) 
[17:42:21.365]                         invokeRestart("muffleMessage")
[17:42:21.365]                     }
[17:42:21.365]                     else if (inherits(cond, "warning")) {
[17:42:21.365]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.365]                       if (muffled) 
[17:42:21.365]                         invokeRestart("muffleWarning")
[17:42:21.365]                     }
[17:42:21.365]                     else if (inherits(cond, "condition")) {
[17:42:21.365]                       if (!is.null(pattern)) {
[17:42:21.365]                         computeRestarts <- base::computeRestarts
[17:42:21.365]                         grepl <- base::grepl
[17:42:21.365]                         restarts <- computeRestarts(cond)
[17:42:21.365]                         for (restart in restarts) {
[17:42:21.365]                           name <- restart$name
[17:42:21.365]                           if (is.null(name)) 
[17:42:21.365]                             next
[17:42:21.365]                           if (!grepl(pattern, name)) 
[17:42:21.365]                             next
[17:42:21.365]                           invokeRestart(restart)
[17:42:21.365]                           muffled <- TRUE
[17:42:21.365]                           break
[17:42:21.365]                         }
[17:42:21.365]                       }
[17:42:21.365]                     }
[17:42:21.365]                     invisible(muffled)
[17:42:21.365]                   }
[17:42:21.365]                   muffleCondition(cond)
[17:42:21.365]                 })
[17:42:21.365]             }))
[17:42:21.365]             future::FutureResult(value = ...future.value$value, 
[17:42:21.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.365]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.365]                     ...future.globalenv.names))
[17:42:21.365]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.365]         }, condition = base::local({
[17:42:21.365]             c <- base::c
[17:42:21.365]             inherits <- base::inherits
[17:42:21.365]             invokeRestart <- base::invokeRestart
[17:42:21.365]             length <- base::length
[17:42:21.365]             list <- base::list
[17:42:21.365]             seq.int <- base::seq.int
[17:42:21.365]             signalCondition <- base::signalCondition
[17:42:21.365]             sys.calls <- base::sys.calls
[17:42:21.365]             `[[` <- base::`[[`
[17:42:21.365]             `+` <- base::`+`
[17:42:21.365]             `<<-` <- base::`<<-`
[17:42:21.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.365]                   3L)]
[17:42:21.365]             }
[17:42:21.365]             function(cond) {
[17:42:21.365]                 is_error <- inherits(cond, "error")
[17:42:21.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.365]                   NULL)
[17:42:21.365]                 if (is_error) {
[17:42:21.365]                   sessionInformation <- function() {
[17:42:21.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.365]                       search = base::search(), system = base::Sys.info())
[17:42:21.365]                   }
[17:42:21.365]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.365]                     cond$call), session = sessionInformation(), 
[17:42:21.365]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.365]                   signalCondition(cond)
[17:42:21.365]                 }
[17:42:21.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.365]                 "immediateCondition"))) {
[17:42:21.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.365]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.365]                   if (TRUE && !signal) {
[17:42:21.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.365]                     {
[17:42:21.365]                       inherits <- base::inherits
[17:42:21.365]                       invokeRestart <- base::invokeRestart
[17:42:21.365]                       is.null <- base::is.null
[17:42:21.365]                       muffled <- FALSE
[17:42:21.365]                       if (inherits(cond, "message")) {
[17:42:21.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.365]                         if (muffled) 
[17:42:21.365]                           invokeRestart("muffleMessage")
[17:42:21.365]                       }
[17:42:21.365]                       else if (inherits(cond, "warning")) {
[17:42:21.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.365]                         if (muffled) 
[17:42:21.365]                           invokeRestart("muffleWarning")
[17:42:21.365]                       }
[17:42:21.365]                       else if (inherits(cond, "condition")) {
[17:42:21.365]                         if (!is.null(pattern)) {
[17:42:21.365]                           computeRestarts <- base::computeRestarts
[17:42:21.365]                           grepl <- base::grepl
[17:42:21.365]                           restarts <- computeRestarts(cond)
[17:42:21.365]                           for (restart in restarts) {
[17:42:21.365]                             name <- restart$name
[17:42:21.365]                             if (is.null(name)) 
[17:42:21.365]                               next
[17:42:21.365]                             if (!grepl(pattern, name)) 
[17:42:21.365]                               next
[17:42:21.365]                             invokeRestart(restart)
[17:42:21.365]                             muffled <- TRUE
[17:42:21.365]                             break
[17:42:21.365]                           }
[17:42:21.365]                         }
[17:42:21.365]                       }
[17:42:21.365]                       invisible(muffled)
[17:42:21.365]                     }
[17:42:21.365]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.365]                   }
[17:42:21.365]                 }
[17:42:21.365]                 else {
[17:42:21.365]                   if (TRUE) {
[17:42:21.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.365]                     {
[17:42:21.365]                       inherits <- base::inherits
[17:42:21.365]                       invokeRestart <- base::invokeRestart
[17:42:21.365]                       is.null <- base::is.null
[17:42:21.365]                       muffled <- FALSE
[17:42:21.365]                       if (inherits(cond, "message")) {
[17:42:21.365]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.365]                         if (muffled) 
[17:42:21.365]                           invokeRestart("muffleMessage")
[17:42:21.365]                       }
[17:42:21.365]                       else if (inherits(cond, "warning")) {
[17:42:21.365]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.365]                         if (muffled) 
[17:42:21.365]                           invokeRestart("muffleWarning")
[17:42:21.365]                       }
[17:42:21.365]                       else if (inherits(cond, "condition")) {
[17:42:21.365]                         if (!is.null(pattern)) {
[17:42:21.365]                           computeRestarts <- base::computeRestarts
[17:42:21.365]                           grepl <- base::grepl
[17:42:21.365]                           restarts <- computeRestarts(cond)
[17:42:21.365]                           for (restart in restarts) {
[17:42:21.365]                             name <- restart$name
[17:42:21.365]                             if (is.null(name)) 
[17:42:21.365]                               next
[17:42:21.365]                             if (!grepl(pattern, name)) 
[17:42:21.365]                               next
[17:42:21.365]                             invokeRestart(restart)
[17:42:21.365]                             muffled <- TRUE
[17:42:21.365]                             break
[17:42:21.365]                           }
[17:42:21.365]                         }
[17:42:21.365]                       }
[17:42:21.365]                       invisible(muffled)
[17:42:21.365]                     }
[17:42:21.365]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.365]                   }
[17:42:21.365]                 }
[17:42:21.365]             }
[17:42:21.365]         }))
[17:42:21.365]     }, error = function(ex) {
[17:42:21.365]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.365]                 ...future.rng), started = ...future.startTime, 
[17:42:21.365]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.365]             version = "1.8"), class = "FutureResult")
[17:42:21.365]     }, finally = {
[17:42:21.365]         if (!identical(...future.workdir, getwd())) 
[17:42:21.365]             setwd(...future.workdir)
[17:42:21.365]         {
[17:42:21.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.365]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.365]             }
[17:42:21.365]             base::options(...future.oldOptions)
[17:42:21.365]             if (.Platform$OS.type == "windows") {
[17:42:21.365]                 old_names <- names(...future.oldEnvVars)
[17:42:21.365]                 envs <- base::Sys.getenv()
[17:42:21.365]                 names <- names(envs)
[17:42:21.365]                 common <- intersect(names, old_names)
[17:42:21.365]                 added <- setdiff(names, old_names)
[17:42:21.365]                 removed <- setdiff(old_names, names)
[17:42:21.365]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.365]                   envs[common]]
[17:42:21.365]                 NAMES <- toupper(changed)
[17:42:21.365]                 args <- list()
[17:42:21.365]                 for (kk in seq_along(NAMES)) {
[17:42:21.365]                   name <- changed[[kk]]
[17:42:21.365]                   NAME <- NAMES[[kk]]
[17:42:21.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.365]                     next
[17:42:21.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.365]                 }
[17:42:21.365]                 NAMES <- toupper(added)
[17:42:21.365]                 for (kk in seq_along(NAMES)) {
[17:42:21.365]                   name <- added[[kk]]
[17:42:21.365]                   NAME <- NAMES[[kk]]
[17:42:21.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.365]                     next
[17:42:21.365]                   args[[name]] <- ""
[17:42:21.365]                 }
[17:42:21.365]                 NAMES <- toupper(removed)
[17:42:21.365]                 for (kk in seq_along(NAMES)) {
[17:42:21.365]                   name <- removed[[kk]]
[17:42:21.365]                   NAME <- NAMES[[kk]]
[17:42:21.365]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.365]                     next
[17:42:21.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.365]                 }
[17:42:21.365]                 if (length(args) > 0) 
[17:42:21.365]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.365]             }
[17:42:21.365]             else {
[17:42:21.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.365]             }
[17:42:21.365]             {
[17:42:21.365]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.365]                   0L) {
[17:42:21.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.365]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.365]                   base::options(opts)
[17:42:21.365]                 }
[17:42:21.365]                 {
[17:42:21.365]                   {
[17:42:21.365]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.365]                     NULL
[17:42:21.365]                   }
[17:42:21.365]                   options(future.plan = NULL)
[17:42:21.365]                   if (is.na(NA_character_)) 
[17:42:21.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.365]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:21.365]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:21.365]                     envir = parent.frame()) 
[17:42:21.365]                   {
[17:42:21.365]                     if (is.function(workers)) 
[17:42:21.365]                       workers <- workers()
[17:42:21.365]                     workers <- structure(as.integer(workers), 
[17:42:21.365]                       class = class(workers))
[17:42:21.365]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:21.365]                       workers >= 1)
[17:42:21.365]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:21.365]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:21.365]                     }
[17:42:21.365]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:21.365]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:21.365]                       envir = envir)
[17:42:21.365]                     if (!future$lazy) 
[17:42:21.365]                       future <- run(future)
[17:42:21.365]                     invisible(future)
[17:42:21.365]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.365]                 }
[17:42:21.365]             }
[17:42:21.365]         }
[17:42:21.365]     })
[17:42:21.365]     if (TRUE) {
[17:42:21.365]         base::sink(type = "output", split = FALSE)
[17:42:21.365]         if (TRUE) {
[17:42:21.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.365]         }
[17:42:21.365]         else {
[17:42:21.365]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.365]         }
[17:42:21.365]         base::close(...future.stdout)
[17:42:21.365]         ...future.stdout <- NULL
[17:42:21.365]     }
[17:42:21.365]     ...future.result$conditions <- ...future.conditions
[17:42:21.365]     ...future.result$finished <- base::Sys.time()
[17:42:21.365]     ...future.result
[17:42:21.365] }
[17:42:21.369] MultisessionFuture started
[17:42:21.369] - Launch lazy future ... done
[17:42:21.369] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef889a0c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef8128828> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef889a0c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55bef8128828> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[17:42:21.398] resolve() on list ...
[17:42:21.398]  recursive: 0
[17:42:21.398]  length: 6
[17:42:21.398]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[17:42:21.398] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.398] - nx: 6
[17:42:21.399] - relay: TRUE
[17:42:21.399] - stdout: TRUE
[17:42:21.399] - signal: TRUE
[17:42:21.399] - resignal: FALSE
[17:42:21.399] - force: TRUE
[17:42:21.399] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.399] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.399]  - until=2
[17:42:21.399]  - relaying element #2
[17:42:21.399] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.399] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.400] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.400]  length: 5 (resolved future 1)
[17:42:21.400] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.400] - Validating connection of MultisessionFuture
[17:42:21.400] - received message: FutureResult
[17:42:21.401] - Received FutureResult
[17:42:21.401] - Erased future from FutureRegistry
[17:42:21.401] result() for ClusterFuture ...
[17:42:21.401] - result already collected: FutureResult
[17:42:21.401] result() for ClusterFuture ... done
[17:42:21.401] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.401] Future #2
[17:42:21.401] result() for ClusterFuture ...
[17:42:21.401] - result already collected: FutureResult
[17:42:21.401] result() for ClusterFuture ... done
[17:42:21.402] result() for ClusterFuture ...
[17:42:21.402] - result already collected: FutureResult
[17:42:21.402] result() for ClusterFuture ... done
[17:42:21.402] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:21.402] - nx: 6
[17:42:21.402] - relay: TRUE
[17:42:21.402] - stdout: TRUE
[17:42:21.402] - signal: TRUE
[17:42:21.402] - resignal: FALSE
[17:42:21.402] - force: TRUE
[17:42:21.402] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.402] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:21.403]  - until=2
[17:42:21.403]  - relaying element #2
[17:42:21.403] result() for ClusterFuture ...
[17:42:21.403] - result already collected: FutureResult
[17:42:21.403] result() for ClusterFuture ... done
[17:42:21.403] result() for ClusterFuture ...
[17:42:21.403] - result already collected: FutureResult
[17:42:21.403] result() for ClusterFuture ... done
[17:42:21.403] result() for ClusterFuture ...
[17:42:21.403] - result already collected: FutureResult
[17:42:21.404] result() for ClusterFuture ... done
[17:42:21.404] result() for ClusterFuture ...
[17:42:21.404] - result already collected: FutureResult
[17:42:21.404] result() for ClusterFuture ... done
[17:42:21.404] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.404] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.404] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:21.404]  length: 4 (resolved future 2)
[17:42:21.415] signalConditionsASAP(NULL, pos=4) ...
[17:42:21.415] - nx: 6
[17:42:21.415] - relay: TRUE
[17:42:21.415] - stdout: TRUE
[17:42:21.415] - signal: TRUE
[17:42:21.415] - resignal: FALSE
[17:42:21.415] - force: TRUE
[17:42:21.416] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.416] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.416]  - until=5
[17:42:21.416]  - relaying element #3
[17:42:21.416]  - relaying element #5
[17:42:21.416] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.416] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.416] signalConditionsASAP(NULL, pos=4) ... done
[17:42:21.416]  length: 3 (resolved future 4)
[17:42:21.416] signalConditionsASAP(NULL, pos=5) ...
[17:42:21.417] - nx: 6
[17:42:21.417] - relay: TRUE
[17:42:21.417] - stdout: TRUE
[17:42:21.417] - signal: TRUE
[17:42:21.417] - resignal: FALSE
[17:42:21.417] - force: TRUE
[17:42:21.417] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[17:42:21.417] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.417]  - until=6
[17:42:21.417]  - relaying element #3
[17:42:21.417]  - relaying element #6
[17:42:21.418] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.418] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.418] signalConditionsASAP(NULL, pos=5) ... done
[17:42:21.418]  length: 2 (resolved future 5)
[17:42:21.418] signalConditionsASAP(numeric, pos=6) ...
[17:42:21.418] - nx: 6
[17:42:21.418] - relay: TRUE
[17:42:21.418] - stdout: TRUE
[17:42:21.418] - signal: TRUE
[17:42:21.418] - resignal: FALSE
[17:42:21.418] - force: TRUE
[17:42:21.419] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[17:42:21.419] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.419]  - until=6
[17:42:21.419]  - relaying element #3
[17:42:21.419] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.419] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.419] signalConditionsASAP(NULL, pos=6) ... done
[17:42:21.419]  length: 1 (resolved future 6)
[17:42:21.430] receiveMessageFromWorker() for ClusterFuture ...
[17:42:21.430] - Validating connection of MultisessionFuture
[17:42:21.430] - received message: FutureResult
[17:42:21.430] - Received FutureResult
[17:42:21.430] - Erased future from FutureRegistry
[17:42:21.431] result() for ClusterFuture ...
[17:42:21.431] - result already collected: FutureResult
[17:42:21.431] result() for ClusterFuture ... done
[17:42:21.431] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:21.431] Future #3
[17:42:21.431] result() for ClusterFuture ...
[17:42:21.431] - result already collected: FutureResult
[17:42:21.431] result() for ClusterFuture ... done
[17:42:21.431] result() for ClusterFuture ...
[17:42:21.431] - result already collected: FutureResult
[17:42:21.432] result() for ClusterFuture ... done
[17:42:21.432] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:21.432] - nx: 6
[17:42:21.432] - relay: TRUE
[17:42:21.432] - stdout: TRUE
[17:42:21.432] - signal: TRUE
[17:42:21.432] - resignal: FALSE
[17:42:21.432] - force: TRUE
[17:42:21.432] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[17:42:21.432] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:21.432]  - until=6
[17:42:21.432]  - relaying element #3
[17:42:21.433] result() for ClusterFuture ...
[17:42:21.433] - result already collected: FutureResult
[17:42:21.433] result() for ClusterFuture ... done
[17:42:21.433] result() for ClusterFuture ...
[17:42:21.433] - result already collected: FutureResult
[17:42:21.433] result() for ClusterFuture ... done
[17:42:21.433] result() for ClusterFuture ...
[17:42:21.433] - result already collected: FutureResult
[17:42:21.433] result() for ClusterFuture ... done
[17:42:21.433] result() for ClusterFuture ...
[17:42:21.433] - result already collected: FutureResult
[17:42:21.434] result() for ClusterFuture ... done
[17:42:21.434] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.434] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.434] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:21.434]  length: 0 (resolved future 3)
[17:42:21.434] Relaying remaining futures
[17:42:21.434] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.434] - nx: 6
[17:42:21.434] - relay: TRUE
[17:42:21.434] - stdout: TRUE
[17:42:21.434] - signal: TRUE
[17:42:21.435] - resignal: FALSE
[17:42:21.435] - force: TRUE
[17:42:21.435] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.435] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[17:42:21.435] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:21.435] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:21.435] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.435] resolve() on list ... DONE
[17:42:21.435] result() for ClusterFuture ...
[17:42:21.435] - result already collected: FutureResult
[17:42:21.436] result() for ClusterFuture ... done
[17:42:21.436] result() for ClusterFuture ...
[17:42:21.436] - result already collected: FutureResult
[17:42:21.436] result() for ClusterFuture ... done
[17:42:21.436] result() for ClusterFuture ...
[17:42:21.436] - result already collected: FutureResult
[17:42:21.436] result() for ClusterFuture ... done
[17:42:21.436] result() for ClusterFuture ...
[17:42:21.436] - result already collected: FutureResult
[17:42:21.436] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[17:42:21.440] plan(): Setting new future strategy stack:
[17:42:21.441] List of future strategies:
[17:42:21.441] 1. multicore:
[17:42:21.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.441]    - tweaked: FALSE
[17:42:21.441]    - call: plan(strategy)
[17:42:21.446] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:42:21.446] getGlobalsAndPackages() ...
[17:42:21.446] Searching for globals...
[17:42:21.447] 
[17:42:21.447] Searching for globals ... DONE
[17:42:21.447] - globals: [0] <none>
[17:42:21.447] getGlobalsAndPackages() ... DONE
[17:42:21.448] run() for ‘Future’ ...
[17:42:21.448] - state: ‘created’
[17:42:21.448] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.452]   - Field: ‘label’
[17:42:21.452]   - Field: ‘local’
[17:42:21.452]   - Field: ‘owner’
[17:42:21.452]   - Field: ‘envir’
[17:42:21.453]   - Field: ‘workers’
[17:42:21.453]   - Field: ‘packages’
[17:42:21.453]   - Field: ‘gc’
[17:42:21.453]   - Field: ‘job’
[17:42:21.453]   - Field: ‘conditions’
[17:42:21.453]   - Field: ‘expr’
[17:42:21.453]   - Field: ‘uuid’
[17:42:21.453]   - Field: ‘seed’
[17:42:21.453]   - Field: ‘version’
[17:42:21.453]   - Field: ‘result’
[17:42:21.454]   - Field: ‘asynchronous’
[17:42:21.454]   - Field: ‘calls’
[17:42:21.454]   - Field: ‘globals’
[17:42:21.454]   - Field: ‘stdout’
[17:42:21.454]   - Field: ‘earlySignal’
[17:42:21.454]   - Field: ‘lazy’
[17:42:21.454]   - Field: ‘state’
[17:42:21.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.454] - Launch lazy future ...
[17:42:21.455] Packages needed by the future expression (n = 0): <none>
[17:42:21.455] Packages needed by future strategies (n = 0): <none>
[17:42:21.455] {
[17:42:21.455]     {
[17:42:21.455]         {
[17:42:21.455]             ...future.startTime <- base::Sys.time()
[17:42:21.455]             {
[17:42:21.455]                 {
[17:42:21.455]                   {
[17:42:21.455]                     {
[17:42:21.455]                       base::local({
[17:42:21.455]                         has_future <- base::requireNamespace("future", 
[17:42:21.455]                           quietly = TRUE)
[17:42:21.455]                         if (has_future) {
[17:42:21.455]                           ns <- base::getNamespace("future")
[17:42:21.455]                           version <- ns[[".package"]][["version"]]
[17:42:21.455]                           if (is.null(version)) 
[17:42:21.455]                             version <- utils::packageVersion("future")
[17:42:21.455]                         }
[17:42:21.455]                         else {
[17:42:21.455]                           version <- NULL
[17:42:21.455]                         }
[17:42:21.455]                         if (!has_future || version < "1.8.0") {
[17:42:21.455]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.455]                             "", base::R.version$version.string), 
[17:42:21.455]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.455]                               "release", "version")], collapse = " "), 
[17:42:21.455]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.455]                             info)
[17:42:21.455]                           info <- base::paste(info, collapse = "; ")
[17:42:21.455]                           if (!has_future) {
[17:42:21.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.455]                               info)
[17:42:21.455]                           }
[17:42:21.455]                           else {
[17:42:21.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.455]                               info, version)
[17:42:21.455]                           }
[17:42:21.455]                           base::stop(msg)
[17:42:21.455]                         }
[17:42:21.455]                       })
[17:42:21.455]                     }
[17:42:21.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.455]                     base::options(mc.cores = 1L)
[17:42:21.455]                   }
[17:42:21.455]                   options(future.plan = NULL)
[17:42:21.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.455]                 }
[17:42:21.455]                 ...future.workdir <- getwd()
[17:42:21.455]             }
[17:42:21.455]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.455]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.455]         }
[17:42:21.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.455]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.455]             base::names(...future.oldOptions))
[17:42:21.455]     }
[17:42:21.455]     if (FALSE) {
[17:42:21.455]     }
[17:42:21.455]     else {
[17:42:21.455]         if (TRUE) {
[17:42:21.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.455]                 open = "w")
[17:42:21.455]         }
[17:42:21.455]         else {
[17:42:21.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.455]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.455]         }
[17:42:21.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.455]             base::sink(type = "output", split = FALSE)
[17:42:21.455]             base::close(...future.stdout)
[17:42:21.455]         }, add = TRUE)
[17:42:21.455]     }
[17:42:21.455]     ...future.frame <- base::sys.nframe()
[17:42:21.455]     ...future.conditions <- base::list()
[17:42:21.455]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.455]     if (FALSE) {
[17:42:21.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.455]     }
[17:42:21.455]     ...future.result <- base::tryCatch({
[17:42:21.455]         base::withCallingHandlers({
[17:42:21.455]             ...future.value <- base::withVisible(base::local({
[17:42:21.455]                 withCallingHandlers({
[17:42:21.455]                   2
[17:42:21.455]                 }, immediateCondition = function(cond) {
[17:42:21.455]                   save_rds <- function (object, pathname, ...) 
[17:42:21.455]                   {
[17:42:21.455]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.455]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.455]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.455]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.455]                         fi_tmp[["mtime"]])
[17:42:21.455]                     }
[17:42:21.455]                     tryCatch({
[17:42:21.455]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.455]                     }, error = function(ex) {
[17:42:21.455]                       msg <- conditionMessage(ex)
[17:42:21.455]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.455]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.455]                         fi_tmp[["mtime"]], msg)
[17:42:21.455]                       ex$message <- msg
[17:42:21.455]                       stop(ex)
[17:42:21.455]                     })
[17:42:21.455]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.455]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.455]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.455]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.455]                       fi <- file.info(pathname)
[17:42:21.455]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.455]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.455]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.455]                         fi[["size"]], fi[["mtime"]])
[17:42:21.455]                       stop(msg)
[17:42:21.455]                     }
[17:42:21.455]                     invisible(pathname)
[17:42:21.455]                   }
[17:42:21.455]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.455]                     rootPath = tempdir()) 
[17:42:21.455]                   {
[17:42:21.455]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.455]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.455]                       tmpdir = path, fileext = ".rds")
[17:42:21.455]                     save_rds(obj, file)
[17:42:21.455]                   }
[17:42:21.455]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.455]                   {
[17:42:21.455]                     inherits <- base::inherits
[17:42:21.455]                     invokeRestart <- base::invokeRestart
[17:42:21.455]                     is.null <- base::is.null
[17:42:21.455]                     muffled <- FALSE
[17:42:21.455]                     if (inherits(cond, "message")) {
[17:42:21.455]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.455]                       if (muffled) 
[17:42:21.455]                         invokeRestart("muffleMessage")
[17:42:21.455]                     }
[17:42:21.455]                     else if (inherits(cond, "warning")) {
[17:42:21.455]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.455]                       if (muffled) 
[17:42:21.455]                         invokeRestart("muffleWarning")
[17:42:21.455]                     }
[17:42:21.455]                     else if (inherits(cond, "condition")) {
[17:42:21.455]                       if (!is.null(pattern)) {
[17:42:21.455]                         computeRestarts <- base::computeRestarts
[17:42:21.455]                         grepl <- base::grepl
[17:42:21.455]                         restarts <- computeRestarts(cond)
[17:42:21.455]                         for (restart in restarts) {
[17:42:21.455]                           name <- restart$name
[17:42:21.455]                           if (is.null(name)) 
[17:42:21.455]                             next
[17:42:21.455]                           if (!grepl(pattern, name)) 
[17:42:21.455]                             next
[17:42:21.455]                           invokeRestart(restart)
[17:42:21.455]                           muffled <- TRUE
[17:42:21.455]                           break
[17:42:21.455]                         }
[17:42:21.455]                       }
[17:42:21.455]                     }
[17:42:21.455]                     invisible(muffled)
[17:42:21.455]                   }
[17:42:21.455]                   muffleCondition(cond)
[17:42:21.455]                 })
[17:42:21.455]             }))
[17:42:21.455]             future::FutureResult(value = ...future.value$value, 
[17:42:21.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.455]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.455]                     ...future.globalenv.names))
[17:42:21.455]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.455]         }, condition = base::local({
[17:42:21.455]             c <- base::c
[17:42:21.455]             inherits <- base::inherits
[17:42:21.455]             invokeRestart <- base::invokeRestart
[17:42:21.455]             length <- base::length
[17:42:21.455]             list <- base::list
[17:42:21.455]             seq.int <- base::seq.int
[17:42:21.455]             signalCondition <- base::signalCondition
[17:42:21.455]             sys.calls <- base::sys.calls
[17:42:21.455]             `[[` <- base::`[[`
[17:42:21.455]             `+` <- base::`+`
[17:42:21.455]             `<<-` <- base::`<<-`
[17:42:21.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.455]                   3L)]
[17:42:21.455]             }
[17:42:21.455]             function(cond) {
[17:42:21.455]                 is_error <- inherits(cond, "error")
[17:42:21.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.455]                   NULL)
[17:42:21.455]                 if (is_error) {
[17:42:21.455]                   sessionInformation <- function() {
[17:42:21.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.455]                       search = base::search(), system = base::Sys.info())
[17:42:21.455]                   }
[17:42:21.455]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.455]                     cond$call), session = sessionInformation(), 
[17:42:21.455]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.455]                   signalCondition(cond)
[17:42:21.455]                 }
[17:42:21.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.455]                 "immediateCondition"))) {
[17:42:21.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.455]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.455]                   if (TRUE && !signal) {
[17:42:21.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.455]                     {
[17:42:21.455]                       inherits <- base::inherits
[17:42:21.455]                       invokeRestart <- base::invokeRestart
[17:42:21.455]                       is.null <- base::is.null
[17:42:21.455]                       muffled <- FALSE
[17:42:21.455]                       if (inherits(cond, "message")) {
[17:42:21.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.455]                         if (muffled) 
[17:42:21.455]                           invokeRestart("muffleMessage")
[17:42:21.455]                       }
[17:42:21.455]                       else if (inherits(cond, "warning")) {
[17:42:21.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.455]                         if (muffled) 
[17:42:21.455]                           invokeRestart("muffleWarning")
[17:42:21.455]                       }
[17:42:21.455]                       else if (inherits(cond, "condition")) {
[17:42:21.455]                         if (!is.null(pattern)) {
[17:42:21.455]                           computeRestarts <- base::computeRestarts
[17:42:21.455]                           grepl <- base::grepl
[17:42:21.455]                           restarts <- computeRestarts(cond)
[17:42:21.455]                           for (restart in restarts) {
[17:42:21.455]                             name <- restart$name
[17:42:21.455]                             if (is.null(name)) 
[17:42:21.455]                               next
[17:42:21.455]                             if (!grepl(pattern, name)) 
[17:42:21.455]                               next
[17:42:21.455]                             invokeRestart(restart)
[17:42:21.455]                             muffled <- TRUE
[17:42:21.455]                             break
[17:42:21.455]                           }
[17:42:21.455]                         }
[17:42:21.455]                       }
[17:42:21.455]                       invisible(muffled)
[17:42:21.455]                     }
[17:42:21.455]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.455]                   }
[17:42:21.455]                 }
[17:42:21.455]                 else {
[17:42:21.455]                   if (TRUE) {
[17:42:21.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.455]                     {
[17:42:21.455]                       inherits <- base::inherits
[17:42:21.455]                       invokeRestart <- base::invokeRestart
[17:42:21.455]                       is.null <- base::is.null
[17:42:21.455]                       muffled <- FALSE
[17:42:21.455]                       if (inherits(cond, "message")) {
[17:42:21.455]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.455]                         if (muffled) 
[17:42:21.455]                           invokeRestart("muffleMessage")
[17:42:21.455]                       }
[17:42:21.455]                       else if (inherits(cond, "warning")) {
[17:42:21.455]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.455]                         if (muffled) 
[17:42:21.455]                           invokeRestart("muffleWarning")
[17:42:21.455]                       }
[17:42:21.455]                       else if (inherits(cond, "condition")) {
[17:42:21.455]                         if (!is.null(pattern)) {
[17:42:21.455]                           computeRestarts <- base::computeRestarts
[17:42:21.455]                           grepl <- base::grepl
[17:42:21.455]                           restarts <- computeRestarts(cond)
[17:42:21.455]                           for (restart in restarts) {
[17:42:21.455]                             name <- restart$name
[17:42:21.455]                             if (is.null(name)) 
[17:42:21.455]                               next
[17:42:21.455]                             if (!grepl(pattern, name)) 
[17:42:21.455]                               next
[17:42:21.455]                             invokeRestart(restart)
[17:42:21.455]                             muffled <- TRUE
[17:42:21.455]                             break
[17:42:21.455]                           }
[17:42:21.455]                         }
[17:42:21.455]                       }
[17:42:21.455]                       invisible(muffled)
[17:42:21.455]                     }
[17:42:21.455]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.455]                   }
[17:42:21.455]                 }
[17:42:21.455]             }
[17:42:21.455]         }))
[17:42:21.455]     }, error = function(ex) {
[17:42:21.455]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.455]                 ...future.rng), started = ...future.startTime, 
[17:42:21.455]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.455]             version = "1.8"), class = "FutureResult")
[17:42:21.455]     }, finally = {
[17:42:21.455]         if (!identical(...future.workdir, getwd())) 
[17:42:21.455]             setwd(...future.workdir)
[17:42:21.455]         {
[17:42:21.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.455]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.455]             }
[17:42:21.455]             base::options(...future.oldOptions)
[17:42:21.455]             if (.Platform$OS.type == "windows") {
[17:42:21.455]                 old_names <- names(...future.oldEnvVars)
[17:42:21.455]                 envs <- base::Sys.getenv()
[17:42:21.455]                 names <- names(envs)
[17:42:21.455]                 common <- intersect(names, old_names)
[17:42:21.455]                 added <- setdiff(names, old_names)
[17:42:21.455]                 removed <- setdiff(old_names, names)
[17:42:21.455]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.455]                   envs[common]]
[17:42:21.455]                 NAMES <- toupper(changed)
[17:42:21.455]                 args <- list()
[17:42:21.455]                 for (kk in seq_along(NAMES)) {
[17:42:21.455]                   name <- changed[[kk]]
[17:42:21.455]                   NAME <- NAMES[[kk]]
[17:42:21.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.455]                     next
[17:42:21.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.455]                 }
[17:42:21.455]                 NAMES <- toupper(added)
[17:42:21.455]                 for (kk in seq_along(NAMES)) {
[17:42:21.455]                   name <- added[[kk]]
[17:42:21.455]                   NAME <- NAMES[[kk]]
[17:42:21.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.455]                     next
[17:42:21.455]                   args[[name]] <- ""
[17:42:21.455]                 }
[17:42:21.455]                 NAMES <- toupper(removed)
[17:42:21.455]                 for (kk in seq_along(NAMES)) {
[17:42:21.455]                   name <- removed[[kk]]
[17:42:21.455]                   NAME <- NAMES[[kk]]
[17:42:21.455]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.455]                     next
[17:42:21.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.455]                 }
[17:42:21.455]                 if (length(args) > 0) 
[17:42:21.455]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.455]             }
[17:42:21.455]             else {
[17:42:21.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.455]             }
[17:42:21.455]             {
[17:42:21.455]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.455]                   0L) {
[17:42:21.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.455]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.455]                   base::options(opts)
[17:42:21.455]                 }
[17:42:21.455]                 {
[17:42:21.455]                   {
[17:42:21.455]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.455]                     NULL
[17:42:21.455]                   }
[17:42:21.455]                   options(future.plan = NULL)
[17:42:21.455]                   if (is.na(NA_character_)) 
[17:42:21.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.455]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.455]                     envir = parent.frame()) 
[17:42:21.455]                   {
[17:42:21.455]                     default_workers <- missing(workers)
[17:42:21.455]                     if (is.function(workers)) 
[17:42:21.455]                       workers <- workers()
[17:42:21.455]                     workers <- structure(as.integer(workers), 
[17:42:21.455]                       class = class(workers))
[17:42:21.455]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.455]                       1L)
[17:42:21.455]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.455]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.455]                       if (default_workers) 
[17:42:21.455]                         supportsMulticore(warn = TRUE)
[17:42:21.455]                       return(sequential(..., envir = envir))
[17:42:21.455]                     }
[17:42:21.455]                     oopts <- options(mc.cores = workers)
[17:42:21.455]                     on.exit(options(oopts))
[17:42:21.455]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.455]                       envir = envir)
[17:42:21.455]                     if (!future$lazy) 
[17:42:21.455]                       future <- run(future)
[17:42:21.455]                     invisible(future)
[17:42:21.455]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.455]                 }
[17:42:21.455]             }
[17:42:21.455]         }
[17:42:21.455]     })
[17:42:21.455]     if (TRUE) {
[17:42:21.455]         base::sink(type = "output", split = FALSE)
[17:42:21.455]         if (TRUE) {
[17:42:21.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.455]         }
[17:42:21.455]         else {
[17:42:21.455]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.455]         }
[17:42:21.455]         base::close(...future.stdout)
[17:42:21.455]         ...future.stdout <- NULL
[17:42:21.455]     }
[17:42:21.455]     ...future.result$conditions <- ...future.conditions
[17:42:21.455]     ...future.result$finished <- base::Sys.time()
[17:42:21.455]     ...future.result
[17:42:21.455] }
[17:42:21.457] requestCore(): workers = 2
[17:42:21.460] MulticoreFuture started
[17:42:21.460] - Launch lazy future ... done
[17:42:21.460] run() for ‘MulticoreFuture’ ... done
[17:42:21.461] getGlobalsAndPackages() ...
[17:42:21.461] Searching for globals...
[17:42:21.461] plan(): Setting new future strategy stack:
[17:42:21.461] 
[17:42:21.461] List of future strategies:
[17:42:21.461] 1. sequential:
[17:42:21.461]    - args: function (..., envir = parent.frame())
[17:42:21.461]    - tweaked: FALSE
[17:42:21.461]    - call: NULL
[17:42:21.462] Searching for globals ... DONE
[17:42:21.462] - globals: [0] <none>
[17:42:21.462] plan(): nbrOfWorkers() = 1
[17:42:21.462] getGlobalsAndPackages() ... DONE
[17:42:21.462] run() for ‘Future’ ...
[17:42:21.463] - state: ‘created’
[17:42:21.463] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.464] plan(): Setting new future strategy stack:
[17:42:21.464] List of future strategies:
[17:42:21.464] 1. multicore:
[17:42:21.464]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.464]    - tweaked: FALSE
[17:42:21.464]    - call: plan(strategy)
[17:42:21.468] plan(): nbrOfWorkers() = 2
[17:42:21.468] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.468]   - Field: ‘label’
[17:42:21.468]   - Field: ‘local’
[17:42:21.469]   - Field: ‘owner’
[17:42:21.469]   - Field: ‘envir’
[17:42:21.469]   - Field: ‘workers’
[17:42:21.469]   - Field: ‘packages’
[17:42:21.469]   - Field: ‘gc’
[17:42:21.469]   - Field: ‘job’
[17:42:21.469]   - Field: ‘conditions’
[17:42:21.469]   - Field: ‘expr’
[17:42:21.470]   - Field: ‘uuid’
[17:42:21.470]   - Field: ‘seed’
[17:42:21.470]   - Field: ‘version’
[17:42:21.470]   - Field: ‘result’
[17:42:21.470]   - Field: ‘asynchronous’
[17:42:21.470]   - Field: ‘calls’
[17:42:21.470]   - Field: ‘globals’
[17:42:21.471]   - Field: ‘stdout’
[17:42:21.471]   - Field: ‘earlySignal’
[17:42:21.471]   - Field: ‘lazy’
[17:42:21.471]   - Field: ‘state’
[17:42:21.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.471] - Launch lazy future ...
[17:42:21.472] Packages needed by the future expression (n = 0): <none>
[17:42:21.472] Packages needed by future strategies (n = 0): <none>
[17:42:21.473] {
[17:42:21.473]     {
[17:42:21.473]         {
[17:42:21.473]             ...future.startTime <- base::Sys.time()
[17:42:21.473]             {
[17:42:21.473]                 {
[17:42:21.473]                   {
[17:42:21.473]                     {
[17:42:21.473]                       base::local({
[17:42:21.473]                         has_future <- base::requireNamespace("future", 
[17:42:21.473]                           quietly = TRUE)
[17:42:21.473]                         if (has_future) {
[17:42:21.473]                           ns <- base::getNamespace("future")
[17:42:21.473]                           version <- ns[[".package"]][["version"]]
[17:42:21.473]                           if (is.null(version)) 
[17:42:21.473]                             version <- utils::packageVersion("future")
[17:42:21.473]                         }
[17:42:21.473]                         else {
[17:42:21.473]                           version <- NULL
[17:42:21.473]                         }
[17:42:21.473]                         if (!has_future || version < "1.8.0") {
[17:42:21.473]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.473]                             "", base::R.version$version.string), 
[17:42:21.473]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.473]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.473]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.473]                               "release", "version")], collapse = " "), 
[17:42:21.473]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.473]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.473]                             info)
[17:42:21.473]                           info <- base::paste(info, collapse = "; ")
[17:42:21.473]                           if (!has_future) {
[17:42:21.473]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.473]                               info)
[17:42:21.473]                           }
[17:42:21.473]                           else {
[17:42:21.473]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.473]                               info, version)
[17:42:21.473]                           }
[17:42:21.473]                           base::stop(msg)
[17:42:21.473]                         }
[17:42:21.473]                       })
[17:42:21.473]                     }
[17:42:21.473]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.473]                     base::options(mc.cores = 1L)
[17:42:21.473]                   }
[17:42:21.473]                   options(future.plan = NULL)
[17:42:21.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.473]                 }
[17:42:21.473]                 ...future.workdir <- getwd()
[17:42:21.473]             }
[17:42:21.473]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.473]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.473]         }
[17:42:21.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.473]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.473]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.473]             base::names(...future.oldOptions))
[17:42:21.473]     }
[17:42:21.473]     if (FALSE) {
[17:42:21.473]     }
[17:42:21.473]     else {
[17:42:21.473]         if (TRUE) {
[17:42:21.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.473]                 open = "w")
[17:42:21.473]         }
[17:42:21.473]         else {
[17:42:21.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.473]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.473]         }
[17:42:21.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.473]             base::sink(type = "output", split = FALSE)
[17:42:21.473]             base::close(...future.stdout)
[17:42:21.473]         }, add = TRUE)
[17:42:21.473]     }
[17:42:21.473]     ...future.frame <- base::sys.nframe()
[17:42:21.473]     ...future.conditions <- base::list()
[17:42:21.473]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.473]     if (FALSE) {
[17:42:21.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.473]     }
[17:42:21.473]     ...future.result <- base::tryCatch({
[17:42:21.473]         base::withCallingHandlers({
[17:42:21.473]             ...future.value <- base::withVisible(base::local({
[17:42:21.473]                 withCallingHandlers({
[17:42:21.473]                   NULL
[17:42:21.473]                 }, immediateCondition = function(cond) {
[17:42:21.473]                   save_rds <- function (object, pathname, ...) 
[17:42:21.473]                   {
[17:42:21.473]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.473]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.473]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.473]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.473]                         fi_tmp[["mtime"]])
[17:42:21.473]                     }
[17:42:21.473]                     tryCatch({
[17:42:21.473]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.473]                     }, error = function(ex) {
[17:42:21.473]                       msg <- conditionMessage(ex)
[17:42:21.473]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.473]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.473]                         fi_tmp[["mtime"]], msg)
[17:42:21.473]                       ex$message <- msg
[17:42:21.473]                       stop(ex)
[17:42:21.473]                     })
[17:42:21.473]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.473]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.473]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.473]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.473]                       fi <- file.info(pathname)
[17:42:21.473]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.473]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.473]                         fi[["size"]], fi[["mtime"]])
[17:42:21.473]                       stop(msg)
[17:42:21.473]                     }
[17:42:21.473]                     invisible(pathname)
[17:42:21.473]                   }
[17:42:21.473]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.473]                     rootPath = tempdir()) 
[17:42:21.473]                   {
[17:42:21.473]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.473]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.473]                       tmpdir = path, fileext = ".rds")
[17:42:21.473]                     save_rds(obj, file)
[17:42:21.473]                   }
[17:42:21.473]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.473]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.473]                   {
[17:42:21.473]                     inherits <- base::inherits
[17:42:21.473]                     invokeRestart <- base::invokeRestart
[17:42:21.473]                     is.null <- base::is.null
[17:42:21.473]                     muffled <- FALSE
[17:42:21.473]                     if (inherits(cond, "message")) {
[17:42:21.473]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.473]                       if (muffled) 
[17:42:21.473]                         invokeRestart("muffleMessage")
[17:42:21.473]                     }
[17:42:21.473]                     else if (inherits(cond, "warning")) {
[17:42:21.473]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.473]                       if (muffled) 
[17:42:21.473]                         invokeRestart("muffleWarning")
[17:42:21.473]                     }
[17:42:21.473]                     else if (inherits(cond, "condition")) {
[17:42:21.473]                       if (!is.null(pattern)) {
[17:42:21.473]                         computeRestarts <- base::computeRestarts
[17:42:21.473]                         grepl <- base::grepl
[17:42:21.473]                         restarts <- computeRestarts(cond)
[17:42:21.473]                         for (restart in restarts) {
[17:42:21.473]                           name <- restart$name
[17:42:21.473]                           if (is.null(name)) 
[17:42:21.473]                             next
[17:42:21.473]                           if (!grepl(pattern, name)) 
[17:42:21.473]                             next
[17:42:21.473]                           invokeRestart(restart)
[17:42:21.473]                           muffled <- TRUE
[17:42:21.473]                           break
[17:42:21.473]                         }
[17:42:21.473]                       }
[17:42:21.473]                     }
[17:42:21.473]                     invisible(muffled)
[17:42:21.473]                   }
[17:42:21.473]                   muffleCondition(cond)
[17:42:21.473]                 })
[17:42:21.473]             }))
[17:42:21.473]             future::FutureResult(value = ...future.value$value, 
[17:42:21.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.473]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.473]                     ...future.globalenv.names))
[17:42:21.473]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.473]         }, condition = base::local({
[17:42:21.473]             c <- base::c
[17:42:21.473]             inherits <- base::inherits
[17:42:21.473]             invokeRestart <- base::invokeRestart
[17:42:21.473]             length <- base::length
[17:42:21.473]             list <- base::list
[17:42:21.473]             seq.int <- base::seq.int
[17:42:21.473]             signalCondition <- base::signalCondition
[17:42:21.473]             sys.calls <- base::sys.calls
[17:42:21.473]             `[[` <- base::`[[`
[17:42:21.473]             `+` <- base::`+`
[17:42:21.473]             `<<-` <- base::`<<-`
[17:42:21.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.473]                   3L)]
[17:42:21.473]             }
[17:42:21.473]             function(cond) {
[17:42:21.473]                 is_error <- inherits(cond, "error")
[17:42:21.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.473]                   NULL)
[17:42:21.473]                 if (is_error) {
[17:42:21.473]                   sessionInformation <- function() {
[17:42:21.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.473]                       search = base::search(), system = base::Sys.info())
[17:42:21.473]                   }
[17:42:21.473]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.473]                     cond$call), session = sessionInformation(), 
[17:42:21.473]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.473]                   signalCondition(cond)
[17:42:21.473]                 }
[17:42:21.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.473]                 "immediateCondition"))) {
[17:42:21.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.473]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.473]                   if (TRUE && !signal) {
[17:42:21.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.473]                     {
[17:42:21.473]                       inherits <- base::inherits
[17:42:21.473]                       invokeRestart <- base::invokeRestart
[17:42:21.473]                       is.null <- base::is.null
[17:42:21.473]                       muffled <- FALSE
[17:42:21.473]                       if (inherits(cond, "message")) {
[17:42:21.473]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.473]                         if (muffled) 
[17:42:21.473]                           invokeRestart("muffleMessage")
[17:42:21.473]                       }
[17:42:21.473]                       else if (inherits(cond, "warning")) {
[17:42:21.473]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.473]                         if (muffled) 
[17:42:21.473]                           invokeRestart("muffleWarning")
[17:42:21.473]                       }
[17:42:21.473]                       else if (inherits(cond, "condition")) {
[17:42:21.473]                         if (!is.null(pattern)) {
[17:42:21.473]                           computeRestarts <- base::computeRestarts
[17:42:21.473]                           grepl <- base::grepl
[17:42:21.473]                           restarts <- computeRestarts(cond)
[17:42:21.473]                           for (restart in restarts) {
[17:42:21.473]                             name <- restart$name
[17:42:21.473]                             if (is.null(name)) 
[17:42:21.473]                               next
[17:42:21.473]                             if (!grepl(pattern, name)) 
[17:42:21.473]                               next
[17:42:21.473]                             invokeRestart(restart)
[17:42:21.473]                             muffled <- TRUE
[17:42:21.473]                             break
[17:42:21.473]                           }
[17:42:21.473]                         }
[17:42:21.473]                       }
[17:42:21.473]                       invisible(muffled)
[17:42:21.473]                     }
[17:42:21.473]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.473]                   }
[17:42:21.473]                 }
[17:42:21.473]                 else {
[17:42:21.473]                   if (TRUE) {
[17:42:21.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.473]                     {
[17:42:21.473]                       inherits <- base::inherits
[17:42:21.473]                       invokeRestart <- base::invokeRestart
[17:42:21.473]                       is.null <- base::is.null
[17:42:21.473]                       muffled <- FALSE
[17:42:21.473]                       if (inherits(cond, "message")) {
[17:42:21.473]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.473]                         if (muffled) 
[17:42:21.473]                           invokeRestart("muffleMessage")
[17:42:21.473]                       }
[17:42:21.473]                       else if (inherits(cond, "warning")) {
[17:42:21.473]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.473]                         if (muffled) 
[17:42:21.473]                           invokeRestart("muffleWarning")
[17:42:21.473]                       }
[17:42:21.473]                       else if (inherits(cond, "condition")) {
[17:42:21.473]                         if (!is.null(pattern)) {
[17:42:21.473]                           computeRestarts <- base::computeRestarts
[17:42:21.473]                           grepl <- base::grepl
[17:42:21.473]                           restarts <- computeRestarts(cond)
[17:42:21.473]                           for (restart in restarts) {
[17:42:21.473]                             name <- restart$name
[17:42:21.473]                             if (is.null(name)) 
[17:42:21.473]                               next
[17:42:21.473]                             if (!grepl(pattern, name)) 
[17:42:21.473]                               next
[17:42:21.473]                             invokeRestart(restart)
[17:42:21.473]                             muffled <- TRUE
[17:42:21.473]                             break
[17:42:21.473]                           }
[17:42:21.473]                         }
[17:42:21.473]                       }
[17:42:21.473]                       invisible(muffled)
[17:42:21.473]                     }
[17:42:21.473]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.473]                   }
[17:42:21.473]                 }
[17:42:21.473]             }
[17:42:21.473]         }))
[17:42:21.473]     }, error = function(ex) {
[17:42:21.473]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.473]                 ...future.rng), started = ...future.startTime, 
[17:42:21.473]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.473]             version = "1.8"), class = "FutureResult")
[17:42:21.473]     }, finally = {
[17:42:21.473]         if (!identical(...future.workdir, getwd())) 
[17:42:21.473]             setwd(...future.workdir)
[17:42:21.473]         {
[17:42:21.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.473]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.473]             }
[17:42:21.473]             base::options(...future.oldOptions)
[17:42:21.473]             if (.Platform$OS.type == "windows") {
[17:42:21.473]                 old_names <- names(...future.oldEnvVars)
[17:42:21.473]                 envs <- base::Sys.getenv()
[17:42:21.473]                 names <- names(envs)
[17:42:21.473]                 common <- intersect(names, old_names)
[17:42:21.473]                 added <- setdiff(names, old_names)
[17:42:21.473]                 removed <- setdiff(old_names, names)
[17:42:21.473]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.473]                   envs[common]]
[17:42:21.473]                 NAMES <- toupper(changed)
[17:42:21.473]                 args <- list()
[17:42:21.473]                 for (kk in seq_along(NAMES)) {
[17:42:21.473]                   name <- changed[[kk]]
[17:42:21.473]                   NAME <- NAMES[[kk]]
[17:42:21.473]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.473]                     next
[17:42:21.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.473]                 }
[17:42:21.473]                 NAMES <- toupper(added)
[17:42:21.473]                 for (kk in seq_along(NAMES)) {
[17:42:21.473]                   name <- added[[kk]]
[17:42:21.473]                   NAME <- NAMES[[kk]]
[17:42:21.473]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.473]                     next
[17:42:21.473]                   args[[name]] <- ""
[17:42:21.473]                 }
[17:42:21.473]                 NAMES <- toupper(removed)
[17:42:21.473]                 for (kk in seq_along(NAMES)) {
[17:42:21.473]                   name <- removed[[kk]]
[17:42:21.473]                   NAME <- NAMES[[kk]]
[17:42:21.473]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.473]                     next
[17:42:21.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.473]                 }
[17:42:21.473]                 if (length(args) > 0) 
[17:42:21.473]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.473]             }
[17:42:21.473]             else {
[17:42:21.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.473]             }
[17:42:21.473]             {
[17:42:21.473]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.473]                   0L) {
[17:42:21.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.473]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.473]                   base::options(opts)
[17:42:21.473]                 }
[17:42:21.473]                 {
[17:42:21.473]                   {
[17:42:21.473]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.473]                     NULL
[17:42:21.473]                   }
[17:42:21.473]                   options(future.plan = NULL)
[17:42:21.473]                   if (is.na(NA_character_)) 
[17:42:21.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.473]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.473]                     envir = parent.frame()) 
[17:42:21.473]                   {
[17:42:21.473]                     default_workers <- missing(workers)
[17:42:21.473]                     if (is.function(workers)) 
[17:42:21.473]                       workers <- workers()
[17:42:21.473]                     workers <- structure(as.integer(workers), 
[17:42:21.473]                       class = class(workers))
[17:42:21.473]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.473]                       1L)
[17:42:21.473]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.473]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.473]                       if (default_workers) 
[17:42:21.473]                         supportsMulticore(warn = TRUE)
[17:42:21.473]                       return(sequential(..., envir = envir))
[17:42:21.473]                     }
[17:42:21.473]                     oopts <- options(mc.cores = workers)
[17:42:21.473]                     on.exit(options(oopts))
[17:42:21.473]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.473]                       envir = envir)
[17:42:21.473]                     if (!future$lazy) 
[17:42:21.473]                       future <- run(future)
[17:42:21.473]                     invisible(future)
[17:42:21.473]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.473]                 }
[17:42:21.473]             }
[17:42:21.473]         }
[17:42:21.473]     })
[17:42:21.473]     if (TRUE) {
[17:42:21.473]         base::sink(type = "output", split = FALSE)
[17:42:21.473]         if (TRUE) {
[17:42:21.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.473]         }
[17:42:21.473]         else {
[17:42:21.473]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.473]         }
[17:42:21.473]         base::close(...future.stdout)
[17:42:21.473]         ...future.stdout <- NULL
[17:42:21.473]     }
[17:42:21.473]     ...future.result$conditions <- ...future.conditions
[17:42:21.473]     ...future.result$finished <- base::Sys.time()
[17:42:21.473]     ...future.result
[17:42:21.473] }
[17:42:21.476] requestCore(): workers = 2
[17:42:21.479] MulticoreFuture started
[17:42:21.479] - Launch lazy future ... done
[17:42:21.479] run() for ‘MulticoreFuture’ ... done
[17:42:21.480] plan(): Setting new future strategy stack:
[17:42:21.480] getGlobalsAndPackages() ...
[17:42:21.480] Searching for globals...
[17:42:21.480] List of future strategies:
[17:42:21.480] 1. sequential:
[17:42:21.480]    - args: function (..., envir = parent.frame())
[17:42:21.480]    - tweaked: FALSE
[17:42:21.480]    - call: NULL
[17:42:21.481] plan(): nbrOfWorkers() = 1
[17:42:21.481] - globals found: [1] ‘{’
[17:42:21.482] Searching for globals ... DONE
[17:42:21.482] Resolving globals: FALSE
[17:42:21.482] 
[17:42:21.482] 
[17:42:21.483] getGlobalsAndPackages() ... DONE
[17:42:21.483] plan(): Setting new future strategy stack:
[17:42:21.483] run() for ‘Future’ ...
[17:42:21.483] List of future strategies:
[17:42:21.483] 1. multicore:
[17:42:21.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.483]    - tweaked: FALSE
[17:42:21.483]    - call: plan(strategy)
[17:42:21.483] - state: ‘created’
[17:42:21.483] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.488] plan(): nbrOfWorkers() = 2
[17:42:21.488] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.488] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.488]   - Field: ‘label’
[17:42:21.489]   - Field: ‘local’
[17:42:21.489]   - Field: ‘owner’
[17:42:21.489]   - Field: ‘envir’
[17:42:21.489]   - Field: ‘workers’
[17:42:21.489]   - Field: ‘packages’
[17:42:21.489]   - Field: ‘gc’
[17:42:21.489]   - Field: ‘job’
[17:42:21.490]   - Field: ‘conditions’
[17:42:21.490]   - Field: ‘expr’
[17:42:21.490]   - Field: ‘uuid’
[17:42:21.490]   - Field: ‘seed’
[17:42:21.490]   - Field: ‘version’
[17:42:21.490]   - Field: ‘result’
[17:42:21.490]   - Field: ‘asynchronous’
[17:42:21.491]   - Field: ‘calls’
[17:42:21.491]   - Field: ‘globals’
[17:42:21.491]   - Field: ‘stdout’
[17:42:21.491]   - Field: ‘earlySignal’
[17:42:21.491]   - Field: ‘lazy’
[17:42:21.491]   - Field: ‘state’
[17:42:21.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.491] - Launch lazy future ...
[17:42:21.492] Packages needed by the future expression (n = 0): <none>
[17:42:21.492] Packages needed by future strategies (n = 0): <none>
[17:42:21.493] {
[17:42:21.493]     {
[17:42:21.493]         {
[17:42:21.493]             ...future.startTime <- base::Sys.time()
[17:42:21.493]             {
[17:42:21.493]                 {
[17:42:21.493]                   {
[17:42:21.493]                     {
[17:42:21.493]                       base::local({
[17:42:21.493]                         has_future <- base::requireNamespace("future", 
[17:42:21.493]                           quietly = TRUE)
[17:42:21.493]                         if (has_future) {
[17:42:21.493]                           ns <- base::getNamespace("future")
[17:42:21.493]                           version <- ns[[".package"]][["version"]]
[17:42:21.493]                           if (is.null(version)) 
[17:42:21.493]                             version <- utils::packageVersion("future")
[17:42:21.493]                         }
[17:42:21.493]                         else {
[17:42:21.493]                           version <- NULL
[17:42:21.493]                         }
[17:42:21.493]                         if (!has_future || version < "1.8.0") {
[17:42:21.493]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.493]                             "", base::R.version$version.string), 
[17:42:21.493]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.493]                               "release", "version")], collapse = " "), 
[17:42:21.493]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.493]                             info)
[17:42:21.493]                           info <- base::paste(info, collapse = "; ")
[17:42:21.493]                           if (!has_future) {
[17:42:21.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.493]                               info)
[17:42:21.493]                           }
[17:42:21.493]                           else {
[17:42:21.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.493]                               info, version)
[17:42:21.493]                           }
[17:42:21.493]                           base::stop(msg)
[17:42:21.493]                         }
[17:42:21.493]                       })
[17:42:21.493]                     }
[17:42:21.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.493]                     base::options(mc.cores = 1L)
[17:42:21.493]                   }
[17:42:21.493]                   options(future.plan = NULL)
[17:42:21.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.493]                 }
[17:42:21.493]                 ...future.workdir <- getwd()
[17:42:21.493]             }
[17:42:21.493]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.493]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.493]         }
[17:42:21.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.493]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.493]             base::names(...future.oldOptions))
[17:42:21.493]     }
[17:42:21.493]     if (FALSE) {
[17:42:21.493]     }
[17:42:21.493]     else {
[17:42:21.493]         if (TRUE) {
[17:42:21.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.493]                 open = "w")
[17:42:21.493]         }
[17:42:21.493]         else {
[17:42:21.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.493]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.493]         }
[17:42:21.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.493]             base::sink(type = "output", split = FALSE)
[17:42:21.493]             base::close(...future.stdout)
[17:42:21.493]         }, add = TRUE)
[17:42:21.493]     }
[17:42:21.493]     ...future.frame <- base::sys.nframe()
[17:42:21.493]     ...future.conditions <- base::list()
[17:42:21.493]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.493]     if (FALSE) {
[17:42:21.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.493]     }
[17:42:21.493]     ...future.result <- base::tryCatch({
[17:42:21.493]         base::withCallingHandlers({
[17:42:21.493]             ...future.value <- base::withVisible(base::local({
[17:42:21.493]                 withCallingHandlers({
[17:42:21.493]                   {
[17:42:21.493]                     4
[17:42:21.493]                   }
[17:42:21.493]                 }, immediateCondition = function(cond) {
[17:42:21.493]                   save_rds <- function (object, pathname, ...) 
[17:42:21.493]                   {
[17:42:21.493]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.493]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.493]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.493]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.493]                         fi_tmp[["mtime"]])
[17:42:21.493]                     }
[17:42:21.493]                     tryCatch({
[17:42:21.493]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.493]                     }, error = function(ex) {
[17:42:21.493]                       msg <- conditionMessage(ex)
[17:42:21.493]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.493]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.493]                         fi_tmp[["mtime"]], msg)
[17:42:21.493]                       ex$message <- msg
[17:42:21.493]                       stop(ex)
[17:42:21.493]                     })
[17:42:21.493]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.493]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.493]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.493]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.493]                       fi <- file.info(pathname)
[17:42:21.493]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.493]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.493]                         fi[["size"]], fi[["mtime"]])
[17:42:21.493]                       stop(msg)
[17:42:21.493]                     }
[17:42:21.493]                     invisible(pathname)
[17:42:21.493]                   }
[17:42:21.493]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.493]                     rootPath = tempdir()) 
[17:42:21.493]                   {
[17:42:21.493]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.493]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.493]                       tmpdir = path, fileext = ".rds")
[17:42:21.493]                     save_rds(obj, file)
[17:42:21.493]                   }
[17:42:21.493]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.493]                   {
[17:42:21.493]                     inherits <- base::inherits
[17:42:21.493]                     invokeRestart <- base::invokeRestart
[17:42:21.493]                     is.null <- base::is.null
[17:42:21.493]                     muffled <- FALSE
[17:42:21.493]                     if (inherits(cond, "message")) {
[17:42:21.493]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.493]                       if (muffled) 
[17:42:21.493]                         invokeRestart("muffleMessage")
[17:42:21.493]                     }
[17:42:21.493]                     else if (inherits(cond, "warning")) {
[17:42:21.493]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.493]                       if (muffled) 
[17:42:21.493]                         invokeRestart("muffleWarning")
[17:42:21.493]                     }
[17:42:21.493]                     else if (inherits(cond, "condition")) {
[17:42:21.493]                       if (!is.null(pattern)) {
[17:42:21.493]                         computeRestarts <- base::computeRestarts
[17:42:21.493]                         grepl <- base::grepl
[17:42:21.493]                         restarts <- computeRestarts(cond)
[17:42:21.493]                         for (restart in restarts) {
[17:42:21.493]                           name <- restart$name
[17:42:21.493]                           if (is.null(name)) 
[17:42:21.493]                             next
[17:42:21.493]                           if (!grepl(pattern, name)) 
[17:42:21.493]                             next
[17:42:21.493]                           invokeRestart(restart)
[17:42:21.493]                           muffled <- TRUE
[17:42:21.493]                           break
[17:42:21.493]                         }
[17:42:21.493]                       }
[17:42:21.493]                     }
[17:42:21.493]                     invisible(muffled)
[17:42:21.493]                   }
[17:42:21.493]                   muffleCondition(cond)
[17:42:21.493]                 })
[17:42:21.493]             }))
[17:42:21.493]             future::FutureResult(value = ...future.value$value, 
[17:42:21.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.493]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.493]                     ...future.globalenv.names))
[17:42:21.493]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.493]         }, condition = base::local({
[17:42:21.493]             c <- base::c
[17:42:21.493]             inherits <- base::inherits
[17:42:21.493]             invokeRestart <- base::invokeRestart
[17:42:21.493]             length <- base::length
[17:42:21.493]             list <- base::list
[17:42:21.493]             seq.int <- base::seq.int
[17:42:21.493]             signalCondition <- base::signalCondition
[17:42:21.493]             sys.calls <- base::sys.calls
[17:42:21.493]             `[[` <- base::`[[`
[17:42:21.493]             `+` <- base::`+`
[17:42:21.493]             `<<-` <- base::`<<-`
[17:42:21.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.493]                   3L)]
[17:42:21.493]             }
[17:42:21.493]             function(cond) {
[17:42:21.493]                 is_error <- inherits(cond, "error")
[17:42:21.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.493]                   NULL)
[17:42:21.493]                 if (is_error) {
[17:42:21.493]                   sessionInformation <- function() {
[17:42:21.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.493]                       search = base::search(), system = base::Sys.info())
[17:42:21.493]                   }
[17:42:21.493]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.493]                     cond$call), session = sessionInformation(), 
[17:42:21.493]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.493]                   signalCondition(cond)
[17:42:21.493]                 }
[17:42:21.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.493]                 "immediateCondition"))) {
[17:42:21.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.493]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.493]                   if (TRUE && !signal) {
[17:42:21.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.493]                     {
[17:42:21.493]                       inherits <- base::inherits
[17:42:21.493]                       invokeRestart <- base::invokeRestart
[17:42:21.493]                       is.null <- base::is.null
[17:42:21.493]                       muffled <- FALSE
[17:42:21.493]                       if (inherits(cond, "message")) {
[17:42:21.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.493]                         if (muffled) 
[17:42:21.493]                           invokeRestart("muffleMessage")
[17:42:21.493]                       }
[17:42:21.493]                       else if (inherits(cond, "warning")) {
[17:42:21.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.493]                         if (muffled) 
[17:42:21.493]                           invokeRestart("muffleWarning")
[17:42:21.493]                       }
[17:42:21.493]                       else if (inherits(cond, "condition")) {
[17:42:21.493]                         if (!is.null(pattern)) {
[17:42:21.493]                           computeRestarts <- base::computeRestarts
[17:42:21.493]                           grepl <- base::grepl
[17:42:21.493]                           restarts <- computeRestarts(cond)
[17:42:21.493]                           for (restart in restarts) {
[17:42:21.493]                             name <- restart$name
[17:42:21.493]                             if (is.null(name)) 
[17:42:21.493]                               next
[17:42:21.493]                             if (!grepl(pattern, name)) 
[17:42:21.493]                               next
[17:42:21.493]                             invokeRestart(restart)
[17:42:21.493]                             muffled <- TRUE
[17:42:21.493]                             break
[17:42:21.493]                           }
[17:42:21.493]                         }
[17:42:21.493]                       }
[17:42:21.493]                       invisible(muffled)
[17:42:21.493]                     }
[17:42:21.493]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.493]                   }
[17:42:21.493]                 }
[17:42:21.493]                 else {
[17:42:21.493]                   if (TRUE) {
[17:42:21.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.493]                     {
[17:42:21.493]                       inherits <- base::inherits
[17:42:21.493]                       invokeRestart <- base::invokeRestart
[17:42:21.493]                       is.null <- base::is.null
[17:42:21.493]                       muffled <- FALSE
[17:42:21.493]                       if (inherits(cond, "message")) {
[17:42:21.493]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.493]                         if (muffled) 
[17:42:21.493]                           invokeRestart("muffleMessage")
[17:42:21.493]                       }
[17:42:21.493]                       else if (inherits(cond, "warning")) {
[17:42:21.493]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.493]                         if (muffled) 
[17:42:21.493]                           invokeRestart("muffleWarning")
[17:42:21.493]                       }
[17:42:21.493]                       else if (inherits(cond, "condition")) {
[17:42:21.493]                         if (!is.null(pattern)) {
[17:42:21.493]                           computeRestarts <- base::computeRestarts
[17:42:21.493]                           grepl <- base::grepl
[17:42:21.493]                           restarts <- computeRestarts(cond)
[17:42:21.493]                           for (restart in restarts) {
[17:42:21.493]                             name <- restart$name
[17:42:21.493]                             if (is.null(name)) 
[17:42:21.493]                               next
[17:42:21.493]                             if (!grepl(pattern, name)) 
[17:42:21.493]                               next
[17:42:21.493]                             invokeRestart(restart)
[17:42:21.493]                             muffled <- TRUE
[17:42:21.493]                             break
[17:42:21.493]                           }
[17:42:21.493]                         }
[17:42:21.493]                       }
[17:42:21.493]                       invisible(muffled)
[17:42:21.493]                     }
[17:42:21.493]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.493]                   }
[17:42:21.493]                 }
[17:42:21.493]             }
[17:42:21.493]         }))
[17:42:21.493]     }, error = function(ex) {
[17:42:21.493]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.493]                 ...future.rng), started = ...future.startTime, 
[17:42:21.493]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.493]             version = "1.8"), class = "FutureResult")
[17:42:21.493]     }, finally = {
[17:42:21.493]         if (!identical(...future.workdir, getwd())) 
[17:42:21.493]             setwd(...future.workdir)
[17:42:21.493]         {
[17:42:21.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.493]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.493]             }
[17:42:21.493]             base::options(...future.oldOptions)
[17:42:21.493]             if (.Platform$OS.type == "windows") {
[17:42:21.493]                 old_names <- names(...future.oldEnvVars)
[17:42:21.493]                 envs <- base::Sys.getenv()
[17:42:21.493]                 names <- names(envs)
[17:42:21.493]                 common <- intersect(names, old_names)
[17:42:21.493]                 added <- setdiff(names, old_names)
[17:42:21.493]                 removed <- setdiff(old_names, names)
[17:42:21.493]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.493]                   envs[common]]
[17:42:21.493]                 NAMES <- toupper(changed)
[17:42:21.493]                 args <- list()
[17:42:21.493]                 for (kk in seq_along(NAMES)) {
[17:42:21.493]                   name <- changed[[kk]]
[17:42:21.493]                   NAME <- NAMES[[kk]]
[17:42:21.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.493]                     next
[17:42:21.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.493]                 }
[17:42:21.493]                 NAMES <- toupper(added)
[17:42:21.493]                 for (kk in seq_along(NAMES)) {
[17:42:21.493]                   name <- added[[kk]]
[17:42:21.493]                   NAME <- NAMES[[kk]]
[17:42:21.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.493]                     next
[17:42:21.493]                   args[[name]] <- ""
[17:42:21.493]                 }
[17:42:21.493]                 NAMES <- toupper(removed)
[17:42:21.493]                 for (kk in seq_along(NAMES)) {
[17:42:21.493]                   name <- removed[[kk]]
[17:42:21.493]                   NAME <- NAMES[[kk]]
[17:42:21.493]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.493]                     next
[17:42:21.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.493]                 }
[17:42:21.493]                 if (length(args) > 0) 
[17:42:21.493]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.493]             }
[17:42:21.493]             else {
[17:42:21.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.493]             }
[17:42:21.493]             {
[17:42:21.493]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.493]                   0L) {
[17:42:21.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.493]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.493]                   base::options(opts)
[17:42:21.493]                 }
[17:42:21.493]                 {
[17:42:21.493]                   {
[17:42:21.493]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.493]                     NULL
[17:42:21.493]                   }
[17:42:21.493]                   options(future.plan = NULL)
[17:42:21.493]                   if (is.na(NA_character_)) 
[17:42:21.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.493]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.493]                     envir = parent.frame()) 
[17:42:21.493]                   {
[17:42:21.493]                     default_workers <- missing(workers)
[17:42:21.493]                     if (is.function(workers)) 
[17:42:21.493]                       workers <- workers()
[17:42:21.493]                     workers <- structure(as.integer(workers), 
[17:42:21.493]                       class = class(workers))
[17:42:21.493]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.493]                       1L)
[17:42:21.493]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.493]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.493]                       if (default_workers) 
[17:42:21.493]                         supportsMulticore(warn = TRUE)
[17:42:21.493]                       return(sequential(..., envir = envir))
[17:42:21.493]                     }
[17:42:21.493]                     oopts <- options(mc.cores = workers)
[17:42:21.493]                     on.exit(options(oopts))
[17:42:21.493]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.493]                       envir = envir)
[17:42:21.493]                     if (!future$lazy) 
[17:42:21.493]                       future <- run(future)
[17:42:21.493]                     invisible(future)
[17:42:21.493]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.493]                 }
[17:42:21.493]             }
[17:42:21.493]         }
[17:42:21.493]     })
[17:42:21.493]     if (TRUE) {
[17:42:21.493]         base::sink(type = "output", split = FALSE)
[17:42:21.493]         if (TRUE) {
[17:42:21.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.493]         }
[17:42:21.493]         else {
[17:42:21.493]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.493]         }
[17:42:21.493]         base::close(...future.stdout)
[17:42:21.493]         ...future.stdout <- NULL
[17:42:21.493]     }
[17:42:21.493]     ...future.result$conditions <- ...future.conditions
[17:42:21.493]     ...future.result$finished <- base::Sys.time()
[17:42:21.493]     ...future.result
[17:42:21.493] }
[17:42:21.496] requestCore(): workers = 2
[17:42:21.501] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:21.516] MulticoreFuture started
[17:42:21.516] - Launch lazy future ... done
[17:42:21.517] run() for ‘MulticoreFuture’ ... done
[17:42:21.517] plan(): Setting new future strategy stack:
<environment: 0x55bef989f368> 
[17:42:21.518] List of future strategies:
[17:42:21.518] 1. sequential:
[17:42:21.518]    - args: function (..., envir = parent.frame())
[17:42:21.518]    - tweaked: FALSE
[17:42:21.518]    - call: NULL
[17:42:21.519] plan(): nbrOfWorkers() = 1
<environment: 0x55bef87c5408> 
[17:42:21.521] plan(): Setting new future strategy stack:
[17:42:21.522] List of future strategies:
[17:42:21.522] 1. multicore:
[17:42:21.522]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.522]    - tweaked: FALSE
[17:42:21.522]    - call: plan(strategy)
[17:42:21.526] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:21.529] resolve() on environment ...
[17:42:21.529]  recursive: 0
[17:42:21.530]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:21.530] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.530] - nx: 4
[17:42:21.530] - relay: TRUE
[17:42:21.530] - stdout: TRUE
[17:42:21.530] - signal: TRUE
[17:42:21.531] - resignal: FALSE
[17:42:21.531] - force: TRUE
[17:42:21.531] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.531] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.531]  - until=2
[17:42:21.531]  - relaying element #2
[17:42:21.531] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.532] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.532] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.532]  length: 3 (resolved future 1)
[17:42:21.532] Future #2
[17:42:21.532] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:21.532] - nx: 4
[17:42:21.533] - relay: TRUE
[17:42:21.533] - stdout: TRUE
[17:42:21.533] - signal: TRUE
[17:42:21.533] - resignal: FALSE
[17:42:21.533] - force: TRUE
[17:42:21.533] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.533] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.533]  - until=2
[17:42:21.534]  - relaying element #2
[17:42:21.534] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.534] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.534] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:21.534]  length: 2 (resolved future 2)
[17:42:21.535] Future #3
[17:42:21.536] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:21.536] - nx: 4
[17:42:21.536] - relay: TRUE
[17:42:21.536] - stdout: TRUE
[17:42:21.536] - signal: TRUE
[17:42:21.536] - resignal: FALSE
[17:42:21.536] - force: TRUE
[17:42:21.537] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.537] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.537]  - until=3
[17:42:21.537]  - relaying element #3
[17:42:21.537] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.538] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.538] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:21.538]  length: 1 (resolved future 3)
[17:42:21.538] Future #4
[17:42:21.539] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:21.539] - nx: 4
[17:42:21.540] - relay: TRUE
[17:42:21.540] - stdout: TRUE
[17:42:21.540] - signal: TRUE
[17:42:21.540] - resignal: FALSE
[17:42:21.540] - force: TRUE
[17:42:21.540] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.540] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.541]  - until=4
[17:42:21.541]  - relaying element #4
[17:42:21.541] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.541] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.541] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:21.542]  length: 0 (resolved future 4)
[17:42:21.542] Relaying remaining futures
[17:42:21.542] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.542] - nx: 4
[17:42:21.542] - relay: TRUE
[17:42:21.542] - stdout: TRUE
[17:42:21.542] - signal: TRUE
[17:42:21.543] - resignal: FALSE
[17:42:21.543] - force: TRUE
[17:42:21.543] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.543] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:21.543] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.543] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.543] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.543] resolve() on environment ... DONE
<environment: 0x55bef867f330> 
Dimensions: c(1, 6)
[17:42:21.544] getGlobalsAndPackages() ...
[17:42:21.544] Searching for globals...
[17:42:21.545] 
[17:42:21.545] Searching for globals ... DONE
[17:42:21.545] - globals: [0] <none>
[17:42:21.545] getGlobalsAndPackages() ... DONE
[17:42:21.545] run() for ‘Future’ ...
[17:42:21.545] - state: ‘created’
[17:42:21.546] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.550] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.550]   - Field: ‘label’
[17:42:21.550]   - Field: ‘local’
[17:42:21.551]   - Field: ‘owner’
[17:42:21.551]   - Field: ‘envir’
[17:42:21.551]   - Field: ‘workers’
[17:42:21.551]   - Field: ‘packages’
[17:42:21.551]   - Field: ‘gc’
[17:42:21.551]   - Field: ‘job’
[17:42:21.551]   - Field: ‘conditions’
[17:42:21.551]   - Field: ‘expr’
[17:42:21.552]   - Field: ‘uuid’
[17:42:21.552]   - Field: ‘seed’
[17:42:21.552]   - Field: ‘version’
[17:42:21.552]   - Field: ‘result’
[17:42:21.552]   - Field: ‘asynchronous’
[17:42:21.552]   - Field: ‘calls’
[17:42:21.552]   - Field: ‘globals’
[17:42:21.552]   - Field: ‘stdout’
[17:42:21.552]   - Field: ‘earlySignal’
[17:42:21.553]   - Field: ‘lazy’
[17:42:21.553]   - Field: ‘state’
[17:42:21.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.553] - Launch lazy future ...
[17:42:21.553] Packages needed by the future expression (n = 0): <none>
[17:42:21.553] Packages needed by future strategies (n = 0): <none>
[17:42:21.554] {
[17:42:21.554]     {
[17:42:21.554]         {
[17:42:21.554]             ...future.startTime <- base::Sys.time()
[17:42:21.554]             {
[17:42:21.554]                 {
[17:42:21.554]                   {
[17:42:21.554]                     {
[17:42:21.554]                       base::local({
[17:42:21.554]                         has_future <- base::requireNamespace("future", 
[17:42:21.554]                           quietly = TRUE)
[17:42:21.554]                         if (has_future) {
[17:42:21.554]                           ns <- base::getNamespace("future")
[17:42:21.554]                           version <- ns[[".package"]][["version"]]
[17:42:21.554]                           if (is.null(version)) 
[17:42:21.554]                             version <- utils::packageVersion("future")
[17:42:21.554]                         }
[17:42:21.554]                         else {
[17:42:21.554]                           version <- NULL
[17:42:21.554]                         }
[17:42:21.554]                         if (!has_future || version < "1.8.0") {
[17:42:21.554]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.554]                             "", base::R.version$version.string), 
[17:42:21.554]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.554]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.554]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.554]                               "release", "version")], collapse = " "), 
[17:42:21.554]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.554]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.554]                             info)
[17:42:21.554]                           info <- base::paste(info, collapse = "; ")
[17:42:21.554]                           if (!has_future) {
[17:42:21.554]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.554]                               info)
[17:42:21.554]                           }
[17:42:21.554]                           else {
[17:42:21.554]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.554]                               info, version)
[17:42:21.554]                           }
[17:42:21.554]                           base::stop(msg)
[17:42:21.554]                         }
[17:42:21.554]                       })
[17:42:21.554]                     }
[17:42:21.554]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.554]                     base::options(mc.cores = 1L)
[17:42:21.554]                   }
[17:42:21.554]                   options(future.plan = NULL)
[17:42:21.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.554]                 }
[17:42:21.554]                 ...future.workdir <- getwd()
[17:42:21.554]             }
[17:42:21.554]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.554]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.554]         }
[17:42:21.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.554]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.554]             base::names(...future.oldOptions))
[17:42:21.554]     }
[17:42:21.554]     if (FALSE) {
[17:42:21.554]     }
[17:42:21.554]     else {
[17:42:21.554]         if (TRUE) {
[17:42:21.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.554]                 open = "w")
[17:42:21.554]         }
[17:42:21.554]         else {
[17:42:21.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.554]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.554]         }
[17:42:21.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.554]             base::sink(type = "output", split = FALSE)
[17:42:21.554]             base::close(...future.stdout)
[17:42:21.554]         }, add = TRUE)
[17:42:21.554]     }
[17:42:21.554]     ...future.frame <- base::sys.nframe()
[17:42:21.554]     ...future.conditions <- base::list()
[17:42:21.554]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.554]     if (FALSE) {
[17:42:21.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.554]     }
[17:42:21.554]     ...future.result <- base::tryCatch({
[17:42:21.554]         base::withCallingHandlers({
[17:42:21.554]             ...future.value <- base::withVisible(base::local({
[17:42:21.554]                 withCallingHandlers({
[17:42:21.554]                   2
[17:42:21.554]                 }, immediateCondition = function(cond) {
[17:42:21.554]                   save_rds <- function (object, pathname, ...) 
[17:42:21.554]                   {
[17:42:21.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.554]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.554]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.554]                         fi_tmp[["mtime"]])
[17:42:21.554]                     }
[17:42:21.554]                     tryCatch({
[17:42:21.554]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.554]                     }, error = function(ex) {
[17:42:21.554]                       msg <- conditionMessage(ex)
[17:42:21.554]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.554]                         fi_tmp[["mtime"]], msg)
[17:42:21.554]                       ex$message <- msg
[17:42:21.554]                       stop(ex)
[17:42:21.554]                     })
[17:42:21.554]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.554]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.554]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.554]                       fi <- file.info(pathname)
[17:42:21.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.554]                         fi[["size"]], fi[["mtime"]])
[17:42:21.554]                       stop(msg)
[17:42:21.554]                     }
[17:42:21.554]                     invisible(pathname)
[17:42:21.554]                   }
[17:42:21.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.554]                     rootPath = tempdir()) 
[17:42:21.554]                   {
[17:42:21.554]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.554]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.554]                       tmpdir = path, fileext = ".rds")
[17:42:21.554]                     save_rds(obj, file)
[17:42:21.554]                   }
[17:42:21.554]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.554]                   {
[17:42:21.554]                     inherits <- base::inherits
[17:42:21.554]                     invokeRestart <- base::invokeRestart
[17:42:21.554]                     is.null <- base::is.null
[17:42:21.554]                     muffled <- FALSE
[17:42:21.554]                     if (inherits(cond, "message")) {
[17:42:21.554]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.554]                       if (muffled) 
[17:42:21.554]                         invokeRestart("muffleMessage")
[17:42:21.554]                     }
[17:42:21.554]                     else if (inherits(cond, "warning")) {
[17:42:21.554]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.554]                       if (muffled) 
[17:42:21.554]                         invokeRestart("muffleWarning")
[17:42:21.554]                     }
[17:42:21.554]                     else if (inherits(cond, "condition")) {
[17:42:21.554]                       if (!is.null(pattern)) {
[17:42:21.554]                         computeRestarts <- base::computeRestarts
[17:42:21.554]                         grepl <- base::grepl
[17:42:21.554]                         restarts <- computeRestarts(cond)
[17:42:21.554]                         for (restart in restarts) {
[17:42:21.554]                           name <- restart$name
[17:42:21.554]                           if (is.null(name)) 
[17:42:21.554]                             next
[17:42:21.554]                           if (!grepl(pattern, name)) 
[17:42:21.554]                             next
[17:42:21.554]                           invokeRestart(restart)
[17:42:21.554]                           muffled <- TRUE
[17:42:21.554]                           break
[17:42:21.554]                         }
[17:42:21.554]                       }
[17:42:21.554]                     }
[17:42:21.554]                     invisible(muffled)
[17:42:21.554]                   }
[17:42:21.554]                   muffleCondition(cond)
[17:42:21.554]                 })
[17:42:21.554]             }))
[17:42:21.554]             future::FutureResult(value = ...future.value$value, 
[17:42:21.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.554]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.554]                     ...future.globalenv.names))
[17:42:21.554]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.554]         }, condition = base::local({
[17:42:21.554]             c <- base::c
[17:42:21.554]             inherits <- base::inherits
[17:42:21.554]             invokeRestart <- base::invokeRestart
[17:42:21.554]             length <- base::length
[17:42:21.554]             list <- base::list
[17:42:21.554]             seq.int <- base::seq.int
[17:42:21.554]             signalCondition <- base::signalCondition
[17:42:21.554]             sys.calls <- base::sys.calls
[17:42:21.554]             `[[` <- base::`[[`
[17:42:21.554]             `+` <- base::`+`
[17:42:21.554]             `<<-` <- base::`<<-`
[17:42:21.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.554]                   3L)]
[17:42:21.554]             }
[17:42:21.554]             function(cond) {
[17:42:21.554]                 is_error <- inherits(cond, "error")
[17:42:21.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.554]                   NULL)
[17:42:21.554]                 if (is_error) {
[17:42:21.554]                   sessionInformation <- function() {
[17:42:21.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.554]                       search = base::search(), system = base::Sys.info())
[17:42:21.554]                   }
[17:42:21.554]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.554]                     cond$call), session = sessionInformation(), 
[17:42:21.554]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.554]                   signalCondition(cond)
[17:42:21.554]                 }
[17:42:21.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.554]                 "immediateCondition"))) {
[17:42:21.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.554]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.554]                   if (TRUE && !signal) {
[17:42:21.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.554]                     {
[17:42:21.554]                       inherits <- base::inherits
[17:42:21.554]                       invokeRestart <- base::invokeRestart
[17:42:21.554]                       is.null <- base::is.null
[17:42:21.554]                       muffled <- FALSE
[17:42:21.554]                       if (inherits(cond, "message")) {
[17:42:21.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.554]                         if (muffled) 
[17:42:21.554]                           invokeRestart("muffleMessage")
[17:42:21.554]                       }
[17:42:21.554]                       else if (inherits(cond, "warning")) {
[17:42:21.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.554]                         if (muffled) 
[17:42:21.554]                           invokeRestart("muffleWarning")
[17:42:21.554]                       }
[17:42:21.554]                       else if (inherits(cond, "condition")) {
[17:42:21.554]                         if (!is.null(pattern)) {
[17:42:21.554]                           computeRestarts <- base::computeRestarts
[17:42:21.554]                           grepl <- base::grepl
[17:42:21.554]                           restarts <- computeRestarts(cond)
[17:42:21.554]                           for (restart in restarts) {
[17:42:21.554]                             name <- restart$name
[17:42:21.554]                             if (is.null(name)) 
[17:42:21.554]                               next
[17:42:21.554]                             if (!grepl(pattern, name)) 
[17:42:21.554]                               next
[17:42:21.554]                             invokeRestart(restart)
[17:42:21.554]                             muffled <- TRUE
[17:42:21.554]                             break
[17:42:21.554]                           }
[17:42:21.554]                         }
[17:42:21.554]                       }
[17:42:21.554]                       invisible(muffled)
[17:42:21.554]                     }
[17:42:21.554]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.554]                   }
[17:42:21.554]                 }
[17:42:21.554]                 else {
[17:42:21.554]                   if (TRUE) {
[17:42:21.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.554]                     {
[17:42:21.554]                       inherits <- base::inherits
[17:42:21.554]                       invokeRestart <- base::invokeRestart
[17:42:21.554]                       is.null <- base::is.null
[17:42:21.554]                       muffled <- FALSE
[17:42:21.554]                       if (inherits(cond, "message")) {
[17:42:21.554]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.554]                         if (muffled) 
[17:42:21.554]                           invokeRestart("muffleMessage")
[17:42:21.554]                       }
[17:42:21.554]                       else if (inherits(cond, "warning")) {
[17:42:21.554]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.554]                         if (muffled) 
[17:42:21.554]                           invokeRestart("muffleWarning")
[17:42:21.554]                       }
[17:42:21.554]                       else if (inherits(cond, "condition")) {
[17:42:21.554]                         if (!is.null(pattern)) {
[17:42:21.554]                           computeRestarts <- base::computeRestarts
[17:42:21.554]                           grepl <- base::grepl
[17:42:21.554]                           restarts <- computeRestarts(cond)
[17:42:21.554]                           for (restart in restarts) {
[17:42:21.554]                             name <- restart$name
[17:42:21.554]                             if (is.null(name)) 
[17:42:21.554]                               next
[17:42:21.554]                             if (!grepl(pattern, name)) 
[17:42:21.554]                               next
[17:42:21.554]                             invokeRestart(restart)
[17:42:21.554]                             muffled <- TRUE
[17:42:21.554]                             break
[17:42:21.554]                           }
[17:42:21.554]                         }
[17:42:21.554]                       }
[17:42:21.554]                       invisible(muffled)
[17:42:21.554]                     }
[17:42:21.554]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.554]                   }
[17:42:21.554]                 }
[17:42:21.554]             }
[17:42:21.554]         }))
[17:42:21.554]     }, error = function(ex) {
[17:42:21.554]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.554]                 ...future.rng), started = ...future.startTime, 
[17:42:21.554]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.554]             version = "1.8"), class = "FutureResult")
[17:42:21.554]     }, finally = {
[17:42:21.554]         if (!identical(...future.workdir, getwd())) 
[17:42:21.554]             setwd(...future.workdir)
[17:42:21.554]         {
[17:42:21.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.554]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.554]             }
[17:42:21.554]             base::options(...future.oldOptions)
[17:42:21.554]             if (.Platform$OS.type == "windows") {
[17:42:21.554]                 old_names <- names(...future.oldEnvVars)
[17:42:21.554]                 envs <- base::Sys.getenv()
[17:42:21.554]                 names <- names(envs)
[17:42:21.554]                 common <- intersect(names, old_names)
[17:42:21.554]                 added <- setdiff(names, old_names)
[17:42:21.554]                 removed <- setdiff(old_names, names)
[17:42:21.554]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.554]                   envs[common]]
[17:42:21.554]                 NAMES <- toupper(changed)
[17:42:21.554]                 args <- list()
[17:42:21.554]                 for (kk in seq_along(NAMES)) {
[17:42:21.554]                   name <- changed[[kk]]
[17:42:21.554]                   NAME <- NAMES[[kk]]
[17:42:21.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.554]                     next
[17:42:21.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.554]                 }
[17:42:21.554]                 NAMES <- toupper(added)
[17:42:21.554]                 for (kk in seq_along(NAMES)) {
[17:42:21.554]                   name <- added[[kk]]
[17:42:21.554]                   NAME <- NAMES[[kk]]
[17:42:21.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.554]                     next
[17:42:21.554]                   args[[name]] <- ""
[17:42:21.554]                 }
[17:42:21.554]                 NAMES <- toupper(removed)
[17:42:21.554]                 for (kk in seq_along(NAMES)) {
[17:42:21.554]                   name <- removed[[kk]]
[17:42:21.554]                   NAME <- NAMES[[kk]]
[17:42:21.554]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.554]                     next
[17:42:21.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.554]                 }
[17:42:21.554]                 if (length(args) > 0) 
[17:42:21.554]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.554]             }
[17:42:21.554]             else {
[17:42:21.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.554]             }
[17:42:21.554]             {
[17:42:21.554]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.554]                   0L) {
[17:42:21.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.554]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.554]                   base::options(opts)
[17:42:21.554]                 }
[17:42:21.554]                 {
[17:42:21.554]                   {
[17:42:21.554]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.554]                     NULL
[17:42:21.554]                   }
[17:42:21.554]                   options(future.plan = NULL)
[17:42:21.554]                   if (is.na(NA_character_)) 
[17:42:21.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.554]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.554]                     envir = parent.frame()) 
[17:42:21.554]                   {
[17:42:21.554]                     default_workers <- missing(workers)
[17:42:21.554]                     if (is.function(workers)) 
[17:42:21.554]                       workers <- workers()
[17:42:21.554]                     workers <- structure(as.integer(workers), 
[17:42:21.554]                       class = class(workers))
[17:42:21.554]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.554]                       1L)
[17:42:21.554]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.554]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.554]                       if (default_workers) 
[17:42:21.554]                         supportsMulticore(warn = TRUE)
[17:42:21.554]                       return(sequential(..., envir = envir))
[17:42:21.554]                     }
[17:42:21.554]                     oopts <- options(mc.cores = workers)
[17:42:21.554]                     on.exit(options(oopts))
[17:42:21.554]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.554]                       envir = envir)
[17:42:21.554]                     if (!future$lazy) 
[17:42:21.554]                       future <- run(future)
[17:42:21.554]                     invisible(future)
[17:42:21.554]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.554]                 }
[17:42:21.554]             }
[17:42:21.554]         }
[17:42:21.554]     })
[17:42:21.554]     if (TRUE) {
[17:42:21.554]         base::sink(type = "output", split = FALSE)
[17:42:21.554]         if (TRUE) {
[17:42:21.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.554]         }
[17:42:21.554]         else {
[17:42:21.554]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.554]         }
[17:42:21.554]         base::close(...future.stdout)
[17:42:21.554]         ...future.stdout <- NULL
[17:42:21.554]     }
[17:42:21.554]     ...future.result$conditions <- ...future.conditions
[17:42:21.554]     ...future.result$finished <- base::Sys.time()
[17:42:21.554]     ...future.result
[17:42:21.554] }
[17:42:21.557] requestCore(): workers = 2
[17:42:21.559] MulticoreFuture started
[17:42:21.559] - Launch lazy future ... done
[17:42:21.559] run() for ‘MulticoreFuture’ ... done
[17:42:21.560] getGlobalsAndPackages() ...
[17:42:21.560] plan(): Setting new future strategy stack:
[17:42:21.560] Searching for globals...
[17:42:21.560] List of future strategies:
[17:42:21.560] 1. sequential:
[17:42:21.560]    - args: function (..., envir = parent.frame())
[17:42:21.560]    - tweaked: FALSE
[17:42:21.560]    - call: NULL
[17:42:21.561] 
[17:42:21.561] plan(): nbrOfWorkers() = 1
[17:42:21.562] Searching for globals ... DONE
[17:42:21.562] - globals: [0] <none>
[17:42:21.562] getGlobalsAndPackages() ... DONE
[17:42:21.563] run() for ‘Future’ ...
[17:42:21.563] - state: ‘created’
[17:42:21.563] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.563] plan(): Setting new future strategy stack:
[17:42:21.563] List of future strategies:
[17:42:21.563] 1. multicore:
[17:42:21.563]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.563]    - tweaked: FALSE
[17:42:21.563]    - call: plan(strategy)
[17:42:21.569] plan(): nbrOfWorkers() = 2
[17:42:21.570] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.570]   - Field: ‘label’
[17:42:21.570]   - Field: ‘local’
[17:42:21.570]   - Field: ‘owner’
[17:42:21.571]   - Field: ‘envir’
[17:42:21.571]   - Field: ‘workers’
[17:42:21.571]   - Field: ‘packages’
[17:42:21.571]   - Field: ‘gc’
[17:42:21.571]   - Field: ‘job’
[17:42:21.572]   - Field: ‘conditions’
[17:42:21.572]   - Field: ‘expr’
[17:42:21.572]   - Field: ‘uuid’
[17:42:21.572]   - Field: ‘seed’
[17:42:21.572]   - Field: ‘version’
[17:42:21.572]   - Field: ‘result’
[17:42:21.573]   - Field: ‘asynchronous’
[17:42:21.573]   - Field: ‘calls’
[17:42:21.573]   - Field: ‘globals’
[17:42:21.573]   - Field: ‘stdout’
[17:42:21.573]   - Field: ‘earlySignal’
[17:42:21.573]   - Field: ‘lazy’
[17:42:21.574]   - Field: ‘state’
[17:42:21.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.574] - Launch lazy future ...
[17:42:21.574] Packages needed by the future expression (n = 0): <none>
[17:42:21.575] Packages needed by future strategies (n = 0): <none>
[17:42:21.576] {
[17:42:21.576]     {
[17:42:21.576]         {
[17:42:21.576]             ...future.startTime <- base::Sys.time()
[17:42:21.576]             {
[17:42:21.576]                 {
[17:42:21.576]                   {
[17:42:21.576]                     {
[17:42:21.576]                       base::local({
[17:42:21.576]                         has_future <- base::requireNamespace("future", 
[17:42:21.576]                           quietly = TRUE)
[17:42:21.576]                         if (has_future) {
[17:42:21.576]                           ns <- base::getNamespace("future")
[17:42:21.576]                           version <- ns[[".package"]][["version"]]
[17:42:21.576]                           if (is.null(version)) 
[17:42:21.576]                             version <- utils::packageVersion("future")
[17:42:21.576]                         }
[17:42:21.576]                         else {
[17:42:21.576]                           version <- NULL
[17:42:21.576]                         }
[17:42:21.576]                         if (!has_future || version < "1.8.0") {
[17:42:21.576]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.576]                             "", base::R.version$version.string), 
[17:42:21.576]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.576]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.576]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.576]                               "release", "version")], collapse = " "), 
[17:42:21.576]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.576]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.576]                             info)
[17:42:21.576]                           info <- base::paste(info, collapse = "; ")
[17:42:21.576]                           if (!has_future) {
[17:42:21.576]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.576]                               info)
[17:42:21.576]                           }
[17:42:21.576]                           else {
[17:42:21.576]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.576]                               info, version)
[17:42:21.576]                           }
[17:42:21.576]                           base::stop(msg)
[17:42:21.576]                         }
[17:42:21.576]                       })
[17:42:21.576]                     }
[17:42:21.576]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.576]                     base::options(mc.cores = 1L)
[17:42:21.576]                   }
[17:42:21.576]                   options(future.plan = NULL)
[17:42:21.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.576]                 }
[17:42:21.576]                 ...future.workdir <- getwd()
[17:42:21.576]             }
[17:42:21.576]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.576]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.576]         }
[17:42:21.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.576]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.576]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.576]             base::names(...future.oldOptions))
[17:42:21.576]     }
[17:42:21.576]     if (FALSE) {
[17:42:21.576]     }
[17:42:21.576]     else {
[17:42:21.576]         if (TRUE) {
[17:42:21.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.576]                 open = "w")
[17:42:21.576]         }
[17:42:21.576]         else {
[17:42:21.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.576]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.576]         }
[17:42:21.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.576]             base::sink(type = "output", split = FALSE)
[17:42:21.576]             base::close(...future.stdout)
[17:42:21.576]         }, add = TRUE)
[17:42:21.576]     }
[17:42:21.576]     ...future.frame <- base::sys.nframe()
[17:42:21.576]     ...future.conditions <- base::list()
[17:42:21.576]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.576]     if (FALSE) {
[17:42:21.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.576]     }
[17:42:21.576]     ...future.result <- base::tryCatch({
[17:42:21.576]         base::withCallingHandlers({
[17:42:21.576]             ...future.value <- base::withVisible(base::local({
[17:42:21.576]                 withCallingHandlers({
[17:42:21.576]                   NULL
[17:42:21.576]                 }, immediateCondition = function(cond) {
[17:42:21.576]                   save_rds <- function (object, pathname, ...) 
[17:42:21.576]                   {
[17:42:21.576]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.576]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.576]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.576]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.576]                         fi_tmp[["mtime"]])
[17:42:21.576]                     }
[17:42:21.576]                     tryCatch({
[17:42:21.576]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.576]                     }, error = function(ex) {
[17:42:21.576]                       msg <- conditionMessage(ex)
[17:42:21.576]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.576]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.576]                         fi_tmp[["mtime"]], msg)
[17:42:21.576]                       ex$message <- msg
[17:42:21.576]                       stop(ex)
[17:42:21.576]                     })
[17:42:21.576]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.576]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.576]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.576]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.576]                       fi <- file.info(pathname)
[17:42:21.576]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.576]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.576]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.576]                         fi[["size"]], fi[["mtime"]])
[17:42:21.576]                       stop(msg)
[17:42:21.576]                     }
[17:42:21.576]                     invisible(pathname)
[17:42:21.576]                   }
[17:42:21.576]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.576]                     rootPath = tempdir()) 
[17:42:21.576]                   {
[17:42:21.576]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.576]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.576]                       tmpdir = path, fileext = ".rds")
[17:42:21.576]                     save_rds(obj, file)
[17:42:21.576]                   }
[17:42:21.576]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.576]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.576]                   {
[17:42:21.576]                     inherits <- base::inherits
[17:42:21.576]                     invokeRestart <- base::invokeRestart
[17:42:21.576]                     is.null <- base::is.null
[17:42:21.576]                     muffled <- FALSE
[17:42:21.576]                     if (inherits(cond, "message")) {
[17:42:21.576]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.576]                       if (muffled) 
[17:42:21.576]                         invokeRestart("muffleMessage")
[17:42:21.576]                     }
[17:42:21.576]                     else if (inherits(cond, "warning")) {
[17:42:21.576]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.576]                       if (muffled) 
[17:42:21.576]                         invokeRestart("muffleWarning")
[17:42:21.576]                     }
[17:42:21.576]                     else if (inherits(cond, "condition")) {
[17:42:21.576]                       if (!is.null(pattern)) {
[17:42:21.576]                         computeRestarts <- base::computeRestarts
[17:42:21.576]                         grepl <- base::grepl
[17:42:21.576]                         restarts <- computeRestarts(cond)
[17:42:21.576]                         for (restart in restarts) {
[17:42:21.576]                           name <- restart$name
[17:42:21.576]                           if (is.null(name)) 
[17:42:21.576]                             next
[17:42:21.576]                           if (!grepl(pattern, name)) 
[17:42:21.576]                             next
[17:42:21.576]                           invokeRestart(restart)
[17:42:21.576]                           muffled <- TRUE
[17:42:21.576]                           break
[17:42:21.576]                         }
[17:42:21.576]                       }
[17:42:21.576]                     }
[17:42:21.576]                     invisible(muffled)
[17:42:21.576]                   }
[17:42:21.576]                   muffleCondition(cond)
[17:42:21.576]                 })
[17:42:21.576]             }))
[17:42:21.576]             future::FutureResult(value = ...future.value$value, 
[17:42:21.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.576]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.576]                     ...future.globalenv.names))
[17:42:21.576]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.576]         }, condition = base::local({
[17:42:21.576]             c <- base::c
[17:42:21.576]             inherits <- base::inherits
[17:42:21.576]             invokeRestart <- base::invokeRestart
[17:42:21.576]             length <- base::length
[17:42:21.576]             list <- base::list
[17:42:21.576]             seq.int <- base::seq.int
[17:42:21.576]             signalCondition <- base::signalCondition
[17:42:21.576]             sys.calls <- base::sys.calls
[17:42:21.576]             `[[` <- base::`[[`
[17:42:21.576]             `+` <- base::`+`
[17:42:21.576]             `<<-` <- base::`<<-`
[17:42:21.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.576]                   3L)]
[17:42:21.576]             }
[17:42:21.576]             function(cond) {
[17:42:21.576]                 is_error <- inherits(cond, "error")
[17:42:21.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.576]                   NULL)
[17:42:21.576]                 if (is_error) {
[17:42:21.576]                   sessionInformation <- function() {
[17:42:21.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.576]                       search = base::search(), system = base::Sys.info())
[17:42:21.576]                   }
[17:42:21.576]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.576]                     cond$call), session = sessionInformation(), 
[17:42:21.576]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.576]                   signalCondition(cond)
[17:42:21.576]                 }
[17:42:21.576]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.576]                 "immediateCondition"))) {
[17:42:21.576]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.576]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.576]                   if (TRUE && !signal) {
[17:42:21.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.576]                     {
[17:42:21.576]                       inherits <- base::inherits
[17:42:21.576]                       invokeRestart <- base::invokeRestart
[17:42:21.576]                       is.null <- base::is.null
[17:42:21.576]                       muffled <- FALSE
[17:42:21.576]                       if (inherits(cond, "message")) {
[17:42:21.576]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.576]                         if (muffled) 
[17:42:21.576]                           invokeRestart("muffleMessage")
[17:42:21.576]                       }
[17:42:21.576]                       else if (inherits(cond, "warning")) {
[17:42:21.576]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.576]                         if (muffled) 
[17:42:21.576]                           invokeRestart("muffleWarning")
[17:42:21.576]                       }
[17:42:21.576]                       else if (inherits(cond, "condition")) {
[17:42:21.576]                         if (!is.null(pattern)) {
[17:42:21.576]                           computeRestarts <- base::computeRestarts
[17:42:21.576]                           grepl <- base::grepl
[17:42:21.576]                           restarts <- computeRestarts(cond)
[17:42:21.576]                           for (restart in restarts) {
[17:42:21.576]                             name <- restart$name
[17:42:21.576]                             if (is.null(name)) 
[17:42:21.576]                               next
[17:42:21.576]                             if (!grepl(pattern, name)) 
[17:42:21.576]                               next
[17:42:21.576]                             invokeRestart(restart)
[17:42:21.576]                             muffled <- TRUE
[17:42:21.576]                             break
[17:42:21.576]                           }
[17:42:21.576]                         }
[17:42:21.576]                       }
[17:42:21.576]                       invisible(muffled)
[17:42:21.576]                     }
[17:42:21.576]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.576]                   }
[17:42:21.576]                 }
[17:42:21.576]                 else {
[17:42:21.576]                   if (TRUE) {
[17:42:21.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.576]                     {
[17:42:21.576]                       inherits <- base::inherits
[17:42:21.576]                       invokeRestart <- base::invokeRestart
[17:42:21.576]                       is.null <- base::is.null
[17:42:21.576]                       muffled <- FALSE
[17:42:21.576]                       if (inherits(cond, "message")) {
[17:42:21.576]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.576]                         if (muffled) 
[17:42:21.576]                           invokeRestart("muffleMessage")
[17:42:21.576]                       }
[17:42:21.576]                       else if (inherits(cond, "warning")) {
[17:42:21.576]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.576]                         if (muffled) 
[17:42:21.576]                           invokeRestart("muffleWarning")
[17:42:21.576]                       }
[17:42:21.576]                       else if (inherits(cond, "condition")) {
[17:42:21.576]                         if (!is.null(pattern)) {
[17:42:21.576]                           computeRestarts <- base::computeRestarts
[17:42:21.576]                           grepl <- base::grepl
[17:42:21.576]                           restarts <- computeRestarts(cond)
[17:42:21.576]                           for (restart in restarts) {
[17:42:21.576]                             name <- restart$name
[17:42:21.576]                             if (is.null(name)) 
[17:42:21.576]                               next
[17:42:21.576]                             if (!grepl(pattern, name)) 
[17:42:21.576]                               next
[17:42:21.576]                             invokeRestart(restart)
[17:42:21.576]                             muffled <- TRUE
[17:42:21.576]                             break
[17:42:21.576]                           }
[17:42:21.576]                         }
[17:42:21.576]                       }
[17:42:21.576]                       invisible(muffled)
[17:42:21.576]                     }
[17:42:21.576]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.576]                   }
[17:42:21.576]                 }
[17:42:21.576]             }
[17:42:21.576]         }))
[17:42:21.576]     }, error = function(ex) {
[17:42:21.576]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.576]                 ...future.rng), started = ...future.startTime, 
[17:42:21.576]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.576]             version = "1.8"), class = "FutureResult")
[17:42:21.576]     }, finally = {
[17:42:21.576]         if (!identical(...future.workdir, getwd())) 
[17:42:21.576]             setwd(...future.workdir)
[17:42:21.576]         {
[17:42:21.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.576]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.576]             }
[17:42:21.576]             base::options(...future.oldOptions)
[17:42:21.576]             if (.Platform$OS.type == "windows") {
[17:42:21.576]                 old_names <- names(...future.oldEnvVars)
[17:42:21.576]                 envs <- base::Sys.getenv()
[17:42:21.576]                 names <- names(envs)
[17:42:21.576]                 common <- intersect(names, old_names)
[17:42:21.576]                 added <- setdiff(names, old_names)
[17:42:21.576]                 removed <- setdiff(old_names, names)
[17:42:21.576]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.576]                   envs[common]]
[17:42:21.576]                 NAMES <- toupper(changed)
[17:42:21.576]                 args <- list()
[17:42:21.576]                 for (kk in seq_along(NAMES)) {
[17:42:21.576]                   name <- changed[[kk]]
[17:42:21.576]                   NAME <- NAMES[[kk]]
[17:42:21.576]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.576]                     next
[17:42:21.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.576]                 }
[17:42:21.576]                 NAMES <- toupper(added)
[17:42:21.576]                 for (kk in seq_along(NAMES)) {
[17:42:21.576]                   name <- added[[kk]]
[17:42:21.576]                   NAME <- NAMES[[kk]]
[17:42:21.576]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.576]                     next
[17:42:21.576]                   args[[name]] <- ""
[17:42:21.576]                 }
[17:42:21.576]                 NAMES <- toupper(removed)
[17:42:21.576]                 for (kk in seq_along(NAMES)) {
[17:42:21.576]                   name <- removed[[kk]]
[17:42:21.576]                   NAME <- NAMES[[kk]]
[17:42:21.576]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.576]                     next
[17:42:21.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.576]                 }
[17:42:21.576]                 if (length(args) > 0) 
[17:42:21.576]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.576]             }
[17:42:21.576]             else {
[17:42:21.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.576]             }
[17:42:21.576]             {
[17:42:21.576]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.576]                   0L) {
[17:42:21.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.576]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.576]                   base::options(opts)
[17:42:21.576]                 }
[17:42:21.576]                 {
[17:42:21.576]                   {
[17:42:21.576]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.576]                     NULL
[17:42:21.576]                   }
[17:42:21.576]                   options(future.plan = NULL)
[17:42:21.576]                   if (is.na(NA_character_)) 
[17:42:21.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.576]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.576]                     envir = parent.frame()) 
[17:42:21.576]                   {
[17:42:21.576]                     default_workers <- missing(workers)
[17:42:21.576]                     if (is.function(workers)) 
[17:42:21.576]                       workers <- workers()
[17:42:21.576]                     workers <- structure(as.integer(workers), 
[17:42:21.576]                       class = class(workers))
[17:42:21.576]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.576]                       1L)
[17:42:21.576]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.576]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.576]                       if (default_workers) 
[17:42:21.576]                         supportsMulticore(warn = TRUE)
[17:42:21.576]                       return(sequential(..., envir = envir))
[17:42:21.576]                     }
[17:42:21.576]                     oopts <- options(mc.cores = workers)
[17:42:21.576]                     on.exit(options(oopts))
[17:42:21.576]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.576]                       envir = envir)
[17:42:21.576]                     if (!future$lazy) 
[17:42:21.576]                       future <- run(future)
[17:42:21.576]                     invisible(future)
[17:42:21.576]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.576]                 }
[17:42:21.576]             }
[17:42:21.576]         }
[17:42:21.576]     })
[17:42:21.576]     if (TRUE) {
[17:42:21.576]         base::sink(type = "output", split = FALSE)
[17:42:21.576]         if (TRUE) {
[17:42:21.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.576]         }
[17:42:21.576]         else {
[17:42:21.576]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.576]         }
[17:42:21.576]         base::close(...future.stdout)
[17:42:21.576]         ...future.stdout <- NULL
[17:42:21.576]     }
[17:42:21.576]     ...future.result$conditions <- ...future.conditions
[17:42:21.576]     ...future.result$finished <- base::Sys.time()
[17:42:21.576]     ...future.result
[17:42:21.576] }
[17:42:21.579] requestCore(): workers = 2
[17:42:21.582] MulticoreFuture started
[17:42:21.582] - Launch lazy future ... done
[17:42:21.583] run() for ‘MulticoreFuture’ ... done
[17:42:21.583] plan(): Setting new future strategy stack:
[17:42:21.583] getGlobalsAndPackages() ...
[17:42:21.584] Searching for globals...
[17:42:21.584] List of future strategies:
[17:42:21.584] 1. sequential:
[17:42:21.584]    - args: function (..., envir = parent.frame())
[17:42:21.584]    - tweaked: FALSE
[17:42:21.584]    - call: NULL
[17:42:21.584] plan(): nbrOfWorkers() = 1
[17:42:21.585] - globals found: [1] ‘{’
[17:42:21.585] Searching for globals ... DONE
[17:42:21.585] Resolving globals: FALSE
[17:42:21.586] 
[17:42:21.586] 
[17:42:21.586] getGlobalsAndPackages() ... DONE
[17:42:21.586] plan(): Setting new future strategy stack:
[17:42:21.587] run() for ‘Future’ ...
[17:42:21.587] - state: ‘created’
[17:42:21.587] List of future strategies:
[17:42:21.587] 1. multicore:
[17:42:21.587]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.587]    - tweaked: FALSE
[17:42:21.587]    - call: plan(strategy)
[17:42:21.587] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.592] plan(): nbrOfWorkers() = 2
[17:42:21.592] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.592] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.592]   - Field: ‘label’
[17:42:21.593]   - Field: ‘local’
[17:42:21.593]   - Field: ‘owner’
[17:42:21.593]   - Field: ‘envir’
[17:42:21.593]   - Field: ‘workers’
[17:42:21.593]   - Field: ‘packages’
[17:42:21.593]   - Field: ‘gc’
[17:42:21.593]   - Field: ‘job’
[17:42:21.594]   - Field: ‘conditions’
[17:42:21.594]   - Field: ‘expr’
[17:42:21.594]   - Field: ‘uuid’
[17:42:21.594]   - Field: ‘seed’
[17:42:21.594]   - Field: ‘version’
[17:42:21.594]   - Field: ‘result’
[17:42:21.594]   - Field: ‘asynchronous’
[17:42:21.595]   - Field: ‘calls’
[17:42:21.595]   - Field: ‘globals’
[17:42:21.595]   - Field: ‘stdout’
[17:42:21.595]   - Field: ‘earlySignal’
[17:42:21.595]   - Field: ‘lazy’
[17:42:21.595]   - Field: ‘state’
[17:42:21.595] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.596] - Launch lazy future ...
[17:42:21.596] Packages needed by the future expression (n = 0): <none>
[17:42:21.596] Packages needed by future strategies (n = 0): <none>
[17:42:21.597] {
[17:42:21.597]     {
[17:42:21.597]         {
[17:42:21.597]             ...future.startTime <- base::Sys.time()
[17:42:21.597]             {
[17:42:21.597]                 {
[17:42:21.597]                   {
[17:42:21.597]                     {
[17:42:21.597]                       base::local({
[17:42:21.597]                         has_future <- base::requireNamespace("future", 
[17:42:21.597]                           quietly = TRUE)
[17:42:21.597]                         if (has_future) {
[17:42:21.597]                           ns <- base::getNamespace("future")
[17:42:21.597]                           version <- ns[[".package"]][["version"]]
[17:42:21.597]                           if (is.null(version)) 
[17:42:21.597]                             version <- utils::packageVersion("future")
[17:42:21.597]                         }
[17:42:21.597]                         else {
[17:42:21.597]                           version <- NULL
[17:42:21.597]                         }
[17:42:21.597]                         if (!has_future || version < "1.8.0") {
[17:42:21.597]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.597]                             "", base::R.version$version.string), 
[17:42:21.597]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.597]                               "release", "version")], collapse = " "), 
[17:42:21.597]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.597]                             info)
[17:42:21.597]                           info <- base::paste(info, collapse = "; ")
[17:42:21.597]                           if (!has_future) {
[17:42:21.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.597]                               info)
[17:42:21.597]                           }
[17:42:21.597]                           else {
[17:42:21.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.597]                               info, version)
[17:42:21.597]                           }
[17:42:21.597]                           base::stop(msg)
[17:42:21.597]                         }
[17:42:21.597]                       })
[17:42:21.597]                     }
[17:42:21.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.597]                     base::options(mc.cores = 1L)
[17:42:21.597]                   }
[17:42:21.597]                   options(future.plan = NULL)
[17:42:21.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.597]                 }
[17:42:21.597]                 ...future.workdir <- getwd()
[17:42:21.597]             }
[17:42:21.597]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.597]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.597]         }
[17:42:21.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.597]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.597]             base::names(...future.oldOptions))
[17:42:21.597]     }
[17:42:21.597]     if (FALSE) {
[17:42:21.597]     }
[17:42:21.597]     else {
[17:42:21.597]         if (TRUE) {
[17:42:21.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.597]                 open = "w")
[17:42:21.597]         }
[17:42:21.597]         else {
[17:42:21.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.597]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.597]         }
[17:42:21.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.597]             base::sink(type = "output", split = FALSE)
[17:42:21.597]             base::close(...future.stdout)
[17:42:21.597]         }, add = TRUE)
[17:42:21.597]     }
[17:42:21.597]     ...future.frame <- base::sys.nframe()
[17:42:21.597]     ...future.conditions <- base::list()
[17:42:21.597]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.597]     if (FALSE) {
[17:42:21.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.597]     }
[17:42:21.597]     ...future.result <- base::tryCatch({
[17:42:21.597]         base::withCallingHandlers({
[17:42:21.597]             ...future.value <- base::withVisible(base::local({
[17:42:21.597]                 withCallingHandlers({
[17:42:21.597]                   {
[17:42:21.597]                     4
[17:42:21.597]                   }
[17:42:21.597]                 }, immediateCondition = function(cond) {
[17:42:21.597]                   save_rds <- function (object, pathname, ...) 
[17:42:21.597]                   {
[17:42:21.597]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.597]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.597]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.597]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.597]                         fi_tmp[["mtime"]])
[17:42:21.597]                     }
[17:42:21.597]                     tryCatch({
[17:42:21.597]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.597]                     }, error = function(ex) {
[17:42:21.597]                       msg <- conditionMessage(ex)
[17:42:21.597]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.597]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.597]                         fi_tmp[["mtime"]], msg)
[17:42:21.597]                       ex$message <- msg
[17:42:21.597]                       stop(ex)
[17:42:21.597]                     })
[17:42:21.597]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.597]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.597]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.597]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.597]                       fi <- file.info(pathname)
[17:42:21.597]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.597]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.597]                         fi[["size"]], fi[["mtime"]])
[17:42:21.597]                       stop(msg)
[17:42:21.597]                     }
[17:42:21.597]                     invisible(pathname)
[17:42:21.597]                   }
[17:42:21.597]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.597]                     rootPath = tempdir()) 
[17:42:21.597]                   {
[17:42:21.597]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.597]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.597]                       tmpdir = path, fileext = ".rds")
[17:42:21.597]                     save_rds(obj, file)
[17:42:21.597]                   }
[17:42:21.597]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.597]                   {
[17:42:21.597]                     inherits <- base::inherits
[17:42:21.597]                     invokeRestart <- base::invokeRestart
[17:42:21.597]                     is.null <- base::is.null
[17:42:21.597]                     muffled <- FALSE
[17:42:21.597]                     if (inherits(cond, "message")) {
[17:42:21.597]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.597]                       if (muffled) 
[17:42:21.597]                         invokeRestart("muffleMessage")
[17:42:21.597]                     }
[17:42:21.597]                     else if (inherits(cond, "warning")) {
[17:42:21.597]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.597]                       if (muffled) 
[17:42:21.597]                         invokeRestart("muffleWarning")
[17:42:21.597]                     }
[17:42:21.597]                     else if (inherits(cond, "condition")) {
[17:42:21.597]                       if (!is.null(pattern)) {
[17:42:21.597]                         computeRestarts <- base::computeRestarts
[17:42:21.597]                         grepl <- base::grepl
[17:42:21.597]                         restarts <- computeRestarts(cond)
[17:42:21.597]                         for (restart in restarts) {
[17:42:21.597]                           name <- restart$name
[17:42:21.597]                           if (is.null(name)) 
[17:42:21.597]                             next
[17:42:21.597]                           if (!grepl(pattern, name)) 
[17:42:21.597]                             next
[17:42:21.597]                           invokeRestart(restart)
[17:42:21.597]                           muffled <- TRUE
[17:42:21.597]                           break
[17:42:21.597]                         }
[17:42:21.597]                       }
[17:42:21.597]                     }
[17:42:21.597]                     invisible(muffled)
[17:42:21.597]                   }
[17:42:21.597]                   muffleCondition(cond)
[17:42:21.597]                 })
[17:42:21.597]             }))
[17:42:21.597]             future::FutureResult(value = ...future.value$value, 
[17:42:21.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.597]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.597]                     ...future.globalenv.names))
[17:42:21.597]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.597]         }, condition = base::local({
[17:42:21.597]             c <- base::c
[17:42:21.597]             inherits <- base::inherits
[17:42:21.597]             invokeRestart <- base::invokeRestart
[17:42:21.597]             length <- base::length
[17:42:21.597]             list <- base::list
[17:42:21.597]             seq.int <- base::seq.int
[17:42:21.597]             signalCondition <- base::signalCondition
[17:42:21.597]             sys.calls <- base::sys.calls
[17:42:21.597]             `[[` <- base::`[[`
[17:42:21.597]             `+` <- base::`+`
[17:42:21.597]             `<<-` <- base::`<<-`
[17:42:21.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.597]                   3L)]
[17:42:21.597]             }
[17:42:21.597]             function(cond) {
[17:42:21.597]                 is_error <- inherits(cond, "error")
[17:42:21.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.597]                   NULL)
[17:42:21.597]                 if (is_error) {
[17:42:21.597]                   sessionInformation <- function() {
[17:42:21.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.597]                       search = base::search(), system = base::Sys.info())
[17:42:21.597]                   }
[17:42:21.597]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.597]                     cond$call), session = sessionInformation(), 
[17:42:21.597]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.597]                   signalCondition(cond)
[17:42:21.597]                 }
[17:42:21.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.597]                 "immediateCondition"))) {
[17:42:21.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.597]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.597]                   if (TRUE && !signal) {
[17:42:21.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.597]                     {
[17:42:21.597]                       inherits <- base::inherits
[17:42:21.597]                       invokeRestart <- base::invokeRestart
[17:42:21.597]                       is.null <- base::is.null
[17:42:21.597]                       muffled <- FALSE
[17:42:21.597]                       if (inherits(cond, "message")) {
[17:42:21.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.597]                         if (muffled) 
[17:42:21.597]                           invokeRestart("muffleMessage")
[17:42:21.597]                       }
[17:42:21.597]                       else if (inherits(cond, "warning")) {
[17:42:21.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.597]                         if (muffled) 
[17:42:21.597]                           invokeRestart("muffleWarning")
[17:42:21.597]                       }
[17:42:21.597]                       else if (inherits(cond, "condition")) {
[17:42:21.597]                         if (!is.null(pattern)) {
[17:42:21.597]                           computeRestarts <- base::computeRestarts
[17:42:21.597]                           grepl <- base::grepl
[17:42:21.597]                           restarts <- computeRestarts(cond)
[17:42:21.597]                           for (restart in restarts) {
[17:42:21.597]                             name <- restart$name
[17:42:21.597]                             if (is.null(name)) 
[17:42:21.597]                               next
[17:42:21.597]                             if (!grepl(pattern, name)) 
[17:42:21.597]                               next
[17:42:21.597]                             invokeRestart(restart)
[17:42:21.597]                             muffled <- TRUE
[17:42:21.597]                             break
[17:42:21.597]                           }
[17:42:21.597]                         }
[17:42:21.597]                       }
[17:42:21.597]                       invisible(muffled)
[17:42:21.597]                     }
[17:42:21.597]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.597]                   }
[17:42:21.597]                 }
[17:42:21.597]                 else {
[17:42:21.597]                   if (TRUE) {
[17:42:21.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.597]                     {
[17:42:21.597]                       inherits <- base::inherits
[17:42:21.597]                       invokeRestart <- base::invokeRestart
[17:42:21.597]                       is.null <- base::is.null
[17:42:21.597]                       muffled <- FALSE
[17:42:21.597]                       if (inherits(cond, "message")) {
[17:42:21.597]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.597]                         if (muffled) 
[17:42:21.597]                           invokeRestart("muffleMessage")
[17:42:21.597]                       }
[17:42:21.597]                       else if (inherits(cond, "warning")) {
[17:42:21.597]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.597]                         if (muffled) 
[17:42:21.597]                           invokeRestart("muffleWarning")
[17:42:21.597]                       }
[17:42:21.597]                       else if (inherits(cond, "condition")) {
[17:42:21.597]                         if (!is.null(pattern)) {
[17:42:21.597]                           computeRestarts <- base::computeRestarts
[17:42:21.597]                           grepl <- base::grepl
[17:42:21.597]                           restarts <- computeRestarts(cond)
[17:42:21.597]                           for (restart in restarts) {
[17:42:21.597]                             name <- restart$name
[17:42:21.597]                             if (is.null(name)) 
[17:42:21.597]                               next
[17:42:21.597]                             if (!grepl(pattern, name)) 
[17:42:21.597]                               next
[17:42:21.597]                             invokeRestart(restart)
[17:42:21.597]                             muffled <- TRUE
[17:42:21.597]                             break
[17:42:21.597]                           }
[17:42:21.597]                         }
[17:42:21.597]                       }
[17:42:21.597]                       invisible(muffled)
[17:42:21.597]                     }
[17:42:21.597]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.597]                   }
[17:42:21.597]                 }
[17:42:21.597]             }
[17:42:21.597]         }))
[17:42:21.597]     }, error = function(ex) {
[17:42:21.597]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.597]                 ...future.rng), started = ...future.startTime, 
[17:42:21.597]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.597]             version = "1.8"), class = "FutureResult")
[17:42:21.597]     }, finally = {
[17:42:21.597]         if (!identical(...future.workdir, getwd())) 
[17:42:21.597]             setwd(...future.workdir)
[17:42:21.597]         {
[17:42:21.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.597]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.597]             }
[17:42:21.597]             base::options(...future.oldOptions)
[17:42:21.597]             if (.Platform$OS.type == "windows") {
[17:42:21.597]                 old_names <- names(...future.oldEnvVars)
[17:42:21.597]                 envs <- base::Sys.getenv()
[17:42:21.597]                 names <- names(envs)
[17:42:21.597]                 common <- intersect(names, old_names)
[17:42:21.597]                 added <- setdiff(names, old_names)
[17:42:21.597]                 removed <- setdiff(old_names, names)
[17:42:21.597]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.597]                   envs[common]]
[17:42:21.597]                 NAMES <- toupper(changed)
[17:42:21.597]                 args <- list()
[17:42:21.597]                 for (kk in seq_along(NAMES)) {
[17:42:21.597]                   name <- changed[[kk]]
[17:42:21.597]                   NAME <- NAMES[[kk]]
[17:42:21.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.597]                     next
[17:42:21.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.597]                 }
[17:42:21.597]                 NAMES <- toupper(added)
[17:42:21.597]                 for (kk in seq_along(NAMES)) {
[17:42:21.597]                   name <- added[[kk]]
[17:42:21.597]                   NAME <- NAMES[[kk]]
[17:42:21.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.597]                     next
[17:42:21.597]                   args[[name]] <- ""
[17:42:21.597]                 }
[17:42:21.597]                 NAMES <- toupper(removed)
[17:42:21.597]                 for (kk in seq_along(NAMES)) {
[17:42:21.597]                   name <- removed[[kk]]
[17:42:21.597]                   NAME <- NAMES[[kk]]
[17:42:21.597]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.597]                     next
[17:42:21.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.597]                 }
[17:42:21.597]                 if (length(args) > 0) 
[17:42:21.597]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.597]             }
[17:42:21.597]             else {
[17:42:21.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.597]             }
[17:42:21.597]             {
[17:42:21.597]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.597]                   0L) {
[17:42:21.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.597]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.597]                   base::options(opts)
[17:42:21.597]                 }
[17:42:21.597]                 {
[17:42:21.597]                   {
[17:42:21.597]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.597]                     NULL
[17:42:21.597]                   }
[17:42:21.597]                   options(future.plan = NULL)
[17:42:21.597]                   if (is.na(NA_character_)) 
[17:42:21.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.597]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.597]                     envir = parent.frame()) 
[17:42:21.597]                   {
[17:42:21.597]                     default_workers <- missing(workers)
[17:42:21.597]                     if (is.function(workers)) 
[17:42:21.597]                       workers <- workers()
[17:42:21.597]                     workers <- structure(as.integer(workers), 
[17:42:21.597]                       class = class(workers))
[17:42:21.597]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.597]                       1L)
[17:42:21.597]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.597]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.597]                       if (default_workers) 
[17:42:21.597]                         supportsMulticore(warn = TRUE)
[17:42:21.597]                       return(sequential(..., envir = envir))
[17:42:21.597]                     }
[17:42:21.597]                     oopts <- options(mc.cores = workers)
[17:42:21.597]                     on.exit(options(oopts))
[17:42:21.597]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.597]                       envir = envir)
[17:42:21.597]                     if (!future$lazy) 
[17:42:21.597]                       future <- run(future)
[17:42:21.597]                     invisible(future)
[17:42:21.597]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.597]                 }
[17:42:21.597]             }
[17:42:21.597]         }
[17:42:21.597]     })
[17:42:21.597]     if (TRUE) {
[17:42:21.597]         base::sink(type = "output", split = FALSE)
[17:42:21.597]         if (TRUE) {
[17:42:21.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.597]         }
[17:42:21.597]         else {
[17:42:21.597]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.597]         }
[17:42:21.597]         base::close(...future.stdout)
[17:42:21.597]         ...future.stdout <- NULL
[17:42:21.597]     }
[17:42:21.597]     ...future.result$conditions <- ...future.conditions
[17:42:21.597]     ...future.result$finished <- base::Sys.time()
[17:42:21.597]     ...future.result
[17:42:21.597] }
[17:42:21.601] requestCore(): workers = 2
[17:42:21.601] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:21.628] MulticoreFuture started
[17:42:21.628] - Launch lazy future ... done
[17:42:21.629] run() for ‘MulticoreFuture’ ... done
[17:42:21.629] plan(): Setting new future strategy stack:
<environment: 0x55bef7e36db8> 
[17:42:21.629] List of future strategies:
[17:42:21.629] 1. sequential:
[17:42:21.629]    - args: function (..., envir = parent.frame())
[17:42:21.629]    - tweaked: FALSE
[17:42:21.629]    - call: NULL
[17:42:21.630] plan(): nbrOfWorkers() = 1
<environment: 0x55bef96bdcb8> 
[17:42:21.632] plan(): Setting new future strategy stack:
[17:42:21.632] List of future strategies:
[17:42:21.632] 1. multicore:
[17:42:21.632]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.632]    - tweaked: FALSE
[17:42:21.632]    - call: plan(strategy)
[17:42:21.638] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:21.641] resolve() on environment ...
[17:42:21.641]  recursive: 0
[17:42:21.642]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:21.642] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.642] - nx: 4
[17:42:21.642] - relay: TRUE
[17:42:21.642] - stdout: TRUE
[17:42:21.642] - signal: TRUE
[17:42:21.642] - resignal: FALSE
[17:42:21.643] - force: TRUE
[17:42:21.643] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.643] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.643]  - until=2
[17:42:21.643]  - relaying element #2
[17:42:21.643] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.643] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.644] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.644]  length: 3 (resolved future 1)
[17:42:21.644] Future #2
[17:42:21.644] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:21.644] - nx: 4
[17:42:21.644] - relay: TRUE
[17:42:21.645] - stdout: TRUE
[17:42:21.645] - signal: TRUE
[17:42:21.645] - resignal: FALSE
[17:42:21.645] - force: TRUE
[17:42:21.645] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.645] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.645]  - until=2
[17:42:21.645]  - relaying element #2
[17:42:21.646] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.646] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.646] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:21.646]  length: 2 (resolved future 2)
[17:42:21.646] Future #3
[17:42:21.647] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:21.648] - nx: 4
[17:42:21.648] - relay: TRUE
[17:42:21.648] - stdout: TRUE
[17:42:21.648] - signal: TRUE
[17:42:21.648] - resignal: FALSE
[17:42:21.648] - force: TRUE
[17:42:21.649] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.649] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.649]  - until=3
[17:42:21.649]  - relaying element #3
[17:42:21.650] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.650] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.650] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:21.650]  length: 1 (resolved future 3)
[17:42:21.650] Future #4
[17:42:21.651] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:21.652] - nx: 4
[17:42:21.652] - relay: TRUE
[17:42:21.652] - stdout: TRUE
[17:42:21.652] - signal: TRUE
[17:42:21.652] - resignal: FALSE
[17:42:21.652] - force: TRUE
[17:42:21.653] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.653] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.653]  - until=4
[17:42:21.653]  - relaying element #4
[17:42:21.653] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.653] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.653] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:21.653]  length: 0 (resolved future 4)
[17:42:21.654] Relaying remaining futures
[17:42:21.654] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.654] - nx: 4
[17:42:21.654] - relay: TRUE
[17:42:21.654] - stdout: TRUE
[17:42:21.654] - signal: TRUE
[17:42:21.654] - resignal: FALSE
[17:42:21.654] - force: TRUE
[17:42:21.654] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.654] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:21.655] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.655] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.655] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.655] resolve() on environment ... DONE
<environment: 0x55bef97f5508> 
Dimensions: c(2, 3)
[17:42:21.656] getGlobalsAndPackages() ...
[17:42:21.656] Searching for globals...
[17:42:21.656] 
[17:42:21.656] Searching for globals ... DONE
[17:42:21.656] - globals: [0] <none>
[17:42:21.657] getGlobalsAndPackages() ... DONE
[17:42:21.657] run() for ‘Future’ ...
[17:42:21.657] - state: ‘created’
[17:42:21.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.662]   - Field: ‘label’
[17:42:21.662]   - Field: ‘local’
[17:42:21.662]   - Field: ‘owner’
[17:42:21.662]   - Field: ‘envir’
[17:42:21.662]   - Field: ‘workers’
[17:42:21.662]   - Field: ‘packages’
[17:42:21.662]   - Field: ‘gc’
[17:42:21.662]   - Field: ‘job’
[17:42:21.662]   - Field: ‘conditions’
[17:42:21.663]   - Field: ‘expr’
[17:42:21.663]   - Field: ‘uuid’
[17:42:21.663]   - Field: ‘seed’
[17:42:21.663]   - Field: ‘version’
[17:42:21.663]   - Field: ‘result’
[17:42:21.663]   - Field: ‘asynchronous’
[17:42:21.663]   - Field: ‘calls’
[17:42:21.663]   - Field: ‘globals’
[17:42:21.663]   - Field: ‘stdout’
[17:42:21.664]   - Field: ‘earlySignal’
[17:42:21.664]   - Field: ‘lazy’
[17:42:21.664]   - Field: ‘state’
[17:42:21.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.664] - Launch lazy future ...
[17:42:21.664] Packages needed by the future expression (n = 0): <none>
[17:42:21.664] Packages needed by future strategies (n = 0): <none>
[17:42:21.665] {
[17:42:21.665]     {
[17:42:21.665]         {
[17:42:21.665]             ...future.startTime <- base::Sys.time()
[17:42:21.665]             {
[17:42:21.665]                 {
[17:42:21.665]                   {
[17:42:21.665]                     {
[17:42:21.665]                       base::local({
[17:42:21.665]                         has_future <- base::requireNamespace("future", 
[17:42:21.665]                           quietly = TRUE)
[17:42:21.665]                         if (has_future) {
[17:42:21.665]                           ns <- base::getNamespace("future")
[17:42:21.665]                           version <- ns[[".package"]][["version"]]
[17:42:21.665]                           if (is.null(version)) 
[17:42:21.665]                             version <- utils::packageVersion("future")
[17:42:21.665]                         }
[17:42:21.665]                         else {
[17:42:21.665]                           version <- NULL
[17:42:21.665]                         }
[17:42:21.665]                         if (!has_future || version < "1.8.0") {
[17:42:21.665]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.665]                             "", base::R.version$version.string), 
[17:42:21.665]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.665]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.665]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.665]                               "release", "version")], collapse = " "), 
[17:42:21.665]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.665]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.665]                             info)
[17:42:21.665]                           info <- base::paste(info, collapse = "; ")
[17:42:21.665]                           if (!has_future) {
[17:42:21.665]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.665]                               info)
[17:42:21.665]                           }
[17:42:21.665]                           else {
[17:42:21.665]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.665]                               info, version)
[17:42:21.665]                           }
[17:42:21.665]                           base::stop(msg)
[17:42:21.665]                         }
[17:42:21.665]                       })
[17:42:21.665]                     }
[17:42:21.665]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.665]                     base::options(mc.cores = 1L)
[17:42:21.665]                   }
[17:42:21.665]                   options(future.plan = NULL)
[17:42:21.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.665]                 }
[17:42:21.665]                 ...future.workdir <- getwd()
[17:42:21.665]             }
[17:42:21.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.665]         }
[17:42:21.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.665]             base::names(...future.oldOptions))
[17:42:21.665]     }
[17:42:21.665]     if (FALSE) {
[17:42:21.665]     }
[17:42:21.665]     else {
[17:42:21.665]         if (TRUE) {
[17:42:21.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.665]                 open = "w")
[17:42:21.665]         }
[17:42:21.665]         else {
[17:42:21.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.665]         }
[17:42:21.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.665]             base::sink(type = "output", split = FALSE)
[17:42:21.665]             base::close(...future.stdout)
[17:42:21.665]         }, add = TRUE)
[17:42:21.665]     }
[17:42:21.665]     ...future.frame <- base::sys.nframe()
[17:42:21.665]     ...future.conditions <- base::list()
[17:42:21.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.665]     if (FALSE) {
[17:42:21.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.665]     }
[17:42:21.665]     ...future.result <- base::tryCatch({
[17:42:21.665]         base::withCallingHandlers({
[17:42:21.665]             ...future.value <- base::withVisible(base::local({
[17:42:21.665]                 withCallingHandlers({
[17:42:21.665]                   2
[17:42:21.665]                 }, immediateCondition = function(cond) {
[17:42:21.665]                   save_rds <- function (object, pathname, ...) 
[17:42:21.665]                   {
[17:42:21.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.665]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.665]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.665]                         fi_tmp[["mtime"]])
[17:42:21.665]                     }
[17:42:21.665]                     tryCatch({
[17:42:21.665]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.665]                     }, error = function(ex) {
[17:42:21.665]                       msg <- conditionMessage(ex)
[17:42:21.665]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.665]                         fi_tmp[["mtime"]], msg)
[17:42:21.665]                       ex$message <- msg
[17:42:21.665]                       stop(ex)
[17:42:21.665]                     })
[17:42:21.665]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.665]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.665]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.665]                       fi <- file.info(pathname)
[17:42:21.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.665]                         fi[["size"]], fi[["mtime"]])
[17:42:21.665]                       stop(msg)
[17:42:21.665]                     }
[17:42:21.665]                     invisible(pathname)
[17:42:21.665]                   }
[17:42:21.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.665]                     rootPath = tempdir()) 
[17:42:21.665]                   {
[17:42:21.665]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.665]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.665]                       tmpdir = path, fileext = ".rds")
[17:42:21.665]                     save_rds(obj, file)
[17:42:21.665]                   }
[17:42:21.665]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.665]                   {
[17:42:21.665]                     inherits <- base::inherits
[17:42:21.665]                     invokeRestart <- base::invokeRestart
[17:42:21.665]                     is.null <- base::is.null
[17:42:21.665]                     muffled <- FALSE
[17:42:21.665]                     if (inherits(cond, "message")) {
[17:42:21.665]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.665]                       if (muffled) 
[17:42:21.665]                         invokeRestart("muffleMessage")
[17:42:21.665]                     }
[17:42:21.665]                     else if (inherits(cond, "warning")) {
[17:42:21.665]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.665]                       if (muffled) 
[17:42:21.665]                         invokeRestart("muffleWarning")
[17:42:21.665]                     }
[17:42:21.665]                     else if (inherits(cond, "condition")) {
[17:42:21.665]                       if (!is.null(pattern)) {
[17:42:21.665]                         computeRestarts <- base::computeRestarts
[17:42:21.665]                         grepl <- base::grepl
[17:42:21.665]                         restarts <- computeRestarts(cond)
[17:42:21.665]                         for (restart in restarts) {
[17:42:21.665]                           name <- restart$name
[17:42:21.665]                           if (is.null(name)) 
[17:42:21.665]                             next
[17:42:21.665]                           if (!grepl(pattern, name)) 
[17:42:21.665]                             next
[17:42:21.665]                           invokeRestart(restart)
[17:42:21.665]                           muffled <- TRUE
[17:42:21.665]                           break
[17:42:21.665]                         }
[17:42:21.665]                       }
[17:42:21.665]                     }
[17:42:21.665]                     invisible(muffled)
[17:42:21.665]                   }
[17:42:21.665]                   muffleCondition(cond)
[17:42:21.665]                 })
[17:42:21.665]             }))
[17:42:21.665]             future::FutureResult(value = ...future.value$value, 
[17:42:21.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.665]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.665]                     ...future.globalenv.names))
[17:42:21.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.665]         }, condition = base::local({
[17:42:21.665]             c <- base::c
[17:42:21.665]             inherits <- base::inherits
[17:42:21.665]             invokeRestart <- base::invokeRestart
[17:42:21.665]             length <- base::length
[17:42:21.665]             list <- base::list
[17:42:21.665]             seq.int <- base::seq.int
[17:42:21.665]             signalCondition <- base::signalCondition
[17:42:21.665]             sys.calls <- base::sys.calls
[17:42:21.665]             `[[` <- base::`[[`
[17:42:21.665]             `+` <- base::`+`
[17:42:21.665]             `<<-` <- base::`<<-`
[17:42:21.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.665]                   3L)]
[17:42:21.665]             }
[17:42:21.665]             function(cond) {
[17:42:21.665]                 is_error <- inherits(cond, "error")
[17:42:21.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.665]                   NULL)
[17:42:21.665]                 if (is_error) {
[17:42:21.665]                   sessionInformation <- function() {
[17:42:21.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.665]                       search = base::search(), system = base::Sys.info())
[17:42:21.665]                   }
[17:42:21.665]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.665]                     cond$call), session = sessionInformation(), 
[17:42:21.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.665]                   signalCondition(cond)
[17:42:21.665]                 }
[17:42:21.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.665]                 "immediateCondition"))) {
[17:42:21.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.665]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.665]                   if (TRUE && !signal) {
[17:42:21.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.665]                     {
[17:42:21.665]                       inherits <- base::inherits
[17:42:21.665]                       invokeRestart <- base::invokeRestart
[17:42:21.665]                       is.null <- base::is.null
[17:42:21.665]                       muffled <- FALSE
[17:42:21.665]                       if (inherits(cond, "message")) {
[17:42:21.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.665]                         if (muffled) 
[17:42:21.665]                           invokeRestart("muffleMessage")
[17:42:21.665]                       }
[17:42:21.665]                       else if (inherits(cond, "warning")) {
[17:42:21.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.665]                         if (muffled) 
[17:42:21.665]                           invokeRestart("muffleWarning")
[17:42:21.665]                       }
[17:42:21.665]                       else if (inherits(cond, "condition")) {
[17:42:21.665]                         if (!is.null(pattern)) {
[17:42:21.665]                           computeRestarts <- base::computeRestarts
[17:42:21.665]                           grepl <- base::grepl
[17:42:21.665]                           restarts <- computeRestarts(cond)
[17:42:21.665]                           for (restart in restarts) {
[17:42:21.665]                             name <- restart$name
[17:42:21.665]                             if (is.null(name)) 
[17:42:21.665]                               next
[17:42:21.665]                             if (!grepl(pattern, name)) 
[17:42:21.665]                               next
[17:42:21.665]                             invokeRestart(restart)
[17:42:21.665]                             muffled <- TRUE
[17:42:21.665]                             break
[17:42:21.665]                           }
[17:42:21.665]                         }
[17:42:21.665]                       }
[17:42:21.665]                       invisible(muffled)
[17:42:21.665]                     }
[17:42:21.665]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.665]                   }
[17:42:21.665]                 }
[17:42:21.665]                 else {
[17:42:21.665]                   if (TRUE) {
[17:42:21.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.665]                     {
[17:42:21.665]                       inherits <- base::inherits
[17:42:21.665]                       invokeRestart <- base::invokeRestart
[17:42:21.665]                       is.null <- base::is.null
[17:42:21.665]                       muffled <- FALSE
[17:42:21.665]                       if (inherits(cond, "message")) {
[17:42:21.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.665]                         if (muffled) 
[17:42:21.665]                           invokeRestart("muffleMessage")
[17:42:21.665]                       }
[17:42:21.665]                       else if (inherits(cond, "warning")) {
[17:42:21.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.665]                         if (muffled) 
[17:42:21.665]                           invokeRestart("muffleWarning")
[17:42:21.665]                       }
[17:42:21.665]                       else if (inherits(cond, "condition")) {
[17:42:21.665]                         if (!is.null(pattern)) {
[17:42:21.665]                           computeRestarts <- base::computeRestarts
[17:42:21.665]                           grepl <- base::grepl
[17:42:21.665]                           restarts <- computeRestarts(cond)
[17:42:21.665]                           for (restart in restarts) {
[17:42:21.665]                             name <- restart$name
[17:42:21.665]                             if (is.null(name)) 
[17:42:21.665]                               next
[17:42:21.665]                             if (!grepl(pattern, name)) 
[17:42:21.665]                               next
[17:42:21.665]                             invokeRestart(restart)
[17:42:21.665]                             muffled <- TRUE
[17:42:21.665]                             break
[17:42:21.665]                           }
[17:42:21.665]                         }
[17:42:21.665]                       }
[17:42:21.665]                       invisible(muffled)
[17:42:21.665]                     }
[17:42:21.665]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.665]                   }
[17:42:21.665]                 }
[17:42:21.665]             }
[17:42:21.665]         }))
[17:42:21.665]     }, error = function(ex) {
[17:42:21.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.665]                 ...future.rng), started = ...future.startTime, 
[17:42:21.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.665]             version = "1.8"), class = "FutureResult")
[17:42:21.665]     }, finally = {
[17:42:21.665]         if (!identical(...future.workdir, getwd())) 
[17:42:21.665]             setwd(...future.workdir)
[17:42:21.665]         {
[17:42:21.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.665]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.665]             }
[17:42:21.665]             base::options(...future.oldOptions)
[17:42:21.665]             if (.Platform$OS.type == "windows") {
[17:42:21.665]                 old_names <- names(...future.oldEnvVars)
[17:42:21.665]                 envs <- base::Sys.getenv()
[17:42:21.665]                 names <- names(envs)
[17:42:21.665]                 common <- intersect(names, old_names)
[17:42:21.665]                 added <- setdiff(names, old_names)
[17:42:21.665]                 removed <- setdiff(old_names, names)
[17:42:21.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.665]                   envs[common]]
[17:42:21.665]                 NAMES <- toupper(changed)
[17:42:21.665]                 args <- list()
[17:42:21.665]                 for (kk in seq_along(NAMES)) {
[17:42:21.665]                   name <- changed[[kk]]
[17:42:21.665]                   NAME <- NAMES[[kk]]
[17:42:21.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.665]                     next
[17:42:21.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.665]                 }
[17:42:21.665]                 NAMES <- toupper(added)
[17:42:21.665]                 for (kk in seq_along(NAMES)) {
[17:42:21.665]                   name <- added[[kk]]
[17:42:21.665]                   NAME <- NAMES[[kk]]
[17:42:21.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.665]                     next
[17:42:21.665]                   args[[name]] <- ""
[17:42:21.665]                 }
[17:42:21.665]                 NAMES <- toupper(removed)
[17:42:21.665]                 for (kk in seq_along(NAMES)) {
[17:42:21.665]                   name <- removed[[kk]]
[17:42:21.665]                   NAME <- NAMES[[kk]]
[17:42:21.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.665]                     next
[17:42:21.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.665]                 }
[17:42:21.665]                 if (length(args) > 0) 
[17:42:21.665]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.665]             }
[17:42:21.665]             else {
[17:42:21.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.665]             }
[17:42:21.665]             {
[17:42:21.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.665]                   0L) {
[17:42:21.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.665]                   base::options(opts)
[17:42:21.665]                 }
[17:42:21.665]                 {
[17:42:21.665]                   {
[17:42:21.665]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.665]                     NULL
[17:42:21.665]                   }
[17:42:21.665]                   options(future.plan = NULL)
[17:42:21.665]                   if (is.na(NA_character_)) 
[17:42:21.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.665]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.665]                     envir = parent.frame()) 
[17:42:21.665]                   {
[17:42:21.665]                     default_workers <- missing(workers)
[17:42:21.665]                     if (is.function(workers)) 
[17:42:21.665]                       workers <- workers()
[17:42:21.665]                     workers <- structure(as.integer(workers), 
[17:42:21.665]                       class = class(workers))
[17:42:21.665]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.665]                       1L)
[17:42:21.665]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.665]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.665]                       if (default_workers) 
[17:42:21.665]                         supportsMulticore(warn = TRUE)
[17:42:21.665]                       return(sequential(..., envir = envir))
[17:42:21.665]                     }
[17:42:21.665]                     oopts <- options(mc.cores = workers)
[17:42:21.665]                     on.exit(options(oopts))
[17:42:21.665]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.665]                       envir = envir)
[17:42:21.665]                     if (!future$lazy) 
[17:42:21.665]                       future <- run(future)
[17:42:21.665]                     invisible(future)
[17:42:21.665]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.665]                 }
[17:42:21.665]             }
[17:42:21.665]         }
[17:42:21.665]     })
[17:42:21.665]     if (TRUE) {
[17:42:21.665]         base::sink(type = "output", split = FALSE)
[17:42:21.665]         if (TRUE) {
[17:42:21.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.665]         }
[17:42:21.665]         else {
[17:42:21.665]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.665]         }
[17:42:21.665]         base::close(...future.stdout)
[17:42:21.665]         ...future.stdout <- NULL
[17:42:21.665]     }
[17:42:21.665]     ...future.result$conditions <- ...future.conditions
[17:42:21.665]     ...future.result$finished <- base::Sys.time()
[17:42:21.665]     ...future.result
[17:42:21.665] }
[17:42:21.668] requestCore(): workers = 2
[17:42:21.671] MulticoreFuture started
[17:42:21.671] - Launch lazy future ... done
[17:42:21.671] run() for ‘MulticoreFuture’ ... done
[17:42:21.672] getGlobalsAndPackages() ...
[17:42:21.672] Searching for globals...
[17:42:21.672] plan(): Setting new future strategy stack:
[17:42:21.673] 
[17:42:21.673] Searching for globals ... DONE
[17:42:21.672] List of future strategies:
[17:42:21.672] 1. sequential:
[17:42:21.672]    - args: function (..., envir = parent.frame())
[17:42:21.672]    - tweaked: FALSE
[17:42:21.672]    - call: NULL
[17:42:21.673] - globals: [0] <none>
[17:42:21.673] getGlobalsAndPackages() ... DONE
[17:42:21.673] plan(): nbrOfWorkers() = 1
[17:42:21.674] run() for ‘Future’ ...
[17:42:21.674] - state: ‘created’
[17:42:21.674] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.675] plan(): Setting new future strategy stack:
[17:42:21.675] List of future strategies:
[17:42:21.675] 1. multicore:
[17:42:21.675]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.675]    - tweaked: FALSE
[17:42:21.675]    - call: plan(strategy)
[17:42:21.679] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.680]   - Field: ‘label’
[17:42:21.680]   - Field: ‘local’
[17:42:21.680] plan(): nbrOfWorkers() = 2
[17:42:21.680]   - Field: ‘owner’
[17:42:21.680]   - Field: ‘envir’
[17:42:21.680]   - Field: ‘workers’
[17:42:21.680]   - Field: ‘packages’
[17:42:21.681]   - Field: ‘gc’
[17:42:21.681]   - Field: ‘job’
[17:42:21.681]   - Field: ‘conditions’
[17:42:21.681]   - Field: ‘expr’
[17:42:21.681]   - Field: ‘uuid’
[17:42:21.681]   - Field: ‘seed’
[17:42:21.681]   - Field: ‘version’
[17:42:21.682]   - Field: ‘result’
[17:42:21.682]   - Field: ‘asynchronous’
[17:42:21.682]   - Field: ‘calls’
[17:42:21.682]   - Field: ‘globals’
[17:42:21.682]   - Field: ‘stdout’
[17:42:21.682]   - Field: ‘earlySignal’
[17:42:21.682]   - Field: ‘lazy’
[17:42:21.683]   - Field: ‘state’
[17:42:21.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.689] - Launch lazy future ...
[17:42:21.689] Packages needed by the future expression (n = 0): <none>
[17:42:21.689] Packages needed by future strategies (n = 0): <none>
[17:42:21.690] {
[17:42:21.690]     {
[17:42:21.690]         {
[17:42:21.690]             ...future.startTime <- base::Sys.time()
[17:42:21.690]             {
[17:42:21.690]                 {
[17:42:21.690]                   {
[17:42:21.690]                     {
[17:42:21.690]                       base::local({
[17:42:21.690]                         has_future <- base::requireNamespace("future", 
[17:42:21.690]                           quietly = TRUE)
[17:42:21.690]                         if (has_future) {
[17:42:21.690]                           ns <- base::getNamespace("future")
[17:42:21.690]                           version <- ns[[".package"]][["version"]]
[17:42:21.690]                           if (is.null(version)) 
[17:42:21.690]                             version <- utils::packageVersion("future")
[17:42:21.690]                         }
[17:42:21.690]                         else {
[17:42:21.690]                           version <- NULL
[17:42:21.690]                         }
[17:42:21.690]                         if (!has_future || version < "1.8.0") {
[17:42:21.690]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.690]                             "", base::R.version$version.string), 
[17:42:21.690]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.690]                               "release", "version")], collapse = " "), 
[17:42:21.690]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.690]                             info)
[17:42:21.690]                           info <- base::paste(info, collapse = "; ")
[17:42:21.690]                           if (!has_future) {
[17:42:21.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.690]                               info)
[17:42:21.690]                           }
[17:42:21.690]                           else {
[17:42:21.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.690]                               info, version)
[17:42:21.690]                           }
[17:42:21.690]                           base::stop(msg)
[17:42:21.690]                         }
[17:42:21.690]                       })
[17:42:21.690]                     }
[17:42:21.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.690]                     base::options(mc.cores = 1L)
[17:42:21.690]                   }
[17:42:21.690]                   options(future.plan = NULL)
[17:42:21.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.690]                 }
[17:42:21.690]                 ...future.workdir <- getwd()
[17:42:21.690]             }
[17:42:21.690]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.690]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.690]         }
[17:42:21.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.690]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.690]             base::names(...future.oldOptions))
[17:42:21.690]     }
[17:42:21.690]     if (FALSE) {
[17:42:21.690]     }
[17:42:21.690]     else {
[17:42:21.690]         if (TRUE) {
[17:42:21.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.690]                 open = "w")
[17:42:21.690]         }
[17:42:21.690]         else {
[17:42:21.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.690]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.690]         }
[17:42:21.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.690]             base::sink(type = "output", split = FALSE)
[17:42:21.690]             base::close(...future.stdout)
[17:42:21.690]         }, add = TRUE)
[17:42:21.690]     }
[17:42:21.690]     ...future.frame <- base::sys.nframe()
[17:42:21.690]     ...future.conditions <- base::list()
[17:42:21.690]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.690]     if (FALSE) {
[17:42:21.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.690]     }
[17:42:21.690]     ...future.result <- base::tryCatch({
[17:42:21.690]         base::withCallingHandlers({
[17:42:21.690]             ...future.value <- base::withVisible(base::local({
[17:42:21.690]                 withCallingHandlers({
[17:42:21.690]                   NULL
[17:42:21.690]                 }, immediateCondition = function(cond) {
[17:42:21.690]                   save_rds <- function (object, pathname, ...) 
[17:42:21.690]                   {
[17:42:21.690]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.690]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.690]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.690]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.690]                         fi_tmp[["mtime"]])
[17:42:21.690]                     }
[17:42:21.690]                     tryCatch({
[17:42:21.690]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.690]                     }, error = function(ex) {
[17:42:21.690]                       msg <- conditionMessage(ex)
[17:42:21.690]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.690]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.690]                         fi_tmp[["mtime"]], msg)
[17:42:21.690]                       ex$message <- msg
[17:42:21.690]                       stop(ex)
[17:42:21.690]                     })
[17:42:21.690]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.690]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.690]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.690]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.690]                       fi <- file.info(pathname)
[17:42:21.690]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.690]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.690]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.690]                         fi[["size"]], fi[["mtime"]])
[17:42:21.690]                       stop(msg)
[17:42:21.690]                     }
[17:42:21.690]                     invisible(pathname)
[17:42:21.690]                   }
[17:42:21.690]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.690]                     rootPath = tempdir()) 
[17:42:21.690]                   {
[17:42:21.690]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.690]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.690]                       tmpdir = path, fileext = ".rds")
[17:42:21.690]                     save_rds(obj, file)
[17:42:21.690]                   }
[17:42:21.690]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.690]                   {
[17:42:21.690]                     inherits <- base::inherits
[17:42:21.690]                     invokeRestart <- base::invokeRestart
[17:42:21.690]                     is.null <- base::is.null
[17:42:21.690]                     muffled <- FALSE
[17:42:21.690]                     if (inherits(cond, "message")) {
[17:42:21.690]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.690]                       if (muffled) 
[17:42:21.690]                         invokeRestart("muffleMessage")
[17:42:21.690]                     }
[17:42:21.690]                     else if (inherits(cond, "warning")) {
[17:42:21.690]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.690]                       if (muffled) 
[17:42:21.690]                         invokeRestart("muffleWarning")
[17:42:21.690]                     }
[17:42:21.690]                     else if (inherits(cond, "condition")) {
[17:42:21.690]                       if (!is.null(pattern)) {
[17:42:21.690]                         computeRestarts <- base::computeRestarts
[17:42:21.690]                         grepl <- base::grepl
[17:42:21.690]                         restarts <- computeRestarts(cond)
[17:42:21.690]                         for (restart in restarts) {
[17:42:21.690]                           name <- restart$name
[17:42:21.690]                           if (is.null(name)) 
[17:42:21.690]                             next
[17:42:21.690]                           if (!grepl(pattern, name)) 
[17:42:21.690]                             next
[17:42:21.690]                           invokeRestart(restart)
[17:42:21.690]                           muffled <- TRUE
[17:42:21.690]                           break
[17:42:21.690]                         }
[17:42:21.690]                       }
[17:42:21.690]                     }
[17:42:21.690]                     invisible(muffled)
[17:42:21.690]                   }
[17:42:21.690]                   muffleCondition(cond)
[17:42:21.690]                 })
[17:42:21.690]             }))
[17:42:21.690]             future::FutureResult(value = ...future.value$value, 
[17:42:21.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.690]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.690]                     ...future.globalenv.names))
[17:42:21.690]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.690]         }, condition = base::local({
[17:42:21.690]             c <- base::c
[17:42:21.690]             inherits <- base::inherits
[17:42:21.690]             invokeRestart <- base::invokeRestart
[17:42:21.690]             length <- base::length
[17:42:21.690]             list <- base::list
[17:42:21.690]             seq.int <- base::seq.int
[17:42:21.690]             signalCondition <- base::signalCondition
[17:42:21.690]             sys.calls <- base::sys.calls
[17:42:21.690]             `[[` <- base::`[[`
[17:42:21.690]             `+` <- base::`+`
[17:42:21.690]             `<<-` <- base::`<<-`
[17:42:21.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.690]                   3L)]
[17:42:21.690]             }
[17:42:21.690]             function(cond) {
[17:42:21.690]                 is_error <- inherits(cond, "error")
[17:42:21.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.690]                   NULL)
[17:42:21.690]                 if (is_error) {
[17:42:21.690]                   sessionInformation <- function() {
[17:42:21.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.690]                       search = base::search(), system = base::Sys.info())
[17:42:21.690]                   }
[17:42:21.690]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.690]                     cond$call), session = sessionInformation(), 
[17:42:21.690]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.690]                   signalCondition(cond)
[17:42:21.690]                 }
[17:42:21.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.690]                 "immediateCondition"))) {
[17:42:21.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.690]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.690]                   if (TRUE && !signal) {
[17:42:21.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.690]                     {
[17:42:21.690]                       inherits <- base::inherits
[17:42:21.690]                       invokeRestart <- base::invokeRestart
[17:42:21.690]                       is.null <- base::is.null
[17:42:21.690]                       muffled <- FALSE
[17:42:21.690]                       if (inherits(cond, "message")) {
[17:42:21.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.690]                         if (muffled) 
[17:42:21.690]                           invokeRestart("muffleMessage")
[17:42:21.690]                       }
[17:42:21.690]                       else if (inherits(cond, "warning")) {
[17:42:21.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.690]                         if (muffled) 
[17:42:21.690]                           invokeRestart("muffleWarning")
[17:42:21.690]                       }
[17:42:21.690]                       else if (inherits(cond, "condition")) {
[17:42:21.690]                         if (!is.null(pattern)) {
[17:42:21.690]                           computeRestarts <- base::computeRestarts
[17:42:21.690]                           grepl <- base::grepl
[17:42:21.690]                           restarts <- computeRestarts(cond)
[17:42:21.690]                           for (restart in restarts) {
[17:42:21.690]                             name <- restart$name
[17:42:21.690]                             if (is.null(name)) 
[17:42:21.690]                               next
[17:42:21.690]                             if (!grepl(pattern, name)) 
[17:42:21.690]                               next
[17:42:21.690]                             invokeRestart(restart)
[17:42:21.690]                             muffled <- TRUE
[17:42:21.690]                             break
[17:42:21.690]                           }
[17:42:21.690]                         }
[17:42:21.690]                       }
[17:42:21.690]                       invisible(muffled)
[17:42:21.690]                     }
[17:42:21.690]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.690]                   }
[17:42:21.690]                 }
[17:42:21.690]                 else {
[17:42:21.690]                   if (TRUE) {
[17:42:21.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.690]                     {
[17:42:21.690]                       inherits <- base::inherits
[17:42:21.690]                       invokeRestart <- base::invokeRestart
[17:42:21.690]                       is.null <- base::is.null
[17:42:21.690]                       muffled <- FALSE
[17:42:21.690]                       if (inherits(cond, "message")) {
[17:42:21.690]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.690]                         if (muffled) 
[17:42:21.690]                           invokeRestart("muffleMessage")
[17:42:21.690]                       }
[17:42:21.690]                       else if (inherits(cond, "warning")) {
[17:42:21.690]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.690]                         if (muffled) 
[17:42:21.690]                           invokeRestart("muffleWarning")
[17:42:21.690]                       }
[17:42:21.690]                       else if (inherits(cond, "condition")) {
[17:42:21.690]                         if (!is.null(pattern)) {
[17:42:21.690]                           computeRestarts <- base::computeRestarts
[17:42:21.690]                           grepl <- base::grepl
[17:42:21.690]                           restarts <- computeRestarts(cond)
[17:42:21.690]                           for (restart in restarts) {
[17:42:21.690]                             name <- restart$name
[17:42:21.690]                             if (is.null(name)) 
[17:42:21.690]                               next
[17:42:21.690]                             if (!grepl(pattern, name)) 
[17:42:21.690]                               next
[17:42:21.690]                             invokeRestart(restart)
[17:42:21.690]                             muffled <- TRUE
[17:42:21.690]                             break
[17:42:21.690]                           }
[17:42:21.690]                         }
[17:42:21.690]                       }
[17:42:21.690]                       invisible(muffled)
[17:42:21.690]                     }
[17:42:21.690]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.690]                   }
[17:42:21.690]                 }
[17:42:21.690]             }
[17:42:21.690]         }))
[17:42:21.690]     }, error = function(ex) {
[17:42:21.690]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.690]                 ...future.rng), started = ...future.startTime, 
[17:42:21.690]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.690]             version = "1.8"), class = "FutureResult")
[17:42:21.690]     }, finally = {
[17:42:21.690]         if (!identical(...future.workdir, getwd())) 
[17:42:21.690]             setwd(...future.workdir)
[17:42:21.690]         {
[17:42:21.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.690]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.690]             }
[17:42:21.690]             base::options(...future.oldOptions)
[17:42:21.690]             if (.Platform$OS.type == "windows") {
[17:42:21.690]                 old_names <- names(...future.oldEnvVars)
[17:42:21.690]                 envs <- base::Sys.getenv()
[17:42:21.690]                 names <- names(envs)
[17:42:21.690]                 common <- intersect(names, old_names)
[17:42:21.690]                 added <- setdiff(names, old_names)
[17:42:21.690]                 removed <- setdiff(old_names, names)
[17:42:21.690]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.690]                   envs[common]]
[17:42:21.690]                 NAMES <- toupper(changed)
[17:42:21.690]                 args <- list()
[17:42:21.690]                 for (kk in seq_along(NAMES)) {
[17:42:21.690]                   name <- changed[[kk]]
[17:42:21.690]                   NAME <- NAMES[[kk]]
[17:42:21.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.690]                     next
[17:42:21.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.690]                 }
[17:42:21.690]                 NAMES <- toupper(added)
[17:42:21.690]                 for (kk in seq_along(NAMES)) {
[17:42:21.690]                   name <- added[[kk]]
[17:42:21.690]                   NAME <- NAMES[[kk]]
[17:42:21.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.690]                     next
[17:42:21.690]                   args[[name]] <- ""
[17:42:21.690]                 }
[17:42:21.690]                 NAMES <- toupper(removed)
[17:42:21.690]                 for (kk in seq_along(NAMES)) {
[17:42:21.690]                   name <- removed[[kk]]
[17:42:21.690]                   NAME <- NAMES[[kk]]
[17:42:21.690]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.690]                     next
[17:42:21.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.690]                 }
[17:42:21.690]                 if (length(args) > 0) 
[17:42:21.690]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.690]             }
[17:42:21.690]             else {
[17:42:21.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.690]             }
[17:42:21.690]             {
[17:42:21.690]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.690]                   0L) {
[17:42:21.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.690]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.690]                   base::options(opts)
[17:42:21.690]                 }
[17:42:21.690]                 {
[17:42:21.690]                   {
[17:42:21.690]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.690]                     NULL
[17:42:21.690]                   }
[17:42:21.690]                   options(future.plan = NULL)
[17:42:21.690]                   if (is.na(NA_character_)) 
[17:42:21.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.690]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.690]                     envir = parent.frame()) 
[17:42:21.690]                   {
[17:42:21.690]                     default_workers <- missing(workers)
[17:42:21.690]                     if (is.function(workers)) 
[17:42:21.690]                       workers <- workers()
[17:42:21.690]                     workers <- structure(as.integer(workers), 
[17:42:21.690]                       class = class(workers))
[17:42:21.690]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.690]                       1L)
[17:42:21.690]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.690]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.690]                       if (default_workers) 
[17:42:21.690]                         supportsMulticore(warn = TRUE)
[17:42:21.690]                       return(sequential(..., envir = envir))
[17:42:21.690]                     }
[17:42:21.690]                     oopts <- options(mc.cores = workers)
[17:42:21.690]                     on.exit(options(oopts))
[17:42:21.690]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.690]                       envir = envir)
[17:42:21.690]                     if (!future$lazy) 
[17:42:21.690]                       future <- run(future)
[17:42:21.690]                     invisible(future)
[17:42:21.690]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.690]                 }
[17:42:21.690]             }
[17:42:21.690]         }
[17:42:21.690]     })
[17:42:21.690]     if (TRUE) {
[17:42:21.690]         base::sink(type = "output", split = FALSE)
[17:42:21.690]         if (TRUE) {
[17:42:21.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.690]         }
[17:42:21.690]         else {
[17:42:21.690]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.690]         }
[17:42:21.690]         base::close(...future.stdout)
[17:42:21.690]         ...future.stdout <- NULL
[17:42:21.690]     }
[17:42:21.690]     ...future.result$conditions <- ...future.conditions
[17:42:21.690]     ...future.result$finished <- base::Sys.time()
[17:42:21.690]     ...future.result
[17:42:21.690] }
[17:42:21.693] requestCore(): workers = 2
[17:42:21.696] MulticoreFuture started
[17:42:21.696] - Launch lazy future ... done
[17:42:21.696] run() for ‘MulticoreFuture’ ... done
[17:42:21.697] plan(): Setting new future strategy stack:
[17:42:21.698] getGlobalsAndPackages() ...
[17:42:21.698] Searching for globals...
[17:42:21.697] List of future strategies:
[17:42:21.697] 1. sequential:
[17:42:21.697]    - args: function (..., envir = parent.frame())
[17:42:21.697]    - tweaked: FALSE
[17:42:21.697]    - call: NULL
[17:42:21.699] plan(): nbrOfWorkers() = 1
[17:42:21.700] - globals found: [1] ‘{’
[17:42:21.700] Searching for globals ... DONE
[17:42:21.700] Resolving globals: FALSE
[17:42:21.701] 
[17:42:21.701] 
[17:42:21.701] plan(): Setting new future strategy stack:
[17:42:21.701] getGlobalsAndPackages() ... DONE
[17:42:21.702] List of future strategies:
[17:42:21.702] 1. multicore:
[17:42:21.702]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.702]    - tweaked: FALSE
[17:42:21.702]    - call: plan(strategy)
[17:42:21.702] run() for ‘Future’ ...
[17:42:21.702] - state: ‘created’
[17:42:21.703] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.708] plan(): nbrOfWorkers() = 2
[17:42:21.708] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.708] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.709]   - Field: ‘label’
[17:42:21.709]   - Field: ‘local’
[17:42:21.709]   - Field: ‘owner’
[17:42:21.709]   - Field: ‘envir’
[17:42:21.709]   - Field: ‘workers’
[17:42:21.709]   - Field: ‘packages’
[17:42:21.710]   - Field: ‘gc’
[17:42:21.710]   - Field: ‘job’
[17:42:21.710]   - Field: ‘conditions’
[17:42:21.710]   - Field: ‘expr’
[17:42:21.710]   - Field: ‘uuid’
[17:42:21.710]   - Field: ‘seed’
[17:42:21.710]   - Field: ‘version’
[17:42:21.711]   - Field: ‘result’
[17:42:21.711]   - Field: ‘asynchronous’
[17:42:21.711]   - Field: ‘calls’
[17:42:21.711]   - Field: ‘globals’
[17:42:21.711]   - Field: ‘stdout’
[17:42:21.711]   - Field: ‘earlySignal’
[17:42:21.712]   - Field: ‘lazy’
[17:42:21.712]   - Field: ‘state’
[17:42:21.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.712] - Launch lazy future ...
[17:42:21.712] Packages needed by the future expression (n = 0): <none>
[17:42:21.713] Packages needed by future strategies (n = 0): <none>
[17:42:21.713] {
[17:42:21.713]     {
[17:42:21.713]         {
[17:42:21.713]             ...future.startTime <- base::Sys.time()
[17:42:21.713]             {
[17:42:21.713]                 {
[17:42:21.713]                   {
[17:42:21.713]                     {
[17:42:21.713]                       base::local({
[17:42:21.713]                         has_future <- base::requireNamespace("future", 
[17:42:21.713]                           quietly = TRUE)
[17:42:21.713]                         if (has_future) {
[17:42:21.713]                           ns <- base::getNamespace("future")
[17:42:21.713]                           version <- ns[[".package"]][["version"]]
[17:42:21.713]                           if (is.null(version)) 
[17:42:21.713]                             version <- utils::packageVersion("future")
[17:42:21.713]                         }
[17:42:21.713]                         else {
[17:42:21.713]                           version <- NULL
[17:42:21.713]                         }
[17:42:21.713]                         if (!has_future || version < "1.8.0") {
[17:42:21.713]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.713]                             "", base::R.version$version.string), 
[17:42:21.713]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.713]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.713]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.713]                               "release", "version")], collapse = " "), 
[17:42:21.713]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.713]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.713]                             info)
[17:42:21.713]                           info <- base::paste(info, collapse = "; ")
[17:42:21.713]                           if (!has_future) {
[17:42:21.713]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.713]                               info)
[17:42:21.713]                           }
[17:42:21.713]                           else {
[17:42:21.713]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.713]                               info, version)
[17:42:21.713]                           }
[17:42:21.713]                           base::stop(msg)
[17:42:21.713]                         }
[17:42:21.713]                       })
[17:42:21.713]                     }
[17:42:21.713]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.713]                     base::options(mc.cores = 1L)
[17:42:21.713]                   }
[17:42:21.713]                   options(future.plan = NULL)
[17:42:21.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.713]                 }
[17:42:21.713]                 ...future.workdir <- getwd()
[17:42:21.713]             }
[17:42:21.713]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.713]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.713]         }
[17:42:21.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.713]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.713]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.713]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.713]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.713]             base::names(...future.oldOptions))
[17:42:21.713]     }
[17:42:21.713]     if (FALSE) {
[17:42:21.713]     }
[17:42:21.713]     else {
[17:42:21.713]         if (TRUE) {
[17:42:21.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.713]                 open = "w")
[17:42:21.713]         }
[17:42:21.713]         else {
[17:42:21.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.713]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.713]         }
[17:42:21.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.713]             base::sink(type = "output", split = FALSE)
[17:42:21.713]             base::close(...future.stdout)
[17:42:21.713]         }, add = TRUE)
[17:42:21.713]     }
[17:42:21.713]     ...future.frame <- base::sys.nframe()
[17:42:21.713]     ...future.conditions <- base::list()
[17:42:21.713]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.713]     if (FALSE) {
[17:42:21.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.713]     }
[17:42:21.713]     ...future.result <- base::tryCatch({
[17:42:21.713]         base::withCallingHandlers({
[17:42:21.713]             ...future.value <- base::withVisible(base::local({
[17:42:21.713]                 withCallingHandlers({
[17:42:21.713]                   {
[17:42:21.713]                     4
[17:42:21.713]                   }
[17:42:21.713]                 }, immediateCondition = function(cond) {
[17:42:21.713]                   save_rds <- function (object, pathname, ...) 
[17:42:21.713]                   {
[17:42:21.713]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.713]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.713]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.713]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.713]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.713]                         fi_tmp[["mtime"]])
[17:42:21.713]                     }
[17:42:21.713]                     tryCatch({
[17:42:21.713]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.713]                     }, error = function(ex) {
[17:42:21.713]                       msg <- conditionMessage(ex)
[17:42:21.713]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.713]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.713]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.713]                         fi_tmp[["mtime"]], msg)
[17:42:21.713]                       ex$message <- msg
[17:42:21.713]                       stop(ex)
[17:42:21.713]                     })
[17:42:21.713]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.713]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.713]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.713]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.713]                       fi <- file.info(pathname)
[17:42:21.713]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.713]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.713]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.713]                         fi[["size"]], fi[["mtime"]])
[17:42:21.713]                       stop(msg)
[17:42:21.713]                     }
[17:42:21.713]                     invisible(pathname)
[17:42:21.713]                   }
[17:42:21.713]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.713]                     rootPath = tempdir()) 
[17:42:21.713]                   {
[17:42:21.713]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.713]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.713]                       tmpdir = path, fileext = ".rds")
[17:42:21.713]                     save_rds(obj, file)
[17:42:21.713]                   }
[17:42:21.713]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.713]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.713]                   {
[17:42:21.713]                     inherits <- base::inherits
[17:42:21.713]                     invokeRestart <- base::invokeRestart
[17:42:21.713]                     is.null <- base::is.null
[17:42:21.713]                     muffled <- FALSE
[17:42:21.713]                     if (inherits(cond, "message")) {
[17:42:21.713]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.713]                       if (muffled) 
[17:42:21.713]                         invokeRestart("muffleMessage")
[17:42:21.713]                     }
[17:42:21.713]                     else if (inherits(cond, "warning")) {
[17:42:21.713]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.713]                       if (muffled) 
[17:42:21.713]                         invokeRestart("muffleWarning")
[17:42:21.713]                     }
[17:42:21.713]                     else if (inherits(cond, "condition")) {
[17:42:21.713]                       if (!is.null(pattern)) {
[17:42:21.713]                         computeRestarts <- base::computeRestarts
[17:42:21.713]                         grepl <- base::grepl
[17:42:21.713]                         restarts <- computeRestarts(cond)
[17:42:21.713]                         for (restart in restarts) {
[17:42:21.713]                           name <- restart$name
[17:42:21.713]                           if (is.null(name)) 
[17:42:21.713]                             next
[17:42:21.713]                           if (!grepl(pattern, name)) 
[17:42:21.713]                             next
[17:42:21.713]                           invokeRestart(restart)
[17:42:21.713]                           muffled <- TRUE
[17:42:21.713]                           break
[17:42:21.713]                         }
[17:42:21.713]                       }
[17:42:21.713]                     }
[17:42:21.713]                     invisible(muffled)
[17:42:21.713]                   }
[17:42:21.713]                   muffleCondition(cond)
[17:42:21.713]                 })
[17:42:21.713]             }))
[17:42:21.713]             future::FutureResult(value = ...future.value$value, 
[17:42:21.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.713]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.713]                     ...future.globalenv.names))
[17:42:21.713]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.713]         }, condition = base::local({
[17:42:21.713]             c <- base::c
[17:42:21.713]             inherits <- base::inherits
[17:42:21.713]             invokeRestart <- base::invokeRestart
[17:42:21.713]             length <- base::length
[17:42:21.713]             list <- base::list
[17:42:21.713]             seq.int <- base::seq.int
[17:42:21.713]             signalCondition <- base::signalCondition
[17:42:21.713]             sys.calls <- base::sys.calls
[17:42:21.713]             `[[` <- base::`[[`
[17:42:21.713]             `+` <- base::`+`
[17:42:21.713]             `<<-` <- base::`<<-`
[17:42:21.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.713]                   3L)]
[17:42:21.713]             }
[17:42:21.713]             function(cond) {
[17:42:21.713]                 is_error <- inherits(cond, "error")
[17:42:21.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.713]                   NULL)
[17:42:21.713]                 if (is_error) {
[17:42:21.713]                   sessionInformation <- function() {
[17:42:21.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.713]                       search = base::search(), system = base::Sys.info())
[17:42:21.713]                   }
[17:42:21.713]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.713]                     cond$call), session = sessionInformation(), 
[17:42:21.713]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.713]                   signalCondition(cond)
[17:42:21.713]                 }
[17:42:21.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.713]                 "immediateCondition"))) {
[17:42:21.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.713]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.713]                   if (TRUE && !signal) {
[17:42:21.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.713]                     {
[17:42:21.713]                       inherits <- base::inherits
[17:42:21.713]                       invokeRestart <- base::invokeRestart
[17:42:21.713]                       is.null <- base::is.null
[17:42:21.713]                       muffled <- FALSE
[17:42:21.713]                       if (inherits(cond, "message")) {
[17:42:21.713]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.713]                         if (muffled) 
[17:42:21.713]                           invokeRestart("muffleMessage")
[17:42:21.713]                       }
[17:42:21.713]                       else if (inherits(cond, "warning")) {
[17:42:21.713]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.713]                         if (muffled) 
[17:42:21.713]                           invokeRestart("muffleWarning")
[17:42:21.713]                       }
[17:42:21.713]                       else if (inherits(cond, "condition")) {
[17:42:21.713]                         if (!is.null(pattern)) {
[17:42:21.713]                           computeRestarts <- base::computeRestarts
[17:42:21.713]                           grepl <- base::grepl
[17:42:21.713]                           restarts <- computeRestarts(cond)
[17:42:21.713]                           for (restart in restarts) {
[17:42:21.713]                             name <- restart$name
[17:42:21.713]                             if (is.null(name)) 
[17:42:21.713]                               next
[17:42:21.713]                             if (!grepl(pattern, name)) 
[17:42:21.713]                               next
[17:42:21.713]                             invokeRestart(restart)
[17:42:21.713]                             muffled <- TRUE
[17:42:21.713]                             break
[17:42:21.713]                           }
[17:42:21.713]                         }
[17:42:21.713]                       }
[17:42:21.713]                       invisible(muffled)
[17:42:21.713]                     }
[17:42:21.713]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.713]                   }
[17:42:21.713]                 }
[17:42:21.713]                 else {
[17:42:21.713]                   if (TRUE) {
[17:42:21.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.713]                     {
[17:42:21.713]                       inherits <- base::inherits
[17:42:21.713]                       invokeRestart <- base::invokeRestart
[17:42:21.713]                       is.null <- base::is.null
[17:42:21.713]                       muffled <- FALSE
[17:42:21.713]                       if (inherits(cond, "message")) {
[17:42:21.713]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.713]                         if (muffled) 
[17:42:21.713]                           invokeRestart("muffleMessage")
[17:42:21.713]                       }
[17:42:21.713]                       else if (inherits(cond, "warning")) {
[17:42:21.713]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.713]                         if (muffled) 
[17:42:21.713]                           invokeRestart("muffleWarning")
[17:42:21.713]                       }
[17:42:21.713]                       else if (inherits(cond, "condition")) {
[17:42:21.713]                         if (!is.null(pattern)) {
[17:42:21.713]                           computeRestarts <- base::computeRestarts
[17:42:21.713]                           grepl <- base::grepl
[17:42:21.713]                           restarts <- computeRestarts(cond)
[17:42:21.713]                           for (restart in restarts) {
[17:42:21.713]                             name <- restart$name
[17:42:21.713]                             if (is.null(name)) 
[17:42:21.713]                               next
[17:42:21.713]                             if (!grepl(pattern, name)) 
[17:42:21.713]                               next
[17:42:21.713]                             invokeRestart(restart)
[17:42:21.713]                             muffled <- TRUE
[17:42:21.713]                             break
[17:42:21.713]                           }
[17:42:21.713]                         }
[17:42:21.713]                       }
[17:42:21.713]                       invisible(muffled)
[17:42:21.713]                     }
[17:42:21.713]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.713]                   }
[17:42:21.713]                 }
[17:42:21.713]             }
[17:42:21.713]         }))
[17:42:21.713]     }, error = function(ex) {
[17:42:21.713]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.713]                 ...future.rng), started = ...future.startTime, 
[17:42:21.713]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.713]             version = "1.8"), class = "FutureResult")
[17:42:21.713]     }, finally = {
[17:42:21.713]         if (!identical(...future.workdir, getwd())) 
[17:42:21.713]             setwd(...future.workdir)
[17:42:21.713]         {
[17:42:21.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.713]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.713]             }
[17:42:21.713]             base::options(...future.oldOptions)
[17:42:21.713]             if (.Platform$OS.type == "windows") {
[17:42:21.713]                 old_names <- names(...future.oldEnvVars)
[17:42:21.713]                 envs <- base::Sys.getenv()
[17:42:21.713]                 names <- names(envs)
[17:42:21.713]                 common <- intersect(names, old_names)
[17:42:21.713]                 added <- setdiff(names, old_names)
[17:42:21.713]                 removed <- setdiff(old_names, names)
[17:42:21.713]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.713]                   envs[common]]
[17:42:21.713]                 NAMES <- toupper(changed)
[17:42:21.713]                 args <- list()
[17:42:21.713]                 for (kk in seq_along(NAMES)) {
[17:42:21.713]                   name <- changed[[kk]]
[17:42:21.713]                   NAME <- NAMES[[kk]]
[17:42:21.713]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.713]                     next
[17:42:21.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.713]                 }
[17:42:21.713]                 NAMES <- toupper(added)
[17:42:21.713]                 for (kk in seq_along(NAMES)) {
[17:42:21.713]                   name <- added[[kk]]
[17:42:21.713]                   NAME <- NAMES[[kk]]
[17:42:21.713]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.713]                     next
[17:42:21.713]                   args[[name]] <- ""
[17:42:21.713]                 }
[17:42:21.713]                 NAMES <- toupper(removed)
[17:42:21.713]                 for (kk in seq_along(NAMES)) {
[17:42:21.713]                   name <- removed[[kk]]
[17:42:21.713]                   NAME <- NAMES[[kk]]
[17:42:21.713]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.713]                     next
[17:42:21.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.713]                 }
[17:42:21.713]                 if (length(args) > 0) 
[17:42:21.713]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.713]             }
[17:42:21.713]             else {
[17:42:21.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.713]             }
[17:42:21.713]             {
[17:42:21.713]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.713]                   0L) {
[17:42:21.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.713]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.713]                   base::options(opts)
[17:42:21.713]                 }
[17:42:21.713]                 {
[17:42:21.713]                   {
[17:42:21.713]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.713]                     NULL
[17:42:21.713]                   }
[17:42:21.713]                   options(future.plan = NULL)
[17:42:21.713]                   if (is.na(NA_character_)) 
[17:42:21.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.713]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.713]                     envir = parent.frame()) 
[17:42:21.713]                   {
[17:42:21.713]                     default_workers <- missing(workers)
[17:42:21.713]                     if (is.function(workers)) 
[17:42:21.713]                       workers <- workers()
[17:42:21.713]                     workers <- structure(as.integer(workers), 
[17:42:21.713]                       class = class(workers))
[17:42:21.713]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.713]                       1L)
[17:42:21.713]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.713]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.713]                       if (default_workers) 
[17:42:21.713]                         supportsMulticore(warn = TRUE)
[17:42:21.713]                       return(sequential(..., envir = envir))
[17:42:21.713]                     }
[17:42:21.713]                     oopts <- options(mc.cores = workers)
[17:42:21.713]                     on.exit(options(oopts))
[17:42:21.713]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.713]                       envir = envir)
[17:42:21.713]                     if (!future$lazy) 
[17:42:21.713]                       future <- run(future)
[17:42:21.713]                     invisible(future)
[17:42:21.713]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.713]                 }
[17:42:21.713]             }
[17:42:21.713]         }
[17:42:21.713]     })
[17:42:21.713]     if (TRUE) {
[17:42:21.713]         base::sink(type = "output", split = FALSE)
[17:42:21.713]         if (TRUE) {
[17:42:21.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.713]         }
[17:42:21.713]         else {
[17:42:21.713]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.713]         }
[17:42:21.713]         base::close(...future.stdout)
[17:42:21.713]         ...future.stdout <- NULL
[17:42:21.713]     }
[17:42:21.713]     ...future.result$conditions <- ...future.conditions
[17:42:21.713]     ...future.result$finished <- base::Sys.time()
[17:42:21.713]     ...future.result
[17:42:21.713] }
[17:42:21.717] requestCore(): workers = 2
[17:42:21.718] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:21.733] MulticoreFuture started
[17:42:21.733] - Launch lazy future ... done
[17:42:21.733] run() for ‘MulticoreFuture’ ... done
[17:42:21.734] plan(): Setting new future strategy stack:
<environment: 0x55bef9cf0588> 
[17:42:21.734] List of future strategies:
[17:42:21.734] 1. sequential:
[17:42:21.734]    - args: function (..., envir = parent.frame())
[17:42:21.734]    - tweaked: FALSE
[17:42:21.734]    - call: NULL
[17:42:21.735] plan(): nbrOfWorkers() = 1
<environment: 0x55bef802ae28> 
[17:42:21.737] plan(): Setting new future strategy stack:
[17:42:21.737] List of future strategies:
[17:42:21.737] 1. multicore:
[17:42:21.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.737]    - tweaked: FALSE
[17:42:21.737]    - call: plan(strategy)
[17:42:21.743] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:21.745] resolve() on environment ...
[17:42:21.745]  recursive: 0
[17:42:21.746]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:21.746] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.746] - nx: 4
[17:42:21.747] - relay: TRUE
[17:42:21.747] - stdout: TRUE
[17:42:21.747] - signal: TRUE
[17:42:21.747] - resignal: FALSE
[17:42:21.747] - force: TRUE
[17:42:21.747] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.747] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.748]  - until=2
[17:42:21.748]  - relaying element #2
[17:42:21.748] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.748] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.748] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.748]  length: 3 (resolved future 1)
[17:42:21.749] Future #2
[17:42:21.749] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:21.749] - nx: 4
[17:42:21.749] - relay: TRUE
[17:42:21.749] - stdout: TRUE
[17:42:21.749] - signal: TRUE
[17:42:21.750] - resignal: FALSE
[17:42:21.750] - force: TRUE
[17:42:21.750] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.750] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.750]  - until=2
[17:42:21.750]  - relaying element #2
[17:42:21.751] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.751] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.751] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:21.751]  length: 2 (resolved future 2)
[17:42:21.751] Future #3
[17:42:21.753] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:21.753] - nx: 4
[17:42:21.753] - relay: TRUE
[17:42:21.753] - stdout: TRUE
[17:42:21.753] - signal: TRUE
[17:42:21.754] - resignal: FALSE
[17:42:21.754] - force: TRUE
[17:42:21.754] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.754] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.754]  - until=3
[17:42:21.755]  - relaying element #3
[17:42:21.755] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.755] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.755] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:21.756]  length: 1 (resolved future 3)
[17:42:21.756] Future #4
[17:42:21.757] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:21.757] - nx: 4
[17:42:21.757] - relay: TRUE
[17:42:21.758] - stdout: TRUE
[17:42:21.758] - signal: TRUE
[17:42:21.758] - resignal: FALSE
[17:42:21.758] - force: TRUE
[17:42:21.758] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.758] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.758]  - until=4
[17:42:21.758]  - relaying element #4
[17:42:21.759] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.759] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.759] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:21.759]  length: 0 (resolved future 4)
[17:42:21.759] Relaying remaining futures
[17:42:21.759] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.760] - nx: 4
[17:42:21.760] - relay: TRUE
[17:42:21.760] - stdout: TRUE
[17:42:21.760] - signal: TRUE
[17:42:21.760] - resignal: FALSE
[17:42:21.760] - force: TRUE
[17:42:21.760] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.760] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:21.761] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.761] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.761] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.761] resolve() on environment ... DONE
<environment: 0x55bef7f1d240> 
Dimensions: c(2, 3, 1)
[17:42:21.762] getGlobalsAndPackages() ...
[17:42:21.762] Searching for globals...
[17:42:21.762] 
[17:42:21.762] Searching for globals ... DONE
[17:42:21.763] - globals: [0] <none>
[17:42:21.763] getGlobalsAndPackages() ... DONE
[17:42:21.763] run() for ‘Future’ ...
[17:42:21.763] - state: ‘created’
[17:42:21.763] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.768] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.768]   - Field: ‘label’
[17:42:21.768]   - Field: ‘local’
[17:42:21.768]   - Field: ‘owner’
[17:42:21.768]   - Field: ‘envir’
[17:42:21.769]   - Field: ‘workers’
[17:42:21.769]   - Field: ‘packages’
[17:42:21.769]   - Field: ‘gc’
[17:42:21.769]   - Field: ‘job’
[17:42:21.769]   - Field: ‘conditions’
[17:42:21.769]   - Field: ‘expr’
[17:42:21.769]   - Field: ‘uuid’
[17:42:21.769]   - Field: ‘seed’
[17:42:21.770]   - Field: ‘version’
[17:42:21.770]   - Field: ‘result’
[17:42:21.770]   - Field: ‘asynchronous’
[17:42:21.770]   - Field: ‘calls’
[17:42:21.770]   - Field: ‘globals’
[17:42:21.770]   - Field: ‘stdout’
[17:42:21.770]   - Field: ‘earlySignal’
[17:42:21.770]   - Field: ‘lazy’
[17:42:21.770]   - Field: ‘state’
[17:42:21.771] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.771] - Launch lazy future ...
[17:42:21.771] Packages needed by the future expression (n = 0): <none>
[17:42:21.771] Packages needed by future strategies (n = 0): <none>
[17:42:21.772] {
[17:42:21.772]     {
[17:42:21.772]         {
[17:42:21.772]             ...future.startTime <- base::Sys.time()
[17:42:21.772]             {
[17:42:21.772]                 {
[17:42:21.772]                   {
[17:42:21.772]                     {
[17:42:21.772]                       base::local({
[17:42:21.772]                         has_future <- base::requireNamespace("future", 
[17:42:21.772]                           quietly = TRUE)
[17:42:21.772]                         if (has_future) {
[17:42:21.772]                           ns <- base::getNamespace("future")
[17:42:21.772]                           version <- ns[[".package"]][["version"]]
[17:42:21.772]                           if (is.null(version)) 
[17:42:21.772]                             version <- utils::packageVersion("future")
[17:42:21.772]                         }
[17:42:21.772]                         else {
[17:42:21.772]                           version <- NULL
[17:42:21.772]                         }
[17:42:21.772]                         if (!has_future || version < "1.8.0") {
[17:42:21.772]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.772]                             "", base::R.version$version.string), 
[17:42:21.772]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.772]                               "release", "version")], collapse = " "), 
[17:42:21.772]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.772]                             info)
[17:42:21.772]                           info <- base::paste(info, collapse = "; ")
[17:42:21.772]                           if (!has_future) {
[17:42:21.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.772]                               info)
[17:42:21.772]                           }
[17:42:21.772]                           else {
[17:42:21.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.772]                               info, version)
[17:42:21.772]                           }
[17:42:21.772]                           base::stop(msg)
[17:42:21.772]                         }
[17:42:21.772]                       })
[17:42:21.772]                     }
[17:42:21.772]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.772]                     base::options(mc.cores = 1L)
[17:42:21.772]                   }
[17:42:21.772]                   options(future.plan = NULL)
[17:42:21.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.772]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.772]                 }
[17:42:21.772]                 ...future.workdir <- getwd()
[17:42:21.772]             }
[17:42:21.772]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.772]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.772]         }
[17:42:21.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.772]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.772]             base::names(...future.oldOptions))
[17:42:21.772]     }
[17:42:21.772]     if (FALSE) {
[17:42:21.772]     }
[17:42:21.772]     else {
[17:42:21.772]         if (TRUE) {
[17:42:21.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.772]                 open = "w")
[17:42:21.772]         }
[17:42:21.772]         else {
[17:42:21.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.772]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.772]         }
[17:42:21.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.772]             base::sink(type = "output", split = FALSE)
[17:42:21.772]             base::close(...future.stdout)
[17:42:21.772]         }, add = TRUE)
[17:42:21.772]     }
[17:42:21.772]     ...future.frame <- base::sys.nframe()
[17:42:21.772]     ...future.conditions <- base::list()
[17:42:21.772]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.772]     if (FALSE) {
[17:42:21.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.772]     }
[17:42:21.772]     ...future.result <- base::tryCatch({
[17:42:21.772]         base::withCallingHandlers({
[17:42:21.772]             ...future.value <- base::withVisible(base::local({
[17:42:21.772]                 withCallingHandlers({
[17:42:21.772]                   2
[17:42:21.772]                 }, immediateCondition = function(cond) {
[17:42:21.772]                   save_rds <- function (object, pathname, ...) 
[17:42:21.772]                   {
[17:42:21.772]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.772]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.772]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.772]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.772]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.772]                         fi_tmp[["mtime"]])
[17:42:21.772]                     }
[17:42:21.772]                     tryCatch({
[17:42:21.772]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.772]                     }, error = function(ex) {
[17:42:21.772]                       msg <- conditionMessage(ex)
[17:42:21.772]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.772]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.772]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.772]                         fi_tmp[["mtime"]], msg)
[17:42:21.772]                       ex$message <- msg
[17:42:21.772]                       stop(ex)
[17:42:21.772]                     })
[17:42:21.772]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.772]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.772]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.772]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.772]                       fi <- file.info(pathname)
[17:42:21.772]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.772]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.772]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.772]                         fi[["size"]], fi[["mtime"]])
[17:42:21.772]                       stop(msg)
[17:42:21.772]                     }
[17:42:21.772]                     invisible(pathname)
[17:42:21.772]                   }
[17:42:21.772]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.772]                     rootPath = tempdir()) 
[17:42:21.772]                   {
[17:42:21.772]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.772]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.772]                       tmpdir = path, fileext = ".rds")
[17:42:21.772]                     save_rds(obj, file)
[17:42:21.772]                   }
[17:42:21.772]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.772]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.772]                   {
[17:42:21.772]                     inherits <- base::inherits
[17:42:21.772]                     invokeRestart <- base::invokeRestart
[17:42:21.772]                     is.null <- base::is.null
[17:42:21.772]                     muffled <- FALSE
[17:42:21.772]                     if (inherits(cond, "message")) {
[17:42:21.772]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.772]                       if (muffled) 
[17:42:21.772]                         invokeRestart("muffleMessage")
[17:42:21.772]                     }
[17:42:21.772]                     else if (inherits(cond, "warning")) {
[17:42:21.772]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.772]                       if (muffled) 
[17:42:21.772]                         invokeRestart("muffleWarning")
[17:42:21.772]                     }
[17:42:21.772]                     else if (inherits(cond, "condition")) {
[17:42:21.772]                       if (!is.null(pattern)) {
[17:42:21.772]                         computeRestarts <- base::computeRestarts
[17:42:21.772]                         grepl <- base::grepl
[17:42:21.772]                         restarts <- computeRestarts(cond)
[17:42:21.772]                         for (restart in restarts) {
[17:42:21.772]                           name <- restart$name
[17:42:21.772]                           if (is.null(name)) 
[17:42:21.772]                             next
[17:42:21.772]                           if (!grepl(pattern, name)) 
[17:42:21.772]                             next
[17:42:21.772]                           invokeRestart(restart)
[17:42:21.772]                           muffled <- TRUE
[17:42:21.772]                           break
[17:42:21.772]                         }
[17:42:21.772]                       }
[17:42:21.772]                     }
[17:42:21.772]                     invisible(muffled)
[17:42:21.772]                   }
[17:42:21.772]                   muffleCondition(cond)
[17:42:21.772]                 })
[17:42:21.772]             }))
[17:42:21.772]             future::FutureResult(value = ...future.value$value, 
[17:42:21.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.772]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.772]                     ...future.globalenv.names))
[17:42:21.772]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.772]         }, condition = base::local({
[17:42:21.772]             c <- base::c
[17:42:21.772]             inherits <- base::inherits
[17:42:21.772]             invokeRestart <- base::invokeRestart
[17:42:21.772]             length <- base::length
[17:42:21.772]             list <- base::list
[17:42:21.772]             seq.int <- base::seq.int
[17:42:21.772]             signalCondition <- base::signalCondition
[17:42:21.772]             sys.calls <- base::sys.calls
[17:42:21.772]             `[[` <- base::`[[`
[17:42:21.772]             `+` <- base::`+`
[17:42:21.772]             `<<-` <- base::`<<-`
[17:42:21.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.772]                   3L)]
[17:42:21.772]             }
[17:42:21.772]             function(cond) {
[17:42:21.772]                 is_error <- inherits(cond, "error")
[17:42:21.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.772]                   NULL)
[17:42:21.772]                 if (is_error) {
[17:42:21.772]                   sessionInformation <- function() {
[17:42:21.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.772]                       search = base::search(), system = base::Sys.info())
[17:42:21.772]                   }
[17:42:21.772]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.772]                     cond$call), session = sessionInformation(), 
[17:42:21.772]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.772]                   signalCondition(cond)
[17:42:21.772]                 }
[17:42:21.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.772]                 "immediateCondition"))) {
[17:42:21.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.772]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.772]                   if (TRUE && !signal) {
[17:42:21.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.772]                     {
[17:42:21.772]                       inherits <- base::inherits
[17:42:21.772]                       invokeRestart <- base::invokeRestart
[17:42:21.772]                       is.null <- base::is.null
[17:42:21.772]                       muffled <- FALSE
[17:42:21.772]                       if (inherits(cond, "message")) {
[17:42:21.772]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.772]                         if (muffled) 
[17:42:21.772]                           invokeRestart("muffleMessage")
[17:42:21.772]                       }
[17:42:21.772]                       else if (inherits(cond, "warning")) {
[17:42:21.772]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.772]                         if (muffled) 
[17:42:21.772]                           invokeRestart("muffleWarning")
[17:42:21.772]                       }
[17:42:21.772]                       else if (inherits(cond, "condition")) {
[17:42:21.772]                         if (!is.null(pattern)) {
[17:42:21.772]                           computeRestarts <- base::computeRestarts
[17:42:21.772]                           grepl <- base::grepl
[17:42:21.772]                           restarts <- computeRestarts(cond)
[17:42:21.772]                           for (restart in restarts) {
[17:42:21.772]                             name <- restart$name
[17:42:21.772]                             if (is.null(name)) 
[17:42:21.772]                               next
[17:42:21.772]                             if (!grepl(pattern, name)) 
[17:42:21.772]                               next
[17:42:21.772]                             invokeRestart(restart)
[17:42:21.772]                             muffled <- TRUE
[17:42:21.772]                             break
[17:42:21.772]                           }
[17:42:21.772]                         }
[17:42:21.772]                       }
[17:42:21.772]                       invisible(muffled)
[17:42:21.772]                     }
[17:42:21.772]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.772]                   }
[17:42:21.772]                 }
[17:42:21.772]                 else {
[17:42:21.772]                   if (TRUE) {
[17:42:21.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.772]                     {
[17:42:21.772]                       inherits <- base::inherits
[17:42:21.772]                       invokeRestart <- base::invokeRestart
[17:42:21.772]                       is.null <- base::is.null
[17:42:21.772]                       muffled <- FALSE
[17:42:21.772]                       if (inherits(cond, "message")) {
[17:42:21.772]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.772]                         if (muffled) 
[17:42:21.772]                           invokeRestart("muffleMessage")
[17:42:21.772]                       }
[17:42:21.772]                       else if (inherits(cond, "warning")) {
[17:42:21.772]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.772]                         if (muffled) 
[17:42:21.772]                           invokeRestart("muffleWarning")
[17:42:21.772]                       }
[17:42:21.772]                       else if (inherits(cond, "condition")) {
[17:42:21.772]                         if (!is.null(pattern)) {
[17:42:21.772]                           computeRestarts <- base::computeRestarts
[17:42:21.772]                           grepl <- base::grepl
[17:42:21.772]                           restarts <- computeRestarts(cond)
[17:42:21.772]                           for (restart in restarts) {
[17:42:21.772]                             name <- restart$name
[17:42:21.772]                             if (is.null(name)) 
[17:42:21.772]                               next
[17:42:21.772]                             if (!grepl(pattern, name)) 
[17:42:21.772]                               next
[17:42:21.772]                             invokeRestart(restart)
[17:42:21.772]                             muffled <- TRUE
[17:42:21.772]                             break
[17:42:21.772]                           }
[17:42:21.772]                         }
[17:42:21.772]                       }
[17:42:21.772]                       invisible(muffled)
[17:42:21.772]                     }
[17:42:21.772]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.772]                   }
[17:42:21.772]                 }
[17:42:21.772]             }
[17:42:21.772]         }))
[17:42:21.772]     }, error = function(ex) {
[17:42:21.772]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.772]                 ...future.rng), started = ...future.startTime, 
[17:42:21.772]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.772]             version = "1.8"), class = "FutureResult")
[17:42:21.772]     }, finally = {
[17:42:21.772]         if (!identical(...future.workdir, getwd())) 
[17:42:21.772]             setwd(...future.workdir)
[17:42:21.772]         {
[17:42:21.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.772]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.772]             }
[17:42:21.772]             base::options(...future.oldOptions)
[17:42:21.772]             if (.Platform$OS.type == "windows") {
[17:42:21.772]                 old_names <- names(...future.oldEnvVars)
[17:42:21.772]                 envs <- base::Sys.getenv()
[17:42:21.772]                 names <- names(envs)
[17:42:21.772]                 common <- intersect(names, old_names)
[17:42:21.772]                 added <- setdiff(names, old_names)
[17:42:21.772]                 removed <- setdiff(old_names, names)
[17:42:21.772]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.772]                   envs[common]]
[17:42:21.772]                 NAMES <- toupper(changed)
[17:42:21.772]                 args <- list()
[17:42:21.772]                 for (kk in seq_along(NAMES)) {
[17:42:21.772]                   name <- changed[[kk]]
[17:42:21.772]                   NAME <- NAMES[[kk]]
[17:42:21.772]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.772]                     next
[17:42:21.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.772]                 }
[17:42:21.772]                 NAMES <- toupper(added)
[17:42:21.772]                 for (kk in seq_along(NAMES)) {
[17:42:21.772]                   name <- added[[kk]]
[17:42:21.772]                   NAME <- NAMES[[kk]]
[17:42:21.772]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.772]                     next
[17:42:21.772]                   args[[name]] <- ""
[17:42:21.772]                 }
[17:42:21.772]                 NAMES <- toupper(removed)
[17:42:21.772]                 for (kk in seq_along(NAMES)) {
[17:42:21.772]                   name <- removed[[kk]]
[17:42:21.772]                   NAME <- NAMES[[kk]]
[17:42:21.772]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.772]                     next
[17:42:21.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.772]                 }
[17:42:21.772]                 if (length(args) > 0) 
[17:42:21.772]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.772]             }
[17:42:21.772]             else {
[17:42:21.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.772]             }
[17:42:21.772]             {
[17:42:21.772]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.772]                   0L) {
[17:42:21.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.772]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.772]                   base::options(opts)
[17:42:21.772]                 }
[17:42:21.772]                 {
[17:42:21.772]                   {
[17:42:21.772]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.772]                     NULL
[17:42:21.772]                   }
[17:42:21.772]                   options(future.plan = NULL)
[17:42:21.772]                   if (is.na(NA_character_)) 
[17:42:21.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.772]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.772]                     envir = parent.frame()) 
[17:42:21.772]                   {
[17:42:21.772]                     default_workers <- missing(workers)
[17:42:21.772]                     if (is.function(workers)) 
[17:42:21.772]                       workers <- workers()
[17:42:21.772]                     workers <- structure(as.integer(workers), 
[17:42:21.772]                       class = class(workers))
[17:42:21.772]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.772]                       1L)
[17:42:21.772]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.772]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.772]                       if (default_workers) 
[17:42:21.772]                         supportsMulticore(warn = TRUE)
[17:42:21.772]                       return(sequential(..., envir = envir))
[17:42:21.772]                     }
[17:42:21.772]                     oopts <- options(mc.cores = workers)
[17:42:21.772]                     on.exit(options(oopts))
[17:42:21.772]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.772]                       envir = envir)
[17:42:21.772]                     if (!future$lazy) 
[17:42:21.772]                       future <- run(future)
[17:42:21.772]                     invisible(future)
[17:42:21.772]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.772]                 }
[17:42:21.772]             }
[17:42:21.772]         }
[17:42:21.772]     })
[17:42:21.772]     if (TRUE) {
[17:42:21.772]         base::sink(type = "output", split = FALSE)
[17:42:21.772]         if (TRUE) {
[17:42:21.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.772]         }
[17:42:21.772]         else {
[17:42:21.772]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.772]         }
[17:42:21.772]         base::close(...future.stdout)
[17:42:21.772]         ...future.stdout <- NULL
[17:42:21.772]     }
[17:42:21.772]     ...future.result$conditions <- ...future.conditions
[17:42:21.772]     ...future.result$finished <- base::Sys.time()
[17:42:21.772]     ...future.result
[17:42:21.772] }
[17:42:21.775] requestCore(): workers = 2
[17:42:21.777] MulticoreFuture started
[17:42:21.778] - Launch lazy future ... done
[17:42:21.778] run() for ‘MulticoreFuture’ ... done
[17:42:21.778] getGlobalsAndPackages() ...
[17:42:21.778] Searching for globals...
[17:42:21.778] plan(): Setting new future strategy stack:
[17:42:21.779] 
[17:42:21.779] Searching for globals ... DONE
[17:42:21.779] List of future strategies:
[17:42:21.779] 1. sequential:
[17:42:21.779]    - args: function (..., envir = parent.frame())
[17:42:21.779]    - tweaked: FALSE
[17:42:21.779]    - call: NULL
[17:42:21.779] - globals: [0] <none>
[17:42:21.780] getGlobalsAndPackages() ... DONE
[17:42:21.780] plan(): nbrOfWorkers() = 1
[17:42:21.780] run() for ‘Future’ ...
[17:42:21.780] - state: ‘created’
[17:42:21.781] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.782] plan(): Setting new future strategy stack:
[17:42:21.782] List of future strategies:
[17:42:21.782] 1. multicore:
[17:42:21.782]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.782]    - tweaked: FALSE
[17:42:21.782]    - call: plan(strategy)
[17:42:21.787] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.787] plan(): nbrOfWorkers() = 2
[17:42:21.787]   - Field: ‘label’
[17:42:21.787]   - Field: ‘local’
[17:42:21.788]   - Field: ‘owner’
[17:42:21.788]   - Field: ‘envir’
[17:42:21.788]   - Field: ‘workers’
[17:42:21.788]   - Field: ‘packages’
[17:42:21.788]   - Field: ‘gc’
[17:42:21.788]   - Field: ‘job’
[17:42:21.788]   - Field: ‘conditions’
[17:42:21.789]   - Field: ‘expr’
[17:42:21.789]   - Field: ‘uuid’
[17:42:21.789]   - Field: ‘seed’
[17:42:21.789]   - Field: ‘version’
[17:42:21.789]   - Field: ‘result’
[17:42:21.789]   - Field: ‘asynchronous’
[17:42:21.789]   - Field: ‘calls’
[17:42:21.790]   - Field: ‘globals’
[17:42:21.790]   - Field: ‘stdout’
[17:42:21.790]   - Field: ‘earlySignal’
[17:42:21.790]   - Field: ‘lazy’
[17:42:21.790]   - Field: ‘state’
[17:42:21.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.790] - Launch lazy future ...
[17:42:21.791] Packages needed by the future expression (n = 0): <none>
[17:42:21.791] Packages needed by future strategies (n = 0): <none>
[17:42:21.792] {
[17:42:21.792]     {
[17:42:21.792]         {
[17:42:21.792]             ...future.startTime <- base::Sys.time()
[17:42:21.792]             {
[17:42:21.792]                 {
[17:42:21.792]                   {
[17:42:21.792]                     {
[17:42:21.792]                       base::local({
[17:42:21.792]                         has_future <- base::requireNamespace("future", 
[17:42:21.792]                           quietly = TRUE)
[17:42:21.792]                         if (has_future) {
[17:42:21.792]                           ns <- base::getNamespace("future")
[17:42:21.792]                           version <- ns[[".package"]][["version"]]
[17:42:21.792]                           if (is.null(version)) 
[17:42:21.792]                             version <- utils::packageVersion("future")
[17:42:21.792]                         }
[17:42:21.792]                         else {
[17:42:21.792]                           version <- NULL
[17:42:21.792]                         }
[17:42:21.792]                         if (!has_future || version < "1.8.0") {
[17:42:21.792]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.792]                             "", base::R.version$version.string), 
[17:42:21.792]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.792]                               "release", "version")], collapse = " "), 
[17:42:21.792]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.792]                             info)
[17:42:21.792]                           info <- base::paste(info, collapse = "; ")
[17:42:21.792]                           if (!has_future) {
[17:42:21.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.792]                               info)
[17:42:21.792]                           }
[17:42:21.792]                           else {
[17:42:21.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.792]                               info, version)
[17:42:21.792]                           }
[17:42:21.792]                           base::stop(msg)
[17:42:21.792]                         }
[17:42:21.792]                       })
[17:42:21.792]                     }
[17:42:21.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.792]                     base::options(mc.cores = 1L)
[17:42:21.792]                   }
[17:42:21.792]                   options(future.plan = NULL)
[17:42:21.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.792]                 }
[17:42:21.792]                 ...future.workdir <- getwd()
[17:42:21.792]             }
[17:42:21.792]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.792]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.792]         }
[17:42:21.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.792]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.792]             base::names(...future.oldOptions))
[17:42:21.792]     }
[17:42:21.792]     if (FALSE) {
[17:42:21.792]     }
[17:42:21.792]     else {
[17:42:21.792]         if (TRUE) {
[17:42:21.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.792]                 open = "w")
[17:42:21.792]         }
[17:42:21.792]         else {
[17:42:21.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.792]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.792]         }
[17:42:21.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.792]             base::sink(type = "output", split = FALSE)
[17:42:21.792]             base::close(...future.stdout)
[17:42:21.792]         }, add = TRUE)
[17:42:21.792]     }
[17:42:21.792]     ...future.frame <- base::sys.nframe()
[17:42:21.792]     ...future.conditions <- base::list()
[17:42:21.792]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.792]     if (FALSE) {
[17:42:21.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.792]     }
[17:42:21.792]     ...future.result <- base::tryCatch({
[17:42:21.792]         base::withCallingHandlers({
[17:42:21.792]             ...future.value <- base::withVisible(base::local({
[17:42:21.792]                 withCallingHandlers({
[17:42:21.792]                   NULL
[17:42:21.792]                 }, immediateCondition = function(cond) {
[17:42:21.792]                   save_rds <- function (object, pathname, ...) 
[17:42:21.792]                   {
[17:42:21.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.792]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.792]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.792]                         fi_tmp[["mtime"]])
[17:42:21.792]                     }
[17:42:21.792]                     tryCatch({
[17:42:21.792]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.792]                     }, error = function(ex) {
[17:42:21.792]                       msg <- conditionMessage(ex)
[17:42:21.792]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.792]                         fi_tmp[["mtime"]], msg)
[17:42:21.792]                       ex$message <- msg
[17:42:21.792]                       stop(ex)
[17:42:21.792]                     })
[17:42:21.792]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.792]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.792]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.792]                       fi <- file.info(pathname)
[17:42:21.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.792]                         fi[["size"]], fi[["mtime"]])
[17:42:21.792]                       stop(msg)
[17:42:21.792]                     }
[17:42:21.792]                     invisible(pathname)
[17:42:21.792]                   }
[17:42:21.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.792]                     rootPath = tempdir()) 
[17:42:21.792]                   {
[17:42:21.792]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.792]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.792]                       tmpdir = path, fileext = ".rds")
[17:42:21.792]                     save_rds(obj, file)
[17:42:21.792]                   }
[17:42:21.792]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.792]                   {
[17:42:21.792]                     inherits <- base::inherits
[17:42:21.792]                     invokeRestart <- base::invokeRestart
[17:42:21.792]                     is.null <- base::is.null
[17:42:21.792]                     muffled <- FALSE
[17:42:21.792]                     if (inherits(cond, "message")) {
[17:42:21.792]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.792]                       if (muffled) 
[17:42:21.792]                         invokeRestart("muffleMessage")
[17:42:21.792]                     }
[17:42:21.792]                     else if (inherits(cond, "warning")) {
[17:42:21.792]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.792]                       if (muffled) 
[17:42:21.792]                         invokeRestart("muffleWarning")
[17:42:21.792]                     }
[17:42:21.792]                     else if (inherits(cond, "condition")) {
[17:42:21.792]                       if (!is.null(pattern)) {
[17:42:21.792]                         computeRestarts <- base::computeRestarts
[17:42:21.792]                         grepl <- base::grepl
[17:42:21.792]                         restarts <- computeRestarts(cond)
[17:42:21.792]                         for (restart in restarts) {
[17:42:21.792]                           name <- restart$name
[17:42:21.792]                           if (is.null(name)) 
[17:42:21.792]                             next
[17:42:21.792]                           if (!grepl(pattern, name)) 
[17:42:21.792]                             next
[17:42:21.792]                           invokeRestart(restart)
[17:42:21.792]                           muffled <- TRUE
[17:42:21.792]                           break
[17:42:21.792]                         }
[17:42:21.792]                       }
[17:42:21.792]                     }
[17:42:21.792]                     invisible(muffled)
[17:42:21.792]                   }
[17:42:21.792]                   muffleCondition(cond)
[17:42:21.792]                 })
[17:42:21.792]             }))
[17:42:21.792]             future::FutureResult(value = ...future.value$value, 
[17:42:21.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.792]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.792]                     ...future.globalenv.names))
[17:42:21.792]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.792]         }, condition = base::local({
[17:42:21.792]             c <- base::c
[17:42:21.792]             inherits <- base::inherits
[17:42:21.792]             invokeRestart <- base::invokeRestart
[17:42:21.792]             length <- base::length
[17:42:21.792]             list <- base::list
[17:42:21.792]             seq.int <- base::seq.int
[17:42:21.792]             signalCondition <- base::signalCondition
[17:42:21.792]             sys.calls <- base::sys.calls
[17:42:21.792]             `[[` <- base::`[[`
[17:42:21.792]             `+` <- base::`+`
[17:42:21.792]             `<<-` <- base::`<<-`
[17:42:21.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.792]                   3L)]
[17:42:21.792]             }
[17:42:21.792]             function(cond) {
[17:42:21.792]                 is_error <- inherits(cond, "error")
[17:42:21.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.792]                   NULL)
[17:42:21.792]                 if (is_error) {
[17:42:21.792]                   sessionInformation <- function() {
[17:42:21.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.792]                       search = base::search(), system = base::Sys.info())
[17:42:21.792]                   }
[17:42:21.792]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.792]                     cond$call), session = sessionInformation(), 
[17:42:21.792]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.792]                   signalCondition(cond)
[17:42:21.792]                 }
[17:42:21.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.792]                 "immediateCondition"))) {
[17:42:21.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.792]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.792]                   if (TRUE && !signal) {
[17:42:21.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.792]                     {
[17:42:21.792]                       inherits <- base::inherits
[17:42:21.792]                       invokeRestart <- base::invokeRestart
[17:42:21.792]                       is.null <- base::is.null
[17:42:21.792]                       muffled <- FALSE
[17:42:21.792]                       if (inherits(cond, "message")) {
[17:42:21.792]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.792]                         if (muffled) 
[17:42:21.792]                           invokeRestart("muffleMessage")
[17:42:21.792]                       }
[17:42:21.792]                       else if (inherits(cond, "warning")) {
[17:42:21.792]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.792]                         if (muffled) 
[17:42:21.792]                           invokeRestart("muffleWarning")
[17:42:21.792]                       }
[17:42:21.792]                       else if (inherits(cond, "condition")) {
[17:42:21.792]                         if (!is.null(pattern)) {
[17:42:21.792]                           computeRestarts <- base::computeRestarts
[17:42:21.792]                           grepl <- base::grepl
[17:42:21.792]                           restarts <- computeRestarts(cond)
[17:42:21.792]                           for (restart in restarts) {
[17:42:21.792]                             name <- restart$name
[17:42:21.792]                             if (is.null(name)) 
[17:42:21.792]                               next
[17:42:21.792]                             if (!grepl(pattern, name)) 
[17:42:21.792]                               next
[17:42:21.792]                             invokeRestart(restart)
[17:42:21.792]                             muffled <- TRUE
[17:42:21.792]                             break
[17:42:21.792]                           }
[17:42:21.792]                         }
[17:42:21.792]                       }
[17:42:21.792]                       invisible(muffled)
[17:42:21.792]                     }
[17:42:21.792]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.792]                   }
[17:42:21.792]                 }
[17:42:21.792]                 else {
[17:42:21.792]                   if (TRUE) {
[17:42:21.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.792]                     {
[17:42:21.792]                       inherits <- base::inherits
[17:42:21.792]                       invokeRestart <- base::invokeRestart
[17:42:21.792]                       is.null <- base::is.null
[17:42:21.792]                       muffled <- FALSE
[17:42:21.792]                       if (inherits(cond, "message")) {
[17:42:21.792]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.792]                         if (muffled) 
[17:42:21.792]                           invokeRestart("muffleMessage")
[17:42:21.792]                       }
[17:42:21.792]                       else if (inherits(cond, "warning")) {
[17:42:21.792]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.792]                         if (muffled) 
[17:42:21.792]                           invokeRestart("muffleWarning")
[17:42:21.792]                       }
[17:42:21.792]                       else if (inherits(cond, "condition")) {
[17:42:21.792]                         if (!is.null(pattern)) {
[17:42:21.792]                           computeRestarts <- base::computeRestarts
[17:42:21.792]                           grepl <- base::grepl
[17:42:21.792]                           restarts <- computeRestarts(cond)
[17:42:21.792]                           for (restart in restarts) {
[17:42:21.792]                             name <- restart$name
[17:42:21.792]                             if (is.null(name)) 
[17:42:21.792]                               next
[17:42:21.792]                             if (!grepl(pattern, name)) 
[17:42:21.792]                               next
[17:42:21.792]                             invokeRestart(restart)
[17:42:21.792]                             muffled <- TRUE
[17:42:21.792]                             break
[17:42:21.792]                           }
[17:42:21.792]                         }
[17:42:21.792]                       }
[17:42:21.792]                       invisible(muffled)
[17:42:21.792]                     }
[17:42:21.792]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.792]                   }
[17:42:21.792]                 }
[17:42:21.792]             }
[17:42:21.792]         }))
[17:42:21.792]     }, error = function(ex) {
[17:42:21.792]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.792]                 ...future.rng), started = ...future.startTime, 
[17:42:21.792]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.792]             version = "1.8"), class = "FutureResult")
[17:42:21.792]     }, finally = {
[17:42:21.792]         if (!identical(...future.workdir, getwd())) 
[17:42:21.792]             setwd(...future.workdir)
[17:42:21.792]         {
[17:42:21.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.792]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.792]             }
[17:42:21.792]             base::options(...future.oldOptions)
[17:42:21.792]             if (.Platform$OS.type == "windows") {
[17:42:21.792]                 old_names <- names(...future.oldEnvVars)
[17:42:21.792]                 envs <- base::Sys.getenv()
[17:42:21.792]                 names <- names(envs)
[17:42:21.792]                 common <- intersect(names, old_names)
[17:42:21.792]                 added <- setdiff(names, old_names)
[17:42:21.792]                 removed <- setdiff(old_names, names)
[17:42:21.792]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.792]                   envs[common]]
[17:42:21.792]                 NAMES <- toupper(changed)
[17:42:21.792]                 args <- list()
[17:42:21.792]                 for (kk in seq_along(NAMES)) {
[17:42:21.792]                   name <- changed[[kk]]
[17:42:21.792]                   NAME <- NAMES[[kk]]
[17:42:21.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.792]                     next
[17:42:21.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.792]                 }
[17:42:21.792]                 NAMES <- toupper(added)
[17:42:21.792]                 for (kk in seq_along(NAMES)) {
[17:42:21.792]                   name <- added[[kk]]
[17:42:21.792]                   NAME <- NAMES[[kk]]
[17:42:21.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.792]                     next
[17:42:21.792]                   args[[name]] <- ""
[17:42:21.792]                 }
[17:42:21.792]                 NAMES <- toupper(removed)
[17:42:21.792]                 for (kk in seq_along(NAMES)) {
[17:42:21.792]                   name <- removed[[kk]]
[17:42:21.792]                   NAME <- NAMES[[kk]]
[17:42:21.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.792]                     next
[17:42:21.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.792]                 }
[17:42:21.792]                 if (length(args) > 0) 
[17:42:21.792]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.792]             }
[17:42:21.792]             else {
[17:42:21.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.792]             }
[17:42:21.792]             {
[17:42:21.792]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.792]                   0L) {
[17:42:21.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.792]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.792]                   base::options(opts)
[17:42:21.792]                 }
[17:42:21.792]                 {
[17:42:21.792]                   {
[17:42:21.792]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.792]                     NULL
[17:42:21.792]                   }
[17:42:21.792]                   options(future.plan = NULL)
[17:42:21.792]                   if (is.na(NA_character_)) 
[17:42:21.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.792]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.792]                     envir = parent.frame()) 
[17:42:21.792]                   {
[17:42:21.792]                     default_workers <- missing(workers)
[17:42:21.792]                     if (is.function(workers)) 
[17:42:21.792]                       workers <- workers()
[17:42:21.792]                     workers <- structure(as.integer(workers), 
[17:42:21.792]                       class = class(workers))
[17:42:21.792]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.792]                       1L)
[17:42:21.792]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.792]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.792]                       if (default_workers) 
[17:42:21.792]                         supportsMulticore(warn = TRUE)
[17:42:21.792]                       return(sequential(..., envir = envir))
[17:42:21.792]                     }
[17:42:21.792]                     oopts <- options(mc.cores = workers)
[17:42:21.792]                     on.exit(options(oopts))
[17:42:21.792]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.792]                       envir = envir)
[17:42:21.792]                     if (!future$lazy) 
[17:42:21.792]                       future <- run(future)
[17:42:21.792]                     invisible(future)
[17:42:21.792]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.792]                 }
[17:42:21.792]             }
[17:42:21.792]         }
[17:42:21.792]     })
[17:42:21.792]     if (TRUE) {
[17:42:21.792]         base::sink(type = "output", split = FALSE)
[17:42:21.792]         if (TRUE) {
[17:42:21.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.792]         }
[17:42:21.792]         else {
[17:42:21.792]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.792]         }
[17:42:21.792]         base::close(...future.stdout)
[17:42:21.792]         ...future.stdout <- NULL
[17:42:21.792]     }
[17:42:21.792]     ...future.result$conditions <- ...future.conditions
[17:42:21.792]     ...future.result$finished <- base::Sys.time()
[17:42:21.792]     ...future.result
[17:42:21.792] }
[17:42:21.795] requestCore(): workers = 2
[17:42:21.798] MulticoreFuture started
[17:42:21.798] - Launch lazy future ... done
[17:42:21.798] run() for ‘MulticoreFuture’ ... done
[17:42:21.799] plan(): Setting new future strategy stack:
[17:42:21.799] getGlobalsAndPackages() ...
[17:42:21.799] Searching for globals...
[17:42:21.799] List of future strategies:
[17:42:21.799] 1. sequential:
[17:42:21.799]    - args: function (..., envir = parent.frame())
[17:42:21.799]    - tweaked: FALSE
[17:42:21.799]    - call: NULL
[17:42:21.800] plan(): nbrOfWorkers() = 1
[17:42:21.801] - globals found: [1] ‘{’
[17:42:21.801] Searching for globals ... DONE
[17:42:21.801] Resolving globals: FALSE
[17:42:21.802] 
[17:42:21.802] 
[17:42:21.802] getGlobalsAndPackages() ... DONE
[17:42:21.802] plan(): Setting new future strategy stack:
[17:42:21.802] run() for ‘Future’ ...
[17:42:21.802] - state: ‘created’
[17:42:21.802] List of future strategies:
[17:42:21.802] 1. multicore:
[17:42:21.802]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.802]    - tweaked: FALSE
[17:42:21.802]    - call: plan(strategy)
[17:42:21.803] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.807] plan(): nbrOfWorkers() = 2
[17:42:21.807] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.808]   - Field: ‘label’
[17:42:21.808]   - Field: ‘local’
[17:42:21.808]   - Field: ‘owner’
[17:42:21.808]   - Field: ‘envir’
[17:42:21.808]   - Field: ‘workers’
[17:42:21.808]   - Field: ‘packages’
[17:42:21.809]   - Field: ‘gc’
[17:42:21.809]   - Field: ‘job’
[17:42:21.809]   - Field: ‘conditions’
[17:42:21.809]   - Field: ‘expr’
[17:42:21.809]   - Field: ‘uuid’
[17:42:21.809]   - Field: ‘seed’
[17:42:21.809]   - Field: ‘version’
[17:42:21.810]   - Field: ‘result’
[17:42:21.810]   - Field: ‘asynchronous’
[17:42:21.810]   - Field: ‘calls’
[17:42:21.810]   - Field: ‘globals’
[17:42:21.810]   - Field: ‘stdout’
[17:42:21.810]   - Field: ‘earlySignal’
[17:42:21.810]   - Field: ‘lazy’
[17:42:21.810]   - Field: ‘state’
[17:42:21.811] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.811] - Launch lazy future ...
[17:42:21.811] Packages needed by the future expression (n = 0): <none>
[17:42:21.811] Packages needed by future strategies (n = 0): <none>
[17:42:21.812] {
[17:42:21.812]     {
[17:42:21.812]         {
[17:42:21.812]             ...future.startTime <- base::Sys.time()
[17:42:21.812]             {
[17:42:21.812]                 {
[17:42:21.812]                   {
[17:42:21.812]                     {
[17:42:21.812]                       base::local({
[17:42:21.812]                         has_future <- base::requireNamespace("future", 
[17:42:21.812]                           quietly = TRUE)
[17:42:21.812]                         if (has_future) {
[17:42:21.812]                           ns <- base::getNamespace("future")
[17:42:21.812]                           version <- ns[[".package"]][["version"]]
[17:42:21.812]                           if (is.null(version)) 
[17:42:21.812]                             version <- utils::packageVersion("future")
[17:42:21.812]                         }
[17:42:21.812]                         else {
[17:42:21.812]                           version <- NULL
[17:42:21.812]                         }
[17:42:21.812]                         if (!has_future || version < "1.8.0") {
[17:42:21.812]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.812]                             "", base::R.version$version.string), 
[17:42:21.812]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.812]                               "release", "version")], collapse = " "), 
[17:42:21.812]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.812]                             info)
[17:42:21.812]                           info <- base::paste(info, collapse = "; ")
[17:42:21.812]                           if (!has_future) {
[17:42:21.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.812]                               info)
[17:42:21.812]                           }
[17:42:21.812]                           else {
[17:42:21.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.812]                               info, version)
[17:42:21.812]                           }
[17:42:21.812]                           base::stop(msg)
[17:42:21.812]                         }
[17:42:21.812]                       })
[17:42:21.812]                     }
[17:42:21.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.812]                     base::options(mc.cores = 1L)
[17:42:21.812]                   }
[17:42:21.812]                   options(future.plan = NULL)
[17:42:21.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.812]                 }
[17:42:21.812]                 ...future.workdir <- getwd()
[17:42:21.812]             }
[17:42:21.812]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.812]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.812]         }
[17:42:21.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.812]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.812]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.812]             base::names(...future.oldOptions))
[17:42:21.812]     }
[17:42:21.812]     if (FALSE) {
[17:42:21.812]     }
[17:42:21.812]     else {
[17:42:21.812]         if (TRUE) {
[17:42:21.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.812]                 open = "w")
[17:42:21.812]         }
[17:42:21.812]         else {
[17:42:21.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.812]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.812]         }
[17:42:21.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.812]             base::sink(type = "output", split = FALSE)
[17:42:21.812]             base::close(...future.stdout)
[17:42:21.812]         }, add = TRUE)
[17:42:21.812]     }
[17:42:21.812]     ...future.frame <- base::sys.nframe()
[17:42:21.812]     ...future.conditions <- base::list()
[17:42:21.812]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.812]     if (FALSE) {
[17:42:21.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.812]     }
[17:42:21.812]     ...future.result <- base::tryCatch({
[17:42:21.812]         base::withCallingHandlers({
[17:42:21.812]             ...future.value <- base::withVisible(base::local({
[17:42:21.812]                 withCallingHandlers({
[17:42:21.812]                   {
[17:42:21.812]                     4
[17:42:21.812]                   }
[17:42:21.812]                 }, immediateCondition = function(cond) {
[17:42:21.812]                   save_rds <- function (object, pathname, ...) 
[17:42:21.812]                   {
[17:42:21.812]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.812]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.812]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.812]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.812]                         fi_tmp[["mtime"]])
[17:42:21.812]                     }
[17:42:21.812]                     tryCatch({
[17:42:21.812]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.812]                     }, error = function(ex) {
[17:42:21.812]                       msg <- conditionMessage(ex)
[17:42:21.812]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.812]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.812]                         fi_tmp[["mtime"]], msg)
[17:42:21.812]                       ex$message <- msg
[17:42:21.812]                       stop(ex)
[17:42:21.812]                     })
[17:42:21.812]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.812]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.812]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.812]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.812]                       fi <- file.info(pathname)
[17:42:21.812]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.812]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.812]                         fi[["size"]], fi[["mtime"]])
[17:42:21.812]                       stop(msg)
[17:42:21.812]                     }
[17:42:21.812]                     invisible(pathname)
[17:42:21.812]                   }
[17:42:21.812]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.812]                     rootPath = tempdir()) 
[17:42:21.812]                   {
[17:42:21.812]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.812]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.812]                       tmpdir = path, fileext = ".rds")
[17:42:21.812]                     save_rds(obj, file)
[17:42:21.812]                   }
[17:42:21.812]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.812]                   {
[17:42:21.812]                     inherits <- base::inherits
[17:42:21.812]                     invokeRestart <- base::invokeRestart
[17:42:21.812]                     is.null <- base::is.null
[17:42:21.812]                     muffled <- FALSE
[17:42:21.812]                     if (inherits(cond, "message")) {
[17:42:21.812]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.812]                       if (muffled) 
[17:42:21.812]                         invokeRestart("muffleMessage")
[17:42:21.812]                     }
[17:42:21.812]                     else if (inherits(cond, "warning")) {
[17:42:21.812]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.812]                       if (muffled) 
[17:42:21.812]                         invokeRestart("muffleWarning")
[17:42:21.812]                     }
[17:42:21.812]                     else if (inherits(cond, "condition")) {
[17:42:21.812]                       if (!is.null(pattern)) {
[17:42:21.812]                         computeRestarts <- base::computeRestarts
[17:42:21.812]                         grepl <- base::grepl
[17:42:21.812]                         restarts <- computeRestarts(cond)
[17:42:21.812]                         for (restart in restarts) {
[17:42:21.812]                           name <- restart$name
[17:42:21.812]                           if (is.null(name)) 
[17:42:21.812]                             next
[17:42:21.812]                           if (!grepl(pattern, name)) 
[17:42:21.812]                             next
[17:42:21.812]                           invokeRestart(restart)
[17:42:21.812]                           muffled <- TRUE
[17:42:21.812]                           break
[17:42:21.812]                         }
[17:42:21.812]                       }
[17:42:21.812]                     }
[17:42:21.812]                     invisible(muffled)
[17:42:21.812]                   }
[17:42:21.812]                   muffleCondition(cond)
[17:42:21.812]                 })
[17:42:21.812]             }))
[17:42:21.812]             future::FutureResult(value = ...future.value$value, 
[17:42:21.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.812]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.812]                     ...future.globalenv.names))
[17:42:21.812]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.812]         }, condition = base::local({
[17:42:21.812]             c <- base::c
[17:42:21.812]             inherits <- base::inherits
[17:42:21.812]             invokeRestart <- base::invokeRestart
[17:42:21.812]             length <- base::length
[17:42:21.812]             list <- base::list
[17:42:21.812]             seq.int <- base::seq.int
[17:42:21.812]             signalCondition <- base::signalCondition
[17:42:21.812]             sys.calls <- base::sys.calls
[17:42:21.812]             `[[` <- base::`[[`
[17:42:21.812]             `+` <- base::`+`
[17:42:21.812]             `<<-` <- base::`<<-`
[17:42:21.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.812]                   3L)]
[17:42:21.812]             }
[17:42:21.812]             function(cond) {
[17:42:21.812]                 is_error <- inherits(cond, "error")
[17:42:21.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.812]                   NULL)
[17:42:21.812]                 if (is_error) {
[17:42:21.812]                   sessionInformation <- function() {
[17:42:21.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.812]                       search = base::search(), system = base::Sys.info())
[17:42:21.812]                   }
[17:42:21.812]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.812]                     cond$call), session = sessionInformation(), 
[17:42:21.812]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.812]                   signalCondition(cond)
[17:42:21.812]                 }
[17:42:21.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.812]                 "immediateCondition"))) {
[17:42:21.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.812]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.812]                   if (TRUE && !signal) {
[17:42:21.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.812]                     {
[17:42:21.812]                       inherits <- base::inherits
[17:42:21.812]                       invokeRestart <- base::invokeRestart
[17:42:21.812]                       is.null <- base::is.null
[17:42:21.812]                       muffled <- FALSE
[17:42:21.812]                       if (inherits(cond, "message")) {
[17:42:21.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.812]                         if (muffled) 
[17:42:21.812]                           invokeRestart("muffleMessage")
[17:42:21.812]                       }
[17:42:21.812]                       else if (inherits(cond, "warning")) {
[17:42:21.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.812]                         if (muffled) 
[17:42:21.812]                           invokeRestart("muffleWarning")
[17:42:21.812]                       }
[17:42:21.812]                       else if (inherits(cond, "condition")) {
[17:42:21.812]                         if (!is.null(pattern)) {
[17:42:21.812]                           computeRestarts <- base::computeRestarts
[17:42:21.812]                           grepl <- base::grepl
[17:42:21.812]                           restarts <- computeRestarts(cond)
[17:42:21.812]                           for (restart in restarts) {
[17:42:21.812]                             name <- restart$name
[17:42:21.812]                             if (is.null(name)) 
[17:42:21.812]                               next
[17:42:21.812]                             if (!grepl(pattern, name)) 
[17:42:21.812]                               next
[17:42:21.812]                             invokeRestart(restart)
[17:42:21.812]                             muffled <- TRUE
[17:42:21.812]                             break
[17:42:21.812]                           }
[17:42:21.812]                         }
[17:42:21.812]                       }
[17:42:21.812]                       invisible(muffled)
[17:42:21.812]                     }
[17:42:21.812]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.812]                   }
[17:42:21.812]                 }
[17:42:21.812]                 else {
[17:42:21.812]                   if (TRUE) {
[17:42:21.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.812]                     {
[17:42:21.812]                       inherits <- base::inherits
[17:42:21.812]                       invokeRestart <- base::invokeRestart
[17:42:21.812]                       is.null <- base::is.null
[17:42:21.812]                       muffled <- FALSE
[17:42:21.812]                       if (inherits(cond, "message")) {
[17:42:21.812]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.812]                         if (muffled) 
[17:42:21.812]                           invokeRestart("muffleMessage")
[17:42:21.812]                       }
[17:42:21.812]                       else if (inherits(cond, "warning")) {
[17:42:21.812]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.812]                         if (muffled) 
[17:42:21.812]                           invokeRestart("muffleWarning")
[17:42:21.812]                       }
[17:42:21.812]                       else if (inherits(cond, "condition")) {
[17:42:21.812]                         if (!is.null(pattern)) {
[17:42:21.812]                           computeRestarts <- base::computeRestarts
[17:42:21.812]                           grepl <- base::grepl
[17:42:21.812]                           restarts <- computeRestarts(cond)
[17:42:21.812]                           for (restart in restarts) {
[17:42:21.812]                             name <- restart$name
[17:42:21.812]                             if (is.null(name)) 
[17:42:21.812]                               next
[17:42:21.812]                             if (!grepl(pattern, name)) 
[17:42:21.812]                               next
[17:42:21.812]                             invokeRestart(restart)
[17:42:21.812]                             muffled <- TRUE
[17:42:21.812]                             break
[17:42:21.812]                           }
[17:42:21.812]                         }
[17:42:21.812]                       }
[17:42:21.812]                       invisible(muffled)
[17:42:21.812]                     }
[17:42:21.812]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.812]                   }
[17:42:21.812]                 }
[17:42:21.812]             }
[17:42:21.812]         }))
[17:42:21.812]     }, error = function(ex) {
[17:42:21.812]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.812]                 ...future.rng), started = ...future.startTime, 
[17:42:21.812]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.812]             version = "1.8"), class = "FutureResult")
[17:42:21.812]     }, finally = {
[17:42:21.812]         if (!identical(...future.workdir, getwd())) 
[17:42:21.812]             setwd(...future.workdir)
[17:42:21.812]         {
[17:42:21.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.812]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.812]             }
[17:42:21.812]             base::options(...future.oldOptions)
[17:42:21.812]             if (.Platform$OS.type == "windows") {
[17:42:21.812]                 old_names <- names(...future.oldEnvVars)
[17:42:21.812]                 envs <- base::Sys.getenv()
[17:42:21.812]                 names <- names(envs)
[17:42:21.812]                 common <- intersect(names, old_names)
[17:42:21.812]                 added <- setdiff(names, old_names)
[17:42:21.812]                 removed <- setdiff(old_names, names)
[17:42:21.812]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.812]                   envs[common]]
[17:42:21.812]                 NAMES <- toupper(changed)
[17:42:21.812]                 args <- list()
[17:42:21.812]                 for (kk in seq_along(NAMES)) {
[17:42:21.812]                   name <- changed[[kk]]
[17:42:21.812]                   NAME <- NAMES[[kk]]
[17:42:21.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.812]                     next
[17:42:21.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.812]                 }
[17:42:21.812]                 NAMES <- toupper(added)
[17:42:21.812]                 for (kk in seq_along(NAMES)) {
[17:42:21.812]                   name <- added[[kk]]
[17:42:21.812]                   NAME <- NAMES[[kk]]
[17:42:21.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.812]                     next
[17:42:21.812]                   args[[name]] <- ""
[17:42:21.812]                 }
[17:42:21.812]                 NAMES <- toupper(removed)
[17:42:21.812]                 for (kk in seq_along(NAMES)) {
[17:42:21.812]                   name <- removed[[kk]]
[17:42:21.812]                   NAME <- NAMES[[kk]]
[17:42:21.812]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.812]                     next
[17:42:21.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.812]                 }
[17:42:21.812]                 if (length(args) > 0) 
[17:42:21.812]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.812]             }
[17:42:21.812]             else {
[17:42:21.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.812]             }
[17:42:21.812]             {
[17:42:21.812]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.812]                   0L) {
[17:42:21.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.812]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.812]                   base::options(opts)
[17:42:21.812]                 }
[17:42:21.812]                 {
[17:42:21.812]                   {
[17:42:21.812]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.812]                     NULL
[17:42:21.812]                   }
[17:42:21.812]                   options(future.plan = NULL)
[17:42:21.812]                   if (is.na(NA_character_)) 
[17:42:21.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.812]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.812]                     envir = parent.frame()) 
[17:42:21.812]                   {
[17:42:21.812]                     default_workers <- missing(workers)
[17:42:21.812]                     if (is.function(workers)) 
[17:42:21.812]                       workers <- workers()
[17:42:21.812]                     workers <- structure(as.integer(workers), 
[17:42:21.812]                       class = class(workers))
[17:42:21.812]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.812]                       1L)
[17:42:21.812]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.812]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.812]                       if (default_workers) 
[17:42:21.812]                         supportsMulticore(warn = TRUE)
[17:42:21.812]                       return(sequential(..., envir = envir))
[17:42:21.812]                     }
[17:42:21.812]                     oopts <- options(mc.cores = workers)
[17:42:21.812]                     on.exit(options(oopts))
[17:42:21.812]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.812]                       envir = envir)
[17:42:21.812]                     if (!future$lazy) 
[17:42:21.812]                       future <- run(future)
[17:42:21.812]                     invisible(future)
[17:42:21.812]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.812]                 }
[17:42:21.812]             }
[17:42:21.812]         }
[17:42:21.812]     })
[17:42:21.812]     if (TRUE) {
[17:42:21.812]         base::sink(type = "output", split = FALSE)
[17:42:21.812]         if (TRUE) {
[17:42:21.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.812]         }
[17:42:21.812]         else {
[17:42:21.812]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.812]         }
[17:42:21.812]         base::close(...future.stdout)
[17:42:21.812]         ...future.stdout <- NULL
[17:42:21.812]     }
[17:42:21.812]     ...future.result$conditions <- ...future.conditions
[17:42:21.812]     ...future.result$finished <- base::Sys.time()
[17:42:21.812]     ...future.result
[17:42:21.812] }
[17:42:21.816] requestCore(): workers = 2
[17:42:21.816] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:21.830] MulticoreFuture started
[17:42:21.831] - Launch lazy future ... done
[17:42:21.831] run() for ‘MulticoreFuture’ ... done
[17:42:21.831] plan(): Setting new future strategy stack:
<environment: 0x55bef6bd7290> 
[17:42:21.832] List of future strategies:
[17:42:21.832] 1. sequential:
[17:42:21.832]    - args: function (..., envir = parent.frame())
[17:42:21.832]    - tweaked: FALSE
[17:42:21.832]    - call: NULL
[17:42:21.833] plan(): nbrOfWorkers() = 1
<environment: 0x55bef95ef1a0> 
[17:42:21.835] plan(): Setting new future strategy stack:
[17:42:21.836] List of future strategies:
[17:42:21.836] 1. multicore:
[17:42:21.836]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.836]    - tweaked: FALSE
[17:42:21.836]    - call: plan(strategy)
[17:42:21.841] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:21.843] resolve() on environment ...
[17:42:21.843]  recursive: 0
[17:42:21.844]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:21.844] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.844] - nx: 4
[17:42:21.844] - relay: TRUE
[17:42:21.845] - stdout: TRUE
[17:42:21.845] - signal: TRUE
[17:42:21.845] - resignal: FALSE
[17:42:21.845] - force: TRUE
[17:42:21.845] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.845] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.845]  - until=2
[17:42:21.846]  - relaying element #2
[17:42:21.846] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.846] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.846] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.846]  length: 3 (resolved future 1)
[17:42:21.846] Future #2
[17:42:21.846] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:21.847] - nx: 4
[17:42:21.847] - relay: TRUE
[17:42:21.847] - stdout: TRUE
[17:42:21.847] - signal: TRUE
[17:42:21.847] - resignal: FALSE
[17:42:21.847] - force: TRUE
[17:42:21.848] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.848] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.848]  - until=2
[17:42:21.848]  - relaying element #2
[17:42:21.848] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.848] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.849] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:21.849]  length: 2 (resolved future 2)
[17:42:21.849] Future #3
[17:42:21.850] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:21.850] - nx: 4
[17:42:21.850] - relay: TRUE
[17:42:21.850] - stdout: TRUE
[17:42:21.850] - signal: TRUE
[17:42:21.851] - resignal: FALSE
[17:42:21.851] - force: TRUE
[17:42:21.851] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.851] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.851]  - until=3
[17:42:21.851]  - relaying element #3
[17:42:21.852] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.852] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.852] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:21.852]  length: 1 (resolved future 3)
[17:42:21.852] Future #4
[17:42:21.853] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:21.853] - nx: 4
[17:42:21.853] - relay: TRUE
[17:42:21.854] - stdout: TRUE
[17:42:21.854] - signal: TRUE
[17:42:21.854] - resignal: FALSE
[17:42:21.854] - force: TRUE
[17:42:21.854] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.854] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.855]  - until=4
[17:42:21.855]  - relaying element #4
[17:42:21.855] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.855] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.855] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:21.856]  length: 0 (resolved future 4)
[17:42:21.856] Relaying remaining futures
[17:42:21.856] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.856] - nx: 4
[17:42:21.856] - relay: TRUE
[17:42:21.856] - stdout: TRUE
[17:42:21.856] - signal: TRUE
[17:42:21.857] - resignal: FALSE
[17:42:21.857] - force: TRUE
[17:42:21.857] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.857] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:21.857] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.857] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.857] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.857] resolve() on environment ... DONE
<environment: 0x55bef96f7478> 
Dimensions: c(2, 1, 3, 1)
[17:42:21.858] getGlobalsAndPackages() ...
[17:42:21.858] Searching for globals...
[17:42:21.859] 
[17:42:21.859] Searching for globals ... DONE
[17:42:21.859] - globals: [0] <none>
[17:42:21.859] getGlobalsAndPackages() ... DONE
[17:42:21.859] run() for ‘Future’ ...
[17:42:21.859] - state: ‘created’
[17:42:21.860] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.864] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.864]   - Field: ‘label’
[17:42:21.864]   - Field: ‘local’
[17:42:21.864]   - Field: ‘owner’
[17:42:21.864]   - Field: ‘envir’
[17:42:21.864]   - Field: ‘workers’
[17:42:21.865]   - Field: ‘packages’
[17:42:21.865]   - Field: ‘gc’
[17:42:21.865]   - Field: ‘job’
[17:42:21.865]   - Field: ‘conditions’
[17:42:21.865]   - Field: ‘expr’
[17:42:21.865]   - Field: ‘uuid’
[17:42:21.865]   - Field: ‘seed’
[17:42:21.865]   - Field: ‘version’
[17:42:21.865]   - Field: ‘result’
[17:42:21.866]   - Field: ‘asynchronous’
[17:42:21.866]   - Field: ‘calls’
[17:42:21.866]   - Field: ‘globals’
[17:42:21.866]   - Field: ‘stdout’
[17:42:21.866]   - Field: ‘earlySignal’
[17:42:21.866]   - Field: ‘lazy’
[17:42:21.866]   - Field: ‘state’
[17:42:21.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.866] - Launch lazy future ...
[17:42:21.867] Packages needed by the future expression (n = 0): <none>
[17:42:21.867] Packages needed by future strategies (n = 0): <none>
[17:42:21.867] {
[17:42:21.867]     {
[17:42:21.867]         {
[17:42:21.867]             ...future.startTime <- base::Sys.time()
[17:42:21.867]             {
[17:42:21.867]                 {
[17:42:21.867]                   {
[17:42:21.867]                     {
[17:42:21.867]                       base::local({
[17:42:21.867]                         has_future <- base::requireNamespace("future", 
[17:42:21.867]                           quietly = TRUE)
[17:42:21.867]                         if (has_future) {
[17:42:21.867]                           ns <- base::getNamespace("future")
[17:42:21.867]                           version <- ns[[".package"]][["version"]]
[17:42:21.867]                           if (is.null(version)) 
[17:42:21.867]                             version <- utils::packageVersion("future")
[17:42:21.867]                         }
[17:42:21.867]                         else {
[17:42:21.867]                           version <- NULL
[17:42:21.867]                         }
[17:42:21.867]                         if (!has_future || version < "1.8.0") {
[17:42:21.867]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.867]                             "", base::R.version$version.string), 
[17:42:21.867]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.867]                               "release", "version")], collapse = " "), 
[17:42:21.867]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.867]                             info)
[17:42:21.867]                           info <- base::paste(info, collapse = "; ")
[17:42:21.867]                           if (!has_future) {
[17:42:21.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.867]                               info)
[17:42:21.867]                           }
[17:42:21.867]                           else {
[17:42:21.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.867]                               info, version)
[17:42:21.867]                           }
[17:42:21.867]                           base::stop(msg)
[17:42:21.867]                         }
[17:42:21.867]                       })
[17:42:21.867]                     }
[17:42:21.867]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.867]                     base::options(mc.cores = 1L)
[17:42:21.867]                   }
[17:42:21.867]                   options(future.plan = NULL)
[17:42:21.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.867]                 }
[17:42:21.867]                 ...future.workdir <- getwd()
[17:42:21.867]             }
[17:42:21.867]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.867]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.867]         }
[17:42:21.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.867]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.867]             base::names(...future.oldOptions))
[17:42:21.867]     }
[17:42:21.867]     if (FALSE) {
[17:42:21.867]     }
[17:42:21.867]     else {
[17:42:21.867]         if (TRUE) {
[17:42:21.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.867]                 open = "w")
[17:42:21.867]         }
[17:42:21.867]         else {
[17:42:21.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.867]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.867]         }
[17:42:21.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.867]             base::sink(type = "output", split = FALSE)
[17:42:21.867]             base::close(...future.stdout)
[17:42:21.867]         }, add = TRUE)
[17:42:21.867]     }
[17:42:21.867]     ...future.frame <- base::sys.nframe()
[17:42:21.867]     ...future.conditions <- base::list()
[17:42:21.867]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.867]     if (FALSE) {
[17:42:21.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.867]     }
[17:42:21.867]     ...future.result <- base::tryCatch({
[17:42:21.867]         base::withCallingHandlers({
[17:42:21.867]             ...future.value <- base::withVisible(base::local({
[17:42:21.867]                 withCallingHandlers({
[17:42:21.867]                   2
[17:42:21.867]                 }, immediateCondition = function(cond) {
[17:42:21.867]                   save_rds <- function (object, pathname, ...) 
[17:42:21.867]                   {
[17:42:21.867]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.867]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.867]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.867]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.867]                         fi_tmp[["mtime"]])
[17:42:21.867]                     }
[17:42:21.867]                     tryCatch({
[17:42:21.867]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.867]                     }, error = function(ex) {
[17:42:21.867]                       msg <- conditionMessage(ex)
[17:42:21.867]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.867]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.867]                         fi_tmp[["mtime"]], msg)
[17:42:21.867]                       ex$message <- msg
[17:42:21.867]                       stop(ex)
[17:42:21.867]                     })
[17:42:21.867]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.867]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.867]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.867]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.867]                       fi <- file.info(pathname)
[17:42:21.867]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.867]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.867]                         fi[["size"]], fi[["mtime"]])
[17:42:21.867]                       stop(msg)
[17:42:21.867]                     }
[17:42:21.867]                     invisible(pathname)
[17:42:21.867]                   }
[17:42:21.867]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.867]                     rootPath = tempdir()) 
[17:42:21.867]                   {
[17:42:21.867]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.867]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.867]                       tmpdir = path, fileext = ".rds")
[17:42:21.867]                     save_rds(obj, file)
[17:42:21.867]                   }
[17:42:21.867]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.867]                   {
[17:42:21.867]                     inherits <- base::inherits
[17:42:21.867]                     invokeRestart <- base::invokeRestart
[17:42:21.867]                     is.null <- base::is.null
[17:42:21.867]                     muffled <- FALSE
[17:42:21.867]                     if (inherits(cond, "message")) {
[17:42:21.867]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.867]                       if (muffled) 
[17:42:21.867]                         invokeRestart("muffleMessage")
[17:42:21.867]                     }
[17:42:21.867]                     else if (inherits(cond, "warning")) {
[17:42:21.867]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.867]                       if (muffled) 
[17:42:21.867]                         invokeRestart("muffleWarning")
[17:42:21.867]                     }
[17:42:21.867]                     else if (inherits(cond, "condition")) {
[17:42:21.867]                       if (!is.null(pattern)) {
[17:42:21.867]                         computeRestarts <- base::computeRestarts
[17:42:21.867]                         grepl <- base::grepl
[17:42:21.867]                         restarts <- computeRestarts(cond)
[17:42:21.867]                         for (restart in restarts) {
[17:42:21.867]                           name <- restart$name
[17:42:21.867]                           if (is.null(name)) 
[17:42:21.867]                             next
[17:42:21.867]                           if (!grepl(pattern, name)) 
[17:42:21.867]                             next
[17:42:21.867]                           invokeRestart(restart)
[17:42:21.867]                           muffled <- TRUE
[17:42:21.867]                           break
[17:42:21.867]                         }
[17:42:21.867]                       }
[17:42:21.867]                     }
[17:42:21.867]                     invisible(muffled)
[17:42:21.867]                   }
[17:42:21.867]                   muffleCondition(cond)
[17:42:21.867]                 })
[17:42:21.867]             }))
[17:42:21.867]             future::FutureResult(value = ...future.value$value, 
[17:42:21.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.867]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.867]                     ...future.globalenv.names))
[17:42:21.867]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.867]         }, condition = base::local({
[17:42:21.867]             c <- base::c
[17:42:21.867]             inherits <- base::inherits
[17:42:21.867]             invokeRestart <- base::invokeRestart
[17:42:21.867]             length <- base::length
[17:42:21.867]             list <- base::list
[17:42:21.867]             seq.int <- base::seq.int
[17:42:21.867]             signalCondition <- base::signalCondition
[17:42:21.867]             sys.calls <- base::sys.calls
[17:42:21.867]             `[[` <- base::`[[`
[17:42:21.867]             `+` <- base::`+`
[17:42:21.867]             `<<-` <- base::`<<-`
[17:42:21.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.867]                   3L)]
[17:42:21.867]             }
[17:42:21.867]             function(cond) {
[17:42:21.867]                 is_error <- inherits(cond, "error")
[17:42:21.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.867]                   NULL)
[17:42:21.867]                 if (is_error) {
[17:42:21.867]                   sessionInformation <- function() {
[17:42:21.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.867]                       search = base::search(), system = base::Sys.info())
[17:42:21.867]                   }
[17:42:21.867]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.867]                     cond$call), session = sessionInformation(), 
[17:42:21.867]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.867]                   signalCondition(cond)
[17:42:21.867]                 }
[17:42:21.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.867]                 "immediateCondition"))) {
[17:42:21.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.867]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.867]                   if (TRUE && !signal) {
[17:42:21.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.867]                     {
[17:42:21.867]                       inherits <- base::inherits
[17:42:21.867]                       invokeRestart <- base::invokeRestart
[17:42:21.867]                       is.null <- base::is.null
[17:42:21.867]                       muffled <- FALSE
[17:42:21.867]                       if (inherits(cond, "message")) {
[17:42:21.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.867]                         if (muffled) 
[17:42:21.867]                           invokeRestart("muffleMessage")
[17:42:21.867]                       }
[17:42:21.867]                       else if (inherits(cond, "warning")) {
[17:42:21.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.867]                         if (muffled) 
[17:42:21.867]                           invokeRestart("muffleWarning")
[17:42:21.867]                       }
[17:42:21.867]                       else if (inherits(cond, "condition")) {
[17:42:21.867]                         if (!is.null(pattern)) {
[17:42:21.867]                           computeRestarts <- base::computeRestarts
[17:42:21.867]                           grepl <- base::grepl
[17:42:21.867]                           restarts <- computeRestarts(cond)
[17:42:21.867]                           for (restart in restarts) {
[17:42:21.867]                             name <- restart$name
[17:42:21.867]                             if (is.null(name)) 
[17:42:21.867]                               next
[17:42:21.867]                             if (!grepl(pattern, name)) 
[17:42:21.867]                               next
[17:42:21.867]                             invokeRestart(restart)
[17:42:21.867]                             muffled <- TRUE
[17:42:21.867]                             break
[17:42:21.867]                           }
[17:42:21.867]                         }
[17:42:21.867]                       }
[17:42:21.867]                       invisible(muffled)
[17:42:21.867]                     }
[17:42:21.867]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.867]                   }
[17:42:21.867]                 }
[17:42:21.867]                 else {
[17:42:21.867]                   if (TRUE) {
[17:42:21.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.867]                     {
[17:42:21.867]                       inherits <- base::inherits
[17:42:21.867]                       invokeRestart <- base::invokeRestart
[17:42:21.867]                       is.null <- base::is.null
[17:42:21.867]                       muffled <- FALSE
[17:42:21.867]                       if (inherits(cond, "message")) {
[17:42:21.867]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.867]                         if (muffled) 
[17:42:21.867]                           invokeRestart("muffleMessage")
[17:42:21.867]                       }
[17:42:21.867]                       else if (inherits(cond, "warning")) {
[17:42:21.867]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.867]                         if (muffled) 
[17:42:21.867]                           invokeRestart("muffleWarning")
[17:42:21.867]                       }
[17:42:21.867]                       else if (inherits(cond, "condition")) {
[17:42:21.867]                         if (!is.null(pattern)) {
[17:42:21.867]                           computeRestarts <- base::computeRestarts
[17:42:21.867]                           grepl <- base::grepl
[17:42:21.867]                           restarts <- computeRestarts(cond)
[17:42:21.867]                           for (restart in restarts) {
[17:42:21.867]                             name <- restart$name
[17:42:21.867]                             if (is.null(name)) 
[17:42:21.867]                               next
[17:42:21.867]                             if (!grepl(pattern, name)) 
[17:42:21.867]                               next
[17:42:21.867]                             invokeRestart(restart)
[17:42:21.867]                             muffled <- TRUE
[17:42:21.867]                             break
[17:42:21.867]                           }
[17:42:21.867]                         }
[17:42:21.867]                       }
[17:42:21.867]                       invisible(muffled)
[17:42:21.867]                     }
[17:42:21.867]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.867]                   }
[17:42:21.867]                 }
[17:42:21.867]             }
[17:42:21.867]         }))
[17:42:21.867]     }, error = function(ex) {
[17:42:21.867]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.867]                 ...future.rng), started = ...future.startTime, 
[17:42:21.867]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.867]             version = "1.8"), class = "FutureResult")
[17:42:21.867]     }, finally = {
[17:42:21.867]         if (!identical(...future.workdir, getwd())) 
[17:42:21.867]             setwd(...future.workdir)
[17:42:21.867]         {
[17:42:21.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.867]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.867]             }
[17:42:21.867]             base::options(...future.oldOptions)
[17:42:21.867]             if (.Platform$OS.type == "windows") {
[17:42:21.867]                 old_names <- names(...future.oldEnvVars)
[17:42:21.867]                 envs <- base::Sys.getenv()
[17:42:21.867]                 names <- names(envs)
[17:42:21.867]                 common <- intersect(names, old_names)
[17:42:21.867]                 added <- setdiff(names, old_names)
[17:42:21.867]                 removed <- setdiff(old_names, names)
[17:42:21.867]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.867]                   envs[common]]
[17:42:21.867]                 NAMES <- toupper(changed)
[17:42:21.867]                 args <- list()
[17:42:21.867]                 for (kk in seq_along(NAMES)) {
[17:42:21.867]                   name <- changed[[kk]]
[17:42:21.867]                   NAME <- NAMES[[kk]]
[17:42:21.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.867]                     next
[17:42:21.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.867]                 }
[17:42:21.867]                 NAMES <- toupper(added)
[17:42:21.867]                 for (kk in seq_along(NAMES)) {
[17:42:21.867]                   name <- added[[kk]]
[17:42:21.867]                   NAME <- NAMES[[kk]]
[17:42:21.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.867]                     next
[17:42:21.867]                   args[[name]] <- ""
[17:42:21.867]                 }
[17:42:21.867]                 NAMES <- toupper(removed)
[17:42:21.867]                 for (kk in seq_along(NAMES)) {
[17:42:21.867]                   name <- removed[[kk]]
[17:42:21.867]                   NAME <- NAMES[[kk]]
[17:42:21.867]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.867]                     next
[17:42:21.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.867]                 }
[17:42:21.867]                 if (length(args) > 0) 
[17:42:21.867]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.867]             }
[17:42:21.867]             else {
[17:42:21.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.867]             }
[17:42:21.867]             {
[17:42:21.867]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.867]                   0L) {
[17:42:21.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.867]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.867]                   base::options(opts)
[17:42:21.867]                 }
[17:42:21.867]                 {
[17:42:21.867]                   {
[17:42:21.867]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.867]                     NULL
[17:42:21.867]                   }
[17:42:21.867]                   options(future.plan = NULL)
[17:42:21.867]                   if (is.na(NA_character_)) 
[17:42:21.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.867]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.867]                     envir = parent.frame()) 
[17:42:21.867]                   {
[17:42:21.867]                     default_workers <- missing(workers)
[17:42:21.867]                     if (is.function(workers)) 
[17:42:21.867]                       workers <- workers()
[17:42:21.867]                     workers <- structure(as.integer(workers), 
[17:42:21.867]                       class = class(workers))
[17:42:21.867]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.867]                       1L)
[17:42:21.867]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.867]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.867]                       if (default_workers) 
[17:42:21.867]                         supportsMulticore(warn = TRUE)
[17:42:21.867]                       return(sequential(..., envir = envir))
[17:42:21.867]                     }
[17:42:21.867]                     oopts <- options(mc.cores = workers)
[17:42:21.867]                     on.exit(options(oopts))
[17:42:21.867]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.867]                       envir = envir)
[17:42:21.867]                     if (!future$lazy) 
[17:42:21.867]                       future <- run(future)
[17:42:21.867]                     invisible(future)
[17:42:21.867]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.867]                 }
[17:42:21.867]             }
[17:42:21.867]         }
[17:42:21.867]     })
[17:42:21.867]     if (TRUE) {
[17:42:21.867]         base::sink(type = "output", split = FALSE)
[17:42:21.867]         if (TRUE) {
[17:42:21.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.867]         }
[17:42:21.867]         else {
[17:42:21.867]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.867]         }
[17:42:21.867]         base::close(...future.stdout)
[17:42:21.867]         ...future.stdout <- NULL
[17:42:21.867]     }
[17:42:21.867]     ...future.result$conditions <- ...future.conditions
[17:42:21.867]     ...future.result$finished <- base::Sys.time()
[17:42:21.867]     ...future.result
[17:42:21.867] }
[17:42:21.870] requestCore(): workers = 2
[17:42:21.873] MulticoreFuture started
[17:42:21.873] - Launch lazy future ... done
[17:42:21.874] run() for ‘MulticoreFuture’ ... done
[17:42:21.874] getGlobalsAndPackages() ...
[17:42:21.874] Searching for globals...
[17:42:21.874] plan(): Setting new future strategy stack:
[17:42:21.875] 
[17:42:21.874] List of future strategies:
[17:42:21.874] 1. sequential:
[17:42:21.874]    - args: function (..., envir = parent.frame())
[17:42:21.874]    - tweaked: FALSE
[17:42:21.874]    - call: NULL
[17:42:21.875] Searching for globals ... DONE
[17:42:21.875] - globals: [0] <none>
[17:42:21.875] plan(): nbrOfWorkers() = 1
[17:42:21.875] getGlobalsAndPackages() ... DONE
[17:42:21.876] run() for ‘Future’ ...
[17:42:21.876] - state: ‘created’
[17:42:21.876] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.877] plan(): Setting new future strategy stack:
[17:42:21.877] List of future strategies:
[17:42:21.877] 1. multicore:
[17:42:21.877]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.877]    - tweaked: FALSE
[17:42:21.877]    - call: plan(strategy)
[17:42:21.881] plan(): nbrOfWorkers() = 2
[17:42:21.882] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.882]   - Field: ‘label’
[17:42:21.882]   - Field: ‘local’
[17:42:21.882]   - Field: ‘owner’
[17:42:21.883]   - Field: ‘envir’
[17:42:21.883]   - Field: ‘workers’
[17:42:21.883]   - Field: ‘packages’
[17:42:21.883]   - Field: ‘gc’
[17:42:21.883]   - Field: ‘job’
[17:42:21.883]   - Field: ‘conditions’
[17:42:21.884]   - Field: ‘expr’
[17:42:21.884]   - Field: ‘uuid’
[17:42:21.884]   - Field: ‘seed’
[17:42:21.884]   - Field: ‘version’
[17:42:21.884]   - Field: ‘result’
[17:42:21.884]   - Field: ‘asynchronous’
[17:42:21.884]   - Field: ‘calls’
[17:42:21.885]   - Field: ‘globals’
[17:42:21.885]   - Field: ‘stdout’
[17:42:21.885]   - Field: ‘earlySignal’
[17:42:21.885]   - Field: ‘lazy’
[17:42:21.885]   - Field: ‘state’
[17:42:21.885] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.885] - Launch lazy future ...
[17:42:21.886] Packages needed by the future expression (n = 0): <none>
[17:42:21.886] Packages needed by future strategies (n = 0): <none>
[17:42:21.887] {
[17:42:21.887]     {
[17:42:21.887]         {
[17:42:21.887]             ...future.startTime <- base::Sys.time()
[17:42:21.887]             {
[17:42:21.887]                 {
[17:42:21.887]                   {
[17:42:21.887]                     {
[17:42:21.887]                       base::local({
[17:42:21.887]                         has_future <- base::requireNamespace("future", 
[17:42:21.887]                           quietly = TRUE)
[17:42:21.887]                         if (has_future) {
[17:42:21.887]                           ns <- base::getNamespace("future")
[17:42:21.887]                           version <- ns[[".package"]][["version"]]
[17:42:21.887]                           if (is.null(version)) 
[17:42:21.887]                             version <- utils::packageVersion("future")
[17:42:21.887]                         }
[17:42:21.887]                         else {
[17:42:21.887]                           version <- NULL
[17:42:21.887]                         }
[17:42:21.887]                         if (!has_future || version < "1.8.0") {
[17:42:21.887]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.887]                             "", base::R.version$version.string), 
[17:42:21.887]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.887]                               "release", "version")], collapse = " "), 
[17:42:21.887]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.887]                             info)
[17:42:21.887]                           info <- base::paste(info, collapse = "; ")
[17:42:21.887]                           if (!has_future) {
[17:42:21.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.887]                               info)
[17:42:21.887]                           }
[17:42:21.887]                           else {
[17:42:21.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.887]                               info, version)
[17:42:21.887]                           }
[17:42:21.887]                           base::stop(msg)
[17:42:21.887]                         }
[17:42:21.887]                       })
[17:42:21.887]                     }
[17:42:21.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.887]                     base::options(mc.cores = 1L)
[17:42:21.887]                   }
[17:42:21.887]                   options(future.plan = NULL)
[17:42:21.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.887]                 }
[17:42:21.887]                 ...future.workdir <- getwd()
[17:42:21.887]             }
[17:42:21.887]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.887]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.887]         }
[17:42:21.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.887]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.887]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.887]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.887]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.887]             base::names(...future.oldOptions))
[17:42:21.887]     }
[17:42:21.887]     if (FALSE) {
[17:42:21.887]     }
[17:42:21.887]     else {
[17:42:21.887]         if (TRUE) {
[17:42:21.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.887]                 open = "w")
[17:42:21.887]         }
[17:42:21.887]         else {
[17:42:21.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.887]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.887]         }
[17:42:21.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.887]             base::sink(type = "output", split = FALSE)
[17:42:21.887]             base::close(...future.stdout)
[17:42:21.887]         }, add = TRUE)
[17:42:21.887]     }
[17:42:21.887]     ...future.frame <- base::sys.nframe()
[17:42:21.887]     ...future.conditions <- base::list()
[17:42:21.887]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.887]     if (FALSE) {
[17:42:21.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.887]     }
[17:42:21.887]     ...future.result <- base::tryCatch({
[17:42:21.887]         base::withCallingHandlers({
[17:42:21.887]             ...future.value <- base::withVisible(base::local({
[17:42:21.887]                 withCallingHandlers({
[17:42:21.887]                   NULL
[17:42:21.887]                 }, immediateCondition = function(cond) {
[17:42:21.887]                   save_rds <- function (object, pathname, ...) 
[17:42:21.887]                   {
[17:42:21.887]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.887]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.887]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.887]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.887]                         fi_tmp[["mtime"]])
[17:42:21.887]                     }
[17:42:21.887]                     tryCatch({
[17:42:21.887]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.887]                     }, error = function(ex) {
[17:42:21.887]                       msg <- conditionMessage(ex)
[17:42:21.887]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.887]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.887]                         fi_tmp[["mtime"]], msg)
[17:42:21.887]                       ex$message <- msg
[17:42:21.887]                       stop(ex)
[17:42:21.887]                     })
[17:42:21.887]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.887]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.887]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.887]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.887]                       fi <- file.info(pathname)
[17:42:21.887]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.887]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.887]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.887]                         fi[["size"]], fi[["mtime"]])
[17:42:21.887]                       stop(msg)
[17:42:21.887]                     }
[17:42:21.887]                     invisible(pathname)
[17:42:21.887]                   }
[17:42:21.887]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.887]                     rootPath = tempdir()) 
[17:42:21.887]                   {
[17:42:21.887]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.887]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.887]                       tmpdir = path, fileext = ".rds")
[17:42:21.887]                     save_rds(obj, file)
[17:42:21.887]                   }
[17:42:21.887]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.887]                   {
[17:42:21.887]                     inherits <- base::inherits
[17:42:21.887]                     invokeRestart <- base::invokeRestart
[17:42:21.887]                     is.null <- base::is.null
[17:42:21.887]                     muffled <- FALSE
[17:42:21.887]                     if (inherits(cond, "message")) {
[17:42:21.887]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.887]                       if (muffled) 
[17:42:21.887]                         invokeRestart("muffleMessage")
[17:42:21.887]                     }
[17:42:21.887]                     else if (inherits(cond, "warning")) {
[17:42:21.887]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.887]                       if (muffled) 
[17:42:21.887]                         invokeRestart("muffleWarning")
[17:42:21.887]                     }
[17:42:21.887]                     else if (inherits(cond, "condition")) {
[17:42:21.887]                       if (!is.null(pattern)) {
[17:42:21.887]                         computeRestarts <- base::computeRestarts
[17:42:21.887]                         grepl <- base::grepl
[17:42:21.887]                         restarts <- computeRestarts(cond)
[17:42:21.887]                         for (restart in restarts) {
[17:42:21.887]                           name <- restart$name
[17:42:21.887]                           if (is.null(name)) 
[17:42:21.887]                             next
[17:42:21.887]                           if (!grepl(pattern, name)) 
[17:42:21.887]                             next
[17:42:21.887]                           invokeRestart(restart)
[17:42:21.887]                           muffled <- TRUE
[17:42:21.887]                           break
[17:42:21.887]                         }
[17:42:21.887]                       }
[17:42:21.887]                     }
[17:42:21.887]                     invisible(muffled)
[17:42:21.887]                   }
[17:42:21.887]                   muffleCondition(cond)
[17:42:21.887]                 })
[17:42:21.887]             }))
[17:42:21.887]             future::FutureResult(value = ...future.value$value, 
[17:42:21.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.887]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.887]                     ...future.globalenv.names))
[17:42:21.887]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.887]         }, condition = base::local({
[17:42:21.887]             c <- base::c
[17:42:21.887]             inherits <- base::inherits
[17:42:21.887]             invokeRestart <- base::invokeRestart
[17:42:21.887]             length <- base::length
[17:42:21.887]             list <- base::list
[17:42:21.887]             seq.int <- base::seq.int
[17:42:21.887]             signalCondition <- base::signalCondition
[17:42:21.887]             sys.calls <- base::sys.calls
[17:42:21.887]             `[[` <- base::`[[`
[17:42:21.887]             `+` <- base::`+`
[17:42:21.887]             `<<-` <- base::`<<-`
[17:42:21.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.887]                   3L)]
[17:42:21.887]             }
[17:42:21.887]             function(cond) {
[17:42:21.887]                 is_error <- inherits(cond, "error")
[17:42:21.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.887]                   NULL)
[17:42:21.887]                 if (is_error) {
[17:42:21.887]                   sessionInformation <- function() {
[17:42:21.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.887]                       search = base::search(), system = base::Sys.info())
[17:42:21.887]                   }
[17:42:21.887]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.887]                     cond$call), session = sessionInformation(), 
[17:42:21.887]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.887]                   signalCondition(cond)
[17:42:21.887]                 }
[17:42:21.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.887]                 "immediateCondition"))) {
[17:42:21.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.887]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.887]                   if (TRUE && !signal) {
[17:42:21.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.887]                     {
[17:42:21.887]                       inherits <- base::inherits
[17:42:21.887]                       invokeRestart <- base::invokeRestart
[17:42:21.887]                       is.null <- base::is.null
[17:42:21.887]                       muffled <- FALSE
[17:42:21.887]                       if (inherits(cond, "message")) {
[17:42:21.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.887]                         if (muffled) 
[17:42:21.887]                           invokeRestart("muffleMessage")
[17:42:21.887]                       }
[17:42:21.887]                       else if (inherits(cond, "warning")) {
[17:42:21.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.887]                         if (muffled) 
[17:42:21.887]                           invokeRestart("muffleWarning")
[17:42:21.887]                       }
[17:42:21.887]                       else if (inherits(cond, "condition")) {
[17:42:21.887]                         if (!is.null(pattern)) {
[17:42:21.887]                           computeRestarts <- base::computeRestarts
[17:42:21.887]                           grepl <- base::grepl
[17:42:21.887]                           restarts <- computeRestarts(cond)
[17:42:21.887]                           for (restart in restarts) {
[17:42:21.887]                             name <- restart$name
[17:42:21.887]                             if (is.null(name)) 
[17:42:21.887]                               next
[17:42:21.887]                             if (!grepl(pattern, name)) 
[17:42:21.887]                               next
[17:42:21.887]                             invokeRestart(restart)
[17:42:21.887]                             muffled <- TRUE
[17:42:21.887]                             break
[17:42:21.887]                           }
[17:42:21.887]                         }
[17:42:21.887]                       }
[17:42:21.887]                       invisible(muffled)
[17:42:21.887]                     }
[17:42:21.887]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.887]                   }
[17:42:21.887]                 }
[17:42:21.887]                 else {
[17:42:21.887]                   if (TRUE) {
[17:42:21.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.887]                     {
[17:42:21.887]                       inherits <- base::inherits
[17:42:21.887]                       invokeRestart <- base::invokeRestart
[17:42:21.887]                       is.null <- base::is.null
[17:42:21.887]                       muffled <- FALSE
[17:42:21.887]                       if (inherits(cond, "message")) {
[17:42:21.887]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.887]                         if (muffled) 
[17:42:21.887]                           invokeRestart("muffleMessage")
[17:42:21.887]                       }
[17:42:21.887]                       else if (inherits(cond, "warning")) {
[17:42:21.887]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.887]                         if (muffled) 
[17:42:21.887]                           invokeRestart("muffleWarning")
[17:42:21.887]                       }
[17:42:21.887]                       else if (inherits(cond, "condition")) {
[17:42:21.887]                         if (!is.null(pattern)) {
[17:42:21.887]                           computeRestarts <- base::computeRestarts
[17:42:21.887]                           grepl <- base::grepl
[17:42:21.887]                           restarts <- computeRestarts(cond)
[17:42:21.887]                           for (restart in restarts) {
[17:42:21.887]                             name <- restart$name
[17:42:21.887]                             if (is.null(name)) 
[17:42:21.887]                               next
[17:42:21.887]                             if (!grepl(pattern, name)) 
[17:42:21.887]                               next
[17:42:21.887]                             invokeRestart(restart)
[17:42:21.887]                             muffled <- TRUE
[17:42:21.887]                             break
[17:42:21.887]                           }
[17:42:21.887]                         }
[17:42:21.887]                       }
[17:42:21.887]                       invisible(muffled)
[17:42:21.887]                     }
[17:42:21.887]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.887]                   }
[17:42:21.887]                 }
[17:42:21.887]             }
[17:42:21.887]         }))
[17:42:21.887]     }, error = function(ex) {
[17:42:21.887]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.887]                 ...future.rng), started = ...future.startTime, 
[17:42:21.887]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.887]             version = "1.8"), class = "FutureResult")
[17:42:21.887]     }, finally = {
[17:42:21.887]         if (!identical(...future.workdir, getwd())) 
[17:42:21.887]             setwd(...future.workdir)
[17:42:21.887]         {
[17:42:21.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.887]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.887]             }
[17:42:21.887]             base::options(...future.oldOptions)
[17:42:21.887]             if (.Platform$OS.type == "windows") {
[17:42:21.887]                 old_names <- names(...future.oldEnvVars)
[17:42:21.887]                 envs <- base::Sys.getenv()
[17:42:21.887]                 names <- names(envs)
[17:42:21.887]                 common <- intersect(names, old_names)
[17:42:21.887]                 added <- setdiff(names, old_names)
[17:42:21.887]                 removed <- setdiff(old_names, names)
[17:42:21.887]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.887]                   envs[common]]
[17:42:21.887]                 NAMES <- toupper(changed)
[17:42:21.887]                 args <- list()
[17:42:21.887]                 for (kk in seq_along(NAMES)) {
[17:42:21.887]                   name <- changed[[kk]]
[17:42:21.887]                   NAME <- NAMES[[kk]]
[17:42:21.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.887]                     next
[17:42:21.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.887]                 }
[17:42:21.887]                 NAMES <- toupper(added)
[17:42:21.887]                 for (kk in seq_along(NAMES)) {
[17:42:21.887]                   name <- added[[kk]]
[17:42:21.887]                   NAME <- NAMES[[kk]]
[17:42:21.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.887]                     next
[17:42:21.887]                   args[[name]] <- ""
[17:42:21.887]                 }
[17:42:21.887]                 NAMES <- toupper(removed)
[17:42:21.887]                 for (kk in seq_along(NAMES)) {
[17:42:21.887]                   name <- removed[[kk]]
[17:42:21.887]                   NAME <- NAMES[[kk]]
[17:42:21.887]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.887]                     next
[17:42:21.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.887]                 }
[17:42:21.887]                 if (length(args) > 0) 
[17:42:21.887]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.887]             }
[17:42:21.887]             else {
[17:42:21.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.887]             }
[17:42:21.887]             {
[17:42:21.887]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.887]                   0L) {
[17:42:21.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.887]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.887]                   base::options(opts)
[17:42:21.887]                 }
[17:42:21.887]                 {
[17:42:21.887]                   {
[17:42:21.887]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.887]                     NULL
[17:42:21.887]                   }
[17:42:21.887]                   options(future.plan = NULL)
[17:42:21.887]                   if (is.na(NA_character_)) 
[17:42:21.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.887]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.887]                     envir = parent.frame()) 
[17:42:21.887]                   {
[17:42:21.887]                     default_workers <- missing(workers)
[17:42:21.887]                     if (is.function(workers)) 
[17:42:21.887]                       workers <- workers()
[17:42:21.887]                     workers <- structure(as.integer(workers), 
[17:42:21.887]                       class = class(workers))
[17:42:21.887]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.887]                       1L)
[17:42:21.887]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.887]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.887]                       if (default_workers) 
[17:42:21.887]                         supportsMulticore(warn = TRUE)
[17:42:21.887]                       return(sequential(..., envir = envir))
[17:42:21.887]                     }
[17:42:21.887]                     oopts <- options(mc.cores = workers)
[17:42:21.887]                     on.exit(options(oopts))
[17:42:21.887]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.887]                       envir = envir)
[17:42:21.887]                     if (!future$lazy) 
[17:42:21.887]                       future <- run(future)
[17:42:21.887]                     invisible(future)
[17:42:21.887]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.887]                 }
[17:42:21.887]             }
[17:42:21.887]         }
[17:42:21.887]     })
[17:42:21.887]     if (TRUE) {
[17:42:21.887]         base::sink(type = "output", split = FALSE)
[17:42:21.887]         if (TRUE) {
[17:42:21.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.887]         }
[17:42:21.887]         else {
[17:42:21.887]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.887]         }
[17:42:21.887]         base::close(...future.stdout)
[17:42:21.887]         ...future.stdout <- NULL
[17:42:21.887]     }
[17:42:21.887]     ...future.result$conditions <- ...future.conditions
[17:42:21.887]     ...future.result$finished <- base::Sys.time()
[17:42:21.887]     ...future.result
[17:42:21.887] }
[17:42:21.901] requestCore(): workers = 2
[17:42:21.904] MulticoreFuture started
[17:42:21.905] - Launch lazy future ... done
[17:42:21.906] run() for ‘MulticoreFuture’ ... done
[17:42:21.906] plan(): Setting new future strategy stack:
[17:42:21.906] List of future strategies:
[17:42:21.906] 1. sequential:
[17:42:21.906]    - args: function (..., envir = parent.frame())
[17:42:21.906]    - tweaked: FALSE
[17:42:21.906]    - call: NULL
[17:42:21.907] getGlobalsAndPackages() ...
[17:42:21.907] Searching for globals...
[17:42:21.907] plan(): nbrOfWorkers() = 1
[17:42:21.909] - globals found: [1] ‘{’
[17:42:21.909] Searching for globals ... DONE
[17:42:21.909] Resolving globals: FALSE
[17:42:21.909] plan(): Setting new future strategy stack:
[17:42:21.910] 
[17:42:21.910] 
[17:42:21.910] getGlobalsAndPackages() ... DONE
[17:42:21.910] List of future strategies:
[17:42:21.910] 1. multicore:
[17:42:21.910]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.910]    - tweaked: FALSE
[17:42:21.910]    - call: plan(strategy)
[17:42:21.910] run() for ‘Future’ ...
[17:42:21.911] - state: ‘created’
[17:42:21.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:21.915] plan(): nbrOfWorkers() = 2
[17:42:21.916] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:21.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:21.916]   - Field: ‘label’
[17:42:21.916]   - Field: ‘local’
[17:42:21.917]   - Field: ‘owner’
[17:42:21.917]   - Field: ‘envir’
[17:42:21.917]   - Field: ‘workers’
[17:42:21.917]   - Field: ‘packages’
[17:42:21.917]   - Field: ‘gc’
[17:42:21.917]   - Field: ‘job’
[17:42:21.917]   - Field: ‘conditions’
[17:42:21.918]   - Field: ‘expr’
[17:42:21.918]   - Field: ‘uuid’
[17:42:21.918]   - Field: ‘seed’
[17:42:21.918]   - Field: ‘version’
[17:42:21.918]   - Field: ‘result’
[17:42:21.918]   - Field: ‘asynchronous’
[17:42:21.919]   - Field: ‘calls’
[17:42:21.919]   - Field: ‘globals’
[17:42:21.919]   - Field: ‘stdout’
[17:42:21.919]   - Field: ‘earlySignal’
[17:42:21.919]   - Field: ‘lazy’
[17:42:21.919]   - Field: ‘state’
[17:42:21.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:21.920] - Launch lazy future ...
[17:42:21.920] Packages needed by the future expression (n = 0): <none>
[17:42:21.920] Packages needed by future strategies (n = 0): <none>
[17:42:21.921] {
[17:42:21.921]     {
[17:42:21.921]         {
[17:42:21.921]             ...future.startTime <- base::Sys.time()
[17:42:21.921]             {
[17:42:21.921]                 {
[17:42:21.921]                   {
[17:42:21.921]                     {
[17:42:21.921]                       base::local({
[17:42:21.921]                         has_future <- base::requireNamespace("future", 
[17:42:21.921]                           quietly = TRUE)
[17:42:21.921]                         if (has_future) {
[17:42:21.921]                           ns <- base::getNamespace("future")
[17:42:21.921]                           version <- ns[[".package"]][["version"]]
[17:42:21.921]                           if (is.null(version)) 
[17:42:21.921]                             version <- utils::packageVersion("future")
[17:42:21.921]                         }
[17:42:21.921]                         else {
[17:42:21.921]                           version <- NULL
[17:42:21.921]                         }
[17:42:21.921]                         if (!has_future || version < "1.8.0") {
[17:42:21.921]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:21.921]                             "", base::R.version$version.string), 
[17:42:21.921]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:21.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:21.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:21.921]                               "release", "version")], collapse = " "), 
[17:42:21.921]                             hostname = base::Sys.info()[["nodename"]])
[17:42:21.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:21.921]                             info)
[17:42:21.921]                           info <- base::paste(info, collapse = "; ")
[17:42:21.921]                           if (!has_future) {
[17:42:21.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:21.921]                               info)
[17:42:21.921]                           }
[17:42:21.921]                           else {
[17:42:21.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:21.921]                               info, version)
[17:42:21.921]                           }
[17:42:21.921]                           base::stop(msg)
[17:42:21.921]                         }
[17:42:21.921]                       })
[17:42:21.921]                     }
[17:42:21.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:21.921]                     base::options(mc.cores = 1L)
[17:42:21.921]                   }
[17:42:21.921]                   options(future.plan = NULL)
[17:42:21.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:21.921]                 }
[17:42:21.921]                 ...future.workdir <- getwd()
[17:42:21.921]             }
[17:42:21.921]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:21.921]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:21.921]         }
[17:42:21.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:21.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:21.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:21.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:21.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:21.921]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:21.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:21.921]             base::names(...future.oldOptions))
[17:42:21.921]     }
[17:42:21.921]     if (FALSE) {
[17:42:21.921]     }
[17:42:21.921]     else {
[17:42:21.921]         if (TRUE) {
[17:42:21.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:21.921]                 open = "w")
[17:42:21.921]         }
[17:42:21.921]         else {
[17:42:21.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:21.921]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:21.921]         }
[17:42:21.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:21.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:21.921]             base::sink(type = "output", split = FALSE)
[17:42:21.921]             base::close(...future.stdout)
[17:42:21.921]         }, add = TRUE)
[17:42:21.921]     }
[17:42:21.921]     ...future.frame <- base::sys.nframe()
[17:42:21.921]     ...future.conditions <- base::list()
[17:42:21.921]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:21.921]     if (FALSE) {
[17:42:21.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:21.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:21.921]     }
[17:42:21.921]     ...future.result <- base::tryCatch({
[17:42:21.921]         base::withCallingHandlers({
[17:42:21.921]             ...future.value <- base::withVisible(base::local({
[17:42:21.921]                 withCallingHandlers({
[17:42:21.921]                   {
[17:42:21.921]                     4
[17:42:21.921]                   }
[17:42:21.921]                 }, immediateCondition = function(cond) {
[17:42:21.921]                   save_rds <- function (object, pathname, ...) 
[17:42:21.921]                   {
[17:42:21.921]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:21.921]                     if (file_test("-f", pathname_tmp)) {
[17:42:21.921]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.921]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:21.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.921]                         fi_tmp[["mtime"]])
[17:42:21.921]                     }
[17:42:21.921]                     tryCatch({
[17:42:21.921]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:21.921]                     }, error = function(ex) {
[17:42:21.921]                       msg <- conditionMessage(ex)
[17:42:21.921]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.921]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:21.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.921]                         fi_tmp[["mtime"]], msg)
[17:42:21.921]                       ex$message <- msg
[17:42:21.921]                       stop(ex)
[17:42:21.921]                     })
[17:42:21.921]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:21.921]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:21.921]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:21.921]                       fi_tmp <- file.info(pathname_tmp)
[17:42:21.921]                       fi <- file.info(pathname)
[17:42:21.921]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:21.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:21.921]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:21.921]                         fi[["size"]], fi[["mtime"]])
[17:42:21.921]                       stop(msg)
[17:42:21.921]                     }
[17:42:21.921]                     invisible(pathname)
[17:42:21.921]                   }
[17:42:21.921]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:21.921]                     rootPath = tempdir()) 
[17:42:21.921]                   {
[17:42:21.921]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:21.921]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:21.921]                       tmpdir = path, fileext = ".rds")
[17:42:21.921]                     save_rds(obj, file)
[17:42:21.921]                   }
[17:42:21.921]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:21.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.921]                   {
[17:42:21.921]                     inherits <- base::inherits
[17:42:21.921]                     invokeRestart <- base::invokeRestart
[17:42:21.921]                     is.null <- base::is.null
[17:42:21.921]                     muffled <- FALSE
[17:42:21.921]                     if (inherits(cond, "message")) {
[17:42:21.921]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:21.921]                       if (muffled) 
[17:42:21.921]                         invokeRestart("muffleMessage")
[17:42:21.921]                     }
[17:42:21.921]                     else if (inherits(cond, "warning")) {
[17:42:21.921]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:21.921]                       if (muffled) 
[17:42:21.921]                         invokeRestart("muffleWarning")
[17:42:21.921]                     }
[17:42:21.921]                     else if (inherits(cond, "condition")) {
[17:42:21.921]                       if (!is.null(pattern)) {
[17:42:21.921]                         computeRestarts <- base::computeRestarts
[17:42:21.921]                         grepl <- base::grepl
[17:42:21.921]                         restarts <- computeRestarts(cond)
[17:42:21.921]                         for (restart in restarts) {
[17:42:21.921]                           name <- restart$name
[17:42:21.921]                           if (is.null(name)) 
[17:42:21.921]                             next
[17:42:21.921]                           if (!grepl(pattern, name)) 
[17:42:21.921]                             next
[17:42:21.921]                           invokeRestart(restart)
[17:42:21.921]                           muffled <- TRUE
[17:42:21.921]                           break
[17:42:21.921]                         }
[17:42:21.921]                       }
[17:42:21.921]                     }
[17:42:21.921]                     invisible(muffled)
[17:42:21.921]                   }
[17:42:21.921]                   muffleCondition(cond)
[17:42:21.921]                 })
[17:42:21.921]             }))
[17:42:21.921]             future::FutureResult(value = ...future.value$value, 
[17:42:21.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.921]                   ...future.rng), globalenv = if (FALSE) 
[17:42:21.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:21.921]                     ...future.globalenv.names))
[17:42:21.921]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:21.921]         }, condition = base::local({
[17:42:21.921]             c <- base::c
[17:42:21.921]             inherits <- base::inherits
[17:42:21.921]             invokeRestart <- base::invokeRestart
[17:42:21.921]             length <- base::length
[17:42:21.921]             list <- base::list
[17:42:21.921]             seq.int <- base::seq.int
[17:42:21.921]             signalCondition <- base::signalCondition
[17:42:21.921]             sys.calls <- base::sys.calls
[17:42:21.921]             `[[` <- base::`[[`
[17:42:21.921]             `+` <- base::`+`
[17:42:21.921]             `<<-` <- base::`<<-`
[17:42:21.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:21.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:21.921]                   3L)]
[17:42:21.921]             }
[17:42:21.921]             function(cond) {
[17:42:21.921]                 is_error <- inherits(cond, "error")
[17:42:21.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:21.921]                   NULL)
[17:42:21.921]                 if (is_error) {
[17:42:21.921]                   sessionInformation <- function() {
[17:42:21.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:21.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:21.921]                       search = base::search(), system = base::Sys.info())
[17:42:21.921]                   }
[17:42:21.921]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:21.921]                     cond$call), session = sessionInformation(), 
[17:42:21.921]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:21.921]                   signalCondition(cond)
[17:42:21.921]                 }
[17:42:21.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:21.921]                 "immediateCondition"))) {
[17:42:21.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:21.921]                   ...future.conditions[[length(...future.conditions) + 
[17:42:21.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:21.921]                   if (TRUE && !signal) {
[17:42:21.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.921]                     {
[17:42:21.921]                       inherits <- base::inherits
[17:42:21.921]                       invokeRestart <- base::invokeRestart
[17:42:21.921]                       is.null <- base::is.null
[17:42:21.921]                       muffled <- FALSE
[17:42:21.921]                       if (inherits(cond, "message")) {
[17:42:21.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.921]                         if (muffled) 
[17:42:21.921]                           invokeRestart("muffleMessage")
[17:42:21.921]                       }
[17:42:21.921]                       else if (inherits(cond, "warning")) {
[17:42:21.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.921]                         if (muffled) 
[17:42:21.921]                           invokeRestart("muffleWarning")
[17:42:21.921]                       }
[17:42:21.921]                       else if (inherits(cond, "condition")) {
[17:42:21.921]                         if (!is.null(pattern)) {
[17:42:21.921]                           computeRestarts <- base::computeRestarts
[17:42:21.921]                           grepl <- base::grepl
[17:42:21.921]                           restarts <- computeRestarts(cond)
[17:42:21.921]                           for (restart in restarts) {
[17:42:21.921]                             name <- restart$name
[17:42:21.921]                             if (is.null(name)) 
[17:42:21.921]                               next
[17:42:21.921]                             if (!grepl(pattern, name)) 
[17:42:21.921]                               next
[17:42:21.921]                             invokeRestart(restart)
[17:42:21.921]                             muffled <- TRUE
[17:42:21.921]                             break
[17:42:21.921]                           }
[17:42:21.921]                         }
[17:42:21.921]                       }
[17:42:21.921]                       invisible(muffled)
[17:42:21.921]                     }
[17:42:21.921]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.921]                   }
[17:42:21.921]                 }
[17:42:21.921]                 else {
[17:42:21.921]                   if (TRUE) {
[17:42:21.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:21.921]                     {
[17:42:21.921]                       inherits <- base::inherits
[17:42:21.921]                       invokeRestart <- base::invokeRestart
[17:42:21.921]                       is.null <- base::is.null
[17:42:21.921]                       muffled <- FALSE
[17:42:21.921]                       if (inherits(cond, "message")) {
[17:42:21.921]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:21.921]                         if (muffled) 
[17:42:21.921]                           invokeRestart("muffleMessage")
[17:42:21.921]                       }
[17:42:21.921]                       else if (inherits(cond, "warning")) {
[17:42:21.921]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:21.921]                         if (muffled) 
[17:42:21.921]                           invokeRestart("muffleWarning")
[17:42:21.921]                       }
[17:42:21.921]                       else if (inherits(cond, "condition")) {
[17:42:21.921]                         if (!is.null(pattern)) {
[17:42:21.921]                           computeRestarts <- base::computeRestarts
[17:42:21.921]                           grepl <- base::grepl
[17:42:21.921]                           restarts <- computeRestarts(cond)
[17:42:21.921]                           for (restart in restarts) {
[17:42:21.921]                             name <- restart$name
[17:42:21.921]                             if (is.null(name)) 
[17:42:21.921]                               next
[17:42:21.921]                             if (!grepl(pattern, name)) 
[17:42:21.921]                               next
[17:42:21.921]                             invokeRestart(restart)
[17:42:21.921]                             muffled <- TRUE
[17:42:21.921]                             break
[17:42:21.921]                           }
[17:42:21.921]                         }
[17:42:21.921]                       }
[17:42:21.921]                       invisible(muffled)
[17:42:21.921]                     }
[17:42:21.921]                     muffleCondition(cond, pattern = "^muffle")
[17:42:21.921]                   }
[17:42:21.921]                 }
[17:42:21.921]             }
[17:42:21.921]         }))
[17:42:21.921]     }, error = function(ex) {
[17:42:21.921]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:21.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:21.921]                 ...future.rng), started = ...future.startTime, 
[17:42:21.921]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:21.921]             version = "1.8"), class = "FutureResult")
[17:42:21.921]     }, finally = {
[17:42:21.921]         if (!identical(...future.workdir, getwd())) 
[17:42:21.921]             setwd(...future.workdir)
[17:42:21.921]         {
[17:42:21.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:21.921]                 ...future.oldOptions$nwarnings <- NULL
[17:42:21.921]             }
[17:42:21.921]             base::options(...future.oldOptions)
[17:42:21.921]             if (.Platform$OS.type == "windows") {
[17:42:21.921]                 old_names <- names(...future.oldEnvVars)
[17:42:21.921]                 envs <- base::Sys.getenv()
[17:42:21.921]                 names <- names(envs)
[17:42:21.921]                 common <- intersect(names, old_names)
[17:42:21.921]                 added <- setdiff(names, old_names)
[17:42:21.921]                 removed <- setdiff(old_names, names)
[17:42:21.921]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:21.921]                   envs[common]]
[17:42:21.921]                 NAMES <- toupper(changed)
[17:42:21.921]                 args <- list()
[17:42:21.921]                 for (kk in seq_along(NAMES)) {
[17:42:21.921]                   name <- changed[[kk]]
[17:42:21.921]                   NAME <- NAMES[[kk]]
[17:42:21.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.921]                     next
[17:42:21.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.921]                 }
[17:42:21.921]                 NAMES <- toupper(added)
[17:42:21.921]                 for (kk in seq_along(NAMES)) {
[17:42:21.921]                   name <- added[[kk]]
[17:42:21.921]                   NAME <- NAMES[[kk]]
[17:42:21.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.921]                     next
[17:42:21.921]                   args[[name]] <- ""
[17:42:21.921]                 }
[17:42:21.921]                 NAMES <- toupper(removed)
[17:42:21.921]                 for (kk in seq_along(NAMES)) {
[17:42:21.921]                   name <- removed[[kk]]
[17:42:21.921]                   NAME <- NAMES[[kk]]
[17:42:21.921]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:21.921]                     next
[17:42:21.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:21.921]                 }
[17:42:21.921]                 if (length(args) > 0) 
[17:42:21.921]                   base::do.call(base::Sys.setenv, args = args)
[17:42:21.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:21.921]             }
[17:42:21.921]             else {
[17:42:21.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:21.921]             }
[17:42:21.921]             {
[17:42:21.921]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:21.921]                   0L) {
[17:42:21.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:21.921]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:21.921]                   base::options(opts)
[17:42:21.921]                 }
[17:42:21.921]                 {
[17:42:21.921]                   {
[17:42:21.921]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:21.921]                     NULL
[17:42:21.921]                   }
[17:42:21.921]                   options(future.plan = NULL)
[17:42:21.921]                   if (is.na(NA_character_)) 
[17:42:21.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:21.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:21.921]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:21.921]                     envir = parent.frame()) 
[17:42:21.921]                   {
[17:42:21.921]                     default_workers <- missing(workers)
[17:42:21.921]                     if (is.function(workers)) 
[17:42:21.921]                       workers <- workers()
[17:42:21.921]                     workers <- structure(as.integer(workers), 
[17:42:21.921]                       class = class(workers))
[17:42:21.921]                     stop_if_not(is.finite(workers), workers >= 
[17:42:21.921]                       1L)
[17:42:21.921]                     if ((workers == 1L && !inherits(workers, 
[17:42:21.921]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:21.921]                       if (default_workers) 
[17:42:21.921]                         supportsMulticore(warn = TRUE)
[17:42:21.921]                       return(sequential(..., envir = envir))
[17:42:21.921]                     }
[17:42:21.921]                     oopts <- options(mc.cores = workers)
[17:42:21.921]                     on.exit(options(oopts))
[17:42:21.921]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:21.921]                       envir = envir)
[17:42:21.921]                     if (!future$lazy) 
[17:42:21.921]                       future <- run(future)
[17:42:21.921]                     invisible(future)
[17:42:21.921]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:21.921]                 }
[17:42:21.921]             }
[17:42:21.921]         }
[17:42:21.921]     })
[17:42:21.921]     if (TRUE) {
[17:42:21.921]         base::sink(type = "output", split = FALSE)
[17:42:21.921]         if (TRUE) {
[17:42:21.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:21.921]         }
[17:42:21.921]         else {
[17:42:21.921]             ...future.result["stdout"] <- base::list(NULL)
[17:42:21.921]         }
[17:42:21.921]         base::close(...future.stdout)
[17:42:21.921]         ...future.stdout <- NULL
[17:42:21.921]     }
[17:42:21.921]     ...future.result$conditions <- ...future.conditions
[17:42:21.921]     ...future.result$finished <- base::Sys.time()
[17:42:21.921]     ...future.result
[17:42:21.921] }
[17:42:21.925] requestCore(): workers = 2
[17:42:21.925] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:21.940] MulticoreFuture started
[17:42:21.940] - Launch lazy future ... done
[17:42:21.940] run() for ‘MulticoreFuture’ ... done
[17:42:21.941] plan(): Setting new future strategy stack:
<environment: 0x55bef9c270f0> 
[17:42:21.941] List of future strategies:
[17:42:21.941] 1. sequential:
[17:42:21.941]    - args: function (..., envir = parent.frame())
[17:42:21.941]    - tweaked: FALSE
[17:42:21.941]    - call: NULL
[17:42:21.943] plan(): nbrOfWorkers() = 1
<environment: 0x55bef81494e8> 
[17:42:21.945] plan(): Setting new future strategy stack:
[17:42:21.945] List of future strategies:
[17:42:21.945] 1. multicore:
[17:42:21.945]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:21.945]    - tweaked: FALSE
[17:42:21.945]    - call: plan(strategy)
[17:42:21.951] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:21.953] resolve() on environment ...
[17:42:21.953]  recursive: 0
[17:42:21.954]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:21.954] signalConditionsASAP(numeric, pos=1) ...
[17:42:21.954] - nx: 4
[17:42:21.954] - relay: TRUE
[17:42:21.955] - stdout: TRUE
[17:42:21.955] - signal: TRUE
[17:42:21.955] - resignal: FALSE
[17:42:21.955] - force: TRUE
[17:42:21.955] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.955] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.955]  - until=2
[17:42:21.956]  - relaying element #2
[17:42:21.956] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.956] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.956] signalConditionsASAP(NULL, pos=1) ... done
[17:42:21.956]  length: 3 (resolved future 1)
[17:42:21.956] Future #2
[17:42:21.957] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:21.957] - nx: 4
[17:42:21.957] - relay: TRUE
[17:42:21.957] - stdout: TRUE
[17:42:21.957] - signal: TRUE
[17:42:21.957] - resignal: FALSE
[17:42:21.957] - force: TRUE
[17:42:21.957] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:21.958] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:21.958]  - until=2
[17:42:21.958]  - relaying element #2
[17:42:21.958] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.958] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.958] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:21.959]  length: 2 (resolved future 2)
[17:42:21.959] Future #3
[17:42:21.960] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:21.960] - nx: 4
[17:42:21.960] - relay: TRUE
[17:42:21.960] - stdout: TRUE
[17:42:21.960] - signal: TRUE
[17:42:21.961] - resignal: FALSE
[17:42:21.961] - force: TRUE
[17:42:21.961] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:21.961] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:21.961]  - until=3
[17:42:21.961]  - relaying element #3
[17:42:21.962] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.962] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.962] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:21.962]  length: 1 (resolved future 3)
[17:42:21.962] Future #4
[17:42:21.963] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:21.963] - nx: 4
[17:42:21.964] - relay: TRUE
[17:42:21.964] - stdout: TRUE
[17:42:21.964] - signal: TRUE
[17:42:21.964] - resignal: FALSE
[17:42:21.964] - force: TRUE
[17:42:21.964] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:21.965] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:21.965]  - until=4
[17:42:21.965]  - relaying element #4
[17:42:21.965] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.965] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.966] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:21.966]  length: 0 (resolved future 4)
[17:42:21.966] Relaying remaining futures
[17:42:21.966] signalConditionsASAP(NULL, pos=0) ...
[17:42:21.966] - nx: 4
[17:42:21.966] - relay: TRUE
[17:42:21.966] - stdout: TRUE
[17:42:21.967] - signal: TRUE
[17:42:21.967] - resignal: FALSE
[17:42:21.967] - force: TRUE
[17:42:21.967] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.967] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:21.967] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:21.967] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:21.967] signalConditionsASAP(NULL, pos=0) ... done
[17:42:21.968] resolve() on environment ... DONE
<environment: 0x55bef80006f8> 
Type of future: multisession
[17:42:21.968] plan(): Setting new future strategy stack:
[17:42:21.969] List of future strategies:
[17:42:21.969] 1. multisession:
[17:42:21.969]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:21.969]    - tweaked: FALSE
[17:42:21.969]    - call: plan(strategy)
[17:42:21.969] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:21.969] multisession:
[17:42:21.969] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:21.969] - tweaked: FALSE
[17:42:21.969] - call: plan(strategy)
[17:42:21.974] getGlobalsAndPackages() ...
[17:42:21.974] Not searching for globals
[17:42:21.974] - globals: [0] <none>
[17:42:21.975] getGlobalsAndPackages() ... DONE
[17:42:21.975] [local output] makeClusterPSOCK() ...
[17:42:21.975] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:21.976] [local output] Base port: 11487
[17:42:21.976] [local output] Getting setup options for 2 cluster nodes ...
[17:42:21.976] [local output]  - Node 1 of 2 ...
[17:42:21.977] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:21.978] [local output] Rscript port: 11487

[17:42:21.978] [local output]  - Node 2 of 2 ...
[17:42:21.978] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:21.979] [local output] Rscript port: 11487

[17:42:21.979] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:21.980] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:21.980] [local output] Setting up PSOCK nodes in parallel
[17:42:21.980] List of 36
[17:42:21.980]  $ worker          : chr "localhost"
[17:42:21.980]   ..- attr(*, "localhost")= logi TRUE
[17:42:21.980]  $ master          : chr "localhost"
[17:42:21.980]  $ port            : int 11487
[17:42:21.980]  $ connectTimeout  : num 120
[17:42:21.980]  $ timeout         : num 2592000
[17:42:21.980]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:21.980]  $ homogeneous     : logi TRUE
[17:42:21.980]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:21.980]  $ rscript_envs    : NULL
[17:42:21.980]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:21.980]  $ rscript_startup : NULL
[17:42:21.980]  $ rscript_sh      : chr "sh"
[17:42:21.980]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:21.980]  $ methods         : logi TRUE
[17:42:21.980]  $ socketOptions   : chr "no-delay"
[17:42:21.980]  $ useXDR          : logi FALSE
[17:42:21.980]  $ outfile         : chr "/dev/null"
[17:42:21.980]  $ renice          : int NA
[17:42:21.980]  $ rshcmd          : NULL
[17:42:21.980]  $ user            : chr(0) 
[17:42:21.980]  $ revtunnel       : logi FALSE
[17:42:21.980]  $ rshlogfile      : NULL
[17:42:21.980]  $ rshopts         : chr(0) 
[17:42:21.980]  $ rank            : int 1
[17:42:21.980]  $ manual          : logi FALSE
[17:42:21.980]  $ dryrun          : logi FALSE
[17:42:21.980]  $ quiet           : logi FALSE
[17:42:21.980]  $ setup_strategy  : chr "parallel"
[17:42:21.980]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:21.980]  $ pidfile         : chr "/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec71fe0ca2b.pid"
[17:42:21.980]  $ rshcmd_label    : NULL
[17:42:21.980]  $ rsh_call        : NULL
[17:42:21.980]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:21.980]  $ localMachine    : logi TRUE
[17:42:21.980]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:21.980]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:21.980]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:21.980]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:21.980]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:21.980]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:21.980]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:21.980]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:21.980]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:21.980]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:21.980]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:21.980]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:21.980]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:21.980]  $ arguments       :List of 28
[17:42:21.980]   ..$ worker          : chr "localhost"
[17:42:21.980]   ..$ master          : NULL
[17:42:21.980]   ..$ port            : int 11487
[17:42:21.980]   ..$ connectTimeout  : num 120
[17:42:21.980]   ..$ timeout         : num 2592000
[17:42:21.980]   ..$ rscript         : NULL
[17:42:21.980]   ..$ homogeneous     : NULL
[17:42:21.980]   ..$ rscript_args    : NULL
[17:42:21.980]   ..$ rscript_envs    : NULL
[17:42:21.980]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:21.980]   ..$ rscript_startup : NULL
[17:42:21.980]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:21.980]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:21.980]   ..$ methods         : logi TRUE
[17:42:21.980]   ..$ socketOptions   : chr "no-delay"
[17:42:21.980]   ..$ useXDR          : logi FALSE
[17:42:21.980]   ..$ outfile         : chr "/dev/null"
[17:42:21.980]   ..$ renice          : int NA
[17:42:21.980]   ..$ rshcmd          : NULL
[17:42:21.980]   ..$ user            : NULL
[17:42:21.980]   ..$ revtunnel       : logi NA
[17:42:21.980]   ..$ rshlogfile      : NULL
[17:42:21.980]   ..$ rshopts         : NULL
[17:42:21.980]   ..$ rank            : int 1
[17:42:21.980]   ..$ manual          : logi FALSE
[17:42:21.980]   ..$ dryrun          : logi FALSE
[17:42:21.980]   ..$ quiet           : logi FALSE
[17:42:21.980]   ..$ setup_strategy  : chr "parallel"
[17:42:21.980]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:22.000] [local output] System call to launch all workers:
[17:42:22.000] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec71fe0ca2b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11487 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:22.000] [local output] Starting PSOCK main server
[17:42:22.002] [local output] Workers launched
[17:42:22.002] [local output] Waiting for workers to connect back
[17:42:22.002]  - [local output] 0 workers out of 2 ready
[17:42:22.247]  - [local output] 0 workers out of 2 ready
[17:42:22.248]  - [local output] 1 workers out of 2 ready
[17:42:22.251]  - [local output] 1 workers out of 2 ready
[17:42:22.252]  - [local output] 2 workers out of 2 ready
[17:42:22.252] [local output] Launching of workers completed
[17:42:22.252] [local output] Collecting session information from workers
[17:42:22.253] [local output]  - Worker #1 of 2
[17:42:22.254] [local output]  - Worker #2 of 2
[17:42:22.254] [local output] makeClusterPSOCK() ... done
[17:42:22.266] Packages needed by the future expression (n = 0): <none>
[17:42:22.266] Packages needed by future strategies (n = 0): <none>
[17:42:22.266] {
[17:42:22.266]     {
[17:42:22.266]         {
[17:42:22.266]             ...future.startTime <- base::Sys.time()
[17:42:22.266]             {
[17:42:22.266]                 {
[17:42:22.266]                   {
[17:42:22.266]                     {
[17:42:22.266]                       base::local({
[17:42:22.266]                         has_future <- base::requireNamespace("future", 
[17:42:22.266]                           quietly = TRUE)
[17:42:22.266]                         if (has_future) {
[17:42:22.266]                           ns <- base::getNamespace("future")
[17:42:22.266]                           version <- ns[[".package"]][["version"]]
[17:42:22.266]                           if (is.null(version)) 
[17:42:22.266]                             version <- utils::packageVersion("future")
[17:42:22.266]                         }
[17:42:22.266]                         else {
[17:42:22.266]                           version <- NULL
[17:42:22.266]                         }
[17:42:22.266]                         if (!has_future || version < "1.8.0") {
[17:42:22.266]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.266]                             "", base::R.version$version.string), 
[17:42:22.266]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.266]                               "release", "version")], collapse = " "), 
[17:42:22.266]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.266]                             info)
[17:42:22.266]                           info <- base::paste(info, collapse = "; ")
[17:42:22.266]                           if (!has_future) {
[17:42:22.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.266]                               info)
[17:42:22.266]                           }
[17:42:22.266]                           else {
[17:42:22.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.266]                               info, version)
[17:42:22.266]                           }
[17:42:22.266]                           base::stop(msg)
[17:42:22.266]                         }
[17:42:22.266]                       })
[17:42:22.266]                     }
[17:42:22.266]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.266]                     base::options(mc.cores = 1L)
[17:42:22.266]                   }
[17:42:22.266]                   options(future.plan = NULL)
[17:42:22.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.266]                 }
[17:42:22.266]                 ...future.workdir <- getwd()
[17:42:22.266]             }
[17:42:22.266]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.266]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.266]         }
[17:42:22.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.266]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.266]             base::names(...future.oldOptions))
[17:42:22.266]     }
[17:42:22.266]     if (FALSE) {
[17:42:22.266]     }
[17:42:22.266]     else {
[17:42:22.266]         if (TRUE) {
[17:42:22.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.266]                 open = "w")
[17:42:22.266]         }
[17:42:22.266]         else {
[17:42:22.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.266]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.266]         }
[17:42:22.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.266]             base::sink(type = "output", split = FALSE)
[17:42:22.266]             base::close(...future.stdout)
[17:42:22.266]         }, add = TRUE)
[17:42:22.266]     }
[17:42:22.266]     ...future.frame <- base::sys.nframe()
[17:42:22.266]     ...future.conditions <- base::list()
[17:42:22.266]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.266]     if (FALSE) {
[17:42:22.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.266]     }
[17:42:22.266]     ...future.result <- base::tryCatch({
[17:42:22.266]         base::withCallingHandlers({
[17:42:22.266]             ...future.value <- base::withVisible(base::local({
[17:42:22.266]                 ...future.makeSendCondition <- local({
[17:42:22.266]                   sendCondition <- NULL
[17:42:22.266]                   function(frame = 1L) {
[17:42:22.266]                     if (is.function(sendCondition)) 
[17:42:22.266]                       return(sendCondition)
[17:42:22.266]                     ns <- getNamespace("parallel")
[17:42:22.266]                     if (exists("sendData", mode = "function", 
[17:42:22.266]                       envir = ns)) {
[17:42:22.266]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.266]                         envir = ns)
[17:42:22.266]                       envir <- sys.frame(frame)
[17:42:22.266]                       master <- NULL
[17:42:22.266]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.266]                         !identical(envir, emptyenv())) {
[17:42:22.266]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.266]                           inherits = FALSE)) {
[17:42:22.266]                           master <- get("master", mode = "list", 
[17:42:22.266]                             envir = envir, inherits = FALSE)
[17:42:22.266]                           if (inherits(master, c("SOCKnode", 
[17:42:22.266]                             "SOCK0node"))) {
[17:42:22.266]                             sendCondition <<- function(cond) {
[17:42:22.266]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.266]                                 success = TRUE)
[17:42:22.266]                               parallel_sendData(master, data)
[17:42:22.266]                             }
[17:42:22.266]                             return(sendCondition)
[17:42:22.266]                           }
[17:42:22.266]                         }
[17:42:22.266]                         frame <- frame + 1L
[17:42:22.266]                         envir <- sys.frame(frame)
[17:42:22.266]                       }
[17:42:22.266]                     }
[17:42:22.266]                     sendCondition <<- function(cond) NULL
[17:42:22.266]                   }
[17:42:22.266]                 })
[17:42:22.266]                 withCallingHandlers({
[17:42:22.266]                   NA
[17:42:22.266]                 }, immediateCondition = function(cond) {
[17:42:22.266]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.266]                   sendCondition(cond)
[17:42:22.266]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.266]                   {
[17:42:22.266]                     inherits <- base::inherits
[17:42:22.266]                     invokeRestart <- base::invokeRestart
[17:42:22.266]                     is.null <- base::is.null
[17:42:22.266]                     muffled <- FALSE
[17:42:22.266]                     if (inherits(cond, "message")) {
[17:42:22.266]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.266]                       if (muffled) 
[17:42:22.266]                         invokeRestart("muffleMessage")
[17:42:22.266]                     }
[17:42:22.266]                     else if (inherits(cond, "warning")) {
[17:42:22.266]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.266]                       if (muffled) 
[17:42:22.266]                         invokeRestart("muffleWarning")
[17:42:22.266]                     }
[17:42:22.266]                     else if (inherits(cond, "condition")) {
[17:42:22.266]                       if (!is.null(pattern)) {
[17:42:22.266]                         computeRestarts <- base::computeRestarts
[17:42:22.266]                         grepl <- base::grepl
[17:42:22.266]                         restarts <- computeRestarts(cond)
[17:42:22.266]                         for (restart in restarts) {
[17:42:22.266]                           name <- restart$name
[17:42:22.266]                           if (is.null(name)) 
[17:42:22.266]                             next
[17:42:22.266]                           if (!grepl(pattern, name)) 
[17:42:22.266]                             next
[17:42:22.266]                           invokeRestart(restart)
[17:42:22.266]                           muffled <- TRUE
[17:42:22.266]                           break
[17:42:22.266]                         }
[17:42:22.266]                       }
[17:42:22.266]                     }
[17:42:22.266]                     invisible(muffled)
[17:42:22.266]                   }
[17:42:22.266]                   muffleCondition(cond)
[17:42:22.266]                 })
[17:42:22.266]             }))
[17:42:22.266]             future::FutureResult(value = ...future.value$value, 
[17:42:22.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.266]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.266]                     ...future.globalenv.names))
[17:42:22.266]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.266]         }, condition = base::local({
[17:42:22.266]             c <- base::c
[17:42:22.266]             inherits <- base::inherits
[17:42:22.266]             invokeRestart <- base::invokeRestart
[17:42:22.266]             length <- base::length
[17:42:22.266]             list <- base::list
[17:42:22.266]             seq.int <- base::seq.int
[17:42:22.266]             signalCondition <- base::signalCondition
[17:42:22.266]             sys.calls <- base::sys.calls
[17:42:22.266]             `[[` <- base::`[[`
[17:42:22.266]             `+` <- base::`+`
[17:42:22.266]             `<<-` <- base::`<<-`
[17:42:22.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.266]                   3L)]
[17:42:22.266]             }
[17:42:22.266]             function(cond) {
[17:42:22.266]                 is_error <- inherits(cond, "error")
[17:42:22.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.266]                   NULL)
[17:42:22.266]                 if (is_error) {
[17:42:22.266]                   sessionInformation <- function() {
[17:42:22.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.266]                       search = base::search(), system = base::Sys.info())
[17:42:22.266]                   }
[17:42:22.266]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.266]                     cond$call), session = sessionInformation(), 
[17:42:22.266]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.266]                   signalCondition(cond)
[17:42:22.266]                 }
[17:42:22.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.266]                 "immediateCondition"))) {
[17:42:22.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.266]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.266]                   if (TRUE && !signal) {
[17:42:22.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.266]                     {
[17:42:22.266]                       inherits <- base::inherits
[17:42:22.266]                       invokeRestart <- base::invokeRestart
[17:42:22.266]                       is.null <- base::is.null
[17:42:22.266]                       muffled <- FALSE
[17:42:22.266]                       if (inherits(cond, "message")) {
[17:42:22.266]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.266]                         if (muffled) 
[17:42:22.266]                           invokeRestart("muffleMessage")
[17:42:22.266]                       }
[17:42:22.266]                       else if (inherits(cond, "warning")) {
[17:42:22.266]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.266]                         if (muffled) 
[17:42:22.266]                           invokeRestart("muffleWarning")
[17:42:22.266]                       }
[17:42:22.266]                       else if (inherits(cond, "condition")) {
[17:42:22.266]                         if (!is.null(pattern)) {
[17:42:22.266]                           computeRestarts <- base::computeRestarts
[17:42:22.266]                           grepl <- base::grepl
[17:42:22.266]                           restarts <- computeRestarts(cond)
[17:42:22.266]                           for (restart in restarts) {
[17:42:22.266]                             name <- restart$name
[17:42:22.266]                             if (is.null(name)) 
[17:42:22.266]                               next
[17:42:22.266]                             if (!grepl(pattern, name)) 
[17:42:22.266]                               next
[17:42:22.266]                             invokeRestart(restart)
[17:42:22.266]                             muffled <- TRUE
[17:42:22.266]                             break
[17:42:22.266]                           }
[17:42:22.266]                         }
[17:42:22.266]                       }
[17:42:22.266]                       invisible(muffled)
[17:42:22.266]                     }
[17:42:22.266]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.266]                   }
[17:42:22.266]                 }
[17:42:22.266]                 else {
[17:42:22.266]                   if (TRUE) {
[17:42:22.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.266]                     {
[17:42:22.266]                       inherits <- base::inherits
[17:42:22.266]                       invokeRestart <- base::invokeRestart
[17:42:22.266]                       is.null <- base::is.null
[17:42:22.266]                       muffled <- FALSE
[17:42:22.266]                       if (inherits(cond, "message")) {
[17:42:22.266]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.266]                         if (muffled) 
[17:42:22.266]                           invokeRestart("muffleMessage")
[17:42:22.266]                       }
[17:42:22.266]                       else if (inherits(cond, "warning")) {
[17:42:22.266]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.266]                         if (muffled) 
[17:42:22.266]                           invokeRestart("muffleWarning")
[17:42:22.266]                       }
[17:42:22.266]                       else if (inherits(cond, "condition")) {
[17:42:22.266]                         if (!is.null(pattern)) {
[17:42:22.266]                           computeRestarts <- base::computeRestarts
[17:42:22.266]                           grepl <- base::grepl
[17:42:22.266]                           restarts <- computeRestarts(cond)
[17:42:22.266]                           for (restart in restarts) {
[17:42:22.266]                             name <- restart$name
[17:42:22.266]                             if (is.null(name)) 
[17:42:22.266]                               next
[17:42:22.266]                             if (!grepl(pattern, name)) 
[17:42:22.266]                               next
[17:42:22.266]                             invokeRestart(restart)
[17:42:22.266]                             muffled <- TRUE
[17:42:22.266]                             break
[17:42:22.266]                           }
[17:42:22.266]                         }
[17:42:22.266]                       }
[17:42:22.266]                       invisible(muffled)
[17:42:22.266]                     }
[17:42:22.266]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.266]                   }
[17:42:22.266]                 }
[17:42:22.266]             }
[17:42:22.266]         }))
[17:42:22.266]     }, error = function(ex) {
[17:42:22.266]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.266]                 ...future.rng), started = ...future.startTime, 
[17:42:22.266]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.266]             version = "1.8"), class = "FutureResult")
[17:42:22.266]     }, finally = {
[17:42:22.266]         if (!identical(...future.workdir, getwd())) 
[17:42:22.266]             setwd(...future.workdir)
[17:42:22.266]         {
[17:42:22.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.266]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.266]             }
[17:42:22.266]             base::options(...future.oldOptions)
[17:42:22.266]             if (.Platform$OS.type == "windows") {
[17:42:22.266]                 old_names <- names(...future.oldEnvVars)
[17:42:22.266]                 envs <- base::Sys.getenv()
[17:42:22.266]                 names <- names(envs)
[17:42:22.266]                 common <- intersect(names, old_names)
[17:42:22.266]                 added <- setdiff(names, old_names)
[17:42:22.266]                 removed <- setdiff(old_names, names)
[17:42:22.266]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.266]                   envs[common]]
[17:42:22.266]                 NAMES <- toupper(changed)
[17:42:22.266]                 args <- list()
[17:42:22.266]                 for (kk in seq_along(NAMES)) {
[17:42:22.266]                   name <- changed[[kk]]
[17:42:22.266]                   NAME <- NAMES[[kk]]
[17:42:22.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.266]                     next
[17:42:22.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.266]                 }
[17:42:22.266]                 NAMES <- toupper(added)
[17:42:22.266]                 for (kk in seq_along(NAMES)) {
[17:42:22.266]                   name <- added[[kk]]
[17:42:22.266]                   NAME <- NAMES[[kk]]
[17:42:22.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.266]                     next
[17:42:22.266]                   args[[name]] <- ""
[17:42:22.266]                 }
[17:42:22.266]                 NAMES <- toupper(removed)
[17:42:22.266]                 for (kk in seq_along(NAMES)) {
[17:42:22.266]                   name <- removed[[kk]]
[17:42:22.266]                   NAME <- NAMES[[kk]]
[17:42:22.266]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.266]                     next
[17:42:22.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.266]                 }
[17:42:22.266]                 if (length(args) > 0) 
[17:42:22.266]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.266]             }
[17:42:22.266]             else {
[17:42:22.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.266]             }
[17:42:22.266]             {
[17:42:22.266]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.266]                   0L) {
[17:42:22.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.266]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.266]                   base::options(opts)
[17:42:22.266]                 }
[17:42:22.266]                 {
[17:42:22.266]                   {
[17:42:22.266]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.266]                     NULL
[17:42:22.266]                   }
[17:42:22.266]                   options(future.plan = NULL)
[17:42:22.266]                   if (is.na(NA_character_)) 
[17:42:22.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.266]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.266]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.266]                     envir = parent.frame()) 
[17:42:22.266]                   {
[17:42:22.266]                     if (is.function(workers)) 
[17:42:22.266]                       workers <- workers()
[17:42:22.266]                     workers <- structure(as.integer(workers), 
[17:42:22.266]                       class = class(workers))
[17:42:22.266]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.266]                       workers >= 1)
[17:42:22.266]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.266]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.266]                     }
[17:42:22.266]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.266]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.266]                       envir = envir)
[17:42:22.266]                     if (!future$lazy) 
[17:42:22.266]                       future <- run(future)
[17:42:22.266]                     invisible(future)
[17:42:22.266]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.266]                 }
[17:42:22.266]             }
[17:42:22.266]         }
[17:42:22.266]     })
[17:42:22.266]     if (TRUE) {
[17:42:22.266]         base::sink(type = "output", split = FALSE)
[17:42:22.266]         if (TRUE) {
[17:42:22.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.266]         }
[17:42:22.266]         else {
[17:42:22.266]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.266]         }
[17:42:22.266]         base::close(...future.stdout)
[17:42:22.266]         ...future.stdout <- NULL
[17:42:22.266]     }
[17:42:22.266]     ...future.result$conditions <- ...future.conditions
[17:42:22.266]     ...future.result$finished <- base::Sys.time()
[17:42:22.266]     ...future.result
[17:42:22.266] }
[17:42:22.340] MultisessionFuture started
[17:42:22.341] result() for ClusterFuture ...
[17:42:22.341] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.341] - Validating connection of MultisessionFuture
[17:42:22.375] - received message: FutureResult
[17:42:22.376] - Received FutureResult
[17:42:22.376] - Erased future from FutureRegistry
[17:42:22.376] result() for ClusterFuture ...
[17:42:22.376] - result already collected: FutureResult
[17:42:22.376] result() for ClusterFuture ... done
[17:42:22.376] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.376] result() for ClusterFuture ... done
[17:42:22.376] result() for ClusterFuture ...
[17:42:22.377] - result already collected: FutureResult
[17:42:22.377] result() for ClusterFuture ... done
[17:42:22.377] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:22.380] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:42:22.381] getGlobalsAndPackages() ...
[17:42:22.381] Searching for globals...
[17:42:22.381] 
[17:42:22.381] Searching for globals ... DONE
[17:42:22.381] - globals: [0] <none>
[17:42:22.382] getGlobalsAndPackages() ... DONE
[17:42:22.382] run() for ‘Future’ ...
[17:42:22.382] - state: ‘created’
[17:42:22.382] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.397]   - Field: ‘node’
[17:42:22.397]   - Field: ‘label’
[17:42:22.397]   - Field: ‘local’
[17:42:22.398]   - Field: ‘owner’
[17:42:22.398]   - Field: ‘envir’
[17:42:22.398]   - Field: ‘workers’
[17:42:22.398]   - Field: ‘packages’
[17:42:22.398]   - Field: ‘gc’
[17:42:22.398]   - Field: ‘conditions’
[17:42:22.398]   - Field: ‘persistent’
[17:42:22.398]   - Field: ‘expr’
[17:42:22.398]   - Field: ‘uuid’
[17:42:22.399]   - Field: ‘seed’
[17:42:22.399]   - Field: ‘version’
[17:42:22.399]   - Field: ‘result’
[17:42:22.399]   - Field: ‘asynchronous’
[17:42:22.399]   - Field: ‘calls’
[17:42:22.399]   - Field: ‘globals’
[17:42:22.399]   - Field: ‘stdout’
[17:42:22.399]   - Field: ‘earlySignal’
[17:42:22.399]   - Field: ‘lazy’
[17:42:22.400]   - Field: ‘state’
[17:42:22.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.400] - Launch lazy future ...
[17:42:22.400] Packages needed by the future expression (n = 0): <none>
[17:42:22.400] Packages needed by future strategies (n = 0): <none>
[17:42:22.401] {
[17:42:22.401]     {
[17:42:22.401]         {
[17:42:22.401]             ...future.startTime <- base::Sys.time()
[17:42:22.401]             {
[17:42:22.401]                 {
[17:42:22.401]                   {
[17:42:22.401]                     {
[17:42:22.401]                       base::local({
[17:42:22.401]                         has_future <- base::requireNamespace("future", 
[17:42:22.401]                           quietly = TRUE)
[17:42:22.401]                         if (has_future) {
[17:42:22.401]                           ns <- base::getNamespace("future")
[17:42:22.401]                           version <- ns[[".package"]][["version"]]
[17:42:22.401]                           if (is.null(version)) 
[17:42:22.401]                             version <- utils::packageVersion("future")
[17:42:22.401]                         }
[17:42:22.401]                         else {
[17:42:22.401]                           version <- NULL
[17:42:22.401]                         }
[17:42:22.401]                         if (!has_future || version < "1.8.0") {
[17:42:22.401]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.401]                             "", base::R.version$version.string), 
[17:42:22.401]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.401]                               "release", "version")], collapse = " "), 
[17:42:22.401]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.401]                             info)
[17:42:22.401]                           info <- base::paste(info, collapse = "; ")
[17:42:22.401]                           if (!has_future) {
[17:42:22.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.401]                               info)
[17:42:22.401]                           }
[17:42:22.401]                           else {
[17:42:22.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.401]                               info, version)
[17:42:22.401]                           }
[17:42:22.401]                           base::stop(msg)
[17:42:22.401]                         }
[17:42:22.401]                       })
[17:42:22.401]                     }
[17:42:22.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.401]                     base::options(mc.cores = 1L)
[17:42:22.401]                   }
[17:42:22.401]                   options(future.plan = NULL)
[17:42:22.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.401]                 }
[17:42:22.401]                 ...future.workdir <- getwd()
[17:42:22.401]             }
[17:42:22.401]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.401]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.401]         }
[17:42:22.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.401]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.401]             base::names(...future.oldOptions))
[17:42:22.401]     }
[17:42:22.401]     if (FALSE) {
[17:42:22.401]     }
[17:42:22.401]     else {
[17:42:22.401]         if (TRUE) {
[17:42:22.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.401]                 open = "w")
[17:42:22.401]         }
[17:42:22.401]         else {
[17:42:22.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.401]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.401]         }
[17:42:22.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.401]             base::sink(type = "output", split = FALSE)
[17:42:22.401]             base::close(...future.stdout)
[17:42:22.401]         }, add = TRUE)
[17:42:22.401]     }
[17:42:22.401]     ...future.frame <- base::sys.nframe()
[17:42:22.401]     ...future.conditions <- base::list()
[17:42:22.401]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.401]     if (FALSE) {
[17:42:22.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.401]     }
[17:42:22.401]     ...future.result <- base::tryCatch({
[17:42:22.401]         base::withCallingHandlers({
[17:42:22.401]             ...future.value <- base::withVisible(base::local({
[17:42:22.401]                 ...future.makeSendCondition <- local({
[17:42:22.401]                   sendCondition <- NULL
[17:42:22.401]                   function(frame = 1L) {
[17:42:22.401]                     if (is.function(sendCondition)) 
[17:42:22.401]                       return(sendCondition)
[17:42:22.401]                     ns <- getNamespace("parallel")
[17:42:22.401]                     if (exists("sendData", mode = "function", 
[17:42:22.401]                       envir = ns)) {
[17:42:22.401]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.401]                         envir = ns)
[17:42:22.401]                       envir <- sys.frame(frame)
[17:42:22.401]                       master <- NULL
[17:42:22.401]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.401]                         !identical(envir, emptyenv())) {
[17:42:22.401]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.401]                           inherits = FALSE)) {
[17:42:22.401]                           master <- get("master", mode = "list", 
[17:42:22.401]                             envir = envir, inherits = FALSE)
[17:42:22.401]                           if (inherits(master, c("SOCKnode", 
[17:42:22.401]                             "SOCK0node"))) {
[17:42:22.401]                             sendCondition <<- function(cond) {
[17:42:22.401]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.401]                                 success = TRUE)
[17:42:22.401]                               parallel_sendData(master, data)
[17:42:22.401]                             }
[17:42:22.401]                             return(sendCondition)
[17:42:22.401]                           }
[17:42:22.401]                         }
[17:42:22.401]                         frame <- frame + 1L
[17:42:22.401]                         envir <- sys.frame(frame)
[17:42:22.401]                       }
[17:42:22.401]                     }
[17:42:22.401]                     sendCondition <<- function(cond) NULL
[17:42:22.401]                   }
[17:42:22.401]                 })
[17:42:22.401]                 withCallingHandlers({
[17:42:22.401]                   2
[17:42:22.401]                 }, immediateCondition = function(cond) {
[17:42:22.401]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.401]                   sendCondition(cond)
[17:42:22.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.401]                   {
[17:42:22.401]                     inherits <- base::inherits
[17:42:22.401]                     invokeRestart <- base::invokeRestart
[17:42:22.401]                     is.null <- base::is.null
[17:42:22.401]                     muffled <- FALSE
[17:42:22.401]                     if (inherits(cond, "message")) {
[17:42:22.401]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.401]                       if (muffled) 
[17:42:22.401]                         invokeRestart("muffleMessage")
[17:42:22.401]                     }
[17:42:22.401]                     else if (inherits(cond, "warning")) {
[17:42:22.401]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.401]                       if (muffled) 
[17:42:22.401]                         invokeRestart("muffleWarning")
[17:42:22.401]                     }
[17:42:22.401]                     else if (inherits(cond, "condition")) {
[17:42:22.401]                       if (!is.null(pattern)) {
[17:42:22.401]                         computeRestarts <- base::computeRestarts
[17:42:22.401]                         grepl <- base::grepl
[17:42:22.401]                         restarts <- computeRestarts(cond)
[17:42:22.401]                         for (restart in restarts) {
[17:42:22.401]                           name <- restart$name
[17:42:22.401]                           if (is.null(name)) 
[17:42:22.401]                             next
[17:42:22.401]                           if (!grepl(pattern, name)) 
[17:42:22.401]                             next
[17:42:22.401]                           invokeRestart(restart)
[17:42:22.401]                           muffled <- TRUE
[17:42:22.401]                           break
[17:42:22.401]                         }
[17:42:22.401]                       }
[17:42:22.401]                     }
[17:42:22.401]                     invisible(muffled)
[17:42:22.401]                   }
[17:42:22.401]                   muffleCondition(cond)
[17:42:22.401]                 })
[17:42:22.401]             }))
[17:42:22.401]             future::FutureResult(value = ...future.value$value, 
[17:42:22.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.401]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.401]                     ...future.globalenv.names))
[17:42:22.401]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.401]         }, condition = base::local({
[17:42:22.401]             c <- base::c
[17:42:22.401]             inherits <- base::inherits
[17:42:22.401]             invokeRestart <- base::invokeRestart
[17:42:22.401]             length <- base::length
[17:42:22.401]             list <- base::list
[17:42:22.401]             seq.int <- base::seq.int
[17:42:22.401]             signalCondition <- base::signalCondition
[17:42:22.401]             sys.calls <- base::sys.calls
[17:42:22.401]             `[[` <- base::`[[`
[17:42:22.401]             `+` <- base::`+`
[17:42:22.401]             `<<-` <- base::`<<-`
[17:42:22.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.401]                   3L)]
[17:42:22.401]             }
[17:42:22.401]             function(cond) {
[17:42:22.401]                 is_error <- inherits(cond, "error")
[17:42:22.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.401]                   NULL)
[17:42:22.401]                 if (is_error) {
[17:42:22.401]                   sessionInformation <- function() {
[17:42:22.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.401]                       search = base::search(), system = base::Sys.info())
[17:42:22.401]                   }
[17:42:22.401]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.401]                     cond$call), session = sessionInformation(), 
[17:42:22.401]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.401]                   signalCondition(cond)
[17:42:22.401]                 }
[17:42:22.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.401]                 "immediateCondition"))) {
[17:42:22.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.401]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.401]                   if (TRUE && !signal) {
[17:42:22.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.401]                     {
[17:42:22.401]                       inherits <- base::inherits
[17:42:22.401]                       invokeRestart <- base::invokeRestart
[17:42:22.401]                       is.null <- base::is.null
[17:42:22.401]                       muffled <- FALSE
[17:42:22.401]                       if (inherits(cond, "message")) {
[17:42:22.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.401]                         if (muffled) 
[17:42:22.401]                           invokeRestart("muffleMessage")
[17:42:22.401]                       }
[17:42:22.401]                       else if (inherits(cond, "warning")) {
[17:42:22.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.401]                         if (muffled) 
[17:42:22.401]                           invokeRestart("muffleWarning")
[17:42:22.401]                       }
[17:42:22.401]                       else if (inherits(cond, "condition")) {
[17:42:22.401]                         if (!is.null(pattern)) {
[17:42:22.401]                           computeRestarts <- base::computeRestarts
[17:42:22.401]                           grepl <- base::grepl
[17:42:22.401]                           restarts <- computeRestarts(cond)
[17:42:22.401]                           for (restart in restarts) {
[17:42:22.401]                             name <- restart$name
[17:42:22.401]                             if (is.null(name)) 
[17:42:22.401]                               next
[17:42:22.401]                             if (!grepl(pattern, name)) 
[17:42:22.401]                               next
[17:42:22.401]                             invokeRestart(restart)
[17:42:22.401]                             muffled <- TRUE
[17:42:22.401]                             break
[17:42:22.401]                           }
[17:42:22.401]                         }
[17:42:22.401]                       }
[17:42:22.401]                       invisible(muffled)
[17:42:22.401]                     }
[17:42:22.401]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.401]                   }
[17:42:22.401]                 }
[17:42:22.401]                 else {
[17:42:22.401]                   if (TRUE) {
[17:42:22.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.401]                     {
[17:42:22.401]                       inherits <- base::inherits
[17:42:22.401]                       invokeRestart <- base::invokeRestart
[17:42:22.401]                       is.null <- base::is.null
[17:42:22.401]                       muffled <- FALSE
[17:42:22.401]                       if (inherits(cond, "message")) {
[17:42:22.401]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.401]                         if (muffled) 
[17:42:22.401]                           invokeRestart("muffleMessage")
[17:42:22.401]                       }
[17:42:22.401]                       else if (inherits(cond, "warning")) {
[17:42:22.401]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.401]                         if (muffled) 
[17:42:22.401]                           invokeRestart("muffleWarning")
[17:42:22.401]                       }
[17:42:22.401]                       else if (inherits(cond, "condition")) {
[17:42:22.401]                         if (!is.null(pattern)) {
[17:42:22.401]                           computeRestarts <- base::computeRestarts
[17:42:22.401]                           grepl <- base::grepl
[17:42:22.401]                           restarts <- computeRestarts(cond)
[17:42:22.401]                           for (restart in restarts) {
[17:42:22.401]                             name <- restart$name
[17:42:22.401]                             if (is.null(name)) 
[17:42:22.401]                               next
[17:42:22.401]                             if (!grepl(pattern, name)) 
[17:42:22.401]                               next
[17:42:22.401]                             invokeRestart(restart)
[17:42:22.401]                             muffled <- TRUE
[17:42:22.401]                             break
[17:42:22.401]                           }
[17:42:22.401]                         }
[17:42:22.401]                       }
[17:42:22.401]                       invisible(muffled)
[17:42:22.401]                     }
[17:42:22.401]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.401]                   }
[17:42:22.401]                 }
[17:42:22.401]             }
[17:42:22.401]         }))
[17:42:22.401]     }, error = function(ex) {
[17:42:22.401]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.401]                 ...future.rng), started = ...future.startTime, 
[17:42:22.401]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.401]             version = "1.8"), class = "FutureResult")
[17:42:22.401]     }, finally = {
[17:42:22.401]         if (!identical(...future.workdir, getwd())) 
[17:42:22.401]             setwd(...future.workdir)
[17:42:22.401]         {
[17:42:22.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.401]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.401]             }
[17:42:22.401]             base::options(...future.oldOptions)
[17:42:22.401]             if (.Platform$OS.type == "windows") {
[17:42:22.401]                 old_names <- names(...future.oldEnvVars)
[17:42:22.401]                 envs <- base::Sys.getenv()
[17:42:22.401]                 names <- names(envs)
[17:42:22.401]                 common <- intersect(names, old_names)
[17:42:22.401]                 added <- setdiff(names, old_names)
[17:42:22.401]                 removed <- setdiff(old_names, names)
[17:42:22.401]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.401]                   envs[common]]
[17:42:22.401]                 NAMES <- toupper(changed)
[17:42:22.401]                 args <- list()
[17:42:22.401]                 for (kk in seq_along(NAMES)) {
[17:42:22.401]                   name <- changed[[kk]]
[17:42:22.401]                   NAME <- NAMES[[kk]]
[17:42:22.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.401]                     next
[17:42:22.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.401]                 }
[17:42:22.401]                 NAMES <- toupper(added)
[17:42:22.401]                 for (kk in seq_along(NAMES)) {
[17:42:22.401]                   name <- added[[kk]]
[17:42:22.401]                   NAME <- NAMES[[kk]]
[17:42:22.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.401]                     next
[17:42:22.401]                   args[[name]] <- ""
[17:42:22.401]                 }
[17:42:22.401]                 NAMES <- toupper(removed)
[17:42:22.401]                 for (kk in seq_along(NAMES)) {
[17:42:22.401]                   name <- removed[[kk]]
[17:42:22.401]                   NAME <- NAMES[[kk]]
[17:42:22.401]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.401]                     next
[17:42:22.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.401]                 }
[17:42:22.401]                 if (length(args) > 0) 
[17:42:22.401]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.401]             }
[17:42:22.401]             else {
[17:42:22.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.401]             }
[17:42:22.401]             {
[17:42:22.401]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.401]                   0L) {
[17:42:22.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.401]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.401]                   base::options(opts)
[17:42:22.401]                 }
[17:42:22.401]                 {
[17:42:22.401]                   {
[17:42:22.401]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.401]                     NULL
[17:42:22.401]                   }
[17:42:22.401]                   options(future.plan = NULL)
[17:42:22.401]                   if (is.na(NA_character_)) 
[17:42:22.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.401]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.401]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.401]                     envir = parent.frame()) 
[17:42:22.401]                   {
[17:42:22.401]                     if (is.function(workers)) 
[17:42:22.401]                       workers <- workers()
[17:42:22.401]                     workers <- structure(as.integer(workers), 
[17:42:22.401]                       class = class(workers))
[17:42:22.401]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.401]                       workers >= 1)
[17:42:22.401]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.401]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.401]                     }
[17:42:22.401]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.401]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.401]                       envir = envir)
[17:42:22.401]                     if (!future$lazy) 
[17:42:22.401]                       future <- run(future)
[17:42:22.401]                     invisible(future)
[17:42:22.401]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.401]                 }
[17:42:22.401]             }
[17:42:22.401]         }
[17:42:22.401]     })
[17:42:22.401]     if (TRUE) {
[17:42:22.401]         base::sink(type = "output", split = FALSE)
[17:42:22.401]         if (TRUE) {
[17:42:22.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.401]         }
[17:42:22.401]         else {
[17:42:22.401]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.401]         }
[17:42:22.401]         base::close(...future.stdout)
[17:42:22.401]         ...future.stdout <- NULL
[17:42:22.401]     }
[17:42:22.401]     ...future.result$conditions <- ...future.conditions
[17:42:22.401]     ...future.result$finished <- base::Sys.time()
[17:42:22.401]     ...future.result
[17:42:22.401] }
[17:42:22.404] MultisessionFuture started
[17:42:22.404] - Launch lazy future ... done
[17:42:22.404] run() for ‘MultisessionFuture’ ... done
[17:42:22.405] getGlobalsAndPackages() ...
[17:42:22.405] Searching for globals...
[17:42:22.405] 
[17:42:22.405] Searching for globals ... DONE
[17:42:22.405] - globals: [0] <none>
[17:42:22.405] getGlobalsAndPackages() ... DONE
[17:42:22.406] run() for ‘Future’ ...
[17:42:22.406] - state: ‘created’
[17:42:22.406] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.421] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.421]   - Field: ‘node’
[17:42:22.421]   - Field: ‘label’
[17:42:22.421]   - Field: ‘local’
[17:42:22.421]   - Field: ‘owner’
[17:42:22.422]   - Field: ‘envir’
[17:42:22.422]   - Field: ‘workers’
[17:42:22.422]   - Field: ‘packages’
[17:42:22.422]   - Field: ‘gc’
[17:42:22.422]   - Field: ‘conditions’
[17:42:22.422]   - Field: ‘persistent’
[17:42:22.422]   - Field: ‘expr’
[17:42:22.422]   - Field: ‘uuid’
[17:42:22.422]   - Field: ‘seed’
[17:42:22.423]   - Field: ‘version’
[17:42:22.423]   - Field: ‘result’
[17:42:22.423]   - Field: ‘asynchronous’
[17:42:22.423]   - Field: ‘calls’
[17:42:22.423]   - Field: ‘globals’
[17:42:22.423]   - Field: ‘stdout’
[17:42:22.423]   - Field: ‘earlySignal’
[17:42:22.423]   - Field: ‘lazy’
[17:42:22.426]   - Field: ‘state’
[17:42:22.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.426] - Launch lazy future ...
[17:42:22.426] Packages needed by the future expression (n = 0): <none>
[17:42:22.427] Packages needed by future strategies (n = 0): <none>
[17:42:22.427] {
[17:42:22.427]     {
[17:42:22.427]         {
[17:42:22.427]             ...future.startTime <- base::Sys.time()
[17:42:22.427]             {
[17:42:22.427]                 {
[17:42:22.427]                   {
[17:42:22.427]                     {
[17:42:22.427]                       base::local({
[17:42:22.427]                         has_future <- base::requireNamespace("future", 
[17:42:22.427]                           quietly = TRUE)
[17:42:22.427]                         if (has_future) {
[17:42:22.427]                           ns <- base::getNamespace("future")
[17:42:22.427]                           version <- ns[[".package"]][["version"]]
[17:42:22.427]                           if (is.null(version)) 
[17:42:22.427]                             version <- utils::packageVersion("future")
[17:42:22.427]                         }
[17:42:22.427]                         else {
[17:42:22.427]                           version <- NULL
[17:42:22.427]                         }
[17:42:22.427]                         if (!has_future || version < "1.8.0") {
[17:42:22.427]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.427]                             "", base::R.version$version.string), 
[17:42:22.427]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.427]                               "release", "version")], collapse = " "), 
[17:42:22.427]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.427]                             info)
[17:42:22.427]                           info <- base::paste(info, collapse = "; ")
[17:42:22.427]                           if (!has_future) {
[17:42:22.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.427]                               info)
[17:42:22.427]                           }
[17:42:22.427]                           else {
[17:42:22.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.427]                               info, version)
[17:42:22.427]                           }
[17:42:22.427]                           base::stop(msg)
[17:42:22.427]                         }
[17:42:22.427]                       })
[17:42:22.427]                     }
[17:42:22.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.427]                     base::options(mc.cores = 1L)
[17:42:22.427]                   }
[17:42:22.427]                   options(future.plan = NULL)
[17:42:22.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.427]                 }
[17:42:22.427]                 ...future.workdir <- getwd()
[17:42:22.427]             }
[17:42:22.427]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.427]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.427]         }
[17:42:22.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.427]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.427]             base::names(...future.oldOptions))
[17:42:22.427]     }
[17:42:22.427]     if (FALSE) {
[17:42:22.427]     }
[17:42:22.427]     else {
[17:42:22.427]         if (TRUE) {
[17:42:22.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.427]                 open = "w")
[17:42:22.427]         }
[17:42:22.427]         else {
[17:42:22.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.427]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.427]         }
[17:42:22.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.427]             base::sink(type = "output", split = FALSE)
[17:42:22.427]             base::close(...future.stdout)
[17:42:22.427]         }, add = TRUE)
[17:42:22.427]     }
[17:42:22.427]     ...future.frame <- base::sys.nframe()
[17:42:22.427]     ...future.conditions <- base::list()
[17:42:22.427]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.427]     if (FALSE) {
[17:42:22.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.427]     }
[17:42:22.427]     ...future.result <- base::tryCatch({
[17:42:22.427]         base::withCallingHandlers({
[17:42:22.427]             ...future.value <- base::withVisible(base::local({
[17:42:22.427]                 ...future.makeSendCondition <- local({
[17:42:22.427]                   sendCondition <- NULL
[17:42:22.427]                   function(frame = 1L) {
[17:42:22.427]                     if (is.function(sendCondition)) 
[17:42:22.427]                       return(sendCondition)
[17:42:22.427]                     ns <- getNamespace("parallel")
[17:42:22.427]                     if (exists("sendData", mode = "function", 
[17:42:22.427]                       envir = ns)) {
[17:42:22.427]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.427]                         envir = ns)
[17:42:22.427]                       envir <- sys.frame(frame)
[17:42:22.427]                       master <- NULL
[17:42:22.427]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.427]                         !identical(envir, emptyenv())) {
[17:42:22.427]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.427]                           inherits = FALSE)) {
[17:42:22.427]                           master <- get("master", mode = "list", 
[17:42:22.427]                             envir = envir, inherits = FALSE)
[17:42:22.427]                           if (inherits(master, c("SOCKnode", 
[17:42:22.427]                             "SOCK0node"))) {
[17:42:22.427]                             sendCondition <<- function(cond) {
[17:42:22.427]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.427]                                 success = TRUE)
[17:42:22.427]                               parallel_sendData(master, data)
[17:42:22.427]                             }
[17:42:22.427]                             return(sendCondition)
[17:42:22.427]                           }
[17:42:22.427]                         }
[17:42:22.427]                         frame <- frame + 1L
[17:42:22.427]                         envir <- sys.frame(frame)
[17:42:22.427]                       }
[17:42:22.427]                     }
[17:42:22.427]                     sendCondition <<- function(cond) NULL
[17:42:22.427]                   }
[17:42:22.427]                 })
[17:42:22.427]                 withCallingHandlers({
[17:42:22.427]                   NULL
[17:42:22.427]                 }, immediateCondition = function(cond) {
[17:42:22.427]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.427]                   sendCondition(cond)
[17:42:22.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.427]                   {
[17:42:22.427]                     inherits <- base::inherits
[17:42:22.427]                     invokeRestart <- base::invokeRestart
[17:42:22.427]                     is.null <- base::is.null
[17:42:22.427]                     muffled <- FALSE
[17:42:22.427]                     if (inherits(cond, "message")) {
[17:42:22.427]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.427]                       if (muffled) 
[17:42:22.427]                         invokeRestart("muffleMessage")
[17:42:22.427]                     }
[17:42:22.427]                     else if (inherits(cond, "warning")) {
[17:42:22.427]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.427]                       if (muffled) 
[17:42:22.427]                         invokeRestart("muffleWarning")
[17:42:22.427]                     }
[17:42:22.427]                     else if (inherits(cond, "condition")) {
[17:42:22.427]                       if (!is.null(pattern)) {
[17:42:22.427]                         computeRestarts <- base::computeRestarts
[17:42:22.427]                         grepl <- base::grepl
[17:42:22.427]                         restarts <- computeRestarts(cond)
[17:42:22.427]                         for (restart in restarts) {
[17:42:22.427]                           name <- restart$name
[17:42:22.427]                           if (is.null(name)) 
[17:42:22.427]                             next
[17:42:22.427]                           if (!grepl(pattern, name)) 
[17:42:22.427]                             next
[17:42:22.427]                           invokeRestart(restart)
[17:42:22.427]                           muffled <- TRUE
[17:42:22.427]                           break
[17:42:22.427]                         }
[17:42:22.427]                       }
[17:42:22.427]                     }
[17:42:22.427]                     invisible(muffled)
[17:42:22.427]                   }
[17:42:22.427]                   muffleCondition(cond)
[17:42:22.427]                 })
[17:42:22.427]             }))
[17:42:22.427]             future::FutureResult(value = ...future.value$value, 
[17:42:22.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.427]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.427]                     ...future.globalenv.names))
[17:42:22.427]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.427]         }, condition = base::local({
[17:42:22.427]             c <- base::c
[17:42:22.427]             inherits <- base::inherits
[17:42:22.427]             invokeRestart <- base::invokeRestart
[17:42:22.427]             length <- base::length
[17:42:22.427]             list <- base::list
[17:42:22.427]             seq.int <- base::seq.int
[17:42:22.427]             signalCondition <- base::signalCondition
[17:42:22.427]             sys.calls <- base::sys.calls
[17:42:22.427]             `[[` <- base::`[[`
[17:42:22.427]             `+` <- base::`+`
[17:42:22.427]             `<<-` <- base::`<<-`
[17:42:22.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.427]                   3L)]
[17:42:22.427]             }
[17:42:22.427]             function(cond) {
[17:42:22.427]                 is_error <- inherits(cond, "error")
[17:42:22.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.427]                   NULL)
[17:42:22.427]                 if (is_error) {
[17:42:22.427]                   sessionInformation <- function() {
[17:42:22.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.427]                       search = base::search(), system = base::Sys.info())
[17:42:22.427]                   }
[17:42:22.427]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.427]                     cond$call), session = sessionInformation(), 
[17:42:22.427]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.427]                   signalCondition(cond)
[17:42:22.427]                 }
[17:42:22.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.427]                 "immediateCondition"))) {
[17:42:22.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.427]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.427]                   if (TRUE && !signal) {
[17:42:22.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.427]                     {
[17:42:22.427]                       inherits <- base::inherits
[17:42:22.427]                       invokeRestart <- base::invokeRestart
[17:42:22.427]                       is.null <- base::is.null
[17:42:22.427]                       muffled <- FALSE
[17:42:22.427]                       if (inherits(cond, "message")) {
[17:42:22.427]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.427]                         if (muffled) 
[17:42:22.427]                           invokeRestart("muffleMessage")
[17:42:22.427]                       }
[17:42:22.427]                       else if (inherits(cond, "warning")) {
[17:42:22.427]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.427]                         if (muffled) 
[17:42:22.427]                           invokeRestart("muffleWarning")
[17:42:22.427]                       }
[17:42:22.427]                       else if (inherits(cond, "condition")) {
[17:42:22.427]                         if (!is.null(pattern)) {
[17:42:22.427]                           computeRestarts <- base::computeRestarts
[17:42:22.427]                           grepl <- base::grepl
[17:42:22.427]                           restarts <- computeRestarts(cond)
[17:42:22.427]                           for (restart in restarts) {
[17:42:22.427]                             name <- restart$name
[17:42:22.427]                             if (is.null(name)) 
[17:42:22.427]                               next
[17:42:22.427]                             if (!grepl(pattern, name)) 
[17:42:22.427]                               next
[17:42:22.427]                             invokeRestart(restart)
[17:42:22.427]                             muffled <- TRUE
[17:42:22.427]                             break
[17:42:22.427]                           }
[17:42:22.427]                         }
[17:42:22.427]                       }
[17:42:22.427]                       invisible(muffled)
[17:42:22.427]                     }
[17:42:22.427]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.427]                   }
[17:42:22.427]                 }
[17:42:22.427]                 else {
[17:42:22.427]                   if (TRUE) {
[17:42:22.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.427]                     {
[17:42:22.427]                       inherits <- base::inherits
[17:42:22.427]                       invokeRestart <- base::invokeRestart
[17:42:22.427]                       is.null <- base::is.null
[17:42:22.427]                       muffled <- FALSE
[17:42:22.427]                       if (inherits(cond, "message")) {
[17:42:22.427]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.427]                         if (muffled) 
[17:42:22.427]                           invokeRestart("muffleMessage")
[17:42:22.427]                       }
[17:42:22.427]                       else if (inherits(cond, "warning")) {
[17:42:22.427]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.427]                         if (muffled) 
[17:42:22.427]                           invokeRestart("muffleWarning")
[17:42:22.427]                       }
[17:42:22.427]                       else if (inherits(cond, "condition")) {
[17:42:22.427]                         if (!is.null(pattern)) {
[17:42:22.427]                           computeRestarts <- base::computeRestarts
[17:42:22.427]                           grepl <- base::grepl
[17:42:22.427]                           restarts <- computeRestarts(cond)
[17:42:22.427]                           for (restart in restarts) {
[17:42:22.427]                             name <- restart$name
[17:42:22.427]                             if (is.null(name)) 
[17:42:22.427]                               next
[17:42:22.427]                             if (!grepl(pattern, name)) 
[17:42:22.427]                               next
[17:42:22.427]                             invokeRestart(restart)
[17:42:22.427]                             muffled <- TRUE
[17:42:22.427]                             break
[17:42:22.427]                           }
[17:42:22.427]                         }
[17:42:22.427]                       }
[17:42:22.427]                       invisible(muffled)
[17:42:22.427]                     }
[17:42:22.427]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.427]                   }
[17:42:22.427]                 }
[17:42:22.427]             }
[17:42:22.427]         }))
[17:42:22.427]     }, error = function(ex) {
[17:42:22.427]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.427]                 ...future.rng), started = ...future.startTime, 
[17:42:22.427]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.427]             version = "1.8"), class = "FutureResult")
[17:42:22.427]     }, finally = {
[17:42:22.427]         if (!identical(...future.workdir, getwd())) 
[17:42:22.427]             setwd(...future.workdir)
[17:42:22.427]         {
[17:42:22.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.427]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.427]             }
[17:42:22.427]             base::options(...future.oldOptions)
[17:42:22.427]             if (.Platform$OS.type == "windows") {
[17:42:22.427]                 old_names <- names(...future.oldEnvVars)
[17:42:22.427]                 envs <- base::Sys.getenv()
[17:42:22.427]                 names <- names(envs)
[17:42:22.427]                 common <- intersect(names, old_names)
[17:42:22.427]                 added <- setdiff(names, old_names)
[17:42:22.427]                 removed <- setdiff(old_names, names)
[17:42:22.427]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.427]                   envs[common]]
[17:42:22.427]                 NAMES <- toupper(changed)
[17:42:22.427]                 args <- list()
[17:42:22.427]                 for (kk in seq_along(NAMES)) {
[17:42:22.427]                   name <- changed[[kk]]
[17:42:22.427]                   NAME <- NAMES[[kk]]
[17:42:22.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.427]                     next
[17:42:22.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.427]                 }
[17:42:22.427]                 NAMES <- toupper(added)
[17:42:22.427]                 for (kk in seq_along(NAMES)) {
[17:42:22.427]                   name <- added[[kk]]
[17:42:22.427]                   NAME <- NAMES[[kk]]
[17:42:22.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.427]                     next
[17:42:22.427]                   args[[name]] <- ""
[17:42:22.427]                 }
[17:42:22.427]                 NAMES <- toupper(removed)
[17:42:22.427]                 for (kk in seq_along(NAMES)) {
[17:42:22.427]                   name <- removed[[kk]]
[17:42:22.427]                   NAME <- NAMES[[kk]]
[17:42:22.427]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.427]                     next
[17:42:22.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.427]                 }
[17:42:22.427]                 if (length(args) > 0) 
[17:42:22.427]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.427]             }
[17:42:22.427]             else {
[17:42:22.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.427]             }
[17:42:22.427]             {
[17:42:22.427]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.427]                   0L) {
[17:42:22.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.427]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.427]                   base::options(opts)
[17:42:22.427]                 }
[17:42:22.427]                 {
[17:42:22.427]                   {
[17:42:22.427]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.427]                     NULL
[17:42:22.427]                   }
[17:42:22.427]                   options(future.plan = NULL)
[17:42:22.427]                   if (is.na(NA_character_)) 
[17:42:22.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.427]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.427]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.427]                     envir = parent.frame()) 
[17:42:22.427]                   {
[17:42:22.427]                     if (is.function(workers)) 
[17:42:22.427]                       workers <- workers()
[17:42:22.427]                     workers <- structure(as.integer(workers), 
[17:42:22.427]                       class = class(workers))
[17:42:22.427]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.427]                       workers >= 1)
[17:42:22.427]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.427]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.427]                     }
[17:42:22.427]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.427]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.427]                       envir = envir)
[17:42:22.427]                     if (!future$lazy) 
[17:42:22.427]                       future <- run(future)
[17:42:22.427]                     invisible(future)
[17:42:22.427]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.427]                 }
[17:42:22.427]             }
[17:42:22.427]         }
[17:42:22.427]     })
[17:42:22.427]     if (TRUE) {
[17:42:22.427]         base::sink(type = "output", split = FALSE)
[17:42:22.427]         if (TRUE) {
[17:42:22.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.427]         }
[17:42:22.427]         else {
[17:42:22.427]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.427]         }
[17:42:22.427]         base::close(...future.stdout)
[17:42:22.427]         ...future.stdout <- NULL
[17:42:22.427]     }
[17:42:22.427]     ...future.result$conditions <- ...future.conditions
[17:42:22.427]     ...future.result$finished <- base::Sys.time()
[17:42:22.427]     ...future.result
[17:42:22.427] }
[17:42:22.500] MultisessionFuture started
[17:42:22.500] - Launch lazy future ... done
[17:42:22.501] run() for ‘MultisessionFuture’ ... done
[17:42:22.501] getGlobalsAndPackages() ...
[17:42:22.501] Searching for globals...
[17:42:22.503] - globals found: [1] ‘{’
[17:42:22.503] Searching for globals ... DONE
[17:42:22.503] Resolving globals: FALSE
[17:42:22.503] 
[17:42:22.504] 
[17:42:22.504] getGlobalsAndPackages() ... DONE
[17:42:22.504] run() for ‘Future’ ...
[17:42:22.504] - state: ‘created’
[17:42:22.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.523] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.524]   - Field: ‘node’
[17:42:22.524]   - Field: ‘label’
[17:42:22.524]   - Field: ‘local’
[17:42:22.524]   - Field: ‘owner’
[17:42:22.524]   - Field: ‘envir’
[17:42:22.525]   - Field: ‘workers’
[17:42:22.525]   - Field: ‘packages’
[17:42:22.525]   - Field: ‘gc’
[17:42:22.525]   - Field: ‘conditions’
[17:42:22.525]   - Field: ‘persistent’
[17:42:22.525]   - Field: ‘expr’
[17:42:22.526]   - Field: ‘uuid’
[17:42:22.526]   - Field: ‘seed’
[17:42:22.526]   - Field: ‘version’
[17:42:22.526]   - Field: ‘result’
[17:42:22.526]   - Field: ‘asynchronous’
[17:42:22.527]   - Field: ‘calls’
[17:42:22.527]   - Field: ‘globals’
[17:42:22.527]   - Field: ‘stdout’
[17:42:22.527]   - Field: ‘earlySignal’
[17:42:22.527]   - Field: ‘lazy’
[17:42:22.527]   - Field: ‘state’
[17:42:22.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.528] - Launch lazy future ...
[17:42:22.528] Packages needed by the future expression (n = 0): <none>
[17:42:22.528] Packages needed by future strategies (n = 0): <none>
[17:42:22.529] {
[17:42:22.529]     {
[17:42:22.529]         {
[17:42:22.529]             ...future.startTime <- base::Sys.time()
[17:42:22.529]             {
[17:42:22.529]                 {
[17:42:22.529]                   {
[17:42:22.529]                     {
[17:42:22.529]                       base::local({
[17:42:22.529]                         has_future <- base::requireNamespace("future", 
[17:42:22.529]                           quietly = TRUE)
[17:42:22.529]                         if (has_future) {
[17:42:22.529]                           ns <- base::getNamespace("future")
[17:42:22.529]                           version <- ns[[".package"]][["version"]]
[17:42:22.529]                           if (is.null(version)) 
[17:42:22.529]                             version <- utils::packageVersion("future")
[17:42:22.529]                         }
[17:42:22.529]                         else {
[17:42:22.529]                           version <- NULL
[17:42:22.529]                         }
[17:42:22.529]                         if (!has_future || version < "1.8.0") {
[17:42:22.529]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.529]                             "", base::R.version$version.string), 
[17:42:22.529]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.529]                               "release", "version")], collapse = " "), 
[17:42:22.529]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.529]                             info)
[17:42:22.529]                           info <- base::paste(info, collapse = "; ")
[17:42:22.529]                           if (!has_future) {
[17:42:22.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.529]                               info)
[17:42:22.529]                           }
[17:42:22.529]                           else {
[17:42:22.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.529]                               info, version)
[17:42:22.529]                           }
[17:42:22.529]                           base::stop(msg)
[17:42:22.529]                         }
[17:42:22.529]                       })
[17:42:22.529]                     }
[17:42:22.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.529]                     base::options(mc.cores = 1L)
[17:42:22.529]                   }
[17:42:22.529]                   options(future.plan = NULL)
[17:42:22.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.529]                 }
[17:42:22.529]                 ...future.workdir <- getwd()
[17:42:22.529]             }
[17:42:22.529]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.529]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.529]         }
[17:42:22.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.529]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.529]             base::names(...future.oldOptions))
[17:42:22.529]     }
[17:42:22.529]     if (FALSE) {
[17:42:22.529]     }
[17:42:22.529]     else {
[17:42:22.529]         if (TRUE) {
[17:42:22.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.529]                 open = "w")
[17:42:22.529]         }
[17:42:22.529]         else {
[17:42:22.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.529]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.529]         }
[17:42:22.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.529]             base::sink(type = "output", split = FALSE)
[17:42:22.529]             base::close(...future.stdout)
[17:42:22.529]         }, add = TRUE)
[17:42:22.529]     }
[17:42:22.529]     ...future.frame <- base::sys.nframe()
[17:42:22.529]     ...future.conditions <- base::list()
[17:42:22.529]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.529]     if (FALSE) {
[17:42:22.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.529]     }
[17:42:22.529]     ...future.result <- base::tryCatch({
[17:42:22.529]         base::withCallingHandlers({
[17:42:22.529]             ...future.value <- base::withVisible(base::local({
[17:42:22.529]                 ...future.makeSendCondition <- local({
[17:42:22.529]                   sendCondition <- NULL
[17:42:22.529]                   function(frame = 1L) {
[17:42:22.529]                     if (is.function(sendCondition)) 
[17:42:22.529]                       return(sendCondition)
[17:42:22.529]                     ns <- getNamespace("parallel")
[17:42:22.529]                     if (exists("sendData", mode = "function", 
[17:42:22.529]                       envir = ns)) {
[17:42:22.529]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.529]                         envir = ns)
[17:42:22.529]                       envir <- sys.frame(frame)
[17:42:22.529]                       master <- NULL
[17:42:22.529]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.529]                         !identical(envir, emptyenv())) {
[17:42:22.529]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.529]                           inherits = FALSE)) {
[17:42:22.529]                           master <- get("master", mode = "list", 
[17:42:22.529]                             envir = envir, inherits = FALSE)
[17:42:22.529]                           if (inherits(master, c("SOCKnode", 
[17:42:22.529]                             "SOCK0node"))) {
[17:42:22.529]                             sendCondition <<- function(cond) {
[17:42:22.529]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.529]                                 success = TRUE)
[17:42:22.529]                               parallel_sendData(master, data)
[17:42:22.529]                             }
[17:42:22.529]                             return(sendCondition)
[17:42:22.529]                           }
[17:42:22.529]                         }
[17:42:22.529]                         frame <- frame + 1L
[17:42:22.529]                         envir <- sys.frame(frame)
[17:42:22.529]                       }
[17:42:22.529]                     }
[17:42:22.529]                     sendCondition <<- function(cond) NULL
[17:42:22.529]                   }
[17:42:22.529]                 })
[17:42:22.529]                 withCallingHandlers({
[17:42:22.529]                   {
[17:42:22.529]                     4
[17:42:22.529]                   }
[17:42:22.529]                 }, immediateCondition = function(cond) {
[17:42:22.529]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.529]                   sendCondition(cond)
[17:42:22.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.529]                   {
[17:42:22.529]                     inherits <- base::inherits
[17:42:22.529]                     invokeRestart <- base::invokeRestart
[17:42:22.529]                     is.null <- base::is.null
[17:42:22.529]                     muffled <- FALSE
[17:42:22.529]                     if (inherits(cond, "message")) {
[17:42:22.529]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.529]                       if (muffled) 
[17:42:22.529]                         invokeRestart("muffleMessage")
[17:42:22.529]                     }
[17:42:22.529]                     else if (inherits(cond, "warning")) {
[17:42:22.529]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.529]                       if (muffled) 
[17:42:22.529]                         invokeRestart("muffleWarning")
[17:42:22.529]                     }
[17:42:22.529]                     else if (inherits(cond, "condition")) {
[17:42:22.529]                       if (!is.null(pattern)) {
[17:42:22.529]                         computeRestarts <- base::computeRestarts
[17:42:22.529]                         grepl <- base::grepl
[17:42:22.529]                         restarts <- computeRestarts(cond)
[17:42:22.529]                         for (restart in restarts) {
[17:42:22.529]                           name <- restart$name
[17:42:22.529]                           if (is.null(name)) 
[17:42:22.529]                             next
[17:42:22.529]                           if (!grepl(pattern, name)) 
[17:42:22.529]                             next
[17:42:22.529]                           invokeRestart(restart)
[17:42:22.529]                           muffled <- TRUE
[17:42:22.529]                           break
[17:42:22.529]                         }
[17:42:22.529]                       }
[17:42:22.529]                     }
[17:42:22.529]                     invisible(muffled)
[17:42:22.529]                   }
[17:42:22.529]                   muffleCondition(cond)
[17:42:22.529]                 })
[17:42:22.529]             }))
[17:42:22.529]             future::FutureResult(value = ...future.value$value, 
[17:42:22.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.529]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.529]                     ...future.globalenv.names))
[17:42:22.529]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.529]         }, condition = base::local({
[17:42:22.529]             c <- base::c
[17:42:22.529]             inherits <- base::inherits
[17:42:22.529]             invokeRestart <- base::invokeRestart
[17:42:22.529]             length <- base::length
[17:42:22.529]             list <- base::list
[17:42:22.529]             seq.int <- base::seq.int
[17:42:22.529]             signalCondition <- base::signalCondition
[17:42:22.529]             sys.calls <- base::sys.calls
[17:42:22.529]             `[[` <- base::`[[`
[17:42:22.529]             `+` <- base::`+`
[17:42:22.529]             `<<-` <- base::`<<-`
[17:42:22.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.529]                   3L)]
[17:42:22.529]             }
[17:42:22.529]             function(cond) {
[17:42:22.529]                 is_error <- inherits(cond, "error")
[17:42:22.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.529]                   NULL)
[17:42:22.529]                 if (is_error) {
[17:42:22.529]                   sessionInformation <- function() {
[17:42:22.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.529]                       search = base::search(), system = base::Sys.info())
[17:42:22.529]                   }
[17:42:22.529]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.529]                     cond$call), session = sessionInformation(), 
[17:42:22.529]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.529]                   signalCondition(cond)
[17:42:22.529]                 }
[17:42:22.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.529]                 "immediateCondition"))) {
[17:42:22.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.529]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.529]                   if (TRUE && !signal) {
[17:42:22.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.529]                     {
[17:42:22.529]                       inherits <- base::inherits
[17:42:22.529]                       invokeRestart <- base::invokeRestart
[17:42:22.529]                       is.null <- base::is.null
[17:42:22.529]                       muffled <- FALSE
[17:42:22.529]                       if (inherits(cond, "message")) {
[17:42:22.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.529]                         if (muffled) 
[17:42:22.529]                           invokeRestart("muffleMessage")
[17:42:22.529]                       }
[17:42:22.529]                       else if (inherits(cond, "warning")) {
[17:42:22.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.529]                         if (muffled) 
[17:42:22.529]                           invokeRestart("muffleWarning")
[17:42:22.529]                       }
[17:42:22.529]                       else if (inherits(cond, "condition")) {
[17:42:22.529]                         if (!is.null(pattern)) {
[17:42:22.529]                           computeRestarts <- base::computeRestarts
[17:42:22.529]                           grepl <- base::grepl
[17:42:22.529]                           restarts <- computeRestarts(cond)
[17:42:22.529]                           for (restart in restarts) {
[17:42:22.529]                             name <- restart$name
[17:42:22.529]                             if (is.null(name)) 
[17:42:22.529]                               next
[17:42:22.529]                             if (!grepl(pattern, name)) 
[17:42:22.529]                               next
[17:42:22.529]                             invokeRestart(restart)
[17:42:22.529]                             muffled <- TRUE
[17:42:22.529]                             break
[17:42:22.529]                           }
[17:42:22.529]                         }
[17:42:22.529]                       }
[17:42:22.529]                       invisible(muffled)
[17:42:22.529]                     }
[17:42:22.529]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.529]                   }
[17:42:22.529]                 }
[17:42:22.529]                 else {
[17:42:22.529]                   if (TRUE) {
[17:42:22.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.529]                     {
[17:42:22.529]                       inherits <- base::inherits
[17:42:22.529]                       invokeRestart <- base::invokeRestart
[17:42:22.529]                       is.null <- base::is.null
[17:42:22.529]                       muffled <- FALSE
[17:42:22.529]                       if (inherits(cond, "message")) {
[17:42:22.529]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.529]                         if (muffled) 
[17:42:22.529]                           invokeRestart("muffleMessage")
[17:42:22.529]                       }
[17:42:22.529]                       else if (inherits(cond, "warning")) {
[17:42:22.529]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.529]                         if (muffled) 
[17:42:22.529]                           invokeRestart("muffleWarning")
[17:42:22.529]                       }
[17:42:22.529]                       else if (inherits(cond, "condition")) {
[17:42:22.529]                         if (!is.null(pattern)) {
[17:42:22.529]                           computeRestarts <- base::computeRestarts
[17:42:22.529]                           grepl <- base::grepl
[17:42:22.529]                           restarts <- computeRestarts(cond)
[17:42:22.529]                           for (restart in restarts) {
[17:42:22.529]                             name <- restart$name
[17:42:22.529]                             if (is.null(name)) 
[17:42:22.529]                               next
[17:42:22.529]                             if (!grepl(pattern, name)) 
[17:42:22.529]                               next
[17:42:22.529]                             invokeRestart(restart)
[17:42:22.529]                             muffled <- TRUE
[17:42:22.529]                             break
[17:42:22.529]                           }
[17:42:22.529]                         }
[17:42:22.529]                       }
[17:42:22.529]                       invisible(muffled)
[17:42:22.529]                     }
[17:42:22.529]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.529]                   }
[17:42:22.529]                 }
[17:42:22.529]             }
[17:42:22.529]         }))
[17:42:22.529]     }, error = function(ex) {
[17:42:22.529]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.529]                 ...future.rng), started = ...future.startTime, 
[17:42:22.529]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.529]             version = "1.8"), class = "FutureResult")
[17:42:22.529]     }, finally = {
[17:42:22.529]         if (!identical(...future.workdir, getwd())) 
[17:42:22.529]             setwd(...future.workdir)
[17:42:22.529]         {
[17:42:22.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.529]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.529]             }
[17:42:22.529]             base::options(...future.oldOptions)
[17:42:22.529]             if (.Platform$OS.type == "windows") {
[17:42:22.529]                 old_names <- names(...future.oldEnvVars)
[17:42:22.529]                 envs <- base::Sys.getenv()
[17:42:22.529]                 names <- names(envs)
[17:42:22.529]                 common <- intersect(names, old_names)
[17:42:22.529]                 added <- setdiff(names, old_names)
[17:42:22.529]                 removed <- setdiff(old_names, names)
[17:42:22.529]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.529]                   envs[common]]
[17:42:22.529]                 NAMES <- toupper(changed)
[17:42:22.529]                 args <- list()
[17:42:22.529]                 for (kk in seq_along(NAMES)) {
[17:42:22.529]                   name <- changed[[kk]]
[17:42:22.529]                   NAME <- NAMES[[kk]]
[17:42:22.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.529]                     next
[17:42:22.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.529]                 }
[17:42:22.529]                 NAMES <- toupper(added)
[17:42:22.529]                 for (kk in seq_along(NAMES)) {
[17:42:22.529]                   name <- added[[kk]]
[17:42:22.529]                   NAME <- NAMES[[kk]]
[17:42:22.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.529]                     next
[17:42:22.529]                   args[[name]] <- ""
[17:42:22.529]                 }
[17:42:22.529]                 NAMES <- toupper(removed)
[17:42:22.529]                 for (kk in seq_along(NAMES)) {
[17:42:22.529]                   name <- removed[[kk]]
[17:42:22.529]                   NAME <- NAMES[[kk]]
[17:42:22.529]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.529]                     next
[17:42:22.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.529]                 }
[17:42:22.529]                 if (length(args) > 0) 
[17:42:22.529]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.529]             }
[17:42:22.529]             else {
[17:42:22.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.529]             }
[17:42:22.529]             {
[17:42:22.529]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.529]                   0L) {
[17:42:22.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.529]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.529]                   base::options(opts)
[17:42:22.529]                 }
[17:42:22.529]                 {
[17:42:22.529]                   {
[17:42:22.529]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.529]                     NULL
[17:42:22.529]                   }
[17:42:22.529]                   options(future.plan = NULL)
[17:42:22.529]                   if (is.na(NA_character_)) 
[17:42:22.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.529]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.529]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.529]                     envir = parent.frame()) 
[17:42:22.529]                   {
[17:42:22.529]                     if (is.function(workers)) 
[17:42:22.529]                       workers <- workers()
[17:42:22.529]                     workers <- structure(as.integer(workers), 
[17:42:22.529]                       class = class(workers))
[17:42:22.529]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.529]                       workers >= 1)
[17:42:22.529]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.529]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.529]                     }
[17:42:22.529]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.529]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.529]                       envir = envir)
[17:42:22.529]                     if (!future$lazy) 
[17:42:22.529]                       future <- run(future)
[17:42:22.529]                     invisible(future)
[17:42:22.529]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.529]                 }
[17:42:22.529]             }
[17:42:22.529]         }
[17:42:22.529]     })
[17:42:22.529]     if (TRUE) {
[17:42:22.529]         base::sink(type = "output", split = FALSE)
[17:42:22.529]         if (TRUE) {
[17:42:22.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.529]         }
[17:42:22.529]         else {
[17:42:22.529]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.529]         }
[17:42:22.529]         base::close(...future.stdout)
[17:42:22.529]         ...future.stdout <- NULL
[17:42:22.529]     }
[17:42:22.529]     ...future.result$conditions <- ...future.conditions
[17:42:22.529]     ...future.result$finished <- base::Sys.time()
[17:42:22.529]     ...future.result
[17:42:22.529] }
[17:42:22.533] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:22.544] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.544] - Validating connection of MultisessionFuture
[17:42:22.544] - received message: FutureResult
[17:42:22.544] - Received FutureResult
[17:42:22.545] - Erased future from FutureRegistry
[17:42:22.545] result() for ClusterFuture ...
[17:42:22.545] - result already collected: FutureResult
[17:42:22.545] result() for ClusterFuture ... done
[17:42:22.545] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.545] result() for ClusterFuture ...
[17:42:22.546] - result already collected: FutureResult
[17:42:22.546] result() for ClusterFuture ... done
[17:42:22.546] result() for ClusterFuture ...
[17:42:22.546] - result already collected: FutureResult
[17:42:22.546] result() for ClusterFuture ... done
[17:42:22.548] MultisessionFuture started
[17:42:22.548] - Launch lazy future ... done
[17:42:22.548] run() for ‘MultisessionFuture’ ... done
<environment: 0x55bef9bbd548> 
<environment: 0x55bef7eb6a28> 
[17:42:22.550] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.550] - Validating connection of MultisessionFuture
[17:42:22.550] - received message: FutureResult
[17:42:22.550] - Received FutureResult
[17:42:22.550] - Erased future from FutureRegistry
[17:42:22.550] result() for ClusterFuture ...
[17:42:22.550] - result already collected: FutureResult
[17:42:22.550] result() for ClusterFuture ... done
[17:42:22.550] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:22.562] resolve() on environment ...
[17:42:22.562]  recursive: 0
[17:42:22.563]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:22.563] signalConditionsASAP(numeric, pos=1) ...
[17:42:22.563] - nx: 4
[17:42:22.563] - relay: TRUE
[17:42:22.563] - stdout: TRUE
[17:42:22.563] - signal: TRUE
[17:42:22.564] - resignal: FALSE
[17:42:22.564] - force: TRUE
[17:42:22.564] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.564] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.564]  - until=2
[17:42:22.564]  - relaying element #2
[17:42:22.564] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.564] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.564] signalConditionsASAP(NULL, pos=1) ... done
[17:42:22.564]  length: 3 (resolved future 1)
[17:42:22.564] Future #2
[17:42:22.565] result() for ClusterFuture ...
[17:42:22.565] - result already collected: FutureResult
[17:42:22.565] result() for ClusterFuture ... done
[17:42:22.565] result() for ClusterFuture ...
[17:42:22.565] - result already collected: FutureResult
[17:42:22.565] result() for ClusterFuture ... done
[17:42:22.565] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:22.565] - nx: 4
[17:42:22.565] - relay: TRUE
[17:42:22.565] - stdout: TRUE
[17:42:22.565] - signal: TRUE
[17:42:22.566] - resignal: FALSE
[17:42:22.566] - force: TRUE
[17:42:22.566] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.566] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.566]  - until=2
[17:42:22.566]  - relaying element #2
[17:42:22.566] result() for ClusterFuture ...
[17:42:22.566] - result already collected: FutureResult
[17:42:22.566] result() for ClusterFuture ... done
[17:42:22.566] result() for ClusterFuture ...
[17:42:22.566] - result already collected: FutureResult
[17:42:22.567] result() for ClusterFuture ... done
[17:42:22.567] result() for ClusterFuture ...
[17:42:22.567] - result already collected: FutureResult
[17:42:22.567] result() for ClusterFuture ... done
[17:42:22.567] result() for ClusterFuture ...
[17:42:22.567] - result already collected: FutureResult
[17:42:22.567] result() for ClusterFuture ... done
[17:42:22.567] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:22.567] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:22.568] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:22.568]  length: 2 (resolved future 2)
[17:42:22.568] Future #3
[17:42:22.568] result() for ClusterFuture ...
[17:42:22.568] - result already collected: FutureResult
[17:42:22.568] result() for ClusterFuture ... done
[17:42:22.568] result() for ClusterFuture ...
[17:42:22.568] - result already collected: FutureResult
[17:42:22.568] result() for ClusterFuture ... done
[17:42:22.568] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:22.568] - nx: 4
[17:42:22.569] - relay: TRUE
[17:42:22.569] - stdout: TRUE
[17:42:22.569] - signal: TRUE
[17:42:22.569] - resignal: FALSE
[17:42:22.569] - force: TRUE
[17:42:22.569] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:22.569] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:22.569]  - until=3
[17:42:22.569]  - relaying element #3
[17:42:22.569] result() for ClusterFuture ...
[17:42:22.569] - result already collected: FutureResult
[17:42:22.570] result() for ClusterFuture ... done
[17:42:22.570] result() for ClusterFuture ...
[17:42:22.570] - result already collected: FutureResult
[17:42:22.570] result() for ClusterFuture ... done
[17:42:22.570] result() for ClusterFuture ...
[17:42:22.570] - result already collected: FutureResult
[17:42:22.570] result() for ClusterFuture ... done
[17:42:22.570] result() for ClusterFuture ...
[17:42:22.570] - result already collected: FutureResult
[17:42:22.570] result() for ClusterFuture ... done
[17:42:22.570] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:22.571] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:22.571] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:22.571]  length: 1 (resolved future 3)
[17:42:22.596] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.596] - Validating connection of MultisessionFuture
[17:42:22.596] - received message: FutureResult
[17:42:22.596] - Received FutureResult
[17:42:22.596] - Erased future from FutureRegistry
[17:42:22.597] result() for ClusterFuture ...
[17:42:22.597] - result already collected: FutureResult
[17:42:22.597] result() for ClusterFuture ... done
[17:42:22.597] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.597] Future #4
[17:42:22.597] result() for ClusterFuture ...
[17:42:22.597] - result already collected: FutureResult
[17:42:22.597] result() for ClusterFuture ... done
[17:42:22.597] result() for ClusterFuture ...
[17:42:22.597] - result already collected: FutureResult
[17:42:22.598] result() for ClusterFuture ... done
[17:42:22.598] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:22.598] - nx: 4
[17:42:22.598] - relay: TRUE
[17:42:22.598] - stdout: TRUE
[17:42:22.598] - signal: TRUE
[17:42:22.598] - resignal: FALSE
[17:42:22.598] - force: TRUE
[17:42:22.598] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:22.598] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:22.598]  - until=4
[17:42:22.599]  - relaying element #4
[17:42:22.599] result() for ClusterFuture ...
[17:42:22.599] - result already collected: FutureResult
[17:42:22.599] result() for ClusterFuture ... done
[17:42:22.599] result() for ClusterFuture ...
[17:42:22.599] - result already collected: FutureResult
[17:42:22.599] result() for ClusterFuture ... done
[17:42:22.599] result() for ClusterFuture ...
[17:42:22.599] - result already collected: FutureResult
[17:42:22.599] result() for ClusterFuture ... done
[17:42:22.600] result() for ClusterFuture ...
[17:42:22.600] - result already collected: FutureResult
[17:42:22.600] result() for ClusterFuture ... done
[17:42:22.600] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.600] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:22.600] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:22.600]  length: 0 (resolved future 4)
[17:42:22.600] Relaying remaining futures
[17:42:22.600] signalConditionsASAP(NULL, pos=0) ...
[17:42:22.600] - nx: 4
[17:42:22.600] - relay: TRUE
[17:42:22.601] - stdout: TRUE
[17:42:22.601] - signal: TRUE
[17:42:22.601] - resignal: FALSE
[17:42:22.601] - force: TRUE
[17:42:22.601] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.601] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:22.601] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.601] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:22.601] signalConditionsASAP(NULL, pos=0) ... done
[17:42:22.601] resolve() on environment ... DONE
[17:42:22.601] result() for ClusterFuture ...
[17:42:22.602] - result already collected: FutureResult
[17:42:22.602] result() for ClusterFuture ... done
[17:42:22.602] result() for ClusterFuture ...
[17:42:22.602] - result already collected: FutureResult
[17:42:22.602] result() for ClusterFuture ... done
[17:42:22.602] result() for ClusterFuture ...
[17:42:22.602] - result already collected: FutureResult
[17:42:22.602] result() for ClusterFuture ... done
[17:42:22.602] result() for ClusterFuture ...
[17:42:22.602] - result already collected: FutureResult
[17:42:22.602] result() for ClusterFuture ... done
[17:42:22.603] result() for ClusterFuture ...
[17:42:22.603] - result already collected: FutureResult
[17:42:22.603] result() for ClusterFuture ... done
[17:42:22.603] result() for ClusterFuture ...
[17:42:22.603] - result already collected: FutureResult
[17:42:22.603] result() for ClusterFuture ... done
<environment: 0x55bef7adb508> 
Dimensions: c(1, 6)
[17:42:22.603] getGlobalsAndPackages() ...
[17:42:22.604] Searching for globals...
[17:42:22.604] 
[17:42:22.604] Searching for globals ... DONE
[17:42:22.604] - globals: [0] <none>
[17:42:22.604] getGlobalsAndPackages() ... DONE
[17:42:22.605] run() for ‘Future’ ...
[17:42:22.605] - state: ‘created’
[17:42:22.605] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.619] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.619]   - Field: ‘node’
[17:42:22.620]   - Field: ‘label’
[17:42:22.620]   - Field: ‘local’
[17:42:22.620]   - Field: ‘owner’
[17:42:22.620]   - Field: ‘envir’
[17:42:22.620]   - Field: ‘workers’
[17:42:22.620]   - Field: ‘packages’
[17:42:22.620]   - Field: ‘gc’
[17:42:22.620]   - Field: ‘conditions’
[17:42:22.620]   - Field: ‘persistent’
[17:42:22.620]   - Field: ‘expr’
[17:42:22.621]   - Field: ‘uuid’
[17:42:22.621]   - Field: ‘seed’
[17:42:22.621]   - Field: ‘version’
[17:42:22.621]   - Field: ‘result’
[17:42:22.621]   - Field: ‘asynchronous’
[17:42:22.621]   - Field: ‘calls’
[17:42:22.621]   - Field: ‘globals’
[17:42:22.621]   - Field: ‘stdout’
[17:42:22.621]   - Field: ‘earlySignal’
[17:42:22.621]   - Field: ‘lazy’
[17:42:22.621]   - Field: ‘state’
[17:42:22.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.622] - Launch lazy future ...
[17:42:22.622] Packages needed by the future expression (n = 0): <none>
[17:42:22.622] Packages needed by future strategies (n = 0): <none>
[17:42:22.623] {
[17:42:22.623]     {
[17:42:22.623]         {
[17:42:22.623]             ...future.startTime <- base::Sys.time()
[17:42:22.623]             {
[17:42:22.623]                 {
[17:42:22.623]                   {
[17:42:22.623]                     {
[17:42:22.623]                       base::local({
[17:42:22.623]                         has_future <- base::requireNamespace("future", 
[17:42:22.623]                           quietly = TRUE)
[17:42:22.623]                         if (has_future) {
[17:42:22.623]                           ns <- base::getNamespace("future")
[17:42:22.623]                           version <- ns[[".package"]][["version"]]
[17:42:22.623]                           if (is.null(version)) 
[17:42:22.623]                             version <- utils::packageVersion("future")
[17:42:22.623]                         }
[17:42:22.623]                         else {
[17:42:22.623]                           version <- NULL
[17:42:22.623]                         }
[17:42:22.623]                         if (!has_future || version < "1.8.0") {
[17:42:22.623]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.623]                             "", base::R.version$version.string), 
[17:42:22.623]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.623]                               "release", "version")], collapse = " "), 
[17:42:22.623]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.623]                             info)
[17:42:22.623]                           info <- base::paste(info, collapse = "; ")
[17:42:22.623]                           if (!has_future) {
[17:42:22.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.623]                               info)
[17:42:22.623]                           }
[17:42:22.623]                           else {
[17:42:22.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.623]                               info, version)
[17:42:22.623]                           }
[17:42:22.623]                           base::stop(msg)
[17:42:22.623]                         }
[17:42:22.623]                       })
[17:42:22.623]                     }
[17:42:22.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.623]                     base::options(mc.cores = 1L)
[17:42:22.623]                   }
[17:42:22.623]                   options(future.plan = NULL)
[17:42:22.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.623]                 }
[17:42:22.623]                 ...future.workdir <- getwd()
[17:42:22.623]             }
[17:42:22.623]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.623]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.623]         }
[17:42:22.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.623]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.623]             base::names(...future.oldOptions))
[17:42:22.623]     }
[17:42:22.623]     if (FALSE) {
[17:42:22.623]     }
[17:42:22.623]     else {
[17:42:22.623]         if (TRUE) {
[17:42:22.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.623]                 open = "w")
[17:42:22.623]         }
[17:42:22.623]         else {
[17:42:22.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.623]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.623]         }
[17:42:22.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.623]             base::sink(type = "output", split = FALSE)
[17:42:22.623]             base::close(...future.stdout)
[17:42:22.623]         }, add = TRUE)
[17:42:22.623]     }
[17:42:22.623]     ...future.frame <- base::sys.nframe()
[17:42:22.623]     ...future.conditions <- base::list()
[17:42:22.623]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.623]     if (FALSE) {
[17:42:22.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.623]     }
[17:42:22.623]     ...future.result <- base::tryCatch({
[17:42:22.623]         base::withCallingHandlers({
[17:42:22.623]             ...future.value <- base::withVisible(base::local({
[17:42:22.623]                 ...future.makeSendCondition <- local({
[17:42:22.623]                   sendCondition <- NULL
[17:42:22.623]                   function(frame = 1L) {
[17:42:22.623]                     if (is.function(sendCondition)) 
[17:42:22.623]                       return(sendCondition)
[17:42:22.623]                     ns <- getNamespace("parallel")
[17:42:22.623]                     if (exists("sendData", mode = "function", 
[17:42:22.623]                       envir = ns)) {
[17:42:22.623]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.623]                         envir = ns)
[17:42:22.623]                       envir <- sys.frame(frame)
[17:42:22.623]                       master <- NULL
[17:42:22.623]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.623]                         !identical(envir, emptyenv())) {
[17:42:22.623]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.623]                           inherits = FALSE)) {
[17:42:22.623]                           master <- get("master", mode = "list", 
[17:42:22.623]                             envir = envir, inherits = FALSE)
[17:42:22.623]                           if (inherits(master, c("SOCKnode", 
[17:42:22.623]                             "SOCK0node"))) {
[17:42:22.623]                             sendCondition <<- function(cond) {
[17:42:22.623]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.623]                                 success = TRUE)
[17:42:22.623]                               parallel_sendData(master, data)
[17:42:22.623]                             }
[17:42:22.623]                             return(sendCondition)
[17:42:22.623]                           }
[17:42:22.623]                         }
[17:42:22.623]                         frame <- frame + 1L
[17:42:22.623]                         envir <- sys.frame(frame)
[17:42:22.623]                       }
[17:42:22.623]                     }
[17:42:22.623]                     sendCondition <<- function(cond) NULL
[17:42:22.623]                   }
[17:42:22.623]                 })
[17:42:22.623]                 withCallingHandlers({
[17:42:22.623]                   2
[17:42:22.623]                 }, immediateCondition = function(cond) {
[17:42:22.623]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.623]                   sendCondition(cond)
[17:42:22.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.623]                   {
[17:42:22.623]                     inherits <- base::inherits
[17:42:22.623]                     invokeRestart <- base::invokeRestart
[17:42:22.623]                     is.null <- base::is.null
[17:42:22.623]                     muffled <- FALSE
[17:42:22.623]                     if (inherits(cond, "message")) {
[17:42:22.623]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.623]                       if (muffled) 
[17:42:22.623]                         invokeRestart("muffleMessage")
[17:42:22.623]                     }
[17:42:22.623]                     else if (inherits(cond, "warning")) {
[17:42:22.623]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.623]                       if (muffled) 
[17:42:22.623]                         invokeRestart("muffleWarning")
[17:42:22.623]                     }
[17:42:22.623]                     else if (inherits(cond, "condition")) {
[17:42:22.623]                       if (!is.null(pattern)) {
[17:42:22.623]                         computeRestarts <- base::computeRestarts
[17:42:22.623]                         grepl <- base::grepl
[17:42:22.623]                         restarts <- computeRestarts(cond)
[17:42:22.623]                         for (restart in restarts) {
[17:42:22.623]                           name <- restart$name
[17:42:22.623]                           if (is.null(name)) 
[17:42:22.623]                             next
[17:42:22.623]                           if (!grepl(pattern, name)) 
[17:42:22.623]                             next
[17:42:22.623]                           invokeRestart(restart)
[17:42:22.623]                           muffled <- TRUE
[17:42:22.623]                           break
[17:42:22.623]                         }
[17:42:22.623]                       }
[17:42:22.623]                     }
[17:42:22.623]                     invisible(muffled)
[17:42:22.623]                   }
[17:42:22.623]                   muffleCondition(cond)
[17:42:22.623]                 })
[17:42:22.623]             }))
[17:42:22.623]             future::FutureResult(value = ...future.value$value, 
[17:42:22.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.623]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.623]                     ...future.globalenv.names))
[17:42:22.623]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.623]         }, condition = base::local({
[17:42:22.623]             c <- base::c
[17:42:22.623]             inherits <- base::inherits
[17:42:22.623]             invokeRestart <- base::invokeRestart
[17:42:22.623]             length <- base::length
[17:42:22.623]             list <- base::list
[17:42:22.623]             seq.int <- base::seq.int
[17:42:22.623]             signalCondition <- base::signalCondition
[17:42:22.623]             sys.calls <- base::sys.calls
[17:42:22.623]             `[[` <- base::`[[`
[17:42:22.623]             `+` <- base::`+`
[17:42:22.623]             `<<-` <- base::`<<-`
[17:42:22.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.623]                   3L)]
[17:42:22.623]             }
[17:42:22.623]             function(cond) {
[17:42:22.623]                 is_error <- inherits(cond, "error")
[17:42:22.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.623]                   NULL)
[17:42:22.623]                 if (is_error) {
[17:42:22.623]                   sessionInformation <- function() {
[17:42:22.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.623]                       search = base::search(), system = base::Sys.info())
[17:42:22.623]                   }
[17:42:22.623]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.623]                     cond$call), session = sessionInformation(), 
[17:42:22.623]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.623]                   signalCondition(cond)
[17:42:22.623]                 }
[17:42:22.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.623]                 "immediateCondition"))) {
[17:42:22.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.623]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.623]                   if (TRUE && !signal) {
[17:42:22.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.623]                     {
[17:42:22.623]                       inherits <- base::inherits
[17:42:22.623]                       invokeRestart <- base::invokeRestart
[17:42:22.623]                       is.null <- base::is.null
[17:42:22.623]                       muffled <- FALSE
[17:42:22.623]                       if (inherits(cond, "message")) {
[17:42:22.623]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.623]                         if (muffled) 
[17:42:22.623]                           invokeRestart("muffleMessage")
[17:42:22.623]                       }
[17:42:22.623]                       else if (inherits(cond, "warning")) {
[17:42:22.623]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.623]                         if (muffled) 
[17:42:22.623]                           invokeRestart("muffleWarning")
[17:42:22.623]                       }
[17:42:22.623]                       else if (inherits(cond, "condition")) {
[17:42:22.623]                         if (!is.null(pattern)) {
[17:42:22.623]                           computeRestarts <- base::computeRestarts
[17:42:22.623]                           grepl <- base::grepl
[17:42:22.623]                           restarts <- computeRestarts(cond)
[17:42:22.623]                           for (restart in restarts) {
[17:42:22.623]                             name <- restart$name
[17:42:22.623]                             if (is.null(name)) 
[17:42:22.623]                               next
[17:42:22.623]                             if (!grepl(pattern, name)) 
[17:42:22.623]                               next
[17:42:22.623]                             invokeRestart(restart)
[17:42:22.623]                             muffled <- TRUE
[17:42:22.623]                             break
[17:42:22.623]                           }
[17:42:22.623]                         }
[17:42:22.623]                       }
[17:42:22.623]                       invisible(muffled)
[17:42:22.623]                     }
[17:42:22.623]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.623]                   }
[17:42:22.623]                 }
[17:42:22.623]                 else {
[17:42:22.623]                   if (TRUE) {
[17:42:22.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.623]                     {
[17:42:22.623]                       inherits <- base::inherits
[17:42:22.623]                       invokeRestart <- base::invokeRestart
[17:42:22.623]                       is.null <- base::is.null
[17:42:22.623]                       muffled <- FALSE
[17:42:22.623]                       if (inherits(cond, "message")) {
[17:42:22.623]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.623]                         if (muffled) 
[17:42:22.623]                           invokeRestart("muffleMessage")
[17:42:22.623]                       }
[17:42:22.623]                       else if (inherits(cond, "warning")) {
[17:42:22.623]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.623]                         if (muffled) 
[17:42:22.623]                           invokeRestart("muffleWarning")
[17:42:22.623]                       }
[17:42:22.623]                       else if (inherits(cond, "condition")) {
[17:42:22.623]                         if (!is.null(pattern)) {
[17:42:22.623]                           computeRestarts <- base::computeRestarts
[17:42:22.623]                           grepl <- base::grepl
[17:42:22.623]                           restarts <- computeRestarts(cond)
[17:42:22.623]                           for (restart in restarts) {
[17:42:22.623]                             name <- restart$name
[17:42:22.623]                             if (is.null(name)) 
[17:42:22.623]                               next
[17:42:22.623]                             if (!grepl(pattern, name)) 
[17:42:22.623]                               next
[17:42:22.623]                             invokeRestart(restart)
[17:42:22.623]                             muffled <- TRUE
[17:42:22.623]                             break
[17:42:22.623]                           }
[17:42:22.623]                         }
[17:42:22.623]                       }
[17:42:22.623]                       invisible(muffled)
[17:42:22.623]                     }
[17:42:22.623]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.623]                   }
[17:42:22.623]                 }
[17:42:22.623]             }
[17:42:22.623]         }))
[17:42:22.623]     }, error = function(ex) {
[17:42:22.623]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.623]                 ...future.rng), started = ...future.startTime, 
[17:42:22.623]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.623]             version = "1.8"), class = "FutureResult")
[17:42:22.623]     }, finally = {
[17:42:22.623]         if (!identical(...future.workdir, getwd())) 
[17:42:22.623]             setwd(...future.workdir)
[17:42:22.623]         {
[17:42:22.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.623]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.623]             }
[17:42:22.623]             base::options(...future.oldOptions)
[17:42:22.623]             if (.Platform$OS.type == "windows") {
[17:42:22.623]                 old_names <- names(...future.oldEnvVars)
[17:42:22.623]                 envs <- base::Sys.getenv()
[17:42:22.623]                 names <- names(envs)
[17:42:22.623]                 common <- intersect(names, old_names)
[17:42:22.623]                 added <- setdiff(names, old_names)
[17:42:22.623]                 removed <- setdiff(old_names, names)
[17:42:22.623]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.623]                   envs[common]]
[17:42:22.623]                 NAMES <- toupper(changed)
[17:42:22.623]                 args <- list()
[17:42:22.623]                 for (kk in seq_along(NAMES)) {
[17:42:22.623]                   name <- changed[[kk]]
[17:42:22.623]                   NAME <- NAMES[[kk]]
[17:42:22.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.623]                     next
[17:42:22.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.623]                 }
[17:42:22.623]                 NAMES <- toupper(added)
[17:42:22.623]                 for (kk in seq_along(NAMES)) {
[17:42:22.623]                   name <- added[[kk]]
[17:42:22.623]                   NAME <- NAMES[[kk]]
[17:42:22.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.623]                     next
[17:42:22.623]                   args[[name]] <- ""
[17:42:22.623]                 }
[17:42:22.623]                 NAMES <- toupper(removed)
[17:42:22.623]                 for (kk in seq_along(NAMES)) {
[17:42:22.623]                   name <- removed[[kk]]
[17:42:22.623]                   NAME <- NAMES[[kk]]
[17:42:22.623]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.623]                     next
[17:42:22.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.623]                 }
[17:42:22.623]                 if (length(args) > 0) 
[17:42:22.623]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.623]             }
[17:42:22.623]             else {
[17:42:22.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.623]             }
[17:42:22.623]             {
[17:42:22.623]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.623]                   0L) {
[17:42:22.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.623]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.623]                   base::options(opts)
[17:42:22.623]                 }
[17:42:22.623]                 {
[17:42:22.623]                   {
[17:42:22.623]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.623]                     NULL
[17:42:22.623]                   }
[17:42:22.623]                   options(future.plan = NULL)
[17:42:22.623]                   if (is.na(NA_character_)) 
[17:42:22.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.623]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.623]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.623]                     envir = parent.frame()) 
[17:42:22.623]                   {
[17:42:22.623]                     if (is.function(workers)) 
[17:42:22.623]                       workers <- workers()
[17:42:22.623]                     workers <- structure(as.integer(workers), 
[17:42:22.623]                       class = class(workers))
[17:42:22.623]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.623]                       workers >= 1)
[17:42:22.623]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.623]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.623]                     }
[17:42:22.623]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.623]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.623]                       envir = envir)
[17:42:22.623]                     if (!future$lazy) 
[17:42:22.623]                       future <- run(future)
[17:42:22.623]                     invisible(future)
[17:42:22.623]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.623]                 }
[17:42:22.623]             }
[17:42:22.623]         }
[17:42:22.623]     })
[17:42:22.623]     if (TRUE) {
[17:42:22.623]         base::sink(type = "output", split = FALSE)
[17:42:22.623]         if (TRUE) {
[17:42:22.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.623]         }
[17:42:22.623]         else {
[17:42:22.623]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.623]         }
[17:42:22.623]         base::close(...future.stdout)
[17:42:22.623]         ...future.stdout <- NULL
[17:42:22.623]     }
[17:42:22.623]     ...future.result$conditions <- ...future.conditions
[17:42:22.623]     ...future.result$finished <- base::Sys.time()
[17:42:22.623]     ...future.result
[17:42:22.623] }
[17:42:22.626] MultisessionFuture started
[17:42:22.626] - Launch lazy future ... done
[17:42:22.626] run() for ‘MultisessionFuture’ ... done
[17:42:22.626] getGlobalsAndPackages() ...
[17:42:22.626] Searching for globals...
[17:42:22.626] 
[17:42:22.627] Searching for globals ... DONE
[17:42:22.627] - globals: [0] <none>
[17:42:22.627] getGlobalsAndPackages() ... DONE
[17:42:22.627] run() for ‘Future’ ...
[17:42:22.627] - state: ‘created’
[17:42:22.627] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.641] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.641]   - Field: ‘node’
[17:42:22.642]   - Field: ‘label’
[17:42:22.642]   - Field: ‘local’
[17:42:22.642]   - Field: ‘owner’
[17:42:22.642]   - Field: ‘envir’
[17:42:22.642]   - Field: ‘workers’
[17:42:22.642]   - Field: ‘packages’
[17:42:22.642]   - Field: ‘gc’
[17:42:22.642]   - Field: ‘conditions’
[17:42:22.642]   - Field: ‘persistent’
[17:42:22.642]   - Field: ‘expr’
[17:42:22.642]   - Field: ‘uuid’
[17:42:22.643]   - Field: ‘seed’
[17:42:22.643]   - Field: ‘version’
[17:42:22.643]   - Field: ‘result’
[17:42:22.643]   - Field: ‘asynchronous’
[17:42:22.643]   - Field: ‘calls’
[17:42:22.643]   - Field: ‘globals’
[17:42:22.643]   - Field: ‘stdout’
[17:42:22.643]   - Field: ‘earlySignal’
[17:42:22.643]   - Field: ‘lazy’
[17:42:22.643]   - Field: ‘state’
[17:42:22.644] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.644] - Launch lazy future ...
[17:42:22.644] Packages needed by the future expression (n = 0): <none>
[17:42:22.644] Packages needed by future strategies (n = 0): <none>
[17:42:22.644] {
[17:42:22.644]     {
[17:42:22.644]         {
[17:42:22.644]             ...future.startTime <- base::Sys.time()
[17:42:22.644]             {
[17:42:22.644]                 {
[17:42:22.644]                   {
[17:42:22.644]                     {
[17:42:22.644]                       base::local({
[17:42:22.644]                         has_future <- base::requireNamespace("future", 
[17:42:22.644]                           quietly = TRUE)
[17:42:22.644]                         if (has_future) {
[17:42:22.644]                           ns <- base::getNamespace("future")
[17:42:22.644]                           version <- ns[[".package"]][["version"]]
[17:42:22.644]                           if (is.null(version)) 
[17:42:22.644]                             version <- utils::packageVersion("future")
[17:42:22.644]                         }
[17:42:22.644]                         else {
[17:42:22.644]                           version <- NULL
[17:42:22.644]                         }
[17:42:22.644]                         if (!has_future || version < "1.8.0") {
[17:42:22.644]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.644]                             "", base::R.version$version.string), 
[17:42:22.644]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.644]                               "release", "version")], collapse = " "), 
[17:42:22.644]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.644]                             info)
[17:42:22.644]                           info <- base::paste(info, collapse = "; ")
[17:42:22.644]                           if (!has_future) {
[17:42:22.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.644]                               info)
[17:42:22.644]                           }
[17:42:22.644]                           else {
[17:42:22.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.644]                               info, version)
[17:42:22.644]                           }
[17:42:22.644]                           base::stop(msg)
[17:42:22.644]                         }
[17:42:22.644]                       })
[17:42:22.644]                     }
[17:42:22.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.644]                     base::options(mc.cores = 1L)
[17:42:22.644]                   }
[17:42:22.644]                   options(future.plan = NULL)
[17:42:22.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.644]                 }
[17:42:22.644]                 ...future.workdir <- getwd()
[17:42:22.644]             }
[17:42:22.644]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.644]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.644]         }
[17:42:22.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.644]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.644]             base::names(...future.oldOptions))
[17:42:22.644]     }
[17:42:22.644]     if (FALSE) {
[17:42:22.644]     }
[17:42:22.644]     else {
[17:42:22.644]         if (TRUE) {
[17:42:22.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.644]                 open = "w")
[17:42:22.644]         }
[17:42:22.644]         else {
[17:42:22.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.644]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.644]         }
[17:42:22.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.644]             base::sink(type = "output", split = FALSE)
[17:42:22.644]             base::close(...future.stdout)
[17:42:22.644]         }, add = TRUE)
[17:42:22.644]     }
[17:42:22.644]     ...future.frame <- base::sys.nframe()
[17:42:22.644]     ...future.conditions <- base::list()
[17:42:22.644]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.644]     if (FALSE) {
[17:42:22.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.644]     }
[17:42:22.644]     ...future.result <- base::tryCatch({
[17:42:22.644]         base::withCallingHandlers({
[17:42:22.644]             ...future.value <- base::withVisible(base::local({
[17:42:22.644]                 ...future.makeSendCondition <- local({
[17:42:22.644]                   sendCondition <- NULL
[17:42:22.644]                   function(frame = 1L) {
[17:42:22.644]                     if (is.function(sendCondition)) 
[17:42:22.644]                       return(sendCondition)
[17:42:22.644]                     ns <- getNamespace("parallel")
[17:42:22.644]                     if (exists("sendData", mode = "function", 
[17:42:22.644]                       envir = ns)) {
[17:42:22.644]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.644]                         envir = ns)
[17:42:22.644]                       envir <- sys.frame(frame)
[17:42:22.644]                       master <- NULL
[17:42:22.644]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.644]                         !identical(envir, emptyenv())) {
[17:42:22.644]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.644]                           inherits = FALSE)) {
[17:42:22.644]                           master <- get("master", mode = "list", 
[17:42:22.644]                             envir = envir, inherits = FALSE)
[17:42:22.644]                           if (inherits(master, c("SOCKnode", 
[17:42:22.644]                             "SOCK0node"))) {
[17:42:22.644]                             sendCondition <<- function(cond) {
[17:42:22.644]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.644]                                 success = TRUE)
[17:42:22.644]                               parallel_sendData(master, data)
[17:42:22.644]                             }
[17:42:22.644]                             return(sendCondition)
[17:42:22.644]                           }
[17:42:22.644]                         }
[17:42:22.644]                         frame <- frame + 1L
[17:42:22.644]                         envir <- sys.frame(frame)
[17:42:22.644]                       }
[17:42:22.644]                     }
[17:42:22.644]                     sendCondition <<- function(cond) NULL
[17:42:22.644]                   }
[17:42:22.644]                 })
[17:42:22.644]                 withCallingHandlers({
[17:42:22.644]                   NULL
[17:42:22.644]                 }, immediateCondition = function(cond) {
[17:42:22.644]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.644]                   sendCondition(cond)
[17:42:22.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.644]                   {
[17:42:22.644]                     inherits <- base::inherits
[17:42:22.644]                     invokeRestart <- base::invokeRestart
[17:42:22.644]                     is.null <- base::is.null
[17:42:22.644]                     muffled <- FALSE
[17:42:22.644]                     if (inherits(cond, "message")) {
[17:42:22.644]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.644]                       if (muffled) 
[17:42:22.644]                         invokeRestart("muffleMessage")
[17:42:22.644]                     }
[17:42:22.644]                     else if (inherits(cond, "warning")) {
[17:42:22.644]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.644]                       if (muffled) 
[17:42:22.644]                         invokeRestart("muffleWarning")
[17:42:22.644]                     }
[17:42:22.644]                     else if (inherits(cond, "condition")) {
[17:42:22.644]                       if (!is.null(pattern)) {
[17:42:22.644]                         computeRestarts <- base::computeRestarts
[17:42:22.644]                         grepl <- base::grepl
[17:42:22.644]                         restarts <- computeRestarts(cond)
[17:42:22.644]                         for (restart in restarts) {
[17:42:22.644]                           name <- restart$name
[17:42:22.644]                           if (is.null(name)) 
[17:42:22.644]                             next
[17:42:22.644]                           if (!grepl(pattern, name)) 
[17:42:22.644]                             next
[17:42:22.644]                           invokeRestart(restart)
[17:42:22.644]                           muffled <- TRUE
[17:42:22.644]                           break
[17:42:22.644]                         }
[17:42:22.644]                       }
[17:42:22.644]                     }
[17:42:22.644]                     invisible(muffled)
[17:42:22.644]                   }
[17:42:22.644]                   muffleCondition(cond)
[17:42:22.644]                 })
[17:42:22.644]             }))
[17:42:22.644]             future::FutureResult(value = ...future.value$value, 
[17:42:22.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.644]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.644]                     ...future.globalenv.names))
[17:42:22.644]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.644]         }, condition = base::local({
[17:42:22.644]             c <- base::c
[17:42:22.644]             inherits <- base::inherits
[17:42:22.644]             invokeRestart <- base::invokeRestart
[17:42:22.644]             length <- base::length
[17:42:22.644]             list <- base::list
[17:42:22.644]             seq.int <- base::seq.int
[17:42:22.644]             signalCondition <- base::signalCondition
[17:42:22.644]             sys.calls <- base::sys.calls
[17:42:22.644]             `[[` <- base::`[[`
[17:42:22.644]             `+` <- base::`+`
[17:42:22.644]             `<<-` <- base::`<<-`
[17:42:22.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.644]                   3L)]
[17:42:22.644]             }
[17:42:22.644]             function(cond) {
[17:42:22.644]                 is_error <- inherits(cond, "error")
[17:42:22.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.644]                   NULL)
[17:42:22.644]                 if (is_error) {
[17:42:22.644]                   sessionInformation <- function() {
[17:42:22.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.644]                       search = base::search(), system = base::Sys.info())
[17:42:22.644]                   }
[17:42:22.644]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.644]                     cond$call), session = sessionInformation(), 
[17:42:22.644]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.644]                   signalCondition(cond)
[17:42:22.644]                 }
[17:42:22.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.644]                 "immediateCondition"))) {
[17:42:22.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.644]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.644]                   if (TRUE && !signal) {
[17:42:22.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.644]                     {
[17:42:22.644]                       inherits <- base::inherits
[17:42:22.644]                       invokeRestart <- base::invokeRestart
[17:42:22.644]                       is.null <- base::is.null
[17:42:22.644]                       muffled <- FALSE
[17:42:22.644]                       if (inherits(cond, "message")) {
[17:42:22.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.644]                         if (muffled) 
[17:42:22.644]                           invokeRestart("muffleMessage")
[17:42:22.644]                       }
[17:42:22.644]                       else if (inherits(cond, "warning")) {
[17:42:22.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.644]                         if (muffled) 
[17:42:22.644]                           invokeRestart("muffleWarning")
[17:42:22.644]                       }
[17:42:22.644]                       else if (inherits(cond, "condition")) {
[17:42:22.644]                         if (!is.null(pattern)) {
[17:42:22.644]                           computeRestarts <- base::computeRestarts
[17:42:22.644]                           grepl <- base::grepl
[17:42:22.644]                           restarts <- computeRestarts(cond)
[17:42:22.644]                           for (restart in restarts) {
[17:42:22.644]                             name <- restart$name
[17:42:22.644]                             if (is.null(name)) 
[17:42:22.644]                               next
[17:42:22.644]                             if (!grepl(pattern, name)) 
[17:42:22.644]                               next
[17:42:22.644]                             invokeRestart(restart)
[17:42:22.644]                             muffled <- TRUE
[17:42:22.644]                             break
[17:42:22.644]                           }
[17:42:22.644]                         }
[17:42:22.644]                       }
[17:42:22.644]                       invisible(muffled)
[17:42:22.644]                     }
[17:42:22.644]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.644]                   }
[17:42:22.644]                 }
[17:42:22.644]                 else {
[17:42:22.644]                   if (TRUE) {
[17:42:22.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.644]                     {
[17:42:22.644]                       inherits <- base::inherits
[17:42:22.644]                       invokeRestart <- base::invokeRestart
[17:42:22.644]                       is.null <- base::is.null
[17:42:22.644]                       muffled <- FALSE
[17:42:22.644]                       if (inherits(cond, "message")) {
[17:42:22.644]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.644]                         if (muffled) 
[17:42:22.644]                           invokeRestart("muffleMessage")
[17:42:22.644]                       }
[17:42:22.644]                       else if (inherits(cond, "warning")) {
[17:42:22.644]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.644]                         if (muffled) 
[17:42:22.644]                           invokeRestart("muffleWarning")
[17:42:22.644]                       }
[17:42:22.644]                       else if (inherits(cond, "condition")) {
[17:42:22.644]                         if (!is.null(pattern)) {
[17:42:22.644]                           computeRestarts <- base::computeRestarts
[17:42:22.644]                           grepl <- base::grepl
[17:42:22.644]                           restarts <- computeRestarts(cond)
[17:42:22.644]                           for (restart in restarts) {
[17:42:22.644]                             name <- restart$name
[17:42:22.644]                             if (is.null(name)) 
[17:42:22.644]                               next
[17:42:22.644]                             if (!grepl(pattern, name)) 
[17:42:22.644]                               next
[17:42:22.644]                             invokeRestart(restart)
[17:42:22.644]                             muffled <- TRUE
[17:42:22.644]                             break
[17:42:22.644]                           }
[17:42:22.644]                         }
[17:42:22.644]                       }
[17:42:22.644]                       invisible(muffled)
[17:42:22.644]                     }
[17:42:22.644]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.644]                   }
[17:42:22.644]                 }
[17:42:22.644]             }
[17:42:22.644]         }))
[17:42:22.644]     }, error = function(ex) {
[17:42:22.644]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.644]                 ...future.rng), started = ...future.startTime, 
[17:42:22.644]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.644]             version = "1.8"), class = "FutureResult")
[17:42:22.644]     }, finally = {
[17:42:22.644]         if (!identical(...future.workdir, getwd())) 
[17:42:22.644]             setwd(...future.workdir)
[17:42:22.644]         {
[17:42:22.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.644]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.644]             }
[17:42:22.644]             base::options(...future.oldOptions)
[17:42:22.644]             if (.Platform$OS.type == "windows") {
[17:42:22.644]                 old_names <- names(...future.oldEnvVars)
[17:42:22.644]                 envs <- base::Sys.getenv()
[17:42:22.644]                 names <- names(envs)
[17:42:22.644]                 common <- intersect(names, old_names)
[17:42:22.644]                 added <- setdiff(names, old_names)
[17:42:22.644]                 removed <- setdiff(old_names, names)
[17:42:22.644]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.644]                   envs[common]]
[17:42:22.644]                 NAMES <- toupper(changed)
[17:42:22.644]                 args <- list()
[17:42:22.644]                 for (kk in seq_along(NAMES)) {
[17:42:22.644]                   name <- changed[[kk]]
[17:42:22.644]                   NAME <- NAMES[[kk]]
[17:42:22.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.644]                     next
[17:42:22.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.644]                 }
[17:42:22.644]                 NAMES <- toupper(added)
[17:42:22.644]                 for (kk in seq_along(NAMES)) {
[17:42:22.644]                   name <- added[[kk]]
[17:42:22.644]                   NAME <- NAMES[[kk]]
[17:42:22.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.644]                     next
[17:42:22.644]                   args[[name]] <- ""
[17:42:22.644]                 }
[17:42:22.644]                 NAMES <- toupper(removed)
[17:42:22.644]                 for (kk in seq_along(NAMES)) {
[17:42:22.644]                   name <- removed[[kk]]
[17:42:22.644]                   NAME <- NAMES[[kk]]
[17:42:22.644]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.644]                     next
[17:42:22.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.644]                 }
[17:42:22.644]                 if (length(args) > 0) 
[17:42:22.644]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.644]             }
[17:42:22.644]             else {
[17:42:22.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.644]             }
[17:42:22.644]             {
[17:42:22.644]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.644]                   0L) {
[17:42:22.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.644]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.644]                   base::options(opts)
[17:42:22.644]                 }
[17:42:22.644]                 {
[17:42:22.644]                   {
[17:42:22.644]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.644]                     NULL
[17:42:22.644]                   }
[17:42:22.644]                   options(future.plan = NULL)
[17:42:22.644]                   if (is.na(NA_character_)) 
[17:42:22.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.644]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.644]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.644]                     envir = parent.frame()) 
[17:42:22.644]                   {
[17:42:22.644]                     if (is.function(workers)) 
[17:42:22.644]                       workers <- workers()
[17:42:22.644]                     workers <- structure(as.integer(workers), 
[17:42:22.644]                       class = class(workers))
[17:42:22.644]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.644]                       workers >= 1)
[17:42:22.644]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.644]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.644]                     }
[17:42:22.644]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.644]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.644]                       envir = envir)
[17:42:22.644]                     if (!future$lazy) 
[17:42:22.644]                       future <- run(future)
[17:42:22.644]                     invisible(future)
[17:42:22.644]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.644]                 }
[17:42:22.644]             }
[17:42:22.644]         }
[17:42:22.644]     })
[17:42:22.644]     if (TRUE) {
[17:42:22.644]         base::sink(type = "output", split = FALSE)
[17:42:22.644]         if (TRUE) {
[17:42:22.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.644]         }
[17:42:22.644]         else {
[17:42:22.644]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.644]         }
[17:42:22.644]         base::close(...future.stdout)
[17:42:22.644]         ...future.stdout <- NULL
[17:42:22.644]     }
[17:42:22.644]     ...future.result$conditions <- ...future.conditions
[17:42:22.644]     ...future.result$finished <- base::Sys.time()
[17:42:22.644]     ...future.result
[17:42:22.644] }
[17:42:22.648] MultisessionFuture started
[17:42:22.648] - Launch lazy future ... done
[17:42:22.648] run() for ‘MultisessionFuture’ ... done
[17:42:22.648] getGlobalsAndPackages() ...
[17:42:22.648] Searching for globals...
[17:42:22.649] - globals found: [1] ‘{’
[17:42:22.649] Searching for globals ... DONE
[17:42:22.649] Resolving globals: FALSE
[17:42:22.649] 
[17:42:22.650] 
[17:42:22.650] getGlobalsAndPackages() ... DONE
[17:42:22.650] run() for ‘Future’ ...
[17:42:22.650] - state: ‘created’
[17:42:22.650] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.665] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.665]   - Field: ‘node’
[17:42:22.665]   - Field: ‘label’
[17:42:22.665]   - Field: ‘local’
[17:42:22.665]   - Field: ‘owner’
[17:42:22.665]   - Field: ‘envir’
[17:42:22.666]   - Field: ‘workers’
[17:42:22.666]   - Field: ‘packages’
[17:42:22.666]   - Field: ‘gc’
[17:42:22.666]   - Field: ‘conditions’
[17:42:22.666]   - Field: ‘persistent’
[17:42:22.666]   - Field: ‘expr’
[17:42:22.666]   - Field: ‘uuid’
[17:42:22.666]   - Field: ‘seed’
[17:42:22.666]   - Field: ‘version’
[17:42:22.666]   - Field: ‘result’
[17:42:22.666]   - Field: ‘asynchronous’
[17:42:22.667]   - Field: ‘calls’
[17:42:22.667]   - Field: ‘globals’
[17:42:22.667]   - Field: ‘stdout’
[17:42:22.667]   - Field: ‘earlySignal’
[17:42:22.667]   - Field: ‘lazy’
[17:42:22.667]   - Field: ‘state’
[17:42:22.667] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.667] - Launch lazy future ...
[17:42:22.668] Packages needed by the future expression (n = 0): <none>
[17:42:22.668] Packages needed by future strategies (n = 0): <none>
[17:42:22.668] {
[17:42:22.668]     {
[17:42:22.668]         {
[17:42:22.668]             ...future.startTime <- base::Sys.time()
[17:42:22.668]             {
[17:42:22.668]                 {
[17:42:22.668]                   {
[17:42:22.668]                     {
[17:42:22.668]                       base::local({
[17:42:22.668]                         has_future <- base::requireNamespace("future", 
[17:42:22.668]                           quietly = TRUE)
[17:42:22.668]                         if (has_future) {
[17:42:22.668]                           ns <- base::getNamespace("future")
[17:42:22.668]                           version <- ns[[".package"]][["version"]]
[17:42:22.668]                           if (is.null(version)) 
[17:42:22.668]                             version <- utils::packageVersion("future")
[17:42:22.668]                         }
[17:42:22.668]                         else {
[17:42:22.668]                           version <- NULL
[17:42:22.668]                         }
[17:42:22.668]                         if (!has_future || version < "1.8.0") {
[17:42:22.668]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.668]                             "", base::R.version$version.string), 
[17:42:22.668]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.668]                               "release", "version")], collapse = " "), 
[17:42:22.668]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.668]                             info)
[17:42:22.668]                           info <- base::paste(info, collapse = "; ")
[17:42:22.668]                           if (!has_future) {
[17:42:22.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.668]                               info)
[17:42:22.668]                           }
[17:42:22.668]                           else {
[17:42:22.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.668]                               info, version)
[17:42:22.668]                           }
[17:42:22.668]                           base::stop(msg)
[17:42:22.668]                         }
[17:42:22.668]                       })
[17:42:22.668]                     }
[17:42:22.668]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.668]                     base::options(mc.cores = 1L)
[17:42:22.668]                   }
[17:42:22.668]                   options(future.plan = NULL)
[17:42:22.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.668]                 }
[17:42:22.668]                 ...future.workdir <- getwd()
[17:42:22.668]             }
[17:42:22.668]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.668]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.668]         }
[17:42:22.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.668]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.668]             base::names(...future.oldOptions))
[17:42:22.668]     }
[17:42:22.668]     if (FALSE) {
[17:42:22.668]     }
[17:42:22.668]     else {
[17:42:22.668]         if (TRUE) {
[17:42:22.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.668]                 open = "w")
[17:42:22.668]         }
[17:42:22.668]         else {
[17:42:22.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.668]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.668]         }
[17:42:22.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.668]             base::sink(type = "output", split = FALSE)
[17:42:22.668]             base::close(...future.stdout)
[17:42:22.668]         }, add = TRUE)
[17:42:22.668]     }
[17:42:22.668]     ...future.frame <- base::sys.nframe()
[17:42:22.668]     ...future.conditions <- base::list()
[17:42:22.668]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.668]     if (FALSE) {
[17:42:22.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.668]     }
[17:42:22.668]     ...future.result <- base::tryCatch({
[17:42:22.668]         base::withCallingHandlers({
[17:42:22.668]             ...future.value <- base::withVisible(base::local({
[17:42:22.668]                 ...future.makeSendCondition <- local({
[17:42:22.668]                   sendCondition <- NULL
[17:42:22.668]                   function(frame = 1L) {
[17:42:22.668]                     if (is.function(sendCondition)) 
[17:42:22.668]                       return(sendCondition)
[17:42:22.668]                     ns <- getNamespace("parallel")
[17:42:22.668]                     if (exists("sendData", mode = "function", 
[17:42:22.668]                       envir = ns)) {
[17:42:22.668]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.668]                         envir = ns)
[17:42:22.668]                       envir <- sys.frame(frame)
[17:42:22.668]                       master <- NULL
[17:42:22.668]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.668]                         !identical(envir, emptyenv())) {
[17:42:22.668]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.668]                           inherits = FALSE)) {
[17:42:22.668]                           master <- get("master", mode = "list", 
[17:42:22.668]                             envir = envir, inherits = FALSE)
[17:42:22.668]                           if (inherits(master, c("SOCKnode", 
[17:42:22.668]                             "SOCK0node"))) {
[17:42:22.668]                             sendCondition <<- function(cond) {
[17:42:22.668]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.668]                                 success = TRUE)
[17:42:22.668]                               parallel_sendData(master, data)
[17:42:22.668]                             }
[17:42:22.668]                             return(sendCondition)
[17:42:22.668]                           }
[17:42:22.668]                         }
[17:42:22.668]                         frame <- frame + 1L
[17:42:22.668]                         envir <- sys.frame(frame)
[17:42:22.668]                       }
[17:42:22.668]                     }
[17:42:22.668]                     sendCondition <<- function(cond) NULL
[17:42:22.668]                   }
[17:42:22.668]                 })
[17:42:22.668]                 withCallingHandlers({
[17:42:22.668]                   {
[17:42:22.668]                     4
[17:42:22.668]                   }
[17:42:22.668]                 }, immediateCondition = function(cond) {
[17:42:22.668]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.668]                   sendCondition(cond)
[17:42:22.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.668]                   {
[17:42:22.668]                     inherits <- base::inherits
[17:42:22.668]                     invokeRestart <- base::invokeRestart
[17:42:22.668]                     is.null <- base::is.null
[17:42:22.668]                     muffled <- FALSE
[17:42:22.668]                     if (inherits(cond, "message")) {
[17:42:22.668]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.668]                       if (muffled) 
[17:42:22.668]                         invokeRestart("muffleMessage")
[17:42:22.668]                     }
[17:42:22.668]                     else if (inherits(cond, "warning")) {
[17:42:22.668]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.668]                       if (muffled) 
[17:42:22.668]                         invokeRestart("muffleWarning")
[17:42:22.668]                     }
[17:42:22.668]                     else if (inherits(cond, "condition")) {
[17:42:22.668]                       if (!is.null(pattern)) {
[17:42:22.668]                         computeRestarts <- base::computeRestarts
[17:42:22.668]                         grepl <- base::grepl
[17:42:22.668]                         restarts <- computeRestarts(cond)
[17:42:22.668]                         for (restart in restarts) {
[17:42:22.668]                           name <- restart$name
[17:42:22.668]                           if (is.null(name)) 
[17:42:22.668]                             next
[17:42:22.668]                           if (!grepl(pattern, name)) 
[17:42:22.668]                             next
[17:42:22.668]                           invokeRestart(restart)
[17:42:22.668]                           muffled <- TRUE
[17:42:22.668]                           break
[17:42:22.668]                         }
[17:42:22.668]                       }
[17:42:22.668]                     }
[17:42:22.668]                     invisible(muffled)
[17:42:22.668]                   }
[17:42:22.668]                   muffleCondition(cond)
[17:42:22.668]                 })
[17:42:22.668]             }))
[17:42:22.668]             future::FutureResult(value = ...future.value$value, 
[17:42:22.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.668]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.668]                     ...future.globalenv.names))
[17:42:22.668]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.668]         }, condition = base::local({
[17:42:22.668]             c <- base::c
[17:42:22.668]             inherits <- base::inherits
[17:42:22.668]             invokeRestart <- base::invokeRestart
[17:42:22.668]             length <- base::length
[17:42:22.668]             list <- base::list
[17:42:22.668]             seq.int <- base::seq.int
[17:42:22.668]             signalCondition <- base::signalCondition
[17:42:22.668]             sys.calls <- base::sys.calls
[17:42:22.668]             `[[` <- base::`[[`
[17:42:22.668]             `+` <- base::`+`
[17:42:22.668]             `<<-` <- base::`<<-`
[17:42:22.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.668]                   3L)]
[17:42:22.668]             }
[17:42:22.668]             function(cond) {
[17:42:22.668]                 is_error <- inherits(cond, "error")
[17:42:22.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.668]                   NULL)
[17:42:22.668]                 if (is_error) {
[17:42:22.668]                   sessionInformation <- function() {
[17:42:22.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.668]                       search = base::search(), system = base::Sys.info())
[17:42:22.668]                   }
[17:42:22.668]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.668]                     cond$call), session = sessionInformation(), 
[17:42:22.668]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.668]                   signalCondition(cond)
[17:42:22.668]                 }
[17:42:22.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.668]                 "immediateCondition"))) {
[17:42:22.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.668]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.668]                   if (TRUE && !signal) {
[17:42:22.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.668]                     {
[17:42:22.668]                       inherits <- base::inherits
[17:42:22.668]                       invokeRestart <- base::invokeRestart
[17:42:22.668]                       is.null <- base::is.null
[17:42:22.668]                       muffled <- FALSE
[17:42:22.668]                       if (inherits(cond, "message")) {
[17:42:22.668]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.668]                         if (muffled) 
[17:42:22.668]                           invokeRestart("muffleMessage")
[17:42:22.668]                       }
[17:42:22.668]                       else if (inherits(cond, "warning")) {
[17:42:22.668]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.668]                         if (muffled) 
[17:42:22.668]                           invokeRestart("muffleWarning")
[17:42:22.668]                       }
[17:42:22.668]                       else if (inherits(cond, "condition")) {
[17:42:22.668]                         if (!is.null(pattern)) {
[17:42:22.668]                           computeRestarts <- base::computeRestarts
[17:42:22.668]                           grepl <- base::grepl
[17:42:22.668]                           restarts <- computeRestarts(cond)
[17:42:22.668]                           for (restart in restarts) {
[17:42:22.668]                             name <- restart$name
[17:42:22.668]                             if (is.null(name)) 
[17:42:22.668]                               next
[17:42:22.668]                             if (!grepl(pattern, name)) 
[17:42:22.668]                               next
[17:42:22.668]                             invokeRestart(restart)
[17:42:22.668]                             muffled <- TRUE
[17:42:22.668]                             break
[17:42:22.668]                           }
[17:42:22.668]                         }
[17:42:22.668]                       }
[17:42:22.668]                       invisible(muffled)
[17:42:22.668]                     }
[17:42:22.668]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.668]                   }
[17:42:22.668]                 }
[17:42:22.668]                 else {
[17:42:22.668]                   if (TRUE) {
[17:42:22.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.668]                     {
[17:42:22.668]                       inherits <- base::inherits
[17:42:22.668]                       invokeRestart <- base::invokeRestart
[17:42:22.668]                       is.null <- base::is.null
[17:42:22.668]                       muffled <- FALSE
[17:42:22.668]                       if (inherits(cond, "message")) {
[17:42:22.668]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.668]                         if (muffled) 
[17:42:22.668]                           invokeRestart("muffleMessage")
[17:42:22.668]                       }
[17:42:22.668]                       else if (inherits(cond, "warning")) {
[17:42:22.668]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.668]                         if (muffled) 
[17:42:22.668]                           invokeRestart("muffleWarning")
[17:42:22.668]                       }
[17:42:22.668]                       else if (inherits(cond, "condition")) {
[17:42:22.668]                         if (!is.null(pattern)) {
[17:42:22.668]                           computeRestarts <- base::computeRestarts
[17:42:22.668]                           grepl <- base::grepl
[17:42:22.668]                           restarts <- computeRestarts(cond)
[17:42:22.668]                           for (restart in restarts) {
[17:42:22.668]                             name <- restart$name
[17:42:22.668]                             if (is.null(name)) 
[17:42:22.668]                               next
[17:42:22.668]                             if (!grepl(pattern, name)) 
[17:42:22.668]                               next
[17:42:22.668]                             invokeRestart(restart)
[17:42:22.668]                             muffled <- TRUE
[17:42:22.668]                             break
[17:42:22.668]                           }
[17:42:22.668]                         }
[17:42:22.668]                       }
[17:42:22.668]                       invisible(muffled)
[17:42:22.668]                     }
[17:42:22.668]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.668]                   }
[17:42:22.668]                 }
[17:42:22.668]             }
[17:42:22.668]         }))
[17:42:22.668]     }, error = function(ex) {
[17:42:22.668]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.668]                 ...future.rng), started = ...future.startTime, 
[17:42:22.668]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.668]             version = "1.8"), class = "FutureResult")
[17:42:22.668]     }, finally = {
[17:42:22.668]         if (!identical(...future.workdir, getwd())) 
[17:42:22.668]             setwd(...future.workdir)
[17:42:22.668]         {
[17:42:22.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.668]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.668]             }
[17:42:22.668]             base::options(...future.oldOptions)
[17:42:22.668]             if (.Platform$OS.type == "windows") {
[17:42:22.668]                 old_names <- names(...future.oldEnvVars)
[17:42:22.668]                 envs <- base::Sys.getenv()
[17:42:22.668]                 names <- names(envs)
[17:42:22.668]                 common <- intersect(names, old_names)
[17:42:22.668]                 added <- setdiff(names, old_names)
[17:42:22.668]                 removed <- setdiff(old_names, names)
[17:42:22.668]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.668]                   envs[common]]
[17:42:22.668]                 NAMES <- toupper(changed)
[17:42:22.668]                 args <- list()
[17:42:22.668]                 for (kk in seq_along(NAMES)) {
[17:42:22.668]                   name <- changed[[kk]]
[17:42:22.668]                   NAME <- NAMES[[kk]]
[17:42:22.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.668]                     next
[17:42:22.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.668]                 }
[17:42:22.668]                 NAMES <- toupper(added)
[17:42:22.668]                 for (kk in seq_along(NAMES)) {
[17:42:22.668]                   name <- added[[kk]]
[17:42:22.668]                   NAME <- NAMES[[kk]]
[17:42:22.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.668]                     next
[17:42:22.668]                   args[[name]] <- ""
[17:42:22.668]                 }
[17:42:22.668]                 NAMES <- toupper(removed)
[17:42:22.668]                 for (kk in seq_along(NAMES)) {
[17:42:22.668]                   name <- removed[[kk]]
[17:42:22.668]                   NAME <- NAMES[[kk]]
[17:42:22.668]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.668]                     next
[17:42:22.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.668]                 }
[17:42:22.668]                 if (length(args) > 0) 
[17:42:22.668]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.668]             }
[17:42:22.668]             else {
[17:42:22.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.668]             }
[17:42:22.668]             {
[17:42:22.668]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.668]                   0L) {
[17:42:22.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.668]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.668]                   base::options(opts)
[17:42:22.668]                 }
[17:42:22.668]                 {
[17:42:22.668]                   {
[17:42:22.668]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.668]                     NULL
[17:42:22.668]                   }
[17:42:22.668]                   options(future.plan = NULL)
[17:42:22.668]                   if (is.na(NA_character_)) 
[17:42:22.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.668]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.668]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.668]                     envir = parent.frame()) 
[17:42:22.668]                   {
[17:42:22.668]                     if (is.function(workers)) 
[17:42:22.668]                       workers <- workers()
[17:42:22.668]                     workers <- structure(as.integer(workers), 
[17:42:22.668]                       class = class(workers))
[17:42:22.668]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.668]                       workers >= 1)
[17:42:22.668]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.668]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.668]                     }
[17:42:22.668]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.668]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.668]                       envir = envir)
[17:42:22.668]                     if (!future$lazy) 
[17:42:22.668]                       future <- run(future)
[17:42:22.668]                     invisible(future)
[17:42:22.668]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.668]                 }
[17:42:22.668]             }
[17:42:22.668]         }
[17:42:22.668]     })
[17:42:22.668]     if (TRUE) {
[17:42:22.668]         base::sink(type = "output", split = FALSE)
[17:42:22.668]         if (TRUE) {
[17:42:22.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.668]         }
[17:42:22.668]         else {
[17:42:22.668]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.668]         }
[17:42:22.668]         base::close(...future.stdout)
[17:42:22.668]         ...future.stdout <- NULL
[17:42:22.668]     }
[17:42:22.668]     ...future.result$conditions <- ...future.conditions
[17:42:22.668]     ...future.result$finished <- base::Sys.time()
[17:42:22.668]     ...future.result
[17:42:22.668] }
[17:42:22.671] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:22.681] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.682] - Validating connection of MultisessionFuture
[17:42:22.682] - received message: FutureResult
[17:42:22.682] - Received FutureResult
[17:42:22.682] - Erased future from FutureRegistry
[17:42:22.682] result() for ClusterFuture ...
[17:42:22.682] - result already collected: FutureResult
[17:42:22.682] result() for ClusterFuture ... done
[17:42:22.682] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.682] result() for ClusterFuture ...
[17:42:22.683] - result already collected: FutureResult
[17:42:22.683] result() for ClusterFuture ... done
[17:42:22.683] result() for ClusterFuture ...
[17:42:22.683] - result already collected: FutureResult
[17:42:22.683] result() for ClusterFuture ... done
[17:42:22.684] MultisessionFuture started
[17:42:22.684] - Launch lazy future ... done
[17:42:22.684] run() for ‘MultisessionFuture’ ... done
<environment: 0x55bef90675e0> 
<environment: 0x55bef9e540d0> 
[17:42:22.695] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.696] - Validating connection of MultisessionFuture
[17:42:22.696] - received message: FutureResult
[17:42:22.696] - Received FutureResult
[17:42:22.696] - Erased future from FutureRegistry
[17:42:22.696] result() for ClusterFuture ...
[17:42:22.696] - result already collected: FutureResult
[17:42:22.696] result() for ClusterFuture ... done
[17:42:22.696] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:22.708] resolve() on environment ...
[17:42:22.709]  recursive: 0
[17:42:22.709]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:22.709] signalConditionsASAP(numeric, pos=1) ...
[17:42:22.709] - nx: 4
[17:42:22.709] - relay: TRUE
[17:42:22.710] - stdout: TRUE
[17:42:22.710] - signal: TRUE
[17:42:22.710] - resignal: FALSE
[17:42:22.710] - force: TRUE
[17:42:22.710] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.710] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.710]  - until=2
[17:42:22.710]  - relaying element #2
[17:42:22.710] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.710] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.710] signalConditionsASAP(NULL, pos=1) ... done
[17:42:22.711]  length: 3 (resolved future 1)
[17:42:22.711] Future #2
[17:42:22.711] result() for ClusterFuture ...
[17:42:22.711] - result already collected: FutureResult
[17:42:22.711] result() for ClusterFuture ... done
[17:42:22.711] result() for ClusterFuture ...
[17:42:22.711] - result already collected: FutureResult
[17:42:22.711] result() for ClusterFuture ... done
[17:42:22.711] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:22.712] - nx: 4
[17:42:22.714] - relay: TRUE
[17:42:22.714] - stdout: TRUE
[17:42:22.714] - signal: TRUE
[17:42:22.714] - resignal: FALSE
[17:42:22.714] - force: TRUE
[17:42:22.714] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.715] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.715]  - until=2
[17:42:22.715]  - relaying element #2
[17:42:22.715] result() for ClusterFuture ...
[17:42:22.715] - result already collected: FutureResult
[17:42:22.715] result() for ClusterFuture ... done
[17:42:22.715] result() for ClusterFuture ...
[17:42:22.715] - result already collected: FutureResult
[17:42:22.715] result() for ClusterFuture ... done
[17:42:22.715] result() for ClusterFuture ...
[17:42:22.716] - result already collected: FutureResult
[17:42:22.716] result() for ClusterFuture ... done
[17:42:22.716] result() for ClusterFuture ...
[17:42:22.716] - result already collected: FutureResult
[17:42:22.716] result() for ClusterFuture ... done
[17:42:22.716] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:22.716] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:22.716] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:22.716]  length: 2 (resolved future 2)
[17:42:22.716] Future #3
[17:42:22.716] result() for ClusterFuture ...
[17:42:22.717] - result already collected: FutureResult
[17:42:22.717] result() for ClusterFuture ... done
[17:42:22.717] result() for ClusterFuture ...
[17:42:22.717] - result already collected: FutureResult
[17:42:22.717] result() for ClusterFuture ... done
[17:42:22.717] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:22.717] - nx: 4
[17:42:22.717] - relay: TRUE
[17:42:22.717] - stdout: TRUE
[17:42:22.718] - signal: TRUE
[17:42:22.718] - resignal: FALSE
[17:42:22.718] - force: TRUE
[17:42:22.718] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:22.718] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:22.718]  - until=3
[17:42:22.718]  - relaying element #3
[17:42:22.718] result() for ClusterFuture ...
[17:42:22.718] - result already collected: FutureResult
[17:42:22.718] result() for ClusterFuture ... done
[17:42:22.719] result() for ClusterFuture ...
[17:42:22.719] - result already collected: FutureResult
[17:42:22.719] result() for ClusterFuture ... done
[17:42:22.719] result() for ClusterFuture ...
[17:42:22.719] - result already collected: FutureResult
[17:42:22.719] result() for ClusterFuture ... done
[17:42:22.719] result() for ClusterFuture ...
[17:42:22.719] - result already collected: FutureResult
[17:42:22.719] result() for ClusterFuture ... done
[17:42:22.719] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:22.719] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:22.720] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:22.720]  length: 1 (resolved future 3)
[17:42:22.741] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.741] - Validating connection of MultisessionFuture
[17:42:22.741] - received message: FutureResult
[17:42:22.741] - Received FutureResult
[17:42:22.742] - Erased future from FutureRegistry
[17:42:22.742] result() for ClusterFuture ...
[17:42:22.742] - result already collected: FutureResult
[17:42:22.742] result() for ClusterFuture ... done
[17:42:22.742] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.742] Future #4
[17:42:22.742] result() for ClusterFuture ...
[17:42:22.742] - result already collected: FutureResult
[17:42:22.742] result() for ClusterFuture ... done
[17:42:22.742] result() for ClusterFuture ...
[17:42:22.742] - result already collected: FutureResult
[17:42:22.743] result() for ClusterFuture ... done
[17:42:22.743] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:22.743] - nx: 4
[17:42:22.743] - relay: TRUE
[17:42:22.743] - stdout: TRUE
[17:42:22.743] - signal: TRUE
[17:42:22.743] - resignal: FALSE
[17:42:22.743] - force: TRUE
[17:42:22.743] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:22.743] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:22.743]  - until=4
[17:42:22.744]  - relaying element #4
[17:42:22.744] result() for ClusterFuture ...
[17:42:22.744] - result already collected: FutureResult
[17:42:22.744] result() for ClusterFuture ... done
[17:42:22.744] result() for ClusterFuture ...
[17:42:22.744] - result already collected: FutureResult
[17:42:22.744] result() for ClusterFuture ... done
[17:42:22.744] result() for ClusterFuture ...
[17:42:22.744] - result already collected: FutureResult
[17:42:22.744] result() for ClusterFuture ... done
[17:42:22.744] result() for ClusterFuture ...
[17:42:22.745] - result already collected: FutureResult
[17:42:22.745] result() for ClusterFuture ... done
[17:42:22.745] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.745] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:22.745] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:22.745]  length: 0 (resolved future 4)
[17:42:22.745] Relaying remaining futures
[17:42:22.745] signalConditionsASAP(NULL, pos=0) ...
[17:42:22.745] - nx: 4
[17:42:22.745] - relay: TRUE
[17:42:22.745] - stdout: TRUE
[17:42:22.746] - signal: TRUE
[17:42:22.746] - resignal: FALSE
[17:42:22.746] - force: TRUE
[17:42:22.746] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.746] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:22.746] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.746] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:22.746] signalConditionsASAP(NULL, pos=0) ... done
[17:42:22.746] resolve() on environment ... DONE
[17:42:22.746] result() for ClusterFuture ...
[17:42:22.746] - result already collected: FutureResult
[17:42:22.747] result() for ClusterFuture ... done
[17:42:22.747] result() for ClusterFuture ...
[17:42:22.747] - result already collected: FutureResult
[17:42:22.747] result() for ClusterFuture ... done
[17:42:22.747] result() for ClusterFuture ...
[17:42:22.747] - result already collected: FutureResult
[17:42:22.747] result() for ClusterFuture ... done
[17:42:22.747] result() for ClusterFuture ...
[17:42:22.747] - result already collected: FutureResult
[17:42:22.747] result() for ClusterFuture ... done
[17:42:22.748] result() for ClusterFuture ...
[17:42:22.748] - result already collected: FutureResult
[17:42:22.748] result() for ClusterFuture ... done
[17:42:22.748] result() for ClusterFuture ...
[17:42:22.748] - result already collected: FutureResult
[17:42:22.748] result() for ClusterFuture ... done
<environment: 0x55bef9fa92b8> 
Dimensions: c(2, 3)
[17:42:22.748] getGlobalsAndPackages() ...
[17:42:22.749] Searching for globals...
[17:42:22.749] 
[17:42:22.749] Searching for globals ... DONE
[17:42:22.749] - globals: [0] <none>
[17:42:22.749] getGlobalsAndPackages() ... DONE
[17:42:22.749] run() for ‘Future’ ...
[17:42:22.749] - state: ‘created’
[17:42:22.750] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.765] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.765]   - Field: ‘node’
[17:42:22.765]   - Field: ‘label’
[17:42:22.765]   - Field: ‘local’
[17:42:22.765]   - Field: ‘owner’
[17:42:22.765]   - Field: ‘envir’
[17:42:22.766]   - Field: ‘workers’
[17:42:22.766]   - Field: ‘packages’
[17:42:22.766]   - Field: ‘gc’
[17:42:22.766]   - Field: ‘conditions’
[17:42:22.766]   - Field: ‘persistent’
[17:42:22.766]   - Field: ‘expr’
[17:42:22.766]   - Field: ‘uuid’
[17:42:22.766]   - Field: ‘seed’
[17:42:22.766]   - Field: ‘version’
[17:42:22.766]   - Field: ‘result’
[17:42:22.767]   - Field: ‘asynchronous’
[17:42:22.767]   - Field: ‘calls’
[17:42:22.767]   - Field: ‘globals’
[17:42:22.767]   - Field: ‘stdout’
[17:42:22.767]   - Field: ‘earlySignal’
[17:42:22.767]   - Field: ‘lazy’
[17:42:22.767]   - Field: ‘state’
[17:42:22.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.767] - Launch lazy future ...
[17:42:22.768] Packages needed by the future expression (n = 0): <none>
[17:42:22.768] Packages needed by future strategies (n = 0): <none>
[17:42:22.768] {
[17:42:22.768]     {
[17:42:22.768]         {
[17:42:22.768]             ...future.startTime <- base::Sys.time()
[17:42:22.768]             {
[17:42:22.768]                 {
[17:42:22.768]                   {
[17:42:22.768]                     {
[17:42:22.768]                       base::local({
[17:42:22.768]                         has_future <- base::requireNamespace("future", 
[17:42:22.768]                           quietly = TRUE)
[17:42:22.768]                         if (has_future) {
[17:42:22.768]                           ns <- base::getNamespace("future")
[17:42:22.768]                           version <- ns[[".package"]][["version"]]
[17:42:22.768]                           if (is.null(version)) 
[17:42:22.768]                             version <- utils::packageVersion("future")
[17:42:22.768]                         }
[17:42:22.768]                         else {
[17:42:22.768]                           version <- NULL
[17:42:22.768]                         }
[17:42:22.768]                         if (!has_future || version < "1.8.0") {
[17:42:22.768]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.768]                             "", base::R.version$version.string), 
[17:42:22.768]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.768]                               "release", "version")], collapse = " "), 
[17:42:22.768]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.768]                             info)
[17:42:22.768]                           info <- base::paste(info, collapse = "; ")
[17:42:22.768]                           if (!has_future) {
[17:42:22.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.768]                               info)
[17:42:22.768]                           }
[17:42:22.768]                           else {
[17:42:22.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.768]                               info, version)
[17:42:22.768]                           }
[17:42:22.768]                           base::stop(msg)
[17:42:22.768]                         }
[17:42:22.768]                       })
[17:42:22.768]                     }
[17:42:22.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.768]                     base::options(mc.cores = 1L)
[17:42:22.768]                   }
[17:42:22.768]                   options(future.plan = NULL)
[17:42:22.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.768]                 }
[17:42:22.768]                 ...future.workdir <- getwd()
[17:42:22.768]             }
[17:42:22.768]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.768]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.768]         }
[17:42:22.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.768]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.768]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.768]             base::names(...future.oldOptions))
[17:42:22.768]     }
[17:42:22.768]     if (FALSE) {
[17:42:22.768]     }
[17:42:22.768]     else {
[17:42:22.768]         if (TRUE) {
[17:42:22.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.768]                 open = "w")
[17:42:22.768]         }
[17:42:22.768]         else {
[17:42:22.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.768]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.768]         }
[17:42:22.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.768]             base::sink(type = "output", split = FALSE)
[17:42:22.768]             base::close(...future.stdout)
[17:42:22.768]         }, add = TRUE)
[17:42:22.768]     }
[17:42:22.768]     ...future.frame <- base::sys.nframe()
[17:42:22.768]     ...future.conditions <- base::list()
[17:42:22.768]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.768]     if (FALSE) {
[17:42:22.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.768]     }
[17:42:22.768]     ...future.result <- base::tryCatch({
[17:42:22.768]         base::withCallingHandlers({
[17:42:22.768]             ...future.value <- base::withVisible(base::local({
[17:42:22.768]                 ...future.makeSendCondition <- local({
[17:42:22.768]                   sendCondition <- NULL
[17:42:22.768]                   function(frame = 1L) {
[17:42:22.768]                     if (is.function(sendCondition)) 
[17:42:22.768]                       return(sendCondition)
[17:42:22.768]                     ns <- getNamespace("parallel")
[17:42:22.768]                     if (exists("sendData", mode = "function", 
[17:42:22.768]                       envir = ns)) {
[17:42:22.768]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.768]                         envir = ns)
[17:42:22.768]                       envir <- sys.frame(frame)
[17:42:22.768]                       master <- NULL
[17:42:22.768]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.768]                         !identical(envir, emptyenv())) {
[17:42:22.768]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.768]                           inherits = FALSE)) {
[17:42:22.768]                           master <- get("master", mode = "list", 
[17:42:22.768]                             envir = envir, inherits = FALSE)
[17:42:22.768]                           if (inherits(master, c("SOCKnode", 
[17:42:22.768]                             "SOCK0node"))) {
[17:42:22.768]                             sendCondition <<- function(cond) {
[17:42:22.768]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.768]                                 success = TRUE)
[17:42:22.768]                               parallel_sendData(master, data)
[17:42:22.768]                             }
[17:42:22.768]                             return(sendCondition)
[17:42:22.768]                           }
[17:42:22.768]                         }
[17:42:22.768]                         frame <- frame + 1L
[17:42:22.768]                         envir <- sys.frame(frame)
[17:42:22.768]                       }
[17:42:22.768]                     }
[17:42:22.768]                     sendCondition <<- function(cond) NULL
[17:42:22.768]                   }
[17:42:22.768]                 })
[17:42:22.768]                 withCallingHandlers({
[17:42:22.768]                   2
[17:42:22.768]                 }, immediateCondition = function(cond) {
[17:42:22.768]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.768]                   sendCondition(cond)
[17:42:22.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.768]                   {
[17:42:22.768]                     inherits <- base::inherits
[17:42:22.768]                     invokeRestart <- base::invokeRestart
[17:42:22.768]                     is.null <- base::is.null
[17:42:22.768]                     muffled <- FALSE
[17:42:22.768]                     if (inherits(cond, "message")) {
[17:42:22.768]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.768]                       if (muffled) 
[17:42:22.768]                         invokeRestart("muffleMessage")
[17:42:22.768]                     }
[17:42:22.768]                     else if (inherits(cond, "warning")) {
[17:42:22.768]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.768]                       if (muffled) 
[17:42:22.768]                         invokeRestart("muffleWarning")
[17:42:22.768]                     }
[17:42:22.768]                     else if (inherits(cond, "condition")) {
[17:42:22.768]                       if (!is.null(pattern)) {
[17:42:22.768]                         computeRestarts <- base::computeRestarts
[17:42:22.768]                         grepl <- base::grepl
[17:42:22.768]                         restarts <- computeRestarts(cond)
[17:42:22.768]                         for (restart in restarts) {
[17:42:22.768]                           name <- restart$name
[17:42:22.768]                           if (is.null(name)) 
[17:42:22.768]                             next
[17:42:22.768]                           if (!grepl(pattern, name)) 
[17:42:22.768]                             next
[17:42:22.768]                           invokeRestart(restart)
[17:42:22.768]                           muffled <- TRUE
[17:42:22.768]                           break
[17:42:22.768]                         }
[17:42:22.768]                       }
[17:42:22.768]                     }
[17:42:22.768]                     invisible(muffled)
[17:42:22.768]                   }
[17:42:22.768]                   muffleCondition(cond)
[17:42:22.768]                 })
[17:42:22.768]             }))
[17:42:22.768]             future::FutureResult(value = ...future.value$value, 
[17:42:22.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.768]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.768]                     ...future.globalenv.names))
[17:42:22.768]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.768]         }, condition = base::local({
[17:42:22.768]             c <- base::c
[17:42:22.768]             inherits <- base::inherits
[17:42:22.768]             invokeRestart <- base::invokeRestart
[17:42:22.768]             length <- base::length
[17:42:22.768]             list <- base::list
[17:42:22.768]             seq.int <- base::seq.int
[17:42:22.768]             signalCondition <- base::signalCondition
[17:42:22.768]             sys.calls <- base::sys.calls
[17:42:22.768]             `[[` <- base::`[[`
[17:42:22.768]             `+` <- base::`+`
[17:42:22.768]             `<<-` <- base::`<<-`
[17:42:22.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.768]                   3L)]
[17:42:22.768]             }
[17:42:22.768]             function(cond) {
[17:42:22.768]                 is_error <- inherits(cond, "error")
[17:42:22.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.768]                   NULL)
[17:42:22.768]                 if (is_error) {
[17:42:22.768]                   sessionInformation <- function() {
[17:42:22.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.768]                       search = base::search(), system = base::Sys.info())
[17:42:22.768]                   }
[17:42:22.768]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.768]                     cond$call), session = sessionInformation(), 
[17:42:22.768]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.768]                   signalCondition(cond)
[17:42:22.768]                 }
[17:42:22.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.768]                 "immediateCondition"))) {
[17:42:22.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.768]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.768]                   if (TRUE && !signal) {
[17:42:22.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.768]                     {
[17:42:22.768]                       inherits <- base::inherits
[17:42:22.768]                       invokeRestart <- base::invokeRestart
[17:42:22.768]                       is.null <- base::is.null
[17:42:22.768]                       muffled <- FALSE
[17:42:22.768]                       if (inherits(cond, "message")) {
[17:42:22.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.768]                         if (muffled) 
[17:42:22.768]                           invokeRestart("muffleMessage")
[17:42:22.768]                       }
[17:42:22.768]                       else if (inherits(cond, "warning")) {
[17:42:22.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.768]                         if (muffled) 
[17:42:22.768]                           invokeRestart("muffleWarning")
[17:42:22.768]                       }
[17:42:22.768]                       else if (inherits(cond, "condition")) {
[17:42:22.768]                         if (!is.null(pattern)) {
[17:42:22.768]                           computeRestarts <- base::computeRestarts
[17:42:22.768]                           grepl <- base::grepl
[17:42:22.768]                           restarts <- computeRestarts(cond)
[17:42:22.768]                           for (restart in restarts) {
[17:42:22.768]                             name <- restart$name
[17:42:22.768]                             if (is.null(name)) 
[17:42:22.768]                               next
[17:42:22.768]                             if (!grepl(pattern, name)) 
[17:42:22.768]                               next
[17:42:22.768]                             invokeRestart(restart)
[17:42:22.768]                             muffled <- TRUE
[17:42:22.768]                             break
[17:42:22.768]                           }
[17:42:22.768]                         }
[17:42:22.768]                       }
[17:42:22.768]                       invisible(muffled)
[17:42:22.768]                     }
[17:42:22.768]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.768]                   }
[17:42:22.768]                 }
[17:42:22.768]                 else {
[17:42:22.768]                   if (TRUE) {
[17:42:22.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.768]                     {
[17:42:22.768]                       inherits <- base::inherits
[17:42:22.768]                       invokeRestart <- base::invokeRestart
[17:42:22.768]                       is.null <- base::is.null
[17:42:22.768]                       muffled <- FALSE
[17:42:22.768]                       if (inherits(cond, "message")) {
[17:42:22.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.768]                         if (muffled) 
[17:42:22.768]                           invokeRestart("muffleMessage")
[17:42:22.768]                       }
[17:42:22.768]                       else if (inherits(cond, "warning")) {
[17:42:22.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.768]                         if (muffled) 
[17:42:22.768]                           invokeRestart("muffleWarning")
[17:42:22.768]                       }
[17:42:22.768]                       else if (inherits(cond, "condition")) {
[17:42:22.768]                         if (!is.null(pattern)) {
[17:42:22.768]                           computeRestarts <- base::computeRestarts
[17:42:22.768]                           grepl <- base::grepl
[17:42:22.768]                           restarts <- computeRestarts(cond)
[17:42:22.768]                           for (restart in restarts) {
[17:42:22.768]                             name <- restart$name
[17:42:22.768]                             if (is.null(name)) 
[17:42:22.768]                               next
[17:42:22.768]                             if (!grepl(pattern, name)) 
[17:42:22.768]                               next
[17:42:22.768]                             invokeRestart(restart)
[17:42:22.768]                             muffled <- TRUE
[17:42:22.768]                             break
[17:42:22.768]                           }
[17:42:22.768]                         }
[17:42:22.768]                       }
[17:42:22.768]                       invisible(muffled)
[17:42:22.768]                     }
[17:42:22.768]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.768]                   }
[17:42:22.768]                 }
[17:42:22.768]             }
[17:42:22.768]         }))
[17:42:22.768]     }, error = function(ex) {
[17:42:22.768]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.768]                 ...future.rng), started = ...future.startTime, 
[17:42:22.768]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.768]             version = "1.8"), class = "FutureResult")
[17:42:22.768]     }, finally = {
[17:42:22.768]         if (!identical(...future.workdir, getwd())) 
[17:42:22.768]             setwd(...future.workdir)
[17:42:22.768]         {
[17:42:22.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.768]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.768]             }
[17:42:22.768]             base::options(...future.oldOptions)
[17:42:22.768]             if (.Platform$OS.type == "windows") {
[17:42:22.768]                 old_names <- names(...future.oldEnvVars)
[17:42:22.768]                 envs <- base::Sys.getenv()
[17:42:22.768]                 names <- names(envs)
[17:42:22.768]                 common <- intersect(names, old_names)
[17:42:22.768]                 added <- setdiff(names, old_names)
[17:42:22.768]                 removed <- setdiff(old_names, names)
[17:42:22.768]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.768]                   envs[common]]
[17:42:22.768]                 NAMES <- toupper(changed)
[17:42:22.768]                 args <- list()
[17:42:22.768]                 for (kk in seq_along(NAMES)) {
[17:42:22.768]                   name <- changed[[kk]]
[17:42:22.768]                   NAME <- NAMES[[kk]]
[17:42:22.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.768]                     next
[17:42:22.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.768]                 }
[17:42:22.768]                 NAMES <- toupper(added)
[17:42:22.768]                 for (kk in seq_along(NAMES)) {
[17:42:22.768]                   name <- added[[kk]]
[17:42:22.768]                   NAME <- NAMES[[kk]]
[17:42:22.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.768]                     next
[17:42:22.768]                   args[[name]] <- ""
[17:42:22.768]                 }
[17:42:22.768]                 NAMES <- toupper(removed)
[17:42:22.768]                 for (kk in seq_along(NAMES)) {
[17:42:22.768]                   name <- removed[[kk]]
[17:42:22.768]                   NAME <- NAMES[[kk]]
[17:42:22.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.768]                     next
[17:42:22.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.768]                 }
[17:42:22.768]                 if (length(args) > 0) 
[17:42:22.768]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.768]             }
[17:42:22.768]             else {
[17:42:22.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.768]             }
[17:42:22.768]             {
[17:42:22.768]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.768]                   0L) {
[17:42:22.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.768]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.768]                   base::options(opts)
[17:42:22.768]                 }
[17:42:22.768]                 {
[17:42:22.768]                   {
[17:42:22.768]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.768]                     NULL
[17:42:22.768]                   }
[17:42:22.768]                   options(future.plan = NULL)
[17:42:22.768]                   if (is.na(NA_character_)) 
[17:42:22.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.768]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.768]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.768]                     envir = parent.frame()) 
[17:42:22.768]                   {
[17:42:22.768]                     if (is.function(workers)) 
[17:42:22.768]                       workers <- workers()
[17:42:22.768]                     workers <- structure(as.integer(workers), 
[17:42:22.768]                       class = class(workers))
[17:42:22.768]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.768]                       workers >= 1)
[17:42:22.768]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.768]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.768]                     }
[17:42:22.768]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.768]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.768]                       envir = envir)
[17:42:22.768]                     if (!future$lazy) 
[17:42:22.768]                       future <- run(future)
[17:42:22.768]                     invisible(future)
[17:42:22.768]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.768]                 }
[17:42:22.768]             }
[17:42:22.768]         }
[17:42:22.768]     })
[17:42:22.768]     if (TRUE) {
[17:42:22.768]         base::sink(type = "output", split = FALSE)
[17:42:22.768]         if (TRUE) {
[17:42:22.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.768]         }
[17:42:22.768]         else {
[17:42:22.768]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.768]         }
[17:42:22.768]         base::close(...future.stdout)
[17:42:22.768]         ...future.stdout <- NULL
[17:42:22.768]     }
[17:42:22.768]     ...future.result$conditions <- ...future.conditions
[17:42:22.768]     ...future.result$finished <- base::Sys.time()
[17:42:22.768]     ...future.result
[17:42:22.768] }
[17:42:22.771] MultisessionFuture started
[17:42:22.771] - Launch lazy future ... done
[17:42:22.772] run() for ‘MultisessionFuture’ ... done
[17:42:22.772] getGlobalsAndPackages() ...
[17:42:22.772] Searching for globals...
[17:42:22.772] 
[17:42:22.772] Searching for globals ... DONE
[17:42:22.772] - globals: [0] <none>
[17:42:22.772] getGlobalsAndPackages() ... DONE
[17:42:22.773] run() for ‘Future’ ...
[17:42:22.773] - state: ‘created’
[17:42:22.773] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.788] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.789]   - Field: ‘node’
[17:42:22.789]   - Field: ‘label’
[17:42:22.789]   - Field: ‘local’
[17:42:22.789]   - Field: ‘owner’
[17:42:22.789]   - Field: ‘envir’
[17:42:22.789]   - Field: ‘workers’
[17:42:22.789]   - Field: ‘packages’
[17:42:22.789]   - Field: ‘gc’
[17:42:22.789]   - Field: ‘conditions’
[17:42:22.789]   - Field: ‘persistent’
[17:42:22.789]   - Field: ‘expr’
[17:42:22.790]   - Field: ‘uuid’
[17:42:22.790]   - Field: ‘seed’
[17:42:22.790]   - Field: ‘version’
[17:42:22.790]   - Field: ‘result’
[17:42:22.790]   - Field: ‘asynchronous’
[17:42:22.790]   - Field: ‘calls’
[17:42:22.790]   - Field: ‘globals’
[17:42:22.790]   - Field: ‘stdout’
[17:42:22.790]   - Field: ‘earlySignal’
[17:42:22.790]   - Field: ‘lazy’
[17:42:22.791]   - Field: ‘state’
[17:42:22.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.791] - Launch lazy future ...
[17:42:22.791] Packages needed by the future expression (n = 0): <none>
[17:42:22.791] Packages needed by future strategies (n = 0): <none>
[17:42:22.792] {
[17:42:22.792]     {
[17:42:22.792]         {
[17:42:22.792]             ...future.startTime <- base::Sys.time()
[17:42:22.792]             {
[17:42:22.792]                 {
[17:42:22.792]                   {
[17:42:22.792]                     {
[17:42:22.792]                       base::local({
[17:42:22.792]                         has_future <- base::requireNamespace("future", 
[17:42:22.792]                           quietly = TRUE)
[17:42:22.792]                         if (has_future) {
[17:42:22.792]                           ns <- base::getNamespace("future")
[17:42:22.792]                           version <- ns[[".package"]][["version"]]
[17:42:22.792]                           if (is.null(version)) 
[17:42:22.792]                             version <- utils::packageVersion("future")
[17:42:22.792]                         }
[17:42:22.792]                         else {
[17:42:22.792]                           version <- NULL
[17:42:22.792]                         }
[17:42:22.792]                         if (!has_future || version < "1.8.0") {
[17:42:22.792]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.792]                             "", base::R.version$version.string), 
[17:42:22.792]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.792]                               "release", "version")], collapse = " "), 
[17:42:22.792]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.792]                             info)
[17:42:22.792]                           info <- base::paste(info, collapse = "; ")
[17:42:22.792]                           if (!has_future) {
[17:42:22.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.792]                               info)
[17:42:22.792]                           }
[17:42:22.792]                           else {
[17:42:22.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.792]                               info, version)
[17:42:22.792]                           }
[17:42:22.792]                           base::stop(msg)
[17:42:22.792]                         }
[17:42:22.792]                       })
[17:42:22.792]                     }
[17:42:22.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.792]                     base::options(mc.cores = 1L)
[17:42:22.792]                   }
[17:42:22.792]                   options(future.plan = NULL)
[17:42:22.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.792]                 }
[17:42:22.792]                 ...future.workdir <- getwd()
[17:42:22.792]             }
[17:42:22.792]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.792]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.792]         }
[17:42:22.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.792]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.792]             base::names(...future.oldOptions))
[17:42:22.792]     }
[17:42:22.792]     if (FALSE) {
[17:42:22.792]     }
[17:42:22.792]     else {
[17:42:22.792]         if (TRUE) {
[17:42:22.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.792]                 open = "w")
[17:42:22.792]         }
[17:42:22.792]         else {
[17:42:22.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.792]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.792]         }
[17:42:22.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.792]             base::sink(type = "output", split = FALSE)
[17:42:22.792]             base::close(...future.stdout)
[17:42:22.792]         }, add = TRUE)
[17:42:22.792]     }
[17:42:22.792]     ...future.frame <- base::sys.nframe()
[17:42:22.792]     ...future.conditions <- base::list()
[17:42:22.792]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.792]     if (FALSE) {
[17:42:22.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.792]     }
[17:42:22.792]     ...future.result <- base::tryCatch({
[17:42:22.792]         base::withCallingHandlers({
[17:42:22.792]             ...future.value <- base::withVisible(base::local({
[17:42:22.792]                 ...future.makeSendCondition <- local({
[17:42:22.792]                   sendCondition <- NULL
[17:42:22.792]                   function(frame = 1L) {
[17:42:22.792]                     if (is.function(sendCondition)) 
[17:42:22.792]                       return(sendCondition)
[17:42:22.792]                     ns <- getNamespace("parallel")
[17:42:22.792]                     if (exists("sendData", mode = "function", 
[17:42:22.792]                       envir = ns)) {
[17:42:22.792]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.792]                         envir = ns)
[17:42:22.792]                       envir <- sys.frame(frame)
[17:42:22.792]                       master <- NULL
[17:42:22.792]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.792]                         !identical(envir, emptyenv())) {
[17:42:22.792]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.792]                           inherits = FALSE)) {
[17:42:22.792]                           master <- get("master", mode = "list", 
[17:42:22.792]                             envir = envir, inherits = FALSE)
[17:42:22.792]                           if (inherits(master, c("SOCKnode", 
[17:42:22.792]                             "SOCK0node"))) {
[17:42:22.792]                             sendCondition <<- function(cond) {
[17:42:22.792]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.792]                                 success = TRUE)
[17:42:22.792]                               parallel_sendData(master, data)
[17:42:22.792]                             }
[17:42:22.792]                             return(sendCondition)
[17:42:22.792]                           }
[17:42:22.792]                         }
[17:42:22.792]                         frame <- frame + 1L
[17:42:22.792]                         envir <- sys.frame(frame)
[17:42:22.792]                       }
[17:42:22.792]                     }
[17:42:22.792]                     sendCondition <<- function(cond) NULL
[17:42:22.792]                   }
[17:42:22.792]                 })
[17:42:22.792]                 withCallingHandlers({
[17:42:22.792]                   NULL
[17:42:22.792]                 }, immediateCondition = function(cond) {
[17:42:22.792]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.792]                   sendCondition(cond)
[17:42:22.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.792]                   {
[17:42:22.792]                     inherits <- base::inherits
[17:42:22.792]                     invokeRestart <- base::invokeRestart
[17:42:22.792]                     is.null <- base::is.null
[17:42:22.792]                     muffled <- FALSE
[17:42:22.792]                     if (inherits(cond, "message")) {
[17:42:22.792]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.792]                       if (muffled) 
[17:42:22.792]                         invokeRestart("muffleMessage")
[17:42:22.792]                     }
[17:42:22.792]                     else if (inherits(cond, "warning")) {
[17:42:22.792]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.792]                       if (muffled) 
[17:42:22.792]                         invokeRestart("muffleWarning")
[17:42:22.792]                     }
[17:42:22.792]                     else if (inherits(cond, "condition")) {
[17:42:22.792]                       if (!is.null(pattern)) {
[17:42:22.792]                         computeRestarts <- base::computeRestarts
[17:42:22.792]                         grepl <- base::grepl
[17:42:22.792]                         restarts <- computeRestarts(cond)
[17:42:22.792]                         for (restart in restarts) {
[17:42:22.792]                           name <- restart$name
[17:42:22.792]                           if (is.null(name)) 
[17:42:22.792]                             next
[17:42:22.792]                           if (!grepl(pattern, name)) 
[17:42:22.792]                             next
[17:42:22.792]                           invokeRestart(restart)
[17:42:22.792]                           muffled <- TRUE
[17:42:22.792]                           break
[17:42:22.792]                         }
[17:42:22.792]                       }
[17:42:22.792]                     }
[17:42:22.792]                     invisible(muffled)
[17:42:22.792]                   }
[17:42:22.792]                   muffleCondition(cond)
[17:42:22.792]                 })
[17:42:22.792]             }))
[17:42:22.792]             future::FutureResult(value = ...future.value$value, 
[17:42:22.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.792]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.792]                     ...future.globalenv.names))
[17:42:22.792]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.792]         }, condition = base::local({
[17:42:22.792]             c <- base::c
[17:42:22.792]             inherits <- base::inherits
[17:42:22.792]             invokeRestart <- base::invokeRestart
[17:42:22.792]             length <- base::length
[17:42:22.792]             list <- base::list
[17:42:22.792]             seq.int <- base::seq.int
[17:42:22.792]             signalCondition <- base::signalCondition
[17:42:22.792]             sys.calls <- base::sys.calls
[17:42:22.792]             `[[` <- base::`[[`
[17:42:22.792]             `+` <- base::`+`
[17:42:22.792]             `<<-` <- base::`<<-`
[17:42:22.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.792]                   3L)]
[17:42:22.792]             }
[17:42:22.792]             function(cond) {
[17:42:22.792]                 is_error <- inherits(cond, "error")
[17:42:22.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.792]                   NULL)
[17:42:22.792]                 if (is_error) {
[17:42:22.792]                   sessionInformation <- function() {
[17:42:22.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.792]                       search = base::search(), system = base::Sys.info())
[17:42:22.792]                   }
[17:42:22.792]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.792]                     cond$call), session = sessionInformation(), 
[17:42:22.792]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.792]                   signalCondition(cond)
[17:42:22.792]                 }
[17:42:22.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.792]                 "immediateCondition"))) {
[17:42:22.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.792]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.792]                   if (TRUE && !signal) {
[17:42:22.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.792]                     {
[17:42:22.792]                       inherits <- base::inherits
[17:42:22.792]                       invokeRestart <- base::invokeRestart
[17:42:22.792]                       is.null <- base::is.null
[17:42:22.792]                       muffled <- FALSE
[17:42:22.792]                       if (inherits(cond, "message")) {
[17:42:22.792]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.792]                         if (muffled) 
[17:42:22.792]                           invokeRestart("muffleMessage")
[17:42:22.792]                       }
[17:42:22.792]                       else if (inherits(cond, "warning")) {
[17:42:22.792]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.792]                         if (muffled) 
[17:42:22.792]                           invokeRestart("muffleWarning")
[17:42:22.792]                       }
[17:42:22.792]                       else if (inherits(cond, "condition")) {
[17:42:22.792]                         if (!is.null(pattern)) {
[17:42:22.792]                           computeRestarts <- base::computeRestarts
[17:42:22.792]                           grepl <- base::grepl
[17:42:22.792]                           restarts <- computeRestarts(cond)
[17:42:22.792]                           for (restart in restarts) {
[17:42:22.792]                             name <- restart$name
[17:42:22.792]                             if (is.null(name)) 
[17:42:22.792]                               next
[17:42:22.792]                             if (!grepl(pattern, name)) 
[17:42:22.792]                               next
[17:42:22.792]                             invokeRestart(restart)
[17:42:22.792]                             muffled <- TRUE
[17:42:22.792]                             break
[17:42:22.792]                           }
[17:42:22.792]                         }
[17:42:22.792]                       }
[17:42:22.792]                       invisible(muffled)
[17:42:22.792]                     }
[17:42:22.792]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.792]                   }
[17:42:22.792]                 }
[17:42:22.792]                 else {
[17:42:22.792]                   if (TRUE) {
[17:42:22.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.792]                     {
[17:42:22.792]                       inherits <- base::inherits
[17:42:22.792]                       invokeRestart <- base::invokeRestart
[17:42:22.792]                       is.null <- base::is.null
[17:42:22.792]                       muffled <- FALSE
[17:42:22.792]                       if (inherits(cond, "message")) {
[17:42:22.792]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.792]                         if (muffled) 
[17:42:22.792]                           invokeRestart("muffleMessage")
[17:42:22.792]                       }
[17:42:22.792]                       else if (inherits(cond, "warning")) {
[17:42:22.792]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.792]                         if (muffled) 
[17:42:22.792]                           invokeRestart("muffleWarning")
[17:42:22.792]                       }
[17:42:22.792]                       else if (inherits(cond, "condition")) {
[17:42:22.792]                         if (!is.null(pattern)) {
[17:42:22.792]                           computeRestarts <- base::computeRestarts
[17:42:22.792]                           grepl <- base::grepl
[17:42:22.792]                           restarts <- computeRestarts(cond)
[17:42:22.792]                           for (restart in restarts) {
[17:42:22.792]                             name <- restart$name
[17:42:22.792]                             if (is.null(name)) 
[17:42:22.792]                               next
[17:42:22.792]                             if (!grepl(pattern, name)) 
[17:42:22.792]                               next
[17:42:22.792]                             invokeRestart(restart)
[17:42:22.792]                             muffled <- TRUE
[17:42:22.792]                             break
[17:42:22.792]                           }
[17:42:22.792]                         }
[17:42:22.792]                       }
[17:42:22.792]                       invisible(muffled)
[17:42:22.792]                     }
[17:42:22.792]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.792]                   }
[17:42:22.792]                 }
[17:42:22.792]             }
[17:42:22.792]         }))
[17:42:22.792]     }, error = function(ex) {
[17:42:22.792]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.792]                 ...future.rng), started = ...future.startTime, 
[17:42:22.792]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.792]             version = "1.8"), class = "FutureResult")
[17:42:22.792]     }, finally = {
[17:42:22.792]         if (!identical(...future.workdir, getwd())) 
[17:42:22.792]             setwd(...future.workdir)
[17:42:22.792]         {
[17:42:22.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.792]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.792]             }
[17:42:22.792]             base::options(...future.oldOptions)
[17:42:22.792]             if (.Platform$OS.type == "windows") {
[17:42:22.792]                 old_names <- names(...future.oldEnvVars)
[17:42:22.792]                 envs <- base::Sys.getenv()
[17:42:22.792]                 names <- names(envs)
[17:42:22.792]                 common <- intersect(names, old_names)
[17:42:22.792]                 added <- setdiff(names, old_names)
[17:42:22.792]                 removed <- setdiff(old_names, names)
[17:42:22.792]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.792]                   envs[common]]
[17:42:22.792]                 NAMES <- toupper(changed)
[17:42:22.792]                 args <- list()
[17:42:22.792]                 for (kk in seq_along(NAMES)) {
[17:42:22.792]                   name <- changed[[kk]]
[17:42:22.792]                   NAME <- NAMES[[kk]]
[17:42:22.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.792]                     next
[17:42:22.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.792]                 }
[17:42:22.792]                 NAMES <- toupper(added)
[17:42:22.792]                 for (kk in seq_along(NAMES)) {
[17:42:22.792]                   name <- added[[kk]]
[17:42:22.792]                   NAME <- NAMES[[kk]]
[17:42:22.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.792]                     next
[17:42:22.792]                   args[[name]] <- ""
[17:42:22.792]                 }
[17:42:22.792]                 NAMES <- toupper(removed)
[17:42:22.792]                 for (kk in seq_along(NAMES)) {
[17:42:22.792]                   name <- removed[[kk]]
[17:42:22.792]                   NAME <- NAMES[[kk]]
[17:42:22.792]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.792]                     next
[17:42:22.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.792]                 }
[17:42:22.792]                 if (length(args) > 0) 
[17:42:22.792]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.792]             }
[17:42:22.792]             else {
[17:42:22.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.792]             }
[17:42:22.792]             {
[17:42:22.792]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.792]                   0L) {
[17:42:22.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.792]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.792]                   base::options(opts)
[17:42:22.792]                 }
[17:42:22.792]                 {
[17:42:22.792]                   {
[17:42:22.792]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.792]                     NULL
[17:42:22.792]                   }
[17:42:22.792]                   options(future.plan = NULL)
[17:42:22.792]                   if (is.na(NA_character_)) 
[17:42:22.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.792]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.792]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.792]                     envir = parent.frame()) 
[17:42:22.792]                   {
[17:42:22.792]                     if (is.function(workers)) 
[17:42:22.792]                       workers <- workers()
[17:42:22.792]                     workers <- structure(as.integer(workers), 
[17:42:22.792]                       class = class(workers))
[17:42:22.792]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.792]                       workers >= 1)
[17:42:22.792]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.792]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.792]                     }
[17:42:22.792]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.792]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.792]                       envir = envir)
[17:42:22.792]                     if (!future$lazy) 
[17:42:22.792]                       future <- run(future)
[17:42:22.792]                     invisible(future)
[17:42:22.792]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.792]                 }
[17:42:22.792]             }
[17:42:22.792]         }
[17:42:22.792]     })
[17:42:22.792]     if (TRUE) {
[17:42:22.792]         base::sink(type = "output", split = FALSE)
[17:42:22.792]         if (TRUE) {
[17:42:22.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.792]         }
[17:42:22.792]         else {
[17:42:22.792]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.792]         }
[17:42:22.792]         base::close(...future.stdout)
[17:42:22.792]         ...future.stdout <- NULL
[17:42:22.792]     }
[17:42:22.792]     ...future.result$conditions <- ...future.conditions
[17:42:22.792]     ...future.result$finished <- base::Sys.time()
[17:42:22.792]     ...future.result
[17:42:22.792] }
[17:42:22.795] MultisessionFuture started
[17:42:22.795] - Launch lazy future ... done
[17:42:22.795] run() for ‘MultisessionFuture’ ... done
[17:42:22.795] getGlobalsAndPackages() ...
[17:42:22.795] Searching for globals...
[17:42:22.796] - globals found: [1] ‘{’
[17:42:22.796] Searching for globals ... DONE
[17:42:22.796] Resolving globals: FALSE
[17:42:22.797] 
[17:42:22.797] 
[17:42:22.797] getGlobalsAndPackages() ... DONE
[17:42:22.797] run() for ‘Future’ ...
[17:42:22.797] - state: ‘created’
[17:42:22.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.811] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.812]   - Field: ‘node’
[17:42:22.812]   - Field: ‘label’
[17:42:22.812]   - Field: ‘local’
[17:42:22.812]   - Field: ‘owner’
[17:42:22.812]   - Field: ‘envir’
[17:42:22.812]   - Field: ‘workers’
[17:42:22.812]   - Field: ‘packages’
[17:42:22.812]   - Field: ‘gc’
[17:42:22.813]   - Field: ‘conditions’
[17:42:22.813]   - Field: ‘persistent’
[17:42:22.813]   - Field: ‘expr’
[17:42:22.813]   - Field: ‘uuid’
[17:42:22.813]   - Field: ‘seed’
[17:42:22.813]   - Field: ‘version’
[17:42:22.813]   - Field: ‘result’
[17:42:22.813]   - Field: ‘asynchronous’
[17:42:22.813]   - Field: ‘calls’
[17:42:22.813]   - Field: ‘globals’
[17:42:22.814]   - Field: ‘stdout’
[17:42:22.814]   - Field: ‘earlySignal’
[17:42:22.814]   - Field: ‘lazy’
[17:42:22.814]   - Field: ‘state’
[17:42:22.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.814] - Launch lazy future ...
[17:42:22.814] Packages needed by the future expression (n = 0): <none>
[17:42:22.814] Packages needed by future strategies (n = 0): <none>
[17:42:22.815] {
[17:42:22.815]     {
[17:42:22.815]         {
[17:42:22.815]             ...future.startTime <- base::Sys.time()
[17:42:22.815]             {
[17:42:22.815]                 {
[17:42:22.815]                   {
[17:42:22.815]                     {
[17:42:22.815]                       base::local({
[17:42:22.815]                         has_future <- base::requireNamespace("future", 
[17:42:22.815]                           quietly = TRUE)
[17:42:22.815]                         if (has_future) {
[17:42:22.815]                           ns <- base::getNamespace("future")
[17:42:22.815]                           version <- ns[[".package"]][["version"]]
[17:42:22.815]                           if (is.null(version)) 
[17:42:22.815]                             version <- utils::packageVersion("future")
[17:42:22.815]                         }
[17:42:22.815]                         else {
[17:42:22.815]                           version <- NULL
[17:42:22.815]                         }
[17:42:22.815]                         if (!has_future || version < "1.8.0") {
[17:42:22.815]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.815]                             "", base::R.version$version.string), 
[17:42:22.815]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.815]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.815]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.815]                               "release", "version")], collapse = " "), 
[17:42:22.815]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.815]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.815]                             info)
[17:42:22.815]                           info <- base::paste(info, collapse = "; ")
[17:42:22.815]                           if (!has_future) {
[17:42:22.815]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.815]                               info)
[17:42:22.815]                           }
[17:42:22.815]                           else {
[17:42:22.815]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.815]                               info, version)
[17:42:22.815]                           }
[17:42:22.815]                           base::stop(msg)
[17:42:22.815]                         }
[17:42:22.815]                       })
[17:42:22.815]                     }
[17:42:22.815]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.815]                     base::options(mc.cores = 1L)
[17:42:22.815]                   }
[17:42:22.815]                   options(future.plan = NULL)
[17:42:22.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.815]                 }
[17:42:22.815]                 ...future.workdir <- getwd()
[17:42:22.815]             }
[17:42:22.815]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.815]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.815]         }
[17:42:22.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.815]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.815]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.815]             base::names(...future.oldOptions))
[17:42:22.815]     }
[17:42:22.815]     if (FALSE) {
[17:42:22.815]     }
[17:42:22.815]     else {
[17:42:22.815]         if (TRUE) {
[17:42:22.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.815]                 open = "w")
[17:42:22.815]         }
[17:42:22.815]         else {
[17:42:22.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.815]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.815]         }
[17:42:22.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.815]             base::sink(type = "output", split = FALSE)
[17:42:22.815]             base::close(...future.stdout)
[17:42:22.815]         }, add = TRUE)
[17:42:22.815]     }
[17:42:22.815]     ...future.frame <- base::sys.nframe()
[17:42:22.815]     ...future.conditions <- base::list()
[17:42:22.815]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.815]     if (FALSE) {
[17:42:22.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.815]     }
[17:42:22.815]     ...future.result <- base::tryCatch({
[17:42:22.815]         base::withCallingHandlers({
[17:42:22.815]             ...future.value <- base::withVisible(base::local({
[17:42:22.815]                 ...future.makeSendCondition <- local({
[17:42:22.815]                   sendCondition <- NULL
[17:42:22.815]                   function(frame = 1L) {
[17:42:22.815]                     if (is.function(sendCondition)) 
[17:42:22.815]                       return(sendCondition)
[17:42:22.815]                     ns <- getNamespace("parallel")
[17:42:22.815]                     if (exists("sendData", mode = "function", 
[17:42:22.815]                       envir = ns)) {
[17:42:22.815]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.815]                         envir = ns)
[17:42:22.815]                       envir <- sys.frame(frame)
[17:42:22.815]                       master <- NULL
[17:42:22.815]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.815]                         !identical(envir, emptyenv())) {
[17:42:22.815]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.815]                           inherits = FALSE)) {
[17:42:22.815]                           master <- get("master", mode = "list", 
[17:42:22.815]                             envir = envir, inherits = FALSE)
[17:42:22.815]                           if (inherits(master, c("SOCKnode", 
[17:42:22.815]                             "SOCK0node"))) {
[17:42:22.815]                             sendCondition <<- function(cond) {
[17:42:22.815]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.815]                                 success = TRUE)
[17:42:22.815]                               parallel_sendData(master, data)
[17:42:22.815]                             }
[17:42:22.815]                             return(sendCondition)
[17:42:22.815]                           }
[17:42:22.815]                         }
[17:42:22.815]                         frame <- frame + 1L
[17:42:22.815]                         envir <- sys.frame(frame)
[17:42:22.815]                       }
[17:42:22.815]                     }
[17:42:22.815]                     sendCondition <<- function(cond) NULL
[17:42:22.815]                   }
[17:42:22.815]                 })
[17:42:22.815]                 withCallingHandlers({
[17:42:22.815]                   {
[17:42:22.815]                     4
[17:42:22.815]                   }
[17:42:22.815]                 }, immediateCondition = function(cond) {
[17:42:22.815]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.815]                   sendCondition(cond)
[17:42:22.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.815]                   {
[17:42:22.815]                     inherits <- base::inherits
[17:42:22.815]                     invokeRestart <- base::invokeRestart
[17:42:22.815]                     is.null <- base::is.null
[17:42:22.815]                     muffled <- FALSE
[17:42:22.815]                     if (inherits(cond, "message")) {
[17:42:22.815]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.815]                       if (muffled) 
[17:42:22.815]                         invokeRestart("muffleMessage")
[17:42:22.815]                     }
[17:42:22.815]                     else if (inherits(cond, "warning")) {
[17:42:22.815]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.815]                       if (muffled) 
[17:42:22.815]                         invokeRestart("muffleWarning")
[17:42:22.815]                     }
[17:42:22.815]                     else if (inherits(cond, "condition")) {
[17:42:22.815]                       if (!is.null(pattern)) {
[17:42:22.815]                         computeRestarts <- base::computeRestarts
[17:42:22.815]                         grepl <- base::grepl
[17:42:22.815]                         restarts <- computeRestarts(cond)
[17:42:22.815]                         for (restart in restarts) {
[17:42:22.815]                           name <- restart$name
[17:42:22.815]                           if (is.null(name)) 
[17:42:22.815]                             next
[17:42:22.815]                           if (!grepl(pattern, name)) 
[17:42:22.815]                             next
[17:42:22.815]                           invokeRestart(restart)
[17:42:22.815]                           muffled <- TRUE
[17:42:22.815]                           break
[17:42:22.815]                         }
[17:42:22.815]                       }
[17:42:22.815]                     }
[17:42:22.815]                     invisible(muffled)
[17:42:22.815]                   }
[17:42:22.815]                   muffleCondition(cond)
[17:42:22.815]                 })
[17:42:22.815]             }))
[17:42:22.815]             future::FutureResult(value = ...future.value$value, 
[17:42:22.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.815]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.815]                     ...future.globalenv.names))
[17:42:22.815]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.815]         }, condition = base::local({
[17:42:22.815]             c <- base::c
[17:42:22.815]             inherits <- base::inherits
[17:42:22.815]             invokeRestart <- base::invokeRestart
[17:42:22.815]             length <- base::length
[17:42:22.815]             list <- base::list
[17:42:22.815]             seq.int <- base::seq.int
[17:42:22.815]             signalCondition <- base::signalCondition
[17:42:22.815]             sys.calls <- base::sys.calls
[17:42:22.815]             `[[` <- base::`[[`
[17:42:22.815]             `+` <- base::`+`
[17:42:22.815]             `<<-` <- base::`<<-`
[17:42:22.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.815]                   3L)]
[17:42:22.815]             }
[17:42:22.815]             function(cond) {
[17:42:22.815]                 is_error <- inherits(cond, "error")
[17:42:22.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.815]                   NULL)
[17:42:22.815]                 if (is_error) {
[17:42:22.815]                   sessionInformation <- function() {
[17:42:22.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.815]                       search = base::search(), system = base::Sys.info())
[17:42:22.815]                   }
[17:42:22.815]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.815]                     cond$call), session = sessionInformation(), 
[17:42:22.815]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.815]                   signalCondition(cond)
[17:42:22.815]                 }
[17:42:22.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.815]                 "immediateCondition"))) {
[17:42:22.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.815]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.815]                   if (TRUE && !signal) {
[17:42:22.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.815]                     {
[17:42:22.815]                       inherits <- base::inherits
[17:42:22.815]                       invokeRestart <- base::invokeRestart
[17:42:22.815]                       is.null <- base::is.null
[17:42:22.815]                       muffled <- FALSE
[17:42:22.815]                       if (inherits(cond, "message")) {
[17:42:22.815]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.815]                         if (muffled) 
[17:42:22.815]                           invokeRestart("muffleMessage")
[17:42:22.815]                       }
[17:42:22.815]                       else if (inherits(cond, "warning")) {
[17:42:22.815]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.815]                         if (muffled) 
[17:42:22.815]                           invokeRestart("muffleWarning")
[17:42:22.815]                       }
[17:42:22.815]                       else if (inherits(cond, "condition")) {
[17:42:22.815]                         if (!is.null(pattern)) {
[17:42:22.815]                           computeRestarts <- base::computeRestarts
[17:42:22.815]                           grepl <- base::grepl
[17:42:22.815]                           restarts <- computeRestarts(cond)
[17:42:22.815]                           for (restart in restarts) {
[17:42:22.815]                             name <- restart$name
[17:42:22.815]                             if (is.null(name)) 
[17:42:22.815]                               next
[17:42:22.815]                             if (!grepl(pattern, name)) 
[17:42:22.815]                               next
[17:42:22.815]                             invokeRestart(restart)
[17:42:22.815]                             muffled <- TRUE
[17:42:22.815]                             break
[17:42:22.815]                           }
[17:42:22.815]                         }
[17:42:22.815]                       }
[17:42:22.815]                       invisible(muffled)
[17:42:22.815]                     }
[17:42:22.815]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.815]                   }
[17:42:22.815]                 }
[17:42:22.815]                 else {
[17:42:22.815]                   if (TRUE) {
[17:42:22.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.815]                     {
[17:42:22.815]                       inherits <- base::inherits
[17:42:22.815]                       invokeRestart <- base::invokeRestart
[17:42:22.815]                       is.null <- base::is.null
[17:42:22.815]                       muffled <- FALSE
[17:42:22.815]                       if (inherits(cond, "message")) {
[17:42:22.815]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.815]                         if (muffled) 
[17:42:22.815]                           invokeRestart("muffleMessage")
[17:42:22.815]                       }
[17:42:22.815]                       else if (inherits(cond, "warning")) {
[17:42:22.815]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.815]                         if (muffled) 
[17:42:22.815]                           invokeRestart("muffleWarning")
[17:42:22.815]                       }
[17:42:22.815]                       else if (inherits(cond, "condition")) {
[17:42:22.815]                         if (!is.null(pattern)) {
[17:42:22.815]                           computeRestarts <- base::computeRestarts
[17:42:22.815]                           grepl <- base::grepl
[17:42:22.815]                           restarts <- computeRestarts(cond)
[17:42:22.815]                           for (restart in restarts) {
[17:42:22.815]                             name <- restart$name
[17:42:22.815]                             if (is.null(name)) 
[17:42:22.815]                               next
[17:42:22.815]                             if (!grepl(pattern, name)) 
[17:42:22.815]                               next
[17:42:22.815]                             invokeRestart(restart)
[17:42:22.815]                             muffled <- TRUE
[17:42:22.815]                             break
[17:42:22.815]                           }
[17:42:22.815]                         }
[17:42:22.815]                       }
[17:42:22.815]                       invisible(muffled)
[17:42:22.815]                     }
[17:42:22.815]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.815]                   }
[17:42:22.815]                 }
[17:42:22.815]             }
[17:42:22.815]         }))
[17:42:22.815]     }, error = function(ex) {
[17:42:22.815]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.815]                 ...future.rng), started = ...future.startTime, 
[17:42:22.815]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.815]             version = "1.8"), class = "FutureResult")
[17:42:22.815]     }, finally = {
[17:42:22.815]         if (!identical(...future.workdir, getwd())) 
[17:42:22.815]             setwd(...future.workdir)
[17:42:22.815]         {
[17:42:22.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.815]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.815]             }
[17:42:22.815]             base::options(...future.oldOptions)
[17:42:22.815]             if (.Platform$OS.type == "windows") {
[17:42:22.815]                 old_names <- names(...future.oldEnvVars)
[17:42:22.815]                 envs <- base::Sys.getenv()
[17:42:22.815]                 names <- names(envs)
[17:42:22.815]                 common <- intersect(names, old_names)
[17:42:22.815]                 added <- setdiff(names, old_names)
[17:42:22.815]                 removed <- setdiff(old_names, names)
[17:42:22.815]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.815]                   envs[common]]
[17:42:22.815]                 NAMES <- toupper(changed)
[17:42:22.815]                 args <- list()
[17:42:22.815]                 for (kk in seq_along(NAMES)) {
[17:42:22.815]                   name <- changed[[kk]]
[17:42:22.815]                   NAME <- NAMES[[kk]]
[17:42:22.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.815]                     next
[17:42:22.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.815]                 }
[17:42:22.815]                 NAMES <- toupper(added)
[17:42:22.815]                 for (kk in seq_along(NAMES)) {
[17:42:22.815]                   name <- added[[kk]]
[17:42:22.815]                   NAME <- NAMES[[kk]]
[17:42:22.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.815]                     next
[17:42:22.815]                   args[[name]] <- ""
[17:42:22.815]                 }
[17:42:22.815]                 NAMES <- toupper(removed)
[17:42:22.815]                 for (kk in seq_along(NAMES)) {
[17:42:22.815]                   name <- removed[[kk]]
[17:42:22.815]                   NAME <- NAMES[[kk]]
[17:42:22.815]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.815]                     next
[17:42:22.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.815]                 }
[17:42:22.815]                 if (length(args) > 0) 
[17:42:22.815]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.815]             }
[17:42:22.815]             else {
[17:42:22.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.815]             }
[17:42:22.815]             {
[17:42:22.815]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.815]                   0L) {
[17:42:22.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.815]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.815]                   base::options(opts)
[17:42:22.815]                 }
[17:42:22.815]                 {
[17:42:22.815]                   {
[17:42:22.815]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.815]                     NULL
[17:42:22.815]                   }
[17:42:22.815]                   options(future.plan = NULL)
[17:42:22.815]                   if (is.na(NA_character_)) 
[17:42:22.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.815]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.815]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.815]                     envir = parent.frame()) 
[17:42:22.815]                   {
[17:42:22.815]                     if (is.function(workers)) 
[17:42:22.815]                       workers <- workers()
[17:42:22.815]                     workers <- structure(as.integer(workers), 
[17:42:22.815]                       class = class(workers))
[17:42:22.815]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.815]                       workers >= 1)
[17:42:22.815]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.815]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.815]                     }
[17:42:22.815]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.815]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.815]                       envir = envir)
[17:42:22.815]                     if (!future$lazy) 
[17:42:22.815]                       future <- run(future)
[17:42:22.815]                     invisible(future)
[17:42:22.815]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.815]                 }
[17:42:22.815]             }
[17:42:22.815]         }
[17:42:22.815]     })
[17:42:22.815]     if (TRUE) {
[17:42:22.815]         base::sink(type = "output", split = FALSE)
[17:42:22.815]         if (TRUE) {
[17:42:22.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.815]         }
[17:42:22.815]         else {
[17:42:22.815]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.815]         }
[17:42:22.815]         base::close(...future.stdout)
[17:42:22.815]         ...future.stdout <- NULL
[17:42:22.815]     }
[17:42:22.815]     ...future.result$conditions <- ...future.conditions
[17:42:22.815]     ...future.result$finished <- base::Sys.time()
[17:42:22.815]     ...future.result
[17:42:22.815] }
[17:42:22.817] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:22.828] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.828] - Validating connection of MultisessionFuture
[17:42:22.828] - received message: FutureResult
[17:42:22.828] - Received FutureResult
[17:42:22.829] - Erased future from FutureRegistry
[17:42:22.829] result() for ClusterFuture ...
[17:42:22.829] - result already collected: FutureResult
[17:42:22.829] result() for ClusterFuture ... done
[17:42:22.829] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.829] result() for ClusterFuture ...
[17:42:22.829] - result already collected: FutureResult
[17:42:22.829] result() for ClusterFuture ... done
[17:42:22.829] result() for ClusterFuture ...
[17:42:22.829] - result already collected: FutureResult
[17:42:22.830] result() for ClusterFuture ... done
[17:42:22.830] MultisessionFuture started
[17:42:22.831] - Launch lazy future ... done
[17:42:22.831] run() for ‘MultisessionFuture’ ... done
<environment: 0x55bef7debb98> 
<environment: 0x55bef9415fb8> 
[17:42:22.840] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.840] - Validating connection of MultisessionFuture
[17:42:22.841] - received message: FutureResult
[17:42:22.841] - Received FutureResult
[17:42:22.841] - Erased future from FutureRegistry
[17:42:22.841] result() for ClusterFuture ...
[17:42:22.841] - result already collected: FutureResult
[17:42:22.841] result() for ClusterFuture ... done
[17:42:22.841] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:22.853] resolve() on environment ...
[17:42:22.853]  recursive: 0
[17:42:22.854]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:22.854] signalConditionsASAP(numeric, pos=1) ...
[17:42:22.854] - nx: 4
[17:42:22.854] - relay: TRUE
[17:42:22.854] - stdout: TRUE
[17:42:22.854] - signal: TRUE
[17:42:22.854] - resignal: FALSE
[17:42:22.854] - force: TRUE
[17:42:22.854] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.854] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.855]  - until=2
[17:42:22.855]  - relaying element #2
[17:42:22.855] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.855] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.855] signalConditionsASAP(NULL, pos=1) ... done
[17:42:22.855]  length: 3 (resolved future 1)
[17:42:22.855] Future #2
[17:42:22.855] result() for ClusterFuture ...
[17:42:22.855] - result already collected: FutureResult
[17:42:22.855] result() for ClusterFuture ... done
[17:42:22.856] result() for ClusterFuture ...
[17:42:22.856] - result already collected: FutureResult
[17:42:22.856] result() for ClusterFuture ... done
[17:42:22.856] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:22.856] - nx: 4
[17:42:22.856] - relay: TRUE
[17:42:22.856] - stdout: TRUE
[17:42:22.856] - signal: TRUE
[17:42:22.856] - resignal: FALSE
[17:42:22.856] - force: TRUE
[17:42:22.856] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.857] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.857]  - until=2
[17:42:22.857]  - relaying element #2
[17:42:22.857] result() for ClusterFuture ...
[17:42:22.857] - result already collected: FutureResult
[17:42:22.857] result() for ClusterFuture ... done
[17:42:22.857] result() for ClusterFuture ...
[17:42:22.857] - result already collected: FutureResult
[17:42:22.857] result() for ClusterFuture ... done
[17:42:22.857] result() for ClusterFuture ...
[17:42:22.857] - result already collected: FutureResult
[17:42:22.858] result() for ClusterFuture ... done
[17:42:22.858] result() for ClusterFuture ...
[17:42:22.858] - result already collected: FutureResult
[17:42:22.858] result() for ClusterFuture ... done
[17:42:22.858] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:22.858] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:22.858] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:22.858]  length: 2 (resolved future 2)
[17:42:22.858] Future #3
[17:42:22.858] result() for ClusterFuture ...
[17:42:22.858] - result already collected: FutureResult
[17:42:22.859] result() for ClusterFuture ... done
[17:42:22.859] result() for ClusterFuture ...
[17:42:22.859] - result already collected: FutureResult
[17:42:22.859] result() for ClusterFuture ... done
[17:42:22.859] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:22.859] - nx: 4
[17:42:22.859] - relay: TRUE
[17:42:22.859] - stdout: TRUE
[17:42:22.859] - signal: TRUE
[17:42:22.859] - resignal: FALSE
[17:42:22.859] - force: TRUE
[17:42:22.860] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:22.860] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:22.860]  - until=3
[17:42:22.860]  - relaying element #3
[17:42:22.860] result() for ClusterFuture ...
[17:42:22.860] - result already collected: FutureResult
[17:42:22.860] result() for ClusterFuture ... done
[17:42:22.860] result() for ClusterFuture ...
[17:42:22.860] - result already collected: FutureResult
[17:42:22.860] result() for ClusterFuture ... done
[17:42:22.860] result() for ClusterFuture ...
[17:42:22.861] - result already collected: FutureResult
[17:42:22.861] result() for ClusterFuture ... done
[17:42:22.861] result() for ClusterFuture ...
[17:42:22.861] - result already collected: FutureResult
[17:42:22.861] result() for ClusterFuture ... done
[17:42:22.861] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:22.861] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:22.861] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:22.861]  length: 1 (resolved future 3)
[17:42:22.882] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.883] - Validating connection of MultisessionFuture
[17:42:22.883] - received message: FutureResult
[17:42:22.883] - Received FutureResult
[17:42:22.883] - Erased future from FutureRegistry
[17:42:22.883] result() for ClusterFuture ...
[17:42:22.883] - result already collected: FutureResult
[17:42:22.883] result() for ClusterFuture ... done
[17:42:22.883] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.884] Future #4
[17:42:22.884] result() for ClusterFuture ...
[17:42:22.884] - result already collected: FutureResult
[17:42:22.884] result() for ClusterFuture ... done
[17:42:22.884] result() for ClusterFuture ...
[17:42:22.884] - result already collected: FutureResult
[17:42:22.884] result() for ClusterFuture ... done
[17:42:22.884] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:22.884] - nx: 4
[17:42:22.884] - relay: TRUE
[17:42:22.884] - stdout: TRUE
[17:42:22.884] - signal: TRUE
[17:42:22.885] - resignal: FALSE
[17:42:22.885] - force: TRUE
[17:42:22.885] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:22.885] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:22.885]  - until=4
[17:42:22.885]  - relaying element #4
[17:42:22.885] result() for ClusterFuture ...
[17:42:22.885] - result already collected: FutureResult
[17:42:22.885] result() for ClusterFuture ... done
[17:42:22.885] result() for ClusterFuture ...
[17:42:22.885] - result already collected: FutureResult
[17:42:22.886] result() for ClusterFuture ... done
[17:42:22.886] result() for ClusterFuture ...
[17:42:22.886] - result already collected: FutureResult
[17:42:22.886] result() for ClusterFuture ... done
[17:42:22.886] result() for ClusterFuture ...
[17:42:22.886] - result already collected: FutureResult
[17:42:22.886] result() for ClusterFuture ... done
[17:42:22.886] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.886] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:22.886] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:22.886]  length: 0 (resolved future 4)
[17:42:22.887] Relaying remaining futures
[17:42:22.887] signalConditionsASAP(NULL, pos=0) ...
[17:42:22.887] - nx: 4
[17:42:22.887] - relay: TRUE
[17:42:22.887] - stdout: TRUE
[17:42:22.887] - signal: TRUE
[17:42:22.887] - resignal: FALSE
[17:42:22.887] - force: TRUE
[17:42:22.887] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.887] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:22.887] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:22.888] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:22.888] signalConditionsASAP(NULL, pos=0) ... done
[17:42:22.888] resolve() on environment ... DONE
[17:42:22.888] result() for ClusterFuture ...
[17:42:22.888] - result already collected: FutureResult
[17:42:22.888] result() for ClusterFuture ... done
[17:42:22.888] result() for ClusterFuture ...
[17:42:22.888] - result already collected: FutureResult
[17:42:22.888] result() for ClusterFuture ... done
[17:42:22.888] result() for ClusterFuture ...
[17:42:22.888] - result already collected: FutureResult
[17:42:22.889] result() for ClusterFuture ... done
[17:42:22.889] result() for ClusterFuture ...
[17:42:22.889] - result already collected: FutureResult
[17:42:22.889] result() for ClusterFuture ... done
[17:42:22.889] result() for ClusterFuture ...
[17:42:22.889] - result already collected: FutureResult
[17:42:22.889] result() for ClusterFuture ... done
[17:42:22.889] result() for ClusterFuture ...
[17:42:22.889] - result already collected: FutureResult
[17:42:22.889] result() for ClusterFuture ... done
<environment: 0x55bef9612838> 
Dimensions: c(2, 3, 1)
[17:42:22.890] getGlobalsAndPackages() ...
[17:42:22.890] Searching for globals...
[17:42:22.890] 
[17:42:22.890] Searching for globals ... DONE
[17:42:22.890] - globals: [0] <none>
[17:42:22.890] getGlobalsAndPackages() ... DONE
[17:42:22.891] run() for ‘Future’ ...
[17:42:22.891] - state: ‘created’
[17:42:22.891] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.905]   - Field: ‘node’
[17:42:22.906]   - Field: ‘label’
[17:42:22.906]   - Field: ‘local’
[17:42:22.906]   - Field: ‘owner’
[17:42:22.906]   - Field: ‘envir’
[17:42:22.906]   - Field: ‘workers’
[17:42:22.906]   - Field: ‘packages’
[17:42:22.906]   - Field: ‘gc’
[17:42:22.906]   - Field: ‘conditions’
[17:42:22.906]   - Field: ‘persistent’
[17:42:22.906]   - Field: ‘expr’
[17:42:22.907]   - Field: ‘uuid’
[17:42:22.907]   - Field: ‘seed’
[17:42:22.907]   - Field: ‘version’
[17:42:22.909]   - Field: ‘result’
[17:42:22.909]   - Field: ‘asynchronous’
[17:42:22.909]   - Field: ‘calls’
[17:42:22.909]   - Field: ‘globals’
[17:42:22.909]   - Field: ‘stdout’
[17:42:22.910]   - Field: ‘earlySignal’
[17:42:22.910]   - Field: ‘lazy’
[17:42:22.910]   - Field: ‘state’
[17:42:22.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.910] - Launch lazy future ...
[17:42:22.910] Packages needed by the future expression (n = 0): <none>
[17:42:22.910] Packages needed by future strategies (n = 0): <none>
[17:42:22.911] {
[17:42:22.911]     {
[17:42:22.911]         {
[17:42:22.911]             ...future.startTime <- base::Sys.time()
[17:42:22.911]             {
[17:42:22.911]                 {
[17:42:22.911]                   {
[17:42:22.911]                     {
[17:42:22.911]                       base::local({
[17:42:22.911]                         has_future <- base::requireNamespace("future", 
[17:42:22.911]                           quietly = TRUE)
[17:42:22.911]                         if (has_future) {
[17:42:22.911]                           ns <- base::getNamespace("future")
[17:42:22.911]                           version <- ns[[".package"]][["version"]]
[17:42:22.911]                           if (is.null(version)) 
[17:42:22.911]                             version <- utils::packageVersion("future")
[17:42:22.911]                         }
[17:42:22.911]                         else {
[17:42:22.911]                           version <- NULL
[17:42:22.911]                         }
[17:42:22.911]                         if (!has_future || version < "1.8.0") {
[17:42:22.911]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.911]                             "", base::R.version$version.string), 
[17:42:22.911]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.911]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.911]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.911]                               "release", "version")], collapse = " "), 
[17:42:22.911]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.911]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.911]                             info)
[17:42:22.911]                           info <- base::paste(info, collapse = "; ")
[17:42:22.911]                           if (!has_future) {
[17:42:22.911]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.911]                               info)
[17:42:22.911]                           }
[17:42:22.911]                           else {
[17:42:22.911]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.911]                               info, version)
[17:42:22.911]                           }
[17:42:22.911]                           base::stop(msg)
[17:42:22.911]                         }
[17:42:22.911]                       })
[17:42:22.911]                     }
[17:42:22.911]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.911]                     base::options(mc.cores = 1L)
[17:42:22.911]                   }
[17:42:22.911]                   options(future.plan = NULL)
[17:42:22.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.911]                 }
[17:42:22.911]                 ...future.workdir <- getwd()
[17:42:22.911]             }
[17:42:22.911]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.911]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.911]         }
[17:42:22.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.911]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.911]             base::names(...future.oldOptions))
[17:42:22.911]     }
[17:42:22.911]     if (FALSE) {
[17:42:22.911]     }
[17:42:22.911]     else {
[17:42:22.911]         if (TRUE) {
[17:42:22.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.911]                 open = "w")
[17:42:22.911]         }
[17:42:22.911]         else {
[17:42:22.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.911]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.911]         }
[17:42:22.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.911]             base::sink(type = "output", split = FALSE)
[17:42:22.911]             base::close(...future.stdout)
[17:42:22.911]         }, add = TRUE)
[17:42:22.911]     }
[17:42:22.911]     ...future.frame <- base::sys.nframe()
[17:42:22.911]     ...future.conditions <- base::list()
[17:42:22.911]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.911]     if (FALSE) {
[17:42:22.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.911]     }
[17:42:22.911]     ...future.result <- base::tryCatch({
[17:42:22.911]         base::withCallingHandlers({
[17:42:22.911]             ...future.value <- base::withVisible(base::local({
[17:42:22.911]                 ...future.makeSendCondition <- local({
[17:42:22.911]                   sendCondition <- NULL
[17:42:22.911]                   function(frame = 1L) {
[17:42:22.911]                     if (is.function(sendCondition)) 
[17:42:22.911]                       return(sendCondition)
[17:42:22.911]                     ns <- getNamespace("parallel")
[17:42:22.911]                     if (exists("sendData", mode = "function", 
[17:42:22.911]                       envir = ns)) {
[17:42:22.911]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.911]                         envir = ns)
[17:42:22.911]                       envir <- sys.frame(frame)
[17:42:22.911]                       master <- NULL
[17:42:22.911]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.911]                         !identical(envir, emptyenv())) {
[17:42:22.911]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.911]                           inherits = FALSE)) {
[17:42:22.911]                           master <- get("master", mode = "list", 
[17:42:22.911]                             envir = envir, inherits = FALSE)
[17:42:22.911]                           if (inherits(master, c("SOCKnode", 
[17:42:22.911]                             "SOCK0node"))) {
[17:42:22.911]                             sendCondition <<- function(cond) {
[17:42:22.911]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.911]                                 success = TRUE)
[17:42:22.911]                               parallel_sendData(master, data)
[17:42:22.911]                             }
[17:42:22.911]                             return(sendCondition)
[17:42:22.911]                           }
[17:42:22.911]                         }
[17:42:22.911]                         frame <- frame + 1L
[17:42:22.911]                         envir <- sys.frame(frame)
[17:42:22.911]                       }
[17:42:22.911]                     }
[17:42:22.911]                     sendCondition <<- function(cond) NULL
[17:42:22.911]                   }
[17:42:22.911]                 })
[17:42:22.911]                 withCallingHandlers({
[17:42:22.911]                   2
[17:42:22.911]                 }, immediateCondition = function(cond) {
[17:42:22.911]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.911]                   sendCondition(cond)
[17:42:22.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.911]                   {
[17:42:22.911]                     inherits <- base::inherits
[17:42:22.911]                     invokeRestart <- base::invokeRestart
[17:42:22.911]                     is.null <- base::is.null
[17:42:22.911]                     muffled <- FALSE
[17:42:22.911]                     if (inherits(cond, "message")) {
[17:42:22.911]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.911]                       if (muffled) 
[17:42:22.911]                         invokeRestart("muffleMessage")
[17:42:22.911]                     }
[17:42:22.911]                     else if (inherits(cond, "warning")) {
[17:42:22.911]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.911]                       if (muffled) 
[17:42:22.911]                         invokeRestart("muffleWarning")
[17:42:22.911]                     }
[17:42:22.911]                     else if (inherits(cond, "condition")) {
[17:42:22.911]                       if (!is.null(pattern)) {
[17:42:22.911]                         computeRestarts <- base::computeRestarts
[17:42:22.911]                         grepl <- base::grepl
[17:42:22.911]                         restarts <- computeRestarts(cond)
[17:42:22.911]                         for (restart in restarts) {
[17:42:22.911]                           name <- restart$name
[17:42:22.911]                           if (is.null(name)) 
[17:42:22.911]                             next
[17:42:22.911]                           if (!grepl(pattern, name)) 
[17:42:22.911]                             next
[17:42:22.911]                           invokeRestart(restart)
[17:42:22.911]                           muffled <- TRUE
[17:42:22.911]                           break
[17:42:22.911]                         }
[17:42:22.911]                       }
[17:42:22.911]                     }
[17:42:22.911]                     invisible(muffled)
[17:42:22.911]                   }
[17:42:22.911]                   muffleCondition(cond)
[17:42:22.911]                 })
[17:42:22.911]             }))
[17:42:22.911]             future::FutureResult(value = ...future.value$value, 
[17:42:22.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.911]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.911]                     ...future.globalenv.names))
[17:42:22.911]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.911]         }, condition = base::local({
[17:42:22.911]             c <- base::c
[17:42:22.911]             inherits <- base::inherits
[17:42:22.911]             invokeRestart <- base::invokeRestart
[17:42:22.911]             length <- base::length
[17:42:22.911]             list <- base::list
[17:42:22.911]             seq.int <- base::seq.int
[17:42:22.911]             signalCondition <- base::signalCondition
[17:42:22.911]             sys.calls <- base::sys.calls
[17:42:22.911]             `[[` <- base::`[[`
[17:42:22.911]             `+` <- base::`+`
[17:42:22.911]             `<<-` <- base::`<<-`
[17:42:22.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.911]                   3L)]
[17:42:22.911]             }
[17:42:22.911]             function(cond) {
[17:42:22.911]                 is_error <- inherits(cond, "error")
[17:42:22.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.911]                   NULL)
[17:42:22.911]                 if (is_error) {
[17:42:22.911]                   sessionInformation <- function() {
[17:42:22.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.911]                       search = base::search(), system = base::Sys.info())
[17:42:22.911]                   }
[17:42:22.911]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.911]                     cond$call), session = sessionInformation(), 
[17:42:22.911]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.911]                   signalCondition(cond)
[17:42:22.911]                 }
[17:42:22.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.911]                 "immediateCondition"))) {
[17:42:22.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.911]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.911]                   if (TRUE && !signal) {
[17:42:22.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.911]                     {
[17:42:22.911]                       inherits <- base::inherits
[17:42:22.911]                       invokeRestart <- base::invokeRestart
[17:42:22.911]                       is.null <- base::is.null
[17:42:22.911]                       muffled <- FALSE
[17:42:22.911]                       if (inherits(cond, "message")) {
[17:42:22.911]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.911]                         if (muffled) 
[17:42:22.911]                           invokeRestart("muffleMessage")
[17:42:22.911]                       }
[17:42:22.911]                       else if (inherits(cond, "warning")) {
[17:42:22.911]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.911]                         if (muffled) 
[17:42:22.911]                           invokeRestart("muffleWarning")
[17:42:22.911]                       }
[17:42:22.911]                       else if (inherits(cond, "condition")) {
[17:42:22.911]                         if (!is.null(pattern)) {
[17:42:22.911]                           computeRestarts <- base::computeRestarts
[17:42:22.911]                           grepl <- base::grepl
[17:42:22.911]                           restarts <- computeRestarts(cond)
[17:42:22.911]                           for (restart in restarts) {
[17:42:22.911]                             name <- restart$name
[17:42:22.911]                             if (is.null(name)) 
[17:42:22.911]                               next
[17:42:22.911]                             if (!grepl(pattern, name)) 
[17:42:22.911]                               next
[17:42:22.911]                             invokeRestart(restart)
[17:42:22.911]                             muffled <- TRUE
[17:42:22.911]                             break
[17:42:22.911]                           }
[17:42:22.911]                         }
[17:42:22.911]                       }
[17:42:22.911]                       invisible(muffled)
[17:42:22.911]                     }
[17:42:22.911]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.911]                   }
[17:42:22.911]                 }
[17:42:22.911]                 else {
[17:42:22.911]                   if (TRUE) {
[17:42:22.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.911]                     {
[17:42:22.911]                       inherits <- base::inherits
[17:42:22.911]                       invokeRestart <- base::invokeRestart
[17:42:22.911]                       is.null <- base::is.null
[17:42:22.911]                       muffled <- FALSE
[17:42:22.911]                       if (inherits(cond, "message")) {
[17:42:22.911]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.911]                         if (muffled) 
[17:42:22.911]                           invokeRestart("muffleMessage")
[17:42:22.911]                       }
[17:42:22.911]                       else if (inherits(cond, "warning")) {
[17:42:22.911]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.911]                         if (muffled) 
[17:42:22.911]                           invokeRestart("muffleWarning")
[17:42:22.911]                       }
[17:42:22.911]                       else if (inherits(cond, "condition")) {
[17:42:22.911]                         if (!is.null(pattern)) {
[17:42:22.911]                           computeRestarts <- base::computeRestarts
[17:42:22.911]                           grepl <- base::grepl
[17:42:22.911]                           restarts <- computeRestarts(cond)
[17:42:22.911]                           for (restart in restarts) {
[17:42:22.911]                             name <- restart$name
[17:42:22.911]                             if (is.null(name)) 
[17:42:22.911]                               next
[17:42:22.911]                             if (!grepl(pattern, name)) 
[17:42:22.911]                               next
[17:42:22.911]                             invokeRestart(restart)
[17:42:22.911]                             muffled <- TRUE
[17:42:22.911]                             break
[17:42:22.911]                           }
[17:42:22.911]                         }
[17:42:22.911]                       }
[17:42:22.911]                       invisible(muffled)
[17:42:22.911]                     }
[17:42:22.911]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.911]                   }
[17:42:22.911]                 }
[17:42:22.911]             }
[17:42:22.911]         }))
[17:42:22.911]     }, error = function(ex) {
[17:42:22.911]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.911]                 ...future.rng), started = ...future.startTime, 
[17:42:22.911]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.911]             version = "1.8"), class = "FutureResult")
[17:42:22.911]     }, finally = {
[17:42:22.911]         if (!identical(...future.workdir, getwd())) 
[17:42:22.911]             setwd(...future.workdir)
[17:42:22.911]         {
[17:42:22.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.911]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.911]             }
[17:42:22.911]             base::options(...future.oldOptions)
[17:42:22.911]             if (.Platform$OS.type == "windows") {
[17:42:22.911]                 old_names <- names(...future.oldEnvVars)
[17:42:22.911]                 envs <- base::Sys.getenv()
[17:42:22.911]                 names <- names(envs)
[17:42:22.911]                 common <- intersect(names, old_names)
[17:42:22.911]                 added <- setdiff(names, old_names)
[17:42:22.911]                 removed <- setdiff(old_names, names)
[17:42:22.911]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.911]                   envs[common]]
[17:42:22.911]                 NAMES <- toupper(changed)
[17:42:22.911]                 args <- list()
[17:42:22.911]                 for (kk in seq_along(NAMES)) {
[17:42:22.911]                   name <- changed[[kk]]
[17:42:22.911]                   NAME <- NAMES[[kk]]
[17:42:22.911]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.911]                     next
[17:42:22.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.911]                 }
[17:42:22.911]                 NAMES <- toupper(added)
[17:42:22.911]                 for (kk in seq_along(NAMES)) {
[17:42:22.911]                   name <- added[[kk]]
[17:42:22.911]                   NAME <- NAMES[[kk]]
[17:42:22.911]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.911]                     next
[17:42:22.911]                   args[[name]] <- ""
[17:42:22.911]                 }
[17:42:22.911]                 NAMES <- toupper(removed)
[17:42:22.911]                 for (kk in seq_along(NAMES)) {
[17:42:22.911]                   name <- removed[[kk]]
[17:42:22.911]                   NAME <- NAMES[[kk]]
[17:42:22.911]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.911]                     next
[17:42:22.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.911]                 }
[17:42:22.911]                 if (length(args) > 0) 
[17:42:22.911]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.911]             }
[17:42:22.911]             else {
[17:42:22.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.911]             }
[17:42:22.911]             {
[17:42:22.911]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.911]                   0L) {
[17:42:22.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.911]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.911]                   base::options(opts)
[17:42:22.911]                 }
[17:42:22.911]                 {
[17:42:22.911]                   {
[17:42:22.911]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.911]                     NULL
[17:42:22.911]                   }
[17:42:22.911]                   options(future.plan = NULL)
[17:42:22.911]                   if (is.na(NA_character_)) 
[17:42:22.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.911]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.911]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.911]                     envir = parent.frame()) 
[17:42:22.911]                   {
[17:42:22.911]                     if (is.function(workers)) 
[17:42:22.911]                       workers <- workers()
[17:42:22.911]                     workers <- structure(as.integer(workers), 
[17:42:22.911]                       class = class(workers))
[17:42:22.911]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.911]                       workers >= 1)
[17:42:22.911]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.911]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.911]                     }
[17:42:22.911]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.911]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.911]                       envir = envir)
[17:42:22.911]                     if (!future$lazy) 
[17:42:22.911]                       future <- run(future)
[17:42:22.911]                     invisible(future)
[17:42:22.911]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.911]                 }
[17:42:22.911]             }
[17:42:22.911]         }
[17:42:22.911]     })
[17:42:22.911]     if (TRUE) {
[17:42:22.911]         base::sink(type = "output", split = FALSE)
[17:42:22.911]         if (TRUE) {
[17:42:22.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.911]         }
[17:42:22.911]         else {
[17:42:22.911]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.911]         }
[17:42:22.911]         base::close(...future.stdout)
[17:42:22.911]         ...future.stdout <- NULL
[17:42:22.911]     }
[17:42:22.911]     ...future.result$conditions <- ...future.conditions
[17:42:22.911]     ...future.result$finished <- base::Sys.time()
[17:42:22.911]     ...future.result
[17:42:22.911] }
[17:42:22.914] MultisessionFuture started
[17:42:22.914] - Launch lazy future ... done
[17:42:22.914] run() for ‘MultisessionFuture’ ... done
[17:42:22.914] getGlobalsAndPackages() ...
[17:42:22.914] Searching for globals...
[17:42:22.915] 
[17:42:22.915] Searching for globals ... DONE
[17:42:22.915] - globals: [0] <none>
[17:42:22.915] getGlobalsAndPackages() ... DONE
[17:42:22.915] run() for ‘Future’ ...
[17:42:22.915] - state: ‘created’
[17:42:22.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.930] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.930]   - Field: ‘node’
[17:42:22.930]   - Field: ‘label’
[17:42:22.930]   - Field: ‘local’
[17:42:22.930]   - Field: ‘owner’
[17:42:22.930]   - Field: ‘envir’
[17:42:22.930]   - Field: ‘workers’
[17:42:22.931]   - Field: ‘packages’
[17:42:22.931]   - Field: ‘gc’
[17:42:22.931]   - Field: ‘conditions’
[17:42:22.931]   - Field: ‘persistent’
[17:42:22.931]   - Field: ‘expr’
[17:42:22.931]   - Field: ‘uuid’
[17:42:22.931]   - Field: ‘seed’
[17:42:22.931]   - Field: ‘version’
[17:42:22.931]   - Field: ‘result’
[17:42:22.931]   - Field: ‘asynchronous’
[17:42:22.932]   - Field: ‘calls’
[17:42:22.932]   - Field: ‘globals’
[17:42:22.932]   - Field: ‘stdout’
[17:42:22.932]   - Field: ‘earlySignal’
[17:42:22.932]   - Field: ‘lazy’
[17:42:22.932]   - Field: ‘state’
[17:42:22.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.932] - Launch lazy future ...
[17:42:22.932] Packages needed by the future expression (n = 0): <none>
[17:42:22.933] Packages needed by future strategies (n = 0): <none>
[17:42:22.933] {
[17:42:22.933]     {
[17:42:22.933]         {
[17:42:22.933]             ...future.startTime <- base::Sys.time()
[17:42:22.933]             {
[17:42:22.933]                 {
[17:42:22.933]                   {
[17:42:22.933]                     {
[17:42:22.933]                       base::local({
[17:42:22.933]                         has_future <- base::requireNamespace("future", 
[17:42:22.933]                           quietly = TRUE)
[17:42:22.933]                         if (has_future) {
[17:42:22.933]                           ns <- base::getNamespace("future")
[17:42:22.933]                           version <- ns[[".package"]][["version"]]
[17:42:22.933]                           if (is.null(version)) 
[17:42:22.933]                             version <- utils::packageVersion("future")
[17:42:22.933]                         }
[17:42:22.933]                         else {
[17:42:22.933]                           version <- NULL
[17:42:22.933]                         }
[17:42:22.933]                         if (!has_future || version < "1.8.0") {
[17:42:22.933]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.933]                             "", base::R.version$version.string), 
[17:42:22.933]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.933]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.933]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.933]                               "release", "version")], collapse = " "), 
[17:42:22.933]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.933]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.933]                             info)
[17:42:22.933]                           info <- base::paste(info, collapse = "; ")
[17:42:22.933]                           if (!has_future) {
[17:42:22.933]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.933]                               info)
[17:42:22.933]                           }
[17:42:22.933]                           else {
[17:42:22.933]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.933]                               info, version)
[17:42:22.933]                           }
[17:42:22.933]                           base::stop(msg)
[17:42:22.933]                         }
[17:42:22.933]                       })
[17:42:22.933]                     }
[17:42:22.933]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.933]                     base::options(mc.cores = 1L)
[17:42:22.933]                   }
[17:42:22.933]                   options(future.plan = NULL)
[17:42:22.933]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.933]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.933]                 }
[17:42:22.933]                 ...future.workdir <- getwd()
[17:42:22.933]             }
[17:42:22.933]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.933]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.933]         }
[17:42:22.933]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.933]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.933]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.933]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.933]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.933]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.933]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.933]             base::names(...future.oldOptions))
[17:42:22.933]     }
[17:42:22.933]     if (FALSE) {
[17:42:22.933]     }
[17:42:22.933]     else {
[17:42:22.933]         if (TRUE) {
[17:42:22.933]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.933]                 open = "w")
[17:42:22.933]         }
[17:42:22.933]         else {
[17:42:22.933]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.933]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.933]         }
[17:42:22.933]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.933]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.933]             base::sink(type = "output", split = FALSE)
[17:42:22.933]             base::close(...future.stdout)
[17:42:22.933]         }, add = TRUE)
[17:42:22.933]     }
[17:42:22.933]     ...future.frame <- base::sys.nframe()
[17:42:22.933]     ...future.conditions <- base::list()
[17:42:22.933]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.933]     if (FALSE) {
[17:42:22.933]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.933]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.933]     }
[17:42:22.933]     ...future.result <- base::tryCatch({
[17:42:22.933]         base::withCallingHandlers({
[17:42:22.933]             ...future.value <- base::withVisible(base::local({
[17:42:22.933]                 ...future.makeSendCondition <- local({
[17:42:22.933]                   sendCondition <- NULL
[17:42:22.933]                   function(frame = 1L) {
[17:42:22.933]                     if (is.function(sendCondition)) 
[17:42:22.933]                       return(sendCondition)
[17:42:22.933]                     ns <- getNamespace("parallel")
[17:42:22.933]                     if (exists("sendData", mode = "function", 
[17:42:22.933]                       envir = ns)) {
[17:42:22.933]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.933]                         envir = ns)
[17:42:22.933]                       envir <- sys.frame(frame)
[17:42:22.933]                       master <- NULL
[17:42:22.933]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.933]                         !identical(envir, emptyenv())) {
[17:42:22.933]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.933]                           inherits = FALSE)) {
[17:42:22.933]                           master <- get("master", mode = "list", 
[17:42:22.933]                             envir = envir, inherits = FALSE)
[17:42:22.933]                           if (inherits(master, c("SOCKnode", 
[17:42:22.933]                             "SOCK0node"))) {
[17:42:22.933]                             sendCondition <<- function(cond) {
[17:42:22.933]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.933]                                 success = TRUE)
[17:42:22.933]                               parallel_sendData(master, data)
[17:42:22.933]                             }
[17:42:22.933]                             return(sendCondition)
[17:42:22.933]                           }
[17:42:22.933]                         }
[17:42:22.933]                         frame <- frame + 1L
[17:42:22.933]                         envir <- sys.frame(frame)
[17:42:22.933]                       }
[17:42:22.933]                     }
[17:42:22.933]                     sendCondition <<- function(cond) NULL
[17:42:22.933]                   }
[17:42:22.933]                 })
[17:42:22.933]                 withCallingHandlers({
[17:42:22.933]                   NULL
[17:42:22.933]                 }, immediateCondition = function(cond) {
[17:42:22.933]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.933]                   sendCondition(cond)
[17:42:22.933]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.933]                   {
[17:42:22.933]                     inherits <- base::inherits
[17:42:22.933]                     invokeRestart <- base::invokeRestart
[17:42:22.933]                     is.null <- base::is.null
[17:42:22.933]                     muffled <- FALSE
[17:42:22.933]                     if (inherits(cond, "message")) {
[17:42:22.933]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.933]                       if (muffled) 
[17:42:22.933]                         invokeRestart("muffleMessage")
[17:42:22.933]                     }
[17:42:22.933]                     else if (inherits(cond, "warning")) {
[17:42:22.933]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.933]                       if (muffled) 
[17:42:22.933]                         invokeRestart("muffleWarning")
[17:42:22.933]                     }
[17:42:22.933]                     else if (inherits(cond, "condition")) {
[17:42:22.933]                       if (!is.null(pattern)) {
[17:42:22.933]                         computeRestarts <- base::computeRestarts
[17:42:22.933]                         grepl <- base::grepl
[17:42:22.933]                         restarts <- computeRestarts(cond)
[17:42:22.933]                         for (restart in restarts) {
[17:42:22.933]                           name <- restart$name
[17:42:22.933]                           if (is.null(name)) 
[17:42:22.933]                             next
[17:42:22.933]                           if (!grepl(pattern, name)) 
[17:42:22.933]                             next
[17:42:22.933]                           invokeRestart(restart)
[17:42:22.933]                           muffled <- TRUE
[17:42:22.933]                           break
[17:42:22.933]                         }
[17:42:22.933]                       }
[17:42:22.933]                     }
[17:42:22.933]                     invisible(muffled)
[17:42:22.933]                   }
[17:42:22.933]                   muffleCondition(cond)
[17:42:22.933]                 })
[17:42:22.933]             }))
[17:42:22.933]             future::FutureResult(value = ...future.value$value, 
[17:42:22.933]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.933]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.933]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.933]                     ...future.globalenv.names))
[17:42:22.933]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.933]         }, condition = base::local({
[17:42:22.933]             c <- base::c
[17:42:22.933]             inherits <- base::inherits
[17:42:22.933]             invokeRestart <- base::invokeRestart
[17:42:22.933]             length <- base::length
[17:42:22.933]             list <- base::list
[17:42:22.933]             seq.int <- base::seq.int
[17:42:22.933]             signalCondition <- base::signalCondition
[17:42:22.933]             sys.calls <- base::sys.calls
[17:42:22.933]             `[[` <- base::`[[`
[17:42:22.933]             `+` <- base::`+`
[17:42:22.933]             `<<-` <- base::`<<-`
[17:42:22.933]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.933]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.933]                   3L)]
[17:42:22.933]             }
[17:42:22.933]             function(cond) {
[17:42:22.933]                 is_error <- inherits(cond, "error")
[17:42:22.933]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.933]                   NULL)
[17:42:22.933]                 if (is_error) {
[17:42:22.933]                   sessionInformation <- function() {
[17:42:22.933]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.933]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.933]                       search = base::search(), system = base::Sys.info())
[17:42:22.933]                   }
[17:42:22.933]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.933]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.933]                     cond$call), session = sessionInformation(), 
[17:42:22.933]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.933]                   signalCondition(cond)
[17:42:22.933]                 }
[17:42:22.933]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.933]                 "immediateCondition"))) {
[17:42:22.933]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.933]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.933]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.933]                   if (TRUE && !signal) {
[17:42:22.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.933]                     {
[17:42:22.933]                       inherits <- base::inherits
[17:42:22.933]                       invokeRestart <- base::invokeRestart
[17:42:22.933]                       is.null <- base::is.null
[17:42:22.933]                       muffled <- FALSE
[17:42:22.933]                       if (inherits(cond, "message")) {
[17:42:22.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.933]                         if (muffled) 
[17:42:22.933]                           invokeRestart("muffleMessage")
[17:42:22.933]                       }
[17:42:22.933]                       else if (inherits(cond, "warning")) {
[17:42:22.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.933]                         if (muffled) 
[17:42:22.933]                           invokeRestart("muffleWarning")
[17:42:22.933]                       }
[17:42:22.933]                       else if (inherits(cond, "condition")) {
[17:42:22.933]                         if (!is.null(pattern)) {
[17:42:22.933]                           computeRestarts <- base::computeRestarts
[17:42:22.933]                           grepl <- base::grepl
[17:42:22.933]                           restarts <- computeRestarts(cond)
[17:42:22.933]                           for (restart in restarts) {
[17:42:22.933]                             name <- restart$name
[17:42:22.933]                             if (is.null(name)) 
[17:42:22.933]                               next
[17:42:22.933]                             if (!grepl(pattern, name)) 
[17:42:22.933]                               next
[17:42:22.933]                             invokeRestart(restart)
[17:42:22.933]                             muffled <- TRUE
[17:42:22.933]                             break
[17:42:22.933]                           }
[17:42:22.933]                         }
[17:42:22.933]                       }
[17:42:22.933]                       invisible(muffled)
[17:42:22.933]                     }
[17:42:22.933]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.933]                   }
[17:42:22.933]                 }
[17:42:22.933]                 else {
[17:42:22.933]                   if (TRUE) {
[17:42:22.933]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.933]                     {
[17:42:22.933]                       inherits <- base::inherits
[17:42:22.933]                       invokeRestart <- base::invokeRestart
[17:42:22.933]                       is.null <- base::is.null
[17:42:22.933]                       muffled <- FALSE
[17:42:22.933]                       if (inherits(cond, "message")) {
[17:42:22.933]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.933]                         if (muffled) 
[17:42:22.933]                           invokeRestart("muffleMessage")
[17:42:22.933]                       }
[17:42:22.933]                       else if (inherits(cond, "warning")) {
[17:42:22.933]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.933]                         if (muffled) 
[17:42:22.933]                           invokeRestart("muffleWarning")
[17:42:22.933]                       }
[17:42:22.933]                       else if (inherits(cond, "condition")) {
[17:42:22.933]                         if (!is.null(pattern)) {
[17:42:22.933]                           computeRestarts <- base::computeRestarts
[17:42:22.933]                           grepl <- base::grepl
[17:42:22.933]                           restarts <- computeRestarts(cond)
[17:42:22.933]                           for (restart in restarts) {
[17:42:22.933]                             name <- restart$name
[17:42:22.933]                             if (is.null(name)) 
[17:42:22.933]                               next
[17:42:22.933]                             if (!grepl(pattern, name)) 
[17:42:22.933]                               next
[17:42:22.933]                             invokeRestart(restart)
[17:42:22.933]                             muffled <- TRUE
[17:42:22.933]                             break
[17:42:22.933]                           }
[17:42:22.933]                         }
[17:42:22.933]                       }
[17:42:22.933]                       invisible(muffled)
[17:42:22.933]                     }
[17:42:22.933]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.933]                   }
[17:42:22.933]                 }
[17:42:22.933]             }
[17:42:22.933]         }))
[17:42:22.933]     }, error = function(ex) {
[17:42:22.933]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.933]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.933]                 ...future.rng), started = ...future.startTime, 
[17:42:22.933]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.933]             version = "1.8"), class = "FutureResult")
[17:42:22.933]     }, finally = {
[17:42:22.933]         if (!identical(...future.workdir, getwd())) 
[17:42:22.933]             setwd(...future.workdir)
[17:42:22.933]         {
[17:42:22.933]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.933]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.933]             }
[17:42:22.933]             base::options(...future.oldOptions)
[17:42:22.933]             if (.Platform$OS.type == "windows") {
[17:42:22.933]                 old_names <- names(...future.oldEnvVars)
[17:42:22.933]                 envs <- base::Sys.getenv()
[17:42:22.933]                 names <- names(envs)
[17:42:22.933]                 common <- intersect(names, old_names)
[17:42:22.933]                 added <- setdiff(names, old_names)
[17:42:22.933]                 removed <- setdiff(old_names, names)
[17:42:22.933]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.933]                   envs[common]]
[17:42:22.933]                 NAMES <- toupper(changed)
[17:42:22.933]                 args <- list()
[17:42:22.933]                 for (kk in seq_along(NAMES)) {
[17:42:22.933]                   name <- changed[[kk]]
[17:42:22.933]                   NAME <- NAMES[[kk]]
[17:42:22.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.933]                     next
[17:42:22.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.933]                 }
[17:42:22.933]                 NAMES <- toupper(added)
[17:42:22.933]                 for (kk in seq_along(NAMES)) {
[17:42:22.933]                   name <- added[[kk]]
[17:42:22.933]                   NAME <- NAMES[[kk]]
[17:42:22.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.933]                     next
[17:42:22.933]                   args[[name]] <- ""
[17:42:22.933]                 }
[17:42:22.933]                 NAMES <- toupper(removed)
[17:42:22.933]                 for (kk in seq_along(NAMES)) {
[17:42:22.933]                   name <- removed[[kk]]
[17:42:22.933]                   NAME <- NAMES[[kk]]
[17:42:22.933]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.933]                     next
[17:42:22.933]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.933]                 }
[17:42:22.933]                 if (length(args) > 0) 
[17:42:22.933]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.933]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.933]             }
[17:42:22.933]             else {
[17:42:22.933]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.933]             }
[17:42:22.933]             {
[17:42:22.933]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.933]                   0L) {
[17:42:22.933]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.933]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.933]                   base::options(opts)
[17:42:22.933]                 }
[17:42:22.933]                 {
[17:42:22.933]                   {
[17:42:22.933]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.933]                     NULL
[17:42:22.933]                   }
[17:42:22.933]                   options(future.plan = NULL)
[17:42:22.933]                   if (is.na(NA_character_)) 
[17:42:22.933]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.933]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.933]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.933]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.933]                     envir = parent.frame()) 
[17:42:22.933]                   {
[17:42:22.933]                     if (is.function(workers)) 
[17:42:22.933]                       workers <- workers()
[17:42:22.933]                     workers <- structure(as.integer(workers), 
[17:42:22.933]                       class = class(workers))
[17:42:22.933]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.933]                       workers >= 1)
[17:42:22.933]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.933]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.933]                     }
[17:42:22.933]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.933]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.933]                       envir = envir)
[17:42:22.933]                     if (!future$lazy) 
[17:42:22.933]                       future <- run(future)
[17:42:22.933]                     invisible(future)
[17:42:22.933]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.933]                 }
[17:42:22.933]             }
[17:42:22.933]         }
[17:42:22.933]     })
[17:42:22.933]     if (TRUE) {
[17:42:22.933]         base::sink(type = "output", split = FALSE)
[17:42:22.933]         if (TRUE) {
[17:42:22.933]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.933]         }
[17:42:22.933]         else {
[17:42:22.933]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.933]         }
[17:42:22.933]         base::close(...future.stdout)
[17:42:22.933]         ...future.stdout <- NULL
[17:42:22.933]     }
[17:42:22.933]     ...future.result$conditions <- ...future.conditions
[17:42:22.933]     ...future.result$finished <- base::Sys.time()
[17:42:22.933]     ...future.result
[17:42:22.933] }
[17:42:22.936] MultisessionFuture started
[17:42:22.936] - Launch lazy future ... done
[17:42:22.937] run() for ‘MultisessionFuture’ ... done
[17:42:22.937] getGlobalsAndPackages() ...
[17:42:22.937] Searching for globals...
[17:42:22.938] - globals found: [1] ‘{’
[17:42:22.938] Searching for globals ... DONE
[17:42:22.938] Resolving globals: FALSE
[17:42:22.938] 
[17:42:22.938] 
[17:42:22.938] getGlobalsAndPackages() ... DONE
[17:42:22.939] run() for ‘Future’ ...
[17:42:22.939] - state: ‘created’
[17:42:22.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:22.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:22.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:22.954]   - Field: ‘node’
[17:42:22.955]   - Field: ‘label’
[17:42:22.955]   - Field: ‘local’
[17:42:22.955]   - Field: ‘owner’
[17:42:22.955]   - Field: ‘envir’
[17:42:22.955]   - Field: ‘workers’
[17:42:22.955]   - Field: ‘packages’
[17:42:22.955]   - Field: ‘gc’
[17:42:22.955]   - Field: ‘conditions’
[17:42:22.955]   - Field: ‘persistent’
[17:42:22.955]   - Field: ‘expr’
[17:42:22.956]   - Field: ‘uuid’
[17:42:22.956]   - Field: ‘seed’
[17:42:22.956]   - Field: ‘version’
[17:42:22.956]   - Field: ‘result’
[17:42:22.956]   - Field: ‘asynchronous’
[17:42:22.956]   - Field: ‘calls’
[17:42:22.956]   - Field: ‘globals’
[17:42:22.956]   - Field: ‘stdout’
[17:42:22.956]   - Field: ‘earlySignal’
[17:42:22.956]   - Field: ‘lazy’
[17:42:22.956]   - Field: ‘state’
[17:42:22.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:22.957] - Launch lazy future ...
[17:42:22.957] Packages needed by the future expression (n = 0): <none>
[17:42:22.957] Packages needed by future strategies (n = 0): <none>
[17:42:22.958] {
[17:42:22.958]     {
[17:42:22.958]         {
[17:42:22.958]             ...future.startTime <- base::Sys.time()
[17:42:22.958]             {
[17:42:22.958]                 {
[17:42:22.958]                   {
[17:42:22.958]                     {
[17:42:22.958]                       base::local({
[17:42:22.958]                         has_future <- base::requireNamespace("future", 
[17:42:22.958]                           quietly = TRUE)
[17:42:22.958]                         if (has_future) {
[17:42:22.958]                           ns <- base::getNamespace("future")
[17:42:22.958]                           version <- ns[[".package"]][["version"]]
[17:42:22.958]                           if (is.null(version)) 
[17:42:22.958]                             version <- utils::packageVersion("future")
[17:42:22.958]                         }
[17:42:22.958]                         else {
[17:42:22.958]                           version <- NULL
[17:42:22.958]                         }
[17:42:22.958]                         if (!has_future || version < "1.8.0") {
[17:42:22.958]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:22.958]                             "", base::R.version$version.string), 
[17:42:22.958]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:22.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:22.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:22.958]                               "release", "version")], collapse = " "), 
[17:42:22.958]                             hostname = base::Sys.info()[["nodename"]])
[17:42:22.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:22.958]                             info)
[17:42:22.958]                           info <- base::paste(info, collapse = "; ")
[17:42:22.958]                           if (!has_future) {
[17:42:22.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:22.958]                               info)
[17:42:22.958]                           }
[17:42:22.958]                           else {
[17:42:22.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:22.958]                               info, version)
[17:42:22.958]                           }
[17:42:22.958]                           base::stop(msg)
[17:42:22.958]                         }
[17:42:22.958]                       })
[17:42:22.958]                     }
[17:42:22.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:22.958]                     base::options(mc.cores = 1L)
[17:42:22.958]                   }
[17:42:22.958]                   options(future.plan = NULL)
[17:42:22.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:22.958]                 }
[17:42:22.958]                 ...future.workdir <- getwd()
[17:42:22.958]             }
[17:42:22.958]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:22.958]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:22.958]         }
[17:42:22.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:22.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:22.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:22.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:22.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:22.958]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:22.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:22.958]             base::names(...future.oldOptions))
[17:42:22.958]     }
[17:42:22.958]     if (FALSE) {
[17:42:22.958]     }
[17:42:22.958]     else {
[17:42:22.958]         if (TRUE) {
[17:42:22.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:22.958]                 open = "w")
[17:42:22.958]         }
[17:42:22.958]         else {
[17:42:22.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:22.958]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:22.958]         }
[17:42:22.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:22.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:22.958]             base::sink(type = "output", split = FALSE)
[17:42:22.958]             base::close(...future.stdout)
[17:42:22.958]         }, add = TRUE)
[17:42:22.958]     }
[17:42:22.958]     ...future.frame <- base::sys.nframe()
[17:42:22.958]     ...future.conditions <- base::list()
[17:42:22.958]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:22.958]     if (FALSE) {
[17:42:22.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:22.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:22.958]     }
[17:42:22.958]     ...future.result <- base::tryCatch({
[17:42:22.958]         base::withCallingHandlers({
[17:42:22.958]             ...future.value <- base::withVisible(base::local({
[17:42:22.958]                 ...future.makeSendCondition <- local({
[17:42:22.958]                   sendCondition <- NULL
[17:42:22.958]                   function(frame = 1L) {
[17:42:22.958]                     if (is.function(sendCondition)) 
[17:42:22.958]                       return(sendCondition)
[17:42:22.958]                     ns <- getNamespace("parallel")
[17:42:22.958]                     if (exists("sendData", mode = "function", 
[17:42:22.958]                       envir = ns)) {
[17:42:22.958]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:22.958]                         envir = ns)
[17:42:22.958]                       envir <- sys.frame(frame)
[17:42:22.958]                       master <- NULL
[17:42:22.958]                       while (!identical(envir, .GlobalEnv) && 
[17:42:22.958]                         !identical(envir, emptyenv())) {
[17:42:22.958]                         if (exists("master", mode = "list", envir = envir, 
[17:42:22.958]                           inherits = FALSE)) {
[17:42:22.958]                           master <- get("master", mode = "list", 
[17:42:22.958]                             envir = envir, inherits = FALSE)
[17:42:22.958]                           if (inherits(master, c("SOCKnode", 
[17:42:22.958]                             "SOCK0node"))) {
[17:42:22.958]                             sendCondition <<- function(cond) {
[17:42:22.958]                               data <- list(type = "VALUE", value = cond, 
[17:42:22.958]                                 success = TRUE)
[17:42:22.958]                               parallel_sendData(master, data)
[17:42:22.958]                             }
[17:42:22.958]                             return(sendCondition)
[17:42:22.958]                           }
[17:42:22.958]                         }
[17:42:22.958]                         frame <- frame + 1L
[17:42:22.958]                         envir <- sys.frame(frame)
[17:42:22.958]                       }
[17:42:22.958]                     }
[17:42:22.958]                     sendCondition <<- function(cond) NULL
[17:42:22.958]                   }
[17:42:22.958]                 })
[17:42:22.958]                 withCallingHandlers({
[17:42:22.958]                   {
[17:42:22.958]                     4
[17:42:22.958]                   }
[17:42:22.958]                 }, immediateCondition = function(cond) {
[17:42:22.958]                   sendCondition <- ...future.makeSendCondition()
[17:42:22.958]                   sendCondition(cond)
[17:42:22.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.958]                   {
[17:42:22.958]                     inherits <- base::inherits
[17:42:22.958]                     invokeRestart <- base::invokeRestart
[17:42:22.958]                     is.null <- base::is.null
[17:42:22.958]                     muffled <- FALSE
[17:42:22.958]                     if (inherits(cond, "message")) {
[17:42:22.958]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:22.958]                       if (muffled) 
[17:42:22.958]                         invokeRestart("muffleMessage")
[17:42:22.958]                     }
[17:42:22.958]                     else if (inherits(cond, "warning")) {
[17:42:22.958]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:22.958]                       if (muffled) 
[17:42:22.958]                         invokeRestart("muffleWarning")
[17:42:22.958]                     }
[17:42:22.958]                     else if (inherits(cond, "condition")) {
[17:42:22.958]                       if (!is.null(pattern)) {
[17:42:22.958]                         computeRestarts <- base::computeRestarts
[17:42:22.958]                         grepl <- base::grepl
[17:42:22.958]                         restarts <- computeRestarts(cond)
[17:42:22.958]                         for (restart in restarts) {
[17:42:22.958]                           name <- restart$name
[17:42:22.958]                           if (is.null(name)) 
[17:42:22.958]                             next
[17:42:22.958]                           if (!grepl(pattern, name)) 
[17:42:22.958]                             next
[17:42:22.958]                           invokeRestart(restart)
[17:42:22.958]                           muffled <- TRUE
[17:42:22.958]                           break
[17:42:22.958]                         }
[17:42:22.958]                       }
[17:42:22.958]                     }
[17:42:22.958]                     invisible(muffled)
[17:42:22.958]                   }
[17:42:22.958]                   muffleCondition(cond)
[17:42:22.958]                 })
[17:42:22.958]             }))
[17:42:22.958]             future::FutureResult(value = ...future.value$value, 
[17:42:22.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.958]                   ...future.rng), globalenv = if (FALSE) 
[17:42:22.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:22.958]                     ...future.globalenv.names))
[17:42:22.958]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:22.958]         }, condition = base::local({
[17:42:22.958]             c <- base::c
[17:42:22.958]             inherits <- base::inherits
[17:42:22.958]             invokeRestart <- base::invokeRestart
[17:42:22.958]             length <- base::length
[17:42:22.958]             list <- base::list
[17:42:22.958]             seq.int <- base::seq.int
[17:42:22.958]             signalCondition <- base::signalCondition
[17:42:22.958]             sys.calls <- base::sys.calls
[17:42:22.958]             `[[` <- base::`[[`
[17:42:22.958]             `+` <- base::`+`
[17:42:22.958]             `<<-` <- base::`<<-`
[17:42:22.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:22.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:22.958]                   3L)]
[17:42:22.958]             }
[17:42:22.958]             function(cond) {
[17:42:22.958]                 is_error <- inherits(cond, "error")
[17:42:22.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:22.958]                   NULL)
[17:42:22.958]                 if (is_error) {
[17:42:22.958]                   sessionInformation <- function() {
[17:42:22.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:22.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:22.958]                       search = base::search(), system = base::Sys.info())
[17:42:22.958]                   }
[17:42:22.958]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:22.958]                     cond$call), session = sessionInformation(), 
[17:42:22.958]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:22.958]                   signalCondition(cond)
[17:42:22.958]                 }
[17:42:22.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:22.958]                 "immediateCondition"))) {
[17:42:22.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:22.958]                   ...future.conditions[[length(...future.conditions) + 
[17:42:22.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:22.958]                   if (TRUE && !signal) {
[17:42:22.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.958]                     {
[17:42:22.958]                       inherits <- base::inherits
[17:42:22.958]                       invokeRestart <- base::invokeRestart
[17:42:22.958]                       is.null <- base::is.null
[17:42:22.958]                       muffled <- FALSE
[17:42:22.958]                       if (inherits(cond, "message")) {
[17:42:22.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.958]                         if (muffled) 
[17:42:22.958]                           invokeRestart("muffleMessage")
[17:42:22.958]                       }
[17:42:22.958]                       else if (inherits(cond, "warning")) {
[17:42:22.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.958]                         if (muffled) 
[17:42:22.958]                           invokeRestart("muffleWarning")
[17:42:22.958]                       }
[17:42:22.958]                       else if (inherits(cond, "condition")) {
[17:42:22.958]                         if (!is.null(pattern)) {
[17:42:22.958]                           computeRestarts <- base::computeRestarts
[17:42:22.958]                           grepl <- base::grepl
[17:42:22.958]                           restarts <- computeRestarts(cond)
[17:42:22.958]                           for (restart in restarts) {
[17:42:22.958]                             name <- restart$name
[17:42:22.958]                             if (is.null(name)) 
[17:42:22.958]                               next
[17:42:22.958]                             if (!grepl(pattern, name)) 
[17:42:22.958]                               next
[17:42:22.958]                             invokeRestart(restart)
[17:42:22.958]                             muffled <- TRUE
[17:42:22.958]                             break
[17:42:22.958]                           }
[17:42:22.958]                         }
[17:42:22.958]                       }
[17:42:22.958]                       invisible(muffled)
[17:42:22.958]                     }
[17:42:22.958]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.958]                   }
[17:42:22.958]                 }
[17:42:22.958]                 else {
[17:42:22.958]                   if (TRUE) {
[17:42:22.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:22.958]                     {
[17:42:22.958]                       inherits <- base::inherits
[17:42:22.958]                       invokeRestart <- base::invokeRestart
[17:42:22.958]                       is.null <- base::is.null
[17:42:22.958]                       muffled <- FALSE
[17:42:22.958]                       if (inherits(cond, "message")) {
[17:42:22.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:22.958]                         if (muffled) 
[17:42:22.958]                           invokeRestart("muffleMessage")
[17:42:22.958]                       }
[17:42:22.958]                       else if (inherits(cond, "warning")) {
[17:42:22.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:22.958]                         if (muffled) 
[17:42:22.958]                           invokeRestart("muffleWarning")
[17:42:22.958]                       }
[17:42:22.958]                       else if (inherits(cond, "condition")) {
[17:42:22.958]                         if (!is.null(pattern)) {
[17:42:22.958]                           computeRestarts <- base::computeRestarts
[17:42:22.958]                           grepl <- base::grepl
[17:42:22.958]                           restarts <- computeRestarts(cond)
[17:42:22.958]                           for (restart in restarts) {
[17:42:22.958]                             name <- restart$name
[17:42:22.958]                             if (is.null(name)) 
[17:42:22.958]                               next
[17:42:22.958]                             if (!grepl(pattern, name)) 
[17:42:22.958]                               next
[17:42:22.958]                             invokeRestart(restart)
[17:42:22.958]                             muffled <- TRUE
[17:42:22.958]                             break
[17:42:22.958]                           }
[17:42:22.958]                         }
[17:42:22.958]                       }
[17:42:22.958]                       invisible(muffled)
[17:42:22.958]                     }
[17:42:22.958]                     muffleCondition(cond, pattern = "^muffle")
[17:42:22.958]                   }
[17:42:22.958]                 }
[17:42:22.958]             }
[17:42:22.958]         }))
[17:42:22.958]     }, error = function(ex) {
[17:42:22.958]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:22.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:22.958]                 ...future.rng), started = ...future.startTime, 
[17:42:22.958]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:22.958]             version = "1.8"), class = "FutureResult")
[17:42:22.958]     }, finally = {
[17:42:22.958]         if (!identical(...future.workdir, getwd())) 
[17:42:22.958]             setwd(...future.workdir)
[17:42:22.958]         {
[17:42:22.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:22.958]                 ...future.oldOptions$nwarnings <- NULL
[17:42:22.958]             }
[17:42:22.958]             base::options(...future.oldOptions)
[17:42:22.958]             if (.Platform$OS.type == "windows") {
[17:42:22.958]                 old_names <- names(...future.oldEnvVars)
[17:42:22.958]                 envs <- base::Sys.getenv()
[17:42:22.958]                 names <- names(envs)
[17:42:22.958]                 common <- intersect(names, old_names)
[17:42:22.958]                 added <- setdiff(names, old_names)
[17:42:22.958]                 removed <- setdiff(old_names, names)
[17:42:22.958]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:22.958]                   envs[common]]
[17:42:22.958]                 NAMES <- toupper(changed)
[17:42:22.958]                 args <- list()
[17:42:22.958]                 for (kk in seq_along(NAMES)) {
[17:42:22.958]                   name <- changed[[kk]]
[17:42:22.958]                   NAME <- NAMES[[kk]]
[17:42:22.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.958]                     next
[17:42:22.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.958]                 }
[17:42:22.958]                 NAMES <- toupper(added)
[17:42:22.958]                 for (kk in seq_along(NAMES)) {
[17:42:22.958]                   name <- added[[kk]]
[17:42:22.958]                   NAME <- NAMES[[kk]]
[17:42:22.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.958]                     next
[17:42:22.958]                   args[[name]] <- ""
[17:42:22.958]                 }
[17:42:22.958]                 NAMES <- toupper(removed)
[17:42:22.958]                 for (kk in seq_along(NAMES)) {
[17:42:22.958]                   name <- removed[[kk]]
[17:42:22.958]                   NAME <- NAMES[[kk]]
[17:42:22.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:22.958]                     next
[17:42:22.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:22.958]                 }
[17:42:22.958]                 if (length(args) > 0) 
[17:42:22.958]                   base::do.call(base::Sys.setenv, args = args)
[17:42:22.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:22.958]             }
[17:42:22.958]             else {
[17:42:22.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:22.958]             }
[17:42:22.958]             {
[17:42:22.958]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:22.958]                   0L) {
[17:42:22.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:22.958]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:22.958]                   base::options(opts)
[17:42:22.958]                 }
[17:42:22.958]                 {
[17:42:22.958]                   {
[17:42:22.958]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:22.958]                     NULL
[17:42:22.958]                   }
[17:42:22.958]                   options(future.plan = NULL)
[17:42:22.958]                   if (is.na(NA_character_)) 
[17:42:22.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:22.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:22.958]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:22.958]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:22.958]                     envir = parent.frame()) 
[17:42:22.958]                   {
[17:42:22.958]                     if (is.function(workers)) 
[17:42:22.958]                       workers <- workers()
[17:42:22.958]                     workers <- structure(as.integer(workers), 
[17:42:22.958]                       class = class(workers))
[17:42:22.958]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:22.958]                       workers >= 1)
[17:42:22.958]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:22.958]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:22.958]                     }
[17:42:22.958]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:22.958]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:22.958]                       envir = envir)
[17:42:22.958]                     if (!future$lazy) 
[17:42:22.958]                       future <- run(future)
[17:42:22.958]                     invisible(future)
[17:42:22.958]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:22.958]                 }
[17:42:22.958]             }
[17:42:22.958]         }
[17:42:22.958]     })
[17:42:22.958]     if (TRUE) {
[17:42:22.958]         base::sink(type = "output", split = FALSE)
[17:42:22.958]         if (TRUE) {
[17:42:22.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:22.958]         }
[17:42:22.958]         else {
[17:42:22.958]             ...future.result["stdout"] <- base::list(NULL)
[17:42:22.958]         }
[17:42:22.958]         base::close(...future.stdout)
[17:42:22.958]         ...future.stdout <- NULL
[17:42:22.958]     }
[17:42:22.958]     ...future.result$conditions <- ...future.conditions
[17:42:22.958]     ...future.result$finished <- base::Sys.time()
[17:42:22.958]     ...future.result
[17:42:22.958] }
[17:42:22.960] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:22.971] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.971] - Validating connection of MultisessionFuture
[17:42:22.971] - received message: FutureResult
[17:42:22.971] - Received FutureResult
[17:42:22.971] - Erased future from FutureRegistry
[17:42:22.971] result() for ClusterFuture ...
[17:42:22.972] - result already collected: FutureResult
[17:42:22.972] result() for ClusterFuture ... done
[17:42:22.972] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:22.972] result() for ClusterFuture ...
[17:42:22.972] - result already collected: FutureResult
[17:42:22.972] result() for ClusterFuture ... done
[17:42:22.972] result() for ClusterFuture ...
[17:42:22.972] - result already collected: FutureResult
[17:42:22.972] result() for ClusterFuture ... done
[17:42:22.973] MultisessionFuture started
[17:42:22.973] - Launch lazy future ... done
[17:42:22.973] run() for ‘MultisessionFuture’ ... done
<environment: 0x55bef9eaefe8> 
<environment: 0x55bef6cfd008> 
[17:42:22.984] receiveMessageFromWorker() for ClusterFuture ...
[17:42:22.984] - Validating connection of MultisessionFuture
[17:42:22.984] - received message: FutureResult
[17:42:22.984] - Received FutureResult
[17:42:22.984] - Erased future from FutureRegistry
[17:42:22.984] result() for ClusterFuture ...
[17:42:22.984] - result already collected: FutureResult
[17:42:22.985] result() for ClusterFuture ... done
[17:42:22.985] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:22.996] resolve() on environment ...
[17:42:22.996]  recursive: 0
[17:42:22.997]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:22.997] signalConditionsASAP(numeric, pos=1) ...
[17:42:22.997] - nx: 4
[17:42:22.997] - relay: TRUE
[17:42:22.997] - stdout: TRUE
[17:42:22.997] - signal: TRUE
[17:42:22.998] - resignal: FALSE
[17:42:22.998] - force: TRUE
[17:42:22.998] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.998] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.998]  - until=2
[17:42:22.998]  - relaying element #2
[17:42:22.998] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:22.998] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:22.998] signalConditionsASAP(NULL, pos=1) ... done
[17:42:22.998]  length: 3 (resolved future 1)
[17:42:22.998] Future #2
[17:42:22.999] result() for ClusterFuture ...
[17:42:22.999] - result already collected: FutureResult
[17:42:22.999] result() for ClusterFuture ... done
[17:42:22.999] result() for ClusterFuture ...
[17:42:22.999] - result already collected: FutureResult
[17:42:22.999] result() for ClusterFuture ... done
[17:42:22.999] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:22.999] - nx: 4
[17:42:22.999] - relay: TRUE
[17:42:22.999] - stdout: TRUE
[17:42:23.000] - signal: TRUE
[17:42:23.000] - resignal: FALSE
[17:42:23.000] - force: TRUE
[17:42:23.000] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:23.000] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:23.000]  - until=2
[17:42:23.000]  - relaying element #2
[17:42:23.000] result() for ClusterFuture ...
[17:42:23.000] - result already collected: FutureResult
[17:42:23.000] result() for ClusterFuture ... done
[17:42:23.000] result() for ClusterFuture ...
[17:42:23.001] - result already collected: FutureResult
[17:42:23.001] result() for ClusterFuture ... done
[17:42:23.001] result() for ClusterFuture ...
[17:42:23.001] - result already collected: FutureResult
[17:42:23.001] result() for ClusterFuture ... done
[17:42:23.001] result() for ClusterFuture ...
[17:42:23.001] - result already collected: FutureResult
[17:42:23.001] result() for ClusterFuture ... done
[17:42:23.001] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:23.001] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:23.001] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:23.002]  length: 2 (resolved future 2)
[17:42:23.002] Future #3
[17:42:23.002] result() for ClusterFuture ...
[17:42:23.002] - result already collected: FutureResult
[17:42:23.002] result() for ClusterFuture ... done
[17:42:23.002] result() for ClusterFuture ...
[17:42:23.002] - result already collected: FutureResult
[17:42:23.002] result() for ClusterFuture ... done
[17:42:23.002] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:23.002] - nx: 4
[17:42:23.002] - relay: TRUE
[17:42:23.003] - stdout: TRUE
[17:42:23.003] - signal: TRUE
[17:42:23.003] - resignal: FALSE
[17:42:23.003] - force: TRUE
[17:42:23.003] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:23.003] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:23.003]  - until=3
[17:42:23.003]  - relaying element #3
[17:42:23.003] result() for ClusterFuture ...
[17:42:23.003] - result already collected: FutureResult
[17:42:23.003] result() for ClusterFuture ... done
[17:42:23.004] result() for ClusterFuture ...
[17:42:23.004] - result already collected: FutureResult
[17:42:23.004] result() for ClusterFuture ... done
[17:42:23.004] result() for ClusterFuture ...
[17:42:23.004] - result already collected: FutureResult
[17:42:23.004] result() for ClusterFuture ... done
[17:42:23.004] result() for ClusterFuture ...
[17:42:23.004] - result already collected: FutureResult
[17:42:23.004] result() for ClusterFuture ... done
[17:42:23.004] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:23.004] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:23.005] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:23.005]  length: 1 (resolved future 3)
[17:42:23.026] receiveMessageFromWorker() for ClusterFuture ...
[17:42:23.026] - Validating connection of MultisessionFuture
[17:42:23.026] - received message: FutureResult
[17:42:23.026] - Received FutureResult
[17:42:23.026] - Erased future from FutureRegistry
[17:42:23.027] result() for ClusterFuture ...
[17:42:23.027] - result already collected: FutureResult
[17:42:23.027] result() for ClusterFuture ... done
[17:42:23.027] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:23.027] Future #4
[17:42:23.027] result() for ClusterFuture ...
[17:42:23.027] - result already collected: FutureResult
[17:42:23.027] result() for ClusterFuture ... done
[17:42:23.027] result() for ClusterFuture ...
[17:42:23.027] - result already collected: FutureResult
[17:42:23.027] result() for ClusterFuture ... done
[17:42:23.028] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:23.028] - nx: 4
[17:42:23.028] - relay: TRUE
[17:42:23.028] - stdout: TRUE
[17:42:23.028] - signal: TRUE
[17:42:23.028] - resignal: FALSE
[17:42:23.028] - force: TRUE
[17:42:23.028] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:23.028] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:23.028]  - until=4
[17:42:23.028]  - relaying element #4
[17:42:23.029] result() for ClusterFuture ...
[17:42:23.029] - result already collected: FutureResult
[17:42:23.029] result() for ClusterFuture ... done
[17:42:23.029] result() for ClusterFuture ...
[17:42:23.029] - result already collected: FutureResult
[17:42:23.029] result() for ClusterFuture ... done
[17:42:23.029] result() for ClusterFuture ...
[17:42:23.029] - result already collected: FutureResult
[17:42:23.029] result() for ClusterFuture ... done
[17:42:23.029] result() for ClusterFuture ...
[17:42:23.029] - result already collected: FutureResult
[17:42:23.030] result() for ClusterFuture ... done
[17:42:23.030] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:23.030] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:23.030] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:23.030]  length: 0 (resolved future 4)
[17:42:23.030] Relaying remaining futures
[17:42:23.030] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.030] - nx: 4
[17:42:23.030] - relay: TRUE
[17:42:23.030] - stdout: TRUE
[17:42:23.030] - signal: TRUE
[17:42:23.030] - resignal: FALSE
[17:42:23.031] - force: TRUE
[17:42:23.031] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:23.031] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:23.031] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:23.031] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:23.031] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.031] resolve() on environment ... DONE
[17:42:23.031] result() for ClusterFuture ...
[17:42:23.031] - result already collected: FutureResult
[17:42:23.032] result() for ClusterFuture ... done
[17:42:23.032] result() for ClusterFuture ...
[17:42:23.032] - result already collected: FutureResult
[17:42:23.032] result() for ClusterFuture ... done
[17:42:23.032] result() for ClusterFuture ...
[17:42:23.032] - result already collected: FutureResult
[17:42:23.032] result() for ClusterFuture ... done
[17:42:23.032] result() for ClusterFuture ...
[17:42:23.032] - result already collected: FutureResult
[17:42:23.032] result() for ClusterFuture ... done
[17:42:23.032] result() for ClusterFuture ...
[17:42:23.033] - result already collected: FutureResult
[17:42:23.033] result() for ClusterFuture ... done
[17:42:23.033] result() for ClusterFuture ...
[17:42:23.033] - result already collected: FutureResult
[17:42:23.033] result() for ClusterFuture ... done
<environment: 0x55bef5f46a30> 
Dimensions: c(2, 1, 3, 1)
[17:42:23.033] getGlobalsAndPackages() ...
[17:42:23.033] Searching for globals...
[17:42:23.034] 
[17:42:23.034] Searching for globals ... DONE
[17:42:23.034] - globals: [0] <none>
[17:42:23.034] getGlobalsAndPackages() ... DONE
[17:42:23.034] run() for ‘Future’ ...
[17:42:23.035] - state: ‘created’
[17:42:23.035] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.049] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.049] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:23.049]   - Field: ‘node’
[17:42:23.049]   - Field: ‘label’
[17:42:23.050]   - Field: ‘local’
[17:42:23.050]   - Field: ‘owner’
[17:42:23.050]   - Field: ‘envir’
[17:42:23.050]   - Field: ‘workers’
[17:42:23.050]   - Field: ‘packages’
[17:42:23.050]   - Field: ‘gc’
[17:42:23.050]   - Field: ‘conditions’
[17:42:23.050]   - Field: ‘persistent’
[17:42:23.050]   - Field: ‘expr’
[17:42:23.050]   - Field: ‘uuid’
[17:42:23.051]   - Field: ‘seed’
[17:42:23.051]   - Field: ‘version’
[17:42:23.051]   - Field: ‘result’
[17:42:23.051]   - Field: ‘asynchronous’
[17:42:23.051]   - Field: ‘calls’
[17:42:23.051]   - Field: ‘globals’
[17:42:23.051]   - Field: ‘stdout’
[17:42:23.051]   - Field: ‘earlySignal’
[17:42:23.051]   - Field: ‘lazy’
[17:42:23.051]   - Field: ‘state’
[17:42:23.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:23.052] - Launch lazy future ...
[17:42:23.052] Packages needed by the future expression (n = 0): <none>
[17:42:23.052] Packages needed by future strategies (n = 0): <none>
[17:42:23.052] {
[17:42:23.052]     {
[17:42:23.052]         {
[17:42:23.052]             ...future.startTime <- base::Sys.time()
[17:42:23.052]             {
[17:42:23.052]                 {
[17:42:23.052]                   {
[17:42:23.052]                     {
[17:42:23.052]                       base::local({
[17:42:23.052]                         has_future <- base::requireNamespace("future", 
[17:42:23.052]                           quietly = TRUE)
[17:42:23.052]                         if (has_future) {
[17:42:23.052]                           ns <- base::getNamespace("future")
[17:42:23.052]                           version <- ns[[".package"]][["version"]]
[17:42:23.052]                           if (is.null(version)) 
[17:42:23.052]                             version <- utils::packageVersion("future")
[17:42:23.052]                         }
[17:42:23.052]                         else {
[17:42:23.052]                           version <- NULL
[17:42:23.052]                         }
[17:42:23.052]                         if (!has_future || version < "1.8.0") {
[17:42:23.052]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.052]                             "", base::R.version$version.string), 
[17:42:23.052]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.052]                               "release", "version")], collapse = " "), 
[17:42:23.052]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.052]                             info)
[17:42:23.052]                           info <- base::paste(info, collapse = "; ")
[17:42:23.052]                           if (!has_future) {
[17:42:23.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.052]                               info)
[17:42:23.052]                           }
[17:42:23.052]                           else {
[17:42:23.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.052]                               info, version)
[17:42:23.052]                           }
[17:42:23.052]                           base::stop(msg)
[17:42:23.052]                         }
[17:42:23.052]                       })
[17:42:23.052]                     }
[17:42:23.052]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.052]                     base::options(mc.cores = 1L)
[17:42:23.052]                   }
[17:42:23.052]                   options(future.plan = NULL)
[17:42:23.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.052]                 }
[17:42:23.052]                 ...future.workdir <- getwd()
[17:42:23.052]             }
[17:42:23.052]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.052]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.052]         }
[17:42:23.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.052]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.052]             base::names(...future.oldOptions))
[17:42:23.052]     }
[17:42:23.052]     if (FALSE) {
[17:42:23.052]     }
[17:42:23.052]     else {
[17:42:23.052]         if (TRUE) {
[17:42:23.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.052]                 open = "w")
[17:42:23.052]         }
[17:42:23.052]         else {
[17:42:23.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.052]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.052]         }
[17:42:23.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.052]             base::sink(type = "output", split = FALSE)
[17:42:23.052]             base::close(...future.stdout)
[17:42:23.052]         }, add = TRUE)
[17:42:23.052]     }
[17:42:23.052]     ...future.frame <- base::sys.nframe()
[17:42:23.052]     ...future.conditions <- base::list()
[17:42:23.052]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.052]     if (FALSE) {
[17:42:23.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.052]     }
[17:42:23.052]     ...future.result <- base::tryCatch({
[17:42:23.052]         base::withCallingHandlers({
[17:42:23.052]             ...future.value <- base::withVisible(base::local({
[17:42:23.052]                 ...future.makeSendCondition <- local({
[17:42:23.052]                   sendCondition <- NULL
[17:42:23.052]                   function(frame = 1L) {
[17:42:23.052]                     if (is.function(sendCondition)) 
[17:42:23.052]                       return(sendCondition)
[17:42:23.052]                     ns <- getNamespace("parallel")
[17:42:23.052]                     if (exists("sendData", mode = "function", 
[17:42:23.052]                       envir = ns)) {
[17:42:23.052]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:23.052]                         envir = ns)
[17:42:23.052]                       envir <- sys.frame(frame)
[17:42:23.052]                       master <- NULL
[17:42:23.052]                       while (!identical(envir, .GlobalEnv) && 
[17:42:23.052]                         !identical(envir, emptyenv())) {
[17:42:23.052]                         if (exists("master", mode = "list", envir = envir, 
[17:42:23.052]                           inherits = FALSE)) {
[17:42:23.052]                           master <- get("master", mode = "list", 
[17:42:23.052]                             envir = envir, inherits = FALSE)
[17:42:23.052]                           if (inherits(master, c("SOCKnode", 
[17:42:23.052]                             "SOCK0node"))) {
[17:42:23.052]                             sendCondition <<- function(cond) {
[17:42:23.052]                               data <- list(type = "VALUE", value = cond, 
[17:42:23.052]                                 success = TRUE)
[17:42:23.052]                               parallel_sendData(master, data)
[17:42:23.052]                             }
[17:42:23.052]                             return(sendCondition)
[17:42:23.052]                           }
[17:42:23.052]                         }
[17:42:23.052]                         frame <- frame + 1L
[17:42:23.052]                         envir <- sys.frame(frame)
[17:42:23.052]                       }
[17:42:23.052]                     }
[17:42:23.052]                     sendCondition <<- function(cond) NULL
[17:42:23.052]                   }
[17:42:23.052]                 })
[17:42:23.052]                 withCallingHandlers({
[17:42:23.052]                   2
[17:42:23.052]                 }, immediateCondition = function(cond) {
[17:42:23.052]                   sendCondition <- ...future.makeSendCondition()
[17:42:23.052]                   sendCondition(cond)
[17:42:23.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.052]                   {
[17:42:23.052]                     inherits <- base::inherits
[17:42:23.052]                     invokeRestart <- base::invokeRestart
[17:42:23.052]                     is.null <- base::is.null
[17:42:23.052]                     muffled <- FALSE
[17:42:23.052]                     if (inherits(cond, "message")) {
[17:42:23.052]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.052]                       if (muffled) 
[17:42:23.052]                         invokeRestart("muffleMessage")
[17:42:23.052]                     }
[17:42:23.052]                     else if (inherits(cond, "warning")) {
[17:42:23.052]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.052]                       if (muffled) 
[17:42:23.052]                         invokeRestart("muffleWarning")
[17:42:23.052]                     }
[17:42:23.052]                     else if (inherits(cond, "condition")) {
[17:42:23.052]                       if (!is.null(pattern)) {
[17:42:23.052]                         computeRestarts <- base::computeRestarts
[17:42:23.052]                         grepl <- base::grepl
[17:42:23.052]                         restarts <- computeRestarts(cond)
[17:42:23.052]                         for (restart in restarts) {
[17:42:23.052]                           name <- restart$name
[17:42:23.052]                           if (is.null(name)) 
[17:42:23.052]                             next
[17:42:23.052]                           if (!grepl(pattern, name)) 
[17:42:23.052]                             next
[17:42:23.052]                           invokeRestart(restart)
[17:42:23.052]                           muffled <- TRUE
[17:42:23.052]                           break
[17:42:23.052]                         }
[17:42:23.052]                       }
[17:42:23.052]                     }
[17:42:23.052]                     invisible(muffled)
[17:42:23.052]                   }
[17:42:23.052]                   muffleCondition(cond)
[17:42:23.052]                 })
[17:42:23.052]             }))
[17:42:23.052]             future::FutureResult(value = ...future.value$value, 
[17:42:23.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.052]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.052]                     ...future.globalenv.names))
[17:42:23.052]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.052]         }, condition = base::local({
[17:42:23.052]             c <- base::c
[17:42:23.052]             inherits <- base::inherits
[17:42:23.052]             invokeRestart <- base::invokeRestart
[17:42:23.052]             length <- base::length
[17:42:23.052]             list <- base::list
[17:42:23.052]             seq.int <- base::seq.int
[17:42:23.052]             signalCondition <- base::signalCondition
[17:42:23.052]             sys.calls <- base::sys.calls
[17:42:23.052]             `[[` <- base::`[[`
[17:42:23.052]             `+` <- base::`+`
[17:42:23.052]             `<<-` <- base::`<<-`
[17:42:23.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.052]                   3L)]
[17:42:23.052]             }
[17:42:23.052]             function(cond) {
[17:42:23.052]                 is_error <- inherits(cond, "error")
[17:42:23.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.052]                   NULL)
[17:42:23.052]                 if (is_error) {
[17:42:23.052]                   sessionInformation <- function() {
[17:42:23.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.052]                       search = base::search(), system = base::Sys.info())
[17:42:23.052]                   }
[17:42:23.052]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.052]                     cond$call), session = sessionInformation(), 
[17:42:23.052]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.052]                   signalCondition(cond)
[17:42:23.052]                 }
[17:42:23.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.052]                 "immediateCondition"))) {
[17:42:23.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.052]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.052]                   if (TRUE && !signal) {
[17:42:23.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.052]                     {
[17:42:23.052]                       inherits <- base::inherits
[17:42:23.052]                       invokeRestart <- base::invokeRestart
[17:42:23.052]                       is.null <- base::is.null
[17:42:23.052]                       muffled <- FALSE
[17:42:23.052]                       if (inherits(cond, "message")) {
[17:42:23.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.052]                         if (muffled) 
[17:42:23.052]                           invokeRestart("muffleMessage")
[17:42:23.052]                       }
[17:42:23.052]                       else if (inherits(cond, "warning")) {
[17:42:23.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.052]                         if (muffled) 
[17:42:23.052]                           invokeRestart("muffleWarning")
[17:42:23.052]                       }
[17:42:23.052]                       else if (inherits(cond, "condition")) {
[17:42:23.052]                         if (!is.null(pattern)) {
[17:42:23.052]                           computeRestarts <- base::computeRestarts
[17:42:23.052]                           grepl <- base::grepl
[17:42:23.052]                           restarts <- computeRestarts(cond)
[17:42:23.052]                           for (restart in restarts) {
[17:42:23.052]                             name <- restart$name
[17:42:23.052]                             if (is.null(name)) 
[17:42:23.052]                               next
[17:42:23.052]                             if (!grepl(pattern, name)) 
[17:42:23.052]                               next
[17:42:23.052]                             invokeRestart(restart)
[17:42:23.052]                             muffled <- TRUE
[17:42:23.052]                             break
[17:42:23.052]                           }
[17:42:23.052]                         }
[17:42:23.052]                       }
[17:42:23.052]                       invisible(muffled)
[17:42:23.052]                     }
[17:42:23.052]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.052]                   }
[17:42:23.052]                 }
[17:42:23.052]                 else {
[17:42:23.052]                   if (TRUE) {
[17:42:23.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.052]                     {
[17:42:23.052]                       inherits <- base::inherits
[17:42:23.052]                       invokeRestart <- base::invokeRestart
[17:42:23.052]                       is.null <- base::is.null
[17:42:23.052]                       muffled <- FALSE
[17:42:23.052]                       if (inherits(cond, "message")) {
[17:42:23.052]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.052]                         if (muffled) 
[17:42:23.052]                           invokeRestart("muffleMessage")
[17:42:23.052]                       }
[17:42:23.052]                       else if (inherits(cond, "warning")) {
[17:42:23.052]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.052]                         if (muffled) 
[17:42:23.052]                           invokeRestart("muffleWarning")
[17:42:23.052]                       }
[17:42:23.052]                       else if (inherits(cond, "condition")) {
[17:42:23.052]                         if (!is.null(pattern)) {
[17:42:23.052]                           computeRestarts <- base::computeRestarts
[17:42:23.052]                           grepl <- base::grepl
[17:42:23.052]                           restarts <- computeRestarts(cond)
[17:42:23.052]                           for (restart in restarts) {
[17:42:23.052]                             name <- restart$name
[17:42:23.052]                             if (is.null(name)) 
[17:42:23.052]                               next
[17:42:23.052]                             if (!grepl(pattern, name)) 
[17:42:23.052]                               next
[17:42:23.052]                             invokeRestart(restart)
[17:42:23.052]                             muffled <- TRUE
[17:42:23.052]                             break
[17:42:23.052]                           }
[17:42:23.052]                         }
[17:42:23.052]                       }
[17:42:23.052]                       invisible(muffled)
[17:42:23.052]                     }
[17:42:23.052]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.052]                   }
[17:42:23.052]                 }
[17:42:23.052]             }
[17:42:23.052]         }))
[17:42:23.052]     }, error = function(ex) {
[17:42:23.052]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.052]                 ...future.rng), started = ...future.startTime, 
[17:42:23.052]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.052]             version = "1.8"), class = "FutureResult")
[17:42:23.052]     }, finally = {
[17:42:23.052]         if (!identical(...future.workdir, getwd())) 
[17:42:23.052]             setwd(...future.workdir)
[17:42:23.052]         {
[17:42:23.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.052]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.052]             }
[17:42:23.052]             base::options(...future.oldOptions)
[17:42:23.052]             if (.Platform$OS.type == "windows") {
[17:42:23.052]                 old_names <- names(...future.oldEnvVars)
[17:42:23.052]                 envs <- base::Sys.getenv()
[17:42:23.052]                 names <- names(envs)
[17:42:23.052]                 common <- intersect(names, old_names)
[17:42:23.052]                 added <- setdiff(names, old_names)
[17:42:23.052]                 removed <- setdiff(old_names, names)
[17:42:23.052]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.052]                   envs[common]]
[17:42:23.052]                 NAMES <- toupper(changed)
[17:42:23.052]                 args <- list()
[17:42:23.052]                 for (kk in seq_along(NAMES)) {
[17:42:23.052]                   name <- changed[[kk]]
[17:42:23.052]                   NAME <- NAMES[[kk]]
[17:42:23.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.052]                     next
[17:42:23.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.052]                 }
[17:42:23.052]                 NAMES <- toupper(added)
[17:42:23.052]                 for (kk in seq_along(NAMES)) {
[17:42:23.052]                   name <- added[[kk]]
[17:42:23.052]                   NAME <- NAMES[[kk]]
[17:42:23.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.052]                     next
[17:42:23.052]                   args[[name]] <- ""
[17:42:23.052]                 }
[17:42:23.052]                 NAMES <- toupper(removed)
[17:42:23.052]                 for (kk in seq_along(NAMES)) {
[17:42:23.052]                   name <- removed[[kk]]
[17:42:23.052]                   NAME <- NAMES[[kk]]
[17:42:23.052]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.052]                     next
[17:42:23.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.052]                 }
[17:42:23.052]                 if (length(args) > 0) 
[17:42:23.052]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.052]             }
[17:42:23.052]             else {
[17:42:23.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.052]             }
[17:42:23.052]             {
[17:42:23.052]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.052]                   0L) {
[17:42:23.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.052]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.052]                   base::options(opts)
[17:42:23.052]                 }
[17:42:23.052]                 {
[17:42:23.052]                   {
[17:42:23.052]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.052]                     NULL
[17:42:23.052]                   }
[17:42:23.052]                   options(future.plan = NULL)
[17:42:23.052]                   if (is.na(NA_character_)) 
[17:42:23.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.052]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:23.052]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:23.052]                     envir = parent.frame()) 
[17:42:23.052]                   {
[17:42:23.052]                     if (is.function(workers)) 
[17:42:23.052]                       workers <- workers()
[17:42:23.052]                     workers <- structure(as.integer(workers), 
[17:42:23.052]                       class = class(workers))
[17:42:23.052]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:23.052]                       workers >= 1)
[17:42:23.052]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:23.052]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:23.052]                     }
[17:42:23.052]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:23.052]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:23.052]                       envir = envir)
[17:42:23.052]                     if (!future$lazy) 
[17:42:23.052]                       future <- run(future)
[17:42:23.052]                     invisible(future)
[17:42:23.052]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.052]                 }
[17:42:23.052]             }
[17:42:23.052]         }
[17:42:23.052]     })
[17:42:23.052]     if (TRUE) {
[17:42:23.052]         base::sink(type = "output", split = FALSE)
[17:42:23.052]         if (TRUE) {
[17:42:23.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.052]         }
[17:42:23.052]         else {
[17:42:23.052]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.052]         }
[17:42:23.052]         base::close(...future.stdout)
[17:42:23.052]         ...future.stdout <- NULL
[17:42:23.052]     }
[17:42:23.052]     ...future.result$conditions <- ...future.conditions
[17:42:23.052]     ...future.result$finished <- base::Sys.time()
[17:42:23.052]     ...future.result
[17:42:23.052] }
[17:42:23.056] MultisessionFuture started
[17:42:23.056] - Launch lazy future ... done
[17:42:23.056] run() for ‘MultisessionFuture’ ... done
[17:42:23.056] getGlobalsAndPackages() ...
[17:42:23.056] Searching for globals...
[17:42:23.056] 
[17:42:23.057] Searching for globals ... DONE
[17:42:23.057] - globals: [0] <none>
[17:42:23.057] getGlobalsAndPackages() ... DONE
[17:42:23.057] run() for ‘Future’ ...
[17:42:23.057] - state: ‘created’
[17:42:23.057] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:23.072]   - Field: ‘node’
[17:42:23.072]   - Field: ‘label’
[17:42:23.072]   - Field: ‘local’
[17:42:23.072]   - Field: ‘owner’
[17:42:23.072]   - Field: ‘envir’
[17:42:23.072]   - Field: ‘workers’
[17:42:23.072]   - Field: ‘packages’
[17:42:23.072]   - Field: ‘gc’
[17:42:23.072]   - Field: ‘conditions’
[17:42:23.073]   - Field: ‘persistent’
[17:42:23.073]   - Field: ‘expr’
[17:42:23.073]   - Field: ‘uuid’
[17:42:23.073]   - Field: ‘seed’
[17:42:23.073]   - Field: ‘version’
[17:42:23.073]   - Field: ‘result’
[17:42:23.073]   - Field: ‘asynchronous’
[17:42:23.073]   - Field: ‘calls’
[17:42:23.073]   - Field: ‘globals’
[17:42:23.073]   - Field: ‘stdout’
[17:42:23.073]   - Field: ‘earlySignal’
[17:42:23.074]   - Field: ‘lazy’
[17:42:23.074]   - Field: ‘state’
[17:42:23.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:23.074] - Launch lazy future ...
[17:42:23.074] Packages needed by the future expression (n = 0): <none>
[17:42:23.074] Packages needed by future strategies (n = 0): <none>
[17:42:23.075] {
[17:42:23.075]     {
[17:42:23.075]         {
[17:42:23.075]             ...future.startTime <- base::Sys.time()
[17:42:23.075]             {
[17:42:23.075]                 {
[17:42:23.075]                   {
[17:42:23.075]                     {
[17:42:23.075]                       base::local({
[17:42:23.075]                         has_future <- base::requireNamespace("future", 
[17:42:23.075]                           quietly = TRUE)
[17:42:23.075]                         if (has_future) {
[17:42:23.075]                           ns <- base::getNamespace("future")
[17:42:23.075]                           version <- ns[[".package"]][["version"]]
[17:42:23.075]                           if (is.null(version)) 
[17:42:23.075]                             version <- utils::packageVersion("future")
[17:42:23.075]                         }
[17:42:23.075]                         else {
[17:42:23.075]                           version <- NULL
[17:42:23.075]                         }
[17:42:23.075]                         if (!has_future || version < "1.8.0") {
[17:42:23.075]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.075]                             "", base::R.version$version.string), 
[17:42:23.075]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.075]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.075]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.075]                               "release", "version")], collapse = " "), 
[17:42:23.075]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.075]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.075]                             info)
[17:42:23.075]                           info <- base::paste(info, collapse = "; ")
[17:42:23.075]                           if (!has_future) {
[17:42:23.075]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.075]                               info)
[17:42:23.075]                           }
[17:42:23.075]                           else {
[17:42:23.075]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.075]                               info, version)
[17:42:23.075]                           }
[17:42:23.075]                           base::stop(msg)
[17:42:23.075]                         }
[17:42:23.075]                       })
[17:42:23.075]                     }
[17:42:23.075]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.075]                     base::options(mc.cores = 1L)
[17:42:23.075]                   }
[17:42:23.075]                   options(future.plan = NULL)
[17:42:23.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.075]                 }
[17:42:23.075]                 ...future.workdir <- getwd()
[17:42:23.075]             }
[17:42:23.075]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.075]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.075]         }
[17:42:23.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.075]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.075]             base::names(...future.oldOptions))
[17:42:23.075]     }
[17:42:23.075]     if (FALSE) {
[17:42:23.075]     }
[17:42:23.075]     else {
[17:42:23.075]         if (TRUE) {
[17:42:23.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.075]                 open = "w")
[17:42:23.075]         }
[17:42:23.075]         else {
[17:42:23.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.075]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.075]         }
[17:42:23.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.075]             base::sink(type = "output", split = FALSE)
[17:42:23.075]             base::close(...future.stdout)
[17:42:23.075]         }, add = TRUE)
[17:42:23.075]     }
[17:42:23.075]     ...future.frame <- base::sys.nframe()
[17:42:23.075]     ...future.conditions <- base::list()
[17:42:23.075]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.075]     if (FALSE) {
[17:42:23.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.075]     }
[17:42:23.075]     ...future.result <- base::tryCatch({
[17:42:23.075]         base::withCallingHandlers({
[17:42:23.075]             ...future.value <- base::withVisible(base::local({
[17:42:23.075]                 ...future.makeSendCondition <- local({
[17:42:23.075]                   sendCondition <- NULL
[17:42:23.075]                   function(frame = 1L) {
[17:42:23.075]                     if (is.function(sendCondition)) 
[17:42:23.075]                       return(sendCondition)
[17:42:23.075]                     ns <- getNamespace("parallel")
[17:42:23.075]                     if (exists("sendData", mode = "function", 
[17:42:23.075]                       envir = ns)) {
[17:42:23.075]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:23.075]                         envir = ns)
[17:42:23.075]                       envir <- sys.frame(frame)
[17:42:23.075]                       master <- NULL
[17:42:23.075]                       while (!identical(envir, .GlobalEnv) && 
[17:42:23.075]                         !identical(envir, emptyenv())) {
[17:42:23.075]                         if (exists("master", mode = "list", envir = envir, 
[17:42:23.075]                           inherits = FALSE)) {
[17:42:23.075]                           master <- get("master", mode = "list", 
[17:42:23.075]                             envir = envir, inherits = FALSE)
[17:42:23.075]                           if (inherits(master, c("SOCKnode", 
[17:42:23.075]                             "SOCK0node"))) {
[17:42:23.075]                             sendCondition <<- function(cond) {
[17:42:23.075]                               data <- list(type = "VALUE", value = cond, 
[17:42:23.075]                                 success = TRUE)
[17:42:23.075]                               parallel_sendData(master, data)
[17:42:23.075]                             }
[17:42:23.075]                             return(sendCondition)
[17:42:23.075]                           }
[17:42:23.075]                         }
[17:42:23.075]                         frame <- frame + 1L
[17:42:23.075]                         envir <- sys.frame(frame)
[17:42:23.075]                       }
[17:42:23.075]                     }
[17:42:23.075]                     sendCondition <<- function(cond) NULL
[17:42:23.075]                   }
[17:42:23.075]                 })
[17:42:23.075]                 withCallingHandlers({
[17:42:23.075]                   NULL
[17:42:23.075]                 }, immediateCondition = function(cond) {
[17:42:23.075]                   sendCondition <- ...future.makeSendCondition()
[17:42:23.075]                   sendCondition(cond)
[17:42:23.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.075]                   {
[17:42:23.075]                     inherits <- base::inherits
[17:42:23.075]                     invokeRestart <- base::invokeRestart
[17:42:23.075]                     is.null <- base::is.null
[17:42:23.075]                     muffled <- FALSE
[17:42:23.075]                     if (inherits(cond, "message")) {
[17:42:23.075]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.075]                       if (muffled) 
[17:42:23.075]                         invokeRestart("muffleMessage")
[17:42:23.075]                     }
[17:42:23.075]                     else if (inherits(cond, "warning")) {
[17:42:23.075]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.075]                       if (muffled) 
[17:42:23.075]                         invokeRestart("muffleWarning")
[17:42:23.075]                     }
[17:42:23.075]                     else if (inherits(cond, "condition")) {
[17:42:23.075]                       if (!is.null(pattern)) {
[17:42:23.075]                         computeRestarts <- base::computeRestarts
[17:42:23.075]                         grepl <- base::grepl
[17:42:23.075]                         restarts <- computeRestarts(cond)
[17:42:23.075]                         for (restart in restarts) {
[17:42:23.075]                           name <- restart$name
[17:42:23.075]                           if (is.null(name)) 
[17:42:23.075]                             next
[17:42:23.075]                           if (!grepl(pattern, name)) 
[17:42:23.075]                             next
[17:42:23.075]                           invokeRestart(restart)
[17:42:23.075]                           muffled <- TRUE
[17:42:23.075]                           break
[17:42:23.075]                         }
[17:42:23.075]                       }
[17:42:23.075]                     }
[17:42:23.075]                     invisible(muffled)
[17:42:23.075]                   }
[17:42:23.075]                   muffleCondition(cond)
[17:42:23.075]                 })
[17:42:23.075]             }))
[17:42:23.075]             future::FutureResult(value = ...future.value$value, 
[17:42:23.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.075]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.075]                     ...future.globalenv.names))
[17:42:23.075]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.075]         }, condition = base::local({
[17:42:23.075]             c <- base::c
[17:42:23.075]             inherits <- base::inherits
[17:42:23.075]             invokeRestart <- base::invokeRestart
[17:42:23.075]             length <- base::length
[17:42:23.075]             list <- base::list
[17:42:23.075]             seq.int <- base::seq.int
[17:42:23.075]             signalCondition <- base::signalCondition
[17:42:23.075]             sys.calls <- base::sys.calls
[17:42:23.075]             `[[` <- base::`[[`
[17:42:23.075]             `+` <- base::`+`
[17:42:23.075]             `<<-` <- base::`<<-`
[17:42:23.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.075]                   3L)]
[17:42:23.075]             }
[17:42:23.075]             function(cond) {
[17:42:23.075]                 is_error <- inherits(cond, "error")
[17:42:23.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.075]                   NULL)
[17:42:23.075]                 if (is_error) {
[17:42:23.075]                   sessionInformation <- function() {
[17:42:23.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.075]                       search = base::search(), system = base::Sys.info())
[17:42:23.075]                   }
[17:42:23.075]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.075]                     cond$call), session = sessionInformation(), 
[17:42:23.075]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.075]                   signalCondition(cond)
[17:42:23.075]                 }
[17:42:23.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.075]                 "immediateCondition"))) {
[17:42:23.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.075]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.075]                   if (TRUE && !signal) {
[17:42:23.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.075]                     {
[17:42:23.075]                       inherits <- base::inherits
[17:42:23.075]                       invokeRestart <- base::invokeRestart
[17:42:23.075]                       is.null <- base::is.null
[17:42:23.075]                       muffled <- FALSE
[17:42:23.075]                       if (inherits(cond, "message")) {
[17:42:23.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.075]                         if (muffled) 
[17:42:23.075]                           invokeRestart("muffleMessage")
[17:42:23.075]                       }
[17:42:23.075]                       else if (inherits(cond, "warning")) {
[17:42:23.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.075]                         if (muffled) 
[17:42:23.075]                           invokeRestart("muffleWarning")
[17:42:23.075]                       }
[17:42:23.075]                       else if (inherits(cond, "condition")) {
[17:42:23.075]                         if (!is.null(pattern)) {
[17:42:23.075]                           computeRestarts <- base::computeRestarts
[17:42:23.075]                           grepl <- base::grepl
[17:42:23.075]                           restarts <- computeRestarts(cond)
[17:42:23.075]                           for (restart in restarts) {
[17:42:23.075]                             name <- restart$name
[17:42:23.075]                             if (is.null(name)) 
[17:42:23.075]                               next
[17:42:23.075]                             if (!grepl(pattern, name)) 
[17:42:23.075]                               next
[17:42:23.075]                             invokeRestart(restart)
[17:42:23.075]                             muffled <- TRUE
[17:42:23.075]                             break
[17:42:23.075]                           }
[17:42:23.075]                         }
[17:42:23.075]                       }
[17:42:23.075]                       invisible(muffled)
[17:42:23.075]                     }
[17:42:23.075]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.075]                   }
[17:42:23.075]                 }
[17:42:23.075]                 else {
[17:42:23.075]                   if (TRUE) {
[17:42:23.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.075]                     {
[17:42:23.075]                       inherits <- base::inherits
[17:42:23.075]                       invokeRestart <- base::invokeRestart
[17:42:23.075]                       is.null <- base::is.null
[17:42:23.075]                       muffled <- FALSE
[17:42:23.075]                       if (inherits(cond, "message")) {
[17:42:23.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.075]                         if (muffled) 
[17:42:23.075]                           invokeRestart("muffleMessage")
[17:42:23.075]                       }
[17:42:23.075]                       else if (inherits(cond, "warning")) {
[17:42:23.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.075]                         if (muffled) 
[17:42:23.075]                           invokeRestart("muffleWarning")
[17:42:23.075]                       }
[17:42:23.075]                       else if (inherits(cond, "condition")) {
[17:42:23.075]                         if (!is.null(pattern)) {
[17:42:23.075]                           computeRestarts <- base::computeRestarts
[17:42:23.075]                           grepl <- base::grepl
[17:42:23.075]                           restarts <- computeRestarts(cond)
[17:42:23.075]                           for (restart in restarts) {
[17:42:23.075]                             name <- restart$name
[17:42:23.075]                             if (is.null(name)) 
[17:42:23.075]                               next
[17:42:23.075]                             if (!grepl(pattern, name)) 
[17:42:23.075]                               next
[17:42:23.075]                             invokeRestart(restart)
[17:42:23.075]                             muffled <- TRUE
[17:42:23.075]                             break
[17:42:23.075]                           }
[17:42:23.075]                         }
[17:42:23.075]                       }
[17:42:23.075]                       invisible(muffled)
[17:42:23.075]                     }
[17:42:23.075]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.075]                   }
[17:42:23.075]                 }
[17:42:23.075]             }
[17:42:23.075]         }))
[17:42:23.075]     }, error = function(ex) {
[17:42:23.075]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.075]                 ...future.rng), started = ...future.startTime, 
[17:42:23.075]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.075]             version = "1.8"), class = "FutureResult")
[17:42:23.075]     }, finally = {
[17:42:23.075]         if (!identical(...future.workdir, getwd())) 
[17:42:23.075]             setwd(...future.workdir)
[17:42:23.075]         {
[17:42:23.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.075]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.075]             }
[17:42:23.075]             base::options(...future.oldOptions)
[17:42:23.075]             if (.Platform$OS.type == "windows") {
[17:42:23.075]                 old_names <- names(...future.oldEnvVars)
[17:42:23.075]                 envs <- base::Sys.getenv()
[17:42:23.075]                 names <- names(envs)
[17:42:23.075]                 common <- intersect(names, old_names)
[17:42:23.075]                 added <- setdiff(names, old_names)
[17:42:23.075]                 removed <- setdiff(old_names, names)
[17:42:23.075]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.075]                   envs[common]]
[17:42:23.075]                 NAMES <- toupper(changed)
[17:42:23.075]                 args <- list()
[17:42:23.075]                 for (kk in seq_along(NAMES)) {
[17:42:23.075]                   name <- changed[[kk]]
[17:42:23.075]                   NAME <- NAMES[[kk]]
[17:42:23.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.075]                     next
[17:42:23.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.075]                 }
[17:42:23.075]                 NAMES <- toupper(added)
[17:42:23.075]                 for (kk in seq_along(NAMES)) {
[17:42:23.075]                   name <- added[[kk]]
[17:42:23.075]                   NAME <- NAMES[[kk]]
[17:42:23.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.075]                     next
[17:42:23.075]                   args[[name]] <- ""
[17:42:23.075]                 }
[17:42:23.075]                 NAMES <- toupper(removed)
[17:42:23.075]                 for (kk in seq_along(NAMES)) {
[17:42:23.075]                   name <- removed[[kk]]
[17:42:23.075]                   NAME <- NAMES[[kk]]
[17:42:23.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.075]                     next
[17:42:23.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.075]                 }
[17:42:23.075]                 if (length(args) > 0) 
[17:42:23.075]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.075]             }
[17:42:23.075]             else {
[17:42:23.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.075]             }
[17:42:23.075]             {
[17:42:23.075]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.075]                   0L) {
[17:42:23.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.075]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.075]                   base::options(opts)
[17:42:23.075]                 }
[17:42:23.075]                 {
[17:42:23.075]                   {
[17:42:23.075]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.075]                     NULL
[17:42:23.075]                   }
[17:42:23.075]                   options(future.plan = NULL)
[17:42:23.075]                   if (is.na(NA_character_)) 
[17:42:23.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.075]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:23.075]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:23.075]                     envir = parent.frame()) 
[17:42:23.075]                   {
[17:42:23.075]                     if (is.function(workers)) 
[17:42:23.075]                       workers <- workers()
[17:42:23.075]                     workers <- structure(as.integer(workers), 
[17:42:23.075]                       class = class(workers))
[17:42:23.075]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:23.075]                       workers >= 1)
[17:42:23.075]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:23.075]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:23.075]                     }
[17:42:23.075]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:23.075]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:23.075]                       envir = envir)
[17:42:23.075]                     if (!future$lazy) 
[17:42:23.075]                       future <- run(future)
[17:42:23.075]                     invisible(future)
[17:42:23.075]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.075]                 }
[17:42:23.075]             }
[17:42:23.075]         }
[17:42:23.075]     })
[17:42:23.075]     if (TRUE) {
[17:42:23.075]         base::sink(type = "output", split = FALSE)
[17:42:23.075]         if (TRUE) {
[17:42:23.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.075]         }
[17:42:23.075]         else {
[17:42:23.075]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.075]         }
[17:42:23.075]         base::close(...future.stdout)
[17:42:23.075]         ...future.stdout <- NULL
[17:42:23.075]     }
[17:42:23.075]     ...future.result$conditions <- ...future.conditions
[17:42:23.075]     ...future.result$finished <- base::Sys.time()
[17:42:23.075]     ...future.result
[17:42:23.075] }
[17:42:23.078] MultisessionFuture started
[17:42:23.078] - Launch lazy future ... done
[17:42:23.078] run() for ‘MultisessionFuture’ ... done
[17:42:23.079] getGlobalsAndPackages() ...
[17:42:23.079] Searching for globals...
[17:42:23.079] - globals found: [1] ‘{’
[17:42:23.080] Searching for globals ... DONE
[17:42:23.080] Resolving globals: FALSE
[17:42:23.080] 
[17:42:23.080] 
[17:42:23.080] getGlobalsAndPackages() ... DONE
[17:42:23.080] run() for ‘Future’ ...
[17:42:23.080] - state: ‘created’
[17:42:23.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:23.096]   - Field: ‘node’
[17:42:23.096]   - Field: ‘label’
[17:42:23.096]   - Field: ‘local’
[17:42:23.096]   - Field: ‘owner’
[17:42:23.097]   - Field: ‘envir’
[17:42:23.097]   - Field: ‘workers’
[17:42:23.097]   - Field: ‘packages’
[17:42:23.097]   - Field: ‘gc’
[17:42:23.097]   - Field: ‘conditions’
[17:42:23.097]   - Field: ‘persistent’
[17:42:23.097]   - Field: ‘expr’
[17:42:23.097]   - Field: ‘uuid’
[17:42:23.097]   - Field: ‘seed’
[17:42:23.097]   - Field: ‘version’
[17:42:23.098]   - Field: ‘result’
[17:42:23.098]   - Field: ‘asynchronous’
[17:42:23.098]   - Field: ‘calls’
[17:42:23.098]   - Field: ‘globals’
[17:42:23.098]   - Field: ‘stdout’
[17:42:23.098]   - Field: ‘earlySignal’
[17:42:23.098]   - Field: ‘lazy’
[17:42:23.098]   - Field: ‘state’
[17:42:23.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:23.098] - Launch lazy future ...
[17:42:23.099] Packages needed by the future expression (n = 0): <none>
[17:42:23.099] Packages needed by future strategies (n = 0): <none>
[17:42:23.099] {
[17:42:23.099]     {
[17:42:23.099]         {
[17:42:23.099]             ...future.startTime <- base::Sys.time()
[17:42:23.099]             {
[17:42:23.099]                 {
[17:42:23.099]                   {
[17:42:23.099]                     {
[17:42:23.099]                       base::local({
[17:42:23.099]                         has_future <- base::requireNamespace("future", 
[17:42:23.099]                           quietly = TRUE)
[17:42:23.099]                         if (has_future) {
[17:42:23.099]                           ns <- base::getNamespace("future")
[17:42:23.099]                           version <- ns[[".package"]][["version"]]
[17:42:23.099]                           if (is.null(version)) 
[17:42:23.099]                             version <- utils::packageVersion("future")
[17:42:23.099]                         }
[17:42:23.099]                         else {
[17:42:23.099]                           version <- NULL
[17:42:23.099]                         }
[17:42:23.099]                         if (!has_future || version < "1.8.0") {
[17:42:23.099]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.099]                             "", base::R.version$version.string), 
[17:42:23.099]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.099]                               "release", "version")], collapse = " "), 
[17:42:23.099]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.099]                             info)
[17:42:23.099]                           info <- base::paste(info, collapse = "; ")
[17:42:23.099]                           if (!has_future) {
[17:42:23.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.099]                               info)
[17:42:23.099]                           }
[17:42:23.099]                           else {
[17:42:23.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.099]                               info, version)
[17:42:23.099]                           }
[17:42:23.099]                           base::stop(msg)
[17:42:23.099]                         }
[17:42:23.099]                       })
[17:42:23.099]                     }
[17:42:23.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.099]                     base::options(mc.cores = 1L)
[17:42:23.099]                   }
[17:42:23.099]                   options(future.plan = NULL)
[17:42:23.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.099]                 }
[17:42:23.099]                 ...future.workdir <- getwd()
[17:42:23.099]             }
[17:42:23.099]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.099]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.099]         }
[17:42:23.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.099]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.099]             base::names(...future.oldOptions))
[17:42:23.099]     }
[17:42:23.099]     if (FALSE) {
[17:42:23.099]     }
[17:42:23.099]     else {
[17:42:23.099]         if (TRUE) {
[17:42:23.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.099]                 open = "w")
[17:42:23.099]         }
[17:42:23.099]         else {
[17:42:23.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.099]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.099]         }
[17:42:23.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.099]             base::sink(type = "output", split = FALSE)
[17:42:23.099]             base::close(...future.stdout)
[17:42:23.099]         }, add = TRUE)
[17:42:23.099]     }
[17:42:23.099]     ...future.frame <- base::sys.nframe()
[17:42:23.099]     ...future.conditions <- base::list()
[17:42:23.099]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.099]     if (FALSE) {
[17:42:23.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.099]     }
[17:42:23.099]     ...future.result <- base::tryCatch({
[17:42:23.099]         base::withCallingHandlers({
[17:42:23.099]             ...future.value <- base::withVisible(base::local({
[17:42:23.099]                 ...future.makeSendCondition <- local({
[17:42:23.099]                   sendCondition <- NULL
[17:42:23.099]                   function(frame = 1L) {
[17:42:23.099]                     if (is.function(sendCondition)) 
[17:42:23.099]                       return(sendCondition)
[17:42:23.099]                     ns <- getNamespace("parallel")
[17:42:23.099]                     if (exists("sendData", mode = "function", 
[17:42:23.099]                       envir = ns)) {
[17:42:23.099]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:23.099]                         envir = ns)
[17:42:23.099]                       envir <- sys.frame(frame)
[17:42:23.099]                       master <- NULL
[17:42:23.099]                       while (!identical(envir, .GlobalEnv) && 
[17:42:23.099]                         !identical(envir, emptyenv())) {
[17:42:23.099]                         if (exists("master", mode = "list", envir = envir, 
[17:42:23.099]                           inherits = FALSE)) {
[17:42:23.099]                           master <- get("master", mode = "list", 
[17:42:23.099]                             envir = envir, inherits = FALSE)
[17:42:23.099]                           if (inherits(master, c("SOCKnode", 
[17:42:23.099]                             "SOCK0node"))) {
[17:42:23.099]                             sendCondition <<- function(cond) {
[17:42:23.099]                               data <- list(type = "VALUE", value = cond, 
[17:42:23.099]                                 success = TRUE)
[17:42:23.099]                               parallel_sendData(master, data)
[17:42:23.099]                             }
[17:42:23.099]                             return(sendCondition)
[17:42:23.099]                           }
[17:42:23.099]                         }
[17:42:23.099]                         frame <- frame + 1L
[17:42:23.099]                         envir <- sys.frame(frame)
[17:42:23.099]                       }
[17:42:23.099]                     }
[17:42:23.099]                     sendCondition <<- function(cond) NULL
[17:42:23.099]                   }
[17:42:23.099]                 })
[17:42:23.099]                 withCallingHandlers({
[17:42:23.099]                   {
[17:42:23.099]                     4
[17:42:23.099]                   }
[17:42:23.099]                 }, immediateCondition = function(cond) {
[17:42:23.099]                   sendCondition <- ...future.makeSendCondition()
[17:42:23.099]                   sendCondition(cond)
[17:42:23.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.099]                   {
[17:42:23.099]                     inherits <- base::inherits
[17:42:23.099]                     invokeRestart <- base::invokeRestart
[17:42:23.099]                     is.null <- base::is.null
[17:42:23.099]                     muffled <- FALSE
[17:42:23.099]                     if (inherits(cond, "message")) {
[17:42:23.099]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.099]                       if (muffled) 
[17:42:23.099]                         invokeRestart("muffleMessage")
[17:42:23.099]                     }
[17:42:23.099]                     else if (inherits(cond, "warning")) {
[17:42:23.099]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.099]                       if (muffled) 
[17:42:23.099]                         invokeRestart("muffleWarning")
[17:42:23.099]                     }
[17:42:23.099]                     else if (inherits(cond, "condition")) {
[17:42:23.099]                       if (!is.null(pattern)) {
[17:42:23.099]                         computeRestarts <- base::computeRestarts
[17:42:23.099]                         grepl <- base::grepl
[17:42:23.099]                         restarts <- computeRestarts(cond)
[17:42:23.099]                         for (restart in restarts) {
[17:42:23.099]                           name <- restart$name
[17:42:23.099]                           if (is.null(name)) 
[17:42:23.099]                             next
[17:42:23.099]                           if (!grepl(pattern, name)) 
[17:42:23.099]                             next
[17:42:23.099]                           invokeRestart(restart)
[17:42:23.099]                           muffled <- TRUE
[17:42:23.099]                           break
[17:42:23.099]                         }
[17:42:23.099]                       }
[17:42:23.099]                     }
[17:42:23.099]                     invisible(muffled)
[17:42:23.099]                   }
[17:42:23.099]                   muffleCondition(cond)
[17:42:23.099]                 })
[17:42:23.099]             }))
[17:42:23.099]             future::FutureResult(value = ...future.value$value, 
[17:42:23.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.099]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.099]                     ...future.globalenv.names))
[17:42:23.099]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.099]         }, condition = base::local({
[17:42:23.099]             c <- base::c
[17:42:23.099]             inherits <- base::inherits
[17:42:23.099]             invokeRestart <- base::invokeRestart
[17:42:23.099]             length <- base::length
[17:42:23.099]             list <- base::list
[17:42:23.099]             seq.int <- base::seq.int
[17:42:23.099]             signalCondition <- base::signalCondition
[17:42:23.099]             sys.calls <- base::sys.calls
[17:42:23.099]             `[[` <- base::`[[`
[17:42:23.099]             `+` <- base::`+`
[17:42:23.099]             `<<-` <- base::`<<-`
[17:42:23.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.099]                   3L)]
[17:42:23.099]             }
[17:42:23.099]             function(cond) {
[17:42:23.099]                 is_error <- inherits(cond, "error")
[17:42:23.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.099]                   NULL)
[17:42:23.099]                 if (is_error) {
[17:42:23.099]                   sessionInformation <- function() {
[17:42:23.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.099]                       search = base::search(), system = base::Sys.info())
[17:42:23.099]                   }
[17:42:23.099]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.099]                     cond$call), session = sessionInformation(), 
[17:42:23.099]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.099]                   signalCondition(cond)
[17:42:23.099]                 }
[17:42:23.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.099]                 "immediateCondition"))) {
[17:42:23.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.099]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.099]                   if (TRUE && !signal) {
[17:42:23.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.099]                     {
[17:42:23.099]                       inherits <- base::inherits
[17:42:23.099]                       invokeRestart <- base::invokeRestart
[17:42:23.099]                       is.null <- base::is.null
[17:42:23.099]                       muffled <- FALSE
[17:42:23.099]                       if (inherits(cond, "message")) {
[17:42:23.099]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.099]                         if (muffled) 
[17:42:23.099]                           invokeRestart("muffleMessage")
[17:42:23.099]                       }
[17:42:23.099]                       else if (inherits(cond, "warning")) {
[17:42:23.099]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.099]                         if (muffled) 
[17:42:23.099]                           invokeRestart("muffleWarning")
[17:42:23.099]                       }
[17:42:23.099]                       else if (inherits(cond, "condition")) {
[17:42:23.099]                         if (!is.null(pattern)) {
[17:42:23.099]                           computeRestarts <- base::computeRestarts
[17:42:23.099]                           grepl <- base::grepl
[17:42:23.099]                           restarts <- computeRestarts(cond)
[17:42:23.099]                           for (restart in restarts) {
[17:42:23.099]                             name <- restart$name
[17:42:23.099]                             if (is.null(name)) 
[17:42:23.099]                               next
[17:42:23.099]                             if (!grepl(pattern, name)) 
[17:42:23.099]                               next
[17:42:23.099]                             invokeRestart(restart)
[17:42:23.099]                             muffled <- TRUE
[17:42:23.099]                             break
[17:42:23.099]                           }
[17:42:23.099]                         }
[17:42:23.099]                       }
[17:42:23.099]                       invisible(muffled)
[17:42:23.099]                     }
[17:42:23.099]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.099]                   }
[17:42:23.099]                 }
[17:42:23.099]                 else {
[17:42:23.099]                   if (TRUE) {
[17:42:23.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.099]                     {
[17:42:23.099]                       inherits <- base::inherits
[17:42:23.099]                       invokeRestart <- base::invokeRestart
[17:42:23.099]                       is.null <- base::is.null
[17:42:23.099]                       muffled <- FALSE
[17:42:23.099]                       if (inherits(cond, "message")) {
[17:42:23.099]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.099]                         if (muffled) 
[17:42:23.099]                           invokeRestart("muffleMessage")
[17:42:23.099]                       }
[17:42:23.099]                       else if (inherits(cond, "warning")) {
[17:42:23.099]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.099]                         if (muffled) 
[17:42:23.099]                           invokeRestart("muffleWarning")
[17:42:23.099]                       }
[17:42:23.099]                       else if (inherits(cond, "condition")) {
[17:42:23.099]                         if (!is.null(pattern)) {
[17:42:23.099]                           computeRestarts <- base::computeRestarts
[17:42:23.099]                           grepl <- base::grepl
[17:42:23.099]                           restarts <- computeRestarts(cond)
[17:42:23.099]                           for (restart in restarts) {
[17:42:23.099]                             name <- restart$name
[17:42:23.099]                             if (is.null(name)) 
[17:42:23.099]                               next
[17:42:23.099]                             if (!grepl(pattern, name)) 
[17:42:23.099]                               next
[17:42:23.099]                             invokeRestart(restart)
[17:42:23.099]                             muffled <- TRUE
[17:42:23.099]                             break
[17:42:23.099]                           }
[17:42:23.099]                         }
[17:42:23.099]                       }
[17:42:23.099]                       invisible(muffled)
[17:42:23.099]                     }
[17:42:23.099]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.099]                   }
[17:42:23.099]                 }
[17:42:23.099]             }
[17:42:23.099]         }))
[17:42:23.099]     }, error = function(ex) {
[17:42:23.099]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.099]                 ...future.rng), started = ...future.startTime, 
[17:42:23.099]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.099]             version = "1.8"), class = "FutureResult")
[17:42:23.099]     }, finally = {
[17:42:23.099]         if (!identical(...future.workdir, getwd())) 
[17:42:23.099]             setwd(...future.workdir)
[17:42:23.099]         {
[17:42:23.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.099]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.099]             }
[17:42:23.099]             base::options(...future.oldOptions)
[17:42:23.099]             if (.Platform$OS.type == "windows") {
[17:42:23.099]                 old_names <- names(...future.oldEnvVars)
[17:42:23.099]                 envs <- base::Sys.getenv()
[17:42:23.099]                 names <- names(envs)
[17:42:23.099]                 common <- intersect(names, old_names)
[17:42:23.099]                 added <- setdiff(names, old_names)
[17:42:23.099]                 removed <- setdiff(old_names, names)
[17:42:23.099]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.099]                   envs[common]]
[17:42:23.099]                 NAMES <- toupper(changed)
[17:42:23.099]                 args <- list()
[17:42:23.099]                 for (kk in seq_along(NAMES)) {
[17:42:23.099]                   name <- changed[[kk]]
[17:42:23.099]                   NAME <- NAMES[[kk]]
[17:42:23.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.099]                     next
[17:42:23.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.099]                 }
[17:42:23.099]                 NAMES <- toupper(added)
[17:42:23.099]                 for (kk in seq_along(NAMES)) {
[17:42:23.099]                   name <- added[[kk]]
[17:42:23.099]                   NAME <- NAMES[[kk]]
[17:42:23.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.099]                     next
[17:42:23.099]                   args[[name]] <- ""
[17:42:23.099]                 }
[17:42:23.099]                 NAMES <- toupper(removed)
[17:42:23.099]                 for (kk in seq_along(NAMES)) {
[17:42:23.099]                   name <- removed[[kk]]
[17:42:23.099]                   NAME <- NAMES[[kk]]
[17:42:23.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.099]                     next
[17:42:23.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.099]                 }
[17:42:23.099]                 if (length(args) > 0) 
[17:42:23.099]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.099]             }
[17:42:23.099]             else {
[17:42:23.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.099]             }
[17:42:23.099]             {
[17:42:23.099]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.099]                   0L) {
[17:42:23.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.099]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.099]                   base::options(opts)
[17:42:23.099]                 }
[17:42:23.099]                 {
[17:42:23.099]                   {
[17:42:23.099]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.099]                     NULL
[17:42:23.099]                   }
[17:42:23.099]                   options(future.plan = NULL)
[17:42:23.099]                   if (is.na(NA_character_)) 
[17:42:23.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.099]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:23.099]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:23.099]                     envir = parent.frame()) 
[17:42:23.099]                   {
[17:42:23.099]                     if (is.function(workers)) 
[17:42:23.099]                       workers <- workers()
[17:42:23.099]                     workers <- structure(as.integer(workers), 
[17:42:23.099]                       class = class(workers))
[17:42:23.099]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:23.099]                       workers >= 1)
[17:42:23.099]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:23.099]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:23.099]                     }
[17:42:23.099]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:23.099]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:23.099]                       envir = envir)
[17:42:23.099]                     if (!future$lazy) 
[17:42:23.099]                       future <- run(future)
[17:42:23.099]                     invisible(future)
[17:42:23.099]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.099]                 }
[17:42:23.099]             }
[17:42:23.099]         }
[17:42:23.099]     })
[17:42:23.099]     if (TRUE) {
[17:42:23.099]         base::sink(type = "output", split = FALSE)
[17:42:23.099]         if (TRUE) {
[17:42:23.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.099]         }
[17:42:23.099]         else {
[17:42:23.099]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.099]         }
[17:42:23.099]         base::close(...future.stdout)
[17:42:23.099]         ...future.stdout <- NULL
[17:42:23.099]     }
[17:42:23.099]     ...future.result$conditions <- ...future.conditions
[17:42:23.099]     ...future.result$finished <- base::Sys.time()
[17:42:23.099]     ...future.result
[17:42:23.099] }
[17:42:23.104] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:23.115] receiveMessageFromWorker() for ClusterFuture ...
[17:42:23.115] - Validating connection of MultisessionFuture
[17:42:23.116] - received message: FutureResult
[17:42:23.116] - Received FutureResult
[17:42:23.116] - Erased future from FutureRegistry
[17:42:23.116] result() for ClusterFuture ...
[17:42:23.116] - result already collected: FutureResult
[17:42:23.116] result() for ClusterFuture ... done
[17:42:23.116] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:23.116] result() for ClusterFuture ...
[17:42:23.117] - result already collected: FutureResult
[17:42:23.117] result() for ClusterFuture ... done
[17:42:23.117] result() for ClusterFuture ...
[17:42:23.117] - result already collected: FutureResult
[17:42:23.117] result() for ClusterFuture ... done
[17:42:23.118] MultisessionFuture started
[17:42:23.118] - Launch lazy future ... done
[17:42:23.118] run() for ‘MultisessionFuture’ ... done
<environment: 0x55bef952a078> 
<environment: 0x55bef86dc4d0> 
[17:42:23.124] receiveMessageFromWorker() for ClusterFuture ...
[17:42:23.125] - Validating connection of MultisessionFuture
[17:42:23.125] - received message: FutureResult
[17:42:23.125] - Received FutureResult
[17:42:23.125] - Erased future from FutureRegistry
[17:42:23.125] result() for ClusterFuture ...
[17:42:23.125] - result already collected: FutureResult
[17:42:23.125] result() for ClusterFuture ... done
[17:42:23.125] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[17:42:23.137] resolve() on environment ...
[17:42:23.137]  recursive: 0
[17:42:23.138]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[17:42:23.138] signalConditionsASAP(numeric, pos=1) ...
[17:42:23.138] - nx: 4
[17:42:23.138] - relay: TRUE
[17:42:23.138] - stdout: TRUE
[17:42:23.138] - signal: TRUE
[17:42:23.138] - resignal: FALSE
[17:42:23.138] - force: TRUE
[17:42:23.138] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:23.139] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:23.139]  - until=2
[17:42:23.139]  - relaying element #2
[17:42:23.139] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:23.139] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:23.139] signalConditionsASAP(NULL, pos=1) ... done
[17:42:23.139]  length: 3 (resolved future 1)
[17:42:23.139] Future #2
[17:42:23.139] result() for ClusterFuture ...
[17:42:23.139] - result already collected: FutureResult
[17:42:23.140] result() for ClusterFuture ... done
[17:42:23.140] result() for ClusterFuture ...
[17:42:23.140] - result already collected: FutureResult
[17:42:23.140] result() for ClusterFuture ... done
[17:42:23.140] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:23.140] - nx: 4
[17:42:23.140] - relay: TRUE
[17:42:23.140] - stdout: TRUE
[17:42:23.140] - signal: TRUE
[17:42:23.140] - resignal: FALSE
[17:42:23.140] - force: TRUE
[17:42:23.141] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[17:42:23.141] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[17:42:23.141]  - until=2
[17:42:23.141]  - relaying element #2
[17:42:23.141] result() for ClusterFuture ...
[17:42:23.141] - result already collected: FutureResult
[17:42:23.141] result() for ClusterFuture ... done
[17:42:23.141] result() for ClusterFuture ...
[17:42:23.141] - result already collected: FutureResult
[17:42:23.141] result() for ClusterFuture ... done
[17:42:23.141] result() for ClusterFuture ...
[17:42:23.142] - result already collected: FutureResult
[17:42:23.142] result() for ClusterFuture ... done
[17:42:23.142] result() for ClusterFuture ...
[17:42:23.142] - result already collected: FutureResult
[17:42:23.142] result() for ClusterFuture ... done
[17:42:23.142] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:23.142] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:23.142] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:23.142]  length: 2 (resolved future 2)
[17:42:23.142] Future #3
[17:42:23.142] result() for ClusterFuture ...
[17:42:23.143] - result already collected: FutureResult
[17:42:23.143] result() for ClusterFuture ... done
[17:42:23.143] result() for ClusterFuture ...
[17:42:23.143] - result already collected: FutureResult
[17:42:23.143] result() for ClusterFuture ... done
[17:42:23.143] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:23.143] - nx: 4
[17:42:23.143] - relay: TRUE
[17:42:23.143] - stdout: TRUE
[17:42:23.143] - signal: TRUE
[17:42:23.143] - resignal: FALSE
[17:42:23.144] - force: TRUE
[17:42:23.144] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[17:42:23.144] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[17:42:23.144]  - until=3
[17:42:23.144]  - relaying element #3
[17:42:23.144] result() for ClusterFuture ...
[17:42:23.144] - result already collected: FutureResult
[17:42:23.144] result() for ClusterFuture ... done
[17:42:23.144] result() for ClusterFuture ...
[17:42:23.144] - result already collected: FutureResult
[17:42:23.144] result() for ClusterFuture ... done
[17:42:23.145] result() for ClusterFuture ...
[17:42:23.145] - result already collected: FutureResult
[17:42:23.145] result() for ClusterFuture ... done
[17:42:23.145] result() for ClusterFuture ...
[17:42:23.145] - result already collected: FutureResult
[17:42:23.145] result() for ClusterFuture ... done
[17:42:23.145] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:23.145] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:23.145] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:23.145]  length: 1 (resolved future 3)
[17:42:23.166] receiveMessageFromWorker() for ClusterFuture ...
[17:42:23.167] - Validating connection of MultisessionFuture
[17:42:23.167] - received message: FutureResult
[17:42:23.167] - Received FutureResult
[17:42:23.167] - Erased future from FutureRegistry
[17:42:23.167] result() for ClusterFuture ...
[17:42:23.167] - result already collected: FutureResult
[17:42:23.167] result() for ClusterFuture ... done
[17:42:23.167] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:23.168] Future #4
[17:42:23.168] result() for ClusterFuture ...
[17:42:23.168] - result already collected: FutureResult
[17:42:23.168] result() for ClusterFuture ... done
[17:42:23.168] result() for ClusterFuture ...
[17:42:23.168] - result already collected: FutureResult
[17:42:23.168] result() for ClusterFuture ... done
[17:42:23.168] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:23.168] - nx: 4
[17:42:23.168] - relay: TRUE
[17:42:23.169] - stdout: TRUE
[17:42:23.169] - signal: TRUE
[17:42:23.169] - resignal: FALSE
[17:42:23.169] - force: TRUE
[17:42:23.169] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[17:42:23.169] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[17:42:23.169]  - until=4
[17:42:23.169]  - relaying element #4
[17:42:23.169] result() for ClusterFuture ...
[17:42:23.169] - result already collected: FutureResult
[17:42:23.169] result() for ClusterFuture ... done
[17:42:23.169] result() for ClusterFuture ...
[17:42:23.170] - result already collected: FutureResult
[17:42:23.170] result() for ClusterFuture ... done
[17:42:23.170] result() for ClusterFuture ...
[17:42:23.170] - result already collected: FutureResult
[17:42:23.170] result() for ClusterFuture ... done
[17:42:23.170] result() for ClusterFuture ...
[17:42:23.170] - result already collected: FutureResult
[17:42:23.170] result() for ClusterFuture ... done
[17:42:23.170] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:23.170] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:23.171] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:23.171]  length: 0 (resolved future 4)
[17:42:23.171] Relaying remaining futures
[17:42:23.171] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.171] - nx: 4
[17:42:23.171] - relay: TRUE
[17:42:23.171] - stdout: TRUE
[17:42:23.171] - signal: TRUE
[17:42:23.171] - resignal: FALSE
[17:42:23.171] - force: TRUE
[17:42:23.171] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:23.172] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[17:42:23.172] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[17:42:23.172] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[17:42:23.172] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.172] resolve() on environment ... DONE
[17:42:23.172] result() for ClusterFuture ...
[17:42:23.172] - result already collected: FutureResult
[17:42:23.172] result() for ClusterFuture ... done
[17:42:23.172] result() for ClusterFuture ...
[17:42:23.173] - result already collected: FutureResult
[17:42:23.173] result() for ClusterFuture ... done
[17:42:23.173] result() for ClusterFuture ...
[17:42:23.173] - result already collected: FutureResult
[17:42:23.173] result() for ClusterFuture ... done
[17:42:23.173] result() for ClusterFuture ...
[17:42:23.173] - result already collected: FutureResult
[17:42:23.173] result() for ClusterFuture ... done
[17:42:23.173] result() for ClusterFuture ...
[17:42:23.173] - result already collected: FutureResult
[17:42:23.173] result() for ClusterFuture ... done
[17:42:23.174] result() for ClusterFuture ...
[17:42:23.174] - result already collected: FutureResult
[17:42:23.174] result() for ClusterFuture ... done
<environment: 0x55bef8398680> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[17:42:23.175] plan(): Setting new future strategy stack:
[17:42:23.175] List of future strategies:
[17:42:23.175] 1. multicore:
[17:42:23.175]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.175]    - tweaked: FALSE
[17:42:23.175]    - call: plan(strategy)
[17:42:23.180] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:42:23.180] getGlobalsAndPackages() ...
[17:42:23.180] Searching for globals...
[17:42:23.181] 
[17:42:23.181] Searching for globals ... DONE
[17:42:23.181] - globals: [0] <none>
[17:42:23.181] getGlobalsAndPackages() ... DONE
[17:42:23.181] run() for ‘Future’ ...
[17:42:23.182] - state: ‘created’
[17:42:23.182] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.186] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.186]   - Field: ‘label’
[17:42:23.187]   - Field: ‘local’
[17:42:23.187]   - Field: ‘owner’
[17:42:23.187]   - Field: ‘envir’
[17:42:23.187]   - Field: ‘workers’
[17:42:23.187]   - Field: ‘packages’
[17:42:23.187]   - Field: ‘gc’
[17:42:23.187]   - Field: ‘job’
[17:42:23.187]   - Field: ‘conditions’
[17:42:23.187]   - Field: ‘expr’
[17:42:23.187]   - Field: ‘uuid’
[17:42:23.188]   - Field: ‘seed’
[17:42:23.188]   - Field: ‘version’
[17:42:23.188]   - Field: ‘result’
[17:42:23.188]   - Field: ‘asynchronous’
[17:42:23.188]   - Field: ‘calls’
[17:42:23.188]   - Field: ‘globals’
[17:42:23.188]   - Field: ‘stdout’
[17:42:23.188]   - Field: ‘earlySignal’
[17:42:23.188]   - Field: ‘lazy’
[17:42:23.188]   - Field: ‘state’
[17:42:23.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.189] - Launch lazy future ...
[17:42:23.189] Packages needed by the future expression (n = 0): <none>
[17:42:23.189] Packages needed by future strategies (n = 0): <none>
[17:42:23.189] {
[17:42:23.189]     {
[17:42:23.189]         {
[17:42:23.189]             ...future.startTime <- base::Sys.time()
[17:42:23.189]             {
[17:42:23.189]                 {
[17:42:23.189]                   {
[17:42:23.189]                     {
[17:42:23.189]                       base::local({
[17:42:23.189]                         has_future <- base::requireNamespace("future", 
[17:42:23.189]                           quietly = TRUE)
[17:42:23.189]                         if (has_future) {
[17:42:23.189]                           ns <- base::getNamespace("future")
[17:42:23.189]                           version <- ns[[".package"]][["version"]]
[17:42:23.189]                           if (is.null(version)) 
[17:42:23.189]                             version <- utils::packageVersion("future")
[17:42:23.189]                         }
[17:42:23.189]                         else {
[17:42:23.189]                           version <- NULL
[17:42:23.189]                         }
[17:42:23.189]                         if (!has_future || version < "1.8.0") {
[17:42:23.189]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.189]                             "", base::R.version$version.string), 
[17:42:23.189]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.189]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.189]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.189]                               "release", "version")], collapse = " "), 
[17:42:23.189]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.189]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.189]                             info)
[17:42:23.189]                           info <- base::paste(info, collapse = "; ")
[17:42:23.189]                           if (!has_future) {
[17:42:23.189]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.189]                               info)
[17:42:23.189]                           }
[17:42:23.189]                           else {
[17:42:23.189]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.189]                               info, version)
[17:42:23.189]                           }
[17:42:23.189]                           base::stop(msg)
[17:42:23.189]                         }
[17:42:23.189]                       })
[17:42:23.189]                     }
[17:42:23.189]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.189]                     base::options(mc.cores = 1L)
[17:42:23.189]                   }
[17:42:23.189]                   options(future.plan = NULL)
[17:42:23.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.189]                 }
[17:42:23.189]                 ...future.workdir <- getwd()
[17:42:23.189]             }
[17:42:23.189]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.189]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.189]         }
[17:42:23.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.189]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.189]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.189]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.189]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.189]             base::names(...future.oldOptions))
[17:42:23.189]     }
[17:42:23.189]     if (FALSE) {
[17:42:23.189]     }
[17:42:23.189]     else {
[17:42:23.189]         if (TRUE) {
[17:42:23.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.189]                 open = "w")
[17:42:23.189]         }
[17:42:23.189]         else {
[17:42:23.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.189]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.189]         }
[17:42:23.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.189]             base::sink(type = "output", split = FALSE)
[17:42:23.189]             base::close(...future.stdout)
[17:42:23.189]         }, add = TRUE)
[17:42:23.189]     }
[17:42:23.189]     ...future.frame <- base::sys.nframe()
[17:42:23.189]     ...future.conditions <- base::list()
[17:42:23.189]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.189]     if (FALSE) {
[17:42:23.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.189]     }
[17:42:23.189]     ...future.result <- base::tryCatch({
[17:42:23.189]         base::withCallingHandlers({
[17:42:23.189]             ...future.value <- base::withVisible(base::local({
[17:42:23.189]                 withCallingHandlers({
[17:42:23.189]                   2
[17:42:23.189]                 }, immediateCondition = function(cond) {
[17:42:23.189]                   save_rds <- function (object, pathname, ...) 
[17:42:23.189]                   {
[17:42:23.189]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.189]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.189]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.189]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.189]                         fi_tmp[["mtime"]])
[17:42:23.189]                     }
[17:42:23.189]                     tryCatch({
[17:42:23.189]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.189]                     }, error = function(ex) {
[17:42:23.189]                       msg <- conditionMessage(ex)
[17:42:23.189]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.189]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.189]                         fi_tmp[["mtime"]], msg)
[17:42:23.189]                       ex$message <- msg
[17:42:23.189]                       stop(ex)
[17:42:23.189]                     })
[17:42:23.189]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.189]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.189]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.189]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.189]                       fi <- file.info(pathname)
[17:42:23.189]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.189]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.189]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.189]                         fi[["size"]], fi[["mtime"]])
[17:42:23.189]                       stop(msg)
[17:42:23.189]                     }
[17:42:23.189]                     invisible(pathname)
[17:42:23.189]                   }
[17:42:23.189]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.189]                     rootPath = tempdir()) 
[17:42:23.189]                   {
[17:42:23.189]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.189]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.189]                       tmpdir = path, fileext = ".rds")
[17:42:23.189]                     save_rds(obj, file)
[17:42:23.189]                   }
[17:42:23.189]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.189]                   {
[17:42:23.189]                     inherits <- base::inherits
[17:42:23.189]                     invokeRestart <- base::invokeRestart
[17:42:23.189]                     is.null <- base::is.null
[17:42:23.189]                     muffled <- FALSE
[17:42:23.189]                     if (inherits(cond, "message")) {
[17:42:23.189]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.189]                       if (muffled) 
[17:42:23.189]                         invokeRestart("muffleMessage")
[17:42:23.189]                     }
[17:42:23.189]                     else if (inherits(cond, "warning")) {
[17:42:23.189]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.189]                       if (muffled) 
[17:42:23.189]                         invokeRestart("muffleWarning")
[17:42:23.189]                     }
[17:42:23.189]                     else if (inherits(cond, "condition")) {
[17:42:23.189]                       if (!is.null(pattern)) {
[17:42:23.189]                         computeRestarts <- base::computeRestarts
[17:42:23.189]                         grepl <- base::grepl
[17:42:23.189]                         restarts <- computeRestarts(cond)
[17:42:23.189]                         for (restart in restarts) {
[17:42:23.189]                           name <- restart$name
[17:42:23.189]                           if (is.null(name)) 
[17:42:23.189]                             next
[17:42:23.189]                           if (!grepl(pattern, name)) 
[17:42:23.189]                             next
[17:42:23.189]                           invokeRestart(restart)
[17:42:23.189]                           muffled <- TRUE
[17:42:23.189]                           break
[17:42:23.189]                         }
[17:42:23.189]                       }
[17:42:23.189]                     }
[17:42:23.189]                     invisible(muffled)
[17:42:23.189]                   }
[17:42:23.189]                   muffleCondition(cond)
[17:42:23.189]                 })
[17:42:23.189]             }))
[17:42:23.189]             future::FutureResult(value = ...future.value$value, 
[17:42:23.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.189]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.189]                     ...future.globalenv.names))
[17:42:23.189]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.189]         }, condition = base::local({
[17:42:23.189]             c <- base::c
[17:42:23.189]             inherits <- base::inherits
[17:42:23.189]             invokeRestart <- base::invokeRestart
[17:42:23.189]             length <- base::length
[17:42:23.189]             list <- base::list
[17:42:23.189]             seq.int <- base::seq.int
[17:42:23.189]             signalCondition <- base::signalCondition
[17:42:23.189]             sys.calls <- base::sys.calls
[17:42:23.189]             `[[` <- base::`[[`
[17:42:23.189]             `+` <- base::`+`
[17:42:23.189]             `<<-` <- base::`<<-`
[17:42:23.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.189]                   3L)]
[17:42:23.189]             }
[17:42:23.189]             function(cond) {
[17:42:23.189]                 is_error <- inherits(cond, "error")
[17:42:23.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.189]                   NULL)
[17:42:23.189]                 if (is_error) {
[17:42:23.189]                   sessionInformation <- function() {
[17:42:23.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.189]                       search = base::search(), system = base::Sys.info())
[17:42:23.189]                   }
[17:42:23.189]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.189]                     cond$call), session = sessionInformation(), 
[17:42:23.189]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.189]                   signalCondition(cond)
[17:42:23.189]                 }
[17:42:23.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.189]                 "immediateCondition"))) {
[17:42:23.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.189]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.189]                   if (TRUE && !signal) {
[17:42:23.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.189]                     {
[17:42:23.189]                       inherits <- base::inherits
[17:42:23.189]                       invokeRestart <- base::invokeRestart
[17:42:23.189]                       is.null <- base::is.null
[17:42:23.189]                       muffled <- FALSE
[17:42:23.189]                       if (inherits(cond, "message")) {
[17:42:23.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.189]                         if (muffled) 
[17:42:23.189]                           invokeRestart("muffleMessage")
[17:42:23.189]                       }
[17:42:23.189]                       else if (inherits(cond, "warning")) {
[17:42:23.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.189]                         if (muffled) 
[17:42:23.189]                           invokeRestart("muffleWarning")
[17:42:23.189]                       }
[17:42:23.189]                       else if (inherits(cond, "condition")) {
[17:42:23.189]                         if (!is.null(pattern)) {
[17:42:23.189]                           computeRestarts <- base::computeRestarts
[17:42:23.189]                           grepl <- base::grepl
[17:42:23.189]                           restarts <- computeRestarts(cond)
[17:42:23.189]                           for (restart in restarts) {
[17:42:23.189]                             name <- restart$name
[17:42:23.189]                             if (is.null(name)) 
[17:42:23.189]                               next
[17:42:23.189]                             if (!grepl(pattern, name)) 
[17:42:23.189]                               next
[17:42:23.189]                             invokeRestart(restart)
[17:42:23.189]                             muffled <- TRUE
[17:42:23.189]                             break
[17:42:23.189]                           }
[17:42:23.189]                         }
[17:42:23.189]                       }
[17:42:23.189]                       invisible(muffled)
[17:42:23.189]                     }
[17:42:23.189]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.189]                   }
[17:42:23.189]                 }
[17:42:23.189]                 else {
[17:42:23.189]                   if (TRUE) {
[17:42:23.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.189]                     {
[17:42:23.189]                       inherits <- base::inherits
[17:42:23.189]                       invokeRestart <- base::invokeRestart
[17:42:23.189]                       is.null <- base::is.null
[17:42:23.189]                       muffled <- FALSE
[17:42:23.189]                       if (inherits(cond, "message")) {
[17:42:23.189]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.189]                         if (muffled) 
[17:42:23.189]                           invokeRestart("muffleMessage")
[17:42:23.189]                       }
[17:42:23.189]                       else if (inherits(cond, "warning")) {
[17:42:23.189]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.189]                         if (muffled) 
[17:42:23.189]                           invokeRestart("muffleWarning")
[17:42:23.189]                       }
[17:42:23.189]                       else if (inherits(cond, "condition")) {
[17:42:23.189]                         if (!is.null(pattern)) {
[17:42:23.189]                           computeRestarts <- base::computeRestarts
[17:42:23.189]                           grepl <- base::grepl
[17:42:23.189]                           restarts <- computeRestarts(cond)
[17:42:23.189]                           for (restart in restarts) {
[17:42:23.189]                             name <- restart$name
[17:42:23.189]                             if (is.null(name)) 
[17:42:23.189]                               next
[17:42:23.189]                             if (!grepl(pattern, name)) 
[17:42:23.189]                               next
[17:42:23.189]                             invokeRestart(restart)
[17:42:23.189]                             muffled <- TRUE
[17:42:23.189]                             break
[17:42:23.189]                           }
[17:42:23.189]                         }
[17:42:23.189]                       }
[17:42:23.189]                       invisible(muffled)
[17:42:23.189]                     }
[17:42:23.189]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.189]                   }
[17:42:23.189]                 }
[17:42:23.189]             }
[17:42:23.189]         }))
[17:42:23.189]     }, error = function(ex) {
[17:42:23.189]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.189]                 ...future.rng), started = ...future.startTime, 
[17:42:23.189]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.189]             version = "1.8"), class = "FutureResult")
[17:42:23.189]     }, finally = {
[17:42:23.189]         if (!identical(...future.workdir, getwd())) 
[17:42:23.189]             setwd(...future.workdir)
[17:42:23.189]         {
[17:42:23.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.189]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.189]             }
[17:42:23.189]             base::options(...future.oldOptions)
[17:42:23.189]             if (.Platform$OS.type == "windows") {
[17:42:23.189]                 old_names <- names(...future.oldEnvVars)
[17:42:23.189]                 envs <- base::Sys.getenv()
[17:42:23.189]                 names <- names(envs)
[17:42:23.189]                 common <- intersect(names, old_names)
[17:42:23.189]                 added <- setdiff(names, old_names)
[17:42:23.189]                 removed <- setdiff(old_names, names)
[17:42:23.189]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.189]                   envs[common]]
[17:42:23.189]                 NAMES <- toupper(changed)
[17:42:23.189]                 args <- list()
[17:42:23.189]                 for (kk in seq_along(NAMES)) {
[17:42:23.189]                   name <- changed[[kk]]
[17:42:23.189]                   NAME <- NAMES[[kk]]
[17:42:23.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.189]                     next
[17:42:23.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.189]                 }
[17:42:23.189]                 NAMES <- toupper(added)
[17:42:23.189]                 for (kk in seq_along(NAMES)) {
[17:42:23.189]                   name <- added[[kk]]
[17:42:23.189]                   NAME <- NAMES[[kk]]
[17:42:23.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.189]                     next
[17:42:23.189]                   args[[name]] <- ""
[17:42:23.189]                 }
[17:42:23.189]                 NAMES <- toupper(removed)
[17:42:23.189]                 for (kk in seq_along(NAMES)) {
[17:42:23.189]                   name <- removed[[kk]]
[17:42:23.189]                   NAME <- NAMES[[kk]]
[17:42:23.189]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.189]                     next
[17:42:23.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.189]                 }
[17:42:23.189]                 if (length(args) > 0) 
[17:42:23.189]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.189]             }
[17:42:23.189]             else {
[17:42:23.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.189]             }
[17:42:23.189]             {
[17:42:23.189]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.189]                   0L) {
[17:42:23.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.189]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.189]                   base::options(opts)
[17:42:23.189]                 }
[17:42:23.189]                 {
[17:42:23.189]                   {
[17:42:23.189]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.189]                     NULL
[17:42:23.189]                   }
[17:42:23.189]                   options(future.plan = NULL)
[17:42:23.189]                   if (is.na(NA_character_)) 
[17:42:23.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.189]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.189]                     envir = parent.frame()) 
[17:42:23.189]                   {
[17:42:23.189]                     default_workers <- missing(workers)
[17:42:23.189]                     if (is.function(workers)) 
[17:42:23.189]                       workers <- workers()
[17:42:23.189]                     workers <- structure(as.integer(workers), 
[17:42:23.189]                       class = class(workers))
[17:42:23.189]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.189]                       1L)
[17:42:23.189]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.189]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.189]                       if (default_workers) 
[17:42:23.189]                         supportsMulticore(warn = TRUE)
[17:42:23.189]                       return(sequential(..., envir = envir))
[17:42:23.189]                     }
[17:42:23.189]                     oopts <- options(mc.cores = workers)
[17:42:23.189]                     on.exit(options(oopts))
[17:42:23.189]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.189]                       envir = envir)
[17:42:23.189]                     if (!future$lazy) 
[17:42:23.189]                       future <- run(future)
[17:42:23.189]                     invisible(future)
[17:42:23.189]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.189]                 }
[17:42:23.189]             }
[17:42:23.189]         }
[17:42:23.189]     })
[17:42:23.189]     if (TRUE) {
[17:42:23.189]         base::sink(type = "output", split = FALSE)
[17:42:23.189]         if (TRUE) {
[17:42:23.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.189]         }
[17:42:23.189]         else {
[17:42:23.189]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.189]         }
[17:42:23.189]         base::close(...future.stdout)
[17:42:23.189]         ...future.stdout <- NULL
[17:42:23.189]     }
[17:42:23.189]     ...future.result$conditions <- ...future.conditions
[17:42:23.189]     ...future.result$finished <- base::Sys.time()
[17:42:23.189]     ...future.result
[17:42:23.189] }
[17:42:23.192] requestCore(): workers = 2
[17:42:23.194] MulticoreFuture started
[17:42:23.195] - Launch lazy future ... done
[17:42:23.195] run() for ‘MulticoreFuture’ ... done
[17:42:23.195] getGlobalsAndPackages() ...
[17:42:23.195] Searching for globals...
[17:42:23.195] plan(): Setting new future strategy stack:
[17:42:23.196] 
[17:42:23.196] List of future strategies:
[17:42:23.196] 1. sequential:
[17:42:23.196]    - args: function (..., envir = parent.frame())
[17:42:23.196]    - tweaked: FALSE
[17:42:23.196]    - call: NULL
[17:42:23.196] Searching for globals ... DONE
[17:42:23.196] - globals: [0] <none>
[17:42:23.196] plan(): nbrOfWorkers() = 1
[17:42:23.197] getGlobalsAndPackages() ... DONE
[17:42:23.197] run() for ‘Future’ ...
[17:42:23.197] - state: ‘created’
[17:42:23.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.198] plan(): Setting new future strategy stack:
[17:42:23.198] List of future strategies:
[17:42:23.198] 1. multicore:
[17:42:23.198]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.198]    - tweaked: FALSE
[17:42:23.198]    - call: plan(strategy)
[17:42:23.203] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.203] plan(): nbrOfWorkers() = 2
[17:42:23.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.204]   - Field: ‘label’
[17:42:23.204]   - Field: ‘local’
[17:42:23.204]   - Field: ‘owner’
[17:42:23.204]   - Field: ‘envir’
[17:42:23.204]   - Field: ‘workers’
[17:42:23.204]   - Field: ‘packages’
[17:42:23.205]   - Field: ‘gc’
[17:42:23.205]   - Field: ‘job’
[17:42:23.205]   - Field: ‘conditions’
[17:42:23.205]   - Field: ‘expr’
[17:42:23.205]   - Field: ‘uuid’
[17:42:23.205]   - Field: ‘seed’
[17:42:23.205]   - Field: ‘version’
[17:42:23.206]   - Field: ‘result’
[17:42:23.206]   - Field: ‘asynchronous’
[17:42:23.206]   - Field: ‘calls’
[17:42:23.206]   - Field: ‘globals’
[17:42:23.206]   - Field: ‘stdout’
[17:42:23.206]   - Field: ‘earlySignal’
[17:42:23.206]   - Field: ‘lazy’
[17:42:23.207]   - Field: ‘state’
[17:42:23.207] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.207] - Launch lazy future ...
[17:42:23.207] Packages needed by the future expression (n = 0): <none>
[17:42:23.208] Packages needed by future strategies (n = 0): <none>
[17:42:23.208] {
[17:42:23.208]     {
[17:42:23.208]         {
[17:42:23.208]             ...future.startTime <- base::Sys.time()
[17:42:23.208]             {
[17:42:23.208]                 {
[17:42:23.208]                   {
[17:42:23.208]                     {
[17:42:23.208]                       base::local({
[17:42:23.208]                         has_future <- base::requireNamespace("future", 
[17:42:23.208]                           quietly = TRUE)
[17:42:23.208]                         if (has_future) {
[17:42:23.208]                           ns <- base::getNamespace("future")
[17:42:23.208]                           version <- ns[[".package"]][["version"]]
[17:42:23.208]                           if (is.null(version)) 
[17:42:23.208]                             version <- utils::packageVersion("future")
[17:42:23.208]                         }
[17:42:23.208]                         else {
[17:42:23.208]                           version <- NULL
[17:42:23.208]                         }
[17:42:23.208]                         if (!has_future || version < "1.8.0") {
[17:42:23.208]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.208]                             "", base::R.version$version.string), 
[17:42:23.208]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.208]                               "release", "version")], collapse = " "), 
[17:42:23.208]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.208]                             info)
[17:42:23.208]                           info <- base::paste(info, collapse = "; ")
[17:42:23.208]                           if (!has_future) {
[17:42:23.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.208]                               info)
[17:42:23.208]                           }
[17:42:23.208]                           else {
[17:42:23.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.208]                               info, version)
[17:42:23.208]                           }
[17:42:23.208]                           base::stop(msg)
[17:42:23.208]                         }
[17:42:23.208]                       })
[17:42:23.208]                     }
[17:42:23.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.208]                     base::options(mc.cores = 1L)
[17:42:23.208]                   }
[17:42:23.208]                   options(future.plan = NULL)
[17:42:23.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.208]                 }
[17:42:23.208]                 ...future.workdir <- getwd()
[17:42:23.208]             }
[17:42:23.208]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.208]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.208]         }
[17:42:23.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.208]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.208]             base::names(...future.oldOptions))
[17:42:23.208]     }
[17:42:23.208]     if (FALSE) {
[17:42:23.208]     }
[17:42:23.208]     else {
[17:42:23.208]         if (TRUE) {
[17:42:23.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.208]                 open = "w")
[17:42:23.208]         }
[17:42:23.208]         else {
[17:42:23.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.208]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.208]         }
[17:42:23.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.208]             base::sink(type = "output", split = FALSE)
[17:42:23.208]             base::close(...future.stdout)
[17:42:23.208]         }, add = TRUE)
[17:42:23.208]     }
[17:42:23.208]     ...future.frame <- base::sys.nframe()
[17:42:23.208]     ...future.conditions <- base::list()
[17:42:23.208]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.208]     if (FALSE) {
[17:42:23.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.208]     }
[17:42:23.208]     ...future.result <- base::tryCatch({
[17:42:23.208]         base::withCallingHandlers({
[17:42:23.208]             ...future.value <- base::withVisible(base::local({
[17:42:23.208]                 withCallingHandlers({
[17:42:23.208]                   NULL
[17:42:23.208]                 }, immediateCondition = function(cond) {
[17:42:23.208]                   save_rds <- function (object, pathname, ...) 
[17:42:23.208]                   {
[17:42:23.208]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.208]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.208]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.208]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.208]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.208]                         fi_tmp[["mtime"]])
[17:42:23.208]                     }
[17:42:23.208]                     tryCatch({
[17:42:23.208]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.208]                     }, error = function(ex) {
[17:42:23.208]                       msg <- conditionMessage(ex)
[17:42:23.208]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.208]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.208]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.208]                         fi_tmp[["mtime"]], msg)
[17:42:23.208]                       ex$message <- msg
[17:42:23.208]                       stop(ex)
[17:42:23.208]                     })
[17:42:23.208]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.208]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.208]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.208]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.208]                       fi <- file.info(pathname)
[17:42:23.208]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.208]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.208]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.208]                         fi[["size"]], fi[["mtime"]])
[17:42:23.208]                       stop(msg)
[17:42:23.208]                     }
[17:42:23.208]                     invisible(pathname)
[17:42:23.208]                   }
[17:42:23.208]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.208]                     rootPath = tempdir()) 
[17:42:23.208]                   {
[17:42:23.208]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.208]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.208]                       tmpdir = path, fileext = ".rds")
[17:42:23.208]                     save_rds(obj, file)
[17:42:23.208]                   }
[17:42:23.208]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.208]                   {
[17:42:23.208]                     inherits <- base::inherits
[17:42:23.208]                     invokeRestart <- base::invokeRestart
[17:42:23.208]                     is.null <- base::is.null
[17:42:23.208]                     muffled <- FALSE
[17:42:23.208]                     if (inherits(cond, "message")) {
[17:42:23.208]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.208]                       if (muffled) 
[17:42:23.208]                         invokeRestart("muffleMessage")
[17:42:23.208]                     }
[17:42:23.208]                     else if (inherits(cond, "warning")) {
[17:42:23.208]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.208]                       if (muffled) 
[17:42:23.208]                         invokeRestart("muffleWarning")
[17:42:23.208]                     }
[17:42:23.208]                     else if (inherits(cond, "condition")) {
[17:42:23.208]                       if (!is.null(pattern)) {
[17:42:23.208]                         computeRestarts <- base::computeRestarts
[17:42:23.208]                         grepl <- base::grepl
[17:42:23.208]                         restarts <- computeRestarts(cond)
[17:42:23.208]                         for (restart in restarts) {
[17:42:23.208]                           name <- restart$name
[17:42:23.208]                           if (is.null(name)) 
[17:42:23.208]                             next
[17:42:23.208]                           if (!grepl(pattern, name)) 
[17:42:23.208]                             next
[17:42:23.208]                           invokeRestart(restart)
[17:42:23.208]                           muffled <- TRUE
[17:42:23.208]                           break
[17:42:23.208]                         }
[17:42:23.208]                       }
[17:42:23.208]                     }
[17:42:23.208]                     invisible(muffled)
[17:42:23.208]                   }
[17:42:23.208]                   muffleCondition(cond)
[17:42:23.208]                 })
[17:42:23.208]             }))
[17:42:23.208]             future::FutureResult(value = ...future.value$value, 
[17:42:23.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.208]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.208]                     ...future.globalenv.names))
[17:42:23.208]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.208]         }, condition = base::local({
[17:42:23.208]             c <- base::c
[17:42:23.208]             inherits <- base::inherits
[17:42:23.208]             invokeRestart <- base::invokeRestart
[17:42:23.208]             length <- base::length
[17:42:23.208]             list <- base::list
[17:42:23.208]             seq.int <- base::seq.int
[17:42:23.208]             signalCondition <- base::signalCondition
[17:42:23.208]             sys.calls <- base::sys.calls
[17:42:23.208]             `[[` <- base::`[[`
[17:42:23.208]             `+` <- base::`+`
[17:42:23.208]             `<<-` <- base::`<<-`
[17:42:23.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.208]                   3L)]
[17:42:23.208]             }
[17:42:23.208]             function(cond) {
[17:42:23.208]                 is_error <- inherits(cond, "error")
[17:42:23.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.208]                   NULL)
[17:42:23.208]                 if (is_error) {
[17:42:23.208]                   sessionInformation <- function() {
[17:42:23.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.208]                       search = base::search(), system = base::Sys.info())
[17:42:23.208]                   }
[17:42:23.208]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.208]                     cond$call), session = sessionInformation(), 
[17:42:23.208]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.208]                   signalCondition(cond)
[17:42:23.208]                 }
[17:42:23.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.208]                 "immediateCondition"))) {
[17:42:23.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.208]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.208]                   if (TRUE && !signal) {
[17:42:23.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.208]                     {
[17:42:23.208]                       inherits <- base::inherits
[17:42:23.208]                       invokeRestart <- base::invokeRestart
[17:42:23.208]                       is.null <- base::is.null
[17:42:23.208]                       muffled <- FALSE
[17:42:23.208]                       if (inherits(cond, "message")) {
[17:42:23.208]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.208]                         if (muffled) 
[17:42:23.208]                           invokeRestart("muffleMessage")
[17:42:23.208]                       }
[17:42:23.208]                       else if (inherits(cond, "warning")) {
[17:42:23.208]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.208]                         if (muffled) 
[17:42:23.208]                           invokeRestart("muffleWarning")
[17:42:23.208]                       }
[17:42:23.208]                       else if (inherits(cond, "condition")) {
[17:42:23.208]                         if (!is.null(pattern)) {
[17:42:23.208]                           computeRestarts <- base::computeRestarts
[17:42:23.208]                           grepl <- base::grepl
[17:42:23.208]                           restarts <- computeRestarts(cond)
[17:42:23.208]                           for (restart in restarts) {
[17:42:23.208]                             name <- restart$name
[17:42:23.208]                             if (is.null(name)) 
[17:42:23.208]                               next
[17:42:23.208]                             if (!grepl(pattern, name)) 
[17:42:23.208]                               next
[17:42:23.208]                             invokeRestart(restart)
[17:42:23.208]                             muffled <- TRUE
[17:42:23.208]                             break
[17:42:23.208]                           }
[17:42:23.208]                         }
[17:42:23.208]                       }
[17:42:23.208]                       invisible(muffled)
[17:42:23.208]                     }
[17:42:23.208]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.208]                   }
[17:42:23.208]                 }
[17:42:23.208]                 else {
[17:42:23.208]                   if (TRUE) {
[17:42:23.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.208]                     {
[17:42:23.208]                       inherits <- base::inherits
[17:42:23.208]                       invokeRestart <- base::invokeRestart
[17:42:23.208]                       is.null <- base::is.null
[17:42:23.208]                       muffled <- FALSE
[17:42:23.208]                       if (inherits(cond, "message")) {
[17:42:23.208]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.208]                         if (muffled) 
[17:42:23.208]                           invokeRestart("muffleMessage")
[17:42:23.208]                       }
[17:42:23.208]                       else if (inherits(cond, "warning")) {
[17:42:23.208]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.208]                         if (muffled) 
[17:42:23.208]                           invokeRestart("muffleWarning")
[17:42:23.208]                       }
[17:42:23.208]                       else if (inherits(cond, "condition")) {
[17:42:23.208]                         if (!is.null(pattern)) {
[17:42:23.208]                           computeRestarts <- base::computeRestarts
[17:42:23.208]                           grepl <- base::grepl
[17:42:23.208]                           restarts <- computeRestarts(cond)
[17:42:23.208]                           for (restart in restarts) {
[17:42:23.208]                             name <- restart$name
[17:42:23.208]                             if (is.null(name)) 
[17:42:23.208]                               next
[17:42:23.208]                             if (!grepl(pattern, name)) 
[17:42:23.208]                               next
[17:42:23.208]                             invokeRestart(restart)
[17:42:23.208]                             muffled <- TRUE
[17:42:23.208]                             break
[17:42:23.208]                           }
[17:42:23.208]                         }
[17:42:23.208]                       }
[17:42:23.208]                       invisible(muffled)
[17:42:23.208]                     }
[17:42:23.208]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.208]                   }
[17:42:23.208]                 }
[17:42:23.208]             }
[17:42:23.208]         }))
[17:42:23.208]     }, error = function(ex) {
[17:42:23.208]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.208]                 ...future.rng), started = ...future.startTime, 
[17:42:23.208]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.208]             version = "1.8"), class = "FutureResult")
[17:42:23.208]     }, finally = {
[17:42:23.208]         if (!identical(...future.workdir, getwd())) 
[17:42:23.208]             setwd(...future.workdir)
[17:42:23.208]         {
[17:42:23.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.208]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.208]             }
[17:42:23.208]             base::options(...future.oldOptions)
[17:42:23.208]             if (.Platform$OS.type == "windows") {
[17:42:23.208]                 old_names <- names(...future.oldEnvVars)
[17:42:23.208]                 envs <- base::Sys.getenv()
[17:42:23.208]                 names <- names(envs)
[17:42:23.208]                 common <- intersect(names, old_names)
[17:42:23.208]                 added <- setdiff(names, old_names)
[17:42:23.208]                 removed <- setdiff(old_names, names)
[17:42:23.208]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.208]                   envs[common]]
[17:42:23.208]                 NAMES <- toupper(changed)
[17:42:23.208]                 args <- list()
[17:42:23.208]                 for (kk in seq_along(NAMES)) {
[17:42:23.208]                   name <- changed[[kk]]
[17:42:23.208]                   NAME <- NAMES[[kk]]
[17:42:23.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.208]                     next
[17:42:23.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.208]                 }
[17:42:23.208]                 NAMES <- toupper(added)
[17:42:23.208]                 for (kk in seq_along(NAMES)) {
[17:42:23.208]                   name <- added[[kk]]
[17:42:23.208]                   NAME <- NAMES[[kk]]
[17:42:23.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.208]                     next
[17:42:23.208]                   args[[name]] <- ""
[17:42:23.208]                 }
[17:42:23.208]                 NAMES <- toupper(removed)
[17:42:23.208]                 for (kk in seq_along(NAMES)) {
[17:42:23.208]                   name <- removed[[kk]]
[17:42:23.208]                   NAME <- NAMES[[kk]]
[17:42:23.208]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.208]                     next
[17:42:23.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.208]                 }
[17:42:23.208]                 if (length(args) > 0) 
[17:42:23.208]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.208]             }
[17:42:23.208]             else {
[17:42:23.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.208]             }
[17:42:23.208]             {
[17:42:23.208]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.208]                   0L) {
[17:42:23.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.208]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.208]                   base::options(opts)
[17:42:23.208]                 }
[17:42:23.208]                 {
[17:42:23.208]                   {
[17:42:23.208]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.208]                     NULL
[17:42:23.208]                   }
[17:42:23.208]                   options(future.plan = NULL)
[17:42:23.208]                   if (is.na(NA_character_)) 
[17:42:23.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.208]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.208]                     envir = parent.frame()) 
[17:42:23.208]                   {
[17:42:23.208]                     default_workers <- missing(workers)
[17:42:23.208]                     if (is.function(workers)) 
[17:42:23.208]                       workers <- workers()
[17:42:23.208]                     workers <- structure(as.integer(workers), 
[17:42:23.208]                       class = class(workers))
[17:42:23.208]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.208]                       1L)
[17:42:23.208]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.208]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.208]                       if (default_workers) 
[17:42:23.208]                         supportsMulticore(warn = TRUE)
[17:42:23.208]                       return(sequential(..., envir = envir))
[17:42:23.208]                     }
[17:42:23.208]                     oopts <- options(mc.cores = workers)
[17:42:23.208]                     on.exit(options(oopts))
[17:42:23.208]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.208]                       envir = envir)
[17:42:23.208]                     if (!future$lazy) 
[17:42:23.208]                       future <- run(future)
[17:42:23.208]                     invisible(future)
[17:42:23.208]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.208]                 }
[17:42:23.208]             }
[17:42:23.208]         }
[17:42:23.208]     })
[17:42:23.208]     if (TRUE) {
[17:42:23.208]         base::sink(type = "output", split = FALSE)
[17:42:23.208]         if (TRUE) {
[17:42:23.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.208]         }
[17:42:23.208]         else {
[17:42:23.208]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.208]         }
[17:42:23.208]         base::close(...future.stdout)
[17:42:23.208]         ...future.stdout <- NULL
[17:42:23.208]     }
[17:42:23.208]     ...future.result$conditions <- ...future.conditions
[17:42:23.208]     ...future.result$finished <- base::Sys.time()
[17:42:23.208]     ...future.result
[17:42:23.208] }
[17:42:23.212] requestCore(): workers = 2
[17:42:23.215] MulticoreFuture started
[17:42:23.216] - Launch lazy future ... done
[17:42:23.216] run() for ‘MulticoreFuture’ ... done
[17:42:23.216] plan(): Setting new future strategy stack:
[17:42:23.217] getGlobalsAndPackages() ...
[17:42:23.217] Searching for globals...
[17:42:23.217] List of future strategies:
[17:42:23.217] 1. sequential:
[17:42:23.217]    - args: function (..., envir = parent.frame())
[17:42:23.217]    - tweaked: FALSE
[17:42:23.217]    - call: NULL
[17:42:23.218] plan(): nbrOfWorkers() = 1
[17:42:23.218] - globals found: [1] ‘{’
[17:42:23.219] Searching for globals ... DONE
[17:42:23.219] Resolving globals: FALSE
[17:42:23.219] 
[17:42:23.220] 
[17:42:23.220] getGlobalsAndPackages() ... DONE
[17:42:23.220] plan(): Setting new future strategy stack:
[17:42:23.220] run() for ‘Future’ ...
[17:42:23.220] - state: ‘created’
[17:42:23.220] List of future strategies:
[17:42:23.220] 1. multicore:
[17:42:23.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.220]    - tweaked: FALSE
[17:42:23.220]    - call: plan(strategy)
[17:42:23.221] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.225] plan(): nbrOfWorkers() = 2
[17:42:23.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.226]   - Field: ‘label’
[17:42:23.226]   - Field: ‘local’
[17:42:23.226]   - Field: ‘owner’
[17:42:23.227]   - Field: ‘envir’
[17:42:23.227]   - Field: ‘workers’
[17:42:23.227]   - Field: ‘packages’
[17:42:23.227]   - Field: ‘gc’
[17:42:23.227]   - Field: ‘job’
[17:42:23.227]   - Field: ‘conditions’
[17:42:23.228]   - Field: ‘expr’
[17:42:23.228]   - Field: ‘uuid’
[17:42:23.228]   - Field: ‘seed’
[17:42:23.228]   - Field: ‘version’
[17:42:23.228]   - Field: ‘result’
[17:42:23.228]   - Field: ‘asynchronous’
[17:42:23.228]   - Field: ‘calls’
[17:42:23.229]   - Field: ‘globals’
[17:42:23.229]   - Field: ‘stdout’
[17:42:23.229]   - Field: ‘earlySignal’
[17:42:23.229]   - Field: ‘lazy’
[17:42:23.229]   - Field: ‘state’
[17:42:23.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.229] - Launch lazy future ...
[17:42:23.230] Packages needed by the future expression (n = 0): <none>
[17:42:23.230] Packages needed by future strategies (n = 0): <none>
[17:42:23.231] {
[17:42:23.231]     {
[17:42:23.231]         {
[17:42:23.231]             ...future.startTime <- base::Sys.time()
[17:42:23.231]             {
[17:42:23.231]                 {
[17:42:23.231]                   {
[17:42:23.231]                     {
[17:42:23.231]                       base::local({
[17:42:23.231]                         has_future <- base::requireNamespace("future", 
[17:42:23.231]                           quietly = TRUE)
[17:42:23.231]                         if (has_future) {
[17:42:23.231]                           ns <- base::getNamespace("future")
[17:42:23.231]                           version <- ns[[".package"]][["version"]]
[17:42:23.231]                           if (is.null(version)) 
[17:42:23.231]                             version <- utils::packageVersion("future")
[17:42:23.231]                         }
[17:42:23.231]                         else {
[17:42:23.231]                           version <- NULL
[17:42:23.231]                         }
[17:42:23.231]                         if (!has_future || version < "1.8.0") {
[17:42:23.231]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.231]                             "", base::R.version$version.string), 
[17:42:23.231]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.231]                               "release", "version")], collapse = " "), 
[17:42:23.231]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.231]                             info)
[17:42:23.231]                           info <- base::paste(info, collapse = "; ")
[17:42:23.231]                           if (!has_future) {
[17:42:23.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.231]                               info)
[17:42:23.231]                           }
[17:42:23.231]                           else {
[17:42:23.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.231]                               info, version)
[17:42:23.231]                           }
[17:42:23.231]                           base::stop(msg)
[17:42:23.231]                         }
[17:42:23.231]                       })
[17:42:23.231]                     }
[17:42:23.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.231]                     base::options(mc.cores = 1L)
[17:42:23.231]                   }
[17:42:23.231]                   options(future.plan = NULL)
[17:42:23.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.231]                 }
[17:42:23.231]                 ...future.workdir <- getwd()
[17:42:23.231]             }
[17:42:23.231]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.231]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.231]         }
[17:42:23.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.231]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.231]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.231]             base::names(...future.oldOptions))
[17:42:23.231]     }
[17:42:23.231]     if (FALSE) {
[17:42:23.231]     }
[17:42:23.231]     else {
[17:42:23.231]         if (TRUE) {
[17:42:23.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.231]                 open = "w")
[17:42:23.231]         }
[17:42:23.231]         else {
[17:42:23.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.231]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.231]         }
[17:42:23.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.231]             base::sink(type = "output", split = FALSE)
[17:42:23.231]             base::close(...future.stdout)
[17:42:23.231]         }, add = TRUE)
[17:42:23.231]     }
[17:42:23.231]     ...future.frame <- base::sys.nframe()
[17:42:23.231]     ...future.conditions <- base::list()
[17:42:23.231]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.231]     if (FALSE) {
[17:42:23.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.231]     }
[17:42:23.231]     ...future.result <- base::tryCatch({
[17:42:23.231]         base::withCallingHandlers({
[17:42:23.231]             ...future.value <- base::withVisible(base::local({
[17:42:23.231]                 withCallingHandlers({
[17:42:23.231]                   {
[17:42:23.231]                     4
[17:42:23.231]                   }
[17:42:23.231]                 }, immediateCondition = function(cond) {
[17:42:23.231]                   save_rds <- function (object, pathname, ...) 
[17:42:23.231]                   {
[17:42:23.231]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.231]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.231]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.231]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.231]                         fi_tmp[["mtime"]])
[17:42:23.231]                     }
[17:42:23.231]                     tryCatch({
[17:42:23.231]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.231]                     }, error = function(ex) {
[17:42:23.231]                       msg <- conditionMessage(ex)
[17:42:23.231]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.231]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.231]                         fi_tmp[["mtime"]], msg)
[17:42:23.231]                       ex$message <- msg
[17:42:23.231]                       stop(ex)
[17:42:23.231]                     })
[17:42:23.231]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.231]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.231]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.231]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.231]                       fi <- file.info(pathname)
[17:42:23.231]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.231]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.231]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.231]                         fi[["size"]], fi[["mtime"]])
[17:42:23.231]                       stop(msg)
[17:42:23.231]                     }
[17:42:23.231]                     invisible(pathname)
[17:42:23.231]                   }
[17:42:23.231]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.231]                     rootPath = tempdir()) 
[17:42:23.231]                   {
[17:42:23.231]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.231]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.231]                       tmpdir = path, fileext = ".rds")
[17:42:23.231]                     save_rds(obj, file)
[17:42:23.231]                   }
[17:42:23.231]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.231]                   {
[17:42:23.231]                     inherits <- base::inherits
[17:42:23.231]                     invokeRestart <- base::invokeRestart
[17:42:23.231]                     is.null <- base::is.null
[17:42:23.231]                     muffled <- FALSE
[17:42:23.231]                     if (inherits(cond, "message")) {
[17:42:23.231]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.231]                       if (muffled) 
[17:42:23.231]                         invokeRestart("muffleMessage")
[17:42:23.231]                     }
[17:42:23.231]                     else if (inherits(cond, "warning")) {
[17:42:23.231]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.231]                       if (muffled) 
[17:42:23.231]                         invokeRestart("muffleWarning")
[17:42:23.231]                     }
[17:42:23.231]                     else if (inherits(cond, "condition")) {
[17:42:23.231]                       if (!is.null(pattern)) {
[17:42:23.231]                         computeRestarts <- base::computeRestarts
[17:42:23.231]                         grepl <- base::grepl
[17:42:23.231]                         restarts <- computeRestarts(cond)
[17:42:23.231]                         for (restart in restarts) {
[17:42:23.231]                           name <- restart$name
[17:42:23.231]                           if (is.null(name)) 
[17:42:23.231]                             next
[17:42:23.231]                           if (!grepl(pattern, name)) 
[17:42:23.231]                             next
[17:42:23.231]                           invokeRestart(restart)
[17:42:23.231]                           muffled <- TRUE
[17:42:23.231]                           break
[17:42:23.231]                         }
[17:42:23.231]                       }
[17:42:23.231]                     }
[17:42:23.231]                     invisible(muffled)
[17:42:23.231]                   }
[17:42:23.231]                   muffleCondition(cond)
[17:42:23.231]                 })
[17:42:23.231]             }))
[17:42:23.231]             future::FutureResult(value = ...future.value$value, 
[17:42:23.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.231]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.231]                     ...future.globalenv.names))
[17:42:23.231]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.231]         }, condition = base::local({
[17:42:23.231]             c <- base::c
[17:42:23.231]             inherits <- base::inherits
[17:42:23.231]             invokeRestart <- base::invokeRestart
[17:42:23.231]             length <- base::length
[17:42:23.231]             list <- base::list
[17:42:23.231]             seq.int <- base::seq.int
[17:42:23.231]             signalCondition <- base::signalCondition
[17:42:23.231]             sys.calls <- base::sys.calls
[17:42:23.231]             `[[` <- base::`[[`
[17:42:23.231]             `+` <- base::`+`
[17:42:23.231]             `<<-` <- base::`<<-`
[17:42:23.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.231]                   3L)]
[17:42:23.231]             }
[17:42:23.231]             function(cond) {
[17:42:23.231]                 is_error <- inherits(cond, "error")
[17:42:23.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.231]                   NULL)
[17:42:23.231]                 if (is_error) {
[17:42:23.231]                   sessionInformation <- function() {
[17:42:23.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.231]                       search = base::search(), system = base::Sys.info())
[17:42:23.231]                   }
[17:42:23.231]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.231]                     cond$call), session = sessionInformation(), 
[17:42:23.231]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.231]                   signalCondition(cond)
[17:42:23.231]                 }
[17:42:23.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.231]                 "immediateCondition"))) {
[17:42:23.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.231]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.231]                   if (TRUE && !signal) {
[17:42:23.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.231]                     {
[17:42:23.231]                       inherits <- base::inherits
[17:42:23.231]                       invokeRestart <- base::invokeRestart
[17:42:23.231]                       is.null <- base::is.null
[17:42:23.231]                       muffled <- FALSE
[17:42:23.231]                       if (inherits(cond, "message")) {
[17:42:23.231]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.231]                         if (muffled) 
[17:42:23.231]                           invokeRestart("muffleMessage")
[17:42:23.231]                       }
[17:42:23.231]                       else if (inherits(cond, "warning")) {
[17:42:23.231]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.231]                         if (muffled) 
[17:42:23.231]                           invokeRestart("muffleWarning")
[17:42:23.231]                       }
[17:42:23.231]                       else if (inherits(cond, "condition")) {
[17:42:23.231]                         if (!is.null(pattern)) {
[17:42:23.231]                           computeRestarts <- base::computeRestarts
[17:42:23.231]                           grepl <- base::grepl
[17:42:23.231]                           restarts <- computeRestarts(cond)
[17:42:23.231]                           for (restart in restarts) {
[17:42:23.231]                             name <- restart$name
[17:42:23.231]                             if (is.null(name)) 
[17:42:23.231]                               next
[17:42:23.231]                             if (!grepl(pattern, name)) 
[17:42:23.231]                               next
[17:42:23.231]                             invokeRestart(restart)
[17:42:23.231]                             muffled <- TRUE
[17:42:23.231]                             break
[17:42:23.231]                           }
[17:42:23.231]                         }
[17:42:23.231]                       }
[17:42:23.231]                       invisible(muffled)
[17:42:23.231]                     }
[17:42:23.231]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.231]                   }
[17:42:23.231]                 }
[17:42:23.231]                 else {
[17:42:23.231]                   if (TRUE) {
[17:42:23.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.231]                     {
[17:42:23.231]                       inherits <- base::inherits
[17:42:23.231]                       invokeRestart <- base::invokeRestart
[17:42:23.231]                       is.null <- base::is.null
[17:42:23.231]                       muffled <- FALSE
[17:42:23.231]                       if (inherits(cond, "message")) {
[17:42:23.231]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.231]                         if (muffled) 
[17:42:23.231]                           invokeRestart("muffleMessage")
[17:42:23.231]                       }
[17:42:23.231]                       else if (inherits(cond, "warning")) {
[17:42:23.231]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.231]                         if (muffled) 
[17:42:23.231]                           invokeRestart("muffleWarning")
[17:42:23.231]                       }
[17:42:23.231]                       else if (inherits(cond, "condition")) {
[17:42:23.231]                         if (!is.null(pattern)) {
[17:42:23.231]                           computeRestarts <- base::computeRestarts
[17:42:23.231]                           grepl <- base::grepl
[17:42:23.231]                           restarts <- computeRestarts(cond)
[17:42:23.231]                           for (restart in restarts) {
[17:42:23.231]                             name <- restart$name
[17:42:23.231]                             if (is.null(name)) 
[17:42:23.231]                               next
[17:42:23.231]                             if (!grepl(pattern, name)) 
[17:42:23.231]                               next
[17:42:23.231]                             invokeRestart(restart)
[17:42:23.231]                             muffled <- TRUE
[17:42:23.231]                             break
[17:42:23.231]                           }
[17:42:23.231]                         }
[17:42:23.231]                       }
[17:42:23.231]                       invisible(muffled)
[17:42:23.231]                     }
[17:42:23.231]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.231]                   }
[17:42:23.231]                 }
[17:42:23.231]             }
[17:42:23.231]         }))
[17:42:23.231]     }, error = function(ex) {
[17:42:23.231]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.231]                 ...future.rng), started = ...future.startTime, 
[17:42:23.231]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.231]             version = "1.8"), class = "FutureResult")
[17:42:23.231]     }, finally = {
[17:42:23.231]         if (!identical(...future.workdir, getwd())) 
[17:42:23.231]             setwd(...future.workdir)
[17:42:23.231]         {
[17:42:23.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.231]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.231]             }
[17:42:23.231]             base::options(...future.oldOptions)
[17:42:23.231]             if (.Platform$OS.type == "windows") {
[17:42:23.231]                 old_names <- names(...future.oldEnvVars)
[17:42:23.231]                 envs <- base::Sys.getenv()
[17:42:23.231]                 names <- names(envs)
[17:42:23.231]                 common <- intersect(names, old_names)
[17:42:23.231]                 added <- setdiff(names, old_names)
[17:42:23.231]                 removed <- setdiff(old_names, names)
[17:42:23.231]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.231]                   envs[common]]
[17:42:23.231]                 NAMES <- toupper(changed)
[17:42:23.231]                 args <- list()
[17:42:23.231]                 for (kk in seq_along(NAMES)) {
[17:42:23.231]                   name <- changed[[kk]]
[17:42:23.231]                   NAME <- NAMES[[kk]]
[17:42:23.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.231]                     next
[17:42:23.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.231]                 }
[17:42:23.231]                 NAMES <- toupper(added)
[17:42:23.231]                 for (kk in seq_along(NAMES)) {
[17:42:23.231]                   name <- added[[kk]]
[17:42:23.231]                   NAME <- NAMES[[kk]]
[17:42:23.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.231]                     next
[17:42:23.231]                   args[[name]] <- ""
[17:42:23.231]                 }
[17:42:23.231]                 NAMES <- toupper(removed)
[17:42:23.231]                 for (kk in seq_along(NAMES)) {
[17:42:23.231]                   name <- removed[[kk]]
[17:42:23.231]                   NAME <- NAMES[[kk]]
[17:42:23.231]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.231]                     next
[17:42:23.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.231]                 }
[17:42:23.231]                 if (length(args) > 0) 
[17:42:23.231]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.231]             }
[17:42:23.231]             else {
[17:42:23.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.231]             }
[17:42:23.231]             {
[17:42:23.231]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.231]                   0L) {
[17:42:23.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.231]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.231]                   base::options(opts)
[17:42:23.231]                 }
[17:42:23.231]                 {
[17:42:23.231]                   {
[17:42:23.231]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.231]                     NULL
[17:42:23.231]                   }
[17:42:23.231]                   options(future.plan = NULL)
[17:42:23.231]                   if (is.na(NA_character_)) 
[17:42:23.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.231]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.231]                     envir = parent.frame()) 
[17:42:23.231]                   {
[17:42:23.231]                     default_workers <- missing(workers)
[17:42:23.231]                     if (is.function(workers)) 
[17:42:23.231]                       workers <- workers()
[17:42:23.231]                     workers <- structure(as.integer(workers), 
[17:42:23.231]                       class = class(workers))
[17:42:23.231]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.231]                       1L)
[17:42:23.231]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.231]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.231]                       if (default_workers) 
[17:42:23.231]                         supportsMulticore(warn = TRUE)
[17:42:23.231]                       return(sequential(..., envir = envir))
[17:42:23.231]                     }
[17:42:23.231]                     oopts <- options(mc.cores = workers)
[17:42:23.231]                     on.exit(options(oopts))
[17:42:23.231]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.231]                       envir = envir)
[17:42:23.231]                     if (!future$lazy) 
[17:42:23.231]                       future <- run(future)
[17:42:23.231]                     invisible(future)
[17:42:23.231]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.231]                 }
[17:42:23.231]             }
[17:42:23.231]         }
[17:42:23.231]     })
[17:42:23.231]     if (TRUE) {
[17:42:23.231]         base::sink(type = "output", split = FALSE)
[17:42:23.231]         if (TRUE) {
[17:42:23.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.231]         }
[17:42:23.231]         else {
[17:42:23.231]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.231]         }
[17:42:23.231]         base::close(...future.stdout)
[17:42:23.231]         ...future.stdout <- NULL
[17:42:23.231]     }
[17:42:23.231]     ...future.result$conditions <- ...future.conditions
[17:42:23.231]     ...future.result$finished <- base::Sys.time()
[17:42:23.231]     ...future.result
[17:42:23.231] }
[17:42:23.234] requestCore(): workers = 2
[17:42:23.235] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:23.249] MulticoreFuture started
[17:42:23.250] - Launch lazy future ... done
[17:42:23.250] run() for ‘MulticoreFuture’ ... done
[17:42:23.251] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55bef8ac8578> 
[17:42:23.251] List of future strategies:
[17:42:23.251] 1. sequential:
[17:42:23.251]    - args: function (..., envir = parent.frame())
[17:42:23.251]    - tweaked: FALSE
[17:42:23.251]    - call: NULL
[17:42:23.252] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55bef9803690> 
[17:42:23.255] plan(): Setting new future strategy stack:
[17:42:23.255] List of future strategies:
[17:42:23.255] 1. multicore:
[17:42:23.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.255]    - tweaked: FALSE
[17:42:23.255]    - call: plan(strategy)
[17:42:23.261] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:23.264] resolve() on list environment ...
[17:42:23.264]  recursive: 0
[17:42:23.265]  length: 6
[17:42:23.265]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:23.266] signalConditionsASAP(numeric, pos=1) ...
[17:42:23.266] - nx: 6
[17:42:23.266] - relay: TRUE
[17:42:23.266] - stdout: TRUE
[17:42:23.266] - signal: TRUE
[17:42:23.266] - resignal: FALSE
[17:42:23.266] - force: TRUE
[17:42:23.267] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.267] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.267]  - until=2
[17:42:23.267]  - relaying element #2
[17:42:23.267] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.267] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.267] signalConditionsASAP(NULL, pos=1) ... done
[17:42:23.268]  length: 5 (resolved future 1)
[17:42:23.268] Future #2
[17:42:23.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:23.268] - nx: 6
[17:42:23.268] - relay: TRUE
[17:42:23.268] - stdout: TRUE
[17:42:23.269] - signal: TRUE
[17:42:23.269] - resignal: FALSE
[17:42:23.269] - force: TRUE
[17:42:23.269] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.269] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.269]  - until=2
[17:42:23.269]  - relaying element #2
[17:42:23.270] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.270] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.270] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:23.270]  length: 4 (resolved future 2)
[17:42:23.270] Future #3
[17:42:23.272] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:23.272] - nx: 6
[17:42:23.272] - relay: TRUE
[17:42:23.272] - stdout: TRUE
[17:42:23.272] - signal: TRUE
[17:42:23.272] - resignal: FALSE
[17:42:23.272] - force: TRUE
[17:42:23.272] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.273] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.273]  - until=3
[17:42:23.273]  - relaying element #3
[17:42:23.273] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.273] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.273] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:23.274]  length: 3 (resolved future 3)
[17:42:23.274] Future #4
[17:42:23.275] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:23.275] - nx: 6
[17:42:23.275] - relay: TRUE
[17:42:23.275] - stdout: TRUE
[17:42:23.275] - signal: TRUE
[17:42:23.275] - resignal: FALSE
[17:42:23.275] - force: TRUE
[17:42:23.276] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.276]  - until=4
[17:42:23.276]  - relaying element #4
[17:42:23.276] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.276] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.276] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:23.277]  length: 2 (resolved future 4)
[17:42:23.277] signalConditionsASAP(NULL, pos=5) ...
[17:42:23.277] - nx: 6
[17:42:23.277] - relay: TRUE
[17:42:23.277] - stdout: TRUE
[17:42:23.277] - signal: TRUE
[17:42:23.277] - resignal: FALSE
[17:42:23.277] - force: TRUE
[17:42:23.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.278] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.278]  - until=6
[17:42:23.278]  - relaying element #6
[17:42:23.278] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.278] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.278] signalConditionsASAP(NULL, pos=5) ... done
[17:42:23.278]  length: 1 (resolved future 5)
[17:42:23.278] signalConditionsASAP(numeric, pos=6) ...
[17:42:23.278] - nx: 6
[17:42:23.279] - relay: TRUE
[17:42:23.279] - stdout: TRUE
[17:42:23.279] - signal: TRUE
[17:42:23.279] - resignal: FALSE
[17:42:23.279] - force: TRUE
[17:42:23.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.279] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.279]  - until=6
[17:42:23.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.279] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.280] signalConditionsASAP(numeric, pos=6) ... done
[17:42:23.280]  length: 0 (resolved future 6)
[17:42:23.280] Relaying remaining futures
[17:42:23.280] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.280] - nx: 6
[17:42:23.280] - relay: TRUE
[17:42:23.280] - stdout: TRUE
[17:42:23.280] - signal: TRUE
[17:42:23.280] - resignal: FALSE
[17:42:23.280] - force: TRUE
[17:42:23.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.281] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:23.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.281] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.281] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.281] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef9a12ef0> 
Dimensions: c(1, 6)
[17:42:23.282] getGlobalsAndPackages() ...
[17:42:23.282] Searching for globals...
[17:42:23.283] 
[17:42:23.283] Searching for globals ... DONE
[17:42:23.283] - globals: [0] <none>
[17:42:23.283] getGlobalsAndPackages() ... DONE
[17:42:23.283] run() for ‘Future’ ...
[17:42:23.284] - state: ‘created’
[17:42:23.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.292] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.293]   - Field: ‘label’
[17:42:23.293]   - Field: ‘local’
[17:42:23.293]   - Field: ‘owner’
[17:42:23.293]   - Field: ‘envir’
[17:42:23.293]   - Field: ‘workers’
[17:42:23.293]   - Field: ‘packages’
[17:42:23.293]   - Field: ‘gc’
[17:42:23.294]   - Field: ‘job’
[17:42:23.294]   - Field: ‘conditions’
[17:42:23.294]   - Field: ‘expr’
[17:42:23.294]   - Field: ‘uuid’
[17:42:23.294]   - Field: ‘seed’
[17:42:23.294]   - Field: ‘version’
[17:42:23.294]   - Field: ‘result’
[17:42:23.294]   - Field: ‘asynchronous’
[17:42:23.294]   - Field: ‘calls’
[17:42:23.295]   - Field: ‘globals’
[17:42:23.295]   - Field: ‘stdout’
[17:42:23.295]   - Field: ‘earlySignal’
[17:42:23.295]   - Field: ‘lazy’
[17:42:23.295]   - Field: ‘state’
[17:42:23.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.295] - Launch lazy future ...
[17:42:23.296] Packages needed by the future expression (n = 0): <none>
[17:42:23.296] Packages needed by future strategies (n = 0): <none>
[17:42:23.296] {
[17:42:23.296]     {
[17:42:23.296]         {
[17:42:23.296]             ...future.startTime <- base::Sys.time()
[17:42:23.296]             {
[17:42:23.296]                 {
[17:42:23.296]                   {
[17:42:23.296]                     {
[17:42:23.296]                       base::local({
[17:42:23.296]                         has_future <- base::requireNamespace("future", 
[17:42:23.296]                           quietly = TRUE)
[17:42:23.296]                         if (has_future) {
[17:42:23.296]                           ns <- base::getNamespace("future")
[17:42:23.296]                           version <- ns[[".package"]][["version"]]
[17:42:23.296]                           if (is.null(version)) 
[17:42:23.296]                             version <- utils::packageVersion("future")
[17:42:23.296]                         }
[17:42:23.296]                         else {
[17:42:23.296]                           version <- NULL
[17:42:23.296]                         }
[17:42:23.296]                         if (!has_future || version < "1.8.0") {
[17:42:23.296]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.296]                             "", base::R.version$version.string), 
[17:42:23.296]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.296]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.296]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.296]                               "release", "version")], collapse = " "), 
[17:42:23.296]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.296]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.296]                             info)
[17:42:23.296]                           info <- base::paste(info, collapse = "; ")
[17:42:23.296]                           if (!has_future) {
[17:42:23.296]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.296]                               info)
[17:42:23.296]                           }
[17:42:23.296]                           else {
[17:42:23.296]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.296]                               info, version)
[17:42:23.296]                           }
[17:42:23.296]                           base::stop(msg)
[17:42:23.296]                         }
[17:42:23.296]                       })
[17:42:23.296]                     }
[17:42:23.296]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.296]                     base::options(mc.cores = 1L)
[17:42:23.296]                   }
[17:42:23.296]                   options(future.plan = NULL)
[17:42:23.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.296]                 }
[17:42:23.296]                 ...future.workdir <- getwd()
[17:42:23.296]             }
[17:42:23.296]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.296]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.296]         }
[17:42:23.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.296]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.296]             base::names(...future.oldOptions))
[17:42:23.296]     }
[17:42:23.296]     if (FALSE) {
[17:42:23.296]     }
[17:42:23.296]     else {
[17:42:23.296]         if (TRUE) {
[17:42:23.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.296]                 open = "w")
[17:42:23.296]         }
[17:42:23.296]         else {
[17:42:23.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.296]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.296]         }
[17:42:23.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.296]             base::sink(type = "output", split = FALSE)
[17:42:23.296]             base::close(...future.stdout)
[17:42:23.296]         }, add = TRUE)
[17:42:23.296]     }
[17:42:23.296]     ...future.frame <- base::sys.nframe()
[17:42:23.296]     ...future.conditions <- base::list()
[17:42:23.296]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.296]     if (FALSE) {
[17:42:23.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.296]     }
[17:42:23.296]     ...future.result <- base::tryCatch({
[17:42:23.296]         base::withCallingHandlers({
[17:42:23.296]             ...future.value <- base::withVisible(base::local({
[17:42:23.296]                 withCallingHandlers({
[17:42:23.296]                   2
[17:42:23.296]                 }, immediateCondition = function(cond) {
[17:42:23.296]                   save_rds <- function (object, pathname, ...) 
[17:42:23.296]                   {
[17:42:23.296]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.296]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.296]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.296]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.296]                         fi_tmp[["mtime"]])
[17:42:23.296]                     }
[17:42:23.296]                     tryCatch({
[17:42:23.296]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.296]                     }, error = function(ex) {
[17:42:23.296]                       msg <- conditionMessage(ex)
[17:42:23.296]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.296]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.296]                         fi_tmp[["mtime"]], msg)
[17:42:23.296]                       ex$message <- msg
[17:42:23.296]                       stop(ex)
[17:42:23.296]                     })
[17:42:23.296]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.296]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.296]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.296]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.296]                       fi <- file.info(pathname)
[17:42:23.296]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.296]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.296]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.296]                         fi[["size"]], fi[["mtime"]])
[17:42:23.296]                       stop(msg)
[17:42:23.296]                     }
[17:42:23.296]                     invisible(pathname)
[17:42:23.296]                   }
[17:42:23.296]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.296]                     rootPath = tempdir()) 
[17:42:23.296]                   {
[17:42:23.296]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.296]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.296]                       tmpdir = path, fileext = ".rds")
[17:42:23.296]                     save_rds(obj, file)
[17:42:23.296]                   }
[17:42:23.296]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.296]                   {
[17:42:23.296]                     inherits <- base::inherits
[17:42:23.296]                     invokeRestart <- base::invokeRestart
[17:42:23.296]                     is.null <- base::is.null
[17:42:23.296]                     muffled <- FALSE
[17:42:23.296]                     if (inherits(cond, "message")) {
[17:42:23.296]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.296]                       if (muffled) 
[17:42:23.296]                         invokeRestart("muffleMessage")
[17:42:23.296]                     }
[17:42:23.296]                     else if (inherits(cond, "warning")) {
[17:42:23.296]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.296]                       if (muffled) 
[17:42:23.296]                         invokeRestart("muffleWarning")
[17:42:23.296]                     }
[17:42:23.296]                     else if (inherits(cond, "condition")) {
[17:42:23.296]                       if (!is.null(pattern)) {
[17:42:23.296]                         computeRestarts <- base::computeRestarts
[17:42:23.296]                         grepl <- base::grepl
[17:42:23.296]                         restarts <- computeRestarts(cond)
[17:42:23.296]                         for (restart in restarts) {
[17:42:23.296]                           name <- restart$name
[17:42:23.296]                           if (is.null(name)) 
[17:42:23.296]                             next
[17:42:23.296]                           if (!grepl(pattern, name)) 
[17:42:23.296]                             next
[17:42:23.296]                           invokeRestart(restart)
[17:42:23.296]                           muffled <- TRUE
[17:42:23.296]                           break
[17:42:23.296]                         }
[17:42:23.296]                       }
[17:42:23.296]                     }
[17:42:23.296]                     invisible(muffled)
[17:42:23.296]                   }
[17:42:23.296]                   muffleCondition(cond)
[17:42:23.296]                 })
[17:42:23.296]             }))
[17:42:23.296]             future::FutureResult(value = ...future.value$value, 
[17:42:23.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.296]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.296]                     ...future.globalenv.names))
[17:42:23.296]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.296]         }, condition = base::local({
[17:42:23.296]             c <- base::c
[17:42:23.296]             inherits <- base::inherits
[17:42:23.296]             invokeRestart <- base::invokeRestart
[17:42:23.296]             length <- base::length
[17:42:23.296]             list <- base::list
[17:42:23.296]             seq.int <- base::seq.int
[17:42:23.296]             signalCondition <- base::signalCondition
[17:42:23.296]             sys.calls <- base::sys.calls
[17:42:23.296]             `[[` <- base::`[[`
[17:42:23.296]             `+` <- base::`+`
[17:42:23.296]             `<<-` <- base::`<<-`
[17:42:23.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.296]                   3L)]
[17:42:23.296]             }
[17:42:23.296]             function(cond) {
[17:42:23.296]                 is_error <- inherits(cond, "error")
[17:42:23.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.296]                   NULL)
[17:42:23.296]                 if (is_error) {
[17:42:23.296]                   sessionInformation <- function() {
[17:42:23.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.296]                       search = base::search(), system = base::Sys.info())
[17:42:23.296]                   }
[17:42:23.296]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.296]                     cond$call), session = sessionInformation(), 
[17:42:23.296]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.296]                   signalCondition(cond)
[17:42:23.296]                 }
[17:42:23.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.296]                 "immediateCondition"))) {
[17:42:23.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.296]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.296]                   if (TRUE && !signal) {
[17:42:23.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.296]                     {
[17:42:23.296]                       inherits <- base::inherits
[17:42:23.296]                       invokeRestart <- base::invokeRestart
[17:42:23.296]                       is.null <- base::is.null
[17:42:23.296]                       muffled <- FALSE
[17:42:23.296]                       if (inherits(cond, "message")) {
[17:42:23.296]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.296]                         if (muffled) 
[17:42:23.296]                           invokeRestart("muffleMessage")
[17:42:23.296]                       }
[17:42:23.296]                       else if (inherits(cond, "warning")) {
[17:42:23.296]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.296]                         if (muffled) 
[17:42:23.296]                           invokeRestart("muffleWarning")
[17:42:23.296]                       }
[17:42:23.296]                       else if (inherits(cond, "condition")) {
[17:42:23.296]                         if (!is.null(pattern)) {
[17:42:23.296]                           computeRestarts <- base::computeRestarts
[17:42:23.296]                           grepl <- base::grepl
[17:42:23.296]                           restarts <- computeRestarts(cond)
[17:42:23.296]                           for (restart in restarts) {
[17:42:23.296]                             name <- restart$name
[17:42:23.296]                             if (is.null(name)) 
[17:42:23.296]                               next
[17:42:23.296]                             if (!grepl(pattern, name)) 
[17:42:23.296]                               next
[17:42:23.296]                             invokeRestart(restart)
[17:42:23.296]                             muffled <- TRUE
[17:42:23.296]                             break
[17:42:23.296]                           }
[17:42:23.296]                         }
[17:42:23.296]                       }
[17:42:23.296]                       invisible(muffled)
[17:42:23.296]                     }
[17:42:23.296]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.296]                   }
[17:42:23.296]                 }
[17:42:23.296]                 else {
[17:42:23.296]                   if (TRUE) {
[17:42:23.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.296]                     {
[17:42:23.296]                       inherits <- base::inherits
[17:42:23.296]                       invokeRestart <- base::invokeRestart
[17:42:23.296]                       is.null <- base::is.null
[17:42:23.296]                       muffled <- FALSE
[17:42:23.296]                       if (inherits(cond, "message")) {
[17:42:23.296]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.296]                         if (muffled) 
[17:42:23.296]                           invokeRestart("muffleMessage")
[17:42:23.296]                       }
[17:42:23.296]                       else if (inherits(cond, "warning")) {
[17:42:23.296]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.296]                         if (muffled) 
[17:42:23.296]                           invokeRestart("muffleWarning")
[17:42:23.296]                       }
[17:42:23.296]                       else if (inherits(cond, "condition")) {
[17:42:23.296]                         if (!is.null(pattern)) {
[17:42:23.296]                           computeRestarts <- base::computeRestarts
[17:42:23.296]                           grepl <- base::grepl
[17:42:23.296]                           restarts <- computeRestarts(cond)
[17:42:23.296]                           for (restart in restarts) {
[17:42:23.296]                             name <- restart$name
[17:42:23.296]                             if (is.null(name)) 
[17:42:23.296]                               next
[17:42:23.296]                             if (!grepl(pattern, name)) 
[17:42:23.296]                               next
[17:42:23.296]                             invokeRestart(restart)
[17:42:23.296]                             muffled <- TRUE
[17:42:23.296]                             break
[17:42:23.296]                           }
[17:42:23.296]                         }
[17:42:23.296]                       }
[17:42:23.296]                       invisible(muffled)
[17:42:23.296]                     }
[17:42:23.296]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.296]                   }
[17:42:23.296]                 }
[17:42:23.296]             }
[17:42:23.296]         }))
[17:42:23.296]     }, error = function(ex) {
[17:42:23.296]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.296]                 ...future.rng), started = ...future.startTime, 
[17:42:23.296]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.296]             version = "1.8"), class = "FutureResult")
[17:42:23.296]     }, finally = {
[17:42:23.296]         if (!identical(...future.workdir, getwd())) 
[17:42:23.296]             setwd(...future.workdir)
[17:42:23.296]         {
[17:42:23.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.296]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.296]             }
[17:42:23.296]             base::options(...future.oldOptions)
[17:42:23.296]             if (.Platform$OS.type == "windows") {
[17:42:23.296]                 old_names <- names(...future.oldEnvVars)
[17:42:23.296]                 envs <- base::Sys.getenv()
[17:42:23.296]                 names <- names(envs)
[17:42:23.296]                 common <- intersect(names, old_names)
[17:42:23.296]                 added <- setdiff(names, old_names)
[17:42:23.296]                 removed <- setdiff(old_names, names)
[17:42:23.296]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.296]                   envs[common]]
[17:42:23.296]                 NAMES <- toupper(changed)
[17:42:23.296]                 args <- list()
[17:42:23.296]                 for (kk in seq_along(NAMES)) {
[17:42:23.296]                   name <- changed[[kk]]
[17:42:23.296]                   NAME <- NAMES[[kk]]
[17:42:23.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.296]                     next
[17:42:23.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.296]                 }
[17:42:23.296]                 NAMES <- toupper(added)
[17:42:23.296]                 for (kk in seq_along(NAMES)) {
[17:42:23.296]                   name <- added[[kk]]
[17:42:23.296]                   NAME <- NAMES[[kk]]
[17:42:23.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.296]                     next
[17:42:23.296]                   args[[name]] <- ""
[17:42:23.296]                 }
[17:42:23.296]                 NAMES <- toupper(removed)
[17:42:23.296]                 for (kk in seq_along(NAMES)) {
[17:42:23.296]                   name <- removed[[kk]]
[17:42:23.296]                   NAME <- NAMES[[kk]]
[17:42:23.296]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.296]                     next
[17:42:23.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.296]                 }
[17:42:23.296]                 if (length(args) > 0) 
[17:42:23.296]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.296]             }
[17:42:23.296]             else {
[17:42:23.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.296]             }
[17:42:23.296]             {
[17:42:23.296]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.296]                   0L) {
[17:42:23.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.296]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.296]                   base::options(opts)
[17:42:23.296]                 }
[17:42:23.296]                 {
[17:42:23.296]                   {
[17:42:23.296]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.296]                     NULL
[17:42:23.296]                   }
[17:42:23.296]                   options(future.plan = NULL)
[17:42:23.296]                   if (is.na(NA_character_)) 
[17:42:23.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.296]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.296]                     envir = parent.frame()) 
[17:42:23.296]                   {
[17:42:23.296]                     default_workers <- missing(workers)
[17:42:23.296]                     if (is.function(workers)) 
[17:42:23.296]                       workers <- workers()
[17:42:23.296]                     workers <- structure(as.integer(workers), 
[17:42:23.296]                       class = class(workers))
[17:42:23.296]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.296]                       1L)
[17:42:23.296]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.296]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.296]                       if (default_workers) 
[17:42:23.296]                         supportsMulticore(warn = TRUE)
[17:42:23.296]                       return(sequential(..., envir = envir))
[17:42:23.296]                     }
[17:42:23.296]                     oopts <- options(mc.cores = workers)
[17:42:23.296]                     on.exit(options(oopts))
[17:42:23.296]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.296]                       envir = envir)
[17:42:23.296]                     if (!future$lazy) 
[17:42:23.296]                       future <- run(future)
[17:42:23.296]                     invisible(future)
[17:42:23.296]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.296]                 }
[17:42:23.296]             }
[17:42:23.296]         }
[17:42:23.296]     })
[17:42:23.296]     if (TRUE) {
[17:42:23.296]         base::sink(type = "output", split = FALSE)
[17:42:23.296]         if (TRUE) {
[17:42:23.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.296]         }
[17:42:23.296]         else {
[17:42:23.296]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.296]         }
[17:42:23.296]         base::close(...future.stdout)
[17:42:23.296]         ...future.stdout <- NULL
[17:42:23.296]     }
[17:42:23.296]     ...future.result$conditions <- ...future.conditions
[17:42:23.296]     ...future.result$finished <- base::Sys.time()
[17:42:23.296]     ...future.result
[17:42:23.296] }
[17:42:23.299] requestCore(): workers = 2
[17:42:23.301] MulticoreFuture started
[17:42:23.302] - Launch lazy future ... done
[17:42:23.302] run() for ‘MulticoreFuture’ ... done
[17:42:23.302] getGlobalsAndPackages() ...
[17:42:23.302] Searching for globals...
[17:42:23.302] plan(): Setting new future strategy stack:
[17:42:23.303] 
[17:42:23.303] List of future strategies:
[17:42:23.303] 1. sequential:
[17:42:23.303]    - args: function (..., envir = parent.frame())
[17:42:23.303]    - tweaked: FALSE
[17:42:23.303]    - call: NULL
[17:42:23.303] Searching for globals ... DONE
[17:42:23.304] - globals: [0] <none>
[17:42:23.304] plan(): nbrOfWorkers() = 1
[17:42:23.304] getGlobalsAndPackages() ... DONE
[17:42:23.304] run() for ‘Future’ ...
[17:42:23.304] - state: ‘created’
[17:42:23.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.305] plan(): Setting new future strategy stack:
[17:42:23.306] List of future strategies:
[17:42:23.306] 1. multicore:
[17:42:23.306]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.306]    - tweaked: FALSE
[17:42:23.306]    - call: plan(strategy)
[17:42:23.310] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.310]   - Field: ‘label’
[17:42:23.311] plan(): nbrOfWorkers() = 2
[17:42:23.311]   - Field: ‘local’
[17:42:23.311]   - Field: ‘owner’
[17:42:23.311]   - Field: ‘envir’
[17:42:23.311]   - Field: ‘workers’
[17:42:23.311]   - Field: ‘packages’
[17:42:23.311]   - Field: ‘gc’
[17:42:23.312]   - Field: ‘job’
[17:42:23.312]   - Field: ‘conditions’
[17:42:23.312]   - Field: ‘expr’
[17:42:23.312]   - Field: ‘uuid’
[17:42:23.312]   - Field: ‘seed’
[17:42:23.312]   - Field: ‘version’
[17:42:23.312]   - Field: ‘result’
[17:42:23.313]   - Field: ‘asynchronous’
[17:42:23.313]   - Field: ‘calls’
[17:42:23.313]   - Field: ‘globals’
[17:42:23.313]   - Field: ‘stdout’
[17:42:23.313]   - Field: ‘earlySignal’
[17:42:23.313]   - Field: ‘lazy’
[17:42:23.314]   - Field: ‘state’
[17:42:23.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.314] - Launch lazy future ...
[17:42:23.314] Packages needed by the future expression (n = 0): <none>
[17:42:23.315] Packages needed by future strategies (n = 0): <none>
[17:42:23.315] {
[17:42:23.315]     {
[17:42:23.315]         {
[17:42:23.315]             ...future.startTime <- base::Sys.time()
[17:42:23.315]             {
[17:42:23.315]                 {
[17:42:23.315]                   {
[17:42:23.315]                     {
[17:42:23.315]                       base::local({
[17:42:23.315]                         has_future <- base::requireNamespace("future", 
[17:42:23.315]                           quietly = TRUE)
[17:42:23.315]                         if (has_future) {
[17:42:23.315]                           ns <- base::getNamespace("future")
[17:42:23.315]                           version <- ns[[".package"]][["version"]]
[17:42:23.315]                           if (is.null(version)) 
[17:42:23.315]                             version <- utils::packageVersion("future")
[17:42:23.315]                         }
[17:42:23.315]                         else {
[17:42:23.315]                           version <- NULL
[17:42:23.315]                         }
[17:42:23.315]                         if (!has_future || version < "1.8.0") {
[17:42:23.315]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.315]                             "", base::R.version$version.string), 
[17:42:23.315]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.315]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.315]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.315]                               "release", "version")], collapse = " "), 
[17:42:23.315]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.315]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.315]                             info)
[17:42:23.315]                           info <- base::paste(info, collapse = "; ")
[17:42:23.315]                           if (!has_future) {
[17:42:23.315]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.315]                               info)
[17:42:23.315]                           }
[17:42:23.315]                           else {
[17:42:23.315]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.315]                               info, version)
[17:42:23.315]                           }
[17:42:23.315]                           base::stop(msg)
[17:42:23.315]                         }
[17:42:23.315]                       })
[17:42:23.315]                     }
[17:42:23.315]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.315]                     base::options(mc.cores = 1L)
[17:42:23.315]                   }
[17:42:23.315]                   options(future.plan = NULL)
[17:42:23.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.315]                 }
[17:42:23.315]                 ...future.workdir <- getwd()
[17:42:23.315]             }
[17:42:23.315]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.315]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.315]         }
[17:42:23.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.315]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.315]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.315]             base::names(...future.oldOptions))
[17:42:23.315]     }
[17:42:23.315]     if (FALSE) {
[17:42:23.315]     }
[17:42:23.315]     else {
[17:42:23.315]         if (TRUE) {
[17:42:23.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.315]                 open = "w")
[17:42:23.315]         }
[17:42:23.315]         else {
[17:42:23.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.315]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.315]         }
[17:42:23.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.315]             base::sink(type = "output", split = FALSE)
[17:42:23.315]             base::close(...future.stdout)
[17:42:23.315]         }, add = TRUE)
[17:42:23.315]     }
[17:42:23.315]     ...future.frame <- base::sys.nframe()
[17:42:23.315]     ...future.conditions <- base::list()
[17:42:23.315]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.315]     if (FALSE) {
[17:42:23.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.315]     }
[17:42:23.315]     ...future.result <- base::tryCatch({
[17:42:23.315]         base::withCallingHandlers({
[17:42:23.315]             ...future.value <- base::withVisible(base::local({
[17:42:23.315]                 withCallingHandlers({
[17:42:23.315]                   NULL
[17:42:23.315]                 }, immediateCondition = function(cond) {
[17:42:23.315]                   save_rds <- function (object, pathname, ...) 
[17:42:23.315]                   {
[17:42:23.315]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.315]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.315]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.315]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.315]                         fi_tmp[["mtime"]])
[17:42:23.315]                     }
[17:42:23.315]                     tryCatch({
[17:42:23.315]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.315]                     }, error = function(ex) {
[17:42:23.315]                       msg <- conditionMessage(ex)
[17:42:23.315]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.315]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.315]                         fi_tmp[["mtime"]], msg)
[17:42:23.315]                       ex$message <- msg
[17:42:23.315]                       stop(ex)
[17:42:23.315]                     })
[17:42:23.315]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.315]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.315]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.315]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.315]                       fi <- file.info(pathname)
[17:42:23.315]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.315]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.315]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.315]                         fi[["size"]], fi[["mtime"]])
[17:42:23.315]                       stop(msg)
[17:42:23.315]                     }
[17:42:23.315]                     invisible(pathname)
[17:42:23.315]                   }
[17:42:23.315]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.315]                     rootPath = tempdir()) 
[17:42:23.315]                   {
[17:42:23.315]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.315]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.315]                       tmpdir = path, fileext = ".rds")
[17:42:23.315]                     save_rds(obj, file)
[17:42:23.315]                   }
[17:42:23.315]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.315]                   {
[17:42:23.315]                     inherits <- base::inherits
[17:42:23.315]                     invokeRestart <- base::invokeRestart
[17:42:23.315]                     is.null <- base::is.null
[17:42:23.315]                     muffled <- FALSE
[17:42:23.315]                     if (inherits(cond, "message")) {
[17:42:23.315]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.315]                       if (muffled) 
[17:42:23.315]                         invokeRestart("muffleMessage")
[17:42:23.315]                     }
[17:42:23.315]                     else if (inherits(cond, "warning")) {
[17:42:23.315]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.315]                       if (muffled) 
[17:42:23.315]                         invokeRestart("muffleWarning")
[17:42:23.315]                     }
[17:42:23.315]                     else if (inherits(cond, "condition")) {
[17:42:23.315]                       if (!is.null(pattern)) {
[17:42:23.315]                         computeRestarts <- base::computeRestarts
[17:42:23.315]                         grepl <- base::grepl
[17:42:23.315]                         restarts <- computeRestarts(cond)
[17:42:23.315]                         for (restart in restarts) {
[17:42:23.315]                           name <- restart$name
[17:42:23.315]                           if (is.null(name)) 
[17:42:23.315]                             next
[17:42:23.315]                           if (!grepl(pattern, name)) 
[17:42:23.315]                             next
[17:42:23.315]                           invokeRestart(restart)
[17:42:23.315]                           muffled <- TRUE
[17:42:23.315]                           break
[17:42:23.315]                         }
[17:42:23.315]                       }
[17:42:23.315]                     }
[17:42:23.315]                     invisible(muffled)
[17:42:23.315]                   }
[17:42:23.315]                   muffleCondition(cond)
[17:42:23.315]                 })
[17:42:23.315]             }))
[17:42:23.315]             future::FutureResult(value = ...future.value$value, 
[17:42:23.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.315]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.315]                     ...future.globalenv.names))
[17:42:23.315]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.315]         }, condition = base::local({
[17:42:23.315]             c <- base::c
[17:42:23.315]             inherits <- base::inherits
[17:42:23.315]             invokeRestart <- base::invokeRestart
[17:42:23.315]             length <- base::length
[17:42:23.315]             list <- base::list
[17:42:23.315]             seq.int <- base::seq.int
[17:42:23.315]             signalCondition <- base::signalCondition
[17:42:23.315]             sys.calls <- base::sys.calls
[17:42:23.315]             `[[` <- base::`[[`
[17:42:23.315]             `+` <- base::`+`
[17:42:23.315]             `<<-` <- base::`<<-`
[17:42:23.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.315]                   3L)]
[17:42:23.315]             }
[17:42:23.315]             function(cond) {
[17:42:23.315]                 is_error <- inherits(cond, "error")
[17:42:23.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.315]                   NULL)
[17:42:23.315]                 if (is_error) {
[17:42:23.315]                   sessionInformation <- function() {
[17:42:23.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.315]                       search = base::search(), system = base::Sys.info())
[17:42:23.315]                   }
[17:42:23.315]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.315]                     cond$call), session = sessionInformation(), 
[17:42:23.315]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.315]                   signalCondition(cond)
[17:42:23.315]                 }
[17:42:23.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.315]                 "immediateCondition"))) {
[17:42:23.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.315]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.315]                   if (TRUE && !signal) {
[17:42:23.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.315]                     {
[17:42:23.315]                       inherits <- base::inherits
[17:42:23.315]                       invokeRestart <- base::invokeRestart
[17:42:23.315]                       is.null <- base::is.null
[17:42:23.315]                       muffled <- FALSE
[17:42:23.315]                       if (inherits(cond, "message")) {
[17:42:23.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.315]                         if (muffled) 
[17:42:23.315]                           invokeRestart("muffleMessage")
[17:42:23.315]                       }
[17:42:23.315]                       else if (inherits(cond, "warning")) {
[17:42:23.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.315]                         if (muffled) 
[17:42:23.315]                           invokeRestart("muffleWarning")
[17:42:23.315]                       }
[17:42:23.315]                       else if (inherits(cond, "condition")) {
[17:42:23.315]                         if (!is.null(pattern)) {
[17:42:23.315]                           computeRestarts <- base::computeRestarts
[17:42:23.315]                           grepl <- base::grepl
[17:42:23.315]                           restarts <- computeRestarts(cond)
[17:42:23.315]                           for (restart in restarts) {
[17:42:23.315]                             name <- restart$name
[17:42:23.315]                             if (is.null(name)) 
[17:42:23.315]                               next
[17:42:23.315]                             if (!grepl(pattern, name)) 
[17:42:23.315]                               next
[17:42:23.315]                             invokeRestart(restart)
[17:42:23.315]                             muffled <- TRUE
[17:42:23.315]                             break
[17:42:23.315]                           }
[17:42:23.315]                         }
[17:42:23.315]                       }
[17:42:23.315]                       invisible(muffled)
[17:42:23.315]                     }
[17:42:23.315]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.315]                   }
[17:42:23.315]                 }
[17:42:23.315]                 else {
[17:42:23.315]                   if (TRUE) {
[17:42:23.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.315]                     {
[17:42:23.315]                       inherits <- base::inherits
[17:42:23.315]                       invokeRestart <- base::invokeRestart
[17:42:23.315]                       is.null <- base::is.null
[17:42:23.315]                       muffled <- FALSE
[17:42:23.315]                       if (inherits(cond, "message")) {
[17:42:23.315]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.315]                         if (muffled) 
[17:42:23.315]                           invokeRestart("muffleMessage")
[17:42:23.315]                       }
[17:42:23.315]                       else if (inherits(cond, "warning")) {
[17:42:23.315]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.315]                         if (muffled) 
[17:42:23.315]                           invokeRestart("muffleWarning")
[17:42:23.315]                       }
[17:42:23.315]                       else if (inherits(cond, "condition")) {
[17:42:23.315]                         if (!is.null(pattern)) {
[17:42:23.315]                           computeRestarts <- base::computeRestarts
[17:42:23.315]                           grepl <- base::grepl
[17:42:23.315]                           restarts <- computeRestarts(cond)
[17:42:23.315]                           for (restart in restarts) {
[17:42:23.315]                             name <- restart$name
[17:42:23.315]                             if (is.null(name)) 
[17:42:23.315]                               next
[17:42:23.315]                             if (!grepl(pattern, name)) 
[17:42:23.315]                               next
[17:42:23.315]                             invokeRestart(restart)
[17:42:23.315]                             muffled <- TRUE
[17:42:23.315]                             break
[17:42:23.315]                           }
[17:42:23.315]                         }
[17:42:23.315]                       }
[17:42:23.315]                       invisible(muffled)
[17:42:23.315]                     }
[17:42:23.315]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.315]                   }
[17:42:23.315]                 }
[17:42:23.315]             }
[17:42:23.315]         }))
[17:42:23.315]     }, error = function(ex) {
[17:42:23.315]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.315]                 ...future.rng), started = ...future.startTime, 
[17:42:23.315]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.315]             version = "1.8"), class = "FutureResult")
[17:42:23.315]     }, finally = {
[17:42:23.315]         if (!identical(...future.workdir, getwd())) 
[17:42:23.315]             setwd(...future.workdir)
[17:42:23.315]         {
[17:42:23.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.315]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.315]             }
[17:42:23.315]             base::options(...future.oldOptions)
[17:42:23.315]             if (.Platform$OS.type == "windows") {
[17:42:23.315]                 old_names <- names(...future.oldEnvVars)
[17:42:23.315]                 envs <- base::Sys.getenv()
[17:42:23.315]                 names <- names(envs)
[17:42:23.315]                 common <- intersect(names, old_names)
[17:42:23.315]                 added <- setdiff(names, old_names)
[17:42:23.315]                 removed <- setdiff(old_names, names)
[17:42:23.315]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.315]                   envs[common]]
[17:42:23.315]                 NAMES <- toupper(changed)
[17:42:23.315]                 args <- list()
[17:42:23.315]                 for (kk in seq_along(NAMES)) {
[17:42:23.315]                   name <- changed[[kk]]
[17:42:23.315]                   NAME <- NAMES[[kk]]
[17:42:23.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.315]                     next
[17:42:23.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.315]                 }
[17:42:23.315]                 NAMES <- toupper(added)
[17:42:23.315]                 for (kk in seq_along(NAMES)) {
[17:42:23.315]                   name <- added[[kk]]
[17:42:23.315]                   NAME <- NAMES[[kk]]
[17:42:23.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.315]                     next
[17:42:23.315]                   args[[name]] <- ""
[17:42:23.315]                 }
[17:42:23.315]                 NAMES <- toupper(removed)
[17:42:23.315]                 for (kk in seq_along(NAMES)) {
[17:42:23.315]                   name <- removed[[kk]]
[17:42:23.315]                   NAME <- NAMES[[kk]]
[17:42:23.315]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.315]                     next
[17:42:23.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.315]                 }
[17:42:23.315]                 if (length(args) > 0) 
[17:42:23.315]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.315]             }
[17:42:23.315]             else {
[17:42:23.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.315]             }
[17:42:23.315]             {
[17:42:23.315]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.315]                   0L) {
[17:42:23.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.315]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.315]                   base::options(opts)
[17:42:23.315]                 }
[17:42:23.315]                 {
[17:42:23.315]                   {
[17:42:23.315]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.315]                     NULL
[17:42:23.315]                   }
[17:42:23.315]                   options(future.plan = NULL)
[17:42:23.315]                   if (is.na(NA_character_)) 
[17:42:23.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.315]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.315]                     envir = parent.frame()) 
[17:42:23.315]                   {
[17:42:23.315]                     default_workers <- missing(workers)
[17:42:23.315]                     if (is.function(workers)) 
[17:42:23.315]                       workers <- workers()
[17:42:23.315]                     workers <- structure(as.integer(workers), 
[17:42:23.315]                       class = class(workers))
[17:42:23.315]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.315]                       1L)
[17:42:23.315]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.315]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.315]                       if (default_workers) 
[17:42:23.315]                         supportsMulticore(warn = TRUE)
[17:42:23.315]                       return(sequential(..., envir = envir))
[17:42:23.315]                     }
[17:42:23.315]                     oopts <- options(mc.cores = workers)
[17:42:23.315]                     on.exit(options(oopts))
[17:42:23.315]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.315]                       envir = envir)
[17:42:23.315]                     if (!future$lazy) 
[17:42:23.315]                       future <- run(future)
[17:42:23.315]                     invisible(future)
[17:42:23.315]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.315]                 }
[17:42:23.315]             }
[17:42:23.315]         }
[17:42:23.315]     })
[17:42:23.315]     if (TRUE) {
[17:42:23.315]         base::sink(type = "output", split = FALSE)
[17:42:23.315]         if (TRUE) {
[17:42:23.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.315]         }
[17:42:23.315]         else {
[17:42:23.315]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.315]         }
[17:42:23.315]         base::close(...future.stdout)
[17:42:23.315]         ...future.stdout <- NULL
[17:42:23.315]     }
[17:42:23.315]     ...future.result$conditions <- ...future.conditions
[17:42:23.315]     ...future.result$finished <- base::Sys.time()
[17:42:23.315]     ...future.result
[17:42:23.315] }
[17:42:23.319] requestCore(): workers = 2
[17:42:23.322] MulticoreFuture started
[17:42:23.322] - Launch lazy future ... done
[17:42:23.322] run() for ‘MulticoreFuture’ ... done
[17:42:23.323] plan(): Setting new future strategy stack:
[17:42:23.323] getGlobalsAndPackages() ...
[17:42:23.323] Searching for globals...
[17:42:23.323] List of future strategies:
[17:42:23.323] 1. sequential:
[17:42:23.323]    - args: function (..., envir = parent.frame())
[17:42:23.323]    - tweaked: FALSE
[17:42:23.323]    - call: NULL
[17:42:23.324] plan(): nbrOfWorkers() = 1
[17:42:23.325] - globals found: [1] ‘{’
[17:42:23.325] Searching for globals ... DONE
[17:42:23.325] Resolving globals: FALSE
[17:42:23.326] 
[17:42:23.326] 
[17:42:23.326] getGlobalsAndPackages() ... DONE
[17:42:23.326] plan(): Setting new future strategy stack:
[17:42:23.326] run() for ‘Future’ ...
[17:42:23.326] List of future strategies:
[17:42:23.326] 1. multicore:
[17:42:23.326]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.326]    - tweaked: FALSE
[17:42:23.326]    - call: plan(strategy)
[17:42:23.327] - state: ‘created’
[17:42:23.327] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.331] plan(): nbrOfWorkers() = 2
[17:42:23.332] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.333]   - Field: ‘label’
[17:42:23.333]   - Field: ‘local’
[17:42:23.333]   - Field: ‘owner’
[17:42:23.333]   - Field: ‘envir’
[17:42:23.333]   - Field: ‘workers’
[17:42:23.333]   - Field: ‘packages’
[17:42:23.334]   - Field: ‘gc’
[17:42:23.334]   - Field: ‘job’
[17:42:23.334]   - Field: ‘conditions’
[17:42:23.334]   - Field: ‘expr’
[17:42:23.334]   - Field: ‘uuid’
[17:42:23.334]   - Field: ‘seed’
[17:42:23.334]   - Field: ‘version’
[17:42:23.335]   - Field: ‘result’
[17:42:23.335]   - Field: ‘asynchronous’
[17:42:23.335]   - Field: ‘calls’
[17:42:23.335]   - Field: ‘globals’
[17:42:23.335]   - Field: ‘stdout’
[17:42:23.335]   - Field: ‘earlySignal’
[17:42:23.336]   - Field: ‘lazy’
[17:42:23.336]   - Field: ‘state’
[17:42:23.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.336] - Launch lazy future ...
[17:42:23.336] Packages needed by the future expression (n = 0): <none>
[17:42:23.337] Packages needed by future strategies (n = 0): <none>
[17:42:23.337] {
[17:42:23.337]     {
[17:42:23.337]         {
[17:42:23.337]             ...future.startTime <- base::Sys.time()
[17:42:23.337]             {
[17:42:23.337]                 {
[17:42:23.337]                   {
[17:42:23.337]                     {
[17:42:23.337]                       base::local({
[17:42:23.337]                         has_future <- base::requireNamespace("future", 
[17:42:23.337]                           quietly = TRUE)
[17:42:23.337]                         if (has_future) {
[17:42:23.337]                           ns <- base::getNamespace("future")
[17:42:23.337]                           version <- ns[[".package"]][["version"]]
[17:42:23.337]                           if (is.null(version)) 
[17:42:23.337]                             version <- utils::packageVersion("future")
[17:42:23.337]                         }
[17:42:23.337]                         else {
[17:42:23.337]                           version <- NULL
[17:42:23.337]                         }
[17:42:23.337]                         if (!has_future || version < "1.8.0") {
[17:42:23.337]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.337]                             "", base::R.version$version.string), 
[17:42:23.337]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.337]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.337]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.337]                               "release", "version")], collapse = " "), 
[17:42:23.337]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.337]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.337]                             info)
[17:42:23.337]                           info <- base::paste(info, collapse = "; ")
[17:42:23.337]                           if (!has_future) {
[17:42:23.337]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.337]                               info)
[17:42:23.337]                           }
[17:42:23.337]                           else {
[17:42:23.337]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.337]                               info, version)
[17:42:23.337]                           }
[17:42:23.337]                           base::stop(msg)
[17:42:23.337]                         }
[17:42:23.337]                       })
[17:42:23.337]                     }
[17:42:23.337]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.337]                     base::options(mc.cores = 1L)
[17:42:23.337]                   }
[17:42:23.337]                   options(future.plan = NULL)
[17:42:23.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.337]                 }
[17:42:23.337]                 ...future.workdir <- getwd()
[17:42:23.337]             }
[17:42:23.337]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.337]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.337]         }
[17:42:23.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.337]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.337]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.337]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.337]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.337]             base::names(...future.oldOptions))
[17:42:23.337]     }
[17:42:23.337]     if (FALSE) {
[17:42:23.337]     }
[17:42:23.337]     else {
[17:42:23.337]         if (TRUE) {
[17:42:23.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.337]                 open = "w")
[17:42:23.337]         }
[17:42:23.337]         else {
[17:42:23.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.337]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.337]         }
[17:42:23.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.337]             base::sink(type = "output", split = FALSE)
[17:42:23.337]             base::close(...future.stdout)
[17:42:23.337]         }, add = TRUE)
[17:42:23.337]     }
[17:42:23.337]     ...future.frame <- base::sys.nframe()
[17:42:23.337]     ...future.conditions <- base::list()
[17:42:23.337]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.337]     if (FALSE) {
[17:42:23.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.337]     }
[17:42:23.337]     ...future.result <- base::tryCatch({
[17:42:23.337]         base::withCallingHandlers({
[17:42:23.337]             ...future.value <- base::withVisible(base::local({
[17:42:23.337]                 withCallingHandlers({
[17:42:23.337]                   {
[17:42:23.337]                     4
[17:42:23.337]                   }
[17:42:23.337]                 }, immediateCondition = function(cond) {
[17:42:23.337]                   save_rds <- function (object, pathname, ...) 
[17:42:23.337]                   {
[17:42:23.337]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.337]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.337]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.337]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.337]                         fi_tmp[["mtime"]])
[17:42:23.337]                     }
[17:42:23.337]                     tryCatch({
[17:42:23.337]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.337]                     }, error = function(ex) {
[17:42:23.337]                       msg <- conditionMessage(ex)
[17:42:23.337]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.337]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.337]                         fi_tmp[["mtime"]], msg)
[17:42:23.337]                       ex$message <- msg
[17:42:23.337]                       stop(ex)
[17:42:23.337]                     })
[17:42:23.337]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.337]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.337]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.337]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.337]                       fi <- file.info(pathname)
[17:42:23.337]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.337]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.337]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.337]                         fi[["size"]], fi[["mtime"]])
[17:42:23.337]                       stop(msg)
[17:42:23.337]                     }
[17:42:23.337]                     invisible(pathname)
[17:42:23.337]                   }
[17:42:23.337]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.337]                     rootPath = tempdir()) 
[17:42:23.337]                   {
[17:42:23.337]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.337]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.337]                       tmpdir = path, fileext = ".rds")
[17:42:23.337]                     save_rds(obj, file)
[17:42:23.337]                   }
[17:42:23.337]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.337]                   {
[17:42:23.337]                     inherits <- base::inherits
[17:42:23.337]                     invokeRestart <- base::invokeRestart
[17:42:23.337]                     is.null <- base::is.null
[17:42:23.337]                     muffled <- FALSE
[17:42:23.337]                     if (inherits(cond, "message")) {
[17:42:23.337]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.337]                       if (muffled) 
[17:42:23.337]                         invokeRestart("muffleMessage")
[17:42:23.337]                     }
[17:42:23.337]                     else if (inherits(cond, "warning")) {
[17:42:23.337]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.337]                       if (muffled) 
[17:42:23.337]                         invokeRestart("muffleWarning")
[17:42:23.337]                     }
[17:42:23.337]                     else if (inherits(cond, "condition")) {
[17:42:23.337]                       if (!is.null(pattern)) {
[17:42:23.337]                         computeRestarts <- base::computeRestarts
[17:42:23.337]                         grepl <- base::grepl
[17:42:23.337]                         restarts <- computeRestarts(cond)
[17:42:23.337]                         for (restart in restarts) {
[17:42:23.337]                           name <- restart$name
[17:42:23.337]                           if (is.null(name)) 
[17:42:23.337]                             next
[17:42:23.337]                           if (!grepl(pattern, name)) 
[17:42:23.337]                             next
[17:42:23.337]                           invokeRestart(restart)
[17:42:23.337]                           muffled <- TRUE
[17:42:23.337]                           break
[17:42:23.337]                         }
[17:42:23.337]                       }
[17:42:23.337]                     }
[17:42:23.337]                     invisible(muffled)
[17:42:23.337]                   }
[17:42:23.337]                   muffleCondition(cond)
[17:42:23.337]                 })
[17:42:23.337]             }))
[17:42:23.337]             future::FutureResult(value = ...future.value$value, 
[17:42:23.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.337]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.337]                     ...future.globalenv.names))
[17:42:23.337]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.337]         }, condition = base::local({
[17:42:23.337]             c <- base::c
[17:42:23.337]             inherits <- base::inherits
[17:42:23.337]             invokeRestart <- base::invokeRestart
[17:42:23.337]             length <- base::length
[17:42:23.337]             list <- base::list
[17:42:23.337]             seq.int <- base::seq.int
[17:42:23.337]             signalCondition <- base::signalCondition
[17:42:23.337]             sys.calls <- base::sys.calls
[17:42:23.337]             `[[` <- base::`[[`
[17:42:23.337]             `+` <- base::`+`
[17:42:23.337]             `<<-` <- base::`<<-`
[17:42:23.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.337]                   3L)]
[17:42:23.337]             }
[17:42:23.337]             function(cond) {
[17:42:23.337]                 is_error <- inherits(cond, "error")
[17:42:23.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.337]                   NULL)
[17:42:23.337]                 if (is_error) {
[17:42:23.337]                   sessionInformation <- function() {
[17:42:23.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.337]                       search = base::search(), system = base::Sys.info())
[17:42:23.337]                   }
[17:42:23.337]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.337]                     cond$call), session = sessionInformation(), 
[17:42:23.337]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.337]                   signalCondition(cond)
[17:42:23.337]                 }
[17:42:23.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.337]                 "immediateCondition"))) {
[17:42:23.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.337]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.337]                   if (TRUE && !signal) {
[17:42:23.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.337]                     {
[17:42:23.337]                       inherits <- base::inherits
[17:42:23.337]                       invokeRestart <- base::invokeRestart
[17:42:23.337]                       is.null <- base::is.null
[17:42:23.337]                       muffled <- FALSE
[17:42:23.337]                       if (inherits(cond, "message")) {
[17:42:23.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.337]                         if (muffled) 
[17:42:23.337]                           invokeRestart("muffleMessage")
[17:42:23.337]                       }
[17:42:23.337]                       else if (inherits(cond, "warning")) {
[17:42:23.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.337]                         if (muffled) 
[17:42:23.337]                           invokeRestart("muffleWarning")
[17:42:23.337]                       }
[17:42:23.337]                       else if (inherits(cond, "condition")) {
[17:42:23.337]                         if (!is.null(pattern)) {
[17:42:23.337]                           computeRestarts <- base::computeRestarts
[17:42:23.337]                           grepl <- base::grepl
[17:42:23.337]                           restarts <- computeRestarts(cond)
[17:42:23.337]                           for (restart in restarts) {
[17:42:23.337]                             name <- restart$name
[17:42:23.337]                             if (is.null(name)) 
[17:42:23.337]                               next
[17:42:23.337]                             if (!grepl(pattern, name)) 
[17:42:23.337]                               next
[17:42:23.337]                             invokeRestart(restart)
[17:42:23.337]                             muffled <- TRUE
[17:42:23.337]                             break
[17:42:23.337]                           }
[17:42:23.337]                         }
[17:42:23.337]                       }
[17:42:23.337]                       invisible(muffled)
[17:42:23.337]                     }
[17:42:23.337]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.337]                   }
[17:42:23.337]                 }
[17:42:23.337]                 else {
[17:42:23.337]                   if (TRUE) {
[17:42:23.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.337]                     {
[17:42:23.337]                       inherits <- base::inherits
[17:42:23.337]                       invokeRestart <- base::invokeRestart
[17:42:23.337]                       is.null <- base::is.null
[17:42:23.337]                       muffled <- FALSE
[17:42:23.337]                       if (inherits(cond, "message")) {
[17:42:23.337]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.337]                         if (muffled) 
[17:42:23.337]                           invokeRestart("muffleMessage")
[17:42:23.337]                       }
[17:42:23.337]                       else if (inherits(cond, "warning")) {
[17:42:23.337]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.337]                         if (muffled) 
[17:42:23.337]                           invokeRestart("muffleWarning")
[17:42:23.337]                       }
[17:42:23.337]                       else if (inherits(cond, "condition")) {
[17:42:23.337]                         if (!is.null(pattern)) {
[17:42:23.337]                           computeRestarts <- base::computeRestarts
[17:42:23.337]                           grepl <- base::grepl
[17:42:23.337]                           restarts <- computeRestarts(cond)
[17:42:23.337]                           for (restart in restarts) {
[17:42:23.337]                             name <- restart$name
[17:42:23.337]                             if (is.null(name)) 
[17:42:23.337]                               next
[17:42:23.337]                             if (!grepl(pattern, name)) 
[17:42:23.337]                               next
[17:42:23.337]                             invokeRestart(restart)
[17:42:23.337]                             muffled <- TRUE
[17:42:23.337]                             break
[17:42:23.337]                           }
[17:42:23.337]                         }
[17:42:23.337]                       }
[17:42:23.337]                       invisible(muffled)
[17:42:23.337]                     }
[17:42:23.337]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.337]                   }
[17:42:23.337]                 }
[17:42:23.337]             }
[17:42:23.337]         }))
[17:42:23.337]     }, error = function(ex) {
[17:42:23.337]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.337]                 ...future.rng), started = ...future.startTime, 
[17:42:23.337]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.337]             version = "1.8"), class = "FutureResult")
[17:42:23.337]     }, finally = {
[17:42:23.337]         if (!identical(...future.workdir, getwd())) 
[17:42:23.337]             setwd(...future.workdir)
[17:42:23.337]         {
[17:42:23.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.337]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.337]             }
[17:42:23.337]             base::options(...future.oldOptions)
[17:42:23.337]             if (.Platform$OS.type == "windows") {
[17:42:23.337]                 old_names <- names(...future.oldEnvVars)
[17:42:23.337]                 envs <- base::Sys.getenv()
[17:42:23.337]                 names <- names(envs)
[17:42:23.337]                 common <- intersect(names, old_names)
[17:42:23.337]                 added <- setdiff(names, old_names)
[17:42:23.337]                 removed <- setdiff(old_names, names)
[17:42:23.337]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.337]                   envs[common]]
[17:42:23.337]                 NAMES <- toupper(changed)
[17:42:23.337]                 args <- list()
[17:42:23.337]                 for (kk in seq_along(NAMES)) {
[17:42:23.337]                   name <- changed[[kk]]
[17:42:23.337]                   NAME <- NAMES[[kk]]
[17:42:23.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.337]                     next
[17:42:23.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.337]                 }
[17:42:23.337]                 NAMES <- toupper(added)
[17:42:23.337]                 for (kk in seq_along(NAMES)) {
[17:42:23.337]                   name <- added[[kk]]
[17:42:23.337]                   NAME <- NAMES[[kk]]
[17:42:23.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.337]                     next
[17:42:23.337]                   args[[name]] <- ""
[17:42:23.337]                 }
[17:42:23.337]                 NAMES <- toupper(removed)
[17:42:23.337]                 for (kk in seq_along(NAMES)) {
[17:42:23.337]                   name <- removed[[kk]]
[17:42:23.337]                   NAME <- NAMES[[kk]]
[17:42:23.337]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.337]                     next
[17:42:23.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.337]                 }
[17:42:23.337]                 if (length(args) > 0) 
[17:42:23.337]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.337]             }
[17:42:23.337]             else {
[17:42:23.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.337]             }
[17:42:23.337]             {
[17:42:23.337]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.337]                   0L) {
[17:42:23.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.337]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.337]                   base::options(opts)
[17:42:23.337]                 }
[17:42:23.337]                 {
[17:42:23.337]                   {
[17:42:23.337]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.337]                     NULL
[17:42:23.337]                   }
[17:42:23.337]                   options(future.plan = NULL)
[17:42:23.337]                   if (is.na(NA_character_)) 
[17:42:23.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.337]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.337]                     envir = parent.frame()) 
[17:42:23.337]                   {
[17:42:23.337]                     default_workers <- missing(workers)
[17:42:23.337]                     if (is.function(workers)) 
[17:42:23.337]                       workers <- workers()
[17:42:23.337]                     workers <- structure(as.integer(workers), 
[17:42:23.337]                       class = class(workers))
[17:42:23.337]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.337]                       1L)
[17:42:23.337]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.337]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.337]                       if (default_workers) 
[17:42:23.337]                         supportsMulticore(warn = TRUE)
[17:42:23.337]                       return(sequential(..., envir = envir))
[17:42:23.337]                     }
[17:42:23.337]                     oopts <- options(mc.cores = workers)
[17:42:23.337]                     on.exit(options(oopts))
[17:42:23.337]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.337]                       envir = envir)
[17:42:23.337]                     if (!future$lazy) 
[17:42:23.337]                       future <- run(future)
[17:42:23.337]                     invisible(future)
[17:42:23.337]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.337]                 }
[17:42:23.337]             }
[17:42:23.337]         }
[17:42:23.337]     })
[17:42:23.337]     if (TRUE) {
[17:42:23.337]         base::sink(type = "output", split = FALSE)
[17:42:23.337]         if (TRUE) {
[17:42:23.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.337]         }
[17:42:23.337]         else {
[17:42:23.337]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.337]         }
[17:42:23.337]         base::close(...future.stdout)
[17:42:23.337]         ...future.stdout <- NULL
[17:42:23.337]     }
[17:42:23.337]     ...future.result$conditions <- ...future.conditions
[17:42:23.337]     ...future.result$finished <- base::Sys.time()
[17:42:23.337]     ...future.result
[17:42:23.337] }
[17:42:23.341] requestCore(): workers = 2
[17:42:23.341] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:23.356] MulticoreFuture started
[17:42:23.356] - Launch lazy future ... done
[17:42:23.356] run() for ‘MulticoreFuture’ ... done
[17:42:23.357] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55befa03da90> 
[17:42:23.357] List of future strategies:
[17:42:23.357] 1. sequential:
[17:42:23.357]    - args: function (..., envir = parent.frame())
[17:42:23.357]    - tweaked: FALSE
[17:42:23.357]    - call: NULL
[17:42:23.359] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55bef7617e48> 
[17:42:23.362] plan(): Setting new future strategy stack:
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[17:42:23.362] List of future strategies:
[17:42:23.362] 1. multicore:
[17:42:23.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.362]    - tweaked: FALSE
[17:42:23.362]    - call: plan(strategy)
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:42:23.369] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:23.374] resolve() on list environment ...
[17:42:23.374]  recursive: 0
[17:42:23.376]  length: 6
[17:42:23.376]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:23.376] signalConditionsASAP(numeric, pos=1) ...
[17:42:23.376] - nx: 6
[17:42:23.377] - relay: TRUE
[17:42:23.377] - stdout: TRUE
[17:42:23.377] - signal: TRUE
[17:42:23.377] - resignal: FALSE
[17:42:23.377] - force: TRUE
[17:42:23.377] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.377] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.378]  - until=2
[17:42:23.378]  - relaying element #2
[17:42:23.378] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.378] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.378] signalConditionsASAP(NULL, pos=1) ... done
[17:42:23.378]  length: 5 (resolved future 1)
[17:42:23.378] Future #2
[17:42:23.379] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:23.379] - nx: 6
[17:42:23.379] - relay: TRUE
[17:42:23.379] - stdout: TRUE
[17:42:23.379] - signal: TRUE
[17:42:23.379] - resignal: FALSE
[17:42:23.379] - force: TRUE
[17:42:23.380] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.380] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.380]  - until=2
[17:42:23.380]  - relaying element #2
[17:42:23.380] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.380] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.381] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:23.381]  length: 4 (resolved future 2)
[17:42:23.381] Future #3
[17:42:23.382] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:23.382] - nx: 6
[17:42:23.382] - relay: TRUE
[17:42:23.382] - stdout: TRUE
[17:42:23.383] - signal: TRUE
[17:42:23.383] - resignal: FALSE
[17:42:23.383] - force: TRUE
[17:42:23.383] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.383] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.383]  - until=3
[17:42:23.383]  - relaying element #3
[17:42:23.384] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.384] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.384] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:23.384]  length: 3 (resolved future 3)
[17:42:23.384] Future #4
[17:42:23.385] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:23.385] - nx: 6
[17:42:23.386] - relay: TRUE
[17:42:23.386] - stdout: TRUE
[17:42:23.386] - signal: TRUE
[17:42:23.386] - resignal: FALSE
[17:42:23.386] - force: TRUE
[17:42:23.387] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.387] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.387]  - until=4
[17:42:23.387]  - relaying element #4
[17:42:23.387] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.388] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.388] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:23.388]  length: 2 (resolved future 4)
[17:42:23.388] signalConditionsASAP(NULL, pos=5) ...
[17:42:23.388] - nx: 6
[17:42:23.388] - relay: TRUE
[17:42:23.389] - stdout: TRUE
[17:42:23.389] - signal: TRUE
[17:42:23.389] - resignal: FALSE
[17:42:23.389] - force: TRUE
[17:42:23.389] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.389] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.389]  - until=6
[17:42:23.390]  - relaying element #6
[17:42:23.390] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.390] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.390] signalConditionsASAP(NULL, pos=5) ... done
[17:42:23.390]  length: 1 (resolved future 5)
[17:42:23.390] signalConditionsASAP(numeric, pos=6) ...
[17:42:23.390] - nx: 6
[17:42:23.390] - relay: TRUE
[17:42:23.390] - stdout: TRUE
[17:42:23.390] - signal: TRUE
[17:42:23.391] - resignal: FALSE
[17:42:23.391] - force: TRUE
[17:42:23.391] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.391] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.391]  - until=6
[17:42:23.391] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.391] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.391] signalConditionsASAP(numeric, pos=6) ... done
[17:42:23.391]  length: 0 (resolved future 6)
[17:42:23.392] Relaying remaining futures
[17:42:23.392] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.392] - nx: 6
[17:42:23.392] - relay: TRUE
[17:42:23.392] - stdout: TRUE
[17:42:23.392] - signal: TRUE
[17:42:23.392] - resignal: FALSE
[17:42:23.392] - force: TRUE
[17:42:23.392] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.392] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:23.393] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.393] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.393] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.393] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef82dbdd8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:42:23.395] getGlobalsAndPackages() ...
[17:42:23.395] Searching for globals...
[17:42:23.396] 
[17:42:23.396] Searching for globals ... DONE
[17:42:23.396] - globals: [0] <none>
[17:42:23.396] getGlobalsAndPackages() ... DONE
[17:42:23.397] run() for ‘Future’ ...
[17:42:23.397] - state: ‘created’
[17:42:23.397] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.402] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.402] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.402]   - Field: ‘label’
[17:42:23.402]   - Field: ‘local’
[17:42:23.402]   - Field: ‘owner’
[17:42:23.402]   - Field: ‘envir’
[17:42:23.402]   - Field: ‘workers’
[17:42:23.402]   - Field: ‘packages’
[17:42:23.403]   - Field: ‘gc’
[17:42:23.403]   - Field: ‘job’
[17:42:23.403]   - Field: ‘conditions’
[17:42:23.403]   - Field: ‘expr’
[17:42:23.403]   - Field: ‘uuid’
[17:42:23.403]   - Field: ‘seed’
[17:42:23.403]   - Field: ‘version’
[17:42:23.403]   - Field: ‘result’
[17:42:23.404]   - Field: ‘asynchronous’
[17:42:23.404]   - Field: ‘calls’
[17:42:23.404]   - Field: ‘globals’
[17:42:23.404]   - Field: ‘stdout’
[17:42:23.404]   - Field: ‘earlySignal’
[17:42:23.404]   - Field: ‘lazy’
[17:42:23.404]   - Field: ‘state’
[17:42:23.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.405] - Launch lazy future ...
[17:42:23.405] Packages needed by the future expression (n = 0): <none>
[17:42:23.405] Packages needed by future strategies (n = 0): <none>
[17:42:23.406] {
[17:42:23.406]     {
[17:42:23.406]         {
[17:42:23.406]             ...future.startTime <- base::Sys.time()
[17:42:23.406]             {
[17:42:23.406]                 {
[17:42:23.406]                   {
[17:42:23.406]                     {
[17:42:23.406]                       base::local({
[17:42:23.406]                         has_future <- base::requireNamespace("future", 
[17:42:23.406]                           quietly = TRUE)
[17:42:23.406]                         if (has_future) {
[17:42:23.406]                           ns <- base::getNamespace("future")
[17:42:23.406]                           version <- ns[[".package"]][["version"]]
[17:42:23.406]                           if (is.null(version)) 
[17:42:23.406]                             version <- utils::packageVersion("future")
[17:42:23.406]                         }
[17:42:23.406]                         else {
[17:42:23.406]                           version <- NULL
[17:42:23.406]                         }
[17:42:23.406]                         if (!has_future || version < "1.8.0") {
[17:42:23.406]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.406]                             "", base::R.version$version.string), 
[17:42:23.406]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.406]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.406]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.406]                               "release", "version")], collapse = " "), 
[17:42:23.406]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.406]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.406]                             info)
[17:42:23.406]                           info <- base::paste(info, collapse = "; ")
[17:42:23.406]                           if (!has_future) {
[17:42:23.406]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.406]                               info)
[17:42:23.406]                           }
[17:42:23.406]                           else {
[17:42:23.406]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.406]                               info, version)
[17:42:23.406]                           }
[17:42:23.406]                           base::stop(msg)
[17:42:23.406]                         }
[17:42:23.406]                       })
[17:42:23.406]                     }
[17:42:23.406]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.406]                     base::options(mc.cores = 1L)
[17:42:23.406]                   }
[17:42:23.406]                   options(future.plan = NULL)
[17:42:23.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.406]                 }
[17:42:23.406]                 ...future.workdir <- getwd()
[17:42:23.406]             }
[17:42:23.406]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.406]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.406]         }
[17:42:23.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.406]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.406]             base::names(...future.oldOptions))
[17:42:23.406]     }
[17:42:23.406]     if (FALSE) {
[17:42:23.406]     }
[17:42:23.406]     else {
[17:42:23.406]         if (TRUE) {
[17:42:23.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.406]                 open = "w")
[17:42:23.406]         }
[17:42:23.406]         else {
[17:42:23.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.406]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.406]         }
[17:42:23.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.406]             base::sink(type = "output", split = FALSE)
[17:42:23.406]             base::close(...future.stdout)
[17:42:23.406]         }, add = TRUE)
[17:42:23.406]     }
[17:42:23.406]     ...future.frame <- base::sys.nframe()
[17:42:23.406]     ...future.conditions <- base::list()
[17:42:23.406]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.406]     if (FALSE) {
[17:42:23.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.406]     }
[17:42:23.406]     ...future.result <- base::tryCatch({
[17:42:23.406]         base::withCallingHandlers({
[17:42:23.406]             ...future.value <- base::withVisible(base::local({
[17:42:23.406]                 withCallingHandlers({
[17:42:23.406]                   2
[17:42:23.406]                 }, immediateCondition = function(cond) {
[17:42:23.406]                   save_rds <- function (object, pathname, ...) 
[17:42:23.406]                   {
[17:42:23.406]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.406]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.406]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.406]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.406]                         fi_tmp[["mtime"]])
[17:42:23.406]                     }
[17:42:23.406]                     tryCatch({
[17:42:23.406]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.406]                     }, error = function(ex) {
[17:42:23.406]                       msg <- conditionMessage(ex)
[17:42:23.406]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.406]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.406]                         fi_tmp[["mtime"]], msg)
[17:42:23.406]                       ex$message <- msg
[17:42:23.406]                       stop(ex)
[17:42:23.406]                     })
[17:42:23.406]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.406]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.406]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.406]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.406]                       fi <- file.info(pathname)
[17:42:23.406]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.406]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.406]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.406]                         fi[["size"]], fi[["mtime"]])
[17:42:23.406]                       stop(msg)
[17:42:23.406]                     }
[17:42:23.406]                     invisible(pathname)
[17:42:23.406]                   }
[17:42:23.406]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.406]                     rootPath = tempdir()) 
[17:42:23.406]                   {
[17:42:23.406]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.406]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.406]                       tmpdir = path, fileext = ".rds")
[17:42:23.406]                     save_rds(obj, file)
[17:42:23.406]                   }
[17:42:23.406]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.406]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.406]                   {
[17:42:23.406]                     inherits <- base::inherits
[17:42:23.406]                     invokeRestart <- base::invokeRestart
[17:42:23.406]                     is.null <- base::is.null
[17:42:23.406]                     muffled <- FALSE
[17:42:23.406]                     if (inherits(cond, "message")) {
[17:42:23.406]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.406]                       if (muffled) 
[17:42:23.406]                         invokeRestart("muffleMessage")
[17:42:23.406]                     }
[17:42:23.406]                     else if (inherits(cond, "warning")) {
[17:42:23.406]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.406]                       if (muffled) 
[17:42:23.406]                         invokeRestart("muffleWarning")
[17:42:23.406]                     }
[17:42:23.406]                     else if (inherits(cond, "condition")) {
[17:42:23.406]                       if (!is.null(pattern)) {
[17:42:23.406]                         computeRestarts <- base::computeRestarts
[17:42:23.406]                         grepl <- base::grepl
[17:42:23.406]                         restarts <- computeRestarts(cond)
[17:42:23.406]                         for (restart in restarts) {
[17:42:23.406]                           name <- restart$name
[17:42:23.406]                           if (is.null(name)) 
[17:42:23.406]                             next
[17:42:23.406]                           if (!grepl(pattern, name)) 
[17:42:23.406]                             next
[17:42:23.406]                           invokeRestart(restart)
[17:42:23.406]                           muffled <- TRUE
[17:42:23.406]                           break
[17:42:23.406]                         }
[17:42:23.406]                       }
[17:42:23.406]                     }
[17:42:23.406]                     invisible(muffled)
[17:42:23.406]                   }
[17:42:23.406]                   muffleCondition(cond)
[17:42:23.406]                 })
[17:42:23.406]             }))
[17:42:23.406]             future::FutureResult(value = ...future.value$value, 
[17:42:23.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.406]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.406]                     ...future.globalenv.names))
[17:42:23.406]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.406]         }, condition = base::local({
[17:42:23.406]             c <- base::c
[17:42:23.406]             inherits <- base::inherits
[17:42:23.406]             invokeRestart <- base::invokeRestart
[17:42:23.406]             length <- base::length
[17:42:23.406]             list <- base::list
[17:42:23.406]             seq.int <- base::seq.int
[17:42:23.406]             signalCondition <- base::signalCondition
[17:42:23.406]             sys.calls <- base::sys.calls
[17:42:23.406]             `[[` <- base::`[[`
[17:42:23.406]             `+` <- base::`+`
[17:42:23.406]             `<<-` <- base::`<<-`
[17:42:23.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.406]                   3L)]
[17:42:23.406]             }
[17:42:23.406]             function(cond) {
[17:42:23.406]                 is_error <- inherits(cond, "error")
[17:42:23.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.406]                   NULL)
[17:42:23.406]                 if (is_error) {
[17:42:23.406]                   sessionInformation <- function() {
[17:42:23.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.406]                       search = base::search(), system = base::Sys.info())
[17:42:23.406]                   }
[17:42:23.406]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.406]                     cond$call), session = sessionInformation(), 
[17:42:23.406]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.406]                   signalCondition(cond)
[17:42:23.406]                 }
[17:42:23.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.406]                 "immediateCondition"))) {
[17:42:23.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.406]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.406]                   if (TRUE && !signal) {
[17:42:23.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.406]                     {
[17:42:23.406]                       inherits <- base::inherits
[17:42:23.406]                       invokeRestart <- base::invokeRestart
[17:42:23.406]                       is.null <- base::is.null
[17:42:23.406]                       muffled <- FALSE
[17:42:23.406]                       if (inherits(cond, "message")) {
[17:42:23.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.406]                         if (muffled) 
[17:42:23.406]                           invokeRestart("muffleMessage")
[17:42:23.406]                       }
[17:42:23.406]                       else if (inherits(cond, "warning")) {
[17:42:23.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.406]                         if (muffled) 
[17:42:23.406]                           invokeRestart("muffleWarning")
[17:42:23.406]                       }
[17:42:23.406]                       else if (inherits(cond, "condition")) {
[17:42:23.406]                         if (!is.null(pattern)) {
[17:42:23.406]                           computeRestarts <- base::computeRestarts
[17:42:23.406]                           grepl <- base::grepl
[17:42:23.406]                           restarts <- computeRestarts(cond)
[17:42:23.406]                           for (restart in restarts) {
[17:42:23.406]                             name <- restart$name
[17:42:23.406]                             if (is.null(name)) 
[17:42:23.406]                               next
[17:42:23.406]                             if (!grepl(pattern, name)) 
[17:42:23.406]                               next
[17:42:23.406]                             invokeRestart(restart)
[17:42:23.406]                             muffled <- TRUE
[17:42:23.406]                             break
[17:42:23.406]                           }
[17:42:23.406]                         }
[17:42:23.406]                       }
[17:42:23.406]                       invisible(muffled)
[17:42:23.406]                     }
[17:42:23.406]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.406]                   }
[17:42:23.406]                 }
[17:42:23.406]                 else {
[17:42:23.406]                   if (TRUE) {
[17:42:23.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.406]                     {
[17:42:23.406]                       inherits <- base::inherits
[17:42:23.406]                       invokeRestart <- base::invokeRestart
[17:42:23.406]                       is.null <- base::is.null
[17:42:23.406]                       muffled <- FALSE
[17:42:23.406]                       if (inherits(cond, "message")) {
[17:42:23.406]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.406]                         if (muffled) 
[17:42:23.406]                           invokeRestart("muffleMessage")
[17:42:23.406]                       }
[17:42:23.406]                       else if (inherits(cond, "warning")) {
[17:42:23.406]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.406]                         if (muffled) 
[17:42:23.406]                           invokeRestart("muffleWarning")
[17:42:23.406]                       }
[17:42:23.406]                       else if (inherits(cond, "condition")) {
[17:42:23.406]                         if (!is.null(pattern)) {
[17:42:23.406]                           computeRestarts <- base::computeRestarts
[17:42:23.406]                           grepl <- base::grepl
[17:42:23.406]                           restarts <- computeRestarts(cond)
[17:42:23.406]                           for (restart in restarts) {
[17:42:23.406]                             name <- restart$name
[17:42:23.406]                             if (is.null(name)) 
[17:42:23.406]                               next
[17:42:23.406]                             if (!grepl(pattern, name)) 
[17:42:23.406]                               next
[17:42:23.406]                             invokeRestart(restart)
[17:42:23.406]                             muffled <- TRUE
[17:42:23.406]                             break
[17:42:23.406]                           }
[17:42:23.406]                         }
[17:42:23.406]                       }
[17:42:23.406]                       invisible(muffled)
[17:42:23.406]                     }
[17:42:23.406]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.406]                   }
[17:42:23.406]                 }
[17:42:23.406]             }
[17:42:23.406]         }))
[17:42:23.406]     }, error = function(ex) {
[17:42:23.406]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.406]                 ...future.rng), started = ...future.startTime, 
[17:42:23.406]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.406]             version = "1.8"), class = "FutureResult")
[17:42:23.406]     }, finally = {
[17:42:23.406]         if (!identical(...future.workdir, getwd())) 
[17:42:23.406]             setwd(...future.workdir)
[17:42:23.406]         {
[17:42:23.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.406]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.406]             }
[17:42:23.406]             base::options(...future.oldOptions)
[17:42:23.406]             if (.Platform$OS.type == "windows") {
[17:42:23.406]                 old_names <- names(...future.oldEnvVars)
[17:42:23.406]                 envs <- base::Sys.getenv()
[17:42:23.406]                 names <- names(envs)
[17:42:23.406]                 common <- intersect(names, old_names)
[17:42:23.406]                 added <- setdiff(names, old_names)
[17:42:23.406]                 removed <- setdiff(old_names, names)
[17:42:23.406]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.406]                   envs[common]]
[17:42:23.406]                 NAMES <- toupper(changed)
[17:42:23.406]                 args <- list()
[17:42:23.406]                 for (kk in seq_along(NAMES)) {
[17:42:23.406]                   name <- changed[[kk]]
[17:42:23.406]                   NAME <- NAMES[[kk]]
[17:42:23.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.406]                     next
[17:42:23.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.406]                 }
[17:42:23.406]                 NAMES <- toupper(added)
[17:42:23.406]                 for (kk in seq_along(NAMES)) {
[17:42:23.406]                   name <- added[[kk]]
[17:42:23.406]                   NAME <- NAMES[[kk]]
[17:42:23.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.406]                     next
[17:42:23.406]                   args[[name]] <- ""
[17:42:23.406]                 }
[17:42:23.406]                 NAMES <- toupper(removed)
[17:42:23.406]                 for (kk in seq_along(NAMES)) {
[17:42:23.406]                   name <- removed[[kk]]
[17:42:23.406]                   NAME <- NAMES[[kk]]
[17:42:23.406]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.406]                     next
[17:42:23.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.406]                 }
[17:42:23.406]                 if (length(args) > 0) 
[17:42:23.406]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.406]             }
[17:42:23.406]             else {
[17:42:23.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.406]             }
[17:42:23.406]             {
[17:42:23.406]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.406]                   0L) {
[17:42:23.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.406]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.406]                   base::options(opts)
[17:42:23.406]                 }
[17:42:23.406]                 {
[17:42:23.406]                   {
[17:42:23.406]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.406]                     NULL
[17:42:23.406]                   }
[17:42:23.406]                   options(future.plan = NULL)
[17:42:23.406]                   if (is.na(NA_character_)) 
[17:42:23.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.406]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.406]                     envir = parent.frame()) 
[17:42:23.406]                   {
[17:42:23.406]                     default_workers <- missing(workers)
[17:42:23.406]                     if (is.function(workers)) 
[17:42:23.406]                       workers <- workers()
[17:42:23.406]                     workers <- structure(as.integer(workers), 
[17:42:23.406]                       class = class(workers))
[17:42:23.406]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.406]                       1L)
[17:42:23.406]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.406]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.406]                       if (default_workers) 
[17:42:23.406]                         supportsMulticore(warn = TRUE)
[17:42:23.406]                       return(sequential(..., envir = envir))
[17:42:23.406]                     }
[17:42:23.406]                     oopts <- options(mc.cores = workers)
[17:42:23.406]                     on.exit(options(oopts))
[17:42:23.406]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.406]                       envir = envir)
[17:42:23.406]                     if (!future$lazy) 
[17:42:23.406]                       future <- run(future)
[17:42:23.406]                     invisible(future)
[17:42:23.406]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.406]                 }
[17:42:23.406]             }
[17:42:23.406]         }
[17:42:23.406]     })
[17:42:23.406]     if (TRUE) {
[17:42:23.406]         base::sink(type = "output", split = FALSE)
[17:42:23.406]         if (TRUE) {
[17:42:23.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.406]         }
[17:42:23.406]         else {
[17:42:23.406]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.406]         }
[17:42:23.406]         base::close(...future.stdout)
[17:42:23.406]         ...future.stdout <- NULL
[17:42:23.406]     }
[17:42:23.406]     ...future.result$conditions <- ...future.conditions
[17:42:23.406]     ...future.result$finished <- base::Sys.time()
[17:42:23.406]     ...future.result
[17:42:23.406] }
[17:42:23.408] requestCore(): workers = 2
[17:42:23.411] MulticoreFuture started
[17:42:23.412] - Launch lazy future ... done
[17:42:23.412] run() for ‘MulticoreFuture’ ... done
[17:42:23.412] getGlobalsAndPackages() ...
[17:42:23.412] Searching for globals...
[17:42:23.412] plan(): Setting new future strategy stack:
[17:42:23.413] List of future strategies:
[17:42:23.413] 1. sequential:
[17:42:23.413]    - args: function (..., envir = parent.frame())
[17:42:23.413]    - tweaked: FALSE
[17:42:23.413]    - call: NULL
[17:42:23.413] 
[17:42:23.413] Searching for globals ... DONE
[17:42:23.413] plan(): nbrOfWorkers() = 1
[17:42:23.413] - globals: [0] <none>
[17:42:23.414] getGlobalsAndPackages() ... DONE
[17:42:23.414] run() for ‘Future’ ...
[17:42:23.414] - state: ‘created’
[17:42:23.414] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.415] plan(): Setting new future strategy stack:
[17:42:23.415] List of future strategies:
[17:42:23.415] 1. multicore:
[17:42:23.415]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.415]    - tweaked: FALSE
[17:42:23.415]    - call: plan(strategy)
[17:42:23.420] plan(): nbrOfWorkers() = 2
[17:42:23.420] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.420] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.421]   - Field: ‘label’
[17:42:23.421]   - Field: ‘local’
[17:42:23.421]   - Field: ‘owner’
[17:42:23.421]   - Field: ‘envir’
[17:42:23.421]   - Field: ‘workers’
[17:42:23.421]   - Field: ‘packages’
[17:42:23.422]   - Field: ‘gc’
[17:42:23.422]   - Field: ‘job’
[17:42:23.422]   - Field: ‘conditions’
[17:42:23.422]   - Field: ‘expr’
[17:42:23.422]   - Field: ‘uuid’
[17:42:23.422]   - Field: ‘seed’
[17:42:23.422]   - Field: ‘version’
[17:42:23.423]   - Field: ‘result’
[17:42:23.423]   - Field: ‘asynchronous’
[17:42:23.423]   - Field: ‘calls’
[17:42:23.423]   - Field: ‘globals’
[17:42:23.423]   - Field: ‘stdout’
[17:42:23.423]   - Field: ‘earlySignal’
[17:42:23.423]   - Field: ‘lazy’
[17:42:23.424]   - Field: ‘state’
[17:42:23.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.424] - Launch lazy future ...
[17:42:23.424] Packages needed by the future expression (n = 0): <none>
[17:42:23.425] Packages needed by future strategies (n = 0): <none>
[17:42:23.425] {
[17:42:23.425]     {
[17:42:23.425]         {
[17:42:23.425]             ...future.startTime <- base::Sys.time()
[17:42:23.425]             {
[17:42:23.425]                 {
[17:42:23.425]                   {
[17:42:23.425]                     {
[17:42:23.425]                       base::local({
[17:42:23.425]                         has_future <- base::requireNamespace("future", 
[17:42:23.425]                           quietly = TRUE)
[17:42:23.425]                         if (has_future) {
[17:42:23.425]                           ns <- base::getNamespace("future")
[17:42:23.425]                           version <- ns[[".package"]][["version"]]
[17:42:23.425]                           if (is.null(version)) 
[17:42:23.425]                             version <- utils::packageVersion("future")
[17:42:23.425]                         }
[17:42:23.425]                         else {
[17:42:23.425]                           version <- NULL
[17:42:23.425]                         }
[17:42:23.425]                         if (!has_future || version < "1.8.0") {
[17:42:23.425]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.425]                             "", base::R.version$version.string), 
[17:42:23.425]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.425]                               "release", "version")], collapse = " "), 
[17:42:23.425]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.425]                             info)
[17:42:23.425]                           info <- base::paste(info, collapse = "; ")
[17:42:23.425]                           if (!has_future) {
[17:42:23.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.425]                               info)
[17:42:23.425]                           }
[17:42:23.425]                           else {
[17:42:23.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.425]                               info, version)
[17:42:23.425]                           }
[17:42:23.425]                           base::stop(msg)
[17:42:23.425]                         }
[17:42:23.425]                       })
[17:42:23.425]                     }
[17:42:23.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.425]                     base::options(mc.cores = 1L)
[17:42:23.425]                   }
[17:42:23.425]                   options(future.plan = NULL)
[17:42:23.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.425]                 }
[17:42:23.425]                 ...future.workdir <- getwd()
[17:42:23.425]             }
[17:42:23.425]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.425]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.425]         }
[17:42:23.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.425]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.425]             base::names(...future.oldOptions))
[17:42:23.425]     }
[17:42:23.425]     if (FALSE) {
[17:42:23.425]     }
[17:42:23.425]     else {
[17:42:23.425]         if (TRUE) {
[17:42:23.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.425]                 open = "w")
[17:42:23.425]         }
[17:42:23.425]         else {
[17:42:23.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.425]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.425]         }
[17:42:23.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.425]             base::sink(type = "output", split = FALSE)
[17:42:23.425]             base::close(...future.stdout)
[17:42:23.425]         }, add = TRUE)
[17:42:23.425]     }
[17:42:23.425]     ...future.frame <- base::sys.nframe()
[17:42:23.425]     ...future.conditions <- base::list()
[17:42:23.425]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.425]     if (FALSE) {
[17:42:23.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.425]     }
[17:42:23.425]     ...future.result <- base::tryCatch({
[17:42:23.425]         base::withCallingHandlers({
[17:42:23.425]             ...future.value <- base::withVisible(base::local({
[17:42:23.425]                 withCallingHandlers({
[17:42:23.425]                   NULL
[17:42:23.425]                 }, immediateCondition = function(cond) {
[17:42:23.425]                   save_rds <- function (object, pathname, ...) 
[17:42:23.425]                   {
[17:42:23.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.425]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.425]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.425]                         fi_tmp[["mtime"]])
[17:42:23.425]                     }
[17:42:23.425]                     tryCatch({
[17:42:23.425]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.425]                     }, error = function(ex) {
[17:42:23.425]                       msg <- conditionMessage(ex)
[17:42:23.425]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.425]                         fi_tmp[["mtime"]], msg)
[17:42:23.425]                       ex$message <- msg
[17:42:23.425]                       stop(ex)
[17:42:23.425]                     })
[17:42:23.425]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.425]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.425]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.425]                       fi <- file.info(pathname)
[17:42:23.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.425]                         fi[["size"]], fi[["mtime"]])
[17:42:23.425]                       stop(msg)
[17:42:23.425]                     }
[17:42:23.425]                     invisible(pathname)
[17:42:23.425]                   }
[17:42:23.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.425]                     rootPath = tempdir()) 
[17:42:23.425]                   {
[17:42:23.425]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.425]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.425]                       tmpdir = path, fileext = ".rds")
[17:42:23.425]                     save_rds(obj, file)
[17:42:23.425]                   }
[17:42:23.425]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.425]                   {
[17:42:23.425]                     inherits <- base::inherits
[17:42:23.425]                     invokeRestart <- base::invokeRestart
[17:42:23.425]                     is.null <- base::is.null
[17:42:23.425]                     muffled <- FALSE
[17:42:23.425]                     if (inherits(cond, "message")) {
[17:42:23.425]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.425]                       if (muffled) 
[17:42:23.425]                         invokeRestart("muffleMessage")
[17:42:23.425]                     }
[17:42:23.425]                     else if (inherits(cond, "warning")) {
[17:42:23.425]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.425]                       if (muffled) 
[17:42:23.425]                         invokeRestart("muffleWarning")
[17:42:23.425]                     }
[17:42:23.425]                     else if (inherits(cond, "condition")) {
[17:42:23.425]                       if (!is.null(pattern)) {
[17:42:23.425]                         computeRestarts <- base::computeRestarts
[17:42:23.425]                         grepl <- base::grepl
[17:42:23.425]                         restarts <- computeRestarts(cond)
[17:42:23.425]                         for (restart in restarts) {
[17:42:23.425]                           name <- restart$name
[17:42:23.425]                           if (is.null(name)) 
[17:42:23.425]                             next
[17:42:23.425]                           if (!grepl(pattern, name)) 
[17:42:23.425]                             next
[17:42:23.425]                           invokeRestart(restart)
[17:42:23.425]                           muffled <- TRUE
[17:42:23.425]                           break
[17:42:23.425]                         }
[17:42:23.425]                       }
[17:42:23.425]                     }
[17:42:23.425]                     invisible(muffled)
[17:42:23.425]                   }
[17:42:23.425]                   muffleCondition(cond)
[17:42:23.425]                 })
[17:42:23.425]             }))
[17:42:23.425]             future::FutureResult(value = ...future.value$value, 
[17:42:23.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.425]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.425]                     ...future.globalenv.names))
[17:42:23.425]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.425]         }, condition = base::local({
[17:42:23.425]             c <- base::c
[17:42:23.425]             inherits <- base::inherits
[17:42:23.425]             invokeRestart <- base::invokeRestart
[17:42:23.425]             length <- base::length
[17:42:23.425]             list <- base::list
[17:42:23.425]             seq.int <- base::seq.int
[17:42:23.425]             signalCondition <- base::signalCondition
[17:42:23.425]             sys.calls <- base::sys.calls
[17:42:23.425]             `[[` <- base::`[[`
[17:42:23.425]             `+` <- base::`+`
[17:42:23.425]             `<<-` <- base::`<<-`
[17:42:23.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.425]                   3L)]
[17:42:23.425]             }
[17:42:23.425]             function(cond) {
[17:42:23.425]                 is_error <- inherits(cond, "error")
[17:42:23.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.425]                   NULL)
[17:42:23.425]                 if (is_error) {
[17:42:23.425]                   sessionInformation <- function() {
[17:42:23.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.425]                       search = base::search(), system = base::Sys.info())
[17:42:23.425]                   }
[17:42:23.425]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.425]                     cond$call), session = sessionInformation(), 
[17:42:23.425]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.425]                   signalCondition(cond)
[17:42:23.425]                 }
[17:42:23.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.425]                 "immediateCondition"))) {
[17:42:23.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.425]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.425]                   if (TRUE && !signal) {
[17:42:23.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.425]                     {
[17:42:23.425]                       inherits <- base::inherits
[17:42:23.425]                       invokeRestart <- base::invokeRestart
[17:42:23.425]                       is.null <- base::is.null
[17:42:23.425]                       muffled <- FALSE
[17:42:23.425]                       if (inherits(cond, "message")) {
[17:42:23.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.425]                         if (muffled) 
[17:42:23.425]                           invokeRestart("muffleMessage")
[17:42:23.425]                       }
[17:42:23.425]                       else if (inherits(cond, "warning")) {
[17:42:23.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.425]                         if (muffled) 
[17:42:23.425]                           invokeRestart("muffleWarning")
[17:42:23.425]                       }
[17:42:23.425]                       else if (inherits(cond, "condition")) {
[17:42:23.425]                         if (!is.null(pattern)) {
[17:42:23.425]                           computeRestarts <- base::computeRestarts
[17:42:23.425]                           grepl <- base::grepl
[17:42:23.425]                           restarts <- computeRestarts(cond)
[17:42:23.425]                           for (restart in restarts) {
[17:42:23.425]                             name <- restart$name
[17:42:23.425]                             if (is.null(name)) 
[17:42:23.425]                               next
[17:42:23.425]                             if (!grepl(pattern, name)) 
[17:42:23.425]                               next
[17:42:23.425]                             invokeRestart(restart)
[17:42:23.425]                             muffled <- TRUE
[17:42:23.425]                             break
[17:42:23.425]                           }
[17:42:23.425]                         }
[17:42:23.425]                       }
[17:42:23.425]                       invisible(muffled)
[17:42:23.425]                     }
[17:42:23.425]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.425]                   }
[17:42:23.425]                 }
[17:42:23.425]                 else {
[17:42:23.425]                   if (TRUE) {
[17:42:23.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.425]                     {
[17:42:23.425]                       inherits <- base::inherits
[17:42:23.425]                       invokeRestart <- base::invokeRestart
[17:42:23.425]                       is.null <- base::is.null
[17:42:23.425]                       muffled <- FALSE
[17:42:23.425]                       if (inherits(cond, "message")) {
[17:42:23.425]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.425]                         if (muffled) 
[17:42:23.425]                           invokeRestart("muffleMessage")
[17:42:23.425]                       }
[17:42:23.425]                       else if (inherits(cond, "warning")) {
[17:42:23.425]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.425]                         if (muffled) 
[17:42:23.425]                           invokeRestart("muffleWarning")
[17:42:23.425]                       }
[17:42:23.425]                       else if (inherits(cond, "condition")) {
[17:42:23.425]                         if (!is.null(pattern)) {
[17:42:23.425]                           computeRestarts <- base::computeRestarts
[17:42:23.425]                           grepl <- base::grepl
[17:42:23.425]                           restarts <- computeRestarts(cond)
[17:42:23.425]                           for (restart in restarts) {
[17:42:23.425]                             name <- restart$name
[17:42:23.425]                             if (is.null(name)) 
[17:42:23.425]                               next
[17:42:23.425]                             if (!grepl(pattern, name)) 
[17:42:23.425]                               next
[17:42:23.425]                             invokeRestart(restart)
[17:42:23.425]                             muffled <- TRUE
[17:42:23.425]                             break
[17:42:23.425]                           }
[17:42:23.425]                         }
[17:42:23.425]                       }
[17:42:23.425]                       invisible(muffled)
[17:42:23.425]                     }
[17:42:23.425]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.425]                   }
[17:42:23.425]                 }
[17:42:23.425]             }
[17:42:23.425]         }))
[17:42:23.425]     }, error = function(ex) {
[17:42:23.425]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.425]                 ...future.rng), started = ...future.startTime, 
[17:42:23.425]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.425]             version = "1.8"), class = "FutureResult")
[17:42:23.425]     }, finally = {
[17:42:23.425]         if (!identical(...future.workdir, getwd())) 
[17:42:23.425]             setwd(...future.workdir)
[17:42:23.425]         {
[17:42:23.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.425]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.425]             }
[17:42:23.425]             base::options(...future.oldOptions)
[17:42:23.425]             if (.Platform$OS.type == "windows") {
[17:42:23.425]                 old_names <- names(...future.oldEnvVars)
[17:42:23.425]                 envs <- base::Sys.getenv()
[17:42:23.425]                 names <- names(envs)
[17:42:23.425]                 common <- intersect(names, old_names)
[17:42:23.425]                 added <- setdiff(names, old_names)
[17:42:23.425]                 removed <- setdiff(old_names, names)
[17:42:23.425]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.425]                   envs[common]]
[17:42:23.425]                 NAMES <- toupper(changed)
[17:42:23.425]                 args <- list()
[17:42:23.425]                 for (kk in seq_along(NAMES)) {
[17:42:23.425]                   name <- changed[[kk]]
[17:42:23.425]                   NAME <- NAMES[[kk]]
[17:42:23.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.425]                     next
[17:42:23.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.425]                 }
[17:42:23.425]                 NAMES <- toupper(added)
[17:42:23.425]                 for (kk in seq_along(NAMES)) {
[17:42:23.425]                   name <- added[[kk]]
[17:42:23.425]                   NAME <- NAMES[[kk]]
[17:42:23.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.425]                     next
[17:42:23.425]                   args[[name]] <- ""
[17:42:23.425]                 }
[17:42:23.425]                 NAMES <- toupper(removed)
[17:42:23.425]                 for (kk in seq_along(NAMES)) {
[17:42:23.425]                   name <- removed[[kk]]
[17:42:23.425]                   NAME <- NAMES[[kk]]
[17:42:23.425]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.425]                     next
[17:42:23.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.425]                 }
[17:42:23.425]                 if (length(args) > 0) 
[17:42:23.425]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.425]             }
[17:42:23.425]             else {
[17:42:23.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.425]             }
[17:42:23.425]             {
[17:42:23.425]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.425]                   0L) {
[17:42:23.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.425]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.425]                   base::options(opts)
[17:42:23.425]                 }
[17:42:23.425]                 {
[17:42:23.425]                   {
[17:42:23.425]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.425]                     NULL
[17:42:23.425]                   }
[17:42:23.425]                   options(future.plan = NULL)
[17:42:23.425]                   if (is.na(NA_character_)) 
[17:42:23.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.425]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.425]                     envir = parent.frame()) 
[17:42:23.425]                   {
[17:42:23.425]                     default_workers <- missing(workers)
[17:42:23.425]                     if (is.function(workers)) 
[17:42:23.425]                       workers <- workers()
[17:42:23.425]                     workers <- structure(as.integer(workers), 
[17:42:23.425]                       class = class(workers))
[17:42:23.425]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.425]                       1L)
[17:42:23.425]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.425]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.425]                       if (default_workers) 
[17:42:23.425]                         supportsMulticore(warn = TRUE)
[17:42:23.425]                       return(sequential(..., envir = envir))
[17:42:23.425]                     }
[17:42:23.425]                     oopts <- options(mc.cores = workers)
[17:42:23.425]                     on.exit(options(oopts))
[17:42:23.425]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.425]                       envir = envir)
[17:42:23.425]                     if (!future$lazy) 
[17:42:23.425]                       future <- run(future)
[17:42:23.425]                     invisible(future)
[17:42:23.425]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.425]                 }
[17:42:23.425]             }
[17:42:23.425]         }
[17:42:23.425]     })
[17:42:23.425]     if (TRUE) {
[17:42:23.425]         base::sink(type = "output", split = FALSE)
[17:42:23.425]         if (TRUE) {
[17:42:23.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.425]         }
[17:42:23.425]         else {
[17:42:23.425]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.425]         }
[17:42:23.425]         base::close(...future.stdout)
[17:42:23.425]         ...future.stdout <- NULL
[17:42:23.425]     }
[17:42:23.425]     ...future.result$conditions <- ...future.conditions
[17:42:23.425]     ...future.result$finished <- base::Sys.time()
[17:42:23.425]     ...future.result
[17:42:23.425] }
[17:42:23.429] requestCore(): workers = 2
[17:42:23.431] MulticoreFuture started
[17:42:23.432] - Launch lazy future ... done
[17:42:23.432] run() for ‘MulticoreFuture’ ... done
[17:42:23.433] plan(): Setting new future strategy stack:
[17:42:23.433] getGlobalsAndPackages() ...
[17:42:23.433] Searching for globals...
[17:42:23.433] List of future strategies:
[17:42:23.433] 1. sequential:
[17:42:23.433]    - args: function (..., envir = parent.frame())
[17:42:23.433]    - tweaked: FALSE
[17:42:23.433]    - call: NULL
[17:42:23.434] plan(): nbrOfWorkers() = 1
[17:42:23.434] - globals found: [1] ‘{’
[17:42:23.435] Searching for globals ... DONE
[17:42:23.435] Resolving globals: FALSE
[17:42:23.435] 
[17:42:23.436] 
[17:42:23.436] plan(): Setting new future strategy stack:
[17:42:23.436] getGlobalsAndPackages() ... DONE
[17:42:23.436] run() for ‘Future’ ...
[17:42:23.436] List of future strategies:
[17:42:23.436] 1. multicore:
[17:42:23.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.436]    - tweaked: FALSE
[17:42:23.436]    - call: plan(strategy)
[17:42:23.436] - state: ‘created’
[17:42:23.437] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.442] plan(): nbrOfWorkers() = 2
[17:42:23.442] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.442]   - Field: ‘label’
[17:42:23.442]   - Field: ‘local’
[17:42:23.442]   - Field: ‘owner’
[17:42:23.443]   - Field: ‘envir’
[17:42:23.443]   - Field: ‘workers’
[17:42:23.443]   - Field: ‘packages’
[17:42:23.443]   - Field: ‘gc’
[17:42:23.443]   - Field: ‘job’
[17:42:23.443]   - Field: ‘conditions’
[17:42:23.443]   - Field: ‘expr’
[17:42:23.444]   - Field: ‘uuid’
[17:42:23.444]   - Field: ‘seed’
[17:42:23.444]   - Field: ‘version’
[17:42:23.444]   - Field: ‘result’
[17:42:23.444]   - Field: ‘asynchronous’
[17:42:23.444]   - Field: ‘calls’
[17:42:23.444]   - Field: ‘globals’
[17:42:23.445]   - Field: ‘stdout’
[17:42:23.445]   - Field: ‘earlySignal’
[17:42:23.445]   - Field: ‘lazy’
[17:42:23.445]   - Field: ‘state’
[17:42:23.445] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.445] - Launch lazy future ...
[17:42:23.446] Packages needed by the future expression (n = 0): <none>
[17:42:23.446] Packages needed by future strategies (n = 0): <none>
[17:42:23.447] {
[17:42:23.447]     {
[17:42:23.447]         {
[17:42:23.447]             ...future.startTime <- base::Sys.time()
[17:42:23.447]             {
[17:42:23.447]                 {
[17:42:23.447]                   {
[17:42:23.447]                     {
[17:42:23.447]                       base::local({
[17:42:23.447]                         has_future <- base::requireNamespace("future", 
[17:42:23.447]                           quietly = TRUE)
[17:42:23.447]                         if (has_future) {
[17:42:23.447]                           ns <- base::getNamespace("future")
[17:42:23.447]                           version <- ns[[".package"]][["version"]]
[17:42:23.447]                           if (is.null(version)) 
[17:42:23.447]                             version <- utils::packageVersion("future")
[17:42:23.447]                         }
[17:42:23.447]                         else {
[17:42:23.447]                           version <- NULL
[17:42:23.447]                         }
[17:42:23.447]                         if (!has_future || version < "1.8.0") {
[17:42:23.447]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.447]                             "", base::R.version$version.string), 
[17:42:23.447]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.447]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.447]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.447]                               "release", "version")], collapse = " "), 
[17:42:23.447]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.447]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.447]                             info)
[17:42:23.447]                           info <- base::paste(info, collapse = "; ")
[17:42:23.447]                           if (!has_future) {
[17:42:23.447]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.447]                               info)
[17:42:23.447]                           }
[17:42:23.447]                           else {
[17:42:23.447]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.447]                               info, version)
[17:42:23.447]                           }
[17:42:23.447]                           base::stop(msg)
[17:42:23.447]                         }
[17:42:23.447]                       })
[17:42:23.447]                     }
[17:42:23.447]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.447]                     base::options(mc.cores = 1L)
[17:42:23.447]                   }
[17:42:23.447]                   options(future.plan = NULL)
[17:42:23.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.447]                 }
[17:42:23.447]                 ...future.workdir <- getwd()
[17:42:23.447]             }
[17:42:23.447]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.447]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.447]         }
[17:42:23.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.447]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.447]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.447]             base::names(...future.oldOptions))
[17:42:23.447]     }
[17:42:23.447]     if (FALSE) {
[17:42:23.447]     }
[17:42:23.447]     else {
[17:42:23.447]         if (TRUE) {
[17:42:23.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.447]                 open = "w")
[17:42:23.447]         }
[17:42:23.447]         else {
[17:42:23.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.447]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.447]         }
[17:42:23.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.447]             base::sink(type = "output", split = FALSE)
[17:42:23.447]             base::close(...future.stdout)
[17:42:23.447]         }, add = TRUE)
[17:42:23.447]     }
[17:42:23.447]     ...future.frame <- base::sys.nframe()
[17:42:23.447]     ...future.conditions <- base::list()
[17:42:23.447]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.447]     if (FALSE) {
[17:42:23.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.447]     }
[17:42:23.447]     ...future.result <- base::tryCatch({
[17:42:23.447]         base::withCallingHandlers({
[17:42:23.447]             ...future.value <- base::withVisible(base::local({
[17:42:23.447]                 withCallingHandlers({
[17:42:23.447]                   {
[17:42:23.447]                     4
[17:42:23.447]                   }
[17:42:23.447]                 }, immediateCondition = function(cond) {
[17:42:23.447]                   save_rds <- function (object, pathname, ...) 
[17:42:23.447]                   {
[17:42:23.447]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.447]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.447]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.447]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.447]                         fi_tmp[["mtime"]])
[17:42:23.447]                     }
[17:42:23.447]                     tryCatch({
[17:42:23.447]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.447]                     }, error = function(ex) {
[17:42:23.447]                       msg <- conditionMessage(ex)
[17:42:23.447]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.447]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.447]                         fi_tmp[["mtime"]], msg)
[17:42:23.447]                       ex$message <- msg
[17:42:23.447]                       stop(ex)
[17:42:23.447]                     })
[17:42:23.447]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.447]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.447]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.447]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.447]                       fi <- file.info(pathname)
[17:42:23.447]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.447]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.447]                         fi[["size"]], fi[["mtime"]])
[17:42:23.447]                       stop(msg)
[17:42:23.447]                     }
[17:42:23.447]                     invisible(pathname)
[17:42:23.447]                   }
[17:42:23.447]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.447]                     rootPath = tempdir()) 
[17:42:23.447]                   {
[17:42:23.447]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.447]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.447]                       tmpdir = path, fileext = ".rds")
[17:42:23.447]                     save_rds(obj, file)
[17:42:23.447]                   }
[17:42:23.447]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.447]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.447]                   {
[17:42:23.447]                     inherits <- base::inherits
[17:42:23.447]                     invokeRestart <- base::invokeRestart
[17:42:23.447]                     is.null <- base::is.null
[17:42:23.447]                     muffled <- FALSE
[17:42:23.447]                     if (inherits(cond, "message")) {
[17:42:23.447]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.447]                       if (muffled) 
[17:42:23.447]                         invokeRestart("muffleMessage")
[17:42:23.447]                     }
[17:42:23.447]                     else if (inherits(cond, "warning")) {
[17:42:23.447]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.447]                       if (muffled) 
[17:42:23.447]                         invokeRestart("muffleWarning")
[17:42:23.447]                     }
[17:42:23.447]                     else if (inherits(cond, "condition")) {
[17:42:23.447]                       if (!is.null(pattern)) {
[17:42:23.447]                         computeRestarts <- base::computeRestarts
[17:42:23.447]                         grepl <- base::grepl
[17:42:23.447]                         restarts <- computeRestarts(cond)
[17:42:23.447]                         for (restart in restarts) {
[17:42:23.447]                           name <- restart$name
[17:42:23.447]                           if (is.null(name)) 
[17:42:23.447]                             next
[17:42:23.447]                           if (!grepl(pattern, name)) 
[17:42:23.447]                             next
[17:42:23.447]                           invokeRestart(restart)
[17:42:23.447]                           muffled <- TRUE
[17:42:23.447]                           break
[17:42:23.447]                         }
[17:42:23.447]                       }
[17:42:23.447]                     }
[17:42:23.447]                     invisible(muffled)
[17:42:23.447]                   }
[17:42:23.447]                   muffleCondition(cond)
[17:42:23.447]                 })
[17:42:23.447]             }))
[17:42:23.447]             future::FutureResult(value = ...future.value$value, 
[17:42:23.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.447]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.447]                     ...future.globalenv.names))
[17:42:23.447]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.447]         }, condition = base::local({
[17:42:23.447]             c <- base::c
[17:42:23.447]             inherits <- base::inherits
[17:42:23.447]             invokeRestart <- base::invokeRestart
[17:42:23.447]             length <- base::length
[17:42:23.447]             list <- base::list
[17:42:23.447]             seq.int <- base::seq.int
[17:42:23.447]             signalCondition <- base::signalCondition
[17:42:23.447]             sys.calls <- base::sys.calls
[17:42:23.447]             `[[` <- base::`[[`
[17:42:23.447]             `+` <- base::`+`
[17:42:23.447]             `<<-` <- base::`<<-`
[17:42:23.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.447]                   3L)]
[17:42:23.447]             }
[17:42:23.447]             function(cond) {
[17:42:23.447]                 is_error <- inherits(cond, "error")
[17:42:23.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.447]                   NULL)
[17:42:23.447]                 if (is_error) {
[17:42:23.447]                   sessionInformation <- function() {
[17:42:23.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.447]                       search = base::search(), system = base::Sys.info())
[17:42:23.447]                   }
[17:42:23.447]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.447]                     cond$call), session = sessionInformation(), 
[17:42:23.447]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.447]                   signalCondition(cond)
[17:42:23.447]                 }
[17:42:23.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.447]                 "immediateCondition"))) {
[17:42:23.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.447]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.447]                   if (TRUE && !signal) {
[17:42:23.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.447]                     {
[17:42:23.447]                       inherits <- base::inherits
[17:42:23.447]                       invokeRestart <- base::invokeRestart
[17:42:23.447]                       is.null <- base::is.null
[17:42:23.447]                       muffled <- FALSE
[17:42:23.447]                       if (inherits(cond, "message")) {
[17:42:23.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.447]                         if (muffled) 
[17:42:23.447]                           invokeRestart("muffleMessage")
[17:42:23.447]                       }
[17:42:23.447]                       else if (inherits(cond, "warning")) {
[17:42:23.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.447]                         if (muffled) 
[17:42:23.447]                           invokeRestart("muffleWarning")
[17:42:23.447]                       }
[17:42:23.447]                       else if (inherits(cond, "condition")) {
[17:42:23.447]                         if (!is.null(pattern)) {
[17:42:23.447]                           computeRestarts <- base::computeRestarts
[17:42:23.447]                           grepl <- base::grepl
[17:42:23.447]                           restarts <- computeRestarts(cond)
[17:42:23.447]                           for (restart in restarts) {
[17:42:23.447]                             name <- restart$name
[17:42:23.447]                             if (is.null(name)) 
[17:42:23.447]                               next
[17:42:23.447]                             if (!grepl(pattern, name)) 
[17:42:23.447]                               next
[17:42:23.447]                             invokeRestart(restart)
[17:42:23.447]                             muffled <- TRUE
[17:42:23.447]                             break
[17:42:23.447]                           }
[17:42:23.447]                         }
[17:42:23.447]                       }
[17:42:23.447]                       invisible(muffled)
[17:42:23.447]                     }
[17:42:23.447]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.447]                   }
[17:42:23.447]                 }
[17:42:23.447]                 else {
[17:42:23.447]                   if (TRUE) {
[17:42:23.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.447]                     {
[17:42:23.447]                       inherits <- base::inherits
[17:42:23.447]                       invokeRestart <- base::invokeRestart
[17:42:23.447]                       is.null <- base::is.null
[17:42:23.447]                       muffled <- FALSE
[17:42:23.447]                       if (inherits(cond, "message")) {
[17:42:23.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.447]                         if (muffled) 
[17:42:23.447]                           invokeRestart("muffleMessage")
[17:42:23.447]                       }
[17:42:23.447]                       else if (inherits(cond, "warning")) {
[17:42:23.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.447]                         if (muffled) 
[17:42:23.447]                           invokeRestart("muffleWarning")
[17:42:23.447]                       }
[17:42:23.447]                       else if (inherits(cond, "condition")) {
[17:42:23.447]                         if (!is.null(pattern)) {
[17:42:23.447]                           computeRestarts <- base::computeRestarts
[17:42:23.447]                           grepl <- base::grepl
[17:42:23.447]                           restarts <- computeRestarts(cond)
[17:42:23.447]                           for (restart in restarts) {
[17:42:23.447]                             name <- restart$name
[17:42:23.447]                             if (is.null(name)) 
[17:42:23.447]                               next
[17:42:23.447]                             if (!grepl(pattern, name)) 
[17:42:23.447]                               next
[17:42:23.447]                             invokeRestart(restart)
[17:42:23.447]                             muffled <- TRUE
[17:42:23.447]                             break
[17:42:23.447]                           }
[17:42:23.447]                         }
[17:42:23.447]                       }
[17:42:23.447]                       invisible(muffled)
[17:42:23.447]                     }
[17:42:23.447]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.447]                   }
[17:42:23.447]                 }
[17:42:23.447]             }
[17:42:23.447]         }))
[17:42:23.447]     }, error = function(ex) {
[17:42:23.447]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.447]                 ...future.rng), started = ...future.startTime, 
[17:42:23.447]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.447]             version = "1.8"), class = "FutureResult")
[17:42:23.447]     }, finally = {
[17:42:23.447]         if (!identical(...future.workdir, getwd())) 
[17:42:23.447]             setwd(...future.workdir)
[17:42:23.447]         {
[17:42:23.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.447]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.447]             }
[17:42:23.447]             base::options(...future.oldOptions)
[17:42:23.447]             if (.Platform$OS.type == "windows") {
[17:42:23.447]                 old_names <- names(...future.oldEnvVars)
[17:42:23.447]                 envs <- base::Sys.getenv()
[17:42:23.447]                 names <- names(envs)
[17:42:23.447]                 common <- intersect(names, old_names)
[17:42:23.447]                 added <- setdiff(names, old_names)
[17:42:23.447]                 removed <- setdiff(old_names, names)
[17:42:23.447]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.447]                   envs[common]]
[17:42:23.447]                 NAMES <- toupper(changed)
[17:42:23.447]                 args <- list()
[17:42:23.447]                 for (kk in seq_along(NAMES)) {
[17:42:23.447]                   name <- changed[[kk]]
[17:42:23.447]                   NAME <- NAMES[[kk]]
[17:42:23.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.447]                     next
[17:42:23.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.447]                 }
[17:42:23.447]                 NAMES <- toupper(added)
[17:42:23.447]                 for (kk in seq_along(NAMES)) {
[17:42:23.447]                   name <- added[[kk]]
[17:42:23.447]                   NAME <- NAMES[[kk]]
[17:42:23.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.447]                     next
[17:42:23.447]                   args[[name]] <- ""
[17:42:23.447]                 }
[17:42:23.447]                 NAMES <- toupper(removed)
[17:42:23.447]                 for (kk in seq_along(NAMES)) {
[17:42:23.447]                   name <- removed[[kk]]
[17:42:23.447]                   NAME <- NAMES[[kk]]
[17:42:23.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.447]                     next
[17:42:23.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.447]                 }
[17:42:23.447]                 if (length(args) > 0) 
[17:42:23.447]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.447]             }
[17:42:23.447]             else {
[17:42:23.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.447]             }
[17:42:23.447]             {
[17:42:23.447]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.447]                   0L) {
[17:42:23.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.447]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.447]                   base::options(opts)
[17:42:23.447]                 }
[17:42:23.447]                 {
[17:42:23.447]                   {
[17:42:23.447]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.447]                     NULL
[17:42:23.447]                   }
[17:42:23.447]                   options(future.plan = NULL)
[17:42:23.447]                   if (is.na(NA_character_)) 
[17:42:23.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.447]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.447]                     envir = parent.frame()) 
[17:42:23.447]                   {
[17:42:23.447]                     default_workers <- missing(workers)
[17:42:23.447]                     if (is.function(workers)) 
[17:42:23.447]                       workers <- workers()
[17:42:23.447]                     workers <- structure(as.integer(workers), 
[17:42:23.447]                       class = class(workers))
[17:42:23.447]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.447]                       1L)
[17:42:23.447]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.447]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.447]                       if (default_workers) 
[17:42:23.447]                         supportsMulticore(warn = TRUE)
[17:42:23.447]                       return(sequential(..., envir = envir))
[17:42:23.447]                     }
[17:42:23.447]                     oopts <- options(mc.cores = workers)
[17:42:23.447]                     on.exit(options(oopts))
[17:42:23.447]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.447]                       envir = envir)
[17:42:23.447]                     if (!future$lazy) 
[17:42:23.447]                       future <- run(future)
[17:42:23.447]                     invisible(future)
[17:42:23.447]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.447]                 }
[17:42:23.447]             }
[17:42:23.447]         }
[17:42:23.447]     })
[17:42:23.447]     if (TRUE) {
[17:42:23.447]         base::sink(type = "output", split = FALSE)
[17:42:23.447]         if (TRUE) {
[17:42:23.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.447]         }
[17:42:23.447]         else {
[17:42:23.447]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.447]         }
[17:42:23.447]         base::close(...future.stdout)
[17:42:23.447]         ...future.stdout <- NULL
[17:42:23.447]     }
[17:42:23.447]     ...future.result$conditions <- ...future.conditions
[17:42:23.447]     ...future.result$finished <- base::Sys.time()
[17:42:23.447]     ...future.result
[17:42:23.447] }
[17:42:23.450] requestCore(): workers = 2
[17:42:23.451] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:23.465] MulticoreFuture started
[17:42:23.466] - Launch lazy future ... done
[17:42:23.466] run() for ‘MulticoreFuture’ ... done
[17:42:23.467] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55bef94d5898> 
[17:42:23.467] List of future strategies:
[17:42:23.467] 1. sequential:
[17:42:23.467]    - args: function (..., envir = parent.frame())
[17:42:23.467]    - tweaked: FALSE
[17:42:23.467]    - call: NULL
[17:42:23.468] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55bef9fb82f8> 
 - attr(*, "dim.")=[17:42:23.471] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=[17:42:23.471] List of future strategies:
[17:42:23.471] 1. multicore:
[17:42:23.471]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.471]    - tweaked: FALSE
[17:42:23.471]    - call: plan(strategy)
List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:42:23.478] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:23.490] resolve() on list environment ...
[17:42:23.490]  recursive: 0
[17:42:23.491]  length: 6
[17:42:23.491]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:23.492] signalConditionsASAP(numeric, pos=1) ...
[17:42:23.492] - nx: 6
[17:42:23.492] - relay: TRUE
[17:42:23.492] - stdout: TRUE
[17:42:23.492] - signal: TRUE
[17:42:23.492] - resignal: FALSE
[17:42:23.492] - force: TRUE
[17:42:23.493] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.493] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.493]  - until=2
[17:42:23.493]  - relaying element #2
[17:42:23.493] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.493] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.493] signalConditionsASAP(NULL, pos=1) ... done
[17:42:23.494]  length: 5 (resolved future 1)
[17:42:23.494] Future #2
[17:42:23.494] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:23.494] - nx: 6
[17:42:23.494] - relay: TRUE
[17:42:23.494] - stdout: TRUE
[17:42:23.494] - signal: TRUE
[17:42:23.495] - resignal: FALSE
[17:42:23.495] - force: TRUE
[17:42:23.495] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.495] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.495]  - until=2
[17:42:23.495]  - relaying element #2
[17:42:23.495] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.496] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.496] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:23.496]  length: 4 (resolved future 2)
[17:42:23.496] Future #3
[17:42:23.497] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:23.497] - nx: 6
[17:42:23.497] - relay: TRUE
[17:42:23.498] - stdout: TRUE
[17:42:23.498] - signal: TRUE
[17:42:23.498] - resignal: FALSE
[17:42:23.498] - force: TRUE
[17:42:23.498] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.498] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.498]  - until=3
[17:42:23.499]  - relaying element #3
[17:42:23.499] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.499] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.499] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:23.499]  length: 3 (resolved future 3)
[17:42:23.500] Future #4
[17:42:23.500] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:23.501] - nx: 6
[17:42:23.501] - relay: TRUE
[17:42:23.501] - stdout: TRUE
[17:42:23.501] - signal: TRUE
[17:42:23.501] - resignal: FALSE
[17:42:23.501] - force: TRUE
[17:42:23.502] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.502] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.502]  - until=4
[17:42:23.502]  - relaying element #4
[17:42:23.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.503] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.503] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:23.503]  length: 2 (resolved future 4)
[17:42:23.503] signalConditionsASAP(NULL, pos=5) ...
[17:42:23.503] - nx: 6
[17:42:23.503] - relay: TRUE
[17:42:23.504] - stdout: TRUE
[17:42:23.504] - signal: TRUE
[17:42:23.504] - resignal: FALSE
[17:42:23.504] - force: TRUE
[17:42:23.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.504] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.504]  - until=6
[17:42:23.505]  - relaying element #6
[17:42:23.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.505] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.505] signalConditionsASAP(NULL, pos=5) ... done
[17:42:23.505]  length: 1 (resolved future 5)
[17:42:23.505] signalConditionsASAP(numeric, pos=6) ...
[17:42:23.505] - nx: 6
[17:42:23.505] - relay: TRUE
[17:42:23.506] - stdout: TRUE
[17:42:23.506] - signal: TRUE
[17:42:23.506] - resignal: FALSE
[17:42:23.506] - force: TRUE
[17:42:23.506] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.506] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.506]  - until=6
[17:42:23.506] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.506] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.506] signalConditionsASAP(numeric, pos=6) ... done
[17:42:23.507]  length: 0 (resolved future 6)
[17:42:23.507] Relaying remaining futures
[17:42:23.507] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.507] - nx: 6
[17:42:23.507] - relay: TRUE
[17:42:23.507] - stdout: TRUE
[17:42:23.507] - signal: TRUE
[17:42:23.507] - resignal: FALSE
[17:42:23.507] - force: TRUE
[17:42:23.507] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.508] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:23.508] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.508] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.508] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.508] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef8747110> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:42:23.511] getGlobalsAndPackages() ...
[17:42:23.511] Searching for globals...
[17:42:23.511] 
[17:42:23.511] Searching for globals ... DONE
[17:42:23.511] - globals: [0] <none>
[17:42:23.511] getGlobalsAndPackages() ... DONE
[17:42:23.512] run() for ‘Future’ ...
[17:42:23.512] - state: ‘created’
[17:42:23.512] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.517] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.517]   - Field: ‘label’
[17:42:23.517]   - Field: ‘local’
[17:42:23.517]   - Field: ‘owner’
[17:42:23.518]   - Field: ‘envir’
[17:42:23.518]   - Field: ‘workers’
[17:42:23.518]   - Field: ‘packages’
[17:42:23.518]   - Field: ‘gc’
[17:42:23.518]   - Field: ‘job’
[17:42:23.518]   - Field: ‘conditions’
[17:42:23.518]   - Field: ‘expr’
[17:42:23.519]   - Field: ‘uuid’
[17:42:23.519]   - Field: ‘seed’
[17:42:23.519]   - Field: ‘version’
[17:42:23.519]   - Field: ‘result’
[17:42:23.519]   - Field: ‘asynchronous’
[17:42:23.519]   - Field: ‘calls’
[17:42:23.519]   - Field: ‘globals’
[17:42:23.520]   - Field: ‘stdout’
[17:42:23.520]   - Field: ‘earlySignal’
[17:42:23.520]   - Field: ‘lazy’
[17:42:23.520]   - Field: ‘state’
[17:42:23.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.520] - Launch lazy future ...
[17:42:23.521] Packages needed by the future expression (n = 0): <none>
[17:42:23.521] Packages needed by future strategies (n = 0): <none>
[17:42:23.521] {
[17:42:23.521]     {
[17:42:23.521]         {
[17:42:23.521]             ...future.startTime <- base::Sys.time()
[17:42:23.521]             {
[17:42:23.521]                 {
[17:42:23.521]                   {
[17:42:23.521]                     {
[17:42:23.521]                       base::local({
[17:42:23.521]                         has_future <- base::requireNamespace("future", 
[17:42:23.521]                           quietly = TRUE)
[17:42:23.521]                         if (has_future) {
[17:42:23.521]                           ns <- base::getNamespace("future")
[17:42:23.521]                           version <- ns[[".package"]][["version"]]
[17:42:23.521]                           if (is.null(version)) 
[17:42:23.521]                             version <- utils::packageVersion("future")
[17:42:23.521]                         }
[17:42:23.521]                         else {
[17:42:23.521]                           version <- NULL
[17:42:23.521]                         }
[17:42:23.521]                         if (!has_future || version < "1.8.0") {
[17:42:23.521]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.521]                             "", base::R.version$version.string), 
[17:42:23.521]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.521]                               "release", "version")], collapse = " "), 
[17:42:23.521]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.521]                             info)
[17:42:23.521]                           info <- base::paste(info, collapse = "; ")
[17:42:23.521]                           if (!has_future) {
[17:42:23.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.521]                               info)
[17:42:23.521]                           }
[17:42:23.521]                           else {
[17:42:23.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.521]                               info, version)
[17:42:23.521]                           }
[17:42:23.521]                           base::stop(msg)
[17:42:23.521]                         }
[17:42:23.521]                       })
[17:42:23.521]                     }
[17:42:23.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.521]                     base::options(mc.cores = 1L)
[17:42:23.521]                   }
[17:42:23.521]                   options(future.plan = NULL)
[17:42:23.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.521]                 }
[17:42:23.521]                 ...future.workdir <- getwd()
[17:42:23.521]             }
[17:42:23.521]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.521]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.521]         }
[17:42:23.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.521]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.521]             base::names(...future.oldOptions))
[17:42:23.521]     }
[17:42:23.521]     if (FALSE) {
[17:42:23.521]     }
[17:42:23.521]     else {
[17:42:23.521]         if (TRUE) {
[17:42:23.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.521]                 open = "w")
[17:42:23.521]         }
[17:42:23.521]         else {
[17:42:23.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.521]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.521]         }
[17:42:23.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.521]             base::sink(type = "output", split = FALSE)
[17:42:23.521]             base::close(...future.stdout)
[17:42:23.521]         }, add = TRUE)
[17:42:23.521]     }
[17:42:23.521]     ...future.frame <- base::sys.nframe()
[17:42:23.521]     ...future.conditions <- base::list()
[17:42:23.521]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.521]     if (FALSE) {
[17:42:23.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.521]     }
[17:42:23.521]     ...future.result <- base::tryCatch({
[17:42:23.521]         base::withCallingHandlers({
[17:42:23.521]             ...future.value <- base::withVisible(base::local({
[17:42:23.521]                 withCallingHandlers({
[17:42:23.521]                   2
[17:42:23.521]                 }, immediateCondition = function(cond) {
[17:42:23.521]                   save_rds <- function (object, pathname, ...) 
[17:42:23.521]                   {
[17:42:23.521]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.521]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.521]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.521]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.521]                         fi_tmp[["mtime"]])
[17:42:23.521]                     }
[17:42:23.521]                     tryCatch({
[17:42:23.521]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.521]                     }, error = function(ex) {
[17:42:23.521]                       msg <- conditionMessage(ex)
[17:42:23.521]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.521]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.521]                         fi_tmp[["mtime"]], msg)
[17:42:23.521]                       ex$message <- msg
[17:42:23.521]                       stop(ex)
[17:42:23.521]                     })
[17:42:23.521]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.521]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.521]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.521]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.521]                       fi <- file.info(pathname)
[17:42:23.521]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.521]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.521]                         fi[["size"]], fi[["mtime"]])
[17:42:23.521]                       stop(msg)
[17:42:23.521]                     }
[17:42:23.521]                     invisible(pathname)
[17:42:23.521]                   }
[17:42:23.521]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.521]                     rootPath = tempdir()) 
[17:42:23.521]                   {
[17:42:23.521]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.521]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.521]                       tmpdir = path, fileext = ".rds")
[17:42:23.521]                     save_rds(obj, file)
[17:42:23.521]                   }
[17:42:23.521]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.521]                   {
[17:42:23.521]                     inherits <- base::inherits
[17:42:23.521]                     invokeRestart <- base::invokeRestart
[17:42:23.521]                     is.null <- base::is.null
[17:42:23.521]                     muffled <- FALSE
[17:42:23.521]                     if (inherits(cond, "message")) {
[17:42:23.521]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.521]                       if (muffled) 
[17:42:23.521]                         invokeRestart("muffleMessage")
[17:42:23.521]                     }
[17:42:23.521]                     else if (inherits(cond, "warning")) {
[17:42:23.521]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.521]                       if (muffled) 
[17:42:23.521]                         invokeRestart("muffleWarning")
[17:42:23.521]                     }
[17:42:23.521]                     else if (inherits(cond, "condition")) {
[17:42:23.521]                       if (!is.null(pattern)) {
[17:42:23.521]                         computeRestarts <- base::computeRestarts
[17:42:23.521]                         grepl <- base::grepl
[17:42:23.521]                         restarts <- computeRestarts(cond)
[17:42:23.521]                         for (restart in restarts) {
[17:42:23.521]                           name <- restart$name
[17:42:23.521]                           if (is.null(name)) 
[17:42:23.521]                             next
[17:42:23.521]                           if (!grepl(pattern, name)) 
[17:42:23.521]                             next
[17:42:23.521]                           invokeRestart(restart)
[17:42:23.521]                           muffled <- TRUE
[17:42:23.521]                           break
[17:42:23.521]                         }
[17:42:23.521]                       }
[17:42:23.521]                     }
[17:42:23.521]                     invisible(muffled)
[17:42:23.521]                   }
[17:42:23.521]                   muffleCondition(cond)
[17:42:23.521]                 })
[17:42:23.521]             }))
[17:42:23.521]             future::FutureResult(value = ...future.value$value, 
[17:42:23.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.521]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.521]                     ...future.globalenv.names))
[17:42:23.521]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.521]         }, condition = base::local({
[17:42:23.521]             c <- base::c
[17:42:23.521]             inherits <- base::inherits
[17:42:23.521]             invokeRestart <- base::invokeRestart
[17:42:23.521]             length <- base::length
[17:42:23.521]             list <- base::list
[17:42:23.521]             seq.int <- base::seq.int
[17:42:23.521]             signalCondition <- base::signalCondition
[17:42:23.521]             sys.calls <- base::sys.calls
[17:42:23.521]             `[[` <- base::`[[`
[17:42:23.521]             `+` <- base::`+`
[17:42:23.521]             `<<-` <- base::`<<-`
[17:42:23.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.521]                   3L)]
[17:42:23.521]             }
[17:42:23.521]             function(cond) {
[17:42:23.521]                 is_error <- inherits(cond, "error")
[17:42:23.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.521]                   NULL)
[17:42:23.521]                 if (is_error) {
[17:42:23.521]                   sessionInformation <- function() {
[17:42:23.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.521]                       search = base::search(), system = base::Sys.info())
[17:42:23.521]                   }
[17:42:23.521]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.521]                     cond$call), session = sessionInformation(), 
[17:42:23.521]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.521]                   signalCondition(cond)
[17:42:23.521]                 }
[17:42:23.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.521]                 "immediateCondition"))) {
[17:42:23.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.521]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.521]                   if (TRUE && !signal) {
[17:42:23.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.521]                     {
[17:42:23.521]                       inherits <- base::inherits
[17:42:23.521]                       invokeRestart <- base::invokeRestart
[17:42:23.521]                       is.null <- base::is.null
[17:42:23.521]                       muffled <- FALSE
[17:42:23.521]                       if (inherits(cond, "message")) {
[17:42:23.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.521]                         if (muffled) 
[17:42:23.521]                           invokeRestart("muffleMessage")
[17:42:23.521]                       }
[17:42:23.521]                       else if (inherits(cond, "warning")) {
[17:42:23.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.521]                         if (muffled) 
[17:42:23.521]                           invokeRestart("muffleWarning")
[17:42:23.521]                       }
[17:42:23.521]                       else if (inherits(cond, "condition")) {
[17:42:23.521]                         if (!is.null(pattern)) {
[17:42:23.521]                           computeRestarts <- base::computeRestarts
[17:42:23.521]                           grepl <- base::grepl
[17:42:23.521]                           restarts <- computeRestarts(cond)
[17:42:23.521]                           for (restart in restarts) {
[17:42:23.521]                             name <- restart$name
[17:42:23.521]                             if (is.null(name)) 
[17:42:23.521]                               next
[17:42:23.521]                             if (!grepl(pattern, name)) 
[17:42:23.521]                               next
[17:42:23.521]                             invokeRestart(restart)
[17:42:23.521]                             muffled <- TRUE
[17:42:23.521]                             break
[17:42:23.521]                           }
[17:42:23.521]                         }
[17:42:23.521]                       }
[17:42:23.521]                       invisible(muffled)
[17:42:23.521]                     }
[17:42:23.521]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.521]                   }
[17:42:23.521]                 }
[17:42:23.521]                 else {
[17:42:23.521]                   if (TRUE) {
[17:42:23.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.521]                     {
[17:42:23.521]                       inherits <- base::inherits
[17:42:23.521]                       invokeRestart <- base::invokeRestart
[17:42:23.521]                       is.null <- base::is.null
[17:42:23.521]                       muffled <- FALSE
[17:42:23.521]                       if (inherits(cond, "message")) {
[17:42:23.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.521]                         if (muffled) 
[17:42:23.521]                           invokeRestart("muffleMessage")
[17:42:23.521]                       }
[17:42:23.521]                       else if (inherits(cond, "warning")) {
[17:42:23.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.521]                         if (muffled) 
[17:42:23.521]                           invokeRestart("muffleWarning")
[17:42:23.521]                       }
[17:42:23.521]                       else if (inherits(cond, "condition")) {
[17:42:23.521]                         if (!is.null(pattern)) {
[17:42:23.521]                           computeRestarts <- base::computeRestarts
[17:42:23.521]                           grepl <- base::grepl
[17:42:23.521]                           restarts <- computeRestarts(cond)
[17:42:23.521]                           for (restart in restarts) {
[17:42:23.521]                             name <- restart$name
[17:42:23.521]                             if (is.null(name)) 
[17:42:23.521]                               next
[17:42:23.521]                             if (!grepl(pattern, name)) 
[17:42:23.521]                               next
[17:42:23.521]                             invokeRestart(restart)
[17:42:23.521]                             muffled <- TRUE
[17:42:23.521]                             break
[17:42:23.521]                           }
[17:42:23.521]                         }
[17:42:23.521]                       }
[17:42:23.521]                       invisible(muffled)
[17:42:23.521]                     }
[17:42:23.521]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.521]                   }
[17:42:23.521]                 }
[17:42:23.521]             }
[17:42:23.521]         }))
[17:42:23.521]     }, error = function(ex) {
[17:42:23.521]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.521]                 ...future.rng), started = ...future.startTime, 
[17:42:23.521]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.521]             version = "1.8"), class = "FutureResult")
[17:42:23.521]     }, finally = {
[17:42:23.521]         if (!identical(...future.workdir, getwd())) 
[17:42:23.521]             setwd(...future.workdir)
[17:42:23.521]         {
[17:42:23.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.521]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.521]             }
[17:42:23.521]             base::options(...future.oldOptions)
[17:42:23.521]             if (.Platform$OS.type == "windows") {
[17:42:23.521]                 old_names <- names(...future.oldEnvVars)
[17:42:23.521]                 envs <- base::Sys.getenv()
[17:42:23.521]                 names <- names(envs)
[17:42:23.521]                 common <- intersect(names, old_names)
[17:42:23.521]                 added <- setdiff(names, old_names)
[17:42:23.521]                 removed <- setdiff(old_names, names)
[17:42:23.521]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.521]                   envs[common]]
[17:42:23.521]                 NAMES <- toupper(changed)
[17:42:23.521]                 args <- list()
[17:42:23.521]                 for (kk in seq_along(NAMES)) {
[17:42:23.521]                   name <- changed[[kk]]
[17:42:23.521]                   NAME <- NAMES[[kk]]
[17:42:23.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.521]                     next
[17:42:23.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.521]                 }
[17:42:23.521]                 NAMES <- toupper(added)
[17:42:23.521]                 for (kk in seq_along(NAMES)) {
[17:42:23.521]                   name <- added[[kk]]
[17:42:23.521]                   NAME <- NAMES[[kk]]
[17:42:23.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.521]                     next
[17:42:23.521]                   args[[name]] <- ""
[17:42:23.521]                 }
[17:42:23.521]                 NAMES <- toupper(removed)
[17:42:23.521]                 for (kk in seq_along(NAMES)) {
[17:42:23.521]                   name <- removed[[kk]]
[17:42:23.521]                   NAME <- NAMES[[kk]]
[17:42:23.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.521]                     next
[17:42:23.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.521]                 }
[17:42:23.521]                 if (length(args) > 0) 
[17:42:23.521]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.521]             }
[17:42:23.521]             else {
[17:42:23.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.521]             }
[17:42:23.521]             {
[17:42:23.521]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.521]                   0L) {
[17:42:23.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.521]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.521]                   base::options(opts)
[17:42:23.521]                 }
[17:42:23.521]                 {
[17:42:23.521]                   {
[17:42:23.521]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.521]                     NULL
[17:42:23.521]                   }
[17:42:23.521]                   options(future.plan = NULL)
[17:42:23.521]                   if (is.na(NA_character_)) 
[17:42:23.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.521]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.521]                     envir = parent.frame()) 
[17:42:23.521]                   {
[17:42:23.521]                     default_workers <- missing(workers)
[17:42:23.521]                     if (is.function(workers)) 
[17:42:23.521]                       workers <- workers()
[17:42:23.521]                     workers <- structure(as.integer(workers), 
[17:42:23.521]                       class = class(workers))
[17:42:23.521]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.521]                       1L)
[17:42:23.521]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.521]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.521]                       if (default_workers) 
[17:42:23.521]                         supportsMulticore(warn = TRUE)
[17:42:23.521]                       return(sequential(..., envir = envir))
[17:42:23.521]                     }
[17:42:23.521]                     oopts <- options(mc.cores = workers)
[17:42:23.521]                     on.exit(options(oopts))
[17:42:23.521]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.521]                       envir = envir)
[17:42:23.521]                     if (!future$lazy) 
[17:42:23.521]                       future <- run(future)
[17:42:23.521]                     invisible(future)
[17:42:23.521]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.521]                 }
[17:42:23.521]             }
[17:42:23.521]         }
[17:42:23.521]     })
[17:42:23.521]     if (TRUE) {
[17:42:23.521]         base::sink(type = "output", split = FALSE)
[17:42:23.521]         if (TRUE) {
[17:42:23.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.521]         }
[17:42:23.521]         else {
[17:42:23.521]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.521]         }
[17:42:23.521]         base::close(...future.stdout)
[17:42:23.521]         ...future.stdout <- NULL
[17:42:23.521]     }
[17:42:23.521]     ...future.result$conditions <- ...future.conditions
[17:42:23.521]     ...future.result$finished <- base::Sys.time()
[17:42:23.521]     ...future.result
[17:42:23.521] }
[17:42:23.524] requestCore(): workers = 2
[17:42:23.526] MulticoreFuture started
[17:42:23.527] - Launch lazy future ... done
[17:42:23.527] run() for ‘MulticoreFuture’ ... done
[17:42:23.527] getGlobalsAndPackages() ...
[17:42:23.528] Searching for globals...
[17:42:23.528] plan(): Setting new future strategy stack:
[17:42:23.528] List of future strategies:
[17:42:23.528] 1. sequential:
[17:42:23.528]    - args: function (..., envir = parent.frame())
[17:42:23.528]    - tweaked: FALSE
[17:42:23.528]    - call: NULL
[17:42:23.529] 
[17:42:23.529] Searching for globals ... DONE
[17:42:23.529] plan(): nbrOfWorkers() = 1
[17:42:23.529] - globals: [0] <none>
[17:42:23.529] getGlobalsAndPackages() ... DONE
[17:42:23.530] run() for ‘Future’ ...
[17:42:23.530] - state: ‘created’
[17:42:23.530] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.531] plan(): Setting new future strategy stack:
[17:42:23.531] List of future strategies:
[17:42:23.531] 1. multicore:
[17:42:23.531]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.531]    - tweaked: FALSE
[17:42:23.531]    - call: plan(strategy)
[17:42:23.535] plan(): nbrOfWorkers() = 2
[17:42:23.536] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.536]   - Field: ‘label’
[17:42:23.536]   - Field: ‘local’
[17:42:23.537]   - Field: ‘owner’
[17:42:23.537]   - Field: ‘envir’
[17:42:23.537]   - Field: ‘workers’
[17:42:23.537]   - Field: ‘packages’
[17:42:23.537]   - Field: ‘gc’
[17:42:23.538]   - Field: ‘job’
[17:42:23.538]   - Field: ‘conditions’
[17:42:23.538]   - Field: ‘expr’
[17:42:23.538]   - Field: ‘uuid’
[17:42:23.538]   - Field: ‘seed’
[17:42:23.538]   - Field: ‘version’
[17:42:23.538]   - Field: ‘result’
[17:42:23.539]   - Field: ‘asynchronous’
[17:42:23.539]   - Field: ‘calls’
[17:42:23.539]   - Field: ‘globals’
[17:42:23.539]   - Field: ‘stdout’
[17:42:23.539]   - Field: ‘earlySignal’
[17:42:23.539]   - Field: ‘lazy’
[17:42:23.540]   - Field: ‘state’
[17:42:23.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.540] - Launch lazy future ...
[17:42:23.540] Packages needed by the future expression (n = 0): <none>
[17:42:23.541] Packages needed by future strategies (n = 0): <none>
[17:42:23.541] {
[17:42:23.541]     {
[17:42:23.541]         {
[17:42:23.541]             ...future.startTime <- base::Sys.time()
[17:42:23.541]             {
[17:42:23.541]                 {
[17:42:23.541]                   {
[17:42:23.541]                     {
[17:42:23.541]                       base::local({
[17:42:23.541]                         has_future <- base::requireNamespace("future", 
[17:42:23.541]                           quietly = TRUE)
[17:42:23.541]                         if (has_future) {
[17:42:23.541]                           ns <- base::getNamespace("future")
[17:42:23.541]                           version <- ns[[".package"]][["version"]]
[17:42:23.541]                           if (is.null(version)) 
[17:42:23.541]                             version <- utils::packageVersion("future")
[17:42:23.541]                         }
[17:42:23.541]                         else {
[17:42:23.541]                           version <- NULL
[17:42:23.541]                         }
[17:42:23.541]                         if (!has_future || version < "1.8.0") {
[17:42:23.541]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.541]                             "", base::R.version$version.string), 
[17:42:23.541]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.541]                               "release", "version")], collapse = " "), 
[17:42:23.541]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.541]                             info)
[17:42:23.541]                           info <- base::paste(info, collapse = "; ")
[17:42:23.541]                           if (!has_future) {
[17:42:23.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.541]                               info)
[17:42:23.541]                           }
[17:42:23.541]                           else {
[17:42:23.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.541]                               info, version)
[17:42:23.541]                           }
[17:42:23.541]                           base::stop(msg)
[17:42:23.541]                         }
[17:42:23.541]                       })
[17:42:23.541]                     }
[17:42:23.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.541]                     base::options(mc.cores = 1L)
[17:42:23.541]                   }
[17:42:23.541]                   options(future.plan = NULL)
[17:42:23.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.541]                 }
[17:42:23.541]                 ...future.workdir <- getwd()
[17:42:23.541]             }
[17:42:23.541]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.541]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.541]         }
[17:42:23.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.541]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.541]             base::names(...future.oldOptions))
[17:42:23.541]     }
[17:42:23.541]     if (FALSE) {
[17:42:23.541]     }
[17:42:23.541]     else {
[17:42:23.541]         if (TRUE) {
[17:42:23.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.541]                 open = "w")
[17:42:23.541]         }
[17:42:23.541]         else {
[17:42:23.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.541]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.541]         }
[17:42:23.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.541]             base::sink(type = "output", split = FALSE)
[17:42:23.541]             base::close(...future.stdout)
[17:42:23.541]         }, add = TRUE)
[17:42:23.541]     }
[17:42:23.541]     ...future.frame <- base::sys.nframe()
[17:42:23.541]     ...future.conditions <- base::list()
[17:42:23.541]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.541]     if (FALSE) {
[17:42:23.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.541]     }
[17:42:23.541]     ...future.result <- base::tryCatch({
[17:42:23.541]         base::withCallingHandlers({
[17:42:23.541]             ...future.value <- base::withVisible(base::local({
[17:42:23.541]                 withCallingHandlers({
[17:42:23.541]                   NULL
[17:42:23.541]                 }, immediateCondition = function(cond) {
[17:42:23.541]                   save_rds <- function (object, pathname, ...) 
[17:42:23.541]                   {
[17:42:23.541]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.541]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.541]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.541]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.541]                         fi_tmp[["mtime"]])
[17:42:23.541]                     }
[17:42:23.541]                     tryCatch({
[17:42:23.541]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.541]                     }, error = function(ex) {
[17:42:23.541]                       msg <- conditionMessage(ex)
[17:42:23.541]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.541]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.541]                         fi_tmp[["mtime"]], msg)
[17:42:23.541]                       ex$message <- msg
[17:42:23.541]                       stop(ex)
[17:42:23.541]                     })
[17:42:23.541]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.541]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.541]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.541]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.541]                       fi <- file.info(pathname)
[17:42:23.541]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.541]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.541]                         fi[["size"]], fi[["mtime"]])
[17:42:23.541]                       stop(msg)
[17:42:23.541]                     }
[17:42:23.541]                     invisible(pathname)
[17:42:23.541]                   }
[17:42:23.541]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.541]                     rootPath = tempdir()) 
[17:42:23.541]                   {
[17:42:23.541]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.541]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.541]                       tmpdir = path, fileext = ".rds")
[17:42:23.541]                     save_rds(obj, file)
[17:42:23.541]                   }
[17:42:23.541]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.541]                   {
[17:42:23.541]                     inherits <- base::inherits
[17:42:23.541]                     invokeRestart <- base::invokeRestart
[17:42:23.541]                     is.null <- base::is.null
[17:42:23.541]                     muffled <- FALSE
[17:42:23.541]                     if (inherits(cond, "message")) {
[17:42:23.541]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.541]                       if (muffled) 
[17:42:23.541]                         invokeRestart("muffleMessage")
[17:42:23.541]                     }
[17:42:23.541]                     else if (inherits(cond, "warning")) {
[17:42:23.541]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.541]                       if (muffled) 
[17:42:23.541]                         invokeRestart("muffleWarning")
[17:42:23.541]                     }
[17:42:23.541]                     else if (inherits(cond, "condition")) {
[17:42:23.541]                       if (!is.null(pattern)) {
[17:42:23.541]                         computeRestarts <- base::computeRestarts
[17:42:23.541]                         grepl <- base::grepl
[17:42:23.541]                         restarts <- computeRestarts(cond)
[17:42:23.541]                         for (restart in restarts) {
[17:42:23.541]                           name <- restart$name
[17:42:23.541]                           if (is.null(name)) 
[17:42:23.541]                             next
[17:42:23.541]                           if (!grepl(pattern, name)) 
[17:42:23.541]                             next
[17:42:23.541]                           invokeRestart(restart)
[17:42:23.541]                           muffled <- TRUE
[17:42:23.541]                           break
[17:42:23.541]                         }
[17:42:23.541]                       }
[17:42:23.541]                     }
[17:42:23.541]                     invisible(muffled)
[17:42:23.541]                   }
[17:42:23.541]                   muffleCondition(cond)
[17:42:23.541]                 })
[17:42:23.541]             }))
[17:42:23.541]             future::FutureResult(value = ...future.value$value, 
[17:42:23.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.541]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.541]                     ...future.globalenv.names))
[17:42:23.541]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.541]         }, condition = base::local({
[17:42:23.541]             c <- base::c
[17:42:23.541]             inherits <- base::inherits
[17:42:23.541]             invokeRestart <- base::invokeRestart
[17:42:23.541]             length <- base::length
[17:42:23.541]             list <- base::list
[17:42:23.541]             seq.int <- base::seq.int
[17:42:23.541]             signalCondition <- base::signalCondition
[17:42:23.541]             sys.calls <- base::sys.calls
[17:42:23.541]             `[[` <- base::`[[`
[17:42:23.541]             `+` <- base::`+`
[17:42:23.541]             `<<-` <- base::`<<-`
[17:42:23.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.541]                   3L)]
[17:42:23.541]             }
[17:42:23.541]             function(cond) {
[17:42:23.541]                 is_error <- inherits(cond, "error")
[17:42:23.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.541]                   NULL)
[17:42:23.541]                 if (is_error) {
[17:42:23.541]                   sessionInformation <- function() {
[17:42:23.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.541]                       search = base::search(), system = base::Sys.info())
[17:42:23.541]                   }
[17:42:23.541]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.541]                     cond$call), session = sessionInformation(), 
[17:42:23.541]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.541]                   signalCondition(cond)
[17:42:23.541]                 }
[17:42:23.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.541]                 "immediateCondition"))) {
[17:42:23.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.541]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.541]                   if (TRUE && !signal) {
[17:42:23.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.541]                     {
[17:42:23.541]                       inherits <- base::inherits
[17:42:23.541]                       invokeRestart <- base::invokeRestart
[17:42:23.541]                       is.null <- base::is.null
[17:42:23.541]                       muffled <- FALSE
[17:42:23.541]                       if (inherits(cond, "message")) {
[17:42:23.541]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.541]                         if (muffled) 
[17:42:23.541]                           invokeRestart("muffleMessage")
[17:42:23.541]                       }
[17:42:23.541]                       else if (inherits(cond, "warning")) {
[17:42:23.541]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.541]                         if (muffled) 
[17:42:23.541]                           invokeRestart("muffleWarning")
[17:42:23.541]                       }
[17:42:23.541]                       else if (inherits(cond, "condition")) {
[17:42:23.541]                         if (!is.null(pattern)) {
[17:42:23.541]                           computeRestarts <- base::computeRestarts
[17:42:23.541]                           grepl <- base::grepl
[17:42:23.541]                           restarts <- computeRestarts(cond)
[17:42:23.541]                           for (restart in restarts) {
[17:42:23.541]                             name <- restart$name
[17:42:23.541]                             if (is.null(name)) 
[17:42:23.541]                               next
[17:42:23.541]                             if (!grepl(pattern, name)) 
[17:42:23.541]                               next
[17:42:23.541]                             invokeRestart(restart)
[17:42:23.541]                             muffled <- TRUE
[17:42:23.541]                             break
[17:42:23.541]                           }
[17:42:23.541]                         }
[17:42:23.541]                       }
[17:42:23.541]                       invisible(muffled)
[17:42:23.541]                     }
[17:42:23.541]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.541]                   }
[17:42:23.541]                 }
[17:42:23.541]                 else {
[17:42:23.541]                   if (TRUE) {
[17:42:23.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.541]                     {
[17:42:23.541]                       inherits <- base::inherits
[17:42:23.541]                       invokeRestart <- base::invokeRestart
[17:42:23.541]                       is.null <- base::is.null
[17:42:23.541]                       muffled <- FALSE
[17:42:23.541]                       if (inherits(cond, "message")) {
[17:42:23.541]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.541]                         if (muffled) 
[17:42:23.541]                           invokeRestart("muffleMessage")
[17:42:23.541]                       }
[17:42:23.541]                       else if (inherits(cond, "warning")) {
[17:42:23.541]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.541]                         if (muffled) 
[17:42:23.541]                           invokeRestart("muffleWarning")
[17:42:23.541]                       }
[17:42:23.541]                       else if (inherits(cond, "condition")) {
[17:42:23.541]                         if (!is.null(pattern)) {
[17:42:23.541]                           computeRestarts <- base::computeRestarts
[17:42:23.541]                           grepl <- base::grepl
[17:42:23.541]                           restarts <- computeRestarts(cond)
[17:42:23.541]                           for (restart in restarts) {
[17:42:23.541]                             name <- restart$name
[17:42:23.541]                             if (is.null(name)) 
[17:42:23.541]                               next
[17:42:23.541]                             if (!grepl(pattern, name)) 
[17:42:23.541]                               next
[17:42:23.541]                             invokeRestart(restart)
[17:42:23.541]                             muffled <- TRUE
[17:42:23.541]                             break
[17:42:23.541]                           }
[17:42:23.541]                         }
[17:42:23.541]                       }
[17:42:23.541]                       invisible(muffled)
[17:42:23.541]                     }
[17:42:23.541]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.541]                   }
[17:42:23.541]                 }
[17:42:23.541]             }
[17:42:23.541]         }))
[17:42:23.541]     }, error = function(ex) {
[17:42:23.541]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.541]                 ...future.rng), started = ...future.startTime, 
[17:42:23.541]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.541]             version = "1.8"), class = "FutureResult")
[17:42:23.541]     }, finally = {
[17:42:23.541]         if (!identical(...future.workdir, getwd())) 
[17:42:23.541]             setwd(...future.workdir)
[17:42:23.541]         {
[17:42:23.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.541]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.541]             }
[17:42:23.541]             base::options(...future.oldOptions)
[17:42:23.541]             if (.Platform$OS.type == "windows") {
[17:42:23.541]                 old_names <- names(...future.oldEnvVars)
[17:42:23.541]                 envs <- base::Sys.getenv()
[17:42:23.541]                 names <- names(envs)
[17:42:23.541]                 common <- intersect(names, old_names)
[17:42:23.541]                 added <- setdiff(names, old_names)
[17:42:23.541]                 removed <- setdiff(old_names, names)
[17:42:23.541]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.541]                   envs[common]]
[17:42:23.541]                 NAMES <- toupper(changed)
[17:42:23.541]                 args <- list()
[17:42:23.541]                 for (kk in seq_along(NAMES)) {
[17:42:23.541]                   name <- changed[[kk]]
[17:42:23.541]                   NAME <- NAMES[[kk]]
[17:42:23.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.541]                     next
[17:42:23.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.541]                 }
[17:42:23.541]                 NAMES <- toupper(added)
[17:42:23.541]                 for (kk in seq_along(NAMES)) {
[17:42:23.541]                   name <- added[[kk]]
[17:42:23.541]                   NAME <- NAMES[[kk]]
[17:42:23.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.541]                     next
[17:42:23.541]                   args[[name]] <- ""
[17:42:23.541]                 }
[17:42:23.541]                 NAMES <- toupper(removed)
[17:42:23.541]                 for (kk in seq_along(NAMES)) {
[17:42:23.541]                   name <- removed[[kk]]
[17:42:23.541]                   NAME <- NAMES[[kk]]
[17:42:23.541]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.541]                     next
[17:42:23.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.541]                 }
[17:42:23.541]                 if (length(args) > 0) 
[17:42:23.541]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.541]             }
[17:42:23.541]             else {
[17:42:23.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.541]             }
[17:42:23.541]             {
[17:42:23.541]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.541]                   0L) {
[17:42:23.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.541]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.541]                   base::options(opts)
[17:42:23.541]                 }
[17:42:23.541]                 {
[17:42:23.541]                   {
[17:42:23.541]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.541]                     NULL
[17:42:23.541]                   }
[17:42:23.541]                   options(future.plan = NULL)
[17:42:23.541]                   if (is.na(NA_character_)) 
[17:42:23.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.541]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.541]                     envir = parent.frame()) 
[17:42:23.541]                   {
[17:42:23.541]                     default_workers <- missing(workers)
[17:42:23.541]                     if (is.function(workers)) 
[17:42:23.541]                       workers <- workers()
[17:42:23.541]                     workers <- structure(as.integer(workers), 
[17:42:23.541]                       class = class(workers))
[17:42:23.541]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.541]                       1L)
[17:42:23.541]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.541]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.541]                       if (default_workers) 
[17:42:23.541]                         supportsMulticore(warn = TRUE)
[17:42:23.541]                       return(sequential(..., envir = envir))
[17:42:23.541]                     }
[17:42:23.541]                     oopts <- options(mc.cores = workers)
[17:42:23.541]                     on.exit(options(oopts))
[17:42:23.541]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.541]                       envir = envir)
[17:42:23.541]                     if (!future$lazy) 
[17:42:23.541]                       future <- run(future)
[17:42:23.541]                     invisible(future)
[17:42:23.541]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.541]                 }
[17:42:23.541]             }
[17:42:23.541]         }
[17:42:23.541]     })
[17:42:23.541]     if (TRUE) {
[17:42:23.541]         base::sink(type = "output", split = FALSE)
[17:42:23.541]         if (TRUE) {
[17:42:23.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.541]         }
[17:42:23.541]         else {
[17:42:23.541]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.541]         }
[17:42:23.541]         base::close(...future.stdout)
[17:42:23.541]         ...future.stdout <- NULL
[17:42:23.541]     }
[17:42:23.541]     ...future.result$conditions <- ...future.conditions
[17:42:23.541]     ...future.result$finished <- base::Sys.time()
[17:42:23.541]     ...future.result
[17:42:23.541] }
[17:42:23.545] requestCore(): workers = 2
[17:42:23.548] MulticoreFuture started
[17:42:23.549] - Launch lazy future ... done
[17:42:23.549] run() for ‘MulticoreFuture’ ... done
[17:42:23.550] plan(): Setting new future strategy stack:
[17:42:23.550] getGlobalsAndPackages() ...
[17:42:23.550] Searching for globals...
[17:42:23.550] List of future strategies:
[17:42:23.550] 1. sequential:
[17:42:23.550]    - args: function (..., envir = parent.frame())
[17:42:23.550]    - tweaked: FALSE
[17:42:23.550]    - call: NULL
[17:42:23.551] plan(): nbrOfWorkers() = 1
[17:42:23.552] - globals found: [1] ‘{’
[17:42:23.552] Searching for globals ... DONE
[17:42:23.552] Resolving globals: FALSE
[17:42:23.552] 
[17:42:23.553] 
[17:42:23.553] getGlobalsAndPackages() ... DONE
[17:42:23.553] plan(): Setting new future strategy stack:
[17:42:23.553] run() for ‘Future’ ...
[17:42:23.553] List of future strategies:
[17:42:23.553] 1. multicore:
[17:42:23.553]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.553]    - tweaked: FALSE
[17:42:23.553]    - call: plan(strategy)
[17:42:23.553] - state: ‘created’
[17:42:23.554] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.559] plan(): nbrOfWorkers() = 2
[17:42:23.560] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.560] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.560]   - Field: ‘label’
[17:42:23.560]   - Field: ‘local’
[17:42:23.560]   - Field: ‘owner’
[17:42:23.560]   - Field: ‘envir’
[17:42:23.560]   - Field: ‘workers’
[17:42:23.561]   - Field: ‘packages’
[17:42:23.561]   - Field: ‘gc’
[17:42:23.561]   - Field: ‘job’
[17:42:23.561]   - Field: ‘conditions’
[17:42:23.561]   - Field: ‘expr’
[17:42:23.561]   - Field: ‘uuid’
[17:42:23.561]   - Field: ‘seed’
[17:42:23.562]   - Field: ‘version’
[17:42:23.562]   - Field: ‘result’
[17:42:23.562]   - Field: ‘asynchronous’
[17:42:23.562]   - Field: ‘calls’
[17:42:23.562]   - Field: ‘globals’
[17:42:23.562]   - Field: ‘stdout’
[17:42:23.562]   - Field: ‘earlySignal’
[17:42:23.563]   - Field: ‘lazy’
[17:42:23.563]   - Field: ‘state’
[17:42:23.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.563] - Launch lazy future ...
[17:42:23.564] Packages needed by the future expression (n = 0): <none>
[17:42:23.564] Packages needed by future strategies (n = 0): <none>
[17:42:23.564] {
[17:42:23.564]     {
[17:42:23.564]         {
[17:42:23.564]             ...future.startTime <- base::Sys.time()
[17:42:23.564]             {
[17:42:23.564]                 {
[17:42:23.564]                   {
[17:42:23.564]                     {
[17:42:23.564]                       base::local({
[17:42:23.564]                         has_future <- base::requireNamespace("future", 
[17:42:23.564]                           quietly = TRUE)
[17:42:23.564]                         if (has_future) {
[17:42:23.564]                           ns <- base::getNamespace("future")
[17:42:23.564]                           version <- ns[[".package"]][["version"]]
[17:42:23.564]                           if (is.null(version)) 
[17:42:23.564]                             version <- utils::packageVersion("future")
[17:42:23.564]                         }
[17:42:23.564]                         else {
[17:42:23.564]                           version <- NULL
[17:42:23.564]                         }
[17:42:23.564]                         if (!has_future || version < "1.8.0") {
[17:42:23.564]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.564]                             "", base::R.version$version.string), 
[17:42:23.564]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.564]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.564]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.564]                               "release", "version")], collapse = " "), 
[17:42:23.564]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.564]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.564]                             info)
[17:42:23.564]                           info <- base::paste(info, collapse = "; ")
[17:42:23.564]                           if (!has_future) {
[17:42:23.564]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.564]                               info)
[17:42:23.564]                           }
[17:42:23.564]                           else {
[17:42:23.564]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.564]                               info, version)
[17:42:23.564]                           }
[17:42:23.564]                           base::stop(msg)
[17:42:23.564]                         }
[17:42:23.564]                       })
[17:42:23.564]                     }
[17:42:23.564]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.564]                     base::options(mc.cores = 1L)
[17:42:23.564]                   }
[17:42:23.564]                   options(future.plan = NULL)
[17:42:23.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.564]                 }
[17:42:23.564]                 ...future.workdir <- getwd()
[17:42:23.564]             }
[17:42:23.564]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.564]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.564]         }
[17:42:23.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.564]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.564]             base::names(...future.oldOptions))
[17:42:23.564]     }
[17:42:23.564]     if (FALSE) {
[17:42:23.564]     }
[17:42:23.564]     else {
[17:42:23.564]         if (TRUE) {
[17:42:23.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.564]                 open = "w")
[17:42:23.564]         }
[17:42:23.564]         else {
[17:42:23.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.564]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.564]         }
[17:42:23.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.564]             base::sink(type = "output", split = FALSE)
[17:42:23.564]             base::close(...future.stdout)
[17:42:23.564]         }, add = TRUE)
[17:42:23.564]     }
[17:42:23.564]     ...future.frame <- base::sys.nframe()
[17:42:23.564]     ...future.conditions <- base::list()
[17:42:23.564]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.564]     if (FALSE) {
[17:42:23.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.564]     }
[17:42:23.564]     ...future.result <- base::tryCatch({
[17:42:23.564]         base::withCallingHandlers({
[17:42:23.564]             ...future.value <- base::withVisible(base::local({
[17:42:23.564]                 withCallingHandlers({
[17:42:23.564]                   {
[17:42:23.564]                     4
[17:42:23.564]                   }
[17:42:23.564]                 }, immediateCondition = function(cond) {
[17:42:23.564]                   save_rds <- function (object, pathname, ...) 
[17:42:23.564]                   {
[17:42:23.564]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.564]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.564]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.564]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.564]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.564]                         fi_tmp[["mtime"]])
[17:42:23.564]                     }
[17:42:23.564]                     tryCatch({
[17:42:23.564]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.564]                     }, error = function(ex) {
[17:42:23.564]                       msg <- conditionMessage(ex)
[17:42:23.564]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.564]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.564]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.564]                         fi_tmp[["mtime"]], msg)
[17:42:23.564]                       ex$message <- msg
[17:42:23.564]                       stop(ex)
[17:42:23.564]                     })
[17:42:23.564]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.564]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.564]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.564]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.564]                       fi <- file.info(pathname)
[17:42:23.564]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.564]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.564]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.564]                         fi[["size"]], fi[["mtime"]])
[17:42:23.564]                       stop(msg)
[17:42:23.564]                     }
[17:42:23.564]                     invisible(pathname)
[17:42:23.564]                   }
[17:42:23.564]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.564]                     rootPath = tempdir()) 
[17:42:23.564]                   {
[17:42:23.564]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.564]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.564]                       tmpdir = path, fileext = ".rds")
[17:42:23.564]                     save_rds(obj, file)
[17:42:23.564]                   }
[17:42:23.564]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.564]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.564]                   {
[17:42:23.564]                     inherits <- base::inherits
[17:42:23.564]                     invokeRestart <- base::invokeRestart
[17:42:23.564]                     is.null <- base::is.null
[17:42:23.564]                     muffled <- FALSE
[17:42:23.564]                     if (inherits(cond, "message")) {
[17:42:23.564]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.564]                       if (muffled) 
[17:42:23.564]                         invokeRestart("muffleMessage")
[17:42:23.564]                     }
[17:42:23.564]                     else if (inherits(cond, "warning")) {
[17:42:23.564]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.564]                       if (muffled) 
[17:42:23.564]                         invokeRestart("muffleWarning")
[17:42:23.564]                     }
[17:42:23.564]                     else if (inherits(cond, "condition")) {
[17:42:23.564]                       if (!is.null(pattern)) {
[17:42:23.564]                         computeRestarts <- base::computeRestarts
[17:42:23.564]                         grepl <- base::grepl
[17:42:23.564]                         restarts <- computeRestarts(cond)
[17:42:23.564]                         for (restart in restarts) {
[17:42:23.564]                           name <- restart$name
[17:42:23.564]                           if (is.null(name)) 
[17:42:23.564]                             next
[17:42:23.564]                           if (!grepl(pattern, name)) 
[17:42:23.564]                             next
[17:42:23.564]                           invokeRestart(restart)
[17:42:23.564]                           muffled <- TRUE
[17:42:23.564]                           break
[17:42:23.564]                         }
[17:42:23.564]                       }
[17:42:23.564]                     }
[17:42:23.564]                     invisible(muffled)
[17:42:23.564]                   }
[17:42:23.564]                   muffleCondition(cond)
[17:42:23.564]                 })
[17:42:23.564]             }))
[17:42:23.564]             future::FutureResult(value = ...future.value$value, 
[17:42:23.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.564]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.564]                     ...future.globalenv.names))
[17:42:23.564]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.564]         }, condition = base::local({
[17:42:23.564]             c <- base::c
[17:42:23.564]             inherits <- base::inherits
[17:42:23.564]             invokeRestart <- base::invokeRestart
[17:42:23.564]             length <- base::length
[17:42:23.564]             list <- base::list
[17:42:23.564]             seq.int <- base::seq.int
[17:42:23.564]             signalCondition <- base::signalCondition
[17:42:23.564]             sys.calls <- base::sys.calls
[17:42:23.564]             `[[` <- base::`[[`
[17:42:23.564]             `+` <- base::`+`
[17:42:23.564]             `<<-` <- base::`<<-`
[17:42:23.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.564]                   3L)]
[17:42:23.564]             }
[17:42:23.564]             function(cond) {
[17:42:23.564]                 is_error <- inherits(cond, "error")
[17:42:23.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.564]                   NULL)
[17:42:23.564]                 if (is_error) {
[17:42:23.564]                   sessionInformation <- function() {
[17:42:23.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.564]                       search = base::search(), system = base::Sys.info())
[17:42:23.564]                   }
[17:42:23.564]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.564]                     cond$call), session = sessionInformation(), 
[17:42:23.564]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.564]                   signalCondition(cond)
[17:42:23.564]                 }
[17:42:23.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.564]                 "immediateCondition"))) {
[17:42:23.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.564]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.564]                   if (TRUE && !signal) {
[17:42:23.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.564]                     {
[17:42:23.564]                       inherits <- base::inherits
[17:42:23.564]                       invokeRestart <- base::invokeRestart
[17:42:23.564]                       is.null <- base::is.null
[17:42:23.564]                       muffled <- FALSE
[17:42:23.564]                       if (inherits(cond, "message")) {
[17:42:23.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.564]                         if (muffled) 
[17:42:23.564]                           invokeRestart("muffleMessage")
[17:42:23.564]                       }
[17:42:23.564]                       else if (inherits(cond, "warning")) {
[17:42:23.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.564]                         if (muffled) 
[17:42:23.564]                           invokeRestart("muffleWarning")
[17:42:23.564]                       }
[17:42:23.564]                       else if (inherits(cond, "condition")) {
[17:42:23.564]                         if (!is.null(pattern)) {
[17:42:23.564]                           computeRestarts <- base::computeRestarts
[17:42:23.564]                           grepl <- base::grepl
[17:42:23.564]                           restarts <- computeRestarts(cond)
[17:42:23.564]                           for (restart in restarts) {
[17:42:23.564]                             name <- restart$name
[17:42:23.564]                             if (is.null(name)) 
[17:42:23.564]                               next
[17:42:23.564]                             if (!grepl(pattern, name)) 
[17:42:23.564]                               next
[17:42:23.564]                             invokeRestart(restart)
[17:42:23.564]                             muffled <- TRUE
[17:42:23.564]                             break
[17:42:23.564]                           }
[17:42:23.564]                         }
[17:42:23.564]                       }
[17:42:23.564]                       invisible(muffled)
[17:42:23.564]                     }
[17:42:23.564]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.564]                   }
[17:42:23.564]                 }
[17:42:23.564]                 else {
[17:42:23.564]                   if (TRUE) {
[17:42:23.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.564]                     {
[17:42:23.564]                       inherits <- base::inherits
[17:42:23.564]                       invokeRestart <- base::invokeRestart
[17:42:23.564]                       is.null <- base::is.null
[17:42:23.564]                       muffled <- FALSE
[17:42:23.564]                       if (inherits(cond, "message")) {
[17:42:23.564]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.564]                         if (muffled) 
[17:42:23.564]                           invokeRestart("muffleMessage")
[17:42:23.564]                       }
[17:42:23.564]                       else if (inherits(cond, "warning")) {
[17:42:23.564]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.564]                         if (muffled) 
[17:42:23.564]                           invokeRestart("muffleWarning")
[17:42:23.564]                       }
[17:42:23.564]                       else if (inherits(cond, "condition")) {
[17:42:23.564]                         if (!is.null(pattern)) {
[17:42:23.564]                           computeRestarts <- base::computeRestarts
[17:42:23.564]                           grepl <- base::grepl
[17:42:23.564]                           restarts <- computeRestarts(cond)
[17:42:23.564]                           for (restart in restarts) {
[17:42:23.564]                             name <- restart$name
[17:42:23.564]                             if (is.null(name)) 
[17:42:23.564]                               next
[17:42:23.564]                             if (!grepl(pattern, name)) 
[17:42:23.564]                               next
[17:42:23.564]                             invokeRestart(restart)
[17:42:23.564]                             muffled <- TRUE
[17:42:23.564]                             break
[17:42:23.564]                           }
[17:42:23.564]                         }
[17:42:23.564]                       }
[17:42:23.564]                       invisible(muffled)
[17:42:23.564]                     }
[17:42:23.564]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.564]                   }
[17:42:23.564]                 }
[17:42:23.564]             }
[17:42:23.564]         }))
[17:42:23.564]     }, error = function(ex) {
[17:42:23.564]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.564]                 ...future.rng), started = ...future.startTime, 
[17:42:23.564]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.564]             version = "1.8"), class = "FutureResult")
[17:42:23.564]     }, finally = {
[17:42:23.564]         if (!identical(...future.workdir, getwd())) 
[17:42:23.564]             setwd(...future.workdir)
[17:42:23.564]         {
[17:42:23.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.564]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.564]             }
[17:42:23.564]             base::options(...future.oldOptions)
[17:42:23.564]             if (.Platform$OS.type == "windows") {
[17:42:23.564]                 old_names <- names(...future.oldEnvVars)
[17:42:23.564]                 envs <- base::Sys.getenv()
[17:42:23.564]                 names <- names(envs)
[17:42:23.564]                 common <- intersect(names, old_names)
[17:42:23.564]                 added <- setdiff(names, old_names)
[17:42:23.564]                 removed <- setdiff(old_names, names)
[17:42:23.564]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.564]                   envs[common]]
[17:42:23.564]                 NAMES <- toupper(changed)
[17:42:23.564]                 args <- list()
[17:42:23.564]                 for (kk in seq_along(NAMES)) {
[17:42:23.564]                   name <- changed[[kk]]
[17:42:23.564]                   NAME <- NAMES[[kk]]
[17:42:23.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.564]                     next
[17:42:23.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.564]                 }
[17:42:23.564]                 NAMES <- toupper(added)
[17:42:23.564]                 for (kk in seq_along(NAMES)) {
[17:42:23.564]                   name <- added[[kk]]
[17:42:23.564]                   NAME <- NAMES[[kk]]
[17:42:23.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.564]                     next
[17:42:23.564]                   args[[name]] <- ""
[17:42:23.564]                 }
[17:42:23.564]                 NAMES <- toupper(removed)
[17:42:23.564]                 for (kk in seq_along(NAMES)) {
[17:42:23.564]                   name <- removed[[kk]]
[17:42:23.564]                   NAME <- NAMES[[kk]]
[17:42:23.564]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.564]                     next
[17:42:23.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.564]                 }
[17:42:23.564]                 if (length(args) > 0) 
[17:42:23.564]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.564]             }
[17:42:23.564]             else {
[17:42:23.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.564]             }
[17:42:23.564]             {
[17:42:23.564]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.564]                   0L) {
[17:42:23.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.564]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.564]                   base::options(opts)
[17:42:23.564]                 }
[17:42:23.564]                 {
[17:42:23.564]                   {
[17:42:23.564]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.564]                     NULL
[17:42:23.564]                   }
[17:42:23.564]                   options(future.plan = NULL)
[17:42:23.564]                   if (is.na(NA_character_)) 
[17:42:23.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.564]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.564]                     envir = parent.frame()) 
[17:42:23.564]                   {
[17:42:23.564]                     default_workers <- missing(workers)
[17:42:23.564]                     if (is.function(workers)) 
[17:42:23.564]                       workers <- workers()
[17:42:23.564]                     workers <- structure(as.integer(workers), 
[17:42:23.564]                       class = class(workers))
[17:42:23.564]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.564]                       1L)
[17:42:23.564]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.564]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.564]                       if (default_workers) 
[17:42:23.564]                         supportsMulticore(warn = TRUE)
[17:42:23.564]                       return(sequential(..., envir = envir))
[17:42:23.564]                     }
[17:42:23.564]                     oopts <- options(mc.cores = workers)
[17:42:23.564]                     on.exit(options(oopts))
[17:42:23.564]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.564]                       envir = envir)
[17:42:23.564]                     if (!future$lazy) 
[17:42:23.564]                       future <- run(future)
[17:42:23.564]                     invisible(future)
[17:42:23.564]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.564]                 }
[17:42:23.564]             }
[17:42:23.564]         }
[17:42:23.564]     })
[17:42:23.564]     if (TRUE) {
[17:42:23.564]         base::sink(type = "output", split = FALSE)
[17:42:23.564]         if (TRUE) {
[17:42:23.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.564]         }
[17:42:23.564]         else {
[17:42:23.564]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.564]         }
[17:42:23.564]         base::close(...future.stdout)
[17:42:23.564]         ...future.stdout <- NULL
[17:42:23.564]     }
[17:42:23.564]     ...future.result$conditions <- ...future.conditions
[17:42:23.564]     ...future.result$finished <- base::Sys.time()
[17:42:23.564]     ...future.result
[17:42:23.564] }
[17:42:23.568] requestCore(): workers = 2
[17:42:23.569] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:23.583] MulticoreFuture started
[17:42:23.584] - Launch lazy future ... done
[17:42:23.584] run() for ‘MulticoreFuture’ ... done
[17:42:23.585] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55bef7900220> 
[17:42:23.585] List of future strategies:
[17:42:23.585] 1. sequential:
[17:42:23.585]    - args: function (..., envir = parent.frame())
[17:42:23.585]    - tweaked: FALSE
[17:42:23.585]    - call: NULL
[17:42:23.586] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55bef93dccc8> 
 - attr(*, "dim.")=[17:42:23.589] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ :[17:42:23.589] List of future strategies:
[17:42:23.589] 1. multicore:
[17:42:23.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.589]    - tweaked: FALSE
[17:42:23.589]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:23.596] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:23.600] resolve() on list environment ...
[17:42:23.600]  recursive: 0
[17:42:23.602]  length: 6
[17:42:23.602]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:23.602] signalConditionsASAP(numeric, pos=1) ...
[17:42:23.602] - nx: 6
[17:42:23.602] - relay: TRUE
[17:42:23.603] - stdout: TRUE
[17:42:23.603] - signal: TRUE
[17:42:23.603] - resignal: FALSE
[17:42:23.603] - force: TRUE
[17:42:23.603] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.603] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.603]  - until=2
[17:42:23.604]  - relaying element #2
[17:42:23.604] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.604] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.604] signalConditionsASAP(NULL, pos=1) ... done
[17:42:23.604]  length: 5 (resolved future 1)
[17:42:23.604] Future #2
[17:42:23.605] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:23.605] - nx: 6
[17:42:23.605] - relay: TRUE
[17:42:23.605] - stdout: TRUE
[17:42:23.605] - signal: TRUE
[17:42:23.605] - resignal: FALSE
[17:42:23.605] - force: TRUE
[17:42:23.605] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.606] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.606]  - until=2
[17:42:23.606]  - relaying element #2
[17:42:23.606] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.606] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.606] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:23.606]  length: 4 (resolved future 2)
[17:42:23.607] Future #3
[17:42:23.608] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:23.608] - nx: 6
[17:42:23.608] - relay: TRUE
[17:42:23.609] - stdout: TRUE
[17:42:23.609] - signal: TRUE
[17:42:23.609] - resignal: FALSE
[17:42:23.609] - force: TRUE
[17:42:23.609] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.609] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.610]  - until=3
[17:42:23.610]  - relaying element #3
[17:42:23.610] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.610] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.610] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:23.611]  length: 3 (resolved future 3)
[17:42:23.611] Future #4
[17:42:23.612] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:23.612] - nx: 6
[17:42:23.612] - relay: TRUE
[17:42:23.613] - stdout: TRUE
[17:42:23.613] - signal: TRUE
[17:42:23.613] - resignal: FALSE
[17:42:23.613] - force: TRUE
[17:42:23.613] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.613] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.613]  - until=4
[17:42:23.614]  - relaying element #4
[17:42:23.614] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.614] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.614] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:23.614]  length: 2 (resolved future 4)
[17:42:23.614] signalConditionsASAP(NULL, pos=5) ...
[17:42:23.614] - nx: 6
[17:42:23.614] - relay: TRUE
[17:42:23.615] - stdout: TRUE
[17:42:23.615] - signal: TRUE
[17:42:23.615] - resignal: FALSE
[17:42:23.615] - force: TRUE
[17:42:23.615] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.615] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.615]  - until=6
[17:42:23.615]  - relaying element #6
[17:42:23.615] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.616] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.616] signalConditionsASAP(NULL, pos=5) ... done
[17:42:23.616]  length: 1 (resolved future 5)
[17:42:23.616] signalConditionsASAP(numeric, pos=6) ...
[17:42:23.616] - nx: 6
[17:42:23.616] - relay: TRUE
[17:42:23.616] - stdout: TRUE
[17:42:23.616] - signal: TRUE
[17:42:23.616] - resignal: FALSE
[17:42:23.617] - force: TRUE
[17:42:23.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.617]  - until=6
[17:42:23.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.617] signalConditionsASAP(numeric, pos=6) ... done
[17:42:23.617]  length: 0 (resolved future 6)
[17:42:23.617] Relaying remaining futures
[17:42:23.617] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.618] - nx: 6
[17:42:23.618] - relay: TRUE
[17:42:23.618] - stdout: TRUE
[17:42:23.618] - signal: TRUE
[17:42:23.618] - resignal: FALSE
[17:42:23.618] - force: TRUE
[17:42:23.618] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.618] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:23.618] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.619] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.619] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.619] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef9750ee0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:42:23.621] getGlobalsAndPackages() ...
[17:42:23.622] Searching for globals...
[17:42:23.622] 
[17:42:23.622] Searching for globals ... DONE
[17:42:23.622] - globals: [0] <none>
[17:42:23.622] getGlobalsAndPackages() ... DONE
[17:42:23.623] run() for ‘Future’ ...
[17:42:23.623] - state: ‘created’
[17:42:23.623] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.627] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.628]   - Field: ‘label’
[17:42:23.628]   - Field: ‘local’
[17:42:23.628]   - Field: ‘owner’
[17:42:23.628]   - Field: ‘envir’
[17:42:23.628]   - Field: ‘workers’
[17:42:23.628]   - Field: ‘packages’
[17:42:23.629]   - Field: ‘gc’
[17:42:23.629]   - Field: ‘job’
[17:42:23.629]   - Field: ‘conditions’
[17:42:23.629]   - Field: ‘expr’
[17:42:23.629]   - Field: ‘uuid’
[17:42:23.633]   - Field: ‘seed’
[17:42:23.633]   - Field: ‘version’
[17:42:23.633]   - Field: ‘result’
[17:42:23.633]   - Field: ‘asynchronous’
[17:42:23.633]   - Field: ‘calls’
[17:42:23.634]   - Field: ‘globals’
[17:42:23.634]   - Field: ‘stdout’
[17:42:23.634]   - Field: ‘earlySignal’
[17:42:23.634]   - Field: ‘lazy’
[17:42:23.634]   - Field: ‘state’
[17:42:23.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.634] - Launch lazy future ...
[17:42:23.635] Packages needed by the future expression (n = 0): <none>
[17:42:23.635] Packages needed by future strategies (n = 0): <none>
[17:42:23.635] {
[17:42:23.635]     {
[17:42:23.635]         {
[17:42:23.635]             ...future.startTime <- base::Sys.time()
[17:42:23.635]             {
[17:42:23.635]                 {
[17:42:23.635]                   {
[17:42:23.635]                     {
[17:42:23.635]                       base::local({
[17:42:23.635]                         has_future <- base::requireNamespace("future", 
[17:42:23.635]                           quietly = TRUE)
[17:42:23.635]                         if (has_future) {
[17:42:23.635]                           ns <- base::getNamespace("future")
[17:42:23.635]                           version <- ns[[".package"]][["version"]]
[17:42:23.635]                           if (is.null(version)) 
[17:42:23.635]                             version <- utils::packageVersion("future")
[17:42:23.635]                         }
[17:42:23.635]                         else {
[17:42:23.635]                           version <- NULL
[17:42:23.635]                         }
[17:42:23.635]                         if (!has_future || version < "1.8.0") {
[17:42:23.635]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.635]                             "", base::R.version$version.string), 
[17:42:23.635]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.635]                               "release", "version")], collapse = " "), 
[17:42:23.635]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.635]                             info)
[17:42:23.635]                           info <- base::paste(info, collapse = "; ")
[17:42:23.635]                           if (!has_future) {
[17:42:23.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.635]                               info)
[17:42:23.635]                           }
[17:42:23.635]                           else {
[17:42:23.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.635]                               info, version)
[17:42:23.635]                           }
[17:42:23.635]                           base::stop(msg)
[17:42:23.635]                         }
[17:42:23.635]                       })
[17:42:23.635]                     }
[17:42:23.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.635]                     base::options(mc.cores = 1L)
[17:42:23.635]                   }
[17:42:23.635]                   options(future.plan = NULL)
[17:42:23.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.635]                 }
[17:42:23.635]                 ...future.workdir <- getwd()
[17:42:23.635]             }
[17:42:23.635]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.635]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.635]         }
[17:42:23.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.635]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.635]             base::names(...future.oldOptions))
[17:42:23.635]     }
[17:42:23.635]     if (FALSE) {
[17:42:23.635]     }
[17:42:23.635]     else {
[17:42:23.635]         if (TRUE) {
[17:42:23.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.635]                 open = "w")
[17:42:23.635]         }
[17:42:23.635]         else {
[17:42:23.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.635]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.635]         }
[17:42:23.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.635]             base::sink(type = "output", split = FALSE)
[17:42:23.635]             base::close(...future.stdout)
[17:42:23.635]         }, add = TRUE)
[17:42:23.635]     }
[17:42:23.635]     ...future.frame <- base::sys.nframe()
[17:42:23.635]     ...future.conditions <- base::list()
[17:42:23.635]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.635]     if (FALSE) {
[17:42:23.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.635]     }
[17:42:23.635]     ...future.result <- base::tryCatch({
[17:42:23.635]         base::withCallingHandlers({
[17:42:23.635]             ...future.value <- base::withVisible(base::local({
[17:42:23.635]                 withCallingHandlers({
[17:42:23.635]                   2
[17:42:23.635]                 }, immediateCondition = function(cond) {
[17:42:23.635]                   save_rds <- function (object, pathname, ...) 
[17:42:23.635]                   {
[17:42:23.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.635]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.635]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.635]                         fi_tmp[["mtime"]])
[17:42:23.635]                     }
[17:42:23.635]                     tryCatch({
[17:42:23.635]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.635]                     }, error = function(ex) {
[17:42:23.635]                       msg <- conditionMessage(ex)
[17:42:23.635]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.635]                         fi_tmp[["mtime"]], msg)
[17:42:23.635]                       ex$message <- msg
[17:42:23.635]                       stop(ex)
[17:42:23.635]                     })
[17:42:23.635]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.635]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.635]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.635]                       fi <- file.info(pathname)
[17:42:23.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.635]                         fi[["size"]], fi[["mtime"]])
[17:42:23.635]                       stop(msg)
[17:42:23.635]                     }
[17:42:23.635]                     invisible(pathname)
[17:42:23.635]                   }
[17:42:23.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.635]                     rootPath = tempdir()) 
[17:42:23.635]                   {
[17:42:23.635]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.635]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.635]                       tmpdir = path, fileext = ".rds")
[17:42:23.635]                     save_rds(obj, file)
[17:42:23.635]                   }
[17:42:23.635]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.635]                   {
[17:42:23.635]                     inherits <- base::inherits
[17:42:23.635]                     invokeRestart <- base::invokeRestart
[17:42:23.635]                     is.null <- base::is.null
[17:42:23.635]                     muffled <- FALSE
[17:42:23.635]                     if (inherits(cond, "message")) {
[17:42:23.635]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.635]                       if (muffled) 
[17:42:23.635]                         invokeRestart("muffleMessage")
[17:42:23.635]                     }
[17:42:23.635]                     else if (inherits(cond, "warning")) {
[17:42:23.635]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.635]                       if (muffled) 
[17:42:23.635]                         invokeRestart("muffleWarning")
[17:42:23.635]                     }
[17:42:23.635]                     else if (inherits(cond, "condition")) {
[17:42:23.635]                       if (!is.null(pattern)) {
[17:42:23.635]                         computeRestarts <- base::computeRestarts
[17:42:23.635]                         grepl <- base::grepl
[17:42:23.635]                         restarts <- computeRestarts(cond)
[17:42:23.635]                         for (restart in restarts) {
[17:42:23.635]                           name <- restart$name
[17:42:23.635]                           if (is.null(name)) 
[17:42:23.635]                             next
[17:42:23.635]                           if (!grepl(pattern, name)) 
[17:42:23.635]                             next
[17:42:23.635]                           invokeRestart(restart)
[17:42:23.635]                           muffled <- TRUE
[17:42:23.635]                           break
[17:42:23.635]                         }
[17:42:23.635]                       }
[17:42:23.635]                     }
[17:42:23.635]                     invisible(muffled)
[17:42:23.635]                   }
[17:42:23.635]                   muffleCondition(cond)
[17:42:23.635]                 })
[17:42:23.635]             }))
[17:42:23.635]             future::FutureResult(value = ...future.value$value, 
[17:42:23.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.635]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.635]                     ...future.globalenv.names))
[17:42:23.635]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.635]         }, condition = base::local({
[17:42:23.635]             c <- base::c
[17:42:23.635]             inherits <- base::inherits
[17:42:23.635]             invokeRestart <- base::invokeRestart
[17:42:23.635]             length <- base::length
[17:42:23.635]             list <- base::list
[17:42:23.635]             seq.int <- base::seq.int
[17:42:23.635]             signalCondition <- base::signalCondition
[17:42:23.635]             sys.calls <- base::sys.calls
[17:42:23.635]             `[[` <- base::`[[`
[17:42:23.635]             `+` <- base::`+`
[17:42:23.635]             `<<-` <- base::`<<-`
[17:42:23.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.635]                   3L)]
[17:42:23.635]             }
[17:42:23.635]             function(cond) {
[17:42:23.635]                 is_error <- inherits(cond, "error")
[17:42:23.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.635]                   NULL)
[17:42:23.635]                 if (is_error) {
[17:42:23.635]                   sessionInformation <- function() {
[17:42:23.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.635]                       search = base::search(), system = base::Sys.info())
[17:42:23.635]                   }
[17:42:23.635]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.635]                     cond$call), session = sessionInformation(), 
[17:42:23.635]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.635]                   signalCondition(cond)
[17:42:23.635]                 }
[17:42:23.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.635]                 "immediateCondition"))) {
[17:42:23.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.635]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.635]                   if (TRUE && !signal) {
[17:42:23.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.635]                     {
[17:42:23.635]                       inherits <- base::inherits
[17:42:23.635]                       invokeRestart <- base::invokeRestart
[17:42:23.635]                       is.null <- base::is.null
[17:42:23.635]                       muffled <- FALSE
[17:42:23.635]                       if (inherits(cond, "message")) {
[17:42:23.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.635]                         if (muffled) 
[17:42:23.635]                           invokeRestart("muffleMessage")
[17:42:23.635]                       }
[17:42:23.635]                       else if (inherits(cond, "warning")) {
[17:42:23.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.635]                         if (muffled) 
[17:42:23.635]                           invokeRestart("muffleWarning")
[17:42:23.635]                       }
[17:42:23.635]                       else if (inherits(cond, "condition")) {
[17:42:23.635]                         if (!is.null(pattern)) {
[17:42:23.635]                           computeRestarts <- base::computeRestarts
[17:42:23.635]                           grepl <- base::grepl
[17:42:23.635]                           restarts <- computeRestarts(cond)
[17:42:23.635]                           for (restart in restarts) {
[17:42:23.635]                             name <- restart$name
[17:42:23.635]                             if (is.null(name)) 
[17:42:23.635]                               next
[17:42:23.635]                             if (!grepl(pattern, name)) 
[17:42:23.635]                               next
[17:42:23.635]                             invokeRestart(restart)
[17:42:23.635]                             muffled <- TRUE
[17:42:23.635]                             break
[17:42:23.635]                           }
[17:42:23.635]                         }
[17:42:23.635]                       }
[17:42:23.635]                       invisible(muffled)
[17:42:23.635]                     }
[17:42:23.635]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.635]                   }
[17:42:23.635]                 }
[17:42:23.635]                 else {
[17:42:23.635]                   if (TRUE) {
[17:42:23.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.635]                     {
[17:42:23.635]                       inherits <- base::inherits
[17:42:23.635]                       invokeRestart <- base::invokeRestart
[17:42:23.635]                       is.null <- base::is.null
[17:42:23.635]                       muffled <- FALSE
[17:42:23.635]                       if (inherits(cond, "message")) {
[17:42:23.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.635]                         if (muffled) 
[17:42:23.635]                           invokeRestart("muffleMessage")
[17:42:23.635]                       }
[17:42:23.635]                       else if (inherits(cond, "warning")) {
[17:42:23.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.635]                         if (muffled) 
[17:42:23.635]                           invokeRestart("muffleWarning")
[17:42:23.635]                       }
[17:42:23.635]                       else if (inherits(cond, "condition")) {
[17:42:23.635]                         if (!is.null(pattern)) {
[17:42:23.635]                           computeRestarts <- base::computeRestarts
[17:42:23.635]                           grepl <- base::grepl
[17:42:23.635]                           restarts <- computeRestarts(cond)
[17:42:23.635]                           for (restart in restarts) {
[17:42:23.635]                             name <- restart$name
[17:42:23.635]                             if (is.null(name)) 
[17:42:23.635]                               next
[17:42:23.635]                             if (!grepl(pattern, name)) 
[17:42:23.635]                               next
[17:42:23.635]                             invokeRestart(restart)
[17:42:23.635]                             muffled <- TRUE
[17:42:23.635]                             break
[17:42:23.635]                           }
[17:42:23.635]                         }
[17:42:23.635]                       }
[17:42:23.635]                       invisible(muffled)
[17:42:23.635]                     }
[17:42:23.635]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.635]                   }
[17:42:23.635]                 }
[17:42:23.635]             }
[17:42:23.635]         }))
[17:42:23.635]     }, error = function(ex) {
[17:42:23.635]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.635]                 ...future.rng), started = ...future.startTime, 
[17:42:23.635]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.635]             version = "1.8"), class = "FutureResult")
[17:42:23.635]     }, finally = {
[17:42:23.635]         if (!identical(...future.workdir, getwd())) 
[17:42:23.635]             setwd(...future.workdir)
[17:42:23.635]         {
[17:42:23.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.635]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.635]             }
[17:42:23.635]             base::options(...future.oldOptions)
[17:42:23.635]             if (.Platform$OS.type == "windows") {
[17:42:23.635]                 old_names <- names(...future.oldEnvVars)
[17:42:23.635]                 envs <- base::Sys.getenv()
[17:42:23.635]                 names <- names(envs)
[17:42:23.635]                 common <- intersect(names, old_names)
[17:42:23.635]                 added <- setdiff(names, old_names)
[17:42:23.635]                 removed <- setdiff(old_names, names)
[17:42:23.635]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.635]                   envs[common]]
[17:42:23.635]                 NAMES <- toupper(changed)
[17:42:23.635]                 args <- list()
[17:42:23.635]                 for (kk in seq_along(NAMES)) {
[17:42:23.635]                   name <- changed[[kk]]
[17:42:23.635]                   NAME <- NAMES[[kk]]
[17:42:23.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.635]                     next
[17:42:23.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.635]                 }
[17:42:23.635]                 NAMES <- toupper(added)
[17:42:23.635]                 for (kk in seq_along(NAMES)) {
[17:42:23.635]                   name <- added[[kk]]
[17:42:23.635]                   NAME <- NAMES[[kk]]
[17:42:23.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.635]                     next
[17:42:23.635]                   args[[name]] <- ""
[17:42:23.635]                 }
[17:42:23.635]                 NAMES <- toupper(removed)
[17:42:23.635]                 for (kk in seq_along(NAMES)) {
[17:42:23.635]                   name <- removed[[kk]]
[17:42:23.635]                   NAME <- NAMES[[kk]]
[17:42:23.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.635]                     next
[17:42:23.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.635]                 }
[17:42:23.635]                 if (length(args) > 0) 
[17:42:23.635]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.635]             }
[17:42:23.635]             else {
[17:42:23.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.635]             }
[17:42:23.635]             {
[17:42:23.635]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.635]                   0L) {
[17:42:23.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.635]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.635]                   base::options(opts)
[17:42:23.635]                 }
[17:42:23.635]                 {
[17:42:23.635]                   {
[17:42:23.635]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.635]                     NULL
[17:42:23.635]                   }
[17:42:23.635]                   options(future.plan = NULL)
[17:42:23.635]                   if (is.na(NA_character_)) 
[17:42:23.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.635]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.635]                     envir = parent.frame()) 
[17:42:23.635]                   {
[17:42:23.635]                     default_workers <- missing(workers)
[17:42:23.635]                     if (is.function(workers)) 
[17:42:23.635]                       workers <- workers()
[17:42:23.635]                     workers <- structure(as.integer(workers), 
[17:42:23.635]                       class = class(workers))
[17:42:23.635]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.635]                       1L)
[17:42:23.635]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.635]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.635]                       if (default_workers) 
[17:42:23.635]                         supportsMulticore(warn = TRUE)
[17:42:23.635]                       return(sequential(..., envir = envir))
[17:42:23.635]                     }
[17:42:23.635]                     oopts <- options(mc.cores = workers)
[17:42:23.635]                     on.exit(options(oopts))
[17:42:23.635]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.635]                       envir = envir)
[17:42:23.635]                     if (!future$lazy) 
[17:42:23.635]                       future <- run(future)
[17:42:23.635]                     invisible(future)
[17:42:23.635]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.635]                 }
[17:42:23.635]             }
[17:42:23.635]         }
[17:42:23.635]     })
[17:42:23.635]     if (TRUE) {
[17:42:23.635]         base::sink(type = "output", split = FALSE)
[17:42:23.635]         if (TRUE) {
[17:42:23.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.635]         }
[17:42:23.635]         else {
[17:42:23.635]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.635]         }
[17:42:23.635]         base::close(...future.stdout)
[17:42:23.635]         ...future.stdout <- NULL
[17:42:23.635]     }
[17:42:23.635]     ...future.result$conditions <- ...future.conditions
[17:42:23.635]     ...future.result$finished <- base::Sys.time()
[17:42:23.635]     ...future.result
[17:42:23.635] }
[17:42:23.638] requestCore(): workers = 2
[17:42:23.641] MulticoreFuture started
[17:42:23.641] - Launch lazy future ... done
[17:42:23.641] run() for ‘MulticoreFuture’ ... done
[17:42:23.642] getGlobalsAndPackages() ...
[17:42:23.642] Searching for globals...
[17:42:23.642] plan(): Setting new future strategy stack:
[17:42:23.642] List of future strategies:
[17:42:23.642] 1. sequential:
[17:42:23.642]    - args: function (..., envir = parent.frame())
[17:42:23.642]    - tweaked: FALSE
[17:42:23.642]    - call: NULL
[17:42:23.643] 
[17:42:23.643] Searching for globals ... DONE
[17:42:23.643] plan(): nbrOfWorkers() = 1
[17:42:23.643] - globals: [0] <none>
[17:42:23.643] getGlobalsAndPackages() ... DONE
[17:42:23.644] run() for ‘Future’ ...
[17:42:23.644] - state: ‘created’
[17:42:23.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.645] plan(): Setting new future strategy stack:
[17:42:23.645] List of future strategies:
[17:42:23.645] 1. multicore:
[17:42:23.645]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.645]    - tweaked: FALSE
[17:42:23.645]    - call: plan(strategy)
[17:42:23.650] plan(): nbrOfWorkers() = 2
[17:42:23.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.651]   - Field: ‘label’
[17:42:23.651]   - Field: ‘local’
[17:42:23.651]   - Field: ‘owner’
[17:42:23.651]   - Field: ‘envir’
[17:42:23.652]   - Field: ‘workers’
[17:42:23.652]   - Field: ‘packages’
[17:42:23.652]   - Field: ‘gc’
[17:42:23.652]   - Field: ‘job’
[17:42:23.652]   - Field: ‘conditions’
[17:42:23.652]   - Field: ‘expr’
[17:42:23.653]   - Field: ‘uuid’
[17:42:23.653]   - Field: ‘seed’
[17:42:23.653]   - Field: ‘version’
[17:42:23.653]   - Field: ‘result’
[17:42:23.653]   - Field: ‘asynchronous’
[17:42:23.653]   - Field: ‘calls’
[17:42:23.653]   - Field: ‘globals’
[17:42:23.654]   - Field: ‘stdout’
[17:42:23.654]   - Field: ‘earlySignal’
[17:42:23.654]   - Field: ‘lazy’
[17:42:23.654]   - Field: ‘state’
[17:42:23.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.654] - Launch lazy future ...
[17:42:23.655] Packages needed by the future expression (n = 0): <none>
[17:42:23.655] Packages needed by future strategies (n = 0): <none>
[17:42:23.656] {
[17:42:23.656]     {
[17:42:23.656]         {
[17:42:23.656]             ...future.startTime <- base::Sys.time()
[17:42:23.656]             {
[17:42:23.656]                 {
[17:42:23.656]                   {
[17:42:23.656]                     {
[17:42:23.656]                       base::local({
[17:42:23.656]                         has_future <- base::requireNamespace("future", 
[17:42:23.656]                           quietly = TRUE)
[17:42:23.656]                         if (has_future) {
[17:42:23.656]                           ns <- base::getNamespace("future")
[17:42:23.656]                           version <- ns[[".package"]][["version"]]
[17:42:23.656]                           if (is.null(version)) 
[17:42:23.656]                             version <- utils::packageVersion("future")
[17:42:23.656]                         }
[17:42:23.656]                         else {
[17:42:23.656]                           version <- NULL
[17:42:23.656]                         }
[17:42:23.656]                         if (!has_future || version < "1.8.0") {
[17:42:23.656]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.656]                             "", base::R.version$version.string), 
[17:42:23.656]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.656]                               "release", "version")], collapse = " "), 
[17:42:23.656]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.656]                             info)
[17:42:23.656]                           info <- base::paste(info, collapse = "; ")
[17:42:23.656]                           if (!has_future) {
[17:42:23.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.656]                               info)
[17:42:23.656]                           }
[17:42:23.656]                           else {
[17:42:23.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.656]                               info, version)
[17:42:23.656]                           }
[17:42:23.656]                           base::stop(msg)
[17:42:23.656]                         }
[17:42:23.656]                       })
[17:42:23.656]                     }
[17:42:23.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.656]                     base::options(mc.cores = 1L)
[17:42:23.656]                   }
[17:42:23.656]                   options(future.plan = NULL)
[17:42:23.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.656]                 }
[17:42:23.656]                 ...future.workdir <- getwd()
[17:42:23.656]             }
[17:42:23.656]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.656]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.656]         }
[17:42:23.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.656]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.656]             base::names(...future.oldOptions))
[17:42:23.656]     }
[17:42:23.656]     if (FALSE) {
[17:42:23.656]     }
[17:42:23.656]     else {
[17:42:23.656]         if (TRUE) {
[17:42:23.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.656]                 open = "w")
[17:42:23.656]         }
[17:42:23.656]         else {
[17:42:23.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.656]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.656]         }
[17:42:23.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.656]             base::sink(type = "output", split = FALSE)
[17:42:23.656]             base::close(...future.stdout)
[17:42:23.656]         }, add = TRUE)
[17:42:23.656]     }
[17:42:23.656]     ...future.frame <- base::sys.nframe()
[17:42:23.656]     ...future.conditions <- base::list()
[17:42:23.656]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.656]     if (FALSE) {
[17:42:23.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.656]     }
[17:42:23.656]     ...future.result <- base::tryCatch({
[17:42:23.656]         base::withCallingHandlers({
[17:42:23.656]             ...future.value <- base::withVisible(base::local({
[17:42:23.656]                 withCallingHandlers({
[17:42:23.656]                   NULL
[17:42:23.656]                 }, immediateCondition = function(cond) {
[17:42:23.656]                   save_rds <- function (object, pathname, ...) 
[17:42:23.656]                   {
[17:42:23.656]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.656]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.656]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.656]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.656]                         fi_tmp[["mtime"]])
[17:42:23.656]                     }
[17:42:23.656]                     tryCatch({
[17:42:23.656]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.656]                     }, error = function(ex) {
[17:42:23.656]                       msg <- conditionMessage(ex)
[17:42:23.656]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.656]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.656]                         fi_tmp[["mtime"]], msg)
[17:42:23.656]                       ex$message <- msg
[17:42:23.656]                       stop(ex)
[17:42:23.656]                     })
[17:42:23.656]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.656]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.656]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.656]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.656]                       fi <- file.info(pathname)
[17:42:23.656]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.656]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.656]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.656]                         fi[["size"]], fi[["mtime"]])
[17:42:23.656]                       stop(msg)
[17:42:23.656]                     }
[17:42:23.656]                     invisible(pathname)
[17:42:23.656]                   }
[17:42:23.656]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.656]                     rootPath = tempdir()) 
[17:42:23.656]                   {
[17:42:23.656]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.656]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.656]                       tmpdir = path, fileext = ".rds")
[17:42:23.656]                     save_rds(obj, file)
[17:42:23.656]                   }
[17:42:23.656]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.656]                   {
[17:42:23.656]                     inherits <- base::inherits
[17:42:23.656]                     invokeRestart <- base::invokeRestart
[17:42:23.656]                     is.null <- base::is.null
[17:42:23.656]                     muffled <- FALSE
[17:42:23.656]                     if (inherits(cond, "message")) {
[17:42:23.656]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.656]                       if (muffled) 
[17:42:23.656]                         invokeRestart("muffleMessage")
[17:42:23.656]                     }
[17:42:23.656]                     else if (inherits(cond, "warning")) {
[17:42:23.656]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.656]                       if (muffled) 
[17:42:23.656]                         invokeRestart("muffleWarning")
[17:42:23.656]                     }
[17:42:23.656]                     else if (inherits(cond, "condition")) {
[17:42:23.656]                       if (!is.null(pattern)) {
[17:42:23.656]                         computeRestarts <- base::computeRestarts
[17:42:23.656]                         grepl <- base::grepl
[17:42:23.656]                         restarts <- computeRestarts(cond)
[17:42:23.656]                         for (restart in restarts) {
[17:42:23.656]                           name <- restart$name
[17:42:23.656]                           if (is.null(name)) 
[17:42:23.656]                             next
[17:42:23.656]                           if (!grepl(pattern, name)) 
[17:42:23.656]                             next
[17:42:23.656]                           invokeRestart(restart)
[17:42:23.656]                           muffled <- TRUE
[17:42:23.656]                           break
[17:42:23.656]                         }
[17:42:23.656]                       }
[17:42:23.656]                     }
[17:42:23.656]                     invisible(muffled)
[17:42:23.656]                   }
[17:42:23.656]                   muffleCondition(cond)
[17:42:23.656]                 })
[17:42:23.656]             }))
[17:42:23.656]             future::FutureResult(value = ...future.value$value, 
[17:42:23.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.656]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.656]                     ...future.globalenv.names))
[17:42:23.656]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.656]         }, condition = base::local({
[17:42:23.656]             c <- base::c
[17:42:23.656]             inherits <- base::inherits
[17:42:23.656]             invokeRestart <- base::invokeRestart
[17:42:23.656]             length <- base::length
[17:42:23.656]             list <- base::list
[17:42:23.656]             seq.int <- base::seq.int
[17:42:23.656]             signalCondition <- base::signalCondition
[17:42:23.656]             sys.calls <- base::sys.calls
[17:42:23.656]             `[[` <- base::`[[`
[17:42:23.656]             `+` <- base::`+`
[17:42:23.656]             `<<-` <- base::`<<-`
[17:42:23.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.656]                   3L)]
[17:42:23.656]             }
[17:42:23.656]             function(cond) {
[17:42:23.656]                 is_error <- inherits(cond, "error")
[17:42:23.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.656]                   NULL)
[17:42:23.656]                 if (is_error) {
[17:42:23.656]                   sessionInformation <- function() {
[17:42:23.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.656]                       search = base::search(), system = base::Sys.info())
[17:42:23.656]                   }
[17:42:23.656]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.656]                     cond$call), session = sessionInformation(), 
[17:42:23.656]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.656]                   signalCondition(cond)
[17:42:23.656]                 }
[17:42:23.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.656]                 "immediateCondition"))) {
[17:42:23.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.656]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.656]                   if (TRUE && !signal) {
[17:42:23.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.656]                     {
[17:42:23.656]                       inherits <- base::inherits
[17:42:23.656]                       invokeRestart <- base::invokeRestart
[17:42:23.656]                       is.null <- base::is.null
[17:42:23.656]                       muffled <- FALSE
[17:42:23.656]                       if (inherits(cond, "message")) {
[17:42:23.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.656]                         if (muffled) 
[17:42:23.656]                           invokeRestart("muffleMessage")
[17:42:23.656]                       }
[17:42:23.656]                       else if (inherits(cond, "warning")) {
[17:42:23.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.656]                         if (muffled) 
[17:42:23.656]                           invokeRestart("muffleWarning")
[17:42:23.656]                       }
[17:42:23.656]                       else if (inherits(cond, "condition")) {
[17:42:23.656]                         if (!is.null(pattern)) {
[17:42:23.656]                           computeRestarts <- base::computeRestarts
[17:42:23.656]                           grepl <- base::grepl
[17:42:23.656]                           restarts <- computeRestarts(cond)
[17:42:23.656]                           for (restart in restarts) {
[17:42:23.656]                             name <- restart$name
[17:42:23.656]                             if (is.null(name)) 
[17:42:23.656]                               next
[17:42:23.656]                             if (!grepl(pattern, name)) 
[17:42:23.656]                               next
[17:42:23.656]                             invokeRestart(restart)
[17:42:23.656]                             muffled <- TRUE
[17:42:23.656]                             break
[17:42:23.656]                           }
[17:42:23.656]                         }
[17:42:23.656]                       }
[17:42:23.656]                       invisible(muffled)
[17:42:23.656]                     }
[17:42:23.656]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.656]                   }
[17:42:23.656]                 }
[17:42:23.656]                 else {
[17:42:23.656]                   if (TRUE) {
[17:42:23.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.656]                     {
[17:42:23.656]                       inherits <- base::inherits
[17:42:23.656]                       invokeRestart <- base::invokeRestart
[17:42:23.656]                       is.null <- base::is.null
[17:42:23.656]                       muffled <- FALSE
[17:42:23.656]                       if (inherits(cond, "message")) {
[17:42:23.656]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.656]                         if (muffled) 
[17:42:23.656]                           invokeRestart("muffleMessage")
[17:42:23.656]                       }
[17:42:23.656]                       else if (inherits(cond, "warning")) {
[17:42:23.656]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.656]                         if (muffled) 
[17:42:23.656]                           invokeRestart("muffleWarning")
[17:42:23.656]                       }
[17:42:23.656]                       else if (inherits(cond, "condition")) {
[17:42:23.656]                         if (!is.null(pattern)) {
[17:42:23.656]                           computeRestarts <- base::computeRestarts
[17:42:23.656]                           grepl <- base::grepl
[17:42:23.656]                           restarts <- computeRestarts(cond)
[17:42:23.656]                           for (restart in restarts) {
[17:42:23.656]                             name <- restart$name
[17:42:23.656]                             if (is.null(name)) 
[17:42:23.656]                               next
[17:42:23.656]                             if (!grepl(pattern, name)) 
[17:42:23.656]                               next
[17:42:23.656]                             invokeRestart(restart)
[17:42:23.656]                             muffled <- TRUE
[17:42:23.656]                             break
[17:42:23.656]                           }
[17:42:23.656]                         }
[17:42:23.656]                       }
[17:42:23.656]                       invisible(muffled)
[17:42:23.656]                     }
[17:42:23.656]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.656]                   }
[17:42:23.656]                 }
[17:42:23.656]             }
[17:42:23.656]         }))
[17:42:23.656]     }, error = function(ex) {
[17:42:23.656]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.656]                 ...future.rng), started = ...future.startTime, 
[17:42:23.656]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.656]             version = "1.8"), class = "FutureResult")
[17:42:23.656]     }, finally = {
[17:42:23.656]         if (!identical(...future.workdir, getwd())) 
[17:42:23.656]             setwd(...future.workdir)
[17:42:23.656]         {
[17:42:23.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.656]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.656]             }
[17:42:23.656]             base::options(...future.oldOptions)
[17:42:23.656]             if (.Platform$OS.type == "windows") {
[17:42:23.656]                 old_names <- names(...future.oldEnvVars)
[17:42:23.656]                 envs <- base::Sys.getenv()
[17:42:23.656]                 names <- names(envs)
[17:42:23.656]                 common <- intersect(names, old_names)
[17:42:23.656]                 added <- setdiff(names, old_names)
[17:42:23.656]                 removed <- setdiff(old_names, names)
[17:42:23.656]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.656]                   envs[common]]
[17:42:23.656]                 NAMES <- toupper(changed)
[17:42:23.656]                 args <- list()
[17:42:23.656]                 for (kk in seq_along(NAMES)) {
[17:42:23.656]                   name <- changed[[kk]]
[17:42:23.656]                   NAME <- NAMES[[kk]]
[17:42:23.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.656]                     next
[17:42:23.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.656]                 }
[17:42:23.656]                 NAMES <- toupper(added)
[17:42:23.656]                 for (kk in seq_along(NAMES)) {
[17:42:23.656]                   name <- added[[kk]]
[17:42:23.656]                   NAME <- NAMES[[kk]]
[17:42:23.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.656]                     next
[17:42:23.656]                   args[[name]] <- ""
[17:42:23.656]                 }
[17:42:23.656]                 NAMES <- toupper(removed)
[17:42:23.656]                 for (kk in seq_along(NAMES)) {
[17:42:23.656]                   name <- removed[[kk]]
[17:42:23.656]                   NAME <- NAMES[[kk]]
[17:42:23.656]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.656]                     next
[17:42:23.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.656]                 }
[17:42:23.656]                 if (length(args) > 0) 
[17:42:23.656]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.656]             }
[17:42:23.656]             else {
[17:42:23.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.656]             }
[17:42:23.656]             {
[17:42:23.656]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.656]                   0L) {
[17:42:23.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.656]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.656]                   base::options(opts)
[17:42:23.656]                 }
[17:42:23.656]                 {
[17:42:23.656]                   {
[17:42:23.656]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.656]                     NULL
[17:42:23.656]                   }
[17:42:23.656]                   options(future.plan = NULL)
[17:42:23.656]                   if (is.na(NA_character_)) 
[17:42:23.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.656]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.656]                     envir = parent.frame()) 
[17:42:23.656]                   {
[17:42:23.656]                     default_workers <- missing(workers)
[17:42:23.656]                     if (is.function(workers)) 
[17:42:23.656]                       workers <- workers()
[17:42:23.656]                     workers <- structure(as.integer(workers), 
[17:42:23.656]                       class = class(workers))
[17:42:23.656]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.656]                       1L)
[17:42:23.656]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.656]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.656]                       if (default_workers) 
[17:42:23.656]                         supportsMulticore(warn = TRUE)
[17:42:23.656]                       return(sequential(..., envir = envir))
[17:42:23.656]                     }
[17:42:23.656]                     oopts <- options(mc.cores = workers)
[17:42:23.656]                     on.exit(options(oopts))
[17:42:23.656]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.656]                       envir = envir)
[17:42:23.656]                     if (!future$lazy) 
[17:42:23.656]                       future <- run(future)
[17:42:23.656]                     invisible(future)
[17:42:23.656]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.656]                 }
[17:42:23.656]             }
[17:42:23.656]         }
[17:42:23.656]     })
[17:42:23.656]     if (TRUE) {
[17:42:23.656]         base::sink(type = "output", split = FALSE)
[17:42:23.656]         if (TRUE) {
[17:42:23.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.656]         }
[17:42:23.656]         else {
[17:42:23.656]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.656]         }
[17:42:23.656]         base::close(...future.stdout)
[17:42:23.656]         ...future.stdout <- NULL
[17:42:23.656]     }
[17:42:23.656]     ...future.result$conditions <- ...future.conditions
[17:42:23.656]     ...future.result$finished <- base::Sys.time()
[17:42:23.656]     ...future.result
[17:42:23.656] }
[17:42:23.660] requestCore(): workers = 2
[17:42:23.662] MulticoreFuture started
[17:42:23.663] - Launch lazy future ... done
[17:42:23.663] run() for ‘MulticoreFuture’ ... done
[17:42:23.664] plan(): Setting new future strategy stack:
[17:42:23.664] getGlobalsAndPackages() ...
[17:42:23.664] Searching for globals...
[17:42:23.664] List of future strategies:
[17:42:23.664] 1. sequential:
[17:42:23.664]    - args: function (..., envir = parent.frame())
[17:42:23.664]    - tweaked: FALSE
[17:42:23.664]    - call: NULL
[17:42:23.665] plan(): nbrOfWorkers() = 1
[17:42:23.666] - globals found: [1] ‘{’
[17:42:23.666] Searching for globals ... DONE
[17:42:23.666] Resolving globals: FALSE
[17:42:23.666] 
[17:42:23.667] 
[17:42:23.667] getGlobalsAndPackages() ... DONE
[17:42:23.667] plan(): Setting new future strategy stack:
[17:42:23.667] run() for ‘Future’ ...
[17:42:23.667] List of future strategies:
[17:42:23.667] 1. multicore:
[17:42:23.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.667]    - tweaked: FALSE
[17:42:23.667]    - call: plan(strategy)
[17:42:23.668] - state: ‘created’
[17:42:23.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:42:23.673] plan(): nbrOfWorkers() = 2
[17:42:23.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:23.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:42:23.673]   - Field: ‘label’
[17:42:23.674]   - Field: ‘local’
[17:42:23.674]   - Field: ‘owner’
[17:42:23.674]   - Field: ‘envir’
[17:42:23.674]   - Field: ‘workers’
[17:42:23.674]   - Field: ‘packages’
[17:42:23.674]   - Field: ‘gc’
[17:42:23.674]   - Field: ‘job’
[17:42:23.675]   - Field: ‘conditions’
[17:42:23.675]   - Field: ‘expr’
[17:42:23.675]   - Field: ‘uuid’
[17:42:23.675]   - Field: ‘seed’
[17:42:23.675]   - Field: ‘version’
[17:42:23.675]   - Field: ‘result’
[17:42:23.676]   - Field: ‘asynchronous’
[17:42:23.676]   - Field: ‘calls’
[17:42:23.676]   - Field: ‘globals’
[17:42:23.676]   - Field: ‘stdout’
[17:42:23.676]   - Field: ‘earlySignal’
[17:42:23.676]   - Field: ‘lazy’
[17:42:23.676]   - Field: ‘state’
[17:42:23.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:42:23.677] - Launch lazy future ...
[17:42:23.677] Packages needed by the future expression (n = 0): <none>
[17:42:23.677] Packages needed by future strategies (n = 0): <none>
[17:42:23.678] {
[17:42:23.678]     {
[17:42:23.678]         {
[17:42:23.678]             ...future.startTime <- base::Sys.time()
[17:42:23.678]             {
[17:42:23.678]                 {
[17:42:23.678]                   {
[17:42:23.678]                     {
[17:42:23.678]                       base::local({
[17:42:23.678]                         has_future <- base::requireNamespace("future", 
[17:42:23.678]                           quietly = TRUE)
[17:42:23.678]                         if (has_future) {
[17:42:23.678]                           ns <- base::getNamespace("future")
[17:42:23.678]                           version <- ns[[".package"]][["version"]]
[17:42:23.678]                           if (is.null(version)) 
[17:42:23.678]                             version <- utils::packageVersion("future")
[17:42:23.678]                         }
[17:42:23.678]                         else {
[17:42:23.678]                           version <- NULL
[17:42:23.678]                         }
[17:42:23.678]                         if (!has_future || version < "1.8.0") {
[17:42:23.678]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:23.678]                             "", base::R.version$version.string), 
[17:42:23.678]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:23.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:23.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:23.678]                               "release", "version")], collapse = " "), 
[17:42:23.678]                             hostname = base::Sys.info()[["nodename"]])
[17:42:23.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:23.678]                             info)
[17:42:23.678]                           info <- base::paste(info, collapse = "; ")
[17:42:23.678]                           if (!has_future) {
[17:42:23.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:23.678]                               info)
[17:42:23.678]                           }
[17:42:23.678]                           else {
[17:42:23.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:23.678]                               info, version)
[17:42:23.678]                           }
[17:42:23.678]                           base::stop(msg)
[17:42:23.678]                         }
[17:42:23.678]                       })
[17:42:23.678]                     }
[17:42:23.678]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:23.678]                     base::options(mc.cores = 1L)
[17:42:23.678]                   }
[17:42:23.678]                   options(future.plan = NULL)
[17:42:23.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:23.678]                 }
[17:42:23.678]                 ...future.workdir <- getwd()
[17:42:23.678]             }
[17:42:23.678]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:23.678]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:23.678]         }
[17:42:23.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:23.678]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:23.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:23.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:23.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:23.678]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:23.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:23.678]             base::names(...future.oldOptions))
[17:42:23.678]     }
[17:42:23.678]     if (FALSE) {
[17:42:23.678]     }
[17:42:23.678]     else {
[17:42:23.678]         if (TRUE) {
[17:42:23.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:23.678]                 open = "w")
[17:42:23.678]         }
[17:42:23.678]         else {
[17:42:23.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:23.678]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:23.678]         }
[17:42:23.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:23.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:23.678]             base::sink(type = "output", split = FALSE)
[17:42:23.678]             base::close(...future.stdout)
[17:42:23.678]         }, add = TRUE)
[17:42:23.678]     }
[17:42:23.678]     ...future.frame <- base::sys.nframe()
[17:42:23.678]     ...future.conditions <- base::list()
[17:42:23.678]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:23.678]     if (FALSE) {
[17:42:23.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:23.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:23.678]     }
[17:42:23.678]     ...future.result <- base::tryCatch({
[17:42:23.678]         base::withCallingHandlers({
[17:42:23.678]             ...future.value <- base::withVisible(base::local({
[17:42:23.678]                 withCallingHandlers({
[17:42:23.678]                   {
[17:42:23.678]                     4
[17:42:23.678]                   }
[17:42:23.678]                 }, immediateCondition = function(cond) {
[17:42:23.678]                   save_rds <- function (object, pathname, ...) 
[17:42:23.678]                   {
[17:42:23.678]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:42:23.678]                     if (file_test("-f", pathname_tmp)) {
[17:42:23.678]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.678]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:42:23.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.678]                         fi_tmp[["mtime"]])
[17:42:23.678]                     }
[17:42:23.678]                     tryCatch({
[17:42:23.678]                       saveRDS(object, file = pathname_tmp, ...)
[17:42:23.678]                     }, error = function(ex) {
[17:42:23.678]                       msg <- conditionMessage(ex)
[17:42:23.678]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.678]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:42:23.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.678]                         fi_tmp[["mtime"]], msg)
[17:42:23.678]                       ex$message <- msg
[17:42:23.678]                       stop(ex)
[17:42:23.678]                     })
[17:42:23.678]                     stopifnot(file_test("-f", pathname_tmp))
[17:42:23.678]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:42:23.678]                     if (!res || file_test("-f", pathname_tmp)) {
[17:42:23.678]                       fi_tmp <- file.info(pathname_tmp)
[17:42:23.678]                       fi <- file.info(pathname)
[17:42:23.678]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:42:23.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:42:23.678]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:42:23.678]                         fi[["size"]], fi[["mtime"]])
[17:42:23.678]                       stop(msg)
[17:42:23.678]                     }
[17:42:23.678]                     invisible(pathname)
[17:42:23.678]                   }
[17:42:23.678]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:42:23.678]                     rootPath = tempdir()) 
[17:42:23.678]                   {
[17:42:23.678]                     obj <- list(time = Sys.time(), condition = cond)
[17:42:23.678]                     file <- tempfile(pattern = class(cond)[1], 
[17:42:23.678]                       tmpdir = path, fileext = ".rds")
[17:42:23.678]                     save_rds(obj, file)
[17:42:23.678]                   }
[17:42:23.678]                   saveImmediateCondition(cond, path = "/tmp/Rtmp0g9Lgr/.future/immediateConditions")
[17:42:23.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.678]                   {
[17:42:23.678]                     inherits <- base::inherits
[17:42:23.678]                     invokeRestart <- base::invokeRestart
[17:42:23.678]                     is.null <- base::is.null
[17:42:23.678]                     muffled <- FALSE
[17:42:23.678]                     if (inherits(cond, "message")) {
[17:42:23.678]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:23.678]                       if (muffled) 
[17:42:23.678]                         invokeRestart("muffleMessage")
[17:42:23.678]                     }
[17:42:23.678]                     else if (inherits(cond, "warning")) {
[17:42:23.678]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:23.678]                       if (muffled) 
[17:42:23.678]                         invokeRestart("muffleWarning")
[17:42:23.678]                     }
[17:42:23.678]                     else if (inherits(cond, "condition")) {
[17:42:23.678]                       if (!is.null(pattern)) {
[17:42:23.678]                         computeRestarts <- base::computeRestarts
[17:42:23.678]                         grepl <- base::grepl
[17:42:23.678]                         restarts <- computeRestarts(cond)
[17:42:23.678]                         for (restart in restarts) {
[17:42:23.678]                           name <- restart$name
[17:42:23.678]                           if (is.null(name)) 
[17:42:23.678]                             next
[17:42:23.678]                           if (!grepl(pattern, name)) 
[17:42:23.678]                             next
[17:42:23.678]                           invokeRestart(restart)
[17:42:23.678]                           muffled <- TRUE
[17:42:23.678]                           break
[17:42:23.678]                         }
[17:42:23.678]                       }
[17:42:23.678]                     }
[17:42:23.678]                     invisible(muffled)
[17:42:23.678]                   }
[17:42:23.678]                   muffleCondition(cond)
[17:42:23.678]                 })
[17:42:23.678]             }))
[17:42:23.678]             future::FutureResult(value = ...future.value$value, 
[17:42:23.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.678]                   ...future.rng), globalenv = if (FALSE) 
[17:42:23.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:23.678]                     ...future.globalenv.names))
[17:42:23.678]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:23.678]         }, condition = base::local({
[17:42:23.678]             c <- base::c
[17:42:23.678]             inherits <- base::inherits
[17:42:23.678]             invokeRestart <- base::invokeRestart
[17:42:23.678]             length <- base::length
[17:42:23.678]             list <- base::list
[17:42:23.678]             seq.int <- base::seq.int
[17:42:23.678]             signalCondition <- base::signalCondition
[17:42:23.678]             sys.calls <- base::sys.calls
[17:42:23.678]             `[[` <- base::`[[`
[17:42:23.678]             `+` <- base::`+`
[17:42:23.678]             `<<-` <- base::`<<-`
[17:42:23.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:23.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:23.678]                   3L)]
[17:42:23.678]             }
[17:42:23.678]             function(cond) {
[17:42:23.678]                 is_error <- inherits(cond, "error")
[17:42:23.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:23.678]                   NULL)
[17:42:23.678]                 if (is_error) {
[17:42:23.678]                   sessionInformation <- function() {
[17:42:23.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:23.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:23.678]                       search = base::search(), system = base::Sys.info())
[17:42:23.678]                   }
[17:42:23.678]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:23.678]                     cond$call), session = sessionInformation(), 
[17:42:23.678]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:23.678]                   signalCondition(cond)
[17:42:23.678]                 }
[17:42:23.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:23.678]                 "immediateCondition"))) {
[17:42:23.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:23.678]                   ...future.conditions[[length(...future.conditions) + 
[17:42:23.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:23.678]                   if (TRUE && !signal) {
[17:42:23.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.678]                     {
[17:42:23.678]                       inherits <- base::inherits
[17:42:23.678]                       invokeRestart <- base::invokeRestart
[17:42:23.678]                       is.null <- base::is.null
[17:42:23.678]                       muffled <- FALSE
[17:42:23.678]                       if (inherits(cond, "message")) {
[17:42:23.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.678]                         if (muffled) 
[17:42:23.678]                           invokeRestart("muffleMessage")
[17:42:23.678]                       }
[17:42:23.678]                       else if (inherits(cond, "warning")) {
[17:42:23.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.678]                         if (muffled) 
[17:42:23.678]                           invokeRestart("muffleWarning")
[17:42:23.678]                       }
[17:42:23.678]                       else if (inherits(cond, "condition")) {
[17:42:23.678]                         if (!is.null(pattern)) {
[17:42:23.678]                           computeRestarts <- base::computeRestarts
[17:42:23.678]                           grepl <- base::grepl
[17:42:23.678]                           restarts <- computeRestarts(cond)
[17:42:23.678]                           for (restart in restarts) {
[17:42:23.678]                             name <- restart$name
[17:42:23.678]                             if (is.null(name)) 
[17:42:23.678]                               next
[17:42:23.678]                             if (!grepl(pattern, name)) 
[17:42:23.678]                               next
[17:42:23.678]                             invokeRestart(restart)
[17:42:23.678]                             muffled <- TRUE
[17:42:23.678]                             break
[17:42:23.678]                           }
[17:42:23.678]                         }
[17:42:23.678]                       }
[17:42:23.678]                       invisible(muffled)
[17:42:23.678]                     }
[17:42:23.678]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.678]                   }
[17:42:23.678]                 }
[17:42:23.678]                 else {
[17:42:23.678]                   if (TRUE) {
[17:42:23.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:23.678]                     {
[17:42:23.678]                       inherits <- base::inherits
[17:42:23.678]                       invokeRestart <- base::invokeRestart
[17:42:23.678]                       is.null <- base::is.null
[17:42:23.678]                       muffled <- FALSE
[17:42:23.678]                       if (inherits(cond, "message")) {
[17:42:23.678]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:23.678]                         if (muffled) 
[17:42:23.678]                           invokeRestart("muffleMessage")
[17:42:23.678]                       }
[17:42:23.678]                       else if (inherits(cond, "warning")) {
[17:42:23.678]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:23.678]                         if (muffled) 
[17:42:23.678]                           invokeRestart("muffleWarning")
[17:42:23.678]                       }
[17:42:23.678]                       else if (inherits(cond, "condition")) {
[17:42:23.678]                         if (!is.null(pattern)) {
[17:42:23.678]                           computeRestarts <- base::computeRestarts
[17:42:23.678]                           grepl <- base::grepl
[17:42:23.678]                           restarts <- computeRestarts(cond)
[17:42:23.678]                           for (restart in restarts) {
[17:42:23.678]                             name <- restart$name
[17:42:23.678]                             if (is.null(name)) 
[17:42:23.678]                               next
[17:42:23.678]                             if (!grepl(pattern, name)) 
[17:42:23.678]                               next
[17:42:23.678]                             invokeRestart(restart)
[17:42:23.678]                             muffled <- TRUE
[17:42:23.678]                             break
[17:42:23.678]                           }
[17:42:23.678]                         }
[17:42:23.678]                       }
[17:42:23.678]                       invisible(muffled)
[17:42:23.678]                     }
[17:42:23.678]                     muffleCondition(cond, pattern = "^muffle")
[17:42:23.678]                   }
[17:42:23.678]                 }
[17:42:23.678]             }
[17:42:23.678]         }))
[17:42:23.678]     }, error = function(ex) {
[17:42:23.678]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:23.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:23.678]                 ...future.rng), started = ...future.startTime, 
[17:42:23.678]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:23.678]             version = "1.8"), class = "FutureResult")
[17:42:23.678]     }, finally = {
[17:42:23.678]         if (!identical(...future.workdir, getwd())) 
[17:42:23.678]             setwd(...future.workdir)
[17:42:23.678]         {
[17:42:23.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:23.678]                 ...future.oldOptions$nwarnings <- NULL
[17:42:23.678]             }
[17:42:23.678]             base::options(...future.oldOptions)
[17:42:23.678]             if (.Platform$OS.type == "windows") {
[17:42:23.678]                 old_names <- names(...future.oldEnvVars)
[17:42:23.678]                 envs <- base::Sys.getenv()
[17:42:23.678]                 names <- names(envs)
[17:42:23.678]                 common <- intersect(names, old_names)
[17:42:23.678]                 added <- setdiff(names, old_names)
[17:42:23.678]                 removed <- setdiff(old_names, names)
[17:42:23.678]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:23.678]                   envs[common]]
[17:42:23.678]                 NAMES <- toupper(changed)
[17:42:23.678]                 args <- list()
[17:42:23.678]                 for (kk in seq_along(NAMES)) {
[17:42:23.678]                   name <- changed[[kk]]
[17:42:23.678]                   NAME <- NAMES[[kk]]
[17:42:23.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.678]                     next
[17:42:23.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.678]                 }
[17:42:23.678]                 NAMES <- toupper(added)
[17:42:23.678]                 for (kk in seq_along(NAMES)) {
[17:42:23.678]                   name <- added[[kk]]
[17:42:23.678]                   NAME <- NAMES[[kk]]
[17:42:23.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.678]                     next
[17:42:23.678]                   args[[name]] <- ""
[17:42:23.678]                 }
[17:42:23.678]                 NAMES <- toupper(removed)
[17:42:23.678]                 for (kk in seq_along(NAMES)) {
[17:42:23.678]                   name <- removed[[kk]]
[17:42:23.678]                   NAME <- NAMES[[kk]]
[17:42:23.678]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:23.678]                     next
[17:42:23.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:23.678]                 }
[17:42:23.678]                 if (length(args) > 0) 
[17:42:23.678]                   base::do.call(base::Sys.setenv, args = args)
[17:42:23.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:23.678]             }
[17:42:23.678]             else {
[17:42:23.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:23.678]             }
[17:42:23.678]             {
[17:42:23.678]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:23.678]                   0L) {
[17:42:23.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:23.678]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:23.678]                   base::options(opts)
[17:42:23.678]                 }
[17:42:23.678]                 {
[17:42:23.678]                   {
[17:42:23.678]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:23.678]                     NULL
[17:42:23.678]                   }
[17:42:23.678]                   options(future.plan = NULL)
[17:42:23.678]                   if (is.na(NA_character_)) 
[17:42:23.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:23.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:23.678]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[17:42:23.678]                     envir = parent.frame()) 
[17:42:23.678]                   {
[17:42:23.678]                     default_workers <- missing(workers)
[17:42:23.678]                     if (is.function(workers)) 
[17:42:23.678]                       workers <- workers()
[17:42:23.678]                     workers <- structure(as.integer(workers), 
[17:42:23.678]                       class = class(workers))
[17:42:23.678]                     stop_if_not(is.finite(workers), workers >= 
[17:42:23.678]                       1L)
[17:42:23.678]                     if ((workers == 1L && !inherits(workers, 
[17:42:23.678]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[17:42:23.678]                       if (default_workers) 
[17:42:23.678]                         supportsMulticore(warn = TRUE)
[17:42:23.678]                       return(sequential(..., envir = envir))
[17:42:23.678]                     }
[17:42:23.678]                     oopts <- options(mc.cores = workers)
[17:42:23.678]                     on.exit(options(oopts))
[17:42:23.678]                     future <- MulticoreFuture(..., workers = workers, 
[17:42:23.678]                       envir = envir)
[17:42:23.678]                     if (!future$lazy) 
[17:42:23.678]                       future <- run(future)
[17:42:23.678]                     invisible(future)
[17:42:23.678]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:23.678]                 }
[17:42:23.678]             }
[17:42:23.678]         }
[17:42:23.678]     })
[17:42:23.678]     if (TRUE) {
[17:42:23.678]         base::sink(type = "output", split = FALSE)
[17:42:23.678]         if (TRUE) {
[17:42:23.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:23.678]         }
[17:42:23.678]         else {
[17:42:23.678]             ...future.result["stdout"] <- base::list(NULL)
[17:42:23.678]         }
[17:42:23.678]         base::close(...future.stdout)
[17:42:23.678]         ...future.stdout <- NULL
[17:42:23.678]     }
[17:42:23.678]     ...future.result$conditions <- ...future.conditions
[17:42:23.678]     ...future.result$finished <- base::Sys.time()
[17:42:23.678]     ...future.result
[17:42:23.678] }
[17:42:23.682] requestCore(): workers = 2
[17:42:23.682] Poll #1 (0): usedCores() = 2, workers = 2
[17:42:23.698] MulticoreFuture started
[17:42:23.698] - Launch lazy future ... done
[17:42:23.698] run() for ‘MulticoreFuture’ ... done
[17:42:23.699] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55bef9f2eaf0> 
[17:42:23.699] List of future strategies:
[17:42:23.699] 1. sequential:
[17:42:23.699]    - args: function (..., envir = parent.frame())
[17:42:23.699]    - tweaked: FALSE
[17:42:23.699]    - call: NULL
[17:42:23.700] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55bef7902a00> 
 - attr(*, "dim.")=[17:42:23.703] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ :[17:42:23.703] List of future strategies:
[17:42:23.703] 1. multicore:
[17:42:23.703]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:42:23.703]    - tweaked: FALSE
[17:42:23.703]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:23.708] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:23.714] resolve() on list environment ...
[17:42:23.714]  recursive: 0
[17:42:23.715]  length: 6
[17:42:23.716]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:23.716] signalConditionsASAP(numeric, pos=1) ...
[17:42:23.716] - nx: 6
[17:42:23.716] - relay: TRUE
[17:42:23.716] - stdout: TRUE
[17:42:23.716] - signal: TRUE
[17:42:23.717] - resignal: FALSE
[17:42:23.717] - force: TRUE
[17:42:23.717] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.717] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.717]  - until=2
[17:42:23.717]  - relaying element #2
[17:42:23.717] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.718] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.718] signalConditionsASAP(NULL, pos=1) ... done
[17:42:23.718]  length: 5 (resolved future 1)
[17:42:23.718] Future #2
[17:42:23.718] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:42:23.718] - nx: 6
[17:42:23.719] - relay: TRUE
[17:42:23.719] - stdout: TRUE
[17:42:23.719] - signal: TRUE
[17:42:23.719] - resignal: FALSE
[17:42:23.719] - force: TRUE
[17:42:23.719] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.719] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:23.720]  - until=2
[17:42:23.720]  - relaying element #2
[17:42:23.720] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.720] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.720] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:42:23.720]  length: 4 (resolved future 2)
[17:42:23.721] Future #3
[17:42:23.722] signalConditionsASAP(MulticoreFuture, pos=3) ...
[17:42:23.722] - nx: 6
[17:42:23.722] - relay: TRUE
[17:42:23.722] - stdout: TRUE
[17:42:23.722] - signal: TRUE
[17:42:23.722] - resignal: FALSE
[17:42:23.723] - force: TRUE
[17:42:23.723] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.723] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:23.723]  - until=3
[17:42:23.723]  - relaying element #3
[17:42:23.723] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.724] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.724] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[17:42:23.724]  length: 3 (resolved future 3)
[17:42:23.724] Future #4
[17:42:23.725] signalConditionsASAP(MulticoreFuture, pos=4) ...
[17:42:23.725] - nx: 6
[17:42:23.725] - relay: TRUE
[17:42:23.725] - stdout: TRUE
[17:42:23.726] - signal: TRUE
[17:42:23.726] - resignal: FALSE
[17:42:23.726] - force: TRUE
[17:42:23.726] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.726] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:23.726]  - until=4
[17:42:23.726]  - relaying element #4
[17:42:23.727] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.727] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.727] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[17:42:23.727]  length: 2 (resolved future 4)
[17:42:23.727] signalConditionsASAP(NULL, pos=5) ...
[17:42:23.727] - nx: 6
[17:42:23.727] - relay: TRUE
[17:42:23.728] - stdout: TRUE
[17:42:23.728] - signal: TRUE
[17:42:23.728] - resignal: FALSE
[17:42:23.728] - force: TRUE
[17:42:23.728] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.728] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.728]  - until=6
[17:42:23.728]  - relaying element #6
[17:42:23.728] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.728] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.729] signalConditionsASAP(NULL, pos=5) ... done
[17:42:23.729]  length: 1 (resolved future 5)
[17:42:23.729] signalConditionsASAP(numeric, pos=6) ...
[17:42:23.729] - nx: 6
[17:42:23.729] - relay: TRUE
[17:42:23.729] - stdout: TRUE
[17:42:23.729] - signal: TRUE
[17:42:23.729] - resignal: FALSE
[17:42:23.729] - force: TRUE
[17:42:23.729] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[17:42:23.730] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.730]  - until=6
[17:42:23.730] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.730] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.730] signalConditionsASAP(numeric, pos=6) ... done
[17:42:23.730]  length: 0 (resolved future 6)
[17:42:23.730] Relaying remaining futures
[17:42:23.730] signalConditionsASAP(NULL, pos=0) ...
[17:42:23.730] - nx: 6
[17:42:23.731] - relay: TRUE
[17:42:23.731] - stdout: TRUE
[17:42:23.731] - signal: TRUE
[17:42:23.731] - resignal: FALSE
[17:42:23.731] - force: TRUE
[17:42:23.731] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.731] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:23.731] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:23.731] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:23.732] signalConditionsASAP(NULL, pos=0) ... done
[17:42:23.732] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55bef5f11d70> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[17:42:23.735] plan(): Setting new future strategy stack:
[17:42:23.735] List of future strategies:
[17:42:23.735] 1. multisession:
[17:42:23.735]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:23.735]    - tweaked: FALSE
[17:42:23.735]    - call: plan(strategy)
[17:42:23.735] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:42:23.735] multisession:
[17:42:23.735] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:42:23.735] - tweaked: FALSE
[17:42:23.735] - call: plan(strategy)
[17:42:23.740] getGlobalsAndPackages() ...
[17:42:23.740] Not searching for globals
[17:42:23.740] - globals: [0] <none>
[17:42:23.740] getGlobalsAndPackages() ... DONE
[17:42:23.741] [local output] makeClusterPSOCK() ...
[17:42:23.741] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:42:23.742] [local output] Base port: 11676
[17:42:23.742] [local output] Getting setup options for 2 cluster nodes ...
[17:42:23.742] [local output]  - Node 1 of 2 ...
[17:42:23.742] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:23.743] [local output] Rscript port: 11676

[17:42:23.744] [local output]  - Node 2 of 2 ...
[17:42:23.744] [local output] localMachine=TRUE => revtunnel=FALSE

[17:42:23.745] [local output] Rscript port: 11676

[17:42:23.745] [local output] Getting setup options for 2 cluster nodes ... done
[17:42:23.745] [local output]  - Parallel setup requested for some PSOCK nodes
[17:42:23.745] [local output] Setting up PSOCK nodes in parallel
[17:42:23.745] List of 36
[17:42:23.745]  $ worker          : chr "localhost"
[17:42:23.745]   ..- attr(*, "localhost")= logi TRUE
[17:42:23.745]  $ master          : chr "localhost"
[17:42:23.745]  $ port            : int 11676
[17:42:23.745]  $ connectTimeout  : num 120
[17:42:23.745]  $ timeout         : num 2592000
[17:42:23.745]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:42:23.745]  $ homogeneous     : logi TRUE
[17:42:23.745]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:42:23.745]  $ rscript_envs    : NULL
[17:42:23.745]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:23.745]  $ rscript_startup : NULL
[17:42:23.745]  $ rscript_sh      : chr "sh"
[17:42:23.745]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:23.745]  $ methods         : logi TRUE
[17:42:23.745]  $ socketOptions   : chr "no-delay"
[17:42:23.745]  $ useXDR          : logi FALSE
[17:42:23.745]  $ outfile         : chr "/dev/null"
[17:42:23.745]  $ renice          : int NA
[17:42:23.745]  $ rshcmd          : NULL
[17:42:23.745]  $ user            : chr(0) 
[17:42:23.745]  $ revtunnel       : logi FALSE
[17:42:23.745]  $ rshlogfile      : NULL
[17:42:23.745]  $ rshopts         : chr(0) 
[17:42:23.745]  $ rank            : int 1
[17:42:23.745]  $ manual          : logi FALSE
[17:42:23.745]  $ dryrun          : logi FALSE
[17:42:23.745]  $ quiet           : logi FALSE
[17:42:23.745]  $ setup_strategy  : chr "parallel"
[17:42:23.745]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:23.745]  $ pidfile         : chr "/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec76f3b3d0b.pid"
[17:42:23.745]  $ rshcmd_label    : NULL
[17:42:23.745]  $ rsh_call        : NULL
[17:42:23.745]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:42:23.745]  $ localMachine    : logi TRUE
[17:42:23.745]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:42:23.745]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:42:23.745]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:42:23.745]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:42:23.745]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:42:23.745]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:42:23.745]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:42:23.745]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:42:23.745]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:42:23.745]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:42:23.745]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:42:23.745]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:42:23.745]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:42:23.745]  $ arguments       :List of 28
[17:42:23.745]   ..$ worker          : chr "localhost"
[17:42:23.745]   ..$ master          : NULL
[17:42:23.745]   ..$ port            : int 11676
[17:42:23.745]   ..$ connectTimeout  : num 120
[17:42:23.745]   ..$ timeout         : num 2592000
[17:42:23.745]   ..$ rscript         : NULL
[17:42:23.745]   ..$ homogeneous     : NULL
[17:42:23.745]   ..$ rscript_args    : NULL
[17:42:23.745]   ..$ rscript_envs    : NULL
[17:42:23.745]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:42:23.745]   ..$ rscript_startup : NULL
[17:42:23.745]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:42:23.745]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:42:23.745]   ..$ methods         : logi TRUE
[17:42:23.745]   ..$ socketOptions   : chr "no-delay"
[17:42:23.745]   ..$ useXDR          : logi FALSE
[17:42:23.745]   ..$ outfile         : chr "/dev/null"
[17:42:23.745]   ..$ renice          : int NA
[17:42:23.745]   ..$ rshcmd          : NULL
[17:42:23.745]   ..$ user            : NULL
[17:42:23.745]   ..$ revtunnel       : logi NA
[17:42:23.745]   ..$ rshlogfile      : NULL
[17:42:23.745]   ..$ rshopts         : NULL
[17:42:23.745]   ..$ rank            : int 1
[17:42:23.745]   ..$ manual          : logi FALSE
[17:42:23.745]   ..$ dryrun          : logi FALSE
[17:42:23.745]   ..$ quiet           : logi FALSE
[17:42:23.745]   ..$ setup_strategy  : chr "parallel"
[17:42:23.745]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:42:23.769] [local output] System call to launch all workers:
[17:42:23.769] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp0g9Lgr/worker.rank=1.parallelly.parent=44743.aec76f3b3d0b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11676 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:42:23.769] [local output] Starting PSOCK main server
[17:42:23.771] [local output] Workers launched
[17:42:23.771] [local output] Waiting for workers to connect back
[17:42:23.771]  - [local output] 0 workers out of 2 ready
[17:42:24.011]  - [local output] 0 workers out of 2 ready
[17:42:24.012]  - [local output] 1 workers out of 2 ready
[17:42:24.023]  - [local output] 1 workers out of 2 ready
[17:42:24.024]  - [local output] 2 workers out of 2 ready
[17:42:24.024] [local output] Launching of workers completed
[17:42:24.024] [local output] Collecting session information from workers
[17:42:24.025] [local output]  - Worker #1 of 2
[17:42:24.025] [local output]  - Worker #2 of 2
[17:42:24.025] [local output] makeClusterPSOCK() ... done
[17:42:24.037] Packages needed by the future expression (n = 0): <none>
[17:42:24.038] Packages needed by future strategies (n = 0): <none>
[17:42:24.038] {
[17:42:24.038]     {
[17:42:24.038]         {
[17:42:24.038]             ...future.startTime <- base::Sys.time()
[17:42:24.038]             {
[17:42:24.038]                 {
[17:42:24.038]                   {
[17:42:24.038]                     {
[17:42:24.038]                       base::local({
[17:42:24.038]                         has_future <- base::requireNamespace("future", 
[17:42:24.038]                           quietly = TRUE)
[17:42:24.038]                         if (has_future) {
[17:42:24.038]                           ns <- base::getNamespace("future")
[17:42:24.038]                           version <- ns[[".package"]][["version"]]
[17:42:24.038]                           if (is.null(version)) 
[17:42:24.038]                             version <- utils::packageVersion("future")
[17:42:24.038]                         }
[17:42:24.038]                         else {
[17:42:24.038]                           version <- NULL
[17:42:24.038]                         }
[17:42:24.038]                         if (!has_future || version < "1.8.0") {
[17:42:24.038]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.038]                             "", base::R.version$version.string), 
[17:42:24.038]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.038]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.038]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.038]                               "release", "version")], collapse = " "), 
[17:42:24.038]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.038]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.038]                             info)
[17:42:24.038]                           info <- base::paste(info, collapse = "; ")
[17:42:24.038]                           if (!has_future) {
[17:42:24.038]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.038]                               info)
[17:42:24.038]                           }
[17:42:24.038]                           else {
[17:42:24.038]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.038]                               info, version)
[17:42:24.038]                           }
[17:42:24.038]                           base::stop(msg)
[17:42:24.038]                         }
[17:42:24.038]                       })
[17:42:24.038]                     }
[17:42:24.038]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.038]                     base::options(mc.cores = 1L)
[17:42:24.038]                   }
[17:42:24.038]                   options(future.plan = NULL)
[17:42:24.038]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.038]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.038]                 }
[17:42:24.038]                 ...future.workdir <- getwd()
[17:42:24.038]             }
[17:42:24.038]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.038]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.038]         }
[17:42:24.038]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.038]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.038]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.038]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.038]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.038]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.038]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.038]             base::names(...future.oldOptions))
[17:42:24.038]     }
[17:42:24.038]     if (FALSE) {
[17:42:24.038]     }
[17:42:24.038]     else {
[17:42:24.038]         if (TRUE) {
[17:42:24.038]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.038]                 open = "w")
[17:42:24.038]         }
[17:42:24.038]         else {
[17:42:24.038]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.038]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.038]         }
[17:42:24.038]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.038]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.038]             base::sink(type = "output", split = FALSE)
[17:42:24.038]             base::close(...future.stdout)
[17:42:24.038]         }, add = TRUE)
[17:42:24.038]     }
[17:42:24.038]     ...future.frame <- base::sys.nframe()
[17:42:24.038]     ...future.conditions <- base::list()
[17:42:24.038]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.038]     if (FALSE) {
[17:42:24.038]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.038]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.038]     }
[17:42:24.038]     ...future.result <- base::tryCatch({
[17:42:24.038]         base::withCallingHandlers({
[17:42:24.038]             ...future.value <- base::withVisible(base::local({
[17:42:24.038]                 ...future.makeSendCondition <- local({
[17:42:24.038]                   sendCondition <- NULL
[17:42:24.038]                   function(frame = 1L) {
[17:42:24.038]                     if (is.function(sendCondition)) 
[17:42:24.038]                       return(sendCondition)
[17:42:24.038]                     ns <- getNamespace("parallel")
[17:42:24.038]                     if (exists("sendData", mode = "function", 
[17:42:24.038]                       envir = ns)) {
[17:42:24.038]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.038]                         envir = ns)
[17:42:24.038]                       envir <- sys.frame(frame)
[17:42:24.038]                       master <- NULL
[17:42:24.038]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.038]                         !identical(envir, emptyenv())) {
[17:42:24.038]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.038]                           inherits = FALSE)) {
[17:42:24.038]                           master <- get("master", mode = "list", 
[17:42:24.038]                             envir = envir, inherits = FALSE)
[17:42:24.038]                           if (inherits(master, c("SOCKnode", 
[17:42:24.038]                             "SOCK0node"))) {
[17:42:24.038]                             sendCondition <<- function(cond) {
[17:42:24.038]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.038]                                 success = TRUE)
[17:42:24.038]                               parallel_sendData(master, data)
[17:42:24.038]                             }
[17:42:24.038]                             return(sendCondition)
[17:42:24.038]                           }
[17:42:24.038]                         }
[17:42:24.038]                         frame <- frame + 1L
[17:42:24.038]                         envir <- sys.frame(frame)
[17:42:24.038]                       }
[17:42:24.038]                     }
[17:42:24.038]                     sendCondition <<- function(cond) NULL
[17:42:24.038]                   }
[17:42:24.038]                 })
[17:42:24.038]                 withCallingHandlers({
[17:42:24.038]                   NA
[17:42:24.038]                 }, immediateCondition = function(cond) {
[17:42:24.038]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.038]                   sendCondition(cond)
[17:42:24.038]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.038]                   {
[17:42:24.038]                     inherits <- base::inherits
[17:42:24.038]                     invokeRestart <- base::invokeRestart
[17:42:24.038]                     is.null <- base::is.null
[17:42:24.038]                     muffled <- FALSE
[17:42:24.038]                     if (inherits(cond, "message")) {
[17:42:24.038]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.038]                       if (muffled) 
[17:42:24.038]                         invokeRestart("muffleMessage")
[17:42:24.038]                     }
[17:42:24.038]                     else if (inherits(cond, "warning")) {
[17:42:24.038]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.038]                       if (muffled) 
[17:42:24.038]                         invokeRestart("muffleWarning")
[17:42:24.038]                     }
[17:42:24.038]                     else if (inherits(cond, "condition")) {
[17:42:24.038]                       if (!is.null(pattern)) {
[17:42:24.038]                         computeRestarts <- base::computeRestarts
[17:42:24.038]                         grepl <- base::grepl
[17:42:24.038]                         restarts <- computeRestarts(cond)
[17:42:24.038]                         for (restart in restarts) {
[17:42:24.038]                           name <- restart$name
[17:42:24.038]                           if (is.null(name)) 
[17:42:24.038]                             next
[17:42:24.038]                           if (!grepl(pattern, name)) 
[17:42:24.038]                             next
[17:42:24.038]                           invokeRestart(restart)
[17:42:24.038]                           muffled <- TRUE
[17:42:24.038]                           break
[17:42:24.038]                         }
[17:42:24.038]                       }
[17:42:24.038]                     }
[17:42:24.038]                     invisible(muffled)
[17:42:24.038]                   }
[17:42:24.038]                   muffleCondition(cond)
[17:42:24.038]                 })
[17:42:24.038]             }))
[17:42:24.038]             future::FutureResult(value = ...future.value$value, 
[17:42:24.038]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.038]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.038]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.038]                     ...future.globalenv.names))
[17:42:24.038]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.038]         }, condition = base::local({
[17:42:24.038]             c <- base::c
[17:42:24.038]             inherits <- base::inherits
[17:42:24.038]             invokeRestart <- base::invokeRestart
[17:42:24.038]             length <- base::length
[17:42:24.038]             list <- base::list
[17:42:24.038]             seq.int <- base::seq.int
[17:42:24.038]             signalCondition <- base::signalCondition
[17:42:24.038]             sys.calls <- base::sys.calls
[17:42:24.038]             `[[` <- base::`[[`
[17:42:24.038]             `+` <- base::`+`
[17:42:24.038]             `<<-` <- base::`<<-`
[17:42:24.038]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.038]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.038]                   3L)]
[17:42:24.038]             }
[17:42:24.038]             function(cond) {
[17:42:24.038]                 is_error <- inherits(cond, "error")
[17:42:24.038]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.038]                   NULL)
[17:42:24.038]                 if (is_error) {
[17:42:24.038]                   sessionInformation <- function() {
[17:42:24.038]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.038]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.038]                       search = base::search(), system = base::Sys.info())
[17:42:24.038]                   }
[17:42:24.038]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.038]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.038]                     cond$call), session = sessionInformation(), 
[17:42:24.038]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.038]                   signalCondition(cond)
[17:42:24.038]                 }
[17:42:24.038]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.038]                 "immediateCondition"))) {
[17:42:24.038]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.038]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.038]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.038]                   if (TRUE && !signal) {
[17:42:24.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.038]                     {
[17:42:24.038]                       inherits <- base::inherits
[17:42:24.038]                       invokeRestart <- base::invokeRestart
[17:42:24.038]                       is.null <- base::is.null
[17:42:24.038]                       muffled <- FALSE
[17:42:24.038]                       if (inherits(cond, "message")) {
[17:42:24.038]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.038]                         if (muffled) 
[17:42:24.038]                           invokeRestart("muffleMessage")
[17:42:24.038]                       }
[17:42:24.038]                       else if (inherits(cond, "warning")) {
[17:42:24.038]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.038]                         if (muffled) 
[17:42:24.038]                           invokeRestart("muffleWarning")
[17:42:24.038]                       }
[17:42:24.038]                       else if (inherits(cond, "condition")) {
[17:42:24.038]                         if (!is.null(pattern)) {
[17:42:24.038]                           computeRestarts <- base::computeRestarts
[17:42:24.038]                           grepl <- base::grepl
[17:42:24.038]                           restarts <- computeRestarts(cond)
[17:42:24.038]                           for (restart in restarts) {
[17:42:24.038]                             name <- restart$name
[17:42:24.038]                             if (is.null(name)) 
[17:42:24.038]                               next
[17:42:24.038]                             if (!grepl(pattern, name)) 
[17:42:24.038]                               next
[17:42:24.038]                             invokeRestart(restart)
[17:42:24.038]                             muffled <- TRUE
[17:42:24.038]                             break
[17:42:24.038]                           }
[17:42:24.038]                         }
[17:42:24.038]                       }
[17:42:24.038]                       invisible(muffled)
[17:42:24.038]                     }
[17:42:24.038]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.038]                   }
[17:42:24.038]                 }
[17:42:24.038]                 else {
[17:42:24.038]                   if (TRUE) {
[17:42:24.038]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.038]                     {
[17:42:24.038]                       inherits <- base::inherits
[17:42:24.038]                       invokeRestart <- base::invokeRestart
[17:42:24.038]                       is.null <- base::is.null
[17:42:24.038]                       muffled <- FALSE
[17:42:24.038]                       if (inherits(cond, "message")) {
[17:42:24.038]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.038]                         if (muffled) 
[17:42:24.038]                           invokeRestart("muffleMessage")
[17:42:24.038]                       }
[17:42:24.038]                       else if (inherits(cond, "warning")) {
[17:42:24.038]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.038]                         if (muffled) 
[17:42:24.038]                           invokeRestart("muffleWarning")
[17:42:24.038]                       }
[17:42:24.038]                       else if (inherits(cond, "condition")) {
[17:42:24.038]                         if (!is.null(pattern)) {
[17:42:24.038]                           computeRestarts <- base::computeRestarts
[17:42:24.038]                           grepl <- base::grepl
[17:42:24.038]                           restarts <- computeRestarts(cond)
[17:42:24.038]                           for (restart in restarts) {
[17:42:24.038]                             name <- restart$name
[17:42:24.038]                             if (is.null(name)) 
[17:42:24.038]                               next
[17:42:24.038]                             if (!grepl(pattern, name)) 
[17:42:24.038]                               next
[17:42:24.038]                             invokeRestart(restart)
[17:42:24.038]                             muffled <- TRUE
[17:42:24.038]                             break
[17:42:24.038]                           }
[17:42:24.038]                         }
[17:42:24.038]                       }
[17:42:24.038]                       invisible(muffled)
[17:42:24.038]                     }
[17:42:24.038]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.038]                   }
[17:42:24.038]                 }
[17:42:24.038]             }
[17:42:24.038]         }))
[17:42:24.038]     }, error = function(ex) {
[17:42:24.038]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.038]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.038]                 ...future.rng), started = ...future.startTime, 
[17:42:24.038]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.038]             version = "1.8"), class = "FutureResult")
[17:42:24.038]     }, finally = {
[17:42:24.038]         if (!identical(...future.workdir, getwd())) 
[17:42:24.038]             setwd(...future.workdir)
[17:42:24.038]         {
[17:42:24.038]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.038]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.038]             }
[17:42:24.038]             base::options(...future.oldOptions)
[17:42:24.038]             if (.Platform$OS.type == "windows") {
[17:42:24.038]                 old_names <- names(...future.oldEnvVars)
[17:42:24.038]                 envs <- base::Sys.getenv()
[17:42:24.038]                 names <- names(envs)
[17:42:24.038]                 common <- intersect(names, old_names)
[17:42:24.038]                 added <- setdiff(names, old_names)
[17:42:24.038]                 removed <- setdiff(old_names, names)
[17:42:24.038]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.038]                   envs[common]]
[17:42:24.038]                 NAMES <- toupper(changed)
[17:42:24.038]                 args <- list()
[17:42:24.038]                 for (kk in seq_along(NAMES)) {
[17:42:24.038]                   name <- changed[[kk]]
[17:42:24.038]                   NAME <- NAMES[[kk]]
[17:42:24.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.038]                     next
[17:42:24.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.038]                 }
[17:42:24.038]                 NAMES <- toupper(added)
[17:42:24.038]                 for (kk in seq_along(NAMES)) {
[17:42:24.038]                   name <- added[[kk]]
[17:42:24.038]                   NAME <- NAMES[[kk]]
[17:42:24.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.038]                     next
[17:42:24.038]                   args[[name]] <- ""
[17:42:24.038]                 }
[17:42:24.038]                 NAMES <- toupper(removed)
[17:42:24.038]                 for (kk in seq_along(NAMES)) {
[17:42:24.038]                   name <- removed[[kk]]
[17:42:24.038]                   NAME <- NAMES[[kk]]
[17:42:24.038]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.038]                     next
[17:42:24.038]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.038]                 }
[17:42:24.038]                 if (length(args) > 0) 
[17:42:24.038]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.038]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.038]             }
[17:42:24.038]             else {
[17:42:24.038]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.038]             }
[17:42:24.038]             {
[17:42:24.038]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.038]                   0L) {
[17:42:24.038]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.038]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.038]                   base::options(opts)
[17:42:24.038]                 }
[17:42:24.038]                 {
[17:42:24.038]                   {
[17:42:24.038]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.038]                     NULL
[17:42:24.038]                   }
[17:42:24.038]                   options(future.plan = NULL)
[17:42:24.038]                   if (is.na(NA_character_)) 
[17:42:24.038]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.038]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.038]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.038]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.038]                     envir = parent.frame()) 
[17:42:24.038]                   {
[17:42:24.038]                     if (is.function(workers)) 
[17:42:24.038]                       workers <- workers()
[17:42:24.038]                     workers <- structure(as.integer(workers), 
[17:42:24.038]                       class = class(workers))
[17:42:24.038]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.038]                       workers >= 1)
[17:42:24.038]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.038]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.038]                     }
[17:42:24.038]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.038]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.038]                       envir = envir)
[17:42:24.038]                     if (!future$lazy) 
[17:42:24.038]                       future <- run(future)
[17:42:24.038]                     invisible(future)
[17:42:24.038]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.038]                 }
[17:42:24.038]             }
[17:42:24.038]         }
[17:42:24.038]     })
[17:42:24.038]     if (TRUE) {
[17:42:24.038]         base::sink(type = "output", split = FALSE)
[17:42:24.038]         if (TRUE) {
[17:42:24.038]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.038]         }
[17:42:24.038]         else {
[17:42:24.038]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.038]         }
[17:42:24.038]         base::close(...future.stdout)
[17:42:24.038]         ...future.stdout <- NULL
[17:42:24.038]     }
[17:42:24.038]     ...future.result$conditions <- ...future.conditions
[17:42:24.038]     ...future.result$finished <- base::Sys.time()
[17:42:24.038]     ...future.result
[17:42:24.038] }
[17:42:24.112] MultisessionFuture started
[17:42:24.112] result() for ClusterFuture ...
[17:42:24.112] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.113] - Validating connection of MultisessionFuture
[17:42:24.145] - received message: FutureResult
[17:42:24.145] - Received FutureResult
[17:42:24.146] - Erased future from FutureRegistry
[17:42:24.146] result() for ClusterFuture ...
[17:42:24.146] - result already collected: FutureResult
[17:42:24.146] result() for ClusterFuture ... done
[17:42:24.146] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.146] result() for ClusterFuture ... done
[17:42:24.146] result() for ClusterFuture ...
[17:42:24.146] - result already collected: FutureResult
[17:42:24.147] result() for ClusterFuture ... done
[17:42:24.147] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:42:24.150] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[17:42:24.151] getGlobalsAndPackages() ...
[17:42:24.151] Searching for globals...
[17:42:24.151] 
[17:42:24.151] Searching for globals ... DONE
[17:42:24.151] - globals: [0] <none>
[17:42:24.151] getGlobalsAndPackages() ... DONE
[17:42:24.152] run() for ‘Future’ ...
[17:42:24.152] - state: ‘created’
[17:42:24.152] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.166] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.166] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.167]   - Field: ‘node’
[17:42:24.167]   - Field: ‘label’
[17:42:24.167]   - Field: ‘local’
[17:42:24.167]   - Field: ‘owner’
[17:42:24.167]   - Field: ‘envir’
[17:42:24.167]   - Field: ‘workers’
[17:42:24.167]   - Field: ‘packages’
[17:42:24.167]   - Field: ‘gc’
[17:42:24.167]   - Field: ‘conditions’
[17:42:24.168]   - Field: ‘persistent’
[17:42:24.168]   - Field: ‘expr’
[17:42:24.168]   - Field: ‘uuid’
[17:42:24.168]   - Field: ‘seed’
[17:42:24.168]   - Field: ‘version’
[17:42:24.168]   - Field: ‘result’
[17:42:24.168]   - Field: ‘asynchronous’
[17:42:24.168]   - Field: ‘calls’
[17:42:24.168]   - Field: ‘globals’
[17:42:24.169]   - Field: ‘stdout’
[17:42:24.169]   - Field: ‘earlySignal’
[17:42:24.169]   - Field: ‘lazy’
[17:42:24.169]   - Field: ‘state’
[17:42:24.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.169] - Launch lazy future ...
[17:42:24.169] Packages needed by the future expression (n = 0): <none>
[17:42:24.170] Packages needed by future strategies (n = 0): <none>
[17:42:24.170] {
[17:42:24.170]     {
[17:42:24.170]         {
[17:42:24.170]             ...future.startTime <- base::Sys.time()
[17:42:24.170]             {
[17:42:24.170]                 {
[17:42:24.170]                   {
[17:42:24.170]                     {
[17:42:24.170]                       base::local({
[17:42:24.170]                         has_future <- base::requireNamespace("future", 
[17:42:24.170]                           quietly = TRUE)
[17:42:24.170]                         if (has_future) {
[17:42:24.170]                           ns <- base::getNamespace("future")
[17:42:24.170]                           version <- ns[[".package"]][["version"]]
[17:42:24.170]                           if (is.null(version)) 
[17:42:24.170]                             version <- utils::packageVersion("future")
[17:42:24.170]                         }
[17:42:24.170]                         else {
[17:42:24.170]                           version <- NULL
[17:42:24.170]                         }
[17:42:24.170]                         if (!has_future || version < "1.8.0") {
[17:42:24.170]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.170]                             "", base::R.version$version.string), 
[17:42:24.170]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.170]                               "release", "version")], collapse = " "), 
[17:42:24.170]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.170]                             info)
[17:42:24.170]                           info <- base::paste(info, collapse = "; ")
[17:42:24.170]                           if (!has_future) {
[17:42:24.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.170]                               info)
[17:42:24.170]                           }
[17:42:24.170]                           else {
[17:42:24.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.170]                               info, version)
[17:42:24.170]                           }
[17:42:24.170]                           base::stop(msg)
[17:42:24.170]                         }
[17:42:24.170]                       })
[17:42:24.170]                     }
[17:42:24.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.170]                     base::options(mc.cores = 1L)
[17:42:24.170]                   }
[17:42:24.170]                   options(future.plan = NULL)
[17:42:24.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.170]                 }
[17:42:24.170]                 ...future.workdir <- getwd()
[17:42:24.170]             }
[17:42:24.170]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.170]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.170]         }
[17:42:24.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.170]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.170]             base::names(...future.oldOptions))
[17:42:24.170]     }
[17:42:24.170]     if (FALSE) {
[17:42:24.170]     }
[17:42:24.170]     else {
[17:42:24.170]         if (TRUE) {
[17:42:24.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.170]                 open = "w")
[17:42:24.170]         }
[17:42:24.170]         else {
[17:42:24.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.170]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.170]         }
[17:42:24.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.170]             base::sink(type = "output", split = FALSE)
[17:42:24.170]             base::close(...future.stdout)
[17:42:24.170]         }, add = TRUE)
[17:42:24.170]     }
[17:42:24.170]     ...future.frame <- base::sys.nframe()
[17:42:24.170]     ...future.conditions <- base::list()
[17:42:24.170]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.170]     if (FALSE) {
[17:42:24.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.170]     }
[17:42:24.170]     ...future.result <- base::tryCatch({
[17:42:24.170]         base::withCallingHandlers({
[17:42:24.170]             ...future.value <- base::withVisible(base::local({
[17:42:24.170]                 ...future.makeSendCondition <- local({
[17:42:24.170]                   sendCondition <- NULL
[17:42:24.170]                   function(frame = 1L) {
[17:42:24.170]                     if (is.function(sendCondition)) 
[17:42:24.170]                       return(sendCondition)
[17:42:24.170]                     ns <- getNamespace("parallel")
[17:42:24.170]                     if (exists("sendData", mode = "function", 
[17:42:24.170]                       envir = ns)) {
[17:42:24.170]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.170]                         envir = ns)
[17:42:24.170]                       envir <- sys.frame(frame)
[17:42:24.170]                       master <- NULL
[17:42:24.170]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.170]                         !identical(envir, emptyenv())) {
[17:42:24.170]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.170]                           inherits = FALSE)) {
[17:42:24.170]                           master <- get("master", mode = "list", 
[17:42:24.170]                             envir = envir, inherits = FALSE)
[17:42:24.170]                           if (inherits(master, c("SOCKnode", 
[17:42:24.170]                             "SOCK0node"))) {
[17:42:24.170]                             sendCondition <<- function(cond) {
[17:42:24.170]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.170]                                 success = TRUE)
[17:42:24.170]                               parallel_sendData(master, data)
[17:42:24.170]                             }
[17:42:24.170]                             return(sendCondition)
[17:42:24.170]                           }
[17:42:24.170]                         }
[17:42:24.170]                         frame <- frame + 1L
[17:42:24.170]                         envir <- sys.frame(frame)
[17:42:24.170]                       }
[17:42:24.170]                     }
[17:42:24.170]                     sendCondition <<- function(cond) NULL
[17:42:24.170]                   }
[17:42:24.170]                 })
[17:42:24.170]                 withCallingHandlers({
[17:42:24.170]                   2
[17:42:24.170]                 }, immediateCondition = function(cond) {
[17:42:24.170]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.170]                   sendCondition(cond)
[17:42:24.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.170]                   {
[17:42:24.170]                     inherits <- base::inherits
[17:42:24.170]                     invokeRestart <- base::invokeRestart
[17:42:24.170]                     is.null <- base::is.null
[17:42:24.170]                     muffled <- FALSE
[17:42:24.170]                     if (inherits(cond, "message")) {
[17:42:24.170]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.170]                       if (muffled) 
[17:42:24.170]                         invokeRestart("muffleMessage")
[17:42:24.170]                     }
[17:42:24.170]                     else if (inherits(cond, "warning")) {
[17:42:24.170]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.170]                       if (muffled) 
[17:42:24.170]                         invokeRestart("muffleWarning")
[17:42:24.170]                     }
[17:42:24.170]                     else if (inherits(cond, "condition")) {
[17:42:24.170]                       if (!is.null(pattern)) {
[17:42:24.170]                         computeRestarts <- base::computeRestarts
[17:42:24.170]                         grepl <- base::grepl
[17:42:24.170]                         restarts <- computeRestarts(cond)
[17:42:24.170]                         for (restart in restarts) {
[17:42:24.170]                           name <- restart$name
[17:42:24.170]                           if (is.null(name)) 
[17:42:24.170]                             next
[17:42:24.170]                           if (!grepl(pattern, name)) 
[17:42:24.170]                             next
[17:42:24.170]                           invokeRestart(restart)
[17:42:24.170]                           muffled <- TRUE
[17:42:24.170]                           break
[17:42:24.170]                         }
[17:42:24.170]                       }
[17:42:24.170]                     }
[17:42:24.170]                     invisible(muffled)
[17:42:24.170]                   }
[17:42:24.170]                   muffleCondition(cond)
[17:42:24.170]                 })
[17:42:24.170]             }))
[17:42:24.170]             future::FutureResult(value = ...future.value$value, 
[17:42:24.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.170]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.170]                     ...future.globalenv.names))
[17:42:24.170]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.170]         }, condition = base::local({
[17:42:24.170]             c <- base::c
[17:42:24.170]             inherits <- base::inherits
[17:42:24.170]             invokeRestart <- base::invokeRestart
[17:42:24.170]             length <- base::length
[17:42:24.170]             list <- base::list
[17:42:24.170]             seq.int <- base::seq.int
[17:42:24.170]             signalCondition <- base::signalCondition
[17:42:24.170]             sys.calls <- base::sys.calls
[17:42:24.170]             `[[` <- base::`[[`
[17:42:24.170]             `+` <- base::`+`
[17:42:24.170]             `<<-` <- base::`<<-`
[17:42:24.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.170]                   3L)]
[17:42:24.170]             }
[17:42:24.170]             function(cond) {
[17:42:24.170]                 is_error <- inherits(cond, "error")
[17:42:24.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.170]                   NULL)
[17:42:24.170]                 if (is_error) {
[17:42:24.170]                   sessionInformation <- function() {
[17:42:24.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.170]                       search = base::search(), system = base::Sys.info())
[17:42:24.170]                   }
[17:42:24.170]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.170]                     cond$call), session = sessionInformation(), 
[17:42:24.170]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.170]                   signalCondition(cond)
[17:42:24.170]                 }
[17:42:24.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.170]                 "immediateCondition"))) {
[17:42:24.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.170]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.170]                   if (TRUE && !signal) {
[17:42:24.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.170]                     {
[17:42:24.170]                       inherits <- base::inherits
[17:42:24.170]                       invokeRestart <- base::invokeRestart
[17:42:24.170]                       is.null <- base::is.null
[17:42:24.170]                       muffled <- FALSE
[17:42:24.170]                       if (inherits(cond, "message")) {
[17:42:24.170]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.170]                         if (muffled) 
[17:42:24.170]                           invokeRestart("muffleMessage")
[17:42:24.170]                       }
[17:42:24.170]                       else if (inherits(cond, "warning")) {
[17:42:24.170]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.170]                         if (muffled) 
[17:42:24.170]                           invokeRestart("muffleWarning")
[17:42:24.170]                       }
[17:42:24.170]                       else if (inherits(cond, "condition")) {
[17:42:24.170]                         if (!is.null(pattern)) {
[17:42:24.170]                           computeRestarts <- base::computeRestarts
[17:42:24.170]                           grepl <- base::grepl
[17:42:24.170]                           restarts <- computeRestarts(cond)
[17:42:24.170]                           for (restart in restarts) {
[17:42:24.170]                             name <- restart$name
[17:42:24.170]                             if (is.null(name)) 
[17:42:24.170]                               next
[17:42:24.170]                             if (!grepl(pattern, name)) 
[17:42:24.170]                               next
[17:42:24.170]                             invokeRestart(restart)
[17:42:24.170]                             muffled <- TRUE
[17:42:24.170]                             break
[17:42:24.170]                           }
[17:42:24.170]                         }
[17:42:24.170]                       }
[17:42:24.170]                       invisible(muffled)
[17:42:24.170]                     }
[17:42:24.170]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.170]                   }
[17:42:24.170]                 }
[17:42:24.170]                 else {
[17:42:24.170]                   if (TRUE) {
[17:42:24.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.170]                     {
[17:42:24.170]                       inherits <- base::inherits
[17:42:24.170]                       invokeRestart <- base::invokeRestart
[17:42:24.170]                       is.null <- base::is.null
[17:42:24.170]                       muffled <- FALSE
[17:42:24.170]                       if (inherits(cond, "message")) {
[17:42:24.170]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.170]                         if (muffled) 
[17:42:24.170]                           invokeRestart("muffleMessage")
[17:42:24.170]                       }
[17:42:24.170]                       else if (inherits(cond, "warning")) {
[17:42:24.170]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.170]                         if (muffled) 
[17:42:24.170]                           invokeRestart("muffleWarning")
[17:42:24.170]                       }
[17:42:24.170]                       else if (inherits(cond, "condition")) {
[17:42:24.170]                         if (!is.null(pattern)) {
[17:42:24.170]                           computeRestarts <- base::computeRestarts
[17:42:24.170]                           grepl <- base::grepl
[17:42:24.170]                           restarts <- computeRestarts(cond)
[17:42:24.170]                           for (restart in restarts) {
[17:42:24.170]                             name <- restart$name
[17:42:24.170]                             if (is.null(name)) 
[17:42:24.170]                               next
[17:42:24.170]                             if (!grepl(pattern, name)) 
[17:42:24.170]                               next
[17:42:24.170]                             invokeRestart(restart)
[17:42:24.170]                             muffled <- TRUE
[17:42:24.170]                             break
[17:42:24.170]                           }
[17:42:24.170]                         }
[17:42:24.170]                       }
[17:42:24.170]                       invisible(muffled)
[17:42:24.170]                     }
[17:42:24.170]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.170]                   }
[17:42:24.170]                 }
[17:42:24.170]             }
[17:42:24.170]         }))
[17:42:24.170]     }, error = function(ex) {
[17:42:24.170]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.170]                 ...future.rng), started = ...future.startTime, 
[17:42:24.170]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.170]             version = "1.8"), class = "FutureResult")
[17:42:24.170]     }, finally = {
[17:42:24.170]         if (!identical(...future.workdir, getwd())) 
[17:42:24.170]             setwd(...future.workdir)
[17:42:24.170]         {
[17:42:24.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.170]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.170]             }
[17:42:24.170]             base::options(...future.oldOptions)
[17:42:24.170]             if (.Platform$OS.type == "windows") {
[17:42:24.170]                 old_names <- names(...future.oldEnvVars)
[17:42:24.170]                 envs <- base::Sys.getenv()
[17:42:24.170]                 names <- names(envs)
[17:42:24.170]                 common <- intersect(names, old_names)
[17:42:24.170]                 added <- setdiff(names, old_names)
[17:42:24.170]                 removed <- setdiff(old_names, names)
[17:42:24.170]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.170]                   envs[common]]
[17:42:24.170]                 NAMES <- toupper(changed)
[17:42:24.170]                 args <- list()
[17:42:24.170]                 for (kk in seq_along(NAMES)) {
[17:42:24.170]                   name <- changed[[kk]]
[17:42:24.170]                   NAME <- NAMES[[kk]]
[17:42:24.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.170]                     next
[17:42:24.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.170]                 }
[17:42:24.170]                 NAMES <- toupper(added)
[17:42:24.170]                 for (kk in seq_along(NAMES)) {
[17:42:24.170]                   name <- added[[kk]]
[17:42:24.170]                   NAME <- NAMES[[kk]]
[17:42:24.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.170]                     next
[17:42:24.170]                   args[[name]] <- ""
[17:42:24.170]                 }
[17:42:24.170]                 NAMES <- toupper(removed)
[17:42:24.170]                 for (kk in seq_along(NAMES)) {
[17:42:24.170]                   name <- removed[[kk]]
[17:42:24.170]                   NAME <- NAMES[[kk]]
[17:42:24.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.170]                     next
[17:42:24.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.170]                 }
[17:42:24.170]                 if (length(args) > 0) 
[17:42:24.170]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.170]             }
[17:42:24.170]             else {
[17:42:24.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.170]             }
[17:42:24.170]             {
[17:42:24.170]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.170]                   0L) {
[17:42:24.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.170]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.170]                   base::options(opts)
[17:42:24.170]                 }
[17:42:24.170]                 {
[17:42:24.170]                   {
[17:42:24.170]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.170]                     NULL
[17:42:24.170]                   }
[17:42:24.170]                   options(future.plan = NULL)
[17:42:24.170]                   if (is.na(NA_character_)) 
[17:42:24.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.170]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.170]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.170]                     envir = parent.frame()) 
[17:42:24.170]                   {
[17:42:24.170]                     if (is.function(workers)) 
[17:42:24.170]                       workers <- workers()
[17:42:24.170]                     workers <- structure(as.integer(workers), 
[17:42:24.170]                       class = class(workers))
[17:42:24.170]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.170]                       workers >= 1)
[17:42:24.170]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.170]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.170]                     }
[17:42:24.170]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.170]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.170]                       envir = envir)
[17:42:24.170]                     if (!future$lazy) 
[17:42:24.170]                       future <- run(future)
[17:42:24.170]                     invisible(future)
[17:42:24.170]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.170]                 }
[17:42:24.170]             }
[17:42:24.170]         }
[17:42:24.170]     })
[17:42:24.170]     if (TRUE) {
[17:42:24.170]         base::sink(type = "output", split = FALSE)
[17:42:24.170]         if (TRUE) {
[17:42:24.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.170]         }
[17:42:24.170]         else {
[17:42:24.170]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.170]         }
[17:42:24.170]         base::close(...future.stdout)
[17:42:24.170]         ...future.stdout <- NULL
[17:42:24.170]     }
[17:42:24.170]     ...future.result$conditions <- ...future.conditions
[17:42:24.170]     ...future.result$finished <- base::Sys.time()
[17:42:24.170]     ...future.result
[17:42:24.170] }
[17:42:24.174] MultisessionFuture started
[17:42:24.174] - Launch lazy future ... done
[17:42:24.174] run() for ‘MultisessionFuture’ ... done
[17:42:24.174] getGlobalsAndPackages() ...
[17:42:24.174] Searching for globals...
[17:42:24.175] 
[17:42:24.175] Searching for globals ... DONE
[17:42:24.175] - globals: [0] <none>
[17:42:24.175] getGlobalsAndPackages() ... DONE
[17:42:24.175] run() for ‘Future’ ...
[17:42:24.175] - state: ‘created’
[17:42:24.176] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.191] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.191]   - Field: ‘node’
[17:42:24.191]   - Field: ‘label’
[17:42:24.191]   - Field: ‘local’
[17:42:24.191]   - Field: ‘owner’
[17:42:24.191]   - Field: ‘envir’
[17:42:24.191]   - Field: ‘workers’
[17:42:24.191]   - Field: ‘packages’
[17:42:24.192]   - Field: ‘gc’
[17:42:24.192]   - Field: ‘conditions’
[17:42:24.192]   - Field: ‘persistent’
[17:42:24.192]   - Field: ‘expr’
[17:42:24.192]   - Field: ‘uuid’
[17:42:24.192]   - Field: ‘seed’
[17:42:24.192]   - Field: ‘version’
[17:42:24.192]   - Field: ‘result’
[17:42:24.192]   - Field: ‘asynchronous’
[17:42:24.192]   - Field: ‘calls’
[17:42:24.193]   - Field: ‘globals’
[17:42:24.193]   - Field: ‘stdout’
[17:42:24.193]   - Field: ‘earlySignal’
[17:42:24.193]   - Field: ‘lazy’
[17:42:24.193]   - Field: ‘state’
[17:42:24.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.193] - Launch lazy future ...
[17:42:24.193] Packages needed by the future expression (n = 0): <none>
[17:42:24.193] Packages needed by future strategies (n = 0): <none>
[17:42:24.194] {
[17:42:24.194]     {
[17:42:24.194]         {
[17:42:24.194]             ...future.startTime <- base::Sys.time()
[17:42:24.194]             {
[17:42:24.194]                 {
[17:42:24.194]                   {
[17:42:24.194]                     {
[17:42:24.194]                       base::local({
[17:42:24.194]                         has_future <- base::requireNamespace("future", 
[17:42:24.194]                           quietly = TRUE)
[17:42:24.194]                         if (has_future) {
[17:42:24.194]                           ns <- base::getNamespace("future")
[17:42:24.194]                           version <- ns[[".package"]][["version"]]
[17:42:24.194]                           if (is.null(version)) 
[17:42:24.194]                             version <- utils::packageVersion("future")
[17:42:24.194]                         }
[17:42:24.194]                         else {
[17:42:24.194]                           version <- NULL
[17:42:24.194]                         }
[17:42:24.194]                         if (!has_future || version < "1.8.0") {
[17:42:24.194]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.194]                             "", base::R.version$version.string), 
[17:42:24.194]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.194]                               "release", "version")], collapse = " "), 
[17:42:24.194]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.194]                             info)
[17:42:24.194]                           info <- base::paste(info, collapse = "; ")
[17:42:24.194]                           if (!has_future) {
[17:42:24.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.194]                               info)
[17:42:24.194]                           }
[17:42:24.194]                           else {
[17:42:24.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.194]                               info, version)
[17:42:24.194]                           }
[17:42:24.194]                           base::stop(msg)
[17:42:24.194]                         }
[17:42:24.194]                       })
[17:42:24.194]                     }
[17:42:24.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.194]                     base::options(mc.cores = 1L)
[17:42:24.194]                   }
[17:42:24.194]                   options(future.plan = NULL)
[17:42:24.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.194]                 }
[17:42:24.194]                 ...future.workdir <- getwd()
[17:42:24.194]             }
[17:42:24.194]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.194]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.194]         }
[17:42:24.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.194]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.194]             base::names(...future.oldOptions))
[17:42:24.194]     }
[17:42:24.194]     if (FALSE) {
[17:42:24.194]     }
[17:42:24.194]     else {
[17:42:24.194]         if (TRUE) {
[17:42:24.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.194]                 open = "w")
[17:42:24.194]         }
[17:42:24.194]         else {
[17:42:24.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.194]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.194]         }
[17:42:24.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.194]             base::sink(type = "output", split = FALSE)
[17:42:24.194]             base::close(...future.stdout)
[17:42:24.194]         }, add = TRUE)
[17:42:24.194]     }
[17:42:24.194]     ...future.frame <- base::sys.nframe()
[17:42:24.194]     ...future.conditions <- base::list()
[17:42:24.194]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.194]     if (FALSE) {
[17:42:24.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.194]     }
[17:42:24.194]     ...future.result <- base::tryCatch({
[17:42:24.194]         base::withCallingHandlers({
[17:42:24.194]             ...future.value <- base::withVisible(base::local({
[17:42:24.194]                 ...future.makeSendCondition <- local({
[17:42:24.194]                   sendCondition <- NULL
[17:42:24.194]                   function(frame = 1L) {
[17:42:24.194]                     if (is.function(sendCondition)) 
[17:42:24.194]                       return(sendCondition)
[17:42:24.194]                     ns <- getNamespace("parallel")
[17:42:24.194]                     if (exists("sendData", mode = "function", 
[17:42:24.194]                       envir = ns)) {
[17:42:24.194]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.194]                         envir = ns)
[17:42:24.194]                       envir <- sys.frame(frame)
[17:42:24.194]                       master <- NULL
[17:42:24.194]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.194]                         !identical(envir, emptyenv())) {
[17:42:24.194]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.194]                           inherits = FALSE)) {
[17:42:24.194]                           master <- get("master", mode = "list", 
[17:42:24.194]                             envir = envir, inherits = FALSE)
[17:42:24.194]                           if (inherits(master, c("SOCKnode", 
[17:42:24.194]                             "SOCK0node"))) {
[17:42:24.194]                             sendCondition <<- function(cond) {
[17:42:24.194]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.194]                                 success = TRUE)
[17:42:24.194]                               parallel_sendData(master, data)
[17:42:24.194]                             }
[17:42:24.194]                             return(sendCondition)
[17:42:24.194]                           }
[17:42:24.194]                         }
[17:42:24.194]                         frame <- frame + 1L
[17:42:24.194]                         envir <- sys.frame(frame)
[17:42:24.194]                       }
[17:42:24.194]                     }
[17:42:24.194]                     sendCondition <<- function(cond) NULL
[17:42:24.194]                   }
[17:42:24.194]                 })
[17:42:24.194]                 withCallingHandlers({
[17:42:24.194]                   NULL
[17:42:24.194]                 }, immediateCondition = function(cond) {
[17:42:24.194]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.194]                   sendCondition(cond)
[17:42:24.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.194]                   {
[17:42:24.194]                     inherits <- base::inherits
[17:42:24.194]                     invokeRestart <- base::invokeRestart
[17:42:24.194]                     is.null <- base::is.null
[17:42:24.194]                     muffled <- FALSE
[17:42:24.194]                     if (inherits(cond, "message")) {
[17:42:24.194]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.194]                       if (muffled) 
[17:42:24.194]                         invokeRestart("muffleMessage")
[17:42:24.194]                     }
[17:42:24.194]                     else if (inherits(cond, "warning")) {
[17:42:24.194]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.194]                       if (muffled) 
[17:42:24.194]                         invokeRestart("muffleWarning")
[17:42:24.194]                     }
[17:42:24.194]                     else if (inherits(cond, "condition")) {
[17:42:24.194]                       if (!is.null(pattern)) {
[17:42:24.194]                         computeRestarts <- base::computeRestarts
[17:42:24.194]                         grepl <- base::grepl
[17:42:24.194]                         restarts <- computeRestarts(cond)
[17:42:24.194]                         for (restart in restarts) {
[17:42:24.194]                           name <- restart$name
[17:42:24.194]                           if (is.null(name)) 
[17:42:24.194]                             next
[17:42:24.194]                           if (!grepl(pattern, name)) 
[17:42:24.194]                             next
[17:42:24.194]                           invokeRestart(restart)
[17:42:24.194]                           muffled <- TRUE
[17:42:24.194]                           break
[17:42:24.194]                         }
[17:42:24.194]                       }
[17:42:24.194]                     }
[17:42:24.194]                     invisible(muffled)
[17:42:24.194]                   }
[17:42:24.194]                   muffleCondition(cond)
[17:42:24.194]                 })
[17:42:24.194]             }))
[17:42:24.194]             future::FutureResult(value = ...future.value$value, 
[17:42:24.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.194]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.194]                     ...future.globalenv.names))
[17:42:24.194]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.194]         }, condition = base::local({
[17:42:24.194]             c <- base::c
[17:42:24.194]             inherits <- base::inherits
[17:42:24.194]             invokeRestart <- base::invokeRestart
[17:42:24.194]             length <- base::length
[17:42:24.194]             list <- base::list
[17:42:24.194]             seq.int <- base::seq.int
[17:42:24.194]             signalCondition <- base::signalCondition
[17:42:24.194]             sys.calls <- base::sys.calls
[17:42:24.194]             `[[` <- base::`[[`
[17:42:24.194]             `+` <- base::`+`
[17:42:24.194]             `<<-` <- base::`<<-`
[17:42:24.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.194]                   3L)]
[17:42:24.194]             }
[17:42:24.194]             function(cond) {
[17:42:24.194]                 is_error <- inherits(cond, "error")
[17:42:24.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.194]                   NULL)
[17:42:24.194]                 if (is_error) {
[17:42:24.194]                   sessionInformation <- function() {
[17:42:24.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.194]                       search = base::search(), system = base::Sys.info())
[17:42:24.194]                   }
[17:42:24.194]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.194]                     cond$call), session = sessionInformation(), 
[17:42:24.194]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.194]                   signalCondition(cond)
[17:42:24.194]                 }
[17:42:24.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.194]                 "immediateCondition"))) {
[17:42:24.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.194]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.194]                   if (TRUE && !signal) {
[17:42:24.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.194]                     {
[17:42:24.194]                       inherits <- base::inherits
[17:42:24.194]                       invokeRestart <- base::invokeRestart
[17:42:24.194]                       is.null <- base::is.null
[17:42:24.194]                       muffled <- FALSE
[17:42:24.194]                       if (inherits(cond, "message")) {
[17:42:24.194]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.194]                         if (muffled) 
[17:42:24.194]                           invokeRestart("muffleMessage")
[17:42:24.194]                       }
[17:42:24.194]                       else if (inherits(cond, "warning")) {
[17:42:24.194]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.194]                         if (muffled) 
[17:42:24.194]                           invokeRestart("muffleWarning")
[17:42:24.194]                       }
[17:42:24.194]                       else if (inherits(cond, "condition")) {
[17:42:24.194]                         if (!is.null(pattern)) {
[17:42:24.194]                           computeRestarts <- base::computeRestarts
[17:42:24.194]                           grepl <- base::grepl
[17:42:24.194]                           restarts <- computeRestarts(cond)
[17:42:24.194]                           for (restart in restarts) {
[17:42:24.194]                             name <- restart$name
[17:42:24.194]                             if (is.null(name)) 
[17:42:24.194]                               next
[17:42:24.194]                             if (!grepl(pattern, name)) 
[17:42:24.194]                               next
[17:42:24.194]                             invokeRestart(restart)
[17:42:24.194]                             muffled <- TRUE
[17:42:24.194]                             break
[17:42:24.194]                           }
[17:42:24.194]                         }
[17:42:24.194]                       }
[17:42:24.194]                       invisible(muffled)
[17:42:24.194]                     }
[17:42:24.194]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.194]                   }
[17:42:24.194]                 }
[17:42:24.194]                 else {
[17:42:24.194]                   if (TRUE) {
[17:42:24.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.194]                     {
[17:42:24.194]                       inherits <- base::inherits
[17:42:24.194]                       invokeRestart <- base::invokeRestart
[17:42:24.194]                       is.null <- base::is.null
[17:42:24.194]                       muffled <- FALSE
[17:42:24.194]                       if (inherits(cond, "message")) {
[17:42:24.194]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.194]                         if (muffled) 
[17:42:24.194]                           invokeRestart("muffleMessage")
[17:42:24.194]                       }
[17:42:24.194]                       else if (inherits(cond, "warning")) {
[17:42:24.194]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.194]                         if (muffled) 
[17:42:24.194]                           invokeRestart("muffleWarning")
[17:42:24.194]                       }
[17:42:24.194]                       else if (inherits(cond, "condition")) {
[17:42:24.194]                         if (!is.null(pattern)) {
[17:42:24.194]                           computeRestarts <- base::computeRestarts
[17:42:24.194]                           grepl <- base::grepl
[17:42:24.194]                           restarts <- computeRestarts(cond)
[17:42:24.194]                           for (restart in restarts) {
[17:42:24.194]                             name <- restart$name
[17:42:24.194]                             if (is.null(name)) 
[17:42:24.194]                               next
[17:42:24.194]                             if (!grepl(pattern, name)) 
[17:42:24.194]                               next
[17:42:24.194]                             invokeRestart(restart)
[17:42:24.194]                             muffled <- TRUE
[17:42:24.194]                             break
[17:42:24.194]                           }
[17:42:24.194]                         }
[17:42:24.194]                       }
[17:42:24.194]                       invisible(muffled)
[17:42:24.194]                     }
[17:42:24.194]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.194]                   }
[17:42:24.194]                 }
[17:42:24.194]             }
[17:42:24.194]         }))
[17:42:24.194]     }, error = function(ex) {
[17:42:24.194]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.194]                 ...future.rng), started = ...future.startTime, 
[17:42:24.194]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.194]             version = "1.8"), class = "FutureResult")
[17:42:24.194]     }, finally = {
[17:42:24.194]         if (!identical(...future.workdir, getwd())) 
[17:42:24.194]             setwd(...future.workdir)
[17:42:24.194]         {
[17:42:24.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.194]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.194]             }
[17:42:24.194]             base::options(...future.oldOptions)
[17:42:24.194]             if (.Platform$OS.type == "windows") {
[17:42:24.194]                 old_names <- names(...future.oldEnvVars)
[17:42:24.194]                 envs <- base::Sys.getenv()
[17:42:24.194]                 names <- names(envs)
[17:42:24.194]                 common <- intersect(names, old_names)
[17:42:24.194]                 added <- setdiff(names, old_names)
[17:42:24.194]                 removed <- setdiff(old_names, names)
[17:42:24.194]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.194]                   envs[common]]
[17:42:24.194]                 NAMES <- toupper(changed)
[17:42:24.194]                 args <- list()
[17:42:24.194]                 for (kk in seq_along(NAMES)) {
[17:42:24.194]                   name <- changed[[kk]]
[17:42:24.194]                   NAME <- NAMES[[kk]]
[17:42:24.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.194]                     next
[17:42:24.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.194]                 }
[17:42:24.194]                 NAMES <- toupper(added)
[17:42:24.194]                 for (kk in seq_along(NAMES)) {
[17:42:24.194]                   name <- added[[kk]]
[17:42:24.194]                   NAME <- NAMES[[kk]]
[17:42:24.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.194]                     next
[17:42:24.194]                   args[[name]] <- ""
[17:42:24.194]                 }
[17:42:24.194]                 NAMES <- toupper(removed)
[17:42:24.194]                 for (kk in seq_along(NAMES)) {
[17:42:24.194]                   name <- removed[[kk]]
[17:42:24.194]                   NAME <- NAMES[[kk]]
[17:42:24.194]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.194]                     next
[17:42:24.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.194]                 }
[17:42:24.194]                 if (length(args) > 0) 
[17:42:24.194]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.194]             }
[17:42:24.194]             else {
[17:42:24.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.194]             }
[17:42:24.194]             {
[17:42:24.194]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.194]                   0L) {
[17:42:24.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.194]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.194]                   base::options(opts)
[17:42:24.194]                 }
[17:42:24.194]                 {
[17:42:24.194]                   {
[17:42:24.194]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.194]                     NULL
[17:42:24.194]                   }
[17:42:24.194]                   options(future.plan = NULL)
[17:42:24.194]                   if (is.na(NA_character_)) 
[17:42:24.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.194]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.194]                     envir = parent.frame()) 
[17:42:24.194]                   {
[17:42:24.194]                     if (is.function(workers)) 
[17:42:24.194]                       workers <- workers()
[17:42:24.194]                     workers <- structure(as.integer(workers), 
[17:42:24.194]                       class = class(workers))
[17:42:24.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.194]                       workers >= 1)
[17:42:24.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.194]                     }
[17:42:24.194]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.194]                       envir = envir)
[17:42:24.194]                     if (!future$lazy) 
[17:42:24.194]                       future <- run(future)
[17:42:24.194]                     invisible(future)
[17:42:24.194]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.194]                 }
[17:42:24.194]             }
[17:42:24.194]         }
[17:42:24.194]     })
[17:42:24.194]     if (TRUE) {
[17:42:24.194]         base::sink(type = "output", split = FALSE)
[17:42:24.194]         if (TRUE) {
[17:42:24.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.194]         }
[17:42:24.194]         else {
[17:42:24.194]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.194]         }
[17:42:24.194]         base::close(...future.stdout)
[17:42:24.194]         ...future.stdout <- NULL
[17:42:24.194]     }
[17:42:24.194]     ...future.result$conditions <- ...future.conditions
[17:42:24.194]     ...future.result$finished <- base::Sys.time()
[17:42:24.194]     ...future.result
[17:42:24.194] }
[17:42:24.267] MultisessionFuture started
[17:42:24.267] - Launch lazy future ... done
[17:42:24.267] run() for ‘MultisessionFuture’ ... done
[17:42:24.268] getGlobalsAndPackages() ...
[17:42:24.268] Searching for globals...
[17:42:24.269] - globals found: [1] ‘{’
[17:42:24.269] Searching for globals ... DONE
[17:42:24.270] Resolving globals: FALSE
[17:42:24.270] 
[17:42:24.270] 
[17:42:24.270] getGlobalsAndPackages() ... DONE
[17:42:24.271] run() for ‘Future’ ...
[17:42:24.271] - state: ‘created’
[17:42:24.271] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.290]   - Field: ‘node’
[17:42:24.290]   - Field: ‘label’
[17:42:24.290]   - Field: ‘local’
[17:42:24.291]   - Field: ‘owner’
[17:42:24.291]   - Field: ‘envir’
[17:42:24.291]   - Field: ‘workers’
[17:42:24.291]   - Field: ‘packages’
[17:42:24.291]   - Field: ‘gc’
[17:42:24.291]   - Field: ‘conditions’
[17:42:24.292]   - Field: ‘persistent’
[17:42:24.292]   - Field: ‘expr’
[17:42:24.292]   - Field: ‘uuid’
[17:42:24.292]   - Field: ‘seed’
[17:42:24.292]   - Field: ‘version’
[17:42:24.292]   - Field: ‘result’
[17:42:24.293]   - Field: ‘asynchronous’
[17:42:24.293]   - Field: ‘calls’
[17:42:24.293]   - Field: ‘globals’
[17:42:24.293]   - Field: ‘stdout’
[17:42:24.293]   - Field: ‘earlySignal’
[17:42:24.293]   - Field: ‘lazy’
[17:42:24.293]   - Field: ‘state’
[17:42:24.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.294] - Launch lazy future ...
[17:42:24.294] Packages needed by the future expression (n = 0): <none>
[17:42:24.294] Packages needed by future strategies (n = 0): <none>
[17:42:24.295] {
[17:42:24.295]     {
[17:42:24.295]         {
[17:42:24.295]             ...future.startTime <- base::Sys.time()
[17:42:24.295]             {
[17:42:24.295]                 {
[17:42:24.295]                   {
[17:42:24.295]                     {
[17:42:24.295]                       base::local({
[17:42:24.295]                         has_future <- base::requireNamespace("future", 
[17:42:24.295]                           quietly = TRUE)
[17:42:24.295]                         if (has_future) {
[17:42:24.295]                           ns <- base::getNamespace("future")
[17:42:24.295]                           version <- ns[[".package"]][["version"]]
[17:42:24.295]                           if (is.null(version)) 
[17:42:24.295]                             version <- utils::packageVersion("future")
[17:42:24.295]                         }
[17:42:24.295]                         else {
[17:42:24.295]                           version <- NULL
[17:42:24.295]                         }
[17:42:24.295]                         if (!has_future || version < "1.8.0") {
[17:42:24.295]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.295]                             "", base::R.version$version.string), 
[17:42:24.295]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.295]                               "release", "version")], collapse = " "), 
[17:42:24.295]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.295]                             info)
[17:42:24.295]                           info <- base::paste(info, collapse = "; ")
[17:42:24.295]                           if (!has_future) {
[17:42:24.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.295]                               info)
[17:42:24.295]                           }
[17:42:24.295]                           else {
[17:42:24.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.295]                               info, version)
[17:42:24.295]                           }
[17:42:24.295]                           base::stop(msg)
[17:42:24.295]                         }
[17:42:24.295]                       })
[17:42:24.295]                     }
[17:42:24.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.295]                     base::options(mc.cores = 1L)
[17:42:24.295]                   }
[17:42:24.295]                   options(future.plan = NULL)
[17:42:24.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.295]                 }
[17:42:24.295]                 ...future.workdir <- getwd()
[17:42:24.295]             }
[17:42:24.295]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.295]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.295]         }
[17:42:24.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.295]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.295]             base::names(...future.oldOptions))
[17:42:24.295]     }
[17:42:24.295]     if (FALSE) {
[17:42:24.295]     }
[17:42:24.295]     else {
[17:42:24.295]         if (TRUE) {
[17:42:24.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.295]                 open = "w")
[17:42:24.295]         }
[17:42:24.295]         else {
[17:42:24.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.295]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.295]         }
[17:42:24.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.295]             base::sink(type = "output", split = FALSE)
[17:42:24.295]             base::close(...future.stdout)
[17:42:24.295]         }, add = TRUE)
[17:42:24.295]     }
[17:42:24.295]     ...future.frame <- base::sys.nframe()
[17:42:24.295]     ...future.conditions <- base::list()
[17:42:24.295]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.295]     if (FALSE) {
[17:42:24.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.295]     }
[17:42:24.295]     ...future.result <- base::tryCatch({
[17:42:24.295]         base::withCallingHandlers({
[17:42:24.295]             ...future.value <- base::withVisible(base::local({
[17:42:24.295]                 ...future.makeSendCondition <- local({
[17:42:24.295]                   sendCondition <- NULL
[17:42:24.295]                   function(frame = 1L) {
[17:42:24.295]                     if (is.function(sendCondition)) 
[17:42:24.295]                       return(sendCondition)
[17:42:24.295]                     ns <- getNamespace("parallel")
[17:42:24.295]                     if (exists("sendData", mode = "function", 
[17:42:24.295]                       envir = ns)) {
[17:42:24.295]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.295]                         envir = ns)
[17:42:24.295]                       envir <- sys.frame(frame)
[17:42:24.295]                       master <- NULL
[17:42:24.295]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.295]                         !identical(envir, emptyenv())) {
[17:42:24.295]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.295]                           inherits = FALSE)) {
[17:42:24.295]                           master <- get("master", mode = "list", 
[17:42:24.295]                             envir = envir, inherits = FALSE)
[17:42:24.295]                           if (inherits(master, c("SOCKnode", 
[17:42:24.295]                             "SOCK0node"))) {
[17:42:24.295]                             sendCondition <<- function(cond) {
[17:42:24.295]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.295]                                 success = TRUE)
[17:42:24.295]                               parallel_sendData(master, data)
[17:42:24.295]                             }
[17:42:24.295]                             return(sendCondition)
[17:42:24.295]                           }
[17:42:24.295]                         }
[17:42:24.295]                         frame <- frame + 1L
[17:42:24.295]                         envir <- sys.frame(frame)
[17:42:24.295]                       }
[17:42:24.295]                     }
[17:42:24.295]                     sendCondition <<- function(cond) NULL
[17:42:24.295]                   }
[17:42:24.295]                 })
[17:42:24.295]                 withCallingHandlers({
[17:42:24.295]                   {
[17:42:24.295]                     4
[17:42:24.295]                   }
[17:42:24.295]                 }, immediateCondition = function(cond) {
[17:42:24.295]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.295]                   sendCondition(cond)
[17:42:24.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.295]                   {
[17:42:24.295]                     inherits <- base::inherits
[17:42:24.295]                     invokeRestart <- base::invokeRestart
[17:42:24.295]                     is.null <- base::is.null
[17:42:24.295]                     muffled <- FALSE
[17:42:24.295]                     if (inherits(cond, "message")) {
[17:42:24.295]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.295]                       if (muffled) 
[17:42:24.295]                         invokeRestart("muffleMessage")
[17:42:24.295]                     }
[17:42:24.295]                     else if (inherits(cond, "warning")) {
[17:42:24.295]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.295]                       if (muffled) 
[17:42:24.295]                         invokeRestart("muffleWarning")
[17:42:24.295]                     }
[17:42:24.295]                     else if (inherits(cond, "condition")) {
[17:42:24.295]                       if (!is.null(pattern)) {
[17:42:24.295]                         computeRestarts <- base::computeRestarts
[17:42:24.295]                         grepl <- base::grepl
[17:42:24.295]                         restarts <- computeRestarts(cond)
[17:42:24.295]                         for (restart in restarts) {
[17:42:24.295]                           name <- restart$name
[17:42:24.295]                           if (is.null(name)) 
[17:42:24.295]                             next
[17:42:24.295]                           if (!grepl(pattern, name)) 
[17:42:24.295]                             next
[17:42:24.295]                           invokeRestart(restart)
[17:42:24.295]                           muffled <- TRUE
[17:42:24.295]                           break
[17:42:24.295]                         }
[17:42:24.295]                       }
[17:42:24.295]                     }
[17:42:24.295]                     invisible(muffled)
[17:42:24.295]                   }
[17:42:24.295]                   muffleCondition(cond)
[17:42:24.295]                 })
[17:42:24.295]             }))
[17:42:24.295]             future::FutureResult(value = ...future.value$value, 
[17:42:24.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.295]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.295]                     ...future.globalenv.names))
[17:42:24.295]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.295]         }, condition = base::local({
[17:42:24.295]             c <- base::c
[17:42:24.295]             inherits <- base::inherits
[17:42:24.295]             invokeRestart <- base::invokeRestart
[17:42:24.295]             length <- base::length
[17:42:24.295]             list <- base::list
[17:42:24.295]             seq.int <- base::seq.int
[17:42:24.295]             signalCondition <- base::signalCondition
[17:42:24.295]             sys.calls <- base::sys.calls
[17:42:24.295]             `[[` <- base::`[[`
[17:42:24.295]             `+` <- base::`+`
[17:42:24.295]             `<<-` <- base::`<<-`
[17:42:24.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.295]                   3L)]
[17:42:24.295]             }
[17:42:24.295]             function(cond) {
[17:42:24.295]                 is_error <- inherits(cond, "error")
[17:42:24.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.295]                   NULL)
[17:42:24.295]                 if (is_error) {
[17:42:24.295]                   sessionInformation <- function() {
[17:42:24.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.295]                       search = base::search(), system = base::Sys.info())
[17:42:24.295]                   }
[17:42:24.295]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.295]                     cond$call), session = sessionInformation(), 
[17:42:24.295]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.295]                   signalCondition(cond)
[17:42:24.295]                 }
[17:42:24.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.295]                 "immediateCondition"))) {
[17:42:24.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.295]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.295]                   if (TRUE && !signal) {
[17:42:24.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.295]                     {
[17:42:24.295]                       inherits <- base::inherits
[17:42:24.295]                       invokeRestart <- base::invokeRestart
[17:42:24.295]                       is.null <- base::is.null
[17:42:24.295]                       muffled <- FALSE
[17:42:24.295]                       if (inherits(cond, "message")) {
[17:42:24.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.295]                         if (muffled) 
[17:42:24.295]                           invokeRestart("muffleMessage")
[17:42:24.295]                       }
[17:42:24.295]                       else if (inherits(cond, "warning")) {
[17:42:24.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.295]                         if (muffled) 
[17:42:24.295]                           invokeRestart("muffleWarning")
[17:42:24.295]                       }
[17:42:24.295]                       else if (inherits(cond, "condition")) {
[17:42:24.295]                         if (!is.null(pattern)) {
[17:42:24.295]                           computeRestarts <- base::computeRestarts
[17:42:24.295]                           grepl <- base::grepl
[17:42:24.295]                           restarts <- computeRestarts(cond)
[17:42:24.295]                           for (restart in restarts) {
[17:42:24.295]                             name <- restart$name
[17:42:24.295]                             if (is.null(name)) 
[17:42:24.295]                               next
[17:42:24.295]                             if (!grepl(pattern, name)) 
[17:42:24.295]                               next
[17:42:24.295]                             invokeRestart(restart)
[17:42:24.295]                             muffled <- TRUE
[17:42:24.295]                             break
[17:42:24.295]                           }
[17:42:24.295]                         }
[17:42:24.295]                       }
[17:42:24.295]                       invisible(muffled)
[17:42:24.295]                     }
[17:42:24.295]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.295]                   }
[17:42:24.295]                 }
[17:42:24.295]                 else {
[17:42:24.295]                   if (TRUE) {
[17:42:24.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.295]                     {
[17:42:24.295]                       inherits <- base::inherits
[17:42:24.295]                       invokeRestart <- base::invokeRestart
[17:42:24.295]                       is.null <- base::is.null
[17:42:24.295]                       muffled <- FALSE
[17:42:24.295]                       if (inherits(cond, "message")) {
[17:42:24.295]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.295]                         if (muffled) 
[17:42:24.295]                           invokeRestart("muffleMessage")
[17:42:24.295]                       }
[17:42:24.295]                       else if (inherits(cond, "warning")) {
[17:42:24.295]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.295]                         if (muffled) 
[17:42:24.295]                           invokeRestart("muffleWarning")
[17:42:24.295]                       }
[17:42:24.295]                       else if (inherits(cond, "condition")) {
[17:42:24.295]                         if (!is.null(pattern)) {
[17:42:24.295]                           computeRestarts <- base::computeRestarts
[17:42:24.295]                           grepl <- base::grepl
[17:42:24.295]                           restarts <- computeRestarts(cond)
[17:42:24.295]                           for (restart in restarts) {
[17:42:24.295]                             name <- restart$name
[17:42:24.295]                             if (is.null(name)) 
[17:42:24.295]                               next
[17:42:24.295]                             if (!grepl(pattern, name)) 
[17:42:24.295]                               next
[17:42:24.295]                             invokeRestart(restart)
[17:42:24.295]                             muffled <- TRUE
[17:42:24.295]                             break
[17:42:24.295]                           }
[17:42:24.295]                         }
[17:42:24.295]                       }
[17:42:24.295]                       invisible(muffled)
[17:42:24.295]                     }
[17:42:24.295]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.295]                   }
[17:42:24.295]                 }
[17:42:24.295]             }
[17:42:24.295]         }))
[17:42:24.295]     }, error = function(ex) {
[17:42:24.295]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.295]                 ...future.rng), started = ...future.startTime, 
[17:42:24.295]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.295]             version = "1.8"), class = "FutureResult")
[17:42:24.295]     }, finally = {
[17:42:24.295]         if (!identical(...future.workdir, getwd())) 
[17:42:24.295]             setwd(...future.workdir)
[17:42:24.295]         {
[17:42:24.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.295]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.295]             }
[17:42:24.295]             base::options(...future.oldOptions)
[17:42:24.295]             if (.Platform$OS.type == "windows") {
[17:42:24.295]                 old_names <- names(...future.oldEnvVars)
[17:42:24.295]                 envs <- base::Sys.getenv()
[17:42:24.295]                 names <- names(envs)
[17:42:24.295]                 common <- intersect(names, old_names)
[17:42:24.295]                 added <- setdiff(names, old_names)
[17:42:24.295]                 removed <- setdiff(old_names, names)
[17:42:24.295]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.295]                   envs[common]]
[17:42:24.295]                 NAMES <- toupper(changed)
[17:42:24.295]                 args <- list()
[17:42:24.295]                 for (kk in seq_along(NAMES)) {
[17:42:24.295]                   name <- changed[[kk]]
[17:42:24.295]                   NAME <- NAMES[[kk]]
[17:42:24.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.295]                     next
[17:42:24.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.295]                 }
[17:42:24.295]                 NAMES <- toupper(added)
[17:42:24.295]                 for (kk in seq_along(NAMES)) {
[17:42:24.295]                   name <- added[[kk]]
[17:42:24.295]                   NAME <- NAMES[[kk]]
[17:42:24.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.295]                     next
[17:42:24.295]                   args[[name]] <- ""
[17:42:24.295]                 }
[17:42:24.295]                 NAMES <- toupper(removed)
[17:42:24.295]                 for (kk in seq_along(NAMES)) {
[17:42:24.295]                   name <- removed[[kk]]
[17:42:24.295]                   NAME <- NAMES[[kk]]
[17:42:24.295]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.295]                     next
[17:42:24.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.295]                 }
[17:42:24.295]                 if (length(args) > 0) 
[17:42:24.295]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.295]             }
[17:42:24.295]             else {
[17:42:24.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.295]             }
[17:42:24.295]             {
[17:42:24.295]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.295]                   0L) {
[17:42:24.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.295]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.295]                   base::options(opts)
[17:42:24.295]                 }
[17:42:24.295]                 {
[17:42:24.295]                   {
[17:42:24.295]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.295]                     NULL
[17:42:24.295]                   }
[17:42:24.295]                   options(future.plan = NULL)
[17:42:24.295]                   if (is.na(NA_character_)) 
[17:42:24.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.295]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.295]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.295]                     envir = parent.frame()) 
[17:42:24.295]                   {
[17:42:24.295]                     if (is.function(workers)) 
[17:42:24.295]                       workers <- workers()
[17:42:24.295]                     workers <- structure(as.integer(workers), 
[17:42:24.295]                       class = class(workers))
[17:42:24.295]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.295]                       workers >= 1)
[17:42:24.295]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.295]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.295]                     }
[17:42:24.295]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.295]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.295]                       envir = envir)
[17:42:24.295]                     if (!future$lazy) 
[17:42:24.295]                       future <- run(future)
[17:42:24.295]                     invisible(future)
[17:42:24.295]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.295]                 }
[17:42:24.295]             }
[17:42:24.295]         }
[17:42:24.295]     })
[17:42:24.295]     if (TRUE) {
[17:42:24.295]         base::sink(type = "output", split = FALSE)
[17:42:24.295]         if (TRUE) {
[17:42:24.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.295]         }
[17:42:24.295]         else {
[17:42:24.295]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.295]         }
[17:42:24.295]         base::close(...future.stdout)
[17:42:24.295]         ...future.stdout <- NULL
[17:42:24.295]     }
[17:42:24.295]     ...future.result$conditions <- ...future.conditions
[17:42:24.295]     ...future.result$finished <- base::Sys.time()
[17:42:24.295]     ...future.result
[17:42:24.295] }
[17:42:24.299] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:24.310] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.311] - Validating connection of MultisessionFuture
[17:42:24.311] - received message: FutureResult
[17:42:24.311] - Received FutureResult
[17:42:24.311] - Erased future from FutureRegistry
[17:42:24.311] result() for ClusterFuture ...
[17:42:24.311] - result already collected: FutureResult
[17:42:24.311] result() for ClusterFuture ... done
[17:42:24.312] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.312] result() for ClusterFuture ...
[17:42:24.312] - result already collected: FutureResult
[17:42:24.312] result() for ClusterFuture ... done
[17:42:24.312] result() for ClusterFuture ...
[17:42:24.312] - result already collected: FutureResult
[17:42:24.313] result() for ClusterFuture ... done
[17:42:24.314] MultisessionFuture started
[17:42:24.314] - Launch lazy future ... done
[17:42:24.314] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef8260548> 
Classes 'listenv', 'environment' <environment: 0x55bef9189380> 
[17:42:24.317] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.317] - Validating connection of MultisessionFuture
[17:42:24.317] - received message: FutureResult
[17:42:24.317] - Received FutureResult
[17:42:24.317] - Erased future from FutureRegistry
[17:42:24.318] result() for ClusterFuture ...
[17:42:24.318] - result already collected: FutureResult
[17:42:24.318] result() for ClusterFuture ... done
[17:42:24.318] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:24.330] resolve() on list environment ...
[17:42:24.330]  recursive: 0
[17:42:24.331]  length: 6
[17:42:24.331]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:24.331] signalConditionsASAP(numeric, pos=1) ...
[17:42:24.331] - nx: 6
[17:42:24.331] - relay: TRUE
[17:42:24.332] - stdout: TRUE
[17:42:24.332] - signal: TRUE
[17:42:24.332] - resignal: FALSE
[17:42:24.332] - force: TRUE
[17:42:24.332] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.332] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.332]  - until=2
[17:42:24.332]  - relaying element #2
[17:42:24.332] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.332] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.332] signalConditionsASAP(NULL, pos=1) ... done
[17:42:24.333]  length: 5 (resolved future 1)
[17:42:24.333] Future #2
[17:42:24.333] result() for ClusterFuture ...
[17:42:24.333] - result already collected: FutureResult
[17:42:24.333] result() for ClusterFuture ... done
[17:42:24.333] result() for ClusterFuture ...
[17:42:24.333] - result already collected: FutureResult
[17:42:24.333] result() for ClusterFuture ... done
[17:42:24.333] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:24.333] - nx: 6
[17:42:24.334] - relay: TRUE
[17:42:24.334] - stdout: TRUE
[17:42:24.334] - signal: TRUE
[17:42:24.334] - resignal: FALSE
[17:42:24.334] - force: TRUE
[17:42:24.334] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.334] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.334]  - until=2
[17:42:24.334]  - relaying element #2
[17:42:24.334] result() for ClusterFuture ...
[17:42:24.334] - result already collected: FutureResult
[17:42:24.335] result() for ClusterFuture ... done
[17:42:24.335] result() for ClusterFuture ...
[17:42:24.335] - result already collected: FutureResult
[17:42:24.335] result() for ClusterFuture ... done
[17:42:24.335] result() for ClusterFuture ...
[17:42:24.335] - result already collected: FutureResult
[17:42:24.335] result() for ClusterFuture ... done
[17:42:24.335] result() for ClusterFuture ...
[17:42:24.335] - result already collected: FutureResult
[17:42:24.335] result() for ClusterFuture ... done
[17:42:24.336] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.336] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.336] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:24.336]  length: 4 (resolved future 2)
[17:42:24.336] Future #3
[17:42:24.336] result() for ClusterFuture ...
[17:42:24.336] - result already collected: FutureResult
[17:42:24.336] result() for ClusterFuture ... done
[17:42:24.336] result() for ClusterFuture ...
[17:42:24.337] - result already collected: FutureResult
[17:42:24.337] result() for ClusterFuture ... done
[17:42:24.337] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:24.337] - nx: 6
[17:42:24.337] - relay: TRUE
[17:42:24.337] - stdout: TRUE
[17:42:24.337] - signal: TRUE
[17:42:24.337] - resignal: FALSE
[17:42:24.337] - force: TRUE
[17:42:24.337] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.337] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.338]  - until=3
[17:42:24.338]  - relaying element #3
[17:42:24.338] result() for ClusterFuture ...
[17:42:24.338] - result already collected: FutureResult
[17:42:24.338] result() for ClusterFuture ... done
[17:42:24.338] result() for ClusterFuture ...
[17:42:24.338] - result already collected: FutureResult
[17:42:24.338] result() for ClusterFuture ... done
[17:42:24.338] result() for ClusterFuture ...
[17:42:24.338] - result already collected: FutureResult
[17:42:24.339] result() for ClusterFuture ... done
[17:42:24.339] result() for ClusterFuture ...
[17:42:24.339] - result already collected: FutureResult
[17:42:24.339] result() for ClusterFuture ... done
[17:42:24.339] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.339] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.339] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:24.339]  length: 3 (resolved future 3)
[17:42:24.350] signalConditionsASAP(NULL, pos=5) ...
[17:42:24.350] - nx: 6
[17:42:24.350] - relay: TRUE
[17:42:24.350] - stdout: TRUE
[17:42:24.350] - signal: TRUE
[17:42:24.350] - resignal: FALSE
[17:42:24.351] - force: TRUE
[17:42:24.351] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.351] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.351]  - until=6
[17:42:24.351]  - relaying element #4
[17:42:24.351]  - relaying element #6
[17:42:24.351] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.351] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.351] signalConditionsASAP(NULL, pos=5) ... done
[17:42:24.351]  length: 2 (resolved future 5)
[17:42:24.352] signalConditionsASAP(numeric, pos=6) ...
[17:42:24.352] - nx: 6
[17:42:24.352] - relay: TRUE
[17:42:24.352] - stdout: TRUE
[17:42:24.352] - signal: TRUE
[17:42:24.352] - resignal: FALSE
[17:42:24.352] - force: TRUE
[17:42:24.352] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.352] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.352]  - until=6
[17:42:24.352]  - relaying element #4
[17:42:24.352] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.353] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.353] signalConditionsASAP(NULL, pos=6) ... done
[17:42:24.353]  length: 1 (resolved future 6)
[17:42:24.363] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.364] - Validating connection of MultisessionFuture
[17:42:24.364] - received message: FutureResult
[17:42:24.364] - Received FutureResult
[17:42:24.364] - Erased future from FutureRegistry
[17:42:24.364] result() for ClusterFuture ...
[17:42:24.364] - result already collected: FutureResult
[17:42:24.364] result() for ClusterFuture ... done
[17:42:24.364] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.364] Future #4
[17:42:24.365] result() for ClusterFuture ...
[17:42:24.365] - result already collected: FutureResult
[17:42:24.365] result() for ClusterFuture ... done
[17:42:24.365] result() for ClusterFuture ...
[17:42:24.365] - result already collected: FutureResult
[17:42:24.365] result() for ClusterFuture ... done
[17:42:24.365] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:24.365] - nx: 6
[17:42:24.365] - relay: TRUE
[17:42:24.365] - stdout: TRUE
[17:42:24.365] - signal: TRUE
[17:42:24.366] - resignal: FALSE
[17:42:24.366] - force: TRUE
[17:42:24.366] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.366] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.366]  - until=6
[17:42:24.366]  - relaying element #4
[17:42:24.366] result() for ClusterFuture ...
[17:42:24.366] - result already collected: FutureResult
[17:42:24.366] result() for ClusterFuture ... done
[17:42:24.366] result() for ClusterFuture ...
[17:42:24.366] - result already collected: FutureResult
[17:42:24.367] result() for ClusterFuture ... done
[17:42:24.367] result() for ClusterFuture ...
[17:42:24.367] - result already collected: FutureResult
[17:42:24.367] result() for ClusterFuture ... done
[17:42:24.367] result() for ClusterFuture ...
[17:42:24.367] - result already collected: FutureResult
[17:42:24.367] result() for ClusterFuture ... done
[17:42:24.367] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.367] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.368] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:24.368]  length: 0 (resolved future 4)
[17:42:24.368] Relaying remaining futures
[17:42:24.368] signalConditionsASAP(NULL, pos=0) ...
[17:42:24.368] - nx: 6
[17:42:24.368] - relay: TRUE
[17:42:24.368] - stdout: TRUE
[17:42:24.368] - signal: TRUE
[17:42:24.368] - resignal: FALSE
[17:42:24.368] - force: TRUE
[17:42:24.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.368] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:24.369] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.369] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.369] signalConditionsASAP(NULL, pos=0) ... done
[17:42:24.369] resolve() on list environment ... DONE
[17:42:24.369] result() for ClusterFuture ...
[17:42:24.369] - result already collected: FutureResult
[17:42:24.369] result() for ClusterFuture ... done
[17:42:24.369] result() for ClusterFuture ...
[17:42:24.369] - result already collected: FutureResult
[17:42:24.370] result() for ClusterFuture ... done
[17:42:24.370] result() for ClusterFuture ...
[17:42:24.370] - result already collected: FutureResult
[17:42:24.370] result() for ClusterFuture ... done
[17:42:24.370] result() for ClusterFuture ...
[17:42:24.370] - result already collected: FutureResult
[17:42:24.370] result() for ClusterFuture ... done
[17:42:24.370] result() for ClusterFuture ...
[17:42:24.370] - result already collected: FutureResult
[17:42:24.371] result() for ClusterFuture ... done
[17:42:24.371] result() for ClusterFuture ...
[17:42:24.371] - result already collected: FutureResult
[17:42:24.371] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55bef93e0280> 
Dimensions: c(1, 6)
[17:42:24.372] getGlobalsAndPackages() ...
[17:42:24.372] Searching for globals...
[17:42:24.372] 
[17:42:24.372] Searching for globals ... DONE
[17:42:24.372] - globals: [0] <none>
[17:42:24.372] getGlobalsAndPackages() ... DONE
[17:42:24.373] run() for ‘Future’ ...
[17:42:24.373] - state: ‘created’
[17:42:24.373] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.391] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.391] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.391]   - Field: ‘node’
[17:42:24.391]   - Field: ‘label’
[17:42:24.391]   - Field: ‘local’
[17:42:24.391]   - Field: ‘owner’
[17:42:24.392]   - Field: ‘envir’
[17:42:24.392]   - Field: ‘workers’
[17:42:24.392]   - Field: ‘packages’
[17:42:24.392]   - Field: ‘gc’
[17:42:24.392]   - Field: ‘conditions’
[17:42:24.392]   - Field: ‘persistent’
[17:42:24.392]   - Field: ‘expr’
[17:42:24.392]   - Field: ‘uuid’
[17:42:24.392]   - Field: ‘seed’
[17:42:24.392]   - Field: ‘version’
[17:42:24.392]   - Field: ‘result’
[17:42:24.393]   - Field: ‘asynchronous’
[17:42:24.393]   - Field: ‘calls’
[17:42:24.393]   - Field: ‘globals’
[17:42:24.393]   - Field: ‘stdout’
[17:42:24.393]   - Field: ‘earlySignal’
[17:42:24.393]   - Field: ‘lazy’
[17:42:24.393]   - Field: ‘state’
[17:42:24.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.393] - Launch lazy future ...
[17:42:24.394] Packages needed by the future expression (n = 0): <none>
[17:42:24.394] Packages needed by future strategies (n = 0): <none>
[17:42:24.394] {
[17:42:24.394]     {
[17:42:24.394]         {
[17:42:24.394]             ...future.startTime <- base::Sys.time()
[17:42:24.394]             {
[17:42:24.394]                 {
[17:42:24.394]                   {
[17:42:24.394]                     {
[17:42:24.394]                       base::local({
[17:42:24.394]                         has_future <- base::requireNamespace("future", 
[17:42:24.394]                           quietly = TRUE)
[17:42:24.394]                         if (has_future) {
[17:42:24.394]                           ns <- base::getNamespace("future")
[17:42:24.394]                           version <- ns[[".package"]][["version"]]
[17:42:24.394]                           if (is.null(version)) 
[17:42:24.394]                             version <- utils::packageVersion("future")
[17:42:24.394]                         }
[17:42:24.394]                         else {
[17:42:24.394]                           version <- NULL
[17:42:24.394]                         }
[17:42:24.394]                         if (!has_future || version < "1.8.0") {
[17:42:24.394]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.394]                             "", base::R.version$version.string), 
[17:42:24.394]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.394]                               "release", "version")], collapse = " "), 
[17:42:24.394]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.394]                             info)
[17:42:24.394]                           info <- base::paste(info, collapse = "; ")
[17:42:24.394]                           if (!has_future) {
[17:42:24.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.394]                               info)
[17:42:24.394]                           }
[17:42:24.394]                           else {
[17:42:24.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.394]                               info, version)
[17:42:24.394]                           }
[17:42:24.394]                           base::stop(msg)
[17:42:24.394]                         }
[17:42:24.394]                       })
[17:42:24.394]                     }
[17:42:24.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.394]                     base::options(mc.cores = 1L)
[17:42:24.394]                   }
[17:42:24.394]                   options(future.plan = NULL)
[17:42:24.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.394]                 }
[17:42:24.394]                 ...future.workdir <- getwd()
[17:42:24.394]             }
[17:42:24.394]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.394]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.394]         }
[17:42:24.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.394]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.394]             base::names(...future.oldOptions))
[17:42:24.394]     }
[17:42:24.394]     if (FALSE) {
[17:42:24.394]     }
[17:42:24.394]     else {
[17:42:24.394]         if (TRUE) {
[17:42:24.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.394]                 open = "w")
[17:42:24.394]         }
[17:42:24.394]         else {
[17:42:24.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.394]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.394]         }
[17:42:24.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.394]             base::sink(type = "output", split = FALSE)
[17:42:24.394]             base::close(...future.stdout)
[17:42:24.394]         }, add = TRUE)
[17:42:24.394]     }
[17:42:24.394]     ...future.frame <- base::sys.nframe()
[17:42:24.394]     ...future.conditions <- base::list()
[17:42:24.394]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.394]     if (FALSE) {
[17:42:24.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.394]     }
[17:42:24.394]     ...future.result <- base::tryCatch({
[17:42:24.394]         base::withCallingHandlers({
[17:42:24.394]             ...future.value <- base::withVisible(base::local({
[17:42:24.394]                 ...future.makeSendCondition <- local({
[17:42:24.394]                   sendCondition <- NULL
[17:42:24.394]                   function(frame = 1L) {
[17:42:24.394]                     if (is.function(sendCondition)) 
[17:42:24.394]                       return(sendCondition)
[17:42:24.394]                     ns <- getNamespace("parallel")
[17:42:24.394]                     if (exists("sendData", mode = "function", 
[17:42:24.394]                       envir = ns)) {
[17:42:24.394]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.394]                         envir = ns)
[17:42:24.394]                       envir <- sys.frame(frame)
[17:42:24.394]                       master <- NULL
[17:42:24.394]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.394]                         !identical(envir, emptyenv())) {
[17:42:24.394]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.394]                           inherits = FALSE)) {
[17:42:24.394]                           master <- get("master", mode = "list", 
[17:42:24.394]                             envir = envir, inherits = FALSE)
[17:42:24.394]                           if (inherits(master, c("SOCKnode", 
[17:42:24.394]                             "SOCK0node"))) {
[17:42:24.394]                             sendCondition <<- function(cond) {
[17:42:24.394]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.394]                                 success = TRUE)
[17:42:24.394]                               parallel_sendData(master, data)
[17:42:24.394]                             }
[17:42:24.394]                             return(sendCondition)
[17:42:24.394]                           }
[17:42:24.394]                         }
[17:42:24.394]                         frame <- frame + 1L
[17:42:24.394]                         envir <- sys.frame(frame)
[17:42:24.394]                       }
[17:42:24.394]                     }
[17:42:24.394]                     sendCondition <<- function(cond) NULL
[17:42:24.394]                   }
[17:42:24.394]                 })
[17:42:24.394]                 withCallingHandlers({
[17:42:24.394]                   2
[17:42:24.394]                 }, immediateCondition = function(cond) {
[17:42:24.394]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.394]                   sendCondition(cond)
[17:42:24.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.394]                   {
[17:42:24.394]                     inherits <- base::inherits
[17:42:24.394]                     invokeRestart <- base::invokeRestart
[17:42:24.394]                     is.null <- base::is.null
[17:42:24.394]                     muffled <- FALSE
[17:42:24.394]                     if (inherits(cond, "message")) {
[17:42:24.394]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.394]                       if (muffled) 
[17:42:24.394]                         invokeRestart("muffleMessage")
[17:42:24.394]                     }
[17:42:24.394]                     else if (inherits(cond, "warning")) {
[17:42:24.394]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.394]                       if (muffled) 
[17:42:24.394]                         invokeRestart("muffleWarning")
[17:42:24.394]                     }
[17:42:24.394]                     else if (inherits(cond, "condition")) {
[17:42:24.394]                       if (!is.null(pattern)) {
[17:42:24.394]                         computeRestarts <- base::computeRestarts
[17:42:24.394]                         grepl <- base::grepl
[17:42:24.394]                         restarts <- computeRestarts(cond)
[17:42:24.394]                         for (restart in restarts) {
[17:42:24.394]                           name <- restart$name
[17:42:24.394]                           if (is.null(name)) 
[17:42:24.394]                             next
[17:42:24.394]                           if (!grepl(pattern, name)) 
[17:42:24.394]                             next
[17:42:24.394]                           invokeRestart(restart)
[17:42:24.394]                           muffled <- TRUE
[17:42:24.394]                           break
[17:42:24.394]                         }
[17:42:24.394]                       }
[17:42:24.394]                     }
[17:42:24.394]                     invisible(muffled)
[17:42:24.394]                   }
[17:42:24.394]                   muffleCondition(cond)
[17:42:24.394]                 })
[17:42:24.394]             }))
[17:42:24.394]             future::FutureResult(value = ...future.value$value, 
[17:42:24.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.394]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.394]                     ...future.globalenv.names))
[17:42:24.394]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.394]         }, condition = base::local({
[17:42:24.394]             c <- base::c
[17:42:24.394]             inherits <- base::inherits
[17:42:24.394]             invokeRestart <- base::invokeRestart
[17:42:24.394]             length <- base::length
[17:42:24.394]             list <- base::list
[17:42:24.394]             seq.int <- base::seq.int
[17:42:24.394]             signalCondition <- base::signalCondition
[17:42:24.394]             sys.calls <- base::sys.calls
[17:42:24.394]             `[[` <- base::`[[`
[17:42:24.394]             `+` <- base::`+`
[17:42:24.394]             `<<-` <- base::`<<-`
[17:42:24.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.394]                   3L)]
[17:42:24.394]             }
[17:42:24.394]             function(cond) {
[17:42:24.394]                 is_error <- inherits(cond, "error")
[17:42:24.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.394]                   NULL)
[17:42:24.394]                 if (is_error) {
[17:42:24.394]                   sessionInformation <- function() {
[17:42:24.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.394]                       search = base::search(), system = base::Sys.info())
[17:42:24.394]                   }
[17:42:24.394]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.394]                     cond$call), session = sessionInformation(), 
[17:42:24.394]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.394]                   signalCondition(cond)
[17:42:24.394]                 }
[17:42:24.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.394]                 "immediateCondition"))) {
[17:42:24.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.394]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.394]                   if (TRUE && !signal) {
[17:42:24.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.394]                     {
[17:42:24.394]                       inherits <- base::inherits
[17:42:24.394]                       invokeRestart <- base::invokeRestart
[17:42:24.394]                       is.null <- base::is.null
[17:42:24.394]                       muffled <- FALSE
[17:42:24.394]                       if (inherits(cond, "message")) {
[17:42:24.394]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.394]                         if (muffled) 
[17:42:24.394]                           invokeRestart("muffleMessage")
[17:42:24.394]                       }
[17:42:24.394]                       else if (inherits(cond, "warning")) {
[17:42:24.394]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.394]                         if (muffled) 
[17:42:24.394]                           invokeRestart("muffleWarning")
[17:42:24.394]                       }
[17:42:24.394]                       else if (inherits(cond, "condition")) {
[17:42:24.394]                         if (!is.null(pattern)) {
[17:42:24.394]                           computeRestarts <- base::computeRestarts
[17:42:24.394]                           grepl <- base::grepl
[17:42:24.394]                           restarts <- computeRestarts(cond)
[17:42:24.394]                           for (restart in restarts) {
[17:42:24.394]                             name <- restart$name
[17:42:24.394]                             if (is.null(name)) 
[17:42:24.394]                               next
[17:42:24.394]                             if (!grepl(pattern, name)) 
[17:42:24.394]                               next
[17:42:24.394]                             invokeRestart(restart)
[17:42:24.394]                             muffled <- TRUE
[17:42:24.394]                             break
[17:42:24.394]                           }
[17:42:24.394]                         }
[17:42:24.394]                       }
[17:42:24.394]                       invisible(muffled)
[17:42:24.394]                     }
[17:42:24.394]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.394]                   }
[17:42:24.394]                 }
[17:42:24.394]                 else {
[17:42:24.394]                   if (TRUE) {
[17:42:24.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.394]                     {
[17:42:24.394]                       inherits <- base::inherits
[17:42:24.394]                       invokeRestart <- base::invokeRestart
[17:42:24.394]                       is.null <- base::is.null
[17:42:24.394]                       muffled <- FALSE
[17:42:24.394]                       if (inherits(cond, "message")) {
[17:42:24.394]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.394]                         if (muffled) 
[17:42:24.394]                           invokeRestart("muffleMessage")
[17:42:24.394]                       }
[17:42:24.394]                       else if (inherits(cond, "warning")) {
[17:42:24.394]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.394]                         if (muffled) 
[17:42:24.394]                           invokeRestart("muffleWarning")
[17:42:24.394]                       }
[17:42:24.394]                       else if (inherits(cond, "condition")) {
[17:42:24.394]                         if (!is.null(pattern)) {
[17:42:24.394]                           computeRestarts <- base::computeRestarts
[17:42:24.394]                           grepl <- base::grepl
[17:42:24.394]                           restarts <- computeRestarts(cond)
[17:42:24.394]                           for (restart in restarts) {
[17:42:24.394]                             name <- restart$name
[17:42:24.394]                             if (is.null(name)) 
[17:42:24.394]                               next
[17:42:24.394]                             if (!grepl(pattern, name)) 
[17:42:24.394]                               next
[17:42:24.394]                             invokeRestart(restart)
[17:42:24.394]                             muffled <- TRUE
[17:42:24.394]                             break
[17:42:24.394]                           }
[17:42:24.394]                         }
[17:42:24.394]                       }
[17:42:24.394]                       invisible(muffled)
[17:42:24.394]                     }
[17:42:24.394]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.394]                   }
[17:42:24.394]                 }
[17:42:24.394]             }
[17:42:24.394]         }))
[17:42:24.394]     }, error = function(ex) {
[17:42:24.394]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.394]                 ...future.rng), started = ...future.startTime, 
[17:42:24.394]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.394]             version = "1.8"), class = "FutureResult")
[17:42:24.394]     }, finally = {
[17:42:24.394]         if (!identical(...future.workdir, getwd())) 
[17:42:24.394]             setwd(...future.workdir)
[17:42:24.394]         {
[17:42:24.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.394]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.394]             }
[17:42:24.394]             base::options(...future.oldOptions)
[17:42:24.394]             if (.Platform$OS.type == "windows") {
[17:42:24.394]                 old_names <- names(...future.oldEnvVars)
[17:42:24.394]                 envs <- base::Sys.getenv()
[17:42:24.394]                 names <- names(envs)
[17:42:24.394]                 common <- intersect(names, old_names)
[17:42:24.394]                 added <- setdiff(names, old_names)
[17:42:24.394]                 removed <- setdiff(old_names, names)
[17:42:24.394]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.394]                   envs[common]]
[17:42:24.394]                 NAMES <- toupper(changed)
[17:42:24.394]                 args <- list()
[17:42:24.394]                 for (kk in seq_along(NAMES)) {
[17:42:24.394]                   name <- changed[[kk]]
[17:42:24.394]                   NAME <- NAMES[[kk]]
[17:42:24.394]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.394]                     next
[17:42:24.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.394]                 }
[17:42:24.394]                 NAMES <- toupper(added)
[17:42:24.394]                 for (kk in seq_along(NAMES)) {
[17:42:24.394]                   name <- added[[kk]]
[17:42:24.394]                   NAME <- NAMES[[kk]]
[17:42:24.394]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.394]                     next
[17:42:24.394]                   args[[name]] <- ""
[17:42:24.394]                 }
[17:42:24.394]                 NAMES <- toupper(removed)
[17:42:24.394]                 for (kk in seq_along(NAMES)) {
[17:42:24.394]                   name <- removed[[kk]]
[17:42:24.394]                   NAME <- NAMES[[kk]]
[17:42:24.394]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.394]                     next
[17:42:24.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.394]                 }
[17:42:24.394]                 if (length(args) > 0) 
[17:42:24.394]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.394]             }
[17:42:24.394]             else {
[17:42:24.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.394]             }
[17:42:24.394]             {
[17:42:24.394]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.394]                   0L) {
[17:42:24.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.394]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.394]                   base::options(opts)
[17:42:24.394]                 }
[17:42:24.394]                 {
[17:42:24.394]                   {
[17:42:24.394]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.394]                     NULL
[17:42:24.394]                   }
[17:42:24.394]                   options(future.plan = NULL)
[17:42:24.394]                   if (is.na(NA_character_)) 
[17:42:24.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.394]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.394]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.394]                     envir = parent.frame()) 
[17:42:24.394]                   {
[17:42:24.394]                     if (is.function(workers)) 
[17:42:24.394]                       workers <- workers()
[17:42:24.394]                     workers <- structure(as.integer(workers), 
[17:42:24.394]                       class = class(workers))
[17:42:24.394]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.394]                       workers >= 1)
[17:42:24.394]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.394]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.394]                     }
[17:42:24.394]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.394]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.394]                       envir = envir)
[17:42:24.394]                     if (!future$lazy) 
[17:42:24.394]                       future <- run(future)
[17:42:24.394]                     invisible(future)
[17:42:24.394]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.394]                 }
[17:42:24.394]             }
[17:42:24.394]         }
[17:42:24.394]     })
[17:42:24.394]     if (TRUE) {
[17:42:24.394]         base::sink(type = "output", split = FALSE)
[17:42:24.394]         if (TRUE) {
[17:42:24.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.394]         }
[17:42:24.394]         else {
[17:42:24.394]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.394]         }
[17:42:24.394]         base::close(...future.stdout)
[17:42:24.394]         ...future.stdout <- NULL
[17:42:24.394]     }
[17:42:24.394]     ...future.result$conditions <- ...future.conditions
[17:42:24.394]     ...future.result$finished <- base::Sys.time()
[17:42:24.394]     ...future.result
[17:42:24.394] }
[17:42:24.397] MultisessionFuture started
[17:42:24.398] - Launch lazy future ... done
[17:42:24.398] run() for ‘MultisessionFuture’ ... done
[17:42:24.398] getGlobalsAndPackages() ...
[17:42:24.398] Searching for globals...
[17:42:24.398] 
[17:42:24.398] Searching for globals ... DONE
[17:42:24.398] - globals: [0] <none>
[17:42:24.399] getGlobalsAndPackages() ... DONE
[17:42:24.399] run() for ‘Future’ ...
[17:42:24.399] - state: ‘created’
[17:42:24.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.414] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.414]   - Field: ‘node’
[17:42:24.415]   - Field: ‘label’
[17:42:24.415]   - Field: ‘local’
[17:42:24.415]   - Field: ‘owner’
[17:42:24.415]   - Field: ‘envir’
[17:42:24.415]   - Field: ‘workers’
[17:42:24.415]   - Field: ‘packages’
[17:42:24.415]   - Field: ‘gc’
[17:42:24.415]   - Field: ‘conditions’
[17:42:24.415]   - Field: ‘persistent’
[17:42:24.415]   - Field: ‘expr’
[17:42:24.416]   - Field: ‘uuid’
[17:42:24.416]   - Field: ‘seed’
[17:42:24.416]   - Field: ‘version’
[17:42:24.416]   - Field: ‘result’
[17:42:24.416]   - Field: ‘asynchronous’
[17:42:24.416]   - Field: ‘calls’
[17:42:24.416]   - Field: ‘globals’
[17:42:24.416]   - Field: ‘stdout’
[17:42:24.416]   - Field: ‘earlySignal’
[17:42:24.416]   - Field: ‘lazy’
[17:42:24.417]   - Field: ‘state’
[17:42:24.417] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.417] - Launch lazy future ...
[17:42:24.417] Packages needed by the future expression (n = 0): <none>
[17:42:24.417] Packages needed by future strategies (n = 0): <none>
[17:42:24.418] {
[17:42:24.418]     {
[17:42:24.418]         {
[17:42:24.418]             ...future.startTime <- base::Sys.time()
[17:42:24.418]             {
[17:42:24.418]                 {
[17:42:24.418]                   {
[17:42:24.418]                     {
[17:42:24.418]                       base::local({
[17:42:24.418]                         has_future <- base::requireNamespace("future", 
[17:42:24.418]                           quietly = TRUE)
[17:42:24.418]                         if (has_future) {
[17:42:24.418]                           ns <- base::getNamespace("future")
[17:42:24.418]                           version <- ns[[".package"]][["version"]]
[17:42:24.418]                           if (is.null(version)) 
[17:42:24.418]                             version <- utils::packageVersion("future")
[17:42:24.418]                         }
[17:42:24.418]                         else {
[17:42:24.418]                           version <- NULL
[17:42:24.418]                         }
[17:42:24.418]                         if (!has_future || version < "1.8.0") {
[17:42:24.418]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.418]                             "", base::R.version$version.string), 
[17:42:24.418]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.418]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.418]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.418]                               "release", "version")], collapse = " "), 
[17:42:24.418]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.418]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.418]                             info)
[17:42:24.418]                           info <- base::paste(info, collapse = "; ")
[17:42:24.418]                           if (!has_future) {
[17:42:24.418]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.418]                               info)
[17:42:24.418]                           }
[17:42:24.418]                           else {
[17:42:24.418]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.418]                               info, version)
[17:42:24.418]                           }
[17:42:24.418]                           base::stop(msg)
[17:42:24.418]                         }
[17:42:24.418]                       })
[17:42:24.418]                     }
[17:42:24.418]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.418]                     base::options(mc.cores = 1L)
[17:42:24.418]                   }
[17:42:24.418]                   options(future.plan = NULL)
[17:42:24.418]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.418]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.418]                 }
[17:42:24.418]                 ...future.workdir <- getwd()
[17:42:24.418]             }
[17:42:24.418]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.418]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.418]         }
[17:42:24.418]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.418]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.418]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.418]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.418]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.418]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.418]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.418]             base::names(...future.oldOptions))
[17:42:24.418]     }
[17:42:24.418]     if (FALSE) {
[17:42:24.418]     }
[17:42:24.418]     else {
[17:42:24.418]         if (TRUE) {
[17:42:24.418]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.418]                 open = "w")
[17:42:24.418]         }
[17:42:24.418]         else {
[17:42:24.418]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.418]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.418]         }
[17:42:24.418]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.418]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.418]             base::sink(type = "output", split = FALSE)
[17:42:24.418]             base::close(...future.stdout)
[17:42:24.418]         }, add = TRUE)
[17:42:24.418]     }
[17:42:24.418]     ...future.frame <- base::sys.nframe()
[17:42:24.418]     ...future.conditions <- base::list()
[17:42:24.418]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.418]     if (FALSE) {
[17:42:24.418]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.418]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.418]     }
[17:42:24.418]     ...future.result <- base::tryCatch({
[17:42:24.418]         base::withCallingHandlers({
[17:42:24.418]             ...future.value <- base::withVisible(base::local({
[17:42:24.418]                 ...future.makeSendCondition <- local({
[17:42:24.418]                   sendCondition <- NULL
[17:42:24.418]                   function(frame = 1L) {
[17:42:24.418]                     if (is.function(sendCondition)) 
[17:42:24.418]                       return(sendCondition)
[17:42:24.418]                     ns <- getNamespace("parallel")
[17:42:24.418]                     if (exists("sendData", mode = "function", 
[17:42:24.418]                       envir = ns)) {
[17:42:24.418]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.418]                         envir = ns)
[17:42:24.418]                       envir <- sys.frame(frame)
[17:42:24.418]                       master <- NULL
[17:42:24.418]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.418]                         !identical(envir, emptyenv())) {
[17:42:24.418]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.418]                           inherits = FALSE)) {
[17:42:24.418]                           master <- get("master", mode = "list", 
[17:42:24.418]                             envir = envir, inherits = FALSE)
[17:42:24.418]                           if (inherits(master, c("SOCKnode", 
[17:42:24.418]                             "SOCK0node"))) {
[17:42:24.418]                             sendCondition <<- function(cond) {
[17:42:24.418]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.418]                                 success = TRUE)
[17:42:24.418]                               parallel_sendData(master, data)
[17:42:24.418]                             }
[17:42:24.418]                             return(sendCondition)
[17:42:24.418]                           }
[17:42:24.418]                         }
[17:42:24.418]                         frame <- frame + 1L
[17:42:24.418]                         envir <- sys.frame(frame)
[17:42:24.418]                       }
[17:42:24.418]                     }
[17:42:24.418]                     sendCondition <<- function(cond) NULL
[17:42:24.418]                   }
[17:42:24.418]                 })
[17:42:24.418]                 withCallingHandlers({
[17:42:24.418]                   NULL
[17:42:24.418]                 }, immediateCondition = function(cond) {
[17:42:24.418]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.418]                   sendCondition(cond)
[17:42:24.418]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.418]                   {
[17:42:24.418]                     inherits <- base::inherits
[17:42:24.418]                     invokeRestart <- base::invokeRestart
[17:42:24.418]                     is.null <- base::is.null
[17:42:24.418]                     muffled <- FALSE
[17:42:24.418]                     if (inherits(cond, "message")) {
[17:42:24.418]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.418]                       if (muffled) 
[17:42:24.418]                         invokeRestart("muffleMessage")
[17:42:24.418]                     }
[17:42:24.418]                     else if (inherits(cond, "warning")) {
[17:42:24.418]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.418]                       if (muffled) 
[17:42:24.418]                         invokeRestart("muffleWarning")
[17:42:24.418]                     }
[17:42:24.418]                     else if (inherits(cond, "condition")) {
[17:42:24.418]                       if (!is.null(pattern)) {
[17:42:24.418]                         computeRestarts <- base::computeRestarts
[17:42:24.418]                         grepl <- base::grepl
[17:42:24.418]                         restarts <- computeRestarts(cond)
[17:42:24.418]                         for (restart in restarts) {
[17:42:24.418]                           name <- restart$name
[17:42:24.418]                           if (is.null(name)) 
[17:42:24.418]                             next
[17:42:24.418]                           if (!grepl(pattern, name)) 
[17:42:24.418]                             next
[17:42:24.418]                           invokeRestart(restart)
[17:42:24.418]                           muffled <- TRUE
[17:42:24.418]                           break
[17:42:24.418]                         }
[17:42:24.418]                       }
[17:42:24.418]                     }
[17:42:24.418]                     invisible(muffled)
[17:42:24.418]                   }
[17:42:24.418]                   muffleCondition(cond)
[17:42:24.418]                 })
[17:42:24.418]             }))
[17:42:24.418]             future::FutureResult(value = ...future.value$value, 
[17:42:24.418]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.418]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.418]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.418]                     ...future.globalenv.names))
[17:42:24.418]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.418]         }, condition = base::local({
[17:42:24.418]             c <- base::c
[17:42:24.418]             inherits <- base::inherits
[17:42:24.418]             invokeRestart <- base::invokeRestart
[17:42:24.418]             length <- base::length
[17:42:24.418]             list <- base::list
[17:42:24.418]             seq.int <- base::seq.int
[17:42:24.418]             signalCondition <- base::signalCondition
[17:42:24.418]             sys.calls <- base::sys.calls
[17:42:24.418]             `[[` <- base::`[[`
[17:42:24.418]             `+` <- base::`+`
[17:42:24.418]             `<<-` <- base::`<<-`
[17:42:24.418]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.418]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.418]                   3L)]
[17:42:24.418]             }
[17:42:24.418]             function(cond) {
[17:42:24.418]                 is_error <- inherits(cond, "error")
[17:42:24.418]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.418]                   NULL)
[17:42:24.418]                 if (is_error) {
[17:42:24.418]                   sessionInformation <- function() {
[17:42:24.418]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.418]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.418]                       search = base::search(), system = base::Sys.info())
[17:42:24.418]                   }
[17:42:24.418]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.418]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.418]                     cond$call), session = sessionInformation(), 
[17:42:24.418]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.418]                   signalCondition(cond)
[17:42:24.418]                 }
[17:42:24.418]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.418]                 "immediateCondition"))) {
[17:42:24.418]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.418]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.418]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.418]                   if (TRUE && !signal) {
[17:42:24.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.418]                     {
[17:42:24.418]                       inherits <- base::inherits
[17:42:24.418]                       invokeRestart <- base::invokeRestart
[17:42:24.418]                       is.null <- base::is.null
[17:42:24.418]                       muffled <- FALSE
[17:42:24.418]                       if (inherits(cond, "message")) {
[17:42:24.418]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.418]                         if (muffled) 
[17:42:24.418]                           invokeRestart("muffleMessage")
[17:42:24.418]                       }
[17:42:24.418]                       else if (inherits(cond, "warning")) {
[17:42:24.418]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.418]                         if (muffled) 
[17:42:24.418]                           invokeRestart("muffleWarning")
[17:42:24.418]                       }
[17:42:24.418]                       else if (inherits(cond, "condition")) {
[17:42:24.418]                         if (!is.null(pattern)) {
[17:42:24.418]                           computeRestarts <- base::computeRestarts
[17:42:24.418]                           grepl <- base::grepl
[17:42:24.418]                           restarts <- computeRestarts(cond)
[17:42:24.418]                           for (restart in restarts) {
[17:42:24.418]                             name <- restart$name
[17:42:24.418]                             if (is.null(name)) 
[17:42:24.418]                               next
[17:42:24.418]                             if (!grepl(pattern, name)) 
[17:42:24.418]                               next
[17:42:24.418]                             invokeRestart(restart)
[17:42:24.418]                             muffled <- TRUE
[17:42:24.418]                             break
[17:42:24.418]                           }
[17:42:24.418]                         }
[17:42:24.418]                       }
[17:42:24.418]                       invisible(muffled)
[17:42:24.418]                     }
[17:42:24.418]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.418]                   }
[17:42:24.418]                 }
[17:42:24.418]                 else {
[17:42:24.418]                   if (TRUE) {
[17:42:24.418]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.418]                     {
[17:42:24.418]                       inherits <- base::inherits
[17:42:24.418]                       invokeRestart <- base::invokeRestart
[17:42:24.418]                       is.null <- base::is.null
[17:42:24.418]                       muffled <- FALSE
[17:42:24.418]                       if (inherits(cond, "message")) {
[17:42:24.418]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.418]                         if (muffled) 
[17:42:24.418]                           invokeRestart("muffleMessage")
[17:42:24.418]                       }
[17:42:24.418]                       else if (inherits(cond, "warning")) {
[17:42:24.418]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.418]                         if (muffled) 
[17:42:24.418]                           invokeRestart("muffleWarning")
[17:42:24.418]                       }
[17:42:24.418]                       else if (inherits(cond, "condition")) {
[17:42:24.418]                         if (!is.null(pattern)) {
[17:42:24.418]                           computeRestarts <- base::computeRestarts
[17:42:24.418]                           grepl <- base::grepl
[17:42:24.418]                           restarts <- computeRestarts(cond)
[17:42:24.418]                           for (restart in restarts) {
[17:42:24.418]                             name <- restart$name
[17:42:24.418]                             if (is.null(name)) 
[17:42:24.418]                               next
[17:42:24.418]                             if (!grepl(pattern, name)) 
[17:42:24.418]                               next
[17:42:24.418]                             invokeRestart(restart)
[17:42:24.418]                             muffled <- TRUE
[17:42:24.418]                             break
[17:42:24.418]                           }
[17:42:24.418]                         }
[17:42:24.418]                       }
[17:42:24.418]                       invisible(muffled)
[17:42:24.418]                     }
[17:42:24.418]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.418]                   }
[17:42:24.418]                 }
[17:42:24.418]             }
[17:42:24.418]         }))
[17:42:24.418]     }, error = function(ex) {
[17:42:24.418]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.418]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.418]                 ...future.rng), started = ...future.startTime, 
[17:42:24.418]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.418]             version = "1.8"), class = "FutureResult")
[17:42:24.418]     }, finally = {
[17:42:24.418]         if (!identical(...future.workdir, getwd())) 
[17:42:24.418]             setwd(...future.workdir)
[17:42:24.418]         {
[17:42:24.418]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.418]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.418]             }
[17:42:24.418]             base::options(...future.oldOptions)
[17:42:24.418]             if (.Platform$OS.type == "windows") {
[17:42:24.418]                 old_names <- names(...future.oldEnvVars)
[17:42:24.418]                 envs <- base::Sys.getenv()
[17:42:24.418]                 names <- names(envs)
[17:42:24.418]                 common <- intersect(names, old_names)
[17:42:24.418]                 added <- setdiff(names, old_names)
[17:42:24.418]                 removed <- setdiff(old_names, names)
[17:42:24.418]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.418]                   envs[common]]
[17:42:24.418]                 NAMES <- toupper(changed)
[17:42:24.418]                 args <- list()
[17:42:24.418]                 for (kk in seq_along(NAMES)) {
[17:42:24.418]                   name <- changed[[kk]]
[17:42:24.418]                   NAME <- NAMES[[kk]]
[17:42:24.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.418]                     next
[17:42:24.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.418]                 }
[17:42:24.418]                 NAMES <- toupper(added)
[17:42:24.418]                 for (kk in seq_along(NAMES)) {
[17:42:24.418]                   name <- added[[kk]]
[17:42:24.418]                   NAME <- NAMES[[kk]]
[17:42:24.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.418]                     next
[17:42:24.418]                   args[[name]] <- ""
[17:42:24.418]                 }
[17:42:24.418]                 NAMES <- toupper(removed)
[17:42:24.418]                 for (kk in seq_along(NAMES)) {
[17:42:24.418]                   name <- removed[[kk]]
[17:42:24.418]                   NAME <- NAMES[[kk]]
[17:42:24.418]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.418]                     next
[17:42:24.418]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.418]                 }
[17:42:24.418]                 if (length(args) > 0) 
[17:42:24.418]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.418]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.418]             }
[17:42:24.418]             else {
[17:42:24.418]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.418]             }
[17:42:24.418]             {
[17:42:24.418]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.418]                   0L) {
[17:42:24.418]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.418]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.418]                   base::options(opts)
[17:42:24.418]                 }
[17:42:24.418]                 {
[17:42:24.418]                   {
[17:42:24.418]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.418]                     NULL
[17:42:24.418]                   }
[17:42:24.418]                   options(future.plan = NULL)
[17:42:24.418]                   if (is.na(NA_character_)) 
[17:42:24.418]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.418]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.418]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.418]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.418]                     envir = parent.frame()) 
[17:42:24.418]                   {
[17:42:24.418]                     if (is.function(workers)) 
[17:42:24.418]                       workers <- workers()
[17:42:24.418]                     workers <- structure(as.integer(workers), 
[17:42:24.418]                       class = class(workers))
[17:42:24.418]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.418]                       workers >= 1)
[17:42:24.418]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.418]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.418]                     }
[17:42:24.418]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.418]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.418]                       envir = envir)
[17:42:24.418]                     if (!future$lazy) 
[17:42:24.418]                       future <- run(future)
[17:42:24.418]                     invisible(future)
[17:42:24.418]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.418]                 }
[17:42:24.418]             }
[17:42:24.418]         }
[17:42:24.418]     })
[17:42:24.418]     if (TRUE) {
[17:42:24.418]         base::sink(type = "output", split = FALSE)
[17:42:24.418]         if (TRUE) {
[17:42:24.418]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.418]         }
[17:42:24.418]         else {
[17:42:24.418]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.418]         }
[17:42:24.418]         base::close(...future.stdout)
[17:42:24.418]         ...future.stdout <- NULL
[17:42:24.418]     }
[17:42:24.418]     ...future.result$conditions <- ...future.conditions
[17:42:24.418]     ...future.result$finished <- base::Sys.time()
[17:42:24.418]     ...future.result
[17:42:24.418] }
[17:42:24.421] MultisessionFuture started
[17:42:24.422] - Launch lazy future ... done
[17:42:24.422] run() for ‘MultisessionFuture’ ... done
[17:42:24.422] getGlobalsAndPackages() ...
[17:42:24.422] Searching for globals...
[17:42:24.423] - globals found: [1] ‘{’
[17:42:24.423] Searching for globals ... DONE
[17:42:24.423] Resolving globals: FALSE
[17:42:24.423] 
[17:42:24.424] 
[17:42:24.424] getGlobalsAndPackages() ... DONE
[17:42:24.424] run() for ‘Future’ ...
[17:42:24.424] - state: ‘created’
[17:42:24.424] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.439] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.439]   - Field: ‘node’
[17:42:24.439]   - Field: ‘label’
[17:42:24.440]   - Field: ‘local’
[17:42:24.440]   - Field: ‘owner’
[17:42:24.440]   - Field: ‘envir’
[17:42:24.440]   - Field: ‘workers’
[17:42:24.440]   - Field: ‘packages’
[17:42:24.440]   - Field: ‘gc’
[17:42:24.440]   - Field: ‘conditions’
[17:42:24.440]   - Field: ‘persistent’
[17:42:24.440]   - Field: ‘expr’
[17:42:24.440]   - Field: ‘uuid’
[17:42:24.440]   - Field: ‘seed’
[17:42:24.441]   - Field: ‘version’
[17:42:24.441]   - Field: ‘result’
[17:42:24.441]   - Field: ‘asynchronous’
[17:42:24.441]   - Field: ‘calls’
[17:42:24.441]   - Field: ‘globals’
[17:42:24.441]   - Field: ‘stdout’
[17:42:24.441]   - Field: ‘earlySignal’
[17:42:24.441]   - Field: ‘lazy’
[17:42:24.441]   - Field: ‘state’
[17:42:24.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.442] - Launch lazy future ...
[17:42:24.442] Packages needed by the future expression (n = 0): <none>
[17:42:24.442] Packages needed by future strategies (n = 0): <none>
[17:42:24.443] {
[17:42:24.443]     {
[17:42:24.443]         {
[17:42:24.443]             ...future.startTime <- base::Sys.time()
[17:42:24.443]             {
[17:42:24.443]                 {
[17:42:24.443]                   {
[17:42:24.443]                     {
[17:42:24.443]                       base::local({
[17:42:24.443]                         has_future <- base::requireNamespace("future", 
[17:42:24.443]                           quietly = TRUE)
[17:42:24.443]                         if (has_future) {
[17:42:24.443]                           ns <- base::getNamespace("future")
[17:42:24.443]                           version <- ns[[".package"]][["version"]]
[17:42:24.443]                           if (is.null(version)) 
[17:42:24.443]                             version <- utils::packageVersion("future")
[17:42:24.443]                         }
[17:42:24.443]                         else {
[17:42:24.443]                           version <- NULL
[17:42:24.443]                         }
[17:42:24.443]                         if (!has_future || version < "1.8.0") {
[17:42:24.443]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.443]                             "", base::R.version$version.string), 
[17:42:24.443]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.443]                               "release", "version")], collapse = " "), 
[17:42:24.443]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.443]                             info)
[17:42:24.443]                           info <- base::paste(info, collapse = "; ")
[17:42:24.443]                           if (!has_future) {
[17:42:24.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.443]                               info)
[17:42:24.443]                           }
[17:42:24.443]                           else {
[17:42:24.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.443]                               info, version)
[17:42:24.443]                           }
[17:42:24.443]                           base::stop(msg)
[17:42:24.443]                         }
[17:42:24.443]                       })
[17:42:24.443]                     }
[17:42:24.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.443]                     base::options(mc.cores = 1L)
[17:42:24.443]                   }
[17:42:24.443]                   options(future.plan = NULL)
[17:42:24.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.443]                 }
[17:42:24.443]                 ...future.workdir <- getwd()
[17:42:24.443]             }
[17:42:24.443]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.443]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.443]         }
[17:42:24.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.443]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.443]             base::names(...future.oldOptions))
[17:42:24.443]     }
[17:42:24.443]     if (FALSE) {
[17:42:24.443]     }
[17:42:24.443]     else {
[17:42:24.443]         if (TRUE) {
[17:42:24.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.443]                 open = "w")
[17:42:24.443]         }
[17:42:24.443]         else {
[17:42:24.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.443]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.443]         }
[17:42:24.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.443]             base::sink(type = "output", split = FALSE)
[17:42:24.443]             base::close(...future.stdout)
[17:42:24.443]         }, add = TRUE)
[17:42:24.443]     }
[17:42:24.443]     ...future.frame <- base::sys.nframe()
[17:42:24.443]     ...future.conditions <- base::list()
[17:42:24.443]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.443]     if (FALSE) {
[17:42:24.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.443]     }
[17:42:24.443]     ...future.result <- base::tryCatch({
[17:42:24.443]         base::withCallingHandlers({
[17:42:24.443]             ...future.value <- base::withVisible(base::local({
[17:42:24.443]                 ...future.makeSendCondition <- local({
[17:42:24.443]                   sendCondition <- NULL
[17:42:24.443]                   function(frame = 1L) {
[17:42:24.443]                     if (is.function(sendCondition)) 
[17:42:24.443]                       return(sendCondition)
[17:42:24.443]                     ns <- getNamespace("parallel")
[17:42:24.443]                     if (exists("sendData", mode = "function", 
[17:42:24.443]                       envir = ns)) {
[17:42:24.443]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.443]                         envir = ns)
[17:42:24.443]                       envir <- sys.frame(frame)
[17:42:24.443]                       master <- NULL
[17:42:24.443]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.443]                         !identical(envir, emptyenv())) {
[17:42:24.443]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.443]                           inherits = FALSE)) {
[17:42:24.443]                           master <- get("master", mode = "list", 
[17:42:24.443]                             envir = envir, inherits = FALSE)
[17:42:24.443]                           if (inherits(master, c("SOCKnode", 
[17:42:24.443]                             "SOCK0node"))) {
[17:42:24.443]                             sendCondition <<- function(cond) {
[17:42:24.443]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.443]                                 success = TRUE)
[17:42:24.443]                               parallel_sendData(master, data)
[17:42:24.443]                             }
[17:42:24.443]                             return(sendCondition)
[17:42:24.443]                           }
[17:42:24.443]                         }
[17:42:24.443]                         frame <- frame + 1L
[17:42:24.443]                         envir <- sys.frame(frame)
[17:42:24.443]                       }
[17:42:24.443]                     }
[17:42:24.443]                     sendCondition <<- function(cond) NULL
[17:42:24.443]                   }
[17:42:24.443]                 })
[17:42:24.443]                 withCallingHandlers({
[17:42:24.443]                   {
[17:42:24.443]                     4
[17:42:24.443]                   }
[17:42:24.443]                 }, immediateCondition = function(cond) {
[17:42:24.443]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.443]                   sendCondition(cond)
[17:42:24.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.443]                   {
[17:42:24.443]                     inherits <- base::inherits
[17:42:24.443]                     invokeRestart <- base::invokeRestart
[17:42:24.443]                     is.null <- base::is.null
[17:42:24.443]                     muffled <- FALSE
[17:42:24.443]                     if (inherits(cond, "message")) {
[17:42:24.443]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.443]                       if (muffled) 
[17:42:24.443]                         invokeRestart("muffleMessage")
[17:42:24.443]                     }
[17:42:24.443]                     else if (inherits(cond, "warning")) {
[17:42:24.443]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.443]                       if (muffled) 
[17:42:24.443]                         invokeRestart("muffleWarning")
[17:42:24.443]                     }
[17:42:24.443]                     else if (inherits(cond, "condition")) {
[17:42:24.443]                       if (!is.null(pattern)) {
[17:42:24.443]                         computeRestarts <- base::computeRestarts
[17:42:24.443]                         grepl <- base::grepl
[17:42:24.443]                         restarts <- computeRestarts(cond)
[17:42:24.443]                         for (restart in restarts) {
[17:42:24.443]                           name <- restart$name
[17:42:24.443]                           if (is.null(name)) 
[17:42:24.443]                             next
[17:42:24.443]                           if (!grepl(pattern, name)) 
[17:42:24.443]                             next
[17:42:24.443]                           invokeRestart(restart)
[17:42:24.443]                           muffled <- TRUE
[17:42:24.443]                           break
[17:42:24.443]                         }
[17:42:24.443]                       }
[17:42:24.443]                     }
[17:42:24.443]                     invisible(muffled)
[17:42:24.443]                   }
[17:42:24.443]                   muffleCondition(cond)
[17:42:24.443]                 })
[17:42:24.443]             }))
[17:42:24.443]             future::FutureResult(value = ...future.value$value, 
[17:42:24.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.443]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.443]                     ...future.globalenv.names))
[17:42:24.443]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.443]         }, condition = base::local({
[17:42:24.443]             c <- base::c
[17:42:24.443]             inherits <- base::inherits
[17:42:24.443]             invokeRestart <- base::invokeRestart
[17:42:24.443]             length <- base::length
[17:42:24.443]             list <- base::list
[17:42:24.443]             seq.int <- base::seq.int
[17:42:24.443]             signalCondition <- base::signalCondition
[17:42:24.443]             sys.calls <- base::sys.calls
[17:42:24.443]             `[[` <- base::`[[`
[17:42:24.443]             `+` <- base::`+`
[17:42:24.443]             `<<-` <- base::`<<-`
[17:42:24.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.443]                   3L)]
[17:42:24.443]             }
[17:42:24.443]             function(cond) {
[17:42:24.443]                 is_error <- inherits(cond, "error")
[17:42:24.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.443]                   NULL)
[17:42:24.443]                 if (is_error) {
[17:42:24.443]                   sessionInformation <- function() {
[17:42:24.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.443]                       search = base::search(), system = base::Sys.info())
[17:42:24.443]                   }
[17:42:24.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.443]                     cond$call), session = sessionInformation(), 
[17:42:24.443]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.443]                   signalCondition(cond)
[17:42:24.443]                 }
[17:42:24.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.443]                 "immediateCondition"))) {
[17:42:24.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.443]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.443]                   if (TRUE && !signal) {
[17:42:24.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.443]                     {
[17:42:24.443]                       inherits <- base::inherits
[17:42:24.443]                       invokeRestart <- base::invokeRestart
[17:42:24.443]                       is.null <- base::is.null
[17:42:24.443]                       muffled <- FALSE
[17:42:24.443]                       if (inherits(cond, "message")) {
[17:42:24.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.443]                         if (muffled) 
[17:42:24.443]                           invokeRestart("muffleMessage")
[17:42:24.443]                       }
[17:42:24.443]                       else if (inherits(cond, "warning")) {
[17:42:24.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.443]                         if (muffled) 
[17:42:24.443]                           invokeRestart("muffleWarning")
[17:42:24.443]                       }
[17:42:24.443]                       else if (inherits(cond, "condition")) {
[17:42:24.443]                         if (!is.null(pattern)) {
[17:42:24.443]                           computeRestarts <- base::computeRestarts
[17:42:24.443]                           grepl <- base::grepl
[17:42:24.443]                           restarts <- computeRestarts(cond)
[17:42:24.443]                           for (restart in restarts) {
[17:42:24.443]                             name <- restart$name
[17:42:24.443]                             if (is.null(name)) 
[17:42:24.443]                               next
[17:42:24.443]                             if (!grepl(pattern, name)) 
[17:42:24.443]                               next
[17:42:24.443]                             invokeRestart(restart)
[17:42:24.443]                             muffled <- TRUE
[17:42:24.443]                             break
[17:42:24.443]                           }
[17:42:24.443]                         }
[17:42:24.443]                       }
[17:42:24.443]                       invisible(muffled)
[17:42:24.443]                     }
[17:42:24.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.443]                   }
[17:42:24.443]                 }
[17:42:24.443]                 else {
[17:42:24.443]                   if (TRUE) {
[17:42:24.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.443]                     {
[17:42:24.443]                       inherits <- base::inherits
[17:42:24.443]                       invokeRestart <- base::invokeRestart
[17:42:24.443]                       is.null <- base::is.null
[17:42:24.443]                       muffled <- FALSE
[17:42:24.443]                       if (inherits(cond, "message")) {
[17:42:24.443]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.443]                         if (muffled) 
[17:42:24.443]                           invokeRestart("muffleMessage")
[17:42:24.443]                       }
[17:42:24.443]                       else if (inherits(cond, "warning")) {
[17:42:24.443]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.443]                         if (muffled) 
[17:42:24.443]                           invokeRestart("muffleWarning")
[17:42:24.443]                       }
[17:42:24.443]                       else if (inherits(cond, "condition")) {
[17:42:24.443]                         if (!is.null(pattern)) {
[17:42:24.443]                           computeRestarts <- base::computeRestarts
[17:42:24.443]                           grepl <- base::grepl
[17:42:24.443]                           restarts <- computeRestarts(cond)
[17:42:24.443]                           for (restart in restarts) {
[17:42:24.443]                             name <- restart$name
[17:42:24.443]                             if (is.null(name)) 
[17:42:24.443]                               next
[17:42:24.443]                             if (!grepl(pattern, name)) 
[17:42:24.443]                               next
[17:42:24.443]                             invokeRestart(restart)
[17:42:24.443]                             muffled <- TRUE
[17:42:24.443]                             break
[17:42:24.443]                           }
[17:42:24.443]                         }
[17:42:24.443]                       }
[17:42:24.443]                       invisible(muffled)
[17:42:24.443]                     }
[17:42:24.443]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.443]                   }
[17:42:24.443]                 }
[17:42:24.443]             }
[17:42:24.443]         }))
[17:42:24.443]     }, error = function(ex) {
[17:42:24.443]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.443]                 ...future.rng), started = ...future.startTime, 
[17:42:24.443]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.443]             version = "1.8"), class = "FutureResult")
[17:42:24.443]     }, finally = {
[17:42:24.443]         if (!identical(...future.workdir, getwd())) 
[17:42:24.443]             setwd(...future.workdir)
[17:42:24.443]         {
[17:42:24.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.443]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.443]             }
[17:42:24.443]             base::options(...future.oldOptions)
[17:42:24.443]             if (.Platform$OS.type == "windows") {
[17:42:24.443]                 old_names <- names(...future.oldEnvVars)
[17:42:24.443]                 envs <- base::Sys.getenv()
[17:42:24.443]                 names <- names(envs)
[17:42:24.443]                 common <- intersect(names, old_names)
[17:42:24.443]                 added <- setdiff(names, old_names)
[17:42:24.443]                 removed <- setdiff(old_names, names)
[17:42:24.443]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.443]                   envs[common]]
[17:42:24.443]                 NAMES <- toupper(changed)
[17:42:24.443]                 args <- list()
[17:42:24.443]                 for (kk in seq_along(NAMES)) {
[17:42:24.443]                   name <- changed[[kk]]
[17:42:24.443]                   NAME <- NAMES[[kk]]
[17:42:24.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.443]                     next
[17:42:24.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.443]                 }
[17:42:24.443]                 NAMES <- toupper(added)
[17:42:24.443]                 for (kk in seq_along(NAMES)) {
[17:42:24.443]                   name <- added[[kk]]
[17:42:24.443]                   NAME <- NAMES[[kk]]
[17:42:24.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.443]                     next
[17:42:24.443]                   args[[name]] <- ""
[17:42:24.443]                 }
[17:42:24.443]                 NAMES <- toupper(removed)
[17:42:24.443]                 for (kk in seq_along(NAMES)) {
[17:42:24.443]                   name <- removed[[kk]]
[17:42:24.443]                   NAME <- NAMES[[kk]]
[17:42:24.443]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.443]                     next
[17:42:24.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.443]                 }
[17:42:24.443]                 if (length(args) > 0) 
[17:42:24.443]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.443]             }
[17:42:24.443]             else {
[17:42:24.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.443]             }
[17:42:24.443]             {
[17:42:24.443]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.443]                   0L) {
[17:42:24.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.443]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.443]                   base::options(opts)
[17:42:24.443]                 }
[17:42:24.443]                 {
[17:42:24.443]                   {
[17:42:24.443]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.443]                     NULL
[17:42:24.443]                   }
[17:42:24.443]                   options(future.plan = NULL)
[17:42:24.443]                   if (is.na(NA_character_)) 
[17:42:24.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.443]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.443]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.443]                     envir = parent.frame()) 
[17:42:24.443]                   {
[17:42:24.443]                     if (is.function(workers)) 
[17:42:24.443]                       workers <- workers()
[17:42:24.443]                     workers <- structure(as.integer(workers), 
[17:42:24.443]                       class = class(workers))
[17:42:24.443]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.443]                       workers >= 1)
[17:42:24.443]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.443]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.443]                     }
[17:42:24.443]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.443]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.443]                       envir = envir)
[17:42:24.443]                     if (!future$lazy) 
[17:42:24.443]                       future <- run(future)
[17:42:24.443]                     invisible(future)
[17:42:24.443]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.443]                 }
[17:42:24.443]             }
[17:42:24.443]         }
[17:42:24.443]     })
[17:42:24.443]     if (TRUE) {
[17:42:24.443]         base::sink(type = "output", split = FALSE)
[17:42:24.443]         if (TRUE) {
[17:42:24.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.443]         }
[17:42:24.443]         else {
[17:42:24.443]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.443]         }
[17:42:24.443]         base::close(...future.stdout)
[17:42:24.443]         ...future.stdout <- NULL
[17:42:24.443]     }
[17:42:24.443]     ...future.result$conditions <- ...future.conditions
[17:42:24.443]     ...future.result$finished <- base::Sys.time()
[17:42:24.443]     ...future.result
[17:42:24.443] }
[17:42:24.445] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:24.456] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.456] - Validating connection of MultisessionFuture
[17:42:24.456] - received message: FutureResult
[17:42:24.456] - Received FutureResult
[17:42:24.456] - Erased future from FutureRegistry
[17:42:24.456] result() for ClusterFuture ...
[17:42:24.457] - result already collected: FutureResult
[17:42:24.457] result() for ClusterFuture ... done
[17:42:24.457] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.457] result() for ClusterFuture ...
[17:42:24.457] - result already collected: FutureResult
[17:42:24.457] result() for ClusterFuture ... done
[17:42:24.457] result() for ClusterFuture ...
[17:42:24.457] - result already collected: FutureResult
[17:42:24.457] result() for ClusterFuture ... done
[17:42:24.458] MultisessionFuture started
[17:42:24.458] - Launch lazy future ... done
[17:42:24.458] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef9f35cf0> 
Classes 'listenv', 'environment' <environment: 0x55bef8ba5190> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[17:42:24.468] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.468] - Validating connection of MultisessionFuture
[17:42:24.468] - received message: FutureResult
[17:42:24.468] - Received FutureResult
[17:42:24.468] - Erased future from FutureRegistry
[17:42:24.468] result() for ClusterFuture ...
[17:42:24.468] - result already collected: FutureResult
[17:42:24.469] result() for ClusterFuture ... done
[17:42:24.469] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:24.482] resolve() on list environment ...
[17:42:24.482]  recursive: 0
[17:42:24.484]  length: 6
[17:42:24.484]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:24.484] signalConditionsASAP(numeric, pos=1) ...
[17:42:24.484] - nx: 6
[17:42:24.484] - relay: TRUE
[17:42:24.484] - stdout: TRUE
[17:42:24.484] - signal: TRUE
[17:42:24.484] - resignal: FALSE
[17:42:24.485] - force: TRUE
[17:42:24.485] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.485] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.485]  - until=2
[17:42:24.485]  - relaying element #2
[17:42:24.485] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.485] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.485] signalConditionsASAP(NULL, pos=1) ... done
[17:42:24.486]  length: 5 (resolved future 1)
[17:42:24.486] Future #2
[17:42:24.486] result() for ClusterFuture ...
[17:42:24.486] - result already collected: FutureResult
[17:42:24.486] result() for ClusterFuture ... done
[17:42:24.486] result() for ClusterFuture ...
[17:42:24.486] - result already collected: FutureResult
[17:42:24.486] result() for ClusterFuture ... done
[17:42:24.487] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:24.487] - nx: 6
[17:42:24.487] - relay: TRUE
[17:42:24.487] - stdout: TRUE
[17:42:24.487] - signal: TRUE
[17:42:24.487] - resignal: FALSE
[17:42:24.487] - force: TRUE
[17:42:24.487] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.488] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.488]  - until=2
[17:42:24.488]  - relaying element #2
[17:42:24.488] result() for ClusterFuture ...
[17:42:24.488] - result already collected: FutureResult
[17:42:24.488] result() for ClusterFuture ... done
[17:42:24.488] result() for ClusterFuture ...
[17:42:24.488] - result already collected: FutureResult
[17:42:24.489] result() for ClusterFuture ... done
[17:42:24.489] result() for ClusterFuture ...
[17:42:24.489] - result already collected: FutureResult
[17:42:24.489] result() for ClusterFuture ... done
[17:42:24.489] result() for ClusterFuture ...
[17:42:24.489] - result already collected: FutureResult
[17:42:24.489] result() for ClusterFuture ... done
[17:42:24.489] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.489] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.490] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:24.490]  length: 4 (resolved future 2)
[17:42:24.490] Future #3
[17:42:24.490] result() for ClusterFuture ...
[17:42:24.490] - result already collected: FutureResult
[17:42:24.490] result() for ClusterFuture ... done
[17:42:24.490] result() for ClusterFuture ...
[17:42:24.490] - result already collected: FutureResult
[17:42:24.491] result() for ClusterFuture ... done
[17:42:24.491] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:24.491] - nx: 6
[17:42:24.491] - relay: TRUE
[17:42:24.491] - stdout: TRUE
[17:42:24.491] - signal: TRUE
[17:42:24.491] - resignal: FALSE
[17:42:24.492] - force: TRUE
[17:42:24.492] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.492] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.492]  - until=3
[17:42:24.492]  - relaying element #3
[17:42:24.492] result() for ClusterFuture ...
[17:42:24.492] - result already collected: FutureResult
[17:42:24.492] result() for ClusterFuture ... done
[17:42:24.493] result() for ClusterFuture ...
[17:42:24.493] - result already collected: FutureResult
[17:42:24.493] result() for ClusterFuture ... done
[17:42:24.493] result() for ClusterFuture ...
[17:42:24.493] - result already collected: FutureResult
[17:42:24.493] result() for ClusterFuture ... done
[17:42:24.493] result() for ClusterFuture ...
[17:42:24.494] - result already collected: FutureResult
[17:42:24.494] result() for ClusterFuture ... done
[17:42:24.494] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.494] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:24.494]  length: 3 (resolved future 3)
[17:42:24.505] signalConditionsASAP(NULL, pos=5) ...
[17:42:24.505] - nx: 6
[17:42:24.505] - relay: TRUE
[17:42:24.506] - stdout: TRUE
[17:42:24.506] - signal: TRUE
[17:42:24.506] - resignal: FALSE
[17:42:24.506] - force: TRUE
[17:42:24.506] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.506] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.506]  - until=6
[17:42:24.507]  - relaying element #4
[17:42:24.507]  - relaying element #6
[17:42:24.507] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.507] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.507] signalConditionsASAP(NULL, pos=5) ... done
[17:42:24.507]  length: 2 (resolved future 5)
[17:42:24.507] signalConditionsASAP(numeric, pos=6) ...
[17:42:24.507] - nx: 6
[17:42:24.508] - relay: TRUE
[17:42:24.508] - stdout: TRUE
[17:42:24.508] - signal: TRUE
[17:42:24.508] - resignal: FALSE
[17:42:24.508] - force: TRUE
[17:42:24.508] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.508] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.509]  - until=6
[17:42:24.509]  - relaying element #4
[17:42:24.509] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.509] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.509] signalConditionsASAP(NULL, pos=6) ... done
[17:42:24.509]  length: 1 (resolved future 6)
[17:42:24.520] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.520] - Validating connection of MultisessionFuture
[17:42:24.520] - received message: FutureResult
[17:42:24.521] - Received FutureResult
[17:42:24.521] - Erased future from FutureRegistry
[17:42:24.521] result() for ClusterFuture ...
[17:42:24.521] - result already collected: FutureResult
[17:42:24.521] result() for ClusterFuture ... done
[17:42:24.521] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.521] Future #4
[17:42:24.521] result() for ClusterFuture ...
[17:42:24.521] - result already collected: FutureResult
[17:42:24.522] result() for ClusterFuture ... done
[17:42:24.522] result() for ClusterFuture ...
[17:42:24.522] - result already collected: FutureResult
[17:42:24.522] result() for ClusterFuture ... done
[17:42:24.522] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:24.522] - nx: 6
[17:42:24.522] - relay: TRUE
[17:42:24.522] - stdout: TRUE
[17:42:24.522] - signal: TRUE
[17:42:24.522] - resignal: FALSE
[17:42:24.522] - force: TRUE
[17:42:24.522] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.523] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.523]  - until=6
[17:42:24.523]  - relaying element #4
[17:42:24.523] result() for ClusterFuture ...
[17:42:24.523] - result already collected: FutureResult
[17:42:24.523] result() for ClusterFuture ... done
[17:42:24.523] result() for ClusterFuture ...
[17:42:24.523] - result already collected: FutureResult
[17:42:24.523] result() for ClusterFuture ... done
[17:42:24.523] result() for ClusterFuture ...
[17:42:24.524] - result already collected: FutureResult
[17:42:24.524] result() for ClusterFuture ... done
[17:42:24.524] result() for ClusterFuture ...
[17:42:24.524] - result already collected: FutureResult
[17:42:24.524] result() for ClusterFuture ... done
[17:42:24.524] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.524] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.524] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:24.524]  length: 0 (resolved future 4)
[17:42:24.524] Relaying remaining futures
[17:42:24.525] signalConditionsASAP(NULL, pos=0) ...
[17:42:24.525] - nx: 6
[17:42:24.525] - relay: TRUE
[17:42:24.525] - stdout: TRUE
[17:42:24.525] - signal: TRUE
[17:42:24.525] - resignal: FALSE
[17:42:24.525] - force: TRUE
[17:42:24.525] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.525] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:24.525] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.525] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.526] signalConditionsASAP(NULL, pos=0) ... done
[17:42:24.526] resolve() on list environment ... DONE
[17:42:24.526] result() for ClusterFuture ...
[17:42:24.526] - result already collected: FutureResult
[17:42:24.526] result() for ClusterFuture ... done
[17:42:24.526] result() for ClusterFuture ...
[17:42:24.526] - result already collected: FutureResult
[17:42:24.526] result() for ClusterFuture ... done
[17:42:24.526] result() for ClusterFuture ...
[17:42:24.526] - result already collected: FutureResult
[17:42:24.526] result() for ClusterFuture ... done
[17:42:24.527] result() for ClusterFuture ...
[17:42:24.527] - result already collected: FutureResult
[17:42:24.527] result() for ClusterFuture ... done
[17:42:24.527] result() for ClusterFuture ...
[17:42:24.527] - result already collected: FutureResult
[17:42:24.527] result() for ClusterFuture ... done
[17:42:24.527] result() for ClusterFuture ...
[17:42:24.527] - result already collected: FutureResult
[17:42:24.527] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55bef8ff50b0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[17:42:24.529] getGlobalsAndPackages() ...
[17:42:24.529] Searching for globals...
[17:42:24.530] 
[17:42:24.530] Searching for globals ... DONE
[17:42:24.530] - globals: [0] <none>
[17:42:24.530] getGlobalsAndPackages() ... DONE
[17:42:24.530] run() for ‘Future’ ...
[17:42:24.530] - state: ‘created’
[17:42:24.531] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.545] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.545] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.546]   - Field: ‘node’
[17:42:24.546]   - Field: ‘label’
[17:42:24.546]   - Field: ‘local’
[17:42:24.546]   - Field: ‘owner’
[17:42:24.546]   - Field: ‘envir’
[17:42:24.546]   - Field: ‘workers’
[17:42:24.546]   - Field: ‘packages’
[17:42:24.546]   - Field: ‘gc’
[17:42:24.546]   - Field: ‘conditions’
[17:42:24.546]   - Field: ‘persistent’
[17:42:24.547]   - Field: ‘expr’
[17:42:24.547]   - Field: ‘uuid’
[17:42:24.547]   - Field: ‘seed’
[17:42:24.547]   - Field: ‘version’
[17:42:24.547]   - Field: ‘result’
[17:42:24.547]   - Field: ‘asynchronous’
[17:42:24.547]   - Field: ‘calls’
[17:42:24.547]   - Field: ‘globals’
[17:42:24.547]   - Field: ‘stdout’
[17:42:24.548]   - Field: ‘earlySignal’
[17:42:24.548]   - Field: ‘lazy’
[17:42:24.548]   - Field: ‘state’
[17:42:24.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.548] - Launch lazy future ...
[17:42:24.548] Packages needed by the future expression (n = 0): <none>
[17:42:24.548] Packages needed by future strategies (n = 0): <none>
[17:42:24.549] {
[17:42:24.549]     {
[17:42:24.549]         {
[17:42:24.549]             ...future.startTime <- base::Sys.time()
[17:42:24.549]             {
[17:42:24.549]                 {
[17:42:24.549]                   {
[17:42:24.549]                     {
[17:42:24.549]                       base::local({
[17:42:24.549]                         has_future <- base::requireNamespace("future", 
[17:42:24.549]                           quietly = TRUE)
[17:42:24.549]                         if (has_future) {
[17:42:24.549]                           ns <- base::getNamespace("future")
[17:42:24.549]                           version <- ns[[".package"]][["version"]]
[17:42:24.549]                           if (is.null(version)) 
[17:42:24.549]                             version <- utils::packageVersion("future")
[17:42:24.549]                         }
[17:42:24.549]                         else {
[17:42:24.549]                           version <- NULL
[17:42:24.549]                         }
[17:42:24.549]                         if (!has_future || version < "1.8.0") {
[17:42:24.549]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.549]                             "", base::R.version$version.string), 
[17:42:24.549]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.549]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.549]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.549]                               "release", "version")], collapse = " "), 
[17:42:24.549]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.549]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.549]                             info)
[17:42:24.549]                           info <- base::paste(info, collapse = "; ")
[17:42:24.549]                           if (!has_future) {
[17:42:24.549]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.549]                               info)
[17:42:24.549]                           }
[17:42:24.549]                           else {
[17:42:24.549]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.549]                               info, version)
[17:42:24.549]                           }
[17:42:24.549]                           base::stop(msg)
[17:42:24.549]                         }
[17:42:24.549]                       })
[17:42:24.549]                     }
[17:42:24.549]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.549]                     base::options(mc.cores = 1L)
[17:42:24.549]                   }
[17:42:24.549]                   options(future.plan = NULL)
[17:42:24.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.549]                 }
[17:42:24.549]                 ...future.workdir <- getwd()
[17:42:24.549]             }
[17:42:24.549]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.549]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.549]         }
[17:42:24.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.549]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.549]             base::names(...future.oldOptions))
[17:42:24.549]     }
[17:42:24.549]     if (FALSE) {
[17:42:24.549]     }
[17:42:24.549]     else {
[17:42:24.549]         if (TRUE) {
[17:42:24.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.549]                 open = "w")
[17:42:24.549]         }
[17:42:24.549]         else {
[17:42:24.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.549]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.549]         }
[17:42:24.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.549]             base::sink(type = "output", split = FALSE)
[17:42:24.549]             base::close(...future.stdout)
[17:42:24.549]         }, add = TRUE)
[17:42:24.549]     }
[17:42:24.549]     ...future.frame <- base::sys.nframe()
[17:42:24.549]     ...future.conditions <- base::list()
[17:42:24.549]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.549]     if (FALSE) {
[17:42:24.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.549]     }
[17:42:24.549]     ...future.result <- base::tryCatch({
[17:42:24.549]         base::withCallingHandlers({
[17:42:24.549]             ...future.value <- base::withVisible(base::local({
[17:42:24.549]                 ...future.makeSendCondition <- local({
[17:42:24.549]                   sendCondition <- NULL
[17:42:24.549]                   function(frame = 1L) {
[17:42:24.549]                     if (is.function(sendCondition)) 
[17:42:24.549]                       return(sendCondition)
[17:42:24.549]                     ns <- getNamespace("parallel")
[17:42:24.549]                     if (exists("sendData", mode = "function", 
[17:42:24.549]                       envir = ns)) {
[17:42:24.549]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.549]                         envir = ns)
[17:42:24.549]                       envir <- sys.frame(frame)
[17:42:24.549]                       master <- NULL
[17:42:24.549]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.549]                         !identical(envir, emptyenv())) {
[17:42:24.549]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.549]                           inherits = FALSE)) {
[17:42:24.549]                           master <- get("master", mode = "list", 
[17:42:24.549]                             envir = envir, inherits = FALSE)
[17:42:24.549]                           if (inherits(master, c("SOCKnode", 
[17:42:24.549]                             "SOCK0node"))) {
[17:42:24.549]                             sendCondition <<- function(cond) {
[17:42:24.549]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.549]                                 success = TRUE)
[17:42:24.549]                               parallel_sendData(master, data)
[17:42:24.549]                             }
[17:42:24.549]                             return(sendCondition)
[17:42:24.549]                           }
[17:42:24.549]                         }
[17:42:24.549]                         frame <- frame + 1L
[17:42:24.549]                         envir <- sys.frame(frame)
[17:42:24.549]                       }
[17:42:24.549]                     }
[17:42:24.549]                     sendCondition <<- function(cond) NULL
[17:42:24.549]                   }
[17:42:24.549]                 })
[17:42:24.549]                 withCallingHandlers({
[17:42:24.549]                   2
[17:42:24.549]                 }, immediateCondition = function(cond) {
[17:42:24.549]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.549]                   sendCondition(cond)
[17:42:24.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.549]                   {
[17:42:24.549]                     inherits <- base::inherits
[17:42:24.549]                     invokeRestart <- base::invokeRestart
[17:42:24.549]                     is.null <- base::is.null
[17:42:24.549]                     muffled <- FALSE
[17:42:24.549]                     if (inherits(cond, "message")) {
[17:42:24.549]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.549]                       if (muffled) 
[17:42:24.549]                         invokeRestart("muffleMessage")
[17:42:24.549]                     }
[17:42:24.549]                     else if (inherits(cond, "warning")) {
[17:42:24.549]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.549]                       if (muffled) 
[17:42:24.549]                         invokeRestart("muffleWarning")
[17:42:24.549]                     }
[17:42:24.549]                     else if (inherits(cond, "condition")) {
[17:42:24.549]                       if (!is.null(pattern)) {
[17:42:24.549]                         computeRestarts <- base::computeRestarts
[17:42:24.549]                         grepl <- base::grepl
[17:42:24.549]                         restarts <- computeRestarts(cond)
[17:42:24.549]                         for (restart in restarts) {
[17:42:24.549]                           name <- restart$name
[17:42:24.549]                           if (is.null(name)) 
[17:42:24.549]                             next
[17:42:24.549]                           if (!grepl(pattern, name)) 
[17:42:24.549]                             next
[17:42:24.549]                           invokeRestart(restart)
[17:42:24.549]                           muffled <- TRUE
[17:42:24.549]                           break
[17:42:24.549]                         }
[17:42:24.549]                       }
[17:42:24.549]                     }
[17:42:24.549]                     invisible(muffled)
[17:42:24.549]                   }
[17:42:24.549]                   muffleCondition(cond)
[17:42:24.549]                 })
[17:42:24.549]             }))
[17:42:24.549]             future::FutureResult(value = ...future.value$value, 
[17:42:24.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.549]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.549]                     ...future.globalenv.names))
[17:42:24.549]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.549]         }, condition = base::local({
[17:42:24.549]             c <- base::c
[17:42:24.549]             inherits <- base::inherits
[17:42:24.549]             invokeRestart <- base::invokeRestart
[17:42:24.549]             length <- base::length
[17:42:24.549]             list <- base::list
[17:42:24.549]             seq.int <- base::seq.int
[17:42:24.549]             signalCondition <- base::signalCondition
[17:42:24.549]             sys.calls <- base::sys.calls
[17:42:24.549]             `[[` <- base::`[[`
[17:42:24.549]             `+` <- base::`+`
[17:42:24.549]             `<<-` <- base::`<<-`
[17:42:24.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.549]                   3L)]
[17:42:24.549]             }
[17:42:24.549]             function(cond) {
[17:42:24.549]                 is_error <- inherits(cond, "error")
[17:42:24.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.549]                   NULL)
[17:42:24.549]                 if (is_error) {
[17:42:24.549]                   sessionInformation <- function() {
[17:42:24.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.549]                       search = base::search(), system = base::Sys.info())
[17:42:24.549]                   }
[17:42:24.549]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.549]                     cond$call), session = sessionInformation(), 
[17:42:24.549]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.549]                   signalCondition(cond)
[17:42:24.549]                 }
[17:42:24.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.549]                 "immediateCondition"))) {
[17:42:24.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.549]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.549]                   if (TRUE && !signal) {
[17:42:24.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.549]                     {
[17:42:24.549]                       inherits <- base::inherits
[17:42:24.549]                       invokeRestart <- base::invokeRestart
[17:42:24.549]                       is.null <- base::is.null
[17:42:24.549]                       muffled <- FALSE
[17:42:24.549]                       if (inherits(cond, "message")) {
[17:42:24.549]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.549]                         if (muffled) 
[17:42:24.549]                           invokeRestart("muffleMessage")
[17:42:24.549]                       }
[17:42:24.549]                       else if (inherits(cond, "warning")) {
[17:42:24.549]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.549]                         if (muffled) 
[17:42:24.549]                           invokeRestart("muffleWarning")
[17:42:24.549]                       }
[17:42:24.549]                       else if (inherits(cond, "condition")) {
[17:42:24.549]                         if (!is.null(pattern)) {
[17:42:24.549]                           computeRestarts <- base::computeRestarts
[17:42:24.549]                           grepl <- base::grepl
[17:42:24.549]                           restarts <- computeRestarts(cond)
[17:42:24.549]                           for (restart in restarts) {
[17:42:24.549]                             name <- restart$name
[17:42:24.549]                             if (is.null(name)) 
[17:42:24.549]                               next
[17:42:24.549]                             if (!grepl(pattern, name)) 
[17:42:24.549]                               next
[17:42:24.549]                             invokeRestart(restart)
[17:42:24.549]                             muffled <- TRUE
[17:42:24.549]                             break
[17:42:24.549]                           }
[17:42:24.549]                         }
[17:42:24.549]                       }
[17:42:24.549]                       invisible(muffled)
[17:42:24.549]                     }
[17:42:24.549]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.549]                   }
[17:42:24.549]                 }
[17:42:24.549]                 else {
[17:42:24.549]                   if (TRUE) {
[17:42:24.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.549]                     {
[17:42:24.549]                       inherits <- base::inherits
[17:42:24.549]                       invokeRestart <- base::invokeRestart
[17:42:24.549]                       is.null <- base::is.null
[17:42:24.549]                       muffled <- FALSE
[17:42:24.549]                       if (inherits(cond, "message")) {
[17:42:24.549]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.549]                         if (muffled) 
[17:42:24.549]                           invokeRestart("muffleMessage")
[17:42:24.549]                       }
[17:42:24.549]                       else if (inherits(cond, "warning")) {
[17:42:24.549]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.549]                         if (muffled) 
[17:42:24.549]                           invokeRestart("muffleWarning")
[17:42:24.549]                       }
[17:42:24.549]                       else if (inherits(cond, "condition")) {
[17:42:24.549]                         if (!is.null(pattern)) {
[17:42:24.549]                           computeRestarts <- base::computeRestarts
[17:42:24.549]                           grepl <- base::grepl
[17:42:24.549]                           restarts <- computeRestarts(cond)
[17:42:24.549]                           for (restart in restarts) {
[17:42:24.549]                             name <- restart$name
[17:42:24.549]                             if (is.null(name)) 
[17:42:24.549]                               next
[17:42:24.549]                             if (!grepl(pattern, name)) 
[17:42:24.549]                               next
[17:42:24.549]                             invokeRestart(restart)
[17:42:24.549]                             muffled <- TRUE
[17:42:24.549]                             break
[17:42:24.549]                           }
[17:42:24.549]                         }
[17:42:24.549]                       }
[17:42:24.549]                       invisible(muffled)
[17:42:24.549]                     }
[17:42:24.549]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.549]                   }
[17:42:24.549]                 }
[17:42:24.549]             }
[17:42:24.549]         }))
[17:42:24.549]     }, error = function(ex) {
[17:42:24.549]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.549]                 ...future.rng), started = ...future.startTime, 
[17:42:24.549]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.549]             version = "1.8"), class = "FutureResult")
[17:42:24.549]     }, finally = {
[17:42:24.549]         if (!identical(...future.workdir, getwd())) 
[17:42:24.549]             setwd(...future.workdir)
[17:42:24.549]         {
[17:42:24.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.549]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.549]             }
[17:42:24.549]             base::options(...future.oldOptions)
[17:42:24.549]             if (.Platform$OS.type == "windows") {
[17:42:24.549]                 old_names <- names(...future.oldEnvVars)
[17:42:24.549]                 envs <- base::Sys.getenv()
[17:42:24.549]                 names <- names(envs)
[17:42:24.549]                 common <- intersect(names, old_names)
[17:42:24.549]                 added <- setdiff(names, old_names)
[17:42:24.549]                 removed <- setdiff(old_names, names)
[17:42:24.549]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.549]                   envs[common]]
[17:42:24.549]                 NAMES <- toupper(changed)
[17:42:24.549]                 args <- list()
[17:42:24.549]                 for (kk in seq_along(NAMES)) {
[17:42:24.549]                   name <- changed[[kk]]
[17:42:24.549]                   NAME <- NAMES[[kk]]
[17:42:24.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.549]                     next
[17:42:24.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.549]                 }
[17:42:24.549]                 NAMES <- toupper(added)
[17:42:24.549]                 for (kk in seq_along(NAMES)) {
[17:42:24.549]                   name <- added[[kk]]
[17:42:24.549]                   NAME <- NAMES[[kk]]
[17:42:24.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.549]                     next
[17:42:24.549]                   args[[name]] <- ""
[17:42:24.549]                 }
[17:42:24.549]                 NAMES <- toupper(removed)
[17:42:24.549]                 for (kk in seq_along(NAMES)) {
[17:42:24.549]                   name <- removed[[kk]]
[17:42:24.549]                   NAME <- NAMES[[kk]]
[17:42:24.549]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.549]                     next
[17:42:24.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.549]                 }
[17:42:24.549]                 if (length(args) > 0) 
[17:42:24.549]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.549]             }
[17:42:24.549]             else {
[17:42:24.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.549]             }
[17:42:24.549]             {
[17:42:24.549]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.549]                   0L) {
[17:42:24.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.549]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.549]                   base::options(opts)
[17:42:24.549]                 }
[17:42:24.549]                 {
[17:42:24.549]                   {
[17:42:24.549]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.549]                     NULL
[17:42:24.549]                   }
[17:42:24.549]                   options(future.plan = NULL)
[17:42:24.549]                   if (is.na(NA_character_)) 
[17:42:24.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.549]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.549]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.549]                     envir = parent.frame()) 
[17:42:24.549]                   {
[17:42:24.549]                     if (is.function(workers)) 
[17:42:24.549]                       workers <- workers()
[17:42:24.549]                     workers <- structure(as.integer(workers), 
[17:42:24.549]                       class = class(workers))
[17:42:24.549]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.549]                       workers >= 1)
[17:42:24.549]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.549]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.549]                     }
[17:42:24.549]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.549]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.549]                       envir = envir)
[17:42:24.549]                     if (!future$lazy) 
[17:42:24.549]                       future <- run(future)
[17:42:24.549]                     invisible(future)
[17:42:24.549]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.549]                 }
[17:42:24.549]             }
[17:42:24.549]         }
[17:42:24.549]     })
[17:42:24.549]     if (TRUE) {
[17:42:24.549]         base::sink(type = "output", split = FALSE)
[17:42:24.549]         if (TRUE) {
[17:42:24.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.549]         }
[17:42:24.549]         else {
[17:42:24.549]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.549]         }
[17:42:24.549]         base::close(...future.stdout)
[17:42:24.549]         ...future.stdout <- NULL
[17:42:24.549]     }
[17:42:24.549]     ...future.result$conditions <- ...future.conditions
[17:42:24.549]     ...future.result$finished <- base::Sys.time()
[17:42:24.549]     ...future.result
[17:42:24.549] }
[17:42:24.552] MultisessionFuture started
[17:42:24.552] - Launch lazy future ... done
[17:42:24.552] run() for ‘MultisessionFuture’ ... done
[17:42:24.553] getGlobalsAndPackages() ...
[17:42:24.553] Searching for globals...
[17:42:24.553] 
[17:42:24.553] Searching for globals ... DONE
[17:42:24.553] - globals: [0] <none>
[17:42:24.553] getGlobalsAndPackages() ... DONE
[17:42:24.554] run() for ‘Future’ ...
[17:42:24.557] - state: ‘created’
[17:42:24.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.572]   - Field: ‘node’
[17:42:24.572]   - Field: ‘label’
[17:42:24.572]   - Field: ‘local’
[17:42:24.572]   - Field: ‘owner’
[17:42:24.572]   - Field: ‘envir’
[17:42:24.572]   - Field: ‘workers’
[17:42:24.572]   - Field: ‘packages’
[17:42:24.573]   - Field: ‘gc’
[17:42:24.573]   - Field: ‘conditions’
[17:42:24.573]   - Field: ‘persistent’
[17:42:24.573]   - Field: ‘expr’
[17:42:24.573]   - Field: ‘uuid’
[17:42:24.573]   - Field: ‘seed’
[17:42:24.573]   - Field: ‘version’
[17:42:24.573]   - Field: ‘result’
[17:42:24.573]   - Field: ‘asynchronous’
[17:42:24.573]   - Field: ‘calls’
[17:42:24.573]   - Field: ‘globals’
[17:42:24.574]   - Field: ‘stdout’
[17:42:24.574]   - Field: ‘earlySignal’
[17:42:24.574]   - Field: ‘lazy’
[17:42:24.574]   - Field: ‘state’
[17:42:24.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.574] - Launch lazy future ...
[17:42:24.574] Packages needed by the future expression (n = 0): <none>
[17:42:24.574] Packages needed by future strategies (n = 0): <none>
[17:42:24.575] {
[17:42:24.575]     {
[17:42:24.575]         {
[17:42:24.575]             ...future.startTime <- base::Sys.time()
[17:42:24.575]             {
[17:42:24.575]                 {
[17:42:24.575]                   {
[17:42:24.575]                     {
[17:42:24.575]                       base::local({
[17:42:24.575]                         has_future <- base::requireNamespace("future", 
[17:42:24.575]                           quietly = TRUE)
[17:42:24.575]                         if (has_future) {
[17:42:24.575]                           ns <- base::getNamespace("future")
[17:42:24.575]                           version <- ns[[".package"]][["version"]]
[17:42:24.575]                           if (is.null(version)) 
[17:42:24.575]                             version <- utils::packageVersion("future")
[17:42:24.575]                         }
[17:42:24.575]                         else {
[17:42:24.575]                           version <- NULL
[17:42:24.575]                         }
[17:42:24.575]                         if (!has_future || version < "1.8.0") {
[17:42:24.575]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.575]                             "", base::R.version$version.string), 
[17:42:24.575]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.575]                               "release", "version")], collapse = " "), 
[17:42:24.575]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.575]                             info)
[17:42:24.575]                           info <- base::paste(info, collapse = "; ")
[17:42:24.575]                           if (!has_future) {
[17:42:24.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.575]                               info)
[17:42:24.575]                           }
[17:42:24.575]                           else {
[17:42:24.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.575]                               info, version)
[17:42:24.575]                           }
[17:42:24.575]                           base::stop(msg)
[17:42:24.575]                         }
[17:42:24.575]                       })
[17:42:24.575]                     }
[17:42:24.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.575]                     base::options(mc.cores = 1L)
[17:42:24.575]                   }
[17:42:24.575]                   options(future.plan = NULL)
[17:42:24.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.575]                 }
[17:42:24.575]                 ...future.workdir <- getwd()
[17:42:24.575]             }
[17:42:24.575]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.575]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.575]         }
[17:42:24.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.575]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.575]             base::names(...future.oldOptions))
[17:42:24.575]     }
[17:42:24.575]     if (FALSE) {
[17:42:24.575]     }
[17:42:24.575]     else {
[17:42:24.575]         if (TRUE) {
[17:42:24.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.575]                 open = "w")
[17:42:24.575]         }
[17:42:24.575]         else {
[17:42:24.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.575]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.575]         }
[17:42:24.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.575]             base::sink(type = "output", split = FALSE)
[17:42:24.575]             base::close(...future.stdout)
[17:42:24.575]         }, add = TRUE)
[17:42:24.575]     }
[17:42:24.575]     ...future.frame <- base::sys.nframe()
[17:42:24.575]     ...future.conditions <- base::list()
[17:42:24.575]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.575]     if (FALSE) {
[17:42:24.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.575]     }
[17:42:24.575]     ...future.result <- base::tryCatch({
[17:42:24.575]         base::withCallingHandlers({
[17:42:24.575]             ...future.value <- base::withVisible(base::local({
[17:42:24.575]                 ...future.makeSendCondition <- local({
[17:42:24.575]                   sendCondition <- NULL
[17:42:24.575]                   function(frame = 1L) {
[17:42:24.575]                     if (is.function(sendCondition)) 
[17:42:24.575]                       return(sendCondition)
[17:42:24.575]                     ns <- getNamespace("parallel")
[17:42:24.575]                     if (exists("sendData", mode = "function", 
[17:42:24.575]                       envir = ns)) {
[17:42:24.575]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.575]                         envir = ns)
[17:42:24.575]                       envir <- sys.frame(frame)
[17:42:24.575]                       master <- NULL
[17:42:24.575]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.575]                         !identical(envir, emptyenv())) {
[17:42:24.575]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.575]                           inherits = FALSE)) {
[17:42:24.575]                           master <- get("master", mode = "list", 
[17:42:24.575]                             envir = envir, inherits = FALSE)
[17:42:24.575]                           if (inherits(master, c("SOCKnode", 
[17:42:24.575]                             "SOCK0node"))) {
[17:42:24.575]                             sendCondition <<- function(cond) {
[17:42:24.575]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.575]                                 success = TRUE)
[17:42:24.575]                               parallel_sendData(master, data)
[17:42:24.575]                             }
[17:42:24.575]                             return(sendCondition)
[17:42:24.575]                           }
[17:42:24.575]                         }
[17:42:24.575]                         frame <- frame + 1L
[17:42:24.575]                         envir <- sys.frame(frame)
[17:42:24.575]                       }
[17:42:24.575]                     }
[17:42:24.575]                     sendCondition <<- function(cond) NULL
[17:42:24.575]                   }
[17:42:24.575]                 })
[17:42:24.575]                 withCallingHandlers({
[17:42:24.575]                   NULL
[17:42:24.575]                 }, immediateCondition = function(cond) {
[17:42:24.575]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.575]                   sendCondition(cond)
[17:42:24.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.575]                   {
[17:42:24.575]                     inherits <- base::inherits
[17:42:24.575]                     invokeRestart <- base::invokeRestart
[17:42:24.575]                     is.null <- base::is.null
[17:42:24.575]                     muffled <- FALSE
[17:42:24.575]                     if (inherits(cond, "message")) {
[17:42:24.575]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.575]                       if (muffled) 
[17:42:24.575]                         invokeRestart("muffleMessage")
[17:42:24.575]                     }
[17:42:24.575]                     else if (inherits(cond, "warning")) {
[17:42:24.575]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.575]                       if (muffled) 
[17:42:24.575]                         invokeRestart("muffleWarning")
[17:42:24.575]                     }
[17:42:24.575]                     else if (inherits(cond, "condition")) {
[17:42:24.575]                       if (!is.null(pattern)) {
[17:42:24.575]                         computeRestarts <- base::computeRestarts
[17:42:24.575]                         grepl <- base::grepl
[17:42:24.575]                         restarts <- computeRestarts(cond)
[17:42:24.575]                         for (restart in restarts) {
[17:42:24.575]                           name <- restart$name
[17:42:24.575]                           if (is.null(name)) 
[17:42:24.575]                             next
[17:42:24.575]                           if (!grepl(pattern, name)) 
[17:42:24.575]                             next
[17:42:24.575]                           invokeRestart(restart)
[17:42:24.575]                           muffled <- TRUE
[17:42:24.575]                           break
[17:42:24.575]                         }
[17:42:24.575]                       }
[17:42:24.575]                     }
[17:42:24.575]                     invisible(muffled)
[17:42:24.575]                   }
[17:42:24.575]                   muffleCondition(cond)
[17:42:24.575]                 })
[17:42:24.575]             }))
[17:42:24.575]             future::FutureResult(value = ...future.value$value, 
[17:42:24.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.575]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.575]                     ...future.globalenv.names))
[17:42:24.575]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.575]         }, condition = base::local({
[17:42:24.575]             c <- base::c
[17:42:24.575]             inherits <- base::inherits
[17:42:24.575]             invokeRestart <- base::invokeRestart
[17:42:24.575]             length <- base::length
[17:42:24.575]             list <- base::list
[17:42:24.575]             seq.int <- base::seq.int
[17:42:24.575]             signalCondition <- base::signalCondition
[17:42:24.575]             sys.calls <- base::sys.calls
[17:42:24.575]             `[[` <- base::`[[`
[17:42:24.575]             `+` <- base::`+`
[17:42:24.575]             `<<-` <- base::`<<-`
[17:42:24.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.575]                   3L)]
[17:42:24.575]             }
[17:42:24.575]             function(cond) {
[17:42:24.575]                 is_error <- inherits(cond, "error")
[17:42:24.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.575]                   NULL)
[17:42:24.575]                 if (is_error) {
[17:42:24.575]                   sessionInformation <- function() {
[17:42:24.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.575]                       search = base::search(), system = base::Sys.info())
[17:42:24.575]                   }
[17:42:24.575]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.575]                     cond$call), session = sessionInformation(), 
[17:42:24.575]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.575]                   signalCondition(cond)
[17:42:24.575]                 }
[17:42:24.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.575]                 "immediateCondition"))) {
[17:42:24.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.575]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.575]                   if (TRUE && !signal) {
[17:42:24.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.575]                     {
[17:42:24.575]                       inherits <- base::inherits
[17:42:24.575]                       invokeRestart <- base::invokeRestart
[17:42:24.575]                       is.null <- base::is.null
[17:42:24.575]                       muffled <- FALSE
[17:42:24.575]                       if (inherits(cond, "message")) {
[17:42:24.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.575]                         if (muffled) 
[17:42:24.575]                           invokeRestart("muffleMessage")
[17:42:24.575]                       }
[17:42:24.575]                       else if (inherits(cond, "warning")) {
[17:42:24.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.575]                         if (muffled) 
[17:42:24.575]                           invokeRestart("muffleWarning")
[17:42:24.575]                       }
[17:42:24.575]                       else if (inherits(cond, "condition")) {
[17:42:24.575]                         if (!is.null(pattern)) {
[17:42:24.575]                           computeRestarts <- base::computeRestarts
[17:42:24.575]                           grepl <- base::grepl
[17:42:24.575]                           restarts <- computeRestarts(cond)
[17:42:24.575]                           for (restart in restarts) {
[17:42:24.575]                             name <- restart$name
[17:42:24.575]                             if (is.null(name)) 
[17:42:24.575]                               next
[17:42:24.575]                             if (!grepl(pattern, name)) 
[17:42:24.575]                               next
[17:42:24.575]                             invokeRestart(restart)
[17:42:24.575]                             muffled <- TRUE
[17:42:24.575]                             break
[17:42:24.575]                           }
[17:42:24.575]                         }
[17:42:24.575]                       }
[17:42:24.575]                       invisible(muffled)
[17:42:24.575]                     }
[17:42:24.575]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.575]                   }
[17:42:24.575]                 }
[17:42:24.575]                 else {
[17:42:24.575]                   if (TRUE) {
[17:42:24.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.575]                     {
[17:42:24.575]                       inherits <- base::inherits
[17:42:24.575]                       invokeRestart <- base::invokeRestart
[17:42:24.575]                       is.null <- base::is.null
[17:42:24.575]                       muffled <- FALSE
[17:42:24.575]                       if (inherits(cond, "message")) {
[17:42:24.575]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.575]                         if (muffled) 
[17:42:24.575]                           invokeRestart("muffleMessage")
[17:42:24.575]                       }
[17:42:24.575]                       else if (inherits(cond, "warning")) {
[17:42:24.575]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.575]                         if (muffled) 
[17:42:24.575]                           invokeRestart("muffleWarning")
[17:42:24.575]                       }
[17:42:24.575]                       else if (inherits(cond, "condition")) {
[17:42:24.575]                         if (!is.null(pattern)) {
[17:42:24.575]                           computeRestarts <- base::computeRestarts
[17:42:24.575]                           grepl <- base::grepl
[17:42:24.575]                           restarts <- computeRestarts(cond)
[17:42:24.575]                           for (restart in restarts) {
[17:42:24.575]                             name <- restart$name
[17:42:24.575]                             if (is.null(name)) 
[17:42:24.575]                               next
[17:42:24.575]                             if (!grepl(pattern, name)) 
[17:42:24.575]                               next
[17:42:24.575]                             invokeRestart(restart)
[17:42:24.575]                             muffled <- TRUE
[17:42:24.575]                             break
[17:42:24.575]                           }
[17:42:24.575]                         }
[17:42:24.575]                       }
[17:42:24.575]                       invisible(muffled)
[17:42:24.575]                     }
[17:42:24.575]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.575]                   }
[17:42:24.575]                 }
[17:42:24.575]             }
[17:42:24.575]         }))
[17:42:24.575]     }, error = function(ex) {
[17:42:24.575]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.575]                 ...future.rng), started = ...future.startTime, 
[17:42:24.575]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.575]             version = "1.8"), class = "FutureResult")
[17:42:24.575]     }, finally = {
[17:42:24.575]         if (!identical(...future.workdir, getwd())) 
[17:42:24.575]             setwd(...future.workdir)
[17:42:24.575]         {
[17:42:24.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.575]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.575]             }
[17:42:24.575]             base::options(...future.oldOptions)
[17:42:24.575]             if (.Platform$OS.type == "windows") {
[17:42:24.575]                 old_names <- names(...future.oldEnvVars)
[17:42:24.575]                 envs <- base::Sys.getenv()
[17:42:24.575]                 names <- names(envs)
[17:42:24.575]                 common <- intersect(names, old_names)
[17:42:24.575]                 added <- setdiff(names, old_names)
[17:42:24.575]                 removed <- setdiff(old_names, names)
[17:42:24.575]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.575]                   envs[common]]
[17:42:24.575]                 NAMES <- toupper(changed)
[17:42:24.575]                 args <- list()
[17:42:24.575]                 for (kk in seq_along(NAMES)) {
[17:42:24.575]                   name <- changed[[kk]]
[17:42:24.575]                   NAME <- NAMES[[kk]]
[17:42:24.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.575]                     next
[17:42:24.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.575]                 }
[17:42:24.575]                 NAMES <- toupper(added)
[17:42:24.575]                 for (kk in seq_along(NAMES)) {
[17:42:24.575]                   name <- added[[kk]]
[17:42:24.575]                   NAME <- NAMES[[kk]]
[17:42:24.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.575]                     next
[17:42:24.575]                   args[[name]] <- ""
[17:42:24.575]                 }
[17:42:24.575]                 NAMES <- toupper(removed)
[17:42:24.575]                 for (kk in seq_along(NAMES)) {
[17:42:24.575]                   name <- removed[[kk]]
[17:42:24.575]                   NAME <- NAMES[[kk]]
[17:42:24.575]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.575]                     next
[17:42:24.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.575]                 }
[17:42:24.575]                 if (length(args) > 0) 
[17:42:24.575]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.575]             }
[17:42:24.575]             else {
[17:42:24.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.575]             }
[17:42:24.575]             {
[17:42:24.575]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.575]                   0L) {
[17:42:24.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.575]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.575]                   base::options(opts)
[17:42:24.575]                 }
[17:42:24.575]                 {
[17:42:24.575]                   {
[17:42:24.575]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.575]                     NULL
[17:42:24.575]                   }
[17:42:24.575]                   options(future.plan = NULL)
[17:42:24.575]                   if (is.na(NA_character_)) 
[17:42:24.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.575]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.575]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.575]                     envir = parent.frame()) 
[17:42:24.575]                   {
[17:42:24.575]                     if (is.function(workers)) 
[17:42:24.575]                       workers <- workers()
[17:42:24.575]                     workers <- structure(as.integer(workers), 
[17:42:24.575]                       class = class(workers))
[17:42:24.575]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.575]                       workers >= 1)
[17:42:24.575]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.575]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.575]                     }
[17:42:24.575]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.575]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.575]                       envir = envir)
[17:42:24.575]                     if (!future$lazy) 
[17:42:24.575]                       future <- run(future)
[17:42:24.575]                     invisible(future)
[17:42:24.575]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.575]                 }
[17:42:24.575]             }
[17:42:24.575]         }
[17:42:24.575]     })
[17:42:24.575]     if (TRUE) {
[17:42:24.575]         base::sink(type = "output", split = FALSE)
[17:42:24.575]         if (TRUE) {
[17:42:24.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.575]         }
[17:42:24.575]         else {
[17:42:24.575]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.575]         }
[17:42:24.575]         base::close(...future.stdout)
[17:42:24.575]         ...future.stdout <- NULL
[17:42:24.575]     }
[17:42:24.575]     ...future.result$conditions <- ...future.conditions
[17:42:24.575]     ...future.result$finished <- base::Sys.time()
[17:42:24.575]     ...future.result
[17:42:24.575] }
[17:42:24.578] MultisessionFuture started
[17:42:24.578] - Launch lazy future ... done
[17:42:24.578] run() for ‘MultisessionFuture’ ... done
[17:42:24.579] getGlobalsAndPackages() ...
[17:42:24.579] Searching for globals...
[17:42:24.579] - globals found: [1] ‘{’
[17:42:24.580] Searching for globals ... DONE
[17:42:24.580] Resolving globals: FALSE
[17:42:24.580] 
[17:42:24.580] 
[17:42:24.580] getGlobalsAndPackages() ... DONE
[17:42:24.580] run() for ‘Future’ ...
[17:42:24.580] - state: ‘created’
[17:42:24.581] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.595] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.595]   - Field: ‘node’
[17:42:24.595]   - Field: ‘label’
[17:42:24.595]   - Field: ‘local’
[17:42:24.595]   - Field: ‘owner’
[17:42:24.596]   - Field: ‘envir’
[17:42:24.596]   - Field: ‘workers’
[17:42:24.596]   - Field: ‘packages’
[17:42:24.596]   - Field: ‘gc’
[17:42:24.596]   - Field: ‘conditions’
[17:42:24.596]   - Field: ‘persistent’
[17:42:24.596]   - Field: ‘expr’
[17:42:24.596]   - Field: ‘uuid’
[17:42:24.596]   - Field: ‘seed’
[17:42:24.596]   - Field: ‘version’
[17:42:24.596]   - Field: ‘result’
[17:42:24.597]   - Field: ‘asynchronous’
[17:42:24.597]   - Field: ‘calls’
[17:42:24.597]   - Field: ‘globals’
[17:42:24.597]   - Field: ‘stdout’
[17:42:24.597]   - Field: ‘earlySignal’
[17:42:24.597]   - Field: ‘lazy’
[17:42:24.597]   - Field: ‘state’
[17:42:24.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.597] - Launch lazy future ...
[17:42:24.598] Packages needed by the future expression (n = 0): <none>
[17:42:24.598] Packages needed by future strategies (n = 0): <none>
[17:42:24.598] {
[17:42:24.598]     {
[17:42:24.598]         {
[17:42:24.598]             ...future.startTime <- base::Sys.time()
[17:42:24.598]             {
[17:42:24.598]                 {
[17:42:24.598]                   {
[17:42:24.598]                     {
[17:42:24.598]                       base::local({
[17:42:24.598]                         has_future <- base::requireNamespace("future", 
[17:42:24.598]                           quietly = TRUE)
[17:42:24.598]                         if (has_future) {
[17:42:24.598]                           ns <- base::getNamespace("future")
[17:42:24.598]                           version <- ns[[".package"]][["version"]]
[17:42:24.598]                           if (is.null(version)) 
[17:42:24.598]                             version <- utils::packageVersion("future")
[17:42:24.598]                         }
[17:42:24.598]                         else {
[17:42:24.598]                           version <- NULL
[17:42:24.598]                         }
[17:42:24.598]                         if (!has_future || version < "1.8.0") {
[17:42:24.598]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.598]                             "", base::R.version$version.string), 
[17:42:24.598]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.598]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.598]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.598]                               "release", "version")], collapse = " "), 
[17:42:24.598]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.598]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.598]                             info)
[17:42:24.598]                           info <- base::paste(info, collapse = "; ")
[17:42:24.598]                           if (!has_future) {
[17:42:24.598]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.598]                               info)
[17:42:24.598]                           }
[17:42:24.598]                           else {
[17:42:24.598]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.598]                               info, version)
[17:42:24.598]                           }
[17:42:24.598]                           base::stop(msg)
[17:42:24.598]                         }
[17:42:24.598]                       })
[17:42:24.598]                     }
[17:42:24.598]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.598]                     base::options(mc.cores = 1L)
[17:42:24.598]                   }
[17:42:24.598]                   options(future.plan = NULL)
[17:42:24.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.598]                 }
[17:42:24.598]                 ...future.workdir <- getwd()
[17:42:24.598]             }
[17:42:24.598]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.598]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.598]         }
[17:42:24.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.598]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.598]             base::names(...future.oldOptions))
[17:42:24.598]     }
[17:42:24.598]     if (FALSE) {
[17:42:24.598]     }
[17:42:24.598]     else {
[17:42:24.598]         if (TRUE) {
[17:42:24.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.598]                 open = "w")
[17:42:24.598]         }
[17:42:24.598]         else {
[17:42:24.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.598]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.598]         }
[17:42:24.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.598]             base::sink(type = "output", split = FALSE)
[17:42:24.598]             base::close(...future.stdout)
[17:42:24.598]         }, add = TRUE)
[17:42:24.598]     }
[17:42:24.598]     ...future.frame <- base::sys.nframe()
[17:42:24.598]     ...future.conditions <- base::list()
[17:42:24.598]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.598]     if (FALSE) {
[17:42:24.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.598]     }
[17:42:24.598]     ...future.result <- base::tryCatch({
[17:42:24.598]         base::withCallingHandlers({
[17:42:24.598]             ...future.value <- base::withVisible(base::local({
[17:42:24.598]                 ...future.makeSendCondition <- local({
[17:42:24.598]                   sendCondition <- NULL
[17:42:24.598]                   function(frame = 1L) {
[17:42:24.598]                     if (is.function(sendCondition)) 
[17:42:24.598]                       return(sendCondition)
[17:42:24.598]                     ns <- getNamespace("parallel")
[17:42:24.598]                     if (exists("sendData", mode = "function", 
[17:42:24.598]                       envir = ns)) {
[17:42:24.598]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.598]                         envir = ns)
[17:42:24.598]                       envir <- sys.frame(frame)
[17:42:24.598]                       master <- NULL
[17:42:24.598]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.598]                         !identical(envir, emptyenv())) {
[17:42:24.598]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.598]                           inherits = FALSE)) {
[17:42:24.598]                           master <- get("master", mode = "list", 
[17:42:24.598]                             envir = envir, inherits = FALSE)
[17:42:24.598]                           if (inherits(master, c("SOCKnode", 
[17:42:24.598]                             "SOCK0node"))) {
[17:42:24.598]                             sendCondition <<- function(cond) {
[17:42:24.598]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.598]                                 success = TRUE)
[17:42:24.598]                               parallel_sendData(master, data)
[17:42:24.598]                             }
[17:42:24.598]                             return(sendCondition)
[17:42:24.598]                           }
[17:42:24.598]                         }
[17:42:24.598]                         frame <- frame + 1L
[17:42:24.598]                         envir <- sys.frame(frame)
[17:42:24.598]                       }
[17:42:24.598]                     }
[17:42:24.598]                     sendCondition <<- function(cond) NULL
[17:42:24.598]                   }
[17:42:24.598]                 })
[17:42:24.598]                 withCallingHandlers({
[17:42:24.598]                   {
[17:42:24.598]                     4
[17:42:24.598]                   }
[17:42:24.598]                 }, immediateCondition = function(cond) {
[17:42:24.598]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.598]                   sendCondition(cond)
[17:42:24.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.598]                   {
[17:42:24.598]                     inherits <- base::inherits
[17:42:24.598]                     invokeRestart <- base::invokeRestart
[17:42:24.598]                     is.null <- base::is.null
[17:42:24.598]                     muffled <- FALSE
[17:42:24.598]                     if (inherits(cond, "message")) {
[17:42:24.598]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.598]                       if (muffled) 
[17:42:24.598]                         invokeRestart("muffleMessage")
[17:42:24.598]                     }
[17:42:24.598]                     else if (inherits(cond, "warning")) {
[17:42:24.598]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.598]                       if (muffled) 
[17:42:24.598]                         invokeRestart("muffleWarning")
[17:42:24.598]                     }
[17:42:24.598]                     else if (inherits(cond, "condition")) {
[17:42:24.598]                       if (!is.null(pattern)) {
[17:42:24.598]                         computeRestarts <- base::computeRestarts
[17:42:24.598]                         grepl <- base::grepl
[17:42:24.598]                         restarts <- computeRestarts(cond)
[17:42:24.598]                         for (restart in restarts) {
[17:42:24.598]                           name <- restart$name
[17:42:24.598]                           if (is.null(name)) 
[17:42:24.598]                             next
[17:42:24.598]                           if (!grepl(pattern, name)) 
[17:42:24.598]                             next
[17:42:24.598]                           invokeRestart(restart)
[17:42:24.598]                           muffled <- TRUE
[17:42:24.598]                           break
[17:42:24.598]                         }
[17:42:24.598]                       }
[17:42:24.598]                     }
[17:42:24.598]                     invisible(muffled)
[17:42:24.598]                   }
[17:42:24.598]                   muffleCondition(cond)
[17:42:24.598]                 })
[17:42:24.598]             }))
[17:42:24.598]             future::FutureResult(value = ...future.value$value, 
[17:42:24.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.598]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.598]                     ...future.globalenv.names))
[17:42:24.598]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.598]         }, condition = base::local({
[17:42:24.598]             c <- base::c
[17:42:24.598]             inherits <- base::inherits
[17:42:24.598]             invokeRestart <- base::invokeRestart
[17:42:24.598]             length <- base::length
[17:42:24.598]             list <- base::list
[17:42:24.598]             seq.int <- base::seq.int
[17:42:24.598]             signalCondition <- base::signalCondition
[17:42:24.598]             sys.calls <- base::sys.calls
[17:42:24.598]             `[[` <- base::`[[`
[17:42:24.598]             `+` <- base::`+`
[17:42:24.598]             `<<-` <- base::`<<-`
[17:42:24.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.598]                   3L)]
[17:42:24.598]             }
[17:42:24.598]             function(cond) {
[17:42:24.598]                 is_error <- inherits(cond, "error")
[17:42:24.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.598]                   NULL)
[17:42:24.598]                 if (is_error) {
[17:42:24.598]                   sessionInformation <- function() {
[17:42:24.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.598]                       search = base::search(), system = base::Sys.info())
[17:42:24.598]                   }
[17:42:24.598]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.598]                     cond$call), session = sessionInformation(), 
[17:42:24.598]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.598]                   signalCondition(cond)
[17:42:24.598]                 }
[17:42:24.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.598]                 "immediateCondition"))) {
[17:42:24.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.598]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.598]                   if (TRUE && !signal) {
[17:42:24.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.598]                     {
[17:42:24.598]                       inherits <- base::inherits
[17:42:24.598]                       invokeRestart <- base::invokeRestart
[17:42:24.598]                       is.null <- base::is.null
[17:42:24.598]                       muffled <- FALSE
[17:42:24.598]                       if (inherits(cond, "message")) {
[17:42:24.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.598]                         if (muffled) 
[17:42:24.598]                           invokeRestart("muffleMessage")
[17:42:24.598]                       }
[17:42:24.598]                       else if (inherits(cond, "warning")) {
[17:42:24.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.598]                         if (muffled) 
[17:42:24.598]                           invokeRestart("muffleWarning")
[17:42:24.598]                       }
[17:42:24.598]                       else if (inherits(cond, "condition")) {
[17:42:24.598]                         if (!is.null(pattern)) {
[17:42:24.598]                           computeRestarts <- base::computeRestarts
[17:42:24.598]                           grepl <- base::grepl
[17:42:24.598]                           restarts <- computeRestarts(cond)
[17:42:24.598]                           for (restart in restarts) {
[17:42:24.598]                             name <- restart$name
[17:42:24.598]                             if (is.null(name)) 
[17:42:24.598]                               next
[17:42:24.598]                             if (!grepl(pattern, name)) 
[17:42:24.598]                               next
[17:42:24.598]                             invokeRestart(restart)
[17:42:24.598]                             muffled <- TRUE
[17:42:24.598]                             break
[17:42:24.598]                           }
[17:42:24.598]                         }
[17:42:24.598]                       }
[17:42:24.598]                       invisible(muffled)
[17:42:24.598]                     }
[17:42:24.598]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.598]                   }
[17:42:24.598]                 }
[17:42:24.598]                 else {
[17:42:24.598]                   if (TRUE) {
[17:42:24.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.598]                     {
[17:42:24.598]                       inherits <- base::inherits
[17:42:24.598]                       invokeRestart <- base::invokeRestart
[17:42:24.598]                       is.null <- base::is.null
[17:42:24.598]                       muffled <- FALSE
[17:42:24.598]                       if (inherits(cond, "message")) {
[17:42:24.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.598]                         if (muffled) 
[17:42:24.598]                           invokeRestart("muffleMessage")
[17:42:24.598]                       }
[17:42:24.598]                       else if (inherits(cond, "warning")) {
[17:42:24.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.598]                         if (muffled) 
[17:42:24.598]                           invokeRestart("muffleWarning")
[17:42:24.598]                       }
[17:42:24.598]                       else if (inherits(cond, "condition")) {
[17:42:24.598]                         if (!is.null(pattern)) {
[17:42:24.598]                           computeRestarts <- base::computeRestarts
[17:42:24.598]                           grepl <- base::grepl
[17:42:24.598]                           restarts <- computeRestarts(cond)
[17:42:24.598]                           for (restart in restarts) {
[17:42:24.598]                             name <- restart$name
[17:42:24.598]                             if (is.null(name)) 
[17:42:24.598]                               next
[17:42:24.598]                             if (!grepl(pattern, name)) 
[17:42:24.598]                               next
[17:42:24.598]                             invokeRestart(restart)
[17:42:24.598]                             muffled <- TRUE
[17:42:24.598]                             break
[17:42:24.598]                           }
[17:42:24.598]                         }
[17:42:24.598]                       }
[17:42:24.598]                       invisible(muffled)
[17:42:24.598]                     }
[17:42:24.598]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.598]                   }
[17:42:24.598]                 }
[17:42:24.598]             }
[17:42:24.598]         }))
[17:42:24.598]     }, error = function(ex) {
[17:42:24.598]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.598]                 ...future.rng), started = ...future.startTime, 
[17:42:24.598]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.598]             version = "1.8"), class = "FutureResult")
[17:42:24.598]     }, finally = {
[17:42:24.598]         if (!identical(...future.workdir, getwd())) 
[17:42:24.598]             setwd(...future.workdir)
[17:42:24.598]         {
[17:42:24.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.598]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.598]             }
[17:42:24.598]             base::options(...future.oldOptions)
[17:42:24.598]             if (.Platform$OS.type == "windows") {
[17:42:24.598]                 old_names <- names(...future.oldEnvVars)
[17:42:24.598]                 envs <- base::Sys.getenv()
[17:42:24.598]                 names <- names(envs)
[17:42:24.598]                 common <- intersect(names, old_names)
[17:42:24.598]                 added <- setdiff(names, old_names)
[17:42:24.598]                 removed <- setdiff(old_names, names)
[17:42:24.598]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.598]                   envs[common]]
[17:42:24.598]                 NAMES <- toupper(changed)
[17:42:24.598]                 args <- list()
[17:42:24.598]                 for (kk in seq_along(NAMES)) {
[17:42:24.598]                   name <- changed[[kk]]
[17:42:24.598]                   NAME <- NAMES[[kk]]
[17:42:24.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.598]                     next
[17:42:24.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.598]                 }
[17:42:24.598]                 NAMES <- toupper(added)
[17:42:24.598]                 for (kk in seq_along(NAMES)) {
[17:42:24.598]                   name <- added[[kk]]
[17:42:24.598]                   NAME <- NAMES[[kk]]
[17:42:24.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.598]                     next
[17:42:24.598]                   args[[name]] <- ""
[17:42:24.598]                 }
[17:42:24.598]                 NAMES <- toupper(removed)
[17:42:24.598]                 for (kk in seq_along(NAMES)) {
[17:42:24.598]                   name <- removed[[kk]]
[17:42:24.598]                   NAME <- NAMES[[kk]]
[17:42:24.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.598]                     next
[17:42:24.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.598]                 }
[17:42:24.598]                 if (length(args) > 0) 
[17:42:24.598]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.598]             }
[17:42:24.598]             else {
[17:42:24.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.598]             }
[17:42:24.598]             {
[17:42:24.598]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.598]                   0L) {
[17:42:24.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.598]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.598]                   base::options(opts)
[17:42:24.598]                 }
[17:42:24.598]                 {
[17:42:24.598]                   {
[17:42:24.598]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.598]                     NULL
[17:42:24.598]                   }
[17:42:24.598]                   options(future.plan = NULL)
[17:42:24.598]                   if (is.na(NA_character_)) 
[17:42:24.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.598]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.598]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.598]                     envir = parent.frame()) 
[17:42:24.598]                   {
[17:42:24.598]                     if (is.function(workers)) 
[17:42:24.598]                       workers <- workers()
[17:42:24.598]                     workers <- structure(as.integer(workers), 
[17:42:24.598]                       class = class(workers))
[17:42:24.598]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.598]                       workers >= 1)
[17:42:24.598]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.598]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.598]                     }
[17:42:24.598]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.598]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.598]                       envir = envir)
[17:42:24.598]                     if (!future$lazy) 
[17:42:24.598]                       future <- run(future)
[17:42:24.598]                     invisible(future)
[17:42:24.598]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.598]                 }
[17:42:24.598]             }
[17:42:24.598]         }
[17:42:24.598]     })
[17:42:24.598]     if (TRUE) {
[17:42:24.598]         base::sink(type = "output", split = FALSE)
[17:42:24.598]         if (TRUE) {
[17:42:24.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.598]         }
[17:42:24.598]         else {
[17:42:24.598]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.598]         }
[17:42:24.598]         base::close(...future.stdout)
[17:42:24.598]         ...future.stdout <- NULL
[17:42:24.598]     }
[17:42:24.598]     ...future.result$conditions <- ...future.conditions
[17:42:24.598]     ...future.result$finished <- base::Sys.time()
[17:42:24.598]     ...future.result
[17:42:24.598] }
[17:42:24.601] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:24.611] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.611] - Validating connection of MultisessionFuture
[17:42:24.612] - received message: FutureResult
[17:42:24.612] - Received FutureResult
[17:42:24.612] - Erased future from FutureRegistry
[17:42:24.612] result() for ClusterFuture ...
[17:42:24.612] - result already collected: FutureResult
[17:42:24.612] result() for ClusterFuture ... done
[17:42:24.612] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.612] result() for ClusterFuture ...
[17:42:24.613] - result already collected: FutureResult
[17:42:24.613] result() for ClusterFuture ... done
[17:42:24.613] result() for ClusterFuture ...
[17:42:24.613] - result already collected: FutureResult
[17:42:24.613] result() for ClusterFuture ... done
[17:42:24.614] MultisessionFuture started
[17:42:24.614] - Launch lazy future ... done
[17:42:24.614] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef9c39ad8> 
Classes 'listenv', 'environment' <environment: 0x55bef668a460> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[17:42:24.628] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.628] - Validating connection of MultisessionFuture
[17:42:24.628] - received message: FutureResult
[17:42:24.628] - Received FutureResult
[17:42:24.628] - Erased future from FutureRegistry
[17:42:24.628] result() for ClusterFuture ...
[17:42:24.628] - result already collected: FutureResult
[17:42:24.629] result() for ClusterFuture ... done
[17:42:24.629] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:24.641] resolve() on list environment ...
[17:42:24.642]  recursive: 0
[17:42:24.642]  length: 6
[17:42:24.643]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:24.643] signalConditionsASAP(numeric, pos=1) ...
[17:42:24.643] - nx: 6
[17:42:24.643] - relay: TRUE
[17:42:24.643] - stdout: TRUE
[17:42:24.643] - signal: TRUE
[17:42:24.643] - resignal: FALSE
[17:42:24.643] - force: TRUE
[17:42:24.643] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.643] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.644]  - until=2
[17:42:24.644]  - relaying element #2
[17:42:24.644] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.644] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.644] signalConditionsASAP(NULL, pos=1) ... done
[17:42:24.644]  length: 5 (resolved future 1)
[17:42:24.644] Future #2
[17:42:24.644] result() for ClusterFuture ...
[17:42:24.644] - result already collected: FutureResult
[17:42:24.644] result() for ClusterFuture ... done
[17:42:24.645] result() for ClusterFuture ...
[17:42:24.645] - result already collected: FutureResult
[17:42:24.645] result() for ClusterFuture ... done
[17:42:24.645] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:24.645] - nx: 6
[17:42:24.645] - relay: TRUE
[17:42:24.645] - stdout: TRUE
[17:42:24.645] - signal: TRUE
[17:42:24.645] - resignal: FALSE
[17:42:24.645] - force: TRUE
[17:42:24.645] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.645] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.646]  - until=2
[17:42:24.646]  - relaying element #2
[17:42:24.646] result() for ClusterFuture ...
[17:42:24.646] - result already collected: FutureResult
[17:42:24.646] result() for ClusterFuture ... done
[17:42:24.646] result() for ClusterFuture ...
[17:42:24.646] - result already collected: FutureResult
[17:42:24.646] result() for ClusterFuture ... done
[17:42:24.646] result() for ClusterFuture ...
[17:42:24.646] - result already collected: FutureResult
[17:42:24.646] result() for ClusterFuture ... done
[17:42:24.647] result() for ClusterFuture ...
[17:42:24.647] - result already collected: FutureResult
[17:42:24.647] result() for ClusterFuture ... done
[17:42:24.647] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.647] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.647] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:24.647]  length: 4 (resolved future 2)
[17:42:24.647] Future #3
[17:42:24.647] result() for ClusterFuture ...
[17:42:24.647] - result already collected: FutureResult
[17:42:24.648] result() for ClusterFuture ... done
[17:42:24.648] result() for ClusterFuture ...
[17:42:24.648] - result already collected: FutureResult
[17:42:24.648] result() for ClusterFuture ... done
[17:42:24.648] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:24.648] - nx: 6
[17:42:24.648] - relay: TRUE
[17:42:24.648] - stdout: TRUE
[17:42:24.648] - signal: TRUE
[17:42:24.648] - resignal: FALSE
[17:42:24.648] - force: TRUE
[17:42:24.648] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.649] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.649]  - until=3
[17:42:24.649]  - relaying element #3
[17:42:24.649] result() for ClusterFuture ...
[17:42:24.649] - result already collected: FutureResult
[17:42:24.649] result() for ClusterFuture ... done
[17:42:24.649] result() for ClusterFuture ...
[17:42:24.649] - result already collected: FutureResult
[17:42:24.649] result() for ClusterFuture ... done
[17:42:24.649] result() for ClusterFuture ...
[17:42:24.649] - result already collected: FutureResult
[17:42:24.650] result() for ClusterFuture ... done
[17:42:24.650] result() for ClusterFuture ...
[17:42:24.650] - result already collected: FutureResult
[17:42:24.650] result() for ClusterFuture ... done
[17:42:24.650] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.650] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.650] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:24.650]  length: 3 (resolved future 3)
[17:42:24.661] signalConditionsASAP(NULL, pos=5) ...
[17:42:24.661] - nx: 6
[17:42:24.661] - relay: TRUE
[17:42:24.661] - stdout: TRUE
[17:42:24.661] - signal: TRUE
[17:42:24.661] - resignal: FALSE
[17:42:24.661] - force: TRUE
[17:42:24.662] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.662] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.662]  - until=6
[17:42:24.662]  - relaying element #4
[17:42:24.662]  - relaying element #6
[17:42:24.662] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.662] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.662] signalConditionsASAP(NULL, pos=5) ... done
[17:42:24.662]  length: 2 (resolved future 5)
[17:42:24.662] signalConditionsASAP(numeric, pos=6) ...
[17:42:24.663] - nx: 6
[17:42:24.663] - relay: TRUE
[17:42:24.663] - stdout: TRUE
[17:42:24.663] - signal: TRUE
[17:42:24.663] - resignal: FALSE
[17:42:24.663] - force: TRUE
[17:42:24.663] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.663] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.663]  - until=6
[17:42:24.663]  - relaying element #4
[17:42:24.663] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.663] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.664] signalConditionsASAP(NULL, pos=6) ... done
[17:42:24.664]  length: 1 (resolved future 6)
[17:42:24.675] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.675] - Validating connection of MultisessionFuture
[17:42:24.675] - received message: FutureResult
[17:42:24.675] - Received FutureResult
[17:42:24.675] - Erased future from FutureRegistry
[17:42:24.675] result() for ClusterFuture ...
[17:42:24.676] - result already collected: FutureResult
[17:42:24.676] result() for ClusterFuture ... done
[17:42:24.676] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.676] Future #4
[17:42:24.676] result() for ClusterFuture ...
[17:42:24.676] - result already collected: FutureResult
[17:42:24.676] result() for ClusterFuture ... done
[17:42:24.676] result() for ClusterFuture ...
[17:42:24.676] - result already collected: FutureResult
[17:42:24.676] result() for ClusterFuture ... done
[17:42:24.676] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:24.677] - nx: 6
[17:42:24.677] - relay: TRUE
[17:42:24.677] - stdout: TRUE
[17:42:24.677] - signal: TRUE
[17:42:24.677] - resignal: FALSE
[17:42:24.677] - force: TRUE
[17:42:24.677] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.677] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.677]  - until=6
[17:42:24.677]  - relaying element #4
[17:42:24.677] result() for ClusterFuture ...
[17:42:24.677] - result already collected: FutureResult
[17:42:24.678] result() for ClusterFuture ... done
[17:42:24.678] result() for ClusterFuture ...
[17:42:24.678] - result already collected: FutureResult
[17:42:24.678] result() for ClusterFuture ... done
[17:42:24.678] result() for ClusterFuture ...
[17:42:24.678] - result already collected: FutureResult
[17:42:24.678] result() for ClusterFuture ... done
[17:42:24.678] result() for ClusterFuture ...
[17:42:24.678] - result already collected: FutureResult
[17:42:24.678] result() for ClusterFuture ... done
[17:42:24.679] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.679] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.679] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:24.679]  length: 0 (resolved future 4)
[17:42:24.679] Relaying remaining futures
[17:42:24.679] signalConditionsASAP(NULL, pos=0) ...
[17:42:24.679] - nx: 6
[17:42:24.679] - relay: TRUE
[17:42:24.679] - stdout: TRUE
[17:42:24.679] - signal: TRUE
[17:42:24.679] - resignal: FALSE
[17:42:24.680] - force: TRUE
[17:42:24.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.680] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:24.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.680] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.680] signalConditionsASAP(NULL, pos=0) ... done
[17:42:24.680] resolve() on list environment ... DONE
[17:42:24.680] result() for ClusterFuture ...
[17:42:24.680] - result already collected: FutureResult
[17:42:24.680] result() for ClusterFuture ... done
[17:42:24.681] result() for ClusterFuture ...
[17:42:24.681] - result already collected: FutureResult
[17:42:24.681] result() for ClusterFuture ... done
[17:42:24.681] result() for ClusterFuture ...
[17:42:24.681] - result already collected: FutureResult
[17:42:24.681] result() for ClusterFuture ... done
[17:42:24.681] result() for ClusterFuture ...
[17:42:24.681] - result already collected: FutureResult
[17:42:24.681] result() for ClusterFuture ... done
[17:42:24.682] result() for ClusterFuture ...
[17:42:24.682] - result already collected: FutureResult
[17:42:24.682] result() for ClusterFuture ... done
[17:42:24.682] result() for ClusterFuture ...
[17:42:24.682] - result already collected: FutureResult
[17:42:24.682] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55bef8b6e540> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[17:42:24.684] getGlobalsAndPackages() ...
[17:42:24.684] Searching for globals...
[17:42:24.684] 
[17:42:24.684] Searching for globals ... DONE
[17:42:24.684] - globals: [0] <none>
[17:42:24.685] getGlobalsAndPackages() ... DONE
[17:42:24.685] run() for ‘Future’ ...
[17:42:24.685] - state: ‘created’
[17:42:24.685] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.700]   - Field: ‘node’
[17:42:24.700]   - Field: ‘label’
[17:42:24.700]   - Field: ‘local’
[17:42:24.700]   - Field: ‘owner’
[17:42:24.701]   - Field: ‘envir’
[17:42:24.701]   - Field: ‘workers’
[17:42:24.701]   - Field: ‘packages’
[17:42:24.701]   - Field: ‘gc’
[17:42:24.701]   - Field: ‘conditions’
[17:42:24.701]   - Field: ‘persistent’
[17:42:24.701]   - Field: ‘expr’
[17:42:24.701]   - Field: ‘uuid’
[17:42:24.701]   - Field: ‘seed’
[17:42:24.701]   - Field: ‘version’
[17:42:24.701]   - Field: ‘result’
[17:42:24.702]   - Field: ‘asynchronous’
[17:42:24.702]   - Field: ‘calls’
[17:42:24.702]   - Field: ‘globals’
[17:42:24.702]   - Field: ‘stdout’
[17:42:24.702]   - Field: ‘earlySignal’
[17:42:24.702]   - Field: ‘lazy’
[17:42:24.702]   - Field: ‘state’
[17:42:24.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.702] - Launch lazy future ...
[17:42:24.703] Packages needed by the future expression (n = 0): <none>
[17:42:24.703] Packages needed by future strategies (n = 0): <none>
[17:42:24.703] {
[17:42:24.703]     {
[17:42:24.703]         {
[17:42:24.703]             ...future.startTime <- base::Sys.time()
[17:42:24.703]             {
[17:42:24.703]                 {
[17:42:24.703]                   {
[17:42:24.703]                     {
[17:42:24.703]                       base::local({
[17:42:24.703]                         has_future <- base::requireNamespace("future", 
[17:42:24.703]                           quietly = TRUE)
[17:42:24.703]                         if (has_future) {
[17:42:24.703]                           ns <- base::getNamespace("future")
[17:42:24.703]                           version <- ns[[".package"]][["version"]]
[17:42:24.703]                           if (is.null(version)) 
[17:42:24.703]                             version <- utils::packageVersion("future")
[17:42:24.703]                         }
[17:42:24.703]                         else {
[17:42:24.703]                           version <- NULL
[17:42:24.703]                         }
[17:42:24.703]                         if (!has_future || version < "1.8.0") {
[17:42:24.703]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.703]                             "", base::R.version$version.string), 
[17:42:24.703]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.703]                               "release", "version")], collapse = " "), 
[17:42:24.703]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.703]                             info)
[17:42:24.703]                           info <- base::paste(info, collapse = "; ")
[17:42:24.703]                           if (!has_future) {
[17:42:24.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.703]                               info)
[17:42:24.703]                           }
[17:42:24.703]                           else {
[17:42:24.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.703]                               info, version)
[17:42:24.703]                           }
[17:42:24.703]                           base::stop(msg)
[17:42:24.703]                         }
[17:42:24.703]                       })
[17:42:24.703]                     }
[17:42:24.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.703]                     base::options(mc.cores = 1L)
[17:42:24.703]                   }
[17:42:24.703]                   options(future.plan = NULL)
[17:42:24.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.703]                 }
[17:42:24.703]                 ...future.workdir <- getwd()
[17:42:24.703]             }
[17:42:24.703]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.703]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.703]         }
[17:42:24.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.703]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.703]             base::names(...future.oldOptions))
[17:42:24.703]     }
[17:42:24.703]     if (FALSE) {
[17:42:24.703]     }
[17:42:24.703]     else {
[17:42:24.703]         if (TRUE) {
[17:42:24.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.703]                 open = "w")
[17:42:24.703]         }
[17:42:24.703]         else {
[17:42:24.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.703]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.703]         }
[17:42:24.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.703]             base::sink(type = "output", split = FALSE)
[17:42:24.703]             base::close(...future.stdout)
[17:42:24.703]         }, add = TRUE)
[17:42:24.703]     }
[17:42:24.703]     ...future.frame <- base::sys.nframe()
[17:42:24.703]     ...future.conditions <- base::list()
[17:42:24.703]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.703]     if (FALSE) {
[17:42:24.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.703]     }
[17:42:24.703]     ...future.result <- base::tryCatch({
[17:42:24.703]         base::withCallingHandlers({
[17:42:24.703]             ...future.value <- base::withVisible(base::local({
[17:42:24.703]                 ...future.makeSendCondition <- local({
[17:42:24.703]                   sendCondition <- NULL
[17:42:24.703]                   function(frame = 1L) {
[17:42:24.703]                     if (is.function(sendCondition)) 
[17:42:24.703]                       return(sendCondition)
[17:42:24.703]                     ns <- getNamespace("parallel")
[17:42:24.703]                     if (exists("sendData", mode = "function", 
[17:42:24.703]                       envir = ns)) {
[17:42:24.703]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.703]                         envir = ns)
[17:42:24.703]                       envir <- sys.frame(frame)
[17:42:24.703]                       master <- NULL
[17:42:24.703]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.703]                         !identical(envir, emptyenv())) {
[17:42:24.703]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.703]                           inherits = FALSE)) {
[17:42:24.703]                           master <- get("master", mode = "list", 
[17:42:24.703]                             envir = envir, inherits = FALSE)
[17:42:24.703]                           if (inherits(master, c("SOCKnode", 
[17:42:24.703]                             "SOCK0node"))) {
[17:42:24.703]                             sendCondition <<- function(cond) {
[17:42:24.703]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.703]                                 success = TRUE)
[17:42:24.703]                               parallel_sendData(master, data)
[17:42:24.703]                             }
[17:42:24.703]                             return(sendCondition)
[17:42:24.703]                           }
[17:42:24.703]                         }
[17:42:24.703]                         frame <- frame + 1L
[17:42:24.703]                         envir <- sys.frame(frame)
[17:42:24.703]                       }
[17:42:24.703]                     }
[17:42:24.703]                     sendCondition <<- function(cond) NULL
[17:42:24.703]                   }
[17:42:24.703]                 })
[17:42:24.703]                 withCallingHandlers({
[17:42:24.703]                   2
[17:42:24.703]                 }, immediateCondition = function(cond) {
[17:42:24.703]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.703]                   sendCondition(cond)
[17:42:24.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.703]                   {
[17:42:24.703]                     inherits <- base::inherits
[17:42:24.703]                     invokeRestart <- base::invokeRestart
[17:42:24.703]                     is.null <- base::is.null
[17:42:24.703]                     muffled <- FALSE
[17:42:24.703]                     if (inherits(cond, "message")) {
[17:42:24.703]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.703]                       if (muffled) 
[17:42:24.703]                         invokeRestart("muffleMessage")
[17:42:24.703]                     }
[17:42:24.703]                     else if (inherits(cond, "warning")) {
[17:42:24.703]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.703]                       if (muffled) 
[17:42:24.703]                         invokeRestart("muffleWarning")
[17:42:24.703]                     }
[17:42:24.703]                     else if (inherits(cond, "condition")) {
[17:42:24.703]                       if (!is.null(pattern)) {
[17:42:24.703]                         computeRestarts <- base::computeRestarts
[17:42:24.703]                         grepl <- base::grepl
[17:42:24.703]                         restarts <- computeRestarts(cond)
[17:42:24.703]                         for (restart in restarts) {
[17:42:24.703]                           name <- restart$name
[17:42:24.703]                           if (is.null(name)) 
[17:42:24.703]                             next
[17:42:24.703]                           if (!grepl(pattern, name)) 
[17:42:24.703]                             next
[17:42:24.703]                           invokeRestart(restart)
[17:42:24.703]                           muffled <- TRUE
[17:42:24.703]                           break
[17:42:24.703]                         }
[17:42:24.703]                       }
[17:42:24.703]                     }
[17:42:24.703]                     invisible(muffled)
[17:42:24.703]                   }
[17:42:24.703]                   muffleCondition(cond)
[17:42:24.703]                 })
[17:42:24.703]             }))
[17:42:24.703]             future::FutureResult(value = ...future.value$value, 
[17:42:24.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.703]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.703]                     ...future.globalenv.names))
[17:42:24.703]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.703]         }, condition = base::local({
[17:42:24.703]             c <- base::c
[17:42:24.703]             inherits <- base::inherits
[17:42:24.703]             invokeRestart <- base::invokeRestart
[17:42:24.703]             length <- base::length
[17:42:24.703]             list <- base::list
[17:42:24.703]             seq.int <- base::seq.int
[17:42:24.703]             signalCondition <- base::signalCondition
[17:42:24.703]             sys.calls <- base::sys.calls
[17:42:24.703]             `[[` <- base::`[[`
[17:42:24.703]             `+` <- base::`+`
[17:42:24.703]             `<<-` <- base::`<<-`
[17:42:24.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.703]                   3L)]
[17:42:24.703]             }
[17:42:24.703]             function(cond) {
[17:42:24.703]                 is_error <- inherits(cond, "error")
[17:42:24.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.703]                   NULL)
[17:42:24.703]                 if (is_error) {
[17:42:24.703]                   sessionInformation <- function() {
[17:42:24.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.703]                       search = base::search(), system = base::Sys.info())
[17:42:24.703]                   }
[17:42:24.703]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.703]                     cond$call), session = sessionInformation(), 
[17:42:24.703]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.703]                   signalCondition(cond)
[17:42:24.703]                 }
[17:42:24.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.703]                 "immediateCondition"))) {
[17:42:24.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.703]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.703]                   if (TRUE && !signal) {
[17:42:24.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.703]                     {
[17:42:24.703]                       inherits <- base::inherits
[17:42:24.703]                       invokeRestart <- base::invokeRestart
[17:42:24.703]                       is.null <- base::is.null
[17:42:24.703]                       muffled <- FALSE
[17:42:24.703]                       if (inherits(cond, "message")) {
[17:42:24.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.703]                         if (muffled) 
[17:42:24.703]                           invokeRestart("muffleMessage")
[17:42:24.703]                       }
[17:42:24.703]                       else if (inherits(cond, "warning")) {
[17:42:24.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.703]                         if (muffled) 
[17:42:24.703]                           invokeRestart("muffleWarning")
[17:42:24.703]                       }
[17:42:24.703]                       else if (inherits(cond, "condition")) {
[17:42:24.703]                         if (!is.null(pattern)) {
[17:42:24.703]                           computeRestarts <- base::computeRestarts
[17:42:24.703]                           grepl <- base::grepl
[17:42:24.703]                           restarts <- computeRestarts(cond)
[17:42:24.703]                           for (restart in restarts) {
[17:42:24.703]                             name <- restart$name
[17:42:24.703]                             if (is.null(name)) 
[17:42:24.703]                               next
[17:42:24.703]                             if (!grepl(pattern, name)) 
[17:42:24.703]                               next
[17:42:24.703]                             invokeRestart(restart)
[17:42:24.703]                             muffled <- TRUE
[17:42:24.703]                             break
[17:42:24.703]                           }
[17:42:24.703]                         }
[17:42:24.703]                       }
[17:42:24.703]                       invisible(muffled)
[17:42:24.703]                     }
[17:42:24.703]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.703]                   }
[17:42:24.703]                 }
[17:42:24.703]                 else {
[17:42:24.703]                   if (TRUE) {
[17:42:24.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.703]                     {
[17:42:24.703]                       inherits <- base::inherits
[17:42:24.703]                       invokeRestart <- base::invokeRestart
[17:42:24.703]                       is.null <- base::is.null
[17:42:24.703]                       muffled <- FALSE
[17:42:24.703]                       if (inherits(cond, "message")) {
[17:42:24.703]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.703]                         if (muffled) 
[17:42:24.703]                           invokeRestart("muffleMessage")
[17:42:24.703]                       }
[17:42:24.703]                       else if (inherits(cond, "warning")) {
[17:42:24.703]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.703]                         if (muffled) 
[17:42:24.703]                           invokeRestart("muffleWarning")
[17:42:24.703]                       }
[17:42:24.703]                       else if (inherits(cond, "condition")) {
[17:42:24.703]                         if (!is.null(pattern)) {
[17:42:24.703]                           computeRestarts <- base::computeRestarts
[17:42:24.703]                           grepl <- base::grepl
[17:42:24.703]                           restarts <- computeRestarts(cond)
[17:42:24.703]                           for (restart in restarts) {
[17:42:24.703]                             name <- restart$name
[17:42:24.703]                             if (is.null(name)) 
[17:42:24.703]                               next
[17:42:24.703]                             if (!grepl(pattern, name)) 
[17:42:24.703]                               next
[17:42:24.703]                             invokeRestart(restart)
[17:42:24.703]                             muffled <- TRUE
[17:42:24.703]                             break
[17:42:24.703]                           }
[17:42:24.703]                         }
[17:42:24.703]                       }
[17:42:24.703]                       invisible(muffled)
[17:42:24.703]                     }
[17:42:24.703]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.703]                   }
[17:42:24.703]                 }
[17:42:24.703]             }
[17:42:24.703]         }))
[17:42:24.703]     }, error = function(ex) {
[17:42:24.703]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.703]                 ...future.rng), started = ...future.startTime, 
[17:42:24.703]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.703]             version = "1.8"), class = "FutureResult")
[17:42:24.703]     }, finally = {
[17:42:24.703]         if (!identical(...future.workdir, getwd())) 
[17:42:24.703]             setwd(...future.workdir)
[17:42:24.703]         {
[17:42:24.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.703]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.703]             }
[17:42:24.703]             base::options(...future.oldOptions)
[17:42:24.703]             if (.Platform$OS.type == "windows") {
[17:42:24.703]                 old_names <- names(...future.oldEnvVars)
[17:42:24.703]                 envs <- base::Sys.getenv()
[17:42:24.703]                 names <- names(envs)
[17:42:24.703]                 common <- intersect(names, old_names)
[17:42:24.703]                 added <- setdiff(names, old_names)
[17:42:24.703]                 removed <- setdiff(old_names, names)
[17:42:24.703]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.703]                   envs[common]]
[17:42:24.703]                 NAMES <- toupper(changed)
[17:42:24.703]                 args <- list()
[17:42:24.703]                 for (kk in seq_along(NAMES)) {
[17:42:24.703]                   name <- changed[[kk]]
[17:42:24.703]                   NAME <- NAMES[[kk]]
[17:42:24.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.703]                     next
[17:42:24.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.703]                 }
[17:42:24.703]                 NAMES <- toupper(added)
[17:42:24.703]                 for (kk in seq_along(NAMES)) {
[17:42:24.703]                   name <- added[[kk]]
[17:42:24.703]                   NAME <- NAMES[[kk]]
[17:42:24.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.703]                     next
[17:42:24.703]                   args[[name]] <- ""
[17:42:24.703]                 }
[17:42:24.703]                 NAMES <- toupper(removed)
[17:42:24.703]                 for (kk in seq_along(NAMES)) {
[17:42:24.703]                   name <- removed[[kk]]
[17:42:24.703]                   NAME <- NAMES[[kk]]
[17:42:24.703]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.703]                     next
[17:42:24.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.703]                 }
[17:42:24.703]                 if (length(args) > 0) 
[17:42:24.703]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.703]             }
[17:42:24.703]             else {
[17:42:24.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.703]             }
[17:42:24.703]             {
[17:42:24.703]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.703]                   0L) {
[17:42:24.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.703]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.703]                   base::options(opts)
[17:42:24.703]                 }
[17:42:24.703]                 {
[17:42:24.703]                   {
[17:42:24.703]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.703]                     NULL
[17:42:24.703]                   }
[17:42:24.703]                   options(future.plan = NULL)
[17:42:24.703]                   if (is.na(NA_character_)) 
[17:42:24.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.703]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.703]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.703]                     envir = parent.frame()) 
[17:42:24.703]                   {
[17:42:24.703]                     if (is.function(workers)) 
[17:42:24.703]                       workers <- workers()
[17:42:24.703]                     workers <- structure(as.integer(workers), 
[17:42:24.703]                       class = class(workers))
[17:42:24.703]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.703]                       workers >= 1)
[17:42:24.703]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.703]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.703]                     }
[17:42:24.703]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.703]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.703]                       envir = envir)
[17:42:24.703]                     if (!future$lazy) 
[17:42:24.703]                       future <- run(future)
[17:42:24.703]                     invisible(future)
[17:42:24.703]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.703]                 }
[17:42:24.703]             }
[17:42:24.703]         }
[17:42:24.703]     })
[17:42:24.703]     if (TRUE) {
[17:42:24.703]         base::sink(type = "output", split = FALSE)
[17:42:24.703]         if (TRUE) {
[17:42:24.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.703]         }
[17:42:24.703]         else {
[17:42:24.703]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.703]         }
[17:42:24.703]         base::close(...future.stdout)
[17:42:24.703]         ...future.stdout <- NULL
[17:42:24.703]     }
[17:42:24.703]     ...future.result$conditions <- ...future.conditions
[17:42:24.703]     ...future.result$finished <- base::Sys.time()
[17:42:24.703]     ...future.result
[17:42:24.703] }
[17:42:24.706] MultisessionFuture started
[17:42:24.706] - Launch lazy future ... done
[17:42:24.707] run() for ‘MultisessionFuture’ ... done
[17:42:24.707] getGlobalsAndPackages() ...
[17:42:24.707] Searching for globals...
[17:42:24.707] 
[17:42:24.707] Searching for globals ... DONE
[17:42:24.707] - globals: [0] <none>
[17:42:24.708] getGlobalsAndPackages() ... DONE
[17:42:24.708] run() for ‘Future’ ...
[17:42:24.708] - state: ‘created’
[17:42:24.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.723]   - Field: ‘node’
[17:42:24.723]   - Field: ‘label’
[17:42:24.723]   - Field: ‘local’
[17:42:24.723]   - Field: ‘owner’
[17:42:24.723]   - Field: ‘envir’
[17:42:24.723]   - Field: ‘workers’
[17:42:24.723]   - Field: ‘packages’
[17:42:24.723]   - Field: ‘gc’
[17:42:24.723]   - Field: ‘conditions’
[17:42:24.723]   - Field: ‘persistent’
[17:42:24.724]   - Field: ‘expr’
[17:42:24.724]   - Field: ‘uuid’
[17:42:24.724]   - Field: ‘seed’
[17:42:24.724]   - Field: ‘version’
[17:42:24.724]   - Field: ‘result’
[17:42:24.724]   - Field: ‘asynchronous’
[17:42:24.724]   - Field: ‘calls’
[17:42:24.724]   - Field: ‘globals’
[17:42:24.724]   - Field: ‘stdout’
[17:42:24.724]   - Field: ‘earlySignal’
[17:42:24.724]   - Field: ‘lazy’
[17:42:24.725]   - Field: ‘state’
[17:42:24.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.725] - Launch lazy future ...
[17:42:24.725] Packages needed by the future expression (n = 0): <none>
[17:42:24.725] Packages needed by future strategies (n = 0): <none>
[17:42:24.726] {
[17:42:24.726]     {
[17:42:24.726]         {
[17:42:24.726]             ...future.startTime <- base::Sys.time()
[17:42:24.726]             {
[17:42:24.726]                 {
[17:42:24.726]                   {
[17:42:24.726]                     {
[17:42:24.726]                       base::local({
[17:42:24.726]                         has_future <- base::requireNamespace("future", 
[17:42:24.726]                           quietly = TRUE)
[17:42:24.726]                         if (has_future) {
[17:42:24.726]                           ns <- base::getNamespace("future")
[17:42:24.726]                           version <- ns[[".package"]][["version"]]
[17:42:24.726]                           if (is.null(version)) 
[17:42:24.726]                             version <- utils::packageVersion("future")
[17:42:24.726]                         }
[17:42:24.726]                         else {
[17:42:24.726]                           version <- NULL
[17:42:24.726]                         }
[17:42:24.726]                         if (!has_future || version < "1.8.0") {
[17:42:24.726]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.726]                             "", base::R.version$version.string), 
[17:42:24.726]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.726]                               "release", "version")], collapse = " "), 
[17:42:24.726]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.726]                             info)
[17:42:24.726]                           info <- base::paste(info, collapse = "; ")
[17:42:24.726]                           if (!has_future) {
[17:42:24.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.726]                               info)
[17:42:24.726]                           }
[17:42:24.726]                           else {
[17:42:24.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.726]                               info, version)
[17:42:24.726]                           }
[17:42:24.726]                           base::stop(msg)
[17:42:24.726]                         }
[17:42:24.726]                       })
[17:42:24.726]                     }
[17:42:24.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.726]                     base::options(mc.cores = 1L)
[17:42:24.726]                   }
[17:42:24.726]                   options(future.plan = NULL)
[17:42:24.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.726]                 }
[17:42:24.726]                 ...future.workdir <- getwd()
[17:42:24.726]             }
[17:42:24.726]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.726]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.726]         }
[17:42:24.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.726]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.726]             base::names(...future.oldOptions))
[17:42:24.726]     }
[17:42:24.726]     if (FALSE) {
[17:42:24.726]     }
[17:42:24.726]     else {
[17:42:24.726]         if (TRUE) {
[17:42:24.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.726]                 open = "w")
[17:42:24.726]         }
[17:42:24.726]         else {
[17:42:24.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.726]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.726]         }
[17:42:24.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.726]             base::sink(type = "output", split = FALSE)
[17:42:24.726]             base::close(...future.stdout)
[17:42:24.726]         }, add = TRUE)
[17:42:24.726]     }
[17:42:24.726]     ...future.frame <- base::sys.nframe()
[17:42:24.726]     ...future.conditions <- base::list()
[17:42:24.726]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.726]     if (FALSE) {
[17:42:24.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.726]     }
[17:42:24.726]     ...future.result <- base::tryCatch({
[17:42:24.726]         base::withCallingHandlers({
[17:42:24.726]             ...future.value <- base::withVisible(base::local({
[17:42:24.726]                 ...future.makeSendCondition <- local({
[17:42:24.726]                   sendCondition <- NULL
[17:42:24.726]                   function(frame = 1L) {
[17:42:24.726]                     if (is.function(sendCondition)) 
[17:42:24.726]                       return(sendCondition)
[17:42:24.726]                     ns <- getNamespace("parallel")
[17:42:24.726]                     if (exists("sendData", mode = "function", 
[17:42:24.726]                       envir = ns)) {
[17:42:24.726]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.726]                         envir = ns)
[17:42:24.726]                       envir <- sys.frame(frame)
[17:42:24.726]                       master <- NULL
[17:42:24.726]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.726]                         !identical(envir, emptyenv())) {
[17:42:24.726]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.726]                           inherits = FALSE)) {
[17:42:24.726]                           master <- get("master", mode = "list", 
[17:42:24.726]                             envir = envir, inherits = FALSE)
[17:42:24.726]                           if (inherits(master, c("SOCKnode", 
[17:42:24.726]                             "SOCK0node"))) {
[17:42:24.726]                             sendCondition <<- function(cond) {
[17:42:24.726]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.726]                                 success = TRUE)
[17:42:24.726]                               parallel_sendData(master, data)
[17:42:24.726]                             }
[17:42:24.726]                             return(sendCondition)
[17:42:24.726]                           }
[17:42:24.726]                         }
[17:42:24.726]                         frame <- frame + 1L
[17:42:24.726]                         envir <- sys.frame(frame)
[17:42:24.726]                       }
[17:42:24.726]                     }
[17:42:24.726]                     sendCondition <<- function(cond) NULL
[17:42:24.726]                   }
[17:42:24.726]                 })
[17:42:24.726]                 withCallingHandlers({
[17:42:24.726]                   NULL
[17:42:24.726]                 }, immediateCondition = function(cond) {
[17:42:24.726]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.726]                   sendCondition(cond)
[17:42:24.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.726]                   {
[17:42:24.726]                     inherits <- base::inherits
[17:42:24.726]                     invokeRestart <- base::invokeRestart
[17:42:24.726]                     is.null <- base::is.null
[17:42:24.726]                     muffled <- FALSE
[17:42:24.726]                     if (inherits(cond, "message")) {
[17:42:24.726]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.726]                       if (muffled) 
[17:42:24.726]                         invokeRestart("muffleMessage")
[17:42:24.726]                     }
[17:42:24.726]                     else if (inherits(cond, "warning")) {
[17:42:24.726]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.726]                       if (muffled) 
[17:42:24.726]                         invokeRestart("muffleWarning")
[17:42:24.726]                     }
[17:42:24.726]                     else if (inherits(cond, "condition")) {
[17:42:24.726]                       if (!is.null(pattern)) {
[17:42:24.726]                         computeRestarts <- base::computeRestarts
[17:42:24.726]                         grepl <- base::grepl
[17:42:24.726]                         restarts <- computeRestarts(cond)
[17:42:24.726]                         for (restart in restarts) {
[17:42:24.726]                           name <- restart$name
[17:42:24.726]                           if (is.null(name)) 
[17:42:24.726]                             next
[17:42:24.726]                           if (!grepl(pattern, name)) 
[17:42:24.726]                             next
[17:42:24.726]                           invokeRestart(restart)
[17:42:24.726]                           muffled <- TRUE
[17:42:24.726]                           break
[17:42:24.726]                         }
[17:42:24.726]                       }
[17:42:24.726]                     }
[17:42:24.726]                     invisible(muffled)
[17:42:24.726]                   }
[17:42:24.726]                   muffleCondition(cond)
[17:42:24.726]                 })
[17:42:24.726]             }))
[17:42:24.726]             future::FutureResult(value = ...future.value$value, 
[17:42:24.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.726]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.726]                     ...future.globalenv.names))
[17:42:24.726]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.726]         }, condition = base::local({
[17:42:24.726]             c <- base::c
[17:42:24.726]             inherits <- base::inherits
[17:42:24.726]             invokeRestart <- base::invokeRestart
[17:42:24.726]             length <- base::length
[17:42:24.726]             list <- base::list
[17:42:24.726]             seq.int <- base::seq.int
[17:42:24.726]             signalCondition <- base::signalCondition
[17:42:24.726]             sys.calls <- base::sys.calls
[17:42:24.726]             `[[` <- base::`[[`
[17:42:24.726]             `+` <- base::`+`
[17:42:24.726]             `<<-` <- base::`<<-`
[17:42:24.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.726]                   3L)]
[17:42:24.726]             }
[17:42:24.726]             function(cond) {
[17:42:24.726]                 is_error <- inherits(cond, "error")
[17:42:24.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.726]                   NULL)
[17:42:24.726]                 if (is_error) {
[17:42:24.726]                   sessionInformation <- function() {
[17:42:24.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.726]                       search = base::search(), system = base::Sys.info())
[17:42:24.726]                   }
[17:42:24.726]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.726]                     cond$call), session = sessionInformation(), 
[17:42:24.726]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.726]                   signalCondition(cond)
[17:42:24.726]                 }
[17:42:24.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.726]                 "immediateCondition"))) {
[17:42:24.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.726]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.726]                   if (TRUE && !signal) {
[17:42:24.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.726]                     {
[17:42:24.726]                       inherits <- base::inherits
[17:42:24.726]                       invokeRestart <- base::invokeRestart
[17:42:24.726]                       is.null <- base::is.null
[17:42:24.726]                       muffled <- FALSE
[17:42:24.726]                       if (inherits(cond, "message")) {
[17:42:24.726]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.726]                         if (muffled) 
[17:42:24.726]                           invokeRestart("muffleMessage")
[17:42:24.726]                       }
[17:42:24.726]                       else if (inherits(cond, "warning")) {
[17:42:24.726]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.726]                         if (muffled) 
[17:42:24.726]                           invokeRestart("muffleWarning")
[17:42:24.726]                       }
[17:42:24.726]                       else if (inherits(cond, "condition")) {
[17:42:24.726]                         if (!is.null(pattern)) {
[17:42:24.726]                           computeRestarts <- base::computeRestarts
[17:42:24.726]                           grepl <- base::grepl
[17:42:24.726]                           restarts <- computeRestarts(cond)
[17:42:24.726]                           for (restart in restarts) {
[17:42:24.726]                             name <- restart$name
[17:42:24.726]                             if (is.null(name)) 
[17:42:24.726]                               next
[17:42:24.726]                             if (!grepl(pattern, name)) 
[17:42:24.726]                               next
[17:42:24.726]                             invokeRestart(restart)
[17:42:24.726]                             muffled <- TRUE
[17:42:24.726]                             break
[17:42:24.726]                           }
[17:42:24.726]                         }
[17:42:24.726]                       }
[17:42:24.726]                       invisible(muffled)
[17:42:24.726]                     }
[17:42:24.726]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.726]                   }
[17:42:24.726]                 }
[17:42:24.726]                 else {
[17:42:24.726]                   if (TRUE) {
[17:42:24.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.726]                     {
[17:42:24.726]                       inherits <- base::inherits
[17:42:24.726]                       invokeRestart <- base::invokeRestart
[17:42:24.726]                       is.null <- base::is.null
[17:42:24.726]                       muffled <- FALSE
[17:42:24.726]                       if (inherits(cond, "message")) {
[17:42:24.726]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.726]                         if (muffled) 
[17:42:24.726]                           invokeRestart("muffleMessage")
[17:42:24.726]                       }
[17:42:24.726]                       else if (inherits(cond, "warning")) {
[17:42:24.726]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.726]                         if (muffled) 
[17:42:24.726]                           invokeRestart("muffleWarning")
[17:42:24.726]                       }
[17:42:24.726]                       else if (inherits(cond, "condition")) {
[17:42:24.726]                         if (!is.null(pattern)) {
[17:42:24.726]                           computeRestarts <- base::computeRestarts
[17:42:24.726]                           grepl <- base::grepl
[17:42:24.726]                           restarts <- computeRestarts(cond)
[17:42:24.726]                           for (restart in restarts) {
[17:42:24.726]                             name <- restart$name
[17:42:24.726]                             if (is.null(name)) 
[17:42:24.726]                               next
[17:42:24.726]                             if (!grepl(pattern, name)) 
[17:42:24.726]                               next
[17:42:24.726]                             invokeRestart(restart)
[17:42:24.726]                             muffled <- TRUE
[17:42:24.726]                             break
[17:42:24.726]                           }
[17:42:24.726]                         }
[17:42:24.726]                       }
[17:42:24.726]                       invisible(muffled)
[17:42:24.726]                     }
[17:42:24.726]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.726]                   }
[17:42:24.726]                 }
[17:42:24.726]             }
[17:42:24.726]         }))
[17:42:24.726]     }, error = function(ex) {
[17:42:24.726]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.726]                 ...future.rng), started = ...future.startTime, 
[17:42:24.726]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.726]             version = "1.8"), class = "FutureResult")
[17:42:24.726]     }, finally = {
[17:42:24.726]         if (!identical(...future.workdir, getwd())) 
[17:42:24.726]             setwd(...future.workdir)
[17:42:24.726]         {
[17:42:24.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.726]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.726]             }
[17:42:24.726]             base::options(...future.oldOptions)
[17:42:24.726]             if (.Platform$OS.type == "windows") {
[17:42:24.726]                 old_names <- names(...future.oldEnvVars)
[17:42:24.726]                 envs <- base::Sys.getenv()
[17:42:24.726]                 names <- names(envs)
[17:42:24.726]                 common <- intersect(names, old_names)
[17:42:24.726]                 added <- setdiff(names, old_names)
[17:42:24.726]                 removed <- setdiff(old_names, names)
[17:42:24.726]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.726]                   envs[common]]
[17:42:24.726]                 NAMES <- toupper(changed)
[17:42:24.726]                 args <- list()
[17:42:24.726]                 for (kk in seq_along(NAMES)) {
[17:42:24.726]                   name <- changed[[kk]]
[17:42:24.726]                   NAME <- NAMES[[kk]]
[17:42:24.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.726]                     next
[17:42:24.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.726]                 }
[17:42:24.726]                 NAMES <- toupper(added)
[17:42:24.726]                 for (kk in seq_along(NAMES)) {
[17:42:24.726]                   name <- added[[kk]]
[17:42:24.726]                   NAME <- NAMES[[kk]]
[17:42:24.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.726]                     next
[17:42:24.726]                   args[[name]] <- ""
[17:42:24.726]                 }
[17:42:24.726]                 NAMES <- toupper(removed)
[17:42:24.726]                 for (kk in seq_along(NAMES)) {
[17:42:24.726]                   name <- removed[[kk]]
[17:42:24.726]                   NAME <- NAMES[[kk]]
[17:42:24.726]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.726]                     next
[17:42:24.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.726]                 }
[17:42:24.726]                 if (length(args) > 0) 
[17:42:24.726]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.726]             }
[17:42:24.726]             else {
[17:42:24.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.726]             }
[17:42:24.726]             {
[17:42:24.726]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.726]                   0L) {
[17:42:24.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.726]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.726]                   base::options(opts)
[17:42:24.726]                 }
[17:42:24.726]                 {
[17:42:24.726]                   {
[17:42:24.726]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.726]                     NULL
[17:42:24.726]                   }
[17:42:24.726]                   options(future.plan = NULL)
[17:42:24.726]                   if (is.na(NA_character_)) 
[17:42:24.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.726]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.726]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.726]                     envir = parent.frame()) 
[17:42:24.726]                   {
[17:42:24.726]                     if (is.function(workers)) 
[17:42:24.726]                       workers <- workers()
[17:42:24.726]                     workers <- structure(as.integer(workers), 
[17:42:24.726]                       class = class(workers))
[17:42:24.726]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.726]                       workers >= 1)
[17:42:24.726]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.726]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.726]                     }
[17:42:24.726]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.726]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.726]                       envir = envir)
[17:42:24.726]                     if (!future$lazy) 
[17:42:24.726]                       future <- run(future)
[17:42:24.726]                     invisible(future)
[17:42:24.726]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.726]                 }
[17:42:24.726]             }
[17:42:24.726]         }
[17:42:24.726]     })
[17:42:24.726]     if (TRUE) {
[17:42:24.726]         base::sink(type = "output", split = FALSE)
[17:42:24.726]         if (TRUE) {
[17:42:24.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.726]         }
[17:42:24.726]         else {
[17:42:24.726]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.726]         }
[17:42:24.726]         base::close(...future.stdout)
[17:42:24.726]         ...future.stdout <- NULL
[17:42:24.726]     }
[17:42:24.726]     ...future.result$conditions <- ...future.conditions
[17:42:24.726]     ...future.result$finished <- base::Sys.time()
[17:42:24.726]     ...future.result
[17:42:24.726] }
[17:42:24.732] MultisessionFuture started
[17:42:24.732] - Launch lazy future ... done
[17:42:24.732] run() for ‘MultisessionFuture’ ... done
[17:42:24.733] getGlobalsAndPackages() ...
[17:42:24.733] Searching for globals...
[17:42:24.733] - globals found: [1] ‘{’
[17:42:24.734] Searching for globals ... DONE
[17:42:24.734] Resolving globals: FALSE
[17:42:24.734] 
[17:42:24.734] 
[17:42:24.734] getGlobalsAndPackages() ... DONE
[17:42:24.734] run() for ‘Future’ ...
[17:42:24.735] - state: ‘created’
[17:42:24.735] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.751] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.751]   - Field: ‘node’
[17:42:24.751]   - Field: ‘label’
[17:42:24.751]   - Field: ‘local’
[17:42:24.751]   - Field: ‘owner’
[17:42:24.752]   - Field: ‘envir’
[17:42:24.752]   - Field: ‘workers’
[17:42:24.752]   - Field: ‘packages’
[17:42:24.752]   - Field: ‘gc’
[17:42:24.752]   - Field: ‘conditions’
[17:42:24.753]   - Field: ‘persistent’
[17:42:24.753]   - Field: ‘expr’
[17:42:24.753]   - Field: ‘uuid’
[17:42:24.753]   - Field: ‘seed’
[17:42:24.753]   - Field: ‘version’
[17:42:24.754]   - Field: ‘result’
[17:42:24.754]   - Field: ‘asynchronous’
[17:42:24.754]   - Field: ‘calls’
[17:42:24.754]   - Field: ‘globals’
[17:42:24.754]   - Field: ‘stdout’
[17:42:24.754]   - Field: ‘earlySignal’
[17:42:24.754]   - Field: ‘lazy’
[17:42:24.754]   - Field: ‘state’
[17:42:24.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.754] - Launch lazy future ...
[17:42:24.755] Packages needed by the future expression (n = 0): <none>
[17:42:24.755] Packages needed by future strategies (n = 0): <none>
[17:42:24.755] {
[17:42:24.755]     {
[17:42:24.755]         {
[17:42:24.755]             ...future.startTime <- base::Sys.time()
[17:42:24.755]             {
[17:42:24.755]                 {
[17:42:24.755]                   {
[17:42:24.755]                     {
[17:42:24.755]                       base::local({
[17:42:24.755]                         has_future <- base::requireNamespace("future", 
[17:42:24.755]                           quietly = TRUE)
[17:42:24.755]                         if (has_future) {
[17:42:24.755]                           ns <- base::getNamespace("future")
[17:42:24.755]                           version <- ns[[".package"]][["version"]]
[17:42:24.755]                           if (is.null(version)) 
[17:42:24.755]                             version <- utils::packageVersion("future")
[17:42:24.755]                         }
[17:42:24.755]                         else {
[17:42:24.755]                           version <- NULL
[17:42:24.755]                         }
[17:42:24.755]                         if (!has_future || version < "1.8.0") {
[17:42:24.755]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.755]                             "", base::R.version$version.string), 
[17:42:24.755]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.755]                               "release", "version")], collapse = " "), 
[17:42:24.755]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.755]                             info)
[17:42:24.755]                           info <- base::paste(info, collapse = "; ")
[17:42:24.755]                           if (!has_future) {
[17:42:24.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.755]                               info)
[17:42:24.755]                           }
[17:42:24.755]                           else {
[17:42:24.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.755]                               info, version)
[17:42:24.755]                           }
[17:42:24.755]                           base::stop(msg)
[17:42:24.755]                         }
[17:42:24.755]                       })
[17:42:24.755]                     }
[17:42:24.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.755]                     base::options(mc.cores = 1L)
[17:42:24.755]                   }
[17:42:24.755]                   options(future.plan = NULL)
[17:42:24.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.755]                 }
[17:42:24.755]                 ...future.workdir <- getwd()
[17:42:24.755]             }
[17:42:24.755]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.755]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.755]         }
[17:42:24.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.755]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.755]             base::names(...future.oldOptions))
[17:42:24.755]     }
[17:42:24.755]     if (FALSE) {
[17:42:24.755]     }
[17:42:24.755]     else {
[17:42:24.755]         if (TRUE) {
[17:42:24.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.755]                 open = "w")
[17:42:24.755]         }
[17:42:24.755]         else {
[17:42:24.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.755]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.755]         }
[17:42:24.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.755]             base::sink(type = "output", split = FALSE)
[17:42:24.755]             base::close(...future.stdout)
[17:42:24.755]         }, add = TRUE)
[17:42:24.755]     }
[17:42:24.755]     ...future.frame <- base::sys.nframe()
[17:42:24.755]     ...future.conditions <- base::list()
[17:42:24.755]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.755]     if (FALSE) {
[17:42:24.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.755]     }
[17:42:24.755]     ...future.result <- base::tryCatch({
[17:42:24.755]         base::withCallingHandlers({
[17:42:24.755]             ...future.value <- base::withVisible(base::local({
[17:42:24.755]                 ...future.makeSendCondition <- local({
[17:42:24.755]                   sendCondition <- NULL
[17:42:24.755]                   function(frame = 1L) {
[17:42:24.755]                     if (is.function(sendCondition)) 
[17:42:24.755]                       return(sendCondition)
[17:42:24.755]                     ns <- getNamespace("parallel")
[17:42:24.755]                     if (exists("sendData", mode = "function", 
[17:42:24.755]                       envir = ns)) {
[17:42:24.755]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.755]                         envir = ns)
[17:42:24.755]                       envir <- sys.frame(frame)
[17:42:24.755]                       master <- NULL
[17:42:24.755]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.755]                         !identical(envir, emptyenv())) {
[17:42:24.755]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.755]                           inherits = FALSE)) {
[17:42:24.755]                           master <- get("master", mode = "list", 
[17:42:24.755]                             envir = envir, inherits = FALSE)
[17:42:24.755]                           if (inherits(master, c("SOCKnode", 
[17:42:24.755]                             "SOCK0node"))) {
[17:42:24.755]                             sendCondition <<- function(cond) {
[17:42:24.755]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.755]                                 success = TRUE)
[17:42:24.755]                               parallel_sendData(master, data)
[17:42:24.755]                             }
[17:42:24.755]                             return(sendCondition)
[17:42:24.755]                           }
[17:42:24.755]                         }
[17:42:24.755]                         frame <- frame + 1L
[17:42:24.755]                         envir <- sys.frame(frame)
[17:42:24.755]                       }
[17:42:24.755]                     }
[17:42:24.755]                     sendCondition <<- function(cond) NULL
[17:42:24.755]                   }
[17:42:24.755]                 })
[17:42:24.755]                 withCallingHandlers({
[17:42:24.755]                   {
[17:42:24.755]                     4
[17:42:24.755]                   }
[17:42:24.755]                 }, immediateCondition = function(cond) {
[17:42:24.755]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.755]                   sendCondition(cond)
[17:42:24.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.755]                   {
[17:42:24.755]                     inherits <- base::inherits
[17:42:24.755]                     invokeRestart <- base::invokeRestart
[17:42:24.755]                     is.null <- base::is.null
[17:42:24.755]                     muffled <- FALSE
[17:42:24.755]                     if (inherits(cond, "message")) {
[17:42:24.755]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.755]                       if (muffled) 
[17:42:24.755]                         invokeRestart("muffleMessage")
[17:42:24.755]                     }
[17:42:24.755]                     else if (inherits(cond, "warning")) {
[17:42:24.755]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.755]                       if (muffled) 
[17:42:24.755]                         invokeRestart("muffleWarning")
[17:42:24.755]                     }
[17:42:24.755]                     else if (inherits(cond, "condition")) {
[17:42:24.755]                       if (!is.null(pattern)) {
[17:42:24.755]                         computeRestarts <- base::computeRestarts
[17:42:24.755]                         grepl <- base::grepl
[17:42:24.755]                         restarts <- computeRestarts(cond)
[17:42:24.755]                         for (restart in restarts) {
[17:42:24.755]                           name <- restart$name
[17:42:24.755]                           if (is.null(name)) 
[17:42:24.755]                             next
[17:42:24.755]                           if (!grepl(pattern, name)) 
[17:42:24.755]                             next
[17:42:24.755]                           invokeRestart(restart)
[17:42:24.755]                           muffled <- TRUE
[17:42:24.755]                           break
[17:42:24.755]                         }
[17:42:24.755]                       }
[17:42:24.755]                     }
[17:42:24.755]                     invisible(muffled)
[17:42:24.755]                   }
[17:42:24.755]                   muffleCondition(cond)
[17:42:24.755]                 })
[17:42:24.755]             }))
[17:42:24.755]             future::FutureResult(value = ...future.value$value, 
[17:42:24.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.755]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.755]                     ...future.globalenv.names))
[17:42:24.755]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.755]         }, condition = base::local({
[17:42:24.755]             c <- base::c
[17:42:24.755]             inherits <- base::inherits
[17:42:24.755]             invokeRestart <- base::invokeRestart
[17:42:24.755]             length <- base::length
[17:42:24.755]             list <- base::list
[17:42:24.755]             seq.int <- base::seq.int
[17:42:24.755]             signalCondition <- base::signalCondition
[17:42:24.755]             sys.calls <- base::sys.calls
[17:42:24.755]             `[[` <- base::`[[`
[17:42:24.755]             `+` <- base::`+`
[17:42:24.755]             `<<-` <- base::`<<-`
[17:42:24.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.755]                   3L)]
[17:42:24.755]             }
[17:42:24.755]             function(cond) {
[17:42:24.755]                 is_error <- inherits(cond, "error")
[17:42:24.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.755]                   NULL)
[17:42:24.755]                 if (is_error) {
[17:42:24.755]                   sessionInformation <- function() {
[17:42:24.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.755]                       search = base::search(), system = base::Sys.info())
[17:42:24.755]                   }
[17:42:24.755]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.755]                     cond$call), session = sessionInformation(), 
[17:42:24.755]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.755]                   signalCondition(cond)
[17:42:24.755]                 }
[17:42:24.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.755]                 "immediateCondition"))) {
[17:42:24.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.755]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.755]                   if (TRUE && !signal) {
[17:42:24.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.755]                     {
[17:42:24.755]                       inherits <- base::inherits
[17:42:24.755]                       invokeRestart <- base::invokeRestart
[17:42:24.755]                       is.null <- base::is.null
[17:42:24.755]                       muffled <- FALSE
[17:42:24.755]                       if (inherits(cond, "message")) {
[17:42:24.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.755]                         if (muffled) 
[17:42:24.755]                           invokeRestart("muffleMessage")
[17:42:24.755]                       }
[17:42:24.755]                       else if (inherits(cond, "warning")) {
[17:42:24.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.755]                         if (muffled) 
[17:42:24.755]                           invokeRestart("muffleWarning")
[17:42:24.755]                       }
[17:42:24.755]                       else if (inherits(cond, "condition")) {
[17:42:24.755]                         if (!is.null(pattern)) {
[17:42:24.755]                           computeRestarts <- base::computeRestarts
[17:42:24.755]                           grepl <- base::grepl
[17:42:24.755]                           restarts <- computeRestarts(cond)
[17:42:24.755]                           for (restart in restarts) {
[17:42:24.755]                             name <- restart$name
[17:42:24.755]                             if (is.null(name)) 
[17:42:24.755]                               next
[17:42:24.755]                             if (!grepl(pattern, name)) 
[17:42:24.755]                               next
[17:42:24.755]                             invokeRestart(restart)
[17:42:24.755]                             muffled <- TRUE
[17:42:24.755]                             break
[17:42:24.755]                           }
[17:42:24.755]                         }
[17:42:24.755]                       }
[17:42:24.755]                       invisible(muffled)
[17:42:24.755]                     }
[17:42:24.755]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.755]                   }
[17:42:24.755]                 }
[17:42:24.755]                 else {
[17:42:24.755]                   if (TRUE) {
[17:42:24.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.755]                     {
[17:42:24.755]                       inherits <- base::inherits
[17:42:24.755]                       invokeRestart <- base::invokeRestart
[17:42:24.755]                       is.null <- base::is.null
[17:42:24.755]                       muffled <- FALSE
[17:42:24.755]                       if (inherits(cond, "message")) {
[17:42:24.755]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.755]                         if (muffled) 
[17:42:24.755]                           invokeRestart("muffleMessage")
[17:42:24.755]                       }
[17:42:24.755]                       else if (inherits(cond, "warning")) {
[17:42:24.755]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.755]                         if (muffled) 
[17:42:24.755]                           invokeRestart("muffleWarning")
[17:42:24.755]                       }
[17:42:24.755]                       else if (inherits(cond, "condition")) {
[17:42:24.755]                         if (!is.null(pattern)) {
[17:42:24.755]                           computeRestarts <- base::computeRestarts
[17:42:24.755]                           grepl <- base::grepl
[17:42:24.755]                           restarts <- computeRestarts(cond)
[17:42:24.755]                           for (restart in restarts) {
[17:42:24.755]                             name <- restart$name
[17:42:24.755]                             if (is.null(name)) 
[17:42:24.755]                               next
[17:42:24.755]                             if (!grepl(pattern, name)) 
[17:42:24.755]                               next
[17:42:24.755]                             invokeRestart(restart)
[17:42:24.755]                             muffled <- TRUE
[17:42:24.755]                             break
[17:42:24.755]                           }
[17:42:24.755]                         }
[17:42:24.755]                       }
[17:42:24.755]                       invisible(muffled)
[17:42:24.755]                     }
[17:42:24.755]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.755]                   }
[17:42:24.755]                 }
[17:42:24.755]             }
[17:42:24.755]         }))
[17:42:24.755]     }, error = function(ex) {
[17:42:24.755]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.755]                 ...future.rng), started = ...future.startTime, 
[17:42:24.755]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.755]             version = "1.8"), class = "FutureResult")
[17:42:24.755]     }, finally = {
[17:42:24.755]         if (!identical(...future.workdir, getwd())) 
[17:42:24.755]             setwd(...future.workdir)
[17:42:24.755]         {
[17:42:24.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.755]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.755]             }
[17:42:24.755]             base::options(...future.oldOptions)
[17:42:24.755]             if (.Platform$OS.type == "windows") {
[17:42:24.755]                 old_names <- names(...future.oldEnvVars)
[17:42:24.755]                 envs <- base::Sys.getenv()
[17:42:24.755]                 names <- names(envs)
[17:42:24.755]                 common <- intersect(names, old_names)
[17:42:24.755]                 added <- setdiff(names, old_names)
[17:42:24.755]                 removed <- setdiff(old_names, names)
[17:42:24.755]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.755]                   envs[common]]
[17:42:24.755]                 NAMES <- toupper(changed)
[17:42:24.755]                 args <- list()
[17:42:24.755]                 for (kk in seq_along(NAMES)) {
[17:42:24.755]                   name <- changed[[kk]]
[17:42:24.755]                   NAME <- NAMES[[kk]]
[17:42:24.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.755]                     next
[17:42:24.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.755]                 }
[17:42:24.755]                 NAMES <- toupper(added)
[17:42:24.755]                 for (kk in seq_along(NAMES)) {
[17:42:24.755]                   name <- added[[kk]]
[17:42:24.755]                   NAME <- NAMES[[kk]]
[17:42:24.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.755]                     next
[17:42:24.755]                   args[[name]] <- ""
[17:42:24.755]                 }
[17:42:24.755]                 NAMES <- toupper(removed)
[17:42:24.755]                 for (kk in seq_along(NAMES)) {
[17:42:24.755]                   name <- removed[[kk]]
[17:42:24.755]                   NAME <- NAMES[[kk]]
[17:42:24.755]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.755]                     next
[17:42:24.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.755]                 }
[17:42:24.755]                 if (length(args) > 0) 
[17:42:24.755]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.755]             }
[17:42:24.755]             else {
[17:42:24.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.755]             }
[17:42:24.755]             {
[17:42:24.755]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.755]                   0L) {
[17:42:24.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.755]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.755]                   base::options(opts)
[17:42:24.755]                 }
[17:42:24.755]                 {
[17:42:24.755]                   {
[17:42:24.755]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.755]                     NULL
[17:42:24.755]                   }
[17:42:24.755]                   options(future.plan = NULL)
[17:42:24.755]                   if (is.na(NA_character_)) 
[17:42:24.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.755]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.755]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.755]                     envir = parent.frame()) 
[17:42:24.755]                   {
[17:42:24.755]                     if (is.function(workers)) 
[17:42:24.755]                       workers <- workers()
[17:42:24.755]                     workers <- structure(as.integer(workers), 
[17:42:24.755]                       class = class(workers))
[17:42:24.755]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.755]                       workers >= 1)
[17:42:24.755]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.755]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.755]                     }
[17:42:24.755]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.755]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.755]                       envir = envir)
[17:42:24.755]                     if (!future$lazy) 
[17:42:24.755]                       future <- run(future)
[17:42:24.755]                     invisible(future)
[17:42:24.755]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.755]                 }
[17:42:24.755]             }
[17:42:24.755]         }
[17:42:24.755]     })
[17:42:24.755]     if (TRUE) {
[17:42:24.755]         base::sink(type = "output", split = FALSE)
[17:42:24.755]         if (TRUE) {
[17:42:24.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.755]         }
[17:42:24.755]         else {
[17:42:24.755]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.755]         }
[17:42:24.755]         base::close(...future.stdout)
[17:42:24.755]         ...future.stdout <- NULL
[17:42:24.755]     }
[17:42:24.755]     ...future.result$conditions <- ...future.conditions
[17:42:24.755]     ...future.result$finished <- base::Sys.time()
[17:42:24.755]     ...future.result
[17:42:24.755] }
[17:42:24.758] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:24.768] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.769] - Validating connection of MultisessionFuture
[17:42:24.769] - received message: FutureResult
[17:42:24.769] - Received FutureResult
[17:42:24.769] - Erased future from FutureRegistry
[17:42:24.769] result() for ClusterFuture ...
[17:42:24.769] - result already collected: FutureResult
[17:42:24.769] result() for ClusterFuture ... done
[17:42:24.769] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.770] result() for ClusterFuture ...
[17:42:24.770] - result already collected: FutureResult
[17:42:24.770] result() for ClusterFuture ... done
[17:42:24.770] result() for ClusterFuture ...
[17:42:24.770] - result already collected: FutureResult
[17:42:24.770] result() for ClusterFuture ... done
[17:42:24.771] MultisessionFuture started
[17:42:24.771] - Launch lazy future ... done
[17:42:24.772] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef98955d0> 
Classes 'listenv', 'environment' <environment: 0x55bef7f18a98> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:24.780] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.780] - Validating connection of MultisessionFuture
[17:42:24.780] - received message: FutureResult
[17:42:24.780] - Received FutureResult
[17:42:24.781] - Erased future from FutureRegistry
[17:42:24.781] result() for ClusterFuture ...
[17:42:24.781] - result already collected: FutureResult
[17:42:24.781] result() for ClusterFuture ... done
[17:42:24.781] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:24.794] resolve() on list environment ...
[17:42:24.794]  recursive: 0
[17:42:24.795]  length: 6
[17:42:24.795]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:24.795] signalConditionsASAP(numeric, pos=1) ...
[17:42:24.795] - nx: 6
[17:42:24.796] - relay: TRUE
[17:42:24.796] - stdout: TRUE
[17:42:24.796] - signal: TRUE
[17:42:24.796] - resignal: FALSE
[17:42:24.796] - force: TRUE
[17:42:24.796] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.796] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.796]  - until=2
[17:42:24.796]  - relaying element #2
[17:42:24.796] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.796] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.797] signalConditionsASAP(NULL, pos=1) ... done
[17:42:24.797]  length: 5 (resolved future 1)
[17:42:24.797] Future #2
[17:42:24.797] result() for ClusterFuture ...
[17:42:24.797] - result already collected: FutureResult
[17:42:24.797] result() for ClusterFuture ... done
[17:42:24.797] result() for ClusterFuture ...
[17:42:24.797] - result already collected: FutureResult
[17:42:24.797] result() for ClusterFuture ... done
[17:42:24.797] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:24.798] - nx: 6
[17:42:24.798] - relay: TRUE
[17:42:24.798] - stdout: TRUE
[17:42:24.798] - signal: TRUE
[17:42:24.798] - resignal: FALSE
[17:42:24.798] - force: TRUE
[17:42:24.798] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.798] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.798]  - until=2
[17:42:24.798]  - relaying element #2
[17:42:24.798] result() for ClusterFuture ...
[17:42:24.798] - result already collected: FutureResult
[17:42:24.799] result() for ClusterFuture ... done
[17:42:24.799] result() for ClusterFuture ...
[17:42:24.799] - result already collected: FutureResult
[17:42:24.799] result() for ClusterFuture ... done
[17:42:24.799] result() for ClusterFuture ...
[17:42:24.799] - result already collected: FutureResult
[17:42:24.799] result() for ClusterFuture ... done
[17:42:24.799] result() for ClusterFuture ...
[17:42:24.799] - result already collected: FutureResult
[17:42:24.799] result() for ClusterFuture ... done
[17:42:24.799] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.800] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.800] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:24.800]  length: 4 (resolved future 2)
[17:42:24.800] Future #3
[17:42:24.800] result() for ClusterFuture ...
[17:42:24.800] - result already collected: FutureResult
[17:42:24.800] result() for ClusterFuture ... done
[17:42:24.800] result() for ClusterFuture ...
[17:42:24.800] - result already collected: FutureResult
[17:42:24.800] result() for ClusterFuture ... done
[17:42:24.801] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:24.801] - nx: 6
[17:42:24.801] - relay: TRUE
[17:42:24.801] - stdout: TRUE
[17:42:24.801] - signal: TRUE
[17:42:24.801] - resignal: FALSE
[17:42:24.801] - force: TRUE
[17:42:24.801] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.801] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.801]  - until=3
[17:42:24.801]  - relaying element #3
[17:42:24.802] result() for ClusterFuture ...
[17:42:24.802] - result already collected: FutureResult
[17:42:24.802] result() for ClusterFuture ... done
[17:42:24.802] result() for ClusterFuture ...
[17:42:24.802] - result already collected: FutureResult
[17:42:24.802] result() for ClusterFuture ... done
[17:42:24.802] result() for ClusterFuture ...
[17:42:24.802] - result already collected: FutureResult
[17:42:24.802] result() for ClusterFuture ... done
[17:42:24.802] result() for ClusterFuture ...
[17:42:24.802] - result already collected: FutureResult
[17:42:24.802] result() for ClusterFuture ... done
[17:42:24.803] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.803] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.803] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:24.803]  length: 3 (resolved future 3)
[17:42:24.813] signalConditionsASAP(NULL, pos=5) ...
[17:42:24.814] - nx: 6
[17:42:24.814] - relay: TRUE
[17:42:24.814] - stdout: TRUE
[17:42:24.814] - signal: TRUE
[17:42:24.814] - resignal: FALSE
[17:42:24.814] - force: TRUE
[17:42:24.814] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.814] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.814]  - until=6
[17:42:24.815]  - relaying element #4
[17:42:24.815]  - relaying element #6
[17:42:24.815] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.815] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.815] signalConditionsASAP(NULL, pos=5) ... done
[17:42:24.815]  length: 2 (resolved future 5)
[17:42:24.815] signalConditionsASAP(numeric, pos=6) ...
[17:42:24.816] - nx: 6
[17:42:24.816] - relay: TRUE
[17:42:24.816] - stdout: TRUE
[17:42:24.816] - signal: TRUE
[17:42:24.816] - resignal: FALSE
[17:42:24.816] - force: TRUE
[17:42:24.816] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.817] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.817]  - until=6
[17:42:24.817]  - relaying element #4
[17:42:24.817] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.817] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.817] signalConditionsASAP(NULL, pos=6) ... done
[17:42:24.817]  length: 1 (resolved future 6)
[17:42:24.828] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.828] - Validating connection of MultisessionFuture
[17:42:24.828] - received message: FutureResult
[17:42:24.829] - Received FutureResult
[17:42:24.829] - Erased future from FutureRegistry
[17:42:24.829] result() for ClusterFuture ...
[17:42:24.829] - result already collected: FutureResult
[17:42:24.829] result() for ClusterFuture ... done
[17:42:24.829] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.829] Future #4
[17:42:24.829] result() for ClusterFuture ...
[17:42:24.829] - result already collected: FutureResult
[17:42:24.829] result() for ClusterFuture ... done
[17:42:24.830] result() for ClusterFuture ...
[17:42:24.830] - result already collected: FutureResult
[17:42:24.830] result() for ClusterFuture ... done
[17:42:24.830] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:24.830] - nx: 6
[17:42:24.830] - relay: TRUE
[17:42:24.830] - stdout: TRUE
[17:42:24.830] - signal: TRUE
[17:42:24.830] - resignal: FALSE
[17:42:24.830] - force: TRUE
[17:42:24.830] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.830] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.831]  - until=6
[17:42:24.831]  - relaying element #4
[17:42:24.831] result() for ClusterFuture ...
[17:42:24.831] - result already collected: FutureResult
[17:42:24.831] result() for ClusterFuture ... done
[17:42:24.831] result() for ClusterFuture ...
[17:42:24.831] - result already collected: FutureResult
[17:42:24.831] result() for ClusterFuture ... done
[17:42:24.831] result() for ClusterFuture ...
[17:42:24.831] - result already collected: FutureResult
[17:42:24.832] result() for ClusterFuture ... done
[17:42:24.832] result() for ClusterFuture ...
[17:42:24.832] - result already collected: FutureResult
[17:42:24.832] result() for ClusterFuture ... done
[17:42:24.832] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.832] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.832] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:24.832]  length: 0 (resolved future 4)
[17:42:24.832] Relaying remaining futures
[17:42:24.832] signalConditionsASAP(NULL, pos=0) ...
[17:42:24.832] - nx: 6
[17:42:24.833] - relay: TRUE
[17:42:24.833] - stdout: TRUE
[17:42:24.833] - signal: TRUE
[17:42:24.833] - resignal: FALSE
[17:42:24.833] - force: TRUE
[17:42:24.833] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.833] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:24.833] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.833] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.833] signalConditionsASAP(NULL, pos=0) ... done
[17:42:24.833] resolve() on list environment ... DONE
[17:42:24.834] result() for ClusterFuture ...
[17:42:24.834] - result already collected: FutureResult
[17:42:24.834] result() for ClusterFuture ... done
[17:42:24.834] result() for ClusterFuture ...
[17:42:24.834] - result already collected: FutureResult
[17:42:24.834] result() for ClusterFuture ... done
[17:42:24.834] result() for ClusterFuture ...
[17:42:24.834] - result already collected: FutureResult
[17:42:24.834] result() for ClusterFuture ... done
[17:42:24.834] result() for ClusterFuture ...
[17:42:24.835] - result already collected: FutureResult
[17:42:24.835] result() for ClusterFuture ... done
[17:42:24.835] result() for ClusterFuture ...
[17:42:24.835] - result already collected: FutureResult
[17:42:24.835] result() for ClusterFuture ... done
[17:42:24.835] result() for ClusterFuture ...
[17:42:24.835] - result already collected: FutureResult
[17:42:24.835] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55bef6cc1350> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[17:42:24.838] getGlobalsAndPackages() ...
[17:42:24.838] Searching for globals...
[17:42:24.838] 
[17:42:24.838] Searching for globals ... DONE
[17:42:24.838] - globals: [0] <none>
[17:42:24.838] getGlobalsAndPackages() ... DONE
[17:42:24.839] run() for ‘Future’ ...
[17:42:24.839] - state: ‘created’
[17:42:24.839] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.853] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.854]   - Field: ‘node’
[17:42:24.854]   - Field: ‘label’
[17:42:24.854]   - Field: ‘local’
[17:42:24.854]   - Field: ‘owner’
[17:42:24.854]   - Field: ‘envir’
[17:42:24.854]   - Field: ‘workers’
[17:42:24.854]   - Field: ‘packages’
[17:42:24.854]   - Field: ‘gc’
[17:42:24.855]   - Field: ‘conditions’
[17:42:24.855]   - Field: ‘persistent’
[17:42:24.855]   - Field: ‘expr’
[17:42:24.855]   - Field: ‘uuid’
[17:42:24.855]   - Field: ‘seed’
[17:42:24.855]   - Field: ‘version’
[17:42:24.855]   - Field: ‘result’
[17:42:24.855]   - Field: ‘asynchronous’
[17:42:24.855]   - Field: ‘calls’
[17:42:24.855]   - Field: ‘globals’
[17:42:24.856]   - Field: ‘stdout’
[17:42:24.856]   - Field: ‘earlySignal’
[17:42:24.856]   - Field: ‘lazy’
[17:42:24.856]   - Field: ‘state’
[17:42:24.856] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.856] - Launch lazy future ...
[17:42:24.856] Packages needed by the future expression (n = 0): <none>
[17:42:24.856] Packages needed by future strategies (n = 0): <none>
[17:42:24.857] {
[17:42:24.857]     {
[17:42:24.857]         {
[17:42:24.857]             ...future.startTime <- base::Sys.time()
[17:42:24.857]             {
[17:42:24.857]                 {
[17:42:24.857]                   {
[17:42:24.857]                     {
[17:42:24.857]                       base::local({
[17:42:24.857]                         has_future <- base::requireNamespace("future", 
[17:42:24.857]                           quietly = TRUE)
[17:42:24.857]                         if (has_future) {
[17:42:24.857]                           ns <- base::getNamespace("future")
[17:42:24.857]                           version <- ns[[".package"]][["version"]]
[17:42:24.857]                           if (is.null(version)) 
[17:42:24.857]                             version <- utils::packageVersion("future")
[17:42:24.857]                         }
[17:42:24.857]                         else {
[17:42:24.857]                           version <- NULL
[17:42:24.857]                         }
[17:42:24.857]                         if (!has_future || version < "1.8.0") {
[17:42:24.857]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.857]                             "", base::R.version$version.string), 
[17:42:24.857]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.857]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.857]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.857]                               "release", "version")], collapse = " "), 
[17:42:24.857]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.857]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.857]                             info)
[17:42:24.857]                           info <- base::paste(info, collapse = "; ")
[17:42:24.857]                           if (!has_future) {
[17:42:24.857]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.857]                               info)
[17:42:24.857]                           }
[17:42:24.857]                           else {
[17:42:24.857]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.857]                               info, version)
[17:42:24.857]                           }
[17:42:24.857]                           base::stop(msg)
[17:42:24.857]                         }
[17:42:24.857]                       })
[17:42:24.857]                     }
[17:42:24.857]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.857]                     base::options(mc.cores = 1L)
[17:42:24.857]                   }
[17:42:24.857]                   options(future.plan = NULL)
[17:42:24.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.857]                 }
[17:42:24.857]                 ...future.workdir <- getwd()
[17:42:24.857]             }
[17:42:24.857]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.857]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.857]         }
[17:42:24.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.857]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.857]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.857]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.857]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.857]             base::names(...future.oldOptions))
[17:42:24.857]     }
[17:42:24.857]     if (FALSE) {
[17:42:24.857]     }
[17:42:24.857]     else {
[17:42:24.857]         if (TRUE) {
[17:42:24.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.857]                 open = "w")
[17:42:24.857]         }
[17:42:24.857]         else {
[17:42:24.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.857]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.857]         }
[17:42:24.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.857]             base::sink(type = "output", split = FALSE)
[17:42:24.857]             base::close(...future.stdout)
[17:42:24.857]         }, add = TRUE)
[17:42:24.857]     }
[17:42:24.857]     ...future.frame <- base::sys.nframe()
[17:42:24.857]     ...future.conditions <- base::list()
[17:42:24.857]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.857]     if (FALSE) {
[17:42:24.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.857]     }
[17:42:24.857]     ...future.result <- base::tryCatch({
[17:42:24.857]         base::withCallingHandlers({
[17:42:24.857]             ...future.value <- base::withVisible(base::local({
[17:42:24.857]                 ...future.makeSendCondition <- local({
[17:42:24.857]                   sendCondition <- NULL
[17:42:24.857]                   function(frame = 1L) {
[17:42:24.857]                     if (is.function(sendCondition)) 
[17:42:24.857]                       return(sendCondition)
[17:42:24.857]                     ns <- getNamespace("parallel")
[17:42:24.857]                     if (exists("sendData", mode = "function", 
[17:42:24.857]                       envir = ns)) {
[17:42:24.857]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.857]                         envir = ns)
[17:42:24.857]                       envir <- sys.frame(frame)
[17:42:24.857]                       master <- NULL
[17:42:24.857]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.857]                         !identical(envir, emptyenv())) {
[17:42:24.857]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.857]                           inherits = FALSE)) {
[17:42:24.857]                           master <- get("master", mode = "list", 
[17:42:24.857]                             envir = envir, inherits = FALSE)
[17:42:24.857]                           if (inherits(master, c("SOCKnode", 
[17:42:24.857]                             "SOCK0node"))) {
[17:42:24.857]                             sendCondition <<- function(cond) {
[17:42:24.857]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.857]                                 success = TRUE)
[17:42:24.857]                               parallel_sendData(master, data)
[17:42:24.857]                             }
[17:42:24.857]                             return(sendCondition)
[17:42:24.857]                           }
[17:42:24.857]                         }
[17:42:24.857]                         frame <- frame + 1L
[17:42:24.857]                         envir <- sys.frame(frame)
[17:42:24.857]                       }
[17:42:24.857]                     }
[17:42:24.857]                     sendCondition <<- function(cond) NULL
[17:42:24.857]                   }
[17:42:24.857]                 })
[17:42:24.857]                 withCallingHandlers({
[17:42:24.857]                   2
[17:42:24.857]                 }, immediateCondition = function(cond) {
[17:42:24.857]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.857]                   sendCondition(cond)
[17:42:24.857]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.857]                   {
[17:42:24.857]                     inherits <- base::inherits
[17:42:24.857]                     invokeRestart <- base::invokeRestart
[17:42:24.857]                     is.null <- base::is.null
[17:42:24.857]                     muffled <- FALSE
[17:42:24.857]                     if (inherits(cond, "message")) {
[17:42:24.857]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.857]                       if (muffled) 
[17:42:24.857]                         invokeRestart("muffleMessage")
[17:42:24.857]                     }
[17:42:24.857]                     else if (inherits(cond, "warning")) {
[17:42:24.857]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.857]                       if (muffled) 
[17:42:24.857]                         invokeRestart("muffleWarning")
[17:42:24.857]                     }
[17:42:24.857]                     else if (inherits(cond, "condition")) {
[17:42:24.857]                       if (!is.null(pattern)) {
[17:42:24.857]                         computeRestarts <- base::computeRestarts
[17:42:24.857]                         grepl <- base::grepl
[17:42:24.857]                         restarts <- computeRestarts(cond)
[17:42:24.857]                         for (restart in restarts) {
[17:42:24.857]                           name <- restart$name
[17:42:24.857]                           if (is.null(name)) 
[17:42:24.857]                             next
[17:42:24.857]                           if (!grepl(pattern, name)) 
[17:42:24.857]                             next
[17:42:24.857]                           invokeRestart(restart)
[17:42:24.857]                           muffled <- TRUE
[17:42:24.857]                           break
[17:42:24.857]                         }
[17:42:24.857]                       }
[17:42:24.857]                     }
[17:42:24.857]                     invisible(muffled)
[17:42:24.857]                   }
[17:42:24.857]                   muffleCondition(cond)
[17:42:24.857]                 })
[17:42:24.857]             }))
[17:42:24.857]             future::FutureResult(value = ...future.value$value, 
[17:42:24.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.857]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.857]                     ...future.globalenv.names))
[17:42:24.857]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.857]         }, condition = base::local({
[17:42:24.857]             c <- base::c
[17:42:24.857]             inherits <- base::inherits
[17:42:24.857]             invokeRestart <- base::invokeRestart
[17:42:24.857]             length <- base::length
[17:42:24.857]             list <- base::list
[17:42:24.857]             seq.int <- base::seq.int
[17:42:24.857]             signalCondition <- base::signalCondition
[17:42:24.857]             sys.calls <- base::sys.calls
[17:42:24.857]             `[[` <- base::`[[`
[17:42:24.857]             `+` <- base::`+`
[17:42:24.857]             `<<-` <- base::`<<-`
[17:42:24.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.857]                   3L)]
[17:42:24.857]             }
[17:42:24.857]             function(cond) {
[17:42:24.857]                 is_error <- inherits(cond, "error")
[17:42:24.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.857]                   NULL)
[17:42:24.857]                 if (is_error) {
[17:42:24.857]                   sessionInformation <- function() {
[17:42:24.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.857]                       search = base::search(), system = base::Sys.info())
[17:42:24.857]                   }
[17:42:24.857]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.857]                     cond$call), session = sessionInformation(), 
[17:42:24.857]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.857]                   signalCondition(cond)
[17:42:24.857]                 }
[17:42:24.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.857]                 "immediateCondition"))) {
[17:42:24.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.857]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.857]                   if (TRUE && !signal) {
[17:42:24.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.857]                     {
[17:42:24.857]                       inherits <- base::inherits
[17:42:24.857]                       invokeRestart <- base::invokeRestart
[17:42:24.857]                       is.null <- base::is.null
[17:42:24.857]                       muffled <- FALSE
[17:42:24.857]                       if (inherits(cond, "message")) {
[17:42:24.857]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.857]                         if (muffled) 
[17:42:24.857]                           invokeRestart("muffleMessage")
[17:42:24.857]                       }
[17:42:24.857]                       else if (inherits(cond, "warning")) {
[17:42:24.857]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.857]                         if (muffled) 
[17:42:24.857]                           invokeRestart("muffleWarning")
[17:42:24.857]                       }
[17:42:24.857]                       else if (inherits(cond, "condition")) {
[17:42:24.857]                         if (!is.null(pattern)) {
[17:42:24.857]                           computeRestarts <- base::computeRestarts
[17:42:24.857]                           grepl <- base::grepl
[17:42:24.857]                           restarts <- computeRestarts(cond)
[17:42:24.857]                           for (restart in restarts) {
[17:42:24.857]                             name <- restart$name
[17:42:24.857]                             if (is.null(name)) 
[17:42:24.857]                               next
[17:42:24.857]                             if (!grepl(pattern, name)) 
[17:42:24.857]                               next
[17:42:24.857]                             invokeRestart(restart)
[17:42:24.857]                             muffled <- TRUE
[17:42:24.857]                             break
[17:42:24.857]                           }
[17:42:24.857]                         }
[17:42:24.857]                       }
[17:42:24.857]                       invisible(muffled)
[17:42:24.857]                     }
[17:42:24.857]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.857]                   }
[17:42:24.857]                 }
[17:42:24.857]                 else {
[17:42:24.857]                   if (TRUE) {
[17:42:24.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.857]                     {
[17:42:24.857]                       inherits <- base::inherits
[17:42:24.857]                       invokeRestart <- base::invokeRestart
[17:42:24.857]                       is.null <- base::is.null
[17:42:24.857]                       muffled <- FALSE
[17:42:24.857]                       if (inherits(cond, "message")) {
[17:42:24.857]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.857]                         if (muffled) 
[17:42:24.857]                           invokeRestart("muffleMessage")
[17:42:24.857]                       }
[17:42:24.857]                       else if (inherits(cond, "warning")) {
[17:42:24.857]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.857]                         if (muffled) 
[17:42:24.857]                           invokeRestart("muffleWarning")
[17:42:24.857]                       }
[17:42:24.857]                       else if (inherits(cond, "condition")) {
[17:42:24.857]                         if (!is.null(pattern)) {
[17:42:24.857]                           computeRestarts <- base::computeRestarts
[17:42:24.857]                           grepl <- base::grepl
[17:42:24.857]                           restarts <- computeRestarts(cond)
[17:42:24.857]                           for (restart in restarts) {
[17:42:24.857]                             name <- restart$name
[17:42:24.857]                             if (is.null(name)) 
[17:42:24.857]                               next
[17:42:24.857]                             if (!grepl(pattern, name)) 
[17:42:24.857]                               next
[17:42:24.857]                             invokeRestart(restart)
[17:42:24.857]                             muffled <- TRUE
[17:42:24.857]                             break
[17:42:24.857]                           }
[17:42:24.857]                         }
[17:42:24.857]                       }
[17:42:24.857]                       invisible(muffled)
[17:42:24.857]                     }
[17:42:24.857]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.857]                   }
[17:42:24.857]                 }
[17:42:24.857]             }
[17:42:24.857]         }))
[17:42:24.857]     }, error = function(ex) {
[17:42:24.857]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.857]                 ...future.rng), started = ...future.startTime, 
[17:42:24.857]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.857]             version = "1.8"), class = "FutureResult")
[17:42:24.857]     }, finally = {
[17:42:24.857]         if (!identical(...future.workdir, getwd())) 
[17:42:24.857]             setwd(...future.workdir)
[17:42:24.857]         {
[17:42:24.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.857]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.857]             }
[17:42:24.857]             base::options(...future.oldOptions)
[17:42:24.857]             if (.Platform$OS.type == "windows") {
[17:42:24.857]                 old_names <- names(...future.oldEnvVars)
[17:42:24.857]                 envs <- base::Sys.getenv()
[17:42:24.857]                 names <- names(envs)
[17:42:24.857]                 common <- intersect(names, old_names)
[17:42:24.857]                 added <- setdiff(names, old_names)
[17:42:24.857]                 removed <- setdiff(old_names, names)
[17:42:24.857]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.857]                   envs[common]]
[17:42:24.857]                 NAMES <- toupper(changed)
[17:42:24.857]                 args <- list()
[17:42:24.857]                 for (kk in seq_along(NAMES)) {
[17:42:24.857]                   name <- changed[[kk]]
[17:42:24.857]                   NAME <- NAMES[[kk]]
[17:42:24.857]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.857]                     next
[17:42:24.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.857]                 }
[17:42:24.857]                 NAMES <- toupper(added)
[17:42:24.857]                 for (kk in seq_along(NAMES)) {
[17:42:24.857]                   name <- added[[kk]]
[17:42:24.857]                   NAME <- NAMES[[kk]]
[17:42:24.857]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.857]                     next
[17:42:24.857]                   args[[name]] <- ""
[17:42:24.857]                 }
[17:42:24.857]                 NAMES <- toupper(removed)
[17:42:24.857]                 for (kk in seq_along(NAMES)) {
[17:42:24.857]                   name <- removed[[kk]]
[17:42:24.857]                   NAME <- NAMES[[kk]]
[17:42:24.857]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.857]                     next
[17:42:24.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.857]                 }
[17:42:24.857]                 if (length(args) > 0) 
[17:42:24.857]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.857]             }
[17:42:24.857]             else {
[17:42:24.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.857]             }
[17:42:24.857]             {
[17:42:24.857]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.857]                   0L) {
[17:42:24.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.857]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.857]                   base::options(opts)
[17:42:24.857]                 }
[17:42:24.857]                 {
[17:42:24.857]                   {
[17:42:24.857]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.857]                     NULL
[17:42:24.857]                   }
[17:42:24.857]                   options(future.plan = NULL)
[17:42:24.857]                   if (is.na(NA_character_)) 
[17:42:24.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.857]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.857]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.857]                     envir = parent.frame()) 
[17:42:24.857]                   {
[17:42:24.857]                     if (is.function(workers)) 
[17:42:24.857]                       workers <- workers()
[17:42:24.857]                     workers <- structure(as.integer(workers), 
[17:42:24.857]                       class = class(workers))
[17:42:24.857]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.857]                       workers >= 1)
[17:42:24.857]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.857]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.857]                     }
[17:42:24.857]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.857]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.857]                       envir = envir)
[17:42:24.857]                     if (!future$lazy) 
[17:42:24.857]                       future <- run(future)
[17:42:24.857]                     invisible(future)
[17:42:24.857]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.857]                 }
[17:42:24.857]             }
[17:42:24.857]         }
[17:42:24.857]     })
[17:42:24.857]     if (TRUE) {
[17:42:24.857]         base::sink(type = "output", split = FALSE)
[17:42:24.857]         if (TRUE) {
[17:42:24.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.857]         }
[17:42:24.857]         else {
[17:42:24.857]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.857]         }
[17:42:24.857]         base::close(...future.stdout)
[17:42:24.857]         ...future.stdout <- NULL
[17:42:24.857]     }
[17:42:24.857]     ...future.result$conditions <- ...future.conditions
[17:42:24.857]     ...future.result$finished <- base::Sys.time()
[17:42:24.857]     ...future.result
[17:42:24.857] }
[17:42:24.860] MultisessionFuture started
[17:42:24.860] - Launch lazy future ... done
[17:42:24.860] run() for ‘MultisessionFuture’ ... done
[17:42:24.861] getGlobalsAndPackages() ...
[17:42:24.861] Searching for globals...
[17:42:24.861] 
[17:42:24.861] Searching for globals ... DONE
[17:42:24.861] - globals: [0] <none>
[17:42:24.861] getGlobalsAndPackages() ... DONE
[17:42:24.862] run() for ‘Future’ ...
[17:42:24.862] - state: ‘created’
[17:42:24.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.876] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.877]   - Field: ‘node’
[17:42:24.877]   - Field: ‘label’
[17:42:24.877]   - Field: ‘local’
[17:42:24.877]   - Field: ‘owner’
[17:42:24.877]   - Field: ‘envir’
[17:42:24.877]   - Field: ‘workers’
[17:42:24.877]   - Field: ‘packages’
[17:42:24.877]   - Field: ‘gc’
[17:42:24.877]   - Field: ‘conditions’
[17:42:24.877]   - Field: ‘persistent’
[17:42:24.878]   - Field: ‘expr’
[17:42:24.878]   - Field: ‘uuid’
[17:42:24.878]   - Field: ‘seed’
[17:42:24.878]   - Field: ‘version’
[17:42:24.878]   - Field: ‘result’
[17:42:24.878]   - Field: ‘asynchronous’
[17:42:24.878]   - Field: ‘calls’
[17:42:24.878]   - Field: ‘globals’
[17:42:24.878]   - Field: ‘stdout’
[17:42:24.878]   - Field: ‘earlySignal’
[17:42:24.878]   - Field: ‘lazy’
[17:42:24.879]   - Field: ‘state’
[17:42:24.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.879] - Launch lazy future ...
[17:42:24.879] Packages needed by the future expression (n = 0): <none>
[17:42:24.879] Packages needed by future strategies (n = 0): <none>
[17:42:24.880] {
[17:42:24.880]     {
[17:42:24.880]         {
[17:42:24.880]             ...future.startTime <- base::Sys.time()
[17:42:24.880]             {
[17:42:24.880]                 {
[17:42:24.880]                   {
[17:42:24.880]                     {
[17:42:24.880]                       base::local({
[17:42:24.880]                         has_future <- base::requireNamespace("future", 
[17:42:24.880]                           quietly = TRUE)
[17:42:24.880]                         if (has_future) {
[17:42:24.880]                           ns <- base::getNamespace("future")
[17:42:24.880]                           version <- ns[[".package"]][["version"]]
[17:42:24.880]                           if (is.null(version)) 
[17:42:24.880]                             version <- utils::packageVersion("future")
[17:42:24.880]                         }
[17:42:24.880]                         else {
[17:42:24.880]                           version <- NULL
[17:42:24.880]                         }
[17:42:24.880]                         if (!has_future || version < "1.8.0") {
[17:42:24.880]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.880]                             "", base::R.version$version.string), 
[17:42:24.880]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.880]                               "release", "version")], collapse = " "), 
[17:42:24.880]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.880]                             info)
[17:42:24.880]                           info <- base::paste(info, collapse = "; ")
[17:42:24.880]                           if (!has_future) {
[17:42:24.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.880]                               info)
[17:42:24.880]                           }
[17:42:24.880]                           else {
[17:42:24.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.880]                               info, version)
[17:42:24.880]                           }
[17:42:24.880]                           base::stop(msg)
[17:42:24.880]                         }
[17:42:24.880]                       })
[17:42:24.880]                     }
[17:42:24.880]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.880]                     base::options(mc.cores = 1L)
[17:42:24.880]                   }
[17:42:24.880]                   options(future.plan = NULL)
[17:42:24.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.880]                 }
[17:42:24.880]                 ...future.workdir <- getwd()
[17:42:24.880]             }
[17:42:24.880]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.880]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.880]         }
[17:42:24.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.880]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.880]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.880]             base::names(...future.oldOptions))
[17:42:24.880]     }
[17:42:24.880]     if (FALSE) {
[17:42:24.880]     }
[17:42:24.880]     else {
[17:42:24.880]         if (TRUE) {
[17:42:24.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.880]                 open = "w")
[17:42:24.880]         }
[17:42:24.880]         else {
[17:42:24.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.880]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.880]         }
[17:42:24.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.880]             base::sink(type = "output", split = FALSE)
[17:42:24.880]             base::close(...future.stdout)
[17:42:24.880]         }, add = TRUE)
[17:42:24.880]     }
[17:42:24.880]     ...future.frame <- base::sys.nframe()
[17:42:24.880]     ...future.conditions <- base::list()
[17:42:24.880]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.880]     if (FALSE) {
[17:42:24.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.880]     }
[17:42:24.880]     ...future.result <- base::tryCatch({
[17:42:24.880]         base::withCallingHandlers({
[17:42:24.880]             ...future.value <- base::withVisible(base::local({
[17:42:24.880]                 ...future.makeSendCondition <- local({
[17:42:24.880]                   sendCondition <- NULL
[17:42:24.880]                   function(frame = 1L) {
[17:42:24.880]                     if (is.function(sendCondition)) 
[17:42:24.880]                       return(sendCondition)
[17:42:24.880]                     ns <- getNamespace("parallel")
[17:42:24.880]                     if (exists("sendData", mode = "function", 
[17:42:24.880]                       envir = ns)) {
[17:42:24.880]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.880]                         envir = ns)
[17:42:24.880]                       envir <- sys.frame(frame)
[17:42:24.880]                       master <- NULL
[17:42:24.880]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.880]                         !identical(envir, emptyenv())) {
[17:42:24.880]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.880]                           inherits = FALSE)) {
[17:42:24.880]                           master <- get("master", mode = "list", 
[17:42:24.880]                             envir = envir, inherits = FALSE)
[17:42:24.880]                           if (inherits(master, c("SOCKnode", 
[17:42:24.880]                             "SOCK0node"))) {
[17:42:24.880]                             sendCondition <<- function(cond) {
[17:42:24.880]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.880]                                 success = TRUE)
[17:42:24.880]                               parallel_sendData(master, data)
[17:42:24.880]                             }
[17:42:24.880]                             return(sendCondition)
[17:42:24.880]                           }
[17:42:24.880]                         }
[17:42:24.880]                         frame <- frame + 1L
[17:42:24.880]                         envir <- sys.frame(frame)
[17:42:24.880]                       }
[17:42:24.880]                     }
[17:42:24.880]                     sendCondition <<- function(cond) NULL
[17:42:24.880]                   }
[17:42:24.880]                 })
[17:42:24.880]                 withCallingHandlers({
[17:42:24.880]                   NULL
[17:42:24.880]                 }, immediateCondition = function(cond) {
[17:42:24.880]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.880]                   sendCondition(cond)
[17:42:24.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.880]                   {
[17:42:24.880]                     inherits <- base::inherits
[17:42:24.880]                     invokeRestart <- base::invokeRestart
[17:42:24.880]                     is.null <- base::is.null
[17:42:24.880]                     muffled <- FALSE
[17:42:24.880]                     if (inherits(cond, "message")) {
[17:42:24.880]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.880]                       if (muffled) 
[17:42:24.880]                         invokeRestart("muffleMessage")
[17:42:24.880]                     }
[17:42:24.880]                     else if (inherits(cond, "warning")) {
[17:42:24.880]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.880]                       if (muffled) 
[17:42:24.880]                         invokeRestart("muffleWarning")
[17:42:24.880]                     }
[17:42:24.880]                     else if (inherits(cond, "condition")) {
[17:42:24.880]                       if (!is.null(pattern)) {
[17:42:24.880]                         computeRestarts <- base::computeRestarts
[17:42:24.880]                         grepl <- base::grepl
[17:42:24.880]                         restarts <- computeRestarts(cond)
[17:42:24.880]                         for (restart in restarts) {
[17:42:24.880]                           name <- restart$name
[17:42:24.880]                           if (is.null(name)) 
[17:42:24.880]                             next
[17:42:24.880]                           if (!grepl(pattern, name)) 
[17:42:24.880]                             next
[17:42:24.880]                           invokeRestart(restart)
[17:42:24.880]                           muffled <- TRUE
[17:42:24.880]                           break
[17:42:24.880]                         }
[17:42:24.880]                       }
[17:42:24.880]                     }
[17:42:24.880]                     invisible(muffled)
[17:42:24.880]                   }
[17:42:24.880]                   muffleCondition(cond)
[17:42:24.880]                 })
[17:42:24.880]             }))
[17:42:24.880]             future::FutureResult(value = ...future.value$value, 
[17:42:24.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.880]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.880]                     ...future.globalenv.names))
[17:42:24.880]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.880]         }, condition = base::local({
[17:42:24.880]             c <- base::c
[17:42:24.880]             inherits <- base::inherits
[17:42:24.880]             invokeRestart <- base::invokeRestart
[17:42:24.880]             length <- base::length
[17:42:24.880]             list <- base::list
[17:42:24.880]             seq.int <- base::seq.int
[17:42:24.880]             signalCondition <- base::signalCondition
[17:42:24.880]             sys.calls <- base::sys.calls
[17:42:24.880]             `[[` <- base::`[[`
[17:42:24.880]             `+` <- base::`+`
[17:42:24.880]             `<<-` <- base::`<<-`
[17:42:24.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.880]                   3L)]
[17:42:24.880]             }
[17:42:24.880]             function(cond) {
[17:42:24.880]                 is_error <- inherits(cond, "error")
[17:42:24.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.880]                   NULL)
[17:42:24.880]                 if (is_error) {
[17:42:24.880]                   sessionInformation <- function() {
[17:42:24.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.880]                       search = base::search(), system = base::Sys.info())
[17:42:24.880]                   }
[17:42:24.880]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.880]                     cond$call), session = sessionInformation(), 
[17:42:24.880]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.880]                   signalCondition(cond)
[17:42:24.880]                 }
[17:42:24.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.880]                 "immediateCondition"))) {
[17:42:24.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.880]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.880]                   if (TRUE && !signal) {
[17:42:24.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.880]                     {
[17:42:24.880]                       inherits <- base::inherits
[17:42:24.880]                       invokeRestart <- base::invokeRestart
[17:42:24.880]                       is.null <- base::is.null
[17:42:24.880]                       muffled <- FALSE
[17:42:24.880]                       if (inherits(cond, "message")) {
[17:42:24.880]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.880]                         if (muffled) 
[17:42:24.880]                           invokeRestart("muffleMessage")
[17:42:24.880]                       }
[17:42:24.880]                       else if (inherits(cond, "warning")) {
[17:42:24.880]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.880]                         if (muffled) 
[17:42:24.880]                           invokeRestart("muffleWarning")
[17:42:24.880]                       }
[17:42:24.880]                       else if (inherits(cond, "condition")) {
[17:42:24.880]                         if (!is.null(pattern)) {
[17:42:24.880]                           computeRestarts <- base::computeRestarts
[17:42:24.880]                           grepl <- base::grepl
[17:42:24.880]                           restarts <- computeRestarts(cond)
[17:42:24.880]                           for (restart in restarts) {
[17:42:24.880]                             name <- restart$name
[17:42:24.880]                             if (is.null(name)) 
[17:42:24.880]                               next
[17:42:24.880]                             if (!grepl(pattern, name)) 
[17:42:24.880]                               next
[17:42:24.880]                             invokeRestart(restart)
[17:42:24.880]                             muffled <- TRUE
[17:42:24.880]                             break
[17:42:24.880]                           }
[17:42:24.880]                         }
[17:42:24.880]                       }
[17:42:24.880]                       invisible(muffled)
[17:42:24.880]                     }
[17:42:24.880]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.880]                   }
[17:42:24.880]                 }
[17:42:24.880]                 else {
[17:42:24.880]                   if (TRUE) {
[17:42:24.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.880]                     {
[17:42:24.880]                       inherits <- base::inherits
[17:42:24.880]                       invokeRestart <- base::invokeRestart
[17:42:24.880]                       is.null <- base::is.null
[17:42:24.880]                       muffled <- FALSE
[17:42:24.880]                       if (inherits(cond, "message")) {
[17:42:24.880]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.880]                         if (muffled) 
[17:42:24.880]                           invokeRestart("muffleMessage")
[17:42:24.880]                       }
[17:42:24.880]                       else if (inherits(cond, "warning")) {
[17:42:24.880]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.880]                         if (muffled) 
[17:42:24.880]                           invokeRestart("muffleWarning")
[17:42:24.880]                       }
[17:42:24.880]                       else if (inherits(cond, "condition")) {
[17:42:24.880]                         if (!is.null(pattern)) {
[17:42:24.880]                           computeRestarts <- base::computeRestarts
[17:42:24.880]                           grepl <- base::grepl
[17:42:24.880]                           restarts <- computeRestarts(cond)
[17:42:24.880]                           for (restart in restarts) {
[17:42:24.880]                             name <- restart$name
[17:42:24.880]                             if (is.null(name)) 
[17:42:24.880]                               next
[17:42:24.880]                             if (!grepl(pattern, name)) 
[17:42:24.880]                               next
[17:42:24.880]                             invokeRestart(restart)
[17:42:24.880]                             muffled <- TRUE
[17:42:24.880]                             break
[17:42:24.880]                           }
[17:42:24.880]                         }
[17:42:24.880]                       }
[17:42:24.880]                       invisible(muffled)
[17:42:24.880]                     }
[17:42:24.880]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.880]                   }
[17:42:24.880]                 }
[17:42:24.880]             }
[17:42:24.880]         }))
[17:42:24.880]     }, error = function(ex) {
[17:42:24.880]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.880]                 ...future.rng), started = ...future.startTime, 
[17:42:24.880]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.880]             version = "1.8"), class = "FutureResult")
[17:42:24.880]     }, finally = {
[17:42:24.880]         if (!identical(...future.workdir, getwd())) 
[17:42:24.880]             setwd(...future.workdir)
[17:42:24.880]         {
[17:42:24.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.880]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.880]             }
[17:42:24.880]             base::options(...future.oldOptions)
[17:42:24.880]             if (.Platform$OS.type == "windows") {
[17:42:24.880]                 old_names <- names(...future.oldEnvVars)
[17:42:24.880]                 envs <- base::Sys.getenv()
[17:42:24.880]                 names <- names(envs)
[17:42:24.880]                 common <- intersect(names, old_names)
[17:42:24.880]                 added <- setdiff(names, old_names)
[17:42:24.880]                 removed <- setdiff(old_names, names)
[17:42:24.880]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.880]                   envs[common]]
[17:42:24.880]                 NAMES <- toupper(changed)
[17:42:24.880]                 args <- list()
[17:42:24.880]                 for (kk in seq_along(NAMES)) {
[17:42:24.880]                   name <- changed[[kk]]
[17:42:24.880]                   NAME <- NAMES[[kk]]
[17:42:24.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.880]                     next
[17:42:24.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.880]                 }
[17:42:24.880]                 NAMES <- toupper(added)
[17:42:24.880]                 for (kk in seq_along(NAMES)) {
[17:42:24.880]                   name <- added[[kk]]
[17:42:24.880]                   NAME <- NAMES[[kk]]
[17:42:24.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.880]                     next
[17:42:24.880]                   args[[name]] <- ""
[17:42:24.880]                 }
[17:42:24.880]                 NAMES <- toupper(removed)
[17:42:24.880]                 for (kk in seq_along(NAMES)) {
[17:42:24.880]                   name <- removed[[kk]]
[17:42:24.880]                   NAME <- NAMES[[kk]]
[17:42:24.880]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.880]                     next
[17:42:24.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.880]                 }
[17:42:24.880]                 if (length(args) > 0) 
[17:42:24.880]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.880]             }
[17:42:24.880]             else {
[17:42:24.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.880]             }
[17:42:24.880]             {
[17:42:24.880]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.880]                   0L) {
[17:42:24.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.880]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.880]                   base::options(opts)
[17:42:24.880]                 }
[17:42:24.880]                 {
[17:42:24.880]                   {
[17:42:24.880]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.880]                     NULL
[17:42:24.880]                   }
[17:42:24.880]                   options(future.plan = NULL)
[17:42:24.880]                   if (is.na(NA_character_)) 
[17:42:24.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.880]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.880]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.880]                     envir = parent.frame()) 
[17:42:24.880]                   {
[17:42:24.880]                     if (is.function(workers)) 
[17:42:24.880]                       workers <- workers()
[17:42:24.880]                     workers <- structure(as.integer(workers), 
[17:42:24.880]                       class = class(workers))
[17:42:24.880]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.880]                       workers >= 1)
[17:42:24.880]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.880]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.880]                     }
[17:42:24.880]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.880]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.880]                       envir = envir)
[17:42:24.880]                     if (!future$lazy) 
[17:42:24.880]                       future <- run(future)
[17:42:24.880]                     invisible(future)
[17:42:24.880]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.880]                 }
[17:42:24.880]             }
[17:42:24.880]         }
[17:42:24.880]     })
[17:42:24.880]     if (TRUE) {
[17:42:24.880]         base::sink(type = "output", split = FALSE)
[17:42:24.880]         if (TRUE) {
[17:42:24.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.880]         }
[17:42:24.880]         else {
[17:42:24.880]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.880]         }
[17:42:24.880]         base::close(...future.stdout)
[17:42:24.880]         ...future.stdout <- NULL
[17:42:24.880]     }
[17:42:24.880]     ...future.result$conditions <- ...future.conditions
[17:42:24.880]     ...future.result$finished <- base::Sys.time()
[17:42:24.880]     ...future.result
[17:42:24.880] }
[17:42:24.883] MultisessionFuture started
[17:42:24.883] - Launch lazy future ... done
[17:42:24.883] run() for ‘MultisessionFuture’ ... done
[17:42:24.884] getGlobalsAndPackages() ...
[17:42:24.884] Searching for globals...
[17:42:24.885] - globals found: [1] ‘{’
[17:42:24.885] Searching for globals ... DONE
[17:42:24.885] Resolving globals: FALSE
[17:42:24.885] 
[17:42:24.885] 
[17:42:24.885] getGlobalsAndPackages() ... DONE
[17:42:24.886] run() for ‘Future’ ...
[17:42:24.886] - state: ‘created’
[17:42:24.886] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:42:24.901] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:42:24.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:42:24.905]   - Field: ‘node’
[17:42:24.906]   - Field: ‘label’
[17:42:24.906]   - Field: ‘local’
[17:42:24.906]   - Field: ‘owner’
[17:42:24.906]   - Field: ‘envir’
[17:42:24.906]   - Field: ‘workers’
[17:42:24.906]   - Field: ‘packages’
[17:42:24.906]   - Field: ‘gc’
[17:42:24.906]   - Field: ‘conditions’
[17:42:24.906]   - Field: ‘persistent’
[17:42:24.906]   - Field: ‘expr’
[17:42:24.907]   - Field: ‘uuid’
[17:42:24.907]   - Field: ‘seed’
[17:42:24.907]   - Field: ‘version’
[17:42:24.907]   - Field: ‘result’
[17:42:24.907]   - Field: ‘asynchronous’
[17:42:24.907]   - Field: ‘calls’
[17:42:24.907]   - Field: ‘globals’
[17:42:24.907]   - Field: ‘stdout’
[17:42:24.907]   - Field: ‘earlySignal’
[17:42:24.907]   - Field: ‘lazy’
[17:42:24.908]   - Field: ‘state’
[17:42:24.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:42:24.908] - Launch lazy future ...
[17:42:24.908] Packages needed by the future expression (n = 0): <none>
[17:42:24.908] Packages needed by future strategies (n = 0): <none>
[17:42:24.909] {
[17:42:24.909]     {
[17:42:24.909]         {
[17:42:24.909]             ...future.startTime <- base::Sys.time()
[17:42:24.909]             {
[17:42:24.909]                 {
[17:42:24.909]                   {
[17:42:24.909]                     {
[17:42:24.909]                       base::local({
[17:42:24.909]                         has_future <- base::requireNamespace("future", 
[17:42:24.909]                           quietly = TRUE)
[17:42:24.909]                         if (has_future) {
[17:42:24.909]                           ns <- base::getNamespace("future")
[17:42:24.909]                           version <- ns[[".package"]][["version"]]
[17:42:24.909]                           if (is.null(version)) 
[17:42:24.909]                             version <- utils::packageVersion("future")
[17:42:24.909]                         }
[17:42:24.909]                         else {
[17:42:24.909]                           version <- NULL
[17:42:24.909]                         }
[17:42:24.909]                         if (!has_future || version < "1.8.0") {
[17:42:24.909]                           info <- base::c(r_version = base::gsub("R version ", 
[17:42:24.909]                             "", base::R.version$version.string), 
[17:42:24.909]                             platform = base::sprintf("%s (%s-bit)", 
[17:42:24.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:42:24.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:42:24.909]                               "release", "version")], collapse = " "), 
[17:42:24.909]                             hostname = base::Sys.info()[["nodename"]])
[17:42:24.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:42:24.909]                             info)
[17:42:24.909]                           info <- base::paste(info, collapse = "; ")
[17:42:24.909]                           if (!has_future) {
[17:42:24.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:42:24.909]                               info)
[17:42:24.909]                           }
[17:42:24.909]                           else {
[17:42:24.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:42:24.909]                               info, version)
[17:42:24.909]                           }
[17:42:24.909]                           base::stop(msg)
[17:42:24.909]                         }
[17:42:24.909]                       })
[17:42:24.909]                     }
[17:42:24.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:42:24.909]                     base::options(mc.cores = 1L)
[17:42:24.909]                   }
[17:42:24.909]                   options(future.plan = NULL)
[17:42:24.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:42:24.909]                 }
[17:42:24.909]                 ...future.workdir <- getwd()
[17:42:24.909]             }
[17:42:24.909]             ...future.oldOptions <- base::as.list(base::.Options)
[17:42:24.909]             ...future.oldEnvVars <- base::Sys.getenv()
[17:42:24.909]         }
[17:42:24.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:42:24.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:42:24.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:42:24.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:42:24.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:42:24.909]             future.stdout.windows.reencode = NULL, width = 80L)
[17:42:24.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:42:24.909]             base::names(...future.oldOptions))
[17:42:24.909]     }
[17:42:24.909]     if (FALSE) {
[17:42:24.909]     }
[17:42:24.909]     else {
[17:42:24.909]         if (TRUE) {
[17:42:24.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:42:24.909]                 open = "w")
[17:42:24.909]         }
[17:42:24.909]         else {
[17:42:24.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:42:24.909]                 windows = "NUL", "/dev/null"), open = "w")
[17:42:24.909]         }
[17:42:24.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:42:24.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:42:24.909]             base::sink(type = "output", split = FALSE)
[17:42:24.909]             base::close(...future.stdout)
[17:42:24.909]         }, add = TRUE)
[17:42:24.909]     }
[17:42:24.909]     ...future.frame <- base::sys.nframe()
[17:42:24.909]     ...future.conditions <- base::list()
[17:42:24.909]     ...future.rng <- base::globalenv()$.Random.seed
[17:42:24.909]     if (FALSE) {
[17:42:24.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:42:24.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:42:24.909]     }
[17:42:24.909]     ...future.result <- base::tryCatch({
[17:42:24.909]         base::withCallingHandlers({
[17:42:24.909]             ...future.value <- base::withVisible(base::local({
[17:42:24.909]                 ...future.makeSendCondition <- local({
[17:42:24.909]                   sendCondition <- NULL
[17:42:24.909]                   function(frame = 1L) {
[17:42:24.909]                     if (is.function(sendCondition)) 
[17:42:24.909]                       return(sendCondition)
[17:42:24.909]                     ns <- getNamespace("parallel")
[17:42:24.909]                     if (exists("sendData", mode = "function", 
[17:42:24.909]                       envir = ns)) {
[17:42:24.909]                       parallel_sendData <- get("sendData", mode = "function", 
[17:42:24.909]                         envir = ns)
[17:42:24.909]                       envir <- sys.frame(frame)
[17:42:24.909]                       master <- NULL
[17:42:24.909]                       while (!identical(envir, .GlobalEnv) && 
[17:42:24.909]                         !identical(envir, emptyenv())) {
[17:42:24.909]                         if (exists("master", mode = "list", envir = envir, 
[17:42:24.909]                           inherits = FALSE)) {
[17:42:24.909]                           master <- get("master", mode = "list", 
[17:42:24.909]                             envir = envir, inherits = FALSE)
[17:42:24.909]                           if (inherits(master, c("SOCKnode", 
[17:42:24.909]                             "SOCK0node"))) {
[17:42:24.909]                             sendCondition <<- function(cond) {
[17:42:24.909]                               data <- list(type = "VALUE", value = cond, 
[17:42:24.909]                                 success = TRUE)
[17:42:24.909]                               parallel_sendData(master, data)
[17:42:24.909]                             }
[17:42:24.909]                             return(sendCondition)
[17:42:24.909]                           }
[17:42:24.909]                         }
[17:42:24.909]                         frame <- frame + 1L
[17:42:24.909]                         envir <- sys.frame(frame)
[17:42:24.909]                       }
[17:42:24.909]                     }
[17:42:24.909]                     sendCondition <<- function(cond) NULL
[17:42:24.909]                   }
[17:42:24.909]                 })
[17:42:24.909]                 withCallingHandlers({
[17:42:24.909]                   {
[17:42:24.909]                     4
[17:42:24.909]                   }
[17:42:24.909]                 }, immediateCondition = function(cond) {
[17:42:24.909]                   sendCondition <- ...future.makeSendCondition()
[17:42:24.909]                   sendCondition(cond)
[17:42:24.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.909]                   {
[17:42:24.909]                     inherits <- base::inherits
[17:42:24.909]                     invokeRestart <- base::invokeRestart
[17:42:24.909]                     is.null <- base::is.null
[17:42:24.909]                     muffled <- FALSE
[17:42:24.909]                     if (inherits(cond, "message")) {
[17:42:24.909]                       muffled <- grepl(pattern, "muffleMessage")
[17:42:24.909]                       if (muffled) 
[17:42:24.909]                         invokeRestart("muffleMessage")
[17:42:24.909]                     }
[17:42:24.909]                     else if (inherits(cond, "warning")) {
[17:42:24.909]                       muffled <- grepl(pattern, "muffleWarning")
[17:42:24.909]                       if (muffled) 
[17:42:24.909]                         invokeRestart("muffleWarning")
[17:42:24.909]                     }
[17:42:24.909]                     else if (inherits(cond, "condition")) {
[17:42:24.909]                       if (!is.null(pattern)) {
[17:42:24.909]                         computeRestarts <- base::computeRestarts
[17:42:24.909]                         grepl <- base::grepl
[17:42:24.909]                         restarts <- computeRestarts(cond)
[17:42:24.909]                         for (restart in restarts) {
[17:42:24.909]                           name <- restart$name
[17:42:24.909]                           if (is.null(name)) 
[17:42:24.909]                             next
[17:42:24.909]                           if (!grepl(pattern, name)) 
[17:42:24.909]                             next
[17:42:24.909]                           invokeRestart(restart)
[17:42:24.909]                           muffled <- TRUE
[17:42:24.909]                           break
[17:42:24.909]                         }
[17:42:24.909]                       }
[17:42:24.909]                     }
[17:42:24.909]                     invisible(muffled)
[17:42:24.909]                   }
[17:42:24.909]                   muffleCondition(cond)
[17:42:24.909]                 })
[17:42:24.909]             }))
[17:42:24.909]             future::FutureResult(value = ...future.value$value, 
[17:42:24.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.909]                   ...future.rng), globalenv = if (FALSE) 
[17:42:24.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:42:24.909]                     ...future.globalenv.names))
[17:42:24.909]                 else NULL, started = ...future.startTime, version = "1.8")
[17:42:24.909]         }, condition = base::local({
[17:42:24.909]             c <- base::c
[17:42:24.909]             inherits <- base::inherits
[17:42:24.909]             invokeRestart <- base::invokeRestart
[17:42:24.909]             length <- base::length
[17:42:24.909]             list <- base::list
[17:42:24.909]             seq.int <- base::seq.int
[17:42:24.909]             signalCondition <- base::signalCondition
[17:42:24.909]             sys.calls <- base::sys.calls
[17:42:24.909]             `[[` <- base::`[[`
[17:42:24.909]             `+` <- base::`+`
[17:42:24.909]             `<<-` <- base::`<<-`
[17:42:24.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:42:24.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:42:24.909]                   3L)]
[17:42:24.909]             }
[17:42:24.909]             function(cond) {
[17:42:24.909]                 is_error <- inherits(cond, "error")
[17:42:24.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:42:24.909]                   NULL)
[17:42:24.909]                 if (is_error) {
[17:42:24.909]                   sessionInformation <- function() {
[17:42:24.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:42:24.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:42:24.909]                       search = base::search(), system = base::Sys.info())
[17:42:24.909]                   }
[17:42:24.909]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:42:24.909]                     cond$call), session = sessionInformation(), 
[17:42:24.909]                     timestamp = base::Sys.time(), signaled = 0L)
[17:42:24.909]                   signalCondition(cond)
[17:42:24.909]                 }
[17:42:24.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:42:24.909]                 "immediateCondition"))) {
[17:42:24.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:42:24.909]                   ...future.conditions[[length(...future.conditions) + 
[17:42:24.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:42:24.909]                   if (TRUE && !signal) {
[17:42:24.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.909]                     {
[17:42:24.909]                       inherits <- base::inherits
[17:42:24.909]                       invokeRestart <- base::invokeRestart
[17:42:24.909]                       is.null <- base::is.null
[17:42:24.909]                       muffled <- FALSE
[17:42:24.909]                       if (inherits(cond, "message")) {
[17:42:24.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.909]                         if (muffled) 
[17:42:24.909]                           invokeRestart("muffleMessage")
[17:42:24.909]                       }
[17:42:24.909]                       else if (inherits(cond, "warning")) {
[17:42:24.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.909]                         if (muffled) 
[17:42:24.909]                           invokeRestart("muffleWarning")
[17:42:24.909]                       }
[17:42:24.909]                       else if (inherits(cond, "condition")) {
[17:42:24.909]                         if (!is.null(pattern)) {
[17:42:24.909]                           computeRestarts <- base::computeRestarts
[17:42:24.909]                           grepl <- base::grepl
[17:42:24.909]                           restarts <- computeRestarts(cond)
[17:42:24.909]                           for (restart in restarts) {
[17:42:24.909]                             name <- restart$name
[17:42:24.909]                             if (is.null(name)) 
[17:42:24.909]                               next
[17:42:24.909]                             if (!grepl(pattern, name)) 
[17:42:24.909]                               next
[17:42:24.909]                             invokeRestart(restart)
[17:42:24.909]                             muffled <- TRUE
[17:42:24.909]                             break
[17:42:24.909]                           }
[17:42:24.909]                         }
[17:42:24.909]                       }
[17:42:24.909]                       invisible(muffled)
[17:42:24.909]                     }
[17:42:24.909]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.909]                   }
[17:42:24.909]                 }
[17:42:24.909]                 else {
[17:42:24.909]                   if (TRUE) {
[17:42:24.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:42:24.909]                     {
[17:42:24.909]                       inherits <- base::inherits
[17:42:24.909]                       invokeRestart <- base::invokeRestart
[17:42:24.909]                       is.null <- base::is.null
[17:42:24.909]                       muffled <- FALSE
[17:42:24.909]                       if (inherits(cond, "message")) {
[17:42:24.909]                         muffled <- grepl(pattern, "muffleMessage")
[17:42:24.909]                         if (muffled) 
[17:42:24.909]                           invokeRestart("muffleMessage")
[17:42:24.909]                       }
[17:42:24.909]                       else if (inherits(cond, "warning")) {
[17:42:24.909]                         muffled <- grepl(pattern, "muffleWarning")
[17:42:24.909]                         if (muffled) 
[17:42:24.909]                           invokeRestart("muffleWarning")
[17:42:24.909]                       }
[17:42:24.909]                       else if (inherits(cond, "condition")) {
[17:42:24.909]                         if (!is.null(pattern)) {
[17:42:24.909]                           computeRestarts <- base::computeRestarts
[17:42:24.909]                           grepl <- base::grepl
[17:42:24.909]                           restarts <- computeRestarts(cond)
[17:42:24.909]                           for (restart in restarts) {
[17:42:24.909]                             name <- restart$name
[17:42:24.909]                             if (is.null(name)) 
[17:42:24.909]                               next
[17:42:24.909]                             if (!grepl(pattern, name)) 
[17:42:24.909]                               next
[17:42:24.909]                             invokeRestart(restart)
[17:42:24.909]                             muffled <- TRUE
[17:42:24.909]                             break
[17:42:24.909]                           }
[17:42:24.909]                         }
[17:42:24.909]                       }
[17:42:24.909]                       invisible(muffled)
[17:42:24.909]                     }
[17:42:24.909]                     muffleCondition(cond, pattern = "^muffle")
[17:42:24.909]                   }
[17:42:24.909]                 }
[17:42:24.909]             }
[17:42:24.909]         }))
[17:42:24.909]     }, error = function(ex) {
[17:42:24.909]         base::structure(base::list(value = NULL, visible = NULL, 
[17:42:24.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:42:24.909]                 ...future.rng), started = ...future.startTime, 
[17:42:24.909]             finished = Sys.time(), session_uuid = NA_character_, 
[17:42:24.909]             version = "1.8"), class = "FutureResult")
[17:42:24.909]     }, finally = {
[17:42:24.909]         if (!identical(...future.workdir, getwd())) 
[17:42:24.909]             setwd(...future.workdir)
[17:42:24.909]         {
[17:42:24.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:42:24.909]                 ...future.oldOptions$nwarnings <- NULL
[17:42:24.909]             }
[17:42:24.909]             base::options(...future.oldOptions)
[17:42:24.909]             if (.Platform$OS.type == "windows") {
[17:42:24.909]                 old_names <- names(...future.oldEnvVars)
[17:42:24.909]                 envs <- base::Sys.getenv()
[17:42:24.909]                 names <- names(envs)
[17:42:24.909]                 common <- intersect(names, old_names)
[17:42:24.909]                 added <- setdiff(names, old_names)
[17:42:24.909]                 removed <- setdiff(old_names, names)
[17:42:24.909]                 changed <- common[...future.oldEnvVars[common] != 
[17:42:24.909]                   envs[common]]
[17:42:24.909]                 NAMES <- toupper(changed)
[17:42:24.909]                 args <- list()
[17:42:24.909]                 for (kk in seq_along(NAMES)) {
[17:42:24.909]                   name <- changed[[kk]]
[17:42:24.909]                   NAME <- NAMES[[kk]]
[17:42:24.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.909]                     next
[17:42:24.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.909]                 }
[17:42:24.909]                 NAMES <- toupper(added)
[17:42:24.909]                 for (kk in seq_along(NAMES)) {
[17:42:24.909]                   name <- added[[kk]]
[17:42:24.909]                   NAME <- NAMES[[kk]]
[17:42:24.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.909]                     next
[17:42:24.909]                   args[[name]] <- ""
[17:42:24.909]                 }
[17:42:24.909]                 NAMES <- toupper(removed)
[17:42:24.909]                 for (kk in seq_along(NAMES)) {
[17:42:24.909]                   name <- removed[[kk]]
[17:42:24.909]                   NAME <- NAMES[[kk]]
[17:42:24.909]                   if (name != NAME && is.element(NAME, old_names)) 
[17:42:24.909]                     next
[17:42:24.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:42:24.909]                 }
[17:42:24.909]                 if (length(args) > 0) 
[17:42:24.909]                   base::do.call(base::Sys.setenv, args = args)
[17:42:24.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:42:24.909]             }
[17:42:24.909]             else {
[17:42:24.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:42:24.909]             }
[17:42:24.909]             {
[17:42:24.909]                 if (base::length(...future.futureOptionsAdded) > 
[17:42:24.909]                   0L) {
[17:42:24.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:42:24.909]                   base::names(opts) <- ...future.futureOptionsAdded
[17:42:24.909]                   base::options(opts)
[17:42:24.909]                 }
[17:42:24.909]                 {
[17:42:24.909]                   {
[17:42:24.909]                     base::options(mc.cores = ...future.mc.cores.old)
[17:42:24.909]                     NULL
[17:42:24.909]                   }
[17:42:24.909]                   options(future.plan = NULL)
[17:42:24.909]                   if (is.na(NA_character_)) 
[17:42:24.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:42:24.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:42:24.909]                   future::plan(list(function (..., workers = availableCores(), 
[17:42:24.909]                     lazy = FALSE, rscript_libs = .libPaths(), 
[17:42:24.909]                     envir = parent.frame()) 
[17:42:24.909]                   {
[17:42:24.909]                     if (is.function(workers)) 
[17:42:24.909]                       workers <- workers()
[17:42:24.909]                     workers <- structure(as.integer(workers), 
[17:42:24.909]                       class = class(workers))
[17:42:24.909]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[17:42:24.909]                       workers >= 1)
[17:42:24.909]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[17:42:24.909]                       return(sequential(..., lazy = TRUE, envir = envir))
[17:42:24.909]                     }
[17:42:24.909]                     future <- MultisessionFuture(..., workers = workers, 
[17:42:24.909]                       lazy = lazy, rscript_libs = rscript_libs, 
[17:42:24.909]                       envir = envir)
[17:42:24.909]                     if (!future$lazy) 
[17:42:24.909]                       future <- run(future)
[17:42:24.909]                     invisible(future)
[17:42:24.909]                   }), .cleanup = FALSE, .init = FALSE)
[17:42:24.909]                 }
[17:42:24.909]             }
[17:42:24.909]         }
[17:42:24.909]     })
[17:42:24.909]     if (TRUE) {
[17:42:24.909]         base::sink(type = "output", split = FALSE)
[17:42:24.909]         if (TRUE) {
[17:42:24.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:42:24.909]         }
[17:42:24.909]         else {
[17:42:24.909]             ...future.result["stdout"] <- base::list(NULL)
[17:42:24.909]         }
[17:42:24.909]         base::close(...future.stdout)
[17:42:24.909]         ...future.stdout <- NULL
[17:42:24.909]     }
[17:42:24.909]     ...future.result$conditions <- ...future.conditions
[17:42:24.909]     ...future.result$finished <- base::Sys.time()
[17:42:24.909]     ...future.result
[17:42:24.909] }
[17:42:24.911] Poll #1 (0): usedNodes() = 2, workers = 2
[17:42:24.922] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.922] - Validating connection of MultisessionFuture
[17:42:24.922] - received message: FutureResult
[17:42:24.922] - Received FutureResult
[17:42:24.922] - Erased future from FutureRegistry
[17:42:24.923] result() for ClusterFuture ...
[17:42:24.923] - result already collected: FutureResult
[17:42:24.923] result() for ClusterFuture ... done
[17:42:24.923] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.923] result() for ClusterFuture ...
[17:42:24.923] - result already collected: FutureResult
[17:42:24.923] result() for ClusterFuture ... done
[17:42:24.923] result() for ClusterFuture ...
[17:42:24.923] - result already collected: FutureResult
[17:42:24.923] result() for ClusterFuture ... done
[17:42:24.924] MultisessionFuture started
[17:42:24.925] - Launch lazy future ... done
[17:42:24.925] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55bef95c2310> 
Classes 'listenv', 'environment' <environment: 0x55bef82de388> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[17:42:24.932] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.933] - Validating connection of MultisessionFuture
[17:42:24.933] - received message: FutureResult
[17:42:24.933] - Received FutureResult
[17:42:24.933] - Erased future from FutureRegistry
[17:42:24.933] result() for ClusterFuture ...
[17:42:24.933] - result already collected: FutureResult
[17:42:24.933] result() for ClusterFuture ... done
[17:42:24.933] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[17:42:24.947] resolve() on list environment ...
[17:42:24.947]  recursive: 0
[17:42:24.948]  length: 6
[17:42:24.948]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[17:42:24.948] signalConditionsASAP(numeric, pos=1) ...
[17:42:24.948] - nx: 6
[17:42:24.949] - relay: TRUE
[17:42:24.949] - stdout: TRUE
[17:42:24.949] - signal: TRUE
[17:42:24.949] - resignal: FALSE
[17:42:24.949] - force: TRUE
[17:42:24.949] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.949] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.949]  - until=2
[17:42:24.949]  - relaying element #2
[17:42:24.949] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.949] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.949] signalConditionsASAP(NULL, pos=1) ... done
[17:42:24.950]  length: 5 (resolved future 1)
[17:42:24.950] Future #2
[17:42:24.950] result() for ClusterFuture ...
[17:42:24.950] - result already collected: FutureResult
[17:42:24.950] result() for ClusterFuture ... done
[17:42:24.950] result() for ClusterFuture ...
[17:42:24.950] - result already collected: FutureResult
[17:42:24.950] result() for ClusterFuture ... done
[17:42:24.950] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:42:24.950] - nx: 6
[17:42:24.951] - relay: TRUE
[17:42:24.951] - stdout: TRUE
[17:42:24.951] - signal: TRUE
[17:42:24.951] - resignal: FALSE
[17:42:24.951] - force: TRUE
[17:42:24.951] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.951] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[17:42:24.951]  - until=2
[17:42:24.951]  - relaying element #2
[17:42:24.951] result() for ClusterFuture ...
[17:42:24.952] - result already collected: FutureResult
[17:42:24.952] result() for ClusterFuture ... done
[17:42:24.952] result() for ClusterFuture ...
[17:42:24.952] - result already collected: FutureResult
[17:42:24.952] result() for ClusterFuture ... done
[17:42:24.952] result() for ClusterFuture ...
[17:42:24.952] - result already collected: FutureResult
[17:42:24.952] result() for ClusterFuture ... done
[17:42:24.952] result() for ClusterFuture ...
[17:42:24.952] - result already collected: FutureResult
[17:42:24.952] result() for ClusterFuture ... done
[17:42:24.953] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.953] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.953] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:42:24.953]  length: 4 (resolved future 2)
[17:42:24.953] Future #3
[17:42:24.953] result() for ClusterFuture ...
[17:42:24.953] - result already collected: FutureResult
[17:42:24.953] result() for ClusterFuture ... done
[17:42:24.953] result() for ClusterFuture ...
[17:42:24.953] - result already collected: FutureResult
[17:42:24.954] result() for ClusterFuture ... done
[17:42:24.954] signalConditionsASAP(MultisessionFuture, pos=3) ...
[17:42:24.954] - nx: 6
[17:42:24.954] - relay: TRUE
[17:42:24.954] - stdout: TRUE
[17:42:24.954] - signal: TRUE
[17:42:24.954] - resignal: FALSE
[17:42:24.954] - force: TRUE
[17:42:24.954] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.954] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[17:42:24.954]  - until=3
[17:42:24.955]  - relaying element #3
[17:42:24.955] result() for ClusterFuture ...
[17:42:24.955] - result already collected: FutureResult
[17:42:24.955] result() for ClusterFuture ... done
[17:42:24.955] result() for ClusterFuture ...
[17:42:24.955] - result already collected: FutureResult
[17:42:24.955] result() for ClusterFuture ... done
[17:42:24.955] result() for ClusterFuture ...
[17:42:24.955] - result already collected: FutureResult
[17:42:24.955] result() for ClusterFuture ... done
[17:42:24.955] result() for ClusterFuture ...
[17:42:24.956] - result already collected: FutureResult
[17:42:24.956] result() for ClusterFuture ... done
[17:42:24.956] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.956] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.956] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[17:42:24.956]  length: 3 (resolved future 3)
[17:42:24.967] signalConditionsASAP(NULL, pos=5) ...
[17:42:24.967] - nx: 6
[17:42:24.967] - relay: TRUE
[17:42:24.967] - stdout: TRUE
[17:42:24.967] - signal: TRUE
[17:42:24.967] - resignal: FALSE
[17:42:24.967] - force: TRUE
[17:42:24.968] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.968]  - until=6
[17:42:24.968]  - relaying element #4
[17:42:24.968]  - relaying element #6
[17:42:24.968] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.968] signalConditionsASAP(NULL, pos=5) ... done
[17:42:24.968]  length: 2 (resolved future 5)
[17:42:24.968] signalConditionsASAP(numeric, pos=6) ...
[17:42:24.969] - nx: 6
[17:42:24.969] - relay: TRUE
[17:42:24.969] - stdout: TRUE
[17:42:24.969] - signal: TRUE
[17:42:24.969] - resignal: FALSE
[17:42:24.969] - force: TRUE
[17:42:24.969] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[17:42:24.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.969]  - until=6
[17:42:24.969]  - relaying element #4
[17:42:24.969] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.970] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.970] signalConditionsASAP(NULL, pos=6) ... done
[17:42:24.970]  length: 1 (resolved future 6)
[17:42:24.980] receiveMessageFromWorker() for ClusterFuture ...
[17:42:24.981] - Validating connection of MultisessionFuture
[17:42:24.981] - received message: FutureResult
[17:42:24.981] - Received FutureResult
[17:42:24.981] - Erased future from FutureRegistry
[17:42:24.981] result() for ClusterFuture ...
[17:42:24.981] - result already collected: FutureResult
[17:42:24.981] result() for ClusterFuture ... done
[17:42:24.982] receiveMessageFromWorker() for ClusterFuture ... done
[17:42:24.982] Future #4
[17:42:24.982] result() for ClusterFuture ...
[17:42:24.982] - result already collected: FutureResult
[17:42:24.982] result() for ClusterFuture ... done
[17:42:24.982] result() for ClusterFuture ...
[17:42:24.982] - result already collected: FutureResult
[17:42:24.982] result() for ClusterFuture ... done
[17:42:24.982] signalConditionsASAP(MultisessionFuture, pos=4) ...
[17:42:24.982] - nx: 6
[17:42:24.983] - relay: TRUE
[17:42:24.983] - stdout: TRUE
[17:42:24.983] - signal: TRUE
[17:42:24.983] - resignal: FALSE
[17:42:24.983] - force: TRUE
[17:42:24.983] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[17:42:24.983] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[17:42:24.983]  - until=6
[17:42:24.983]  - relaying element #4
[17:42:24.983] result() for ClusterFuture ...
[17:42:24.983] - result already collected: FutureResult
[17:42:24.984] result() for ClusterFuture ... done
[17:42:24.984] result() for ClusterFuture ...
[17:42:24.984] - result already collected: FutureResult
[17:42:24.984] result() for ClusterFuture ... done
[17:42:24.984] result() for ClusterFuture ...
[17:42:24.984] - result already collected: FutureResult
[17:42:24.984] result() for ClusterFuture ... done
[17:42:24.984] result() for ClusterFuture ...
[17:42:24.984] - result already collected: FutureResult
[17:42:24.984] result() for ClusterFuture ... done
[17:42:24.984] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.985] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.985] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[17:42:24.985]  length: 0 (resolved future 4)
[17:42:24.985] Relaying remaining futures
[17:42:24.985] signalConditionsASAP(NULL, pos=0) ...
[17:42:24.985] - nx: 6
[17:42:24.985] - relay: TRUE
[17:42:24.985] - stdout: TRUE
[17:42:24.985] - signal: TRUE
[17:42:24.985] - resignal: FALSE
[17:42:24.985] - force: TRUE
[17:42:24.986] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.986] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[17:42:24.986] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[17:42:24.986] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[17:42:24.986] signalConditionsASAP(NULL, pos=0) ... done
[17:42:24.986] resolve() on list environment ... DONE
[17:42:24.986] result() for ClusterFuture ...
[17:42:24.986] - result already collected: FutureResult
[17:42:24.986] result() for ClusterFuture ... done
[17:42:24.986] result() for ClusterFuture ...
[17:42:24.987] - result already collected: FutureResult
[17:42:24.987] result() for ClusterFuture ... done
[17:42:24.987] result() for ClusterFuture ...
[17:42:24.987] - result already collected: FutureResult
[17:42:24.987] result() for ClusterFuture ... done
[17:42:24.987] result() for ClusterFuture ...
[17:42:24.987] - result already collected: FutureResult
[17:42:24.987] result() for ClusterFuture ... done
[17:42:24.988] result() for ClusterFuture ...
[17:42:24.988] - result already collected: FutureResult
[17:42:24.988] result() for ClusterFuture ... done
[17:42:24.988] result() for ClusterFuture ...
[17:42:24.988] - result already collected: FutureResult
[17:42:24.988] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55bef7b4d5d8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[17:42:24.991] plan(): Setting new future strategy stack:
[17:42:24.991] List of future strategies:
[17:42:24.991] 1. FutureStrategy:
[17:42:24.991]    - args: function (..., envir = parent.frame())
[17:42:24.991]    - tweaked: FALSE
[17:42:24.991]    - call: future::plan(oplan)
[17:42:24.992] plan(): nbrOfWorkers() = 1
> 
