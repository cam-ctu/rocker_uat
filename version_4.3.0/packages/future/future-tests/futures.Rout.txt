
R version 4.3.0 (2023-04-21) -- "Already Tomorrow"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:12:26.174] plan(): Setting new future strategy stack:
[16:12:26.175] List of future strategies:
[16:12:26.175] 1. sequential:
[16:12:26.175]    - args: function (..., envir = parent.frame())
[16:12:26.175]    - tweaked: FALSE
[16:12:26.175]    - call: future::plan("sequential")
[16:12:26.189] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[16:12:26.240] plan(): Setting new future strategy stack:
[16:12:26.241] List of future strategies:
[16:12:26.241] 1. sequential:
[16:12:26.241]    - args: function (..., envir = parent.frame())
[16:12:26.241]    - tweaked: FALSE
[16:12:26.241]    - call: plan(strategy)
[16:12:26.252] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:12:26.253] getGlobalsAndPackages() ...
[16:12:26.253] Searching for globals...
[16:12:26.255] 
[16:12:26.255] Searching for globals ... DONE
[16:12:26.256] - globals: [0] <none>
[16:12:26.256] getGlobalsAndPackages() ... DONE
[16:12:26.256] run() for ‘Future’ ...
[16:12:26.257] - state: ‘created’
[16:12:26.257] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.257]   - Field: ‘label’
[16:12:26.257]   - Field: ‘local’
[16:12:26.257]   - Field: ‘owner’
[16:12:26.258]   - Field: ‘envir’
[16:12:26.258]   - Field: ‘packages’
[16:12:26.258]   - Field: ‘gc’
[16:12:26.258]   - Field: ‘conditions’
[16:12:26.258]   - Field: ‘expr’
[16:12:26.258]   - Field: ‘uuid’
[16:12:26.258]   - Field: ‘seed’
[16:12:26.258]   - Field: ‘version’
[16:12:26.258]   - Field: ‘result’
[16:12:26.258]   - Field: ‘asynchronous’
[16:12:26.258]   - Field: ‘calls’
[16:12:26.259]   - Field: ‘globals’
[16:12:26.259]   - Field: ‘stdout’
[16:12:26.259]   - Field: ‘earlySignal’
[16:12:26.259]   - Field: ‘lazy’
[16:12:26.259]   - Field: ‘state’
[16:12:26.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.259] - Launch lazy future ...
[16:12:26.260] Packages needed by the future expression (n = 0): <none>
[16:12:26.260] Packages needed by future strategies (n = 0): <none>
[16:12:26.261] {
[16:12:26.261]     {
[16:12:26.261]         {
[16:12:26.261]             ...future.startTime <- base::Sys.time()
[16:12:26.261]             {
[16:12:26.261]                 {
[16:12:26.261]                   {
[16:12:26.261]                     base::local({
[16:12:26.261]                       has_future <- base::requireNamespace("future", 
[16:12:26.261]                         quietly = TRUE)
[16:12:26.261]                       if (has_future) {
[16:12:26.261]                         ns <- base::getNamespace("future")
[16:12:26.261]                         version <- ns[[".package"]][["version"]]
[16:12:26.261]                         if (is.null(version)) 
[16:12:26.261]                           version <- utils::packageVersion("future")
[16:12:26.261]                       }
[16:12:26.261]                       else {
[16:12:26.261]                         version <- NULL
[16:12:26.261]                       }
[16:12:26.261]                       if (!has_future || version < "1.8.0") {
[16:12:26.261]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.261]                           "", base::R.version$version.string), 
[16:12:26.261]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.261]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.261]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.261]                             "release", "version")], collapse = " "), 
[16:12:26.261]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.261]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.261]                           info)
[16:12:26.261]                         info <- base::paste(info, collapse = "; ")
[16:12:26.261]                         if (!has_future) {
[16:12:26.261]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.261]                             info)
[16:12:26.261]                         }
[16:12:26.261]                         else {
[16:12:26.261]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.261]                             info, version)
[16:12:26.261]                         }
[16:12:26.261]                         base::stop(msg)
[16:12:26.261]                       }
[16:12:26.261]                     })
[16:12:26.261]                   }
[16:12:26.261]                   options(future.plan = NULL)
[16:12:26.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.261]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.261]                 }
[16:12:26.261]                 ...future.workdir <- getwd()
[16:12:26.261]             }
[16:12:26.261]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.261]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.261]         }
[16:12:26.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.261]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.261]             base::names(...future.oldOptions))
[16:12:26.261]     }
[16:12:26.261]     if (FALSE) {
[16:12:26.261]     }
[16:12:26.261]     else {
[16:12:26.261]         if (TRUE) {
[16:12:26.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.261]                 open = "w")
[16:12:26.261]         }
[16:12:26.261]         else {
[16:12:26.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.261]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.261]         }
[16:12:26.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.261]             base::sink(type = "output", split = FALSE)
[16:12:26.261]             base::close(...future.stdout)
[16:12:26.261]         }, add = TRUE)
[16:12:26.261]     }
[16:12:26.261]     ...future.frame <- base::sys.nframe()
[16:12:26.261]     ...future.conditions <- base::list()
[16:12:26.261]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.261]     if (FALSE) {
[16:12:26.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.261]     }
[16:12:26.261]     ...future.result <- base::tryCatch({
[16:12:26.261]         base::withCallingHandlers({
[16:12:26.261]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.261]             future::FutureResult(value = ...future.value$value, 
[16:12:26.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.261]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.261]                     ...future.globalenv.names))
[16:12:26.261]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.261]         }, condition = base::local({
[16:12:26.261]             c <- base::c
[16:12:26.261]             inherits <- base::inherits
[16:12:26.261]             invokeRestart <- base::invokeRestart
[16:12:26.261]             length <- base::length
[16:12:26.261]             list <- base::list
[16:12:26.261]             seq.int <- base::seq.int
[16:12:26.261]             signalCondition <- base::signalCondition
[16:12:26.261]             sys.calls <- base::sys.calls
[16:12:26.261]             `[[` <- base::`[[`
[16:12:26.261]             `+` <- base::`+`
[16:12:26.261]             `<<-` <- base::`<<-`
[16:12:26.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.261]                   3L)]
[16:12:26.261]             }
[16:12:26.261]             function(cond) {
[16:12:26.261]                 is_error <- inherits(cond, "error")
[16:12:26.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.261]                   NULL)
[16:12:26.261]                 if (is_error) {
[16:12:26.261]                   sessionInformation <- function() {
[16:12:26.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.261]                       search = base::search(), system = base::Sys.info())
[16:12:26.261]                   }
[16:12:26.261]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.261]                     cond$call), session = sessionInformation(), 
[16:12:26.261]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.261]                   signalCondition(cond)
[16:12:26.261]                 }
[16:12:26.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.261]                 "immediateCondition"))) {
[16:12:26.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.261]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.261]                   if (TRUE && !signal) {
[16:12:26.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.261]                     {
[16:12:26.261]                       inherits <- base::inherits
[16:12:26.261]                       invokeRestart <- base::invokeRestart
[16:12:26.261]                       is.null <- base::is.null
[16:12:26.261]                       muffled <- FALSE
[16:12:26.261]                       if (inherits(cond, "message")) {
[16:12:26.261]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.261]                         if (muffled) 
[16:12:26.261]                           invokeRestart("muffleMessage")
[16:12:26.261]                       }
[16:12:26.261]                       else if (inherits(cond, "warning")) {
[16:12:26.261]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.261]                         if (muffled) 
[16:12:26.261]                           invokeRestart("muffleWarning")
[16:12:26.261]                       }
[16:12:26.261]                       else if (inherits(cond, "condition")) {
[16:12:26.261]                         if (!is.null(pattern)) {
[16:12:26.261]                           computeRestarts <- base::computeRestarts
[16:12:26.261]                           grepl <- base::grepl
[16:12:26.261]                           restarts <- computeRestarts(cond)
[16:12:26.261]                           for (restart in restarts) {
[16:12:26.261]                             name <- restart$name
[16:12:26.261]                             if (is.null(name)) 
[16:12:26.261]                               next
[16:12:26.261]                             if (!grepl(pattern, name)) 
[16:12:26.261]                               next
[16:12:26.261]                             invokeRestart(restart)
[16:12:26.261]                             muffled <- TRUE
[16:12:26.261]                             break
[16:12:26.261]                           }
[16:12:26.261]                         }
[16:12:26.261]                       }
[16:12:26.261]                       invisible(muffled)
[16:12:26.261]                     }
[16:12:26.261]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.261]                   }
[16:12:26.261]                 }
[16:12:26.261]                 else {
[16:12:26.261]                   if (TRUE) {
[16:12:26.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.261]                     {
[16:12:26.261]                       inherits <- base::inherits
[16:12:26.261]                       invokeRestart <- base::invokeRestart
[16:12:26.261]                       is.null <- base::is.null
[16:12:26.261]                       muffled <- FALSE
[16:12:26.261]                       if (inherits(cond, "message")) {
[16:12:26.261]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.261]                         if (muffled) 
[16:12:26.261]                           invokeRestart("muffleMessage")
[16:12:26.261]                       }
[16:12:26.261]                       else if (inherits(cond, "warning")) {
[16:12:26.261]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.261]                         if (muffled) 
[16:12:26.261]                           invokeRestart("muffleWarning")
[16:12:26.261]                       }
[16:12:26.261]                       else if (inherits(cond, "condition")) {
[16:12:26.261]                         if (!is.null(pattern)) {
[16:12:26.261]                           computeRestarts <- base::computeRestarts
[16:12:26.261]                           grepl <- base::grepl
[16:12:26.261]                           restarts <- computeRestarts(cond)
[16:12:26.261]                           for (restart in restarts) {
[16:12:26.261]                             name <- restart$name
[16:12:26.261]                             if (is.null(name)) 
[16:12:26.261]                               next
[16:12:26.261]                             if (!grepl(pattern, name)) 
[16:12:26.261]                               next
[16:12:26.261]                             invokeRestart(restart)
[16:12:26.261]                             muffled <- TRUE
[16:12:26.261]                             break
[16:12:26.261]                           }
[16:12:26.261]                         }
[16:12:26.261]                       }
[16:12:26.261]                       invisible(muffled)
[16:12:26.261]                     }
[16:12:26.261]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.261]                   }
[16:12:26.261]                 }
[16:12:26.261]             }
[16:12:26.261]         }))
[16:12:26.261]     }, error = function(ex) {
[16:12:26.261]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.261]                 ...future.rng), started = ...future.startTime, 
[16:12:26.261]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.261]             version = "1.8"), class = "FutureResult")
[16:12:26.261]     }, finally = {
[16:12:26.261]         if (!identical(...future.workdir, getwd())) 
[16:12:26.261]             setwd(...future.workdir)
[16:12:26.261]         {
[16:12:26.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.261]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.261]             }
[16:12:26.261]             base::options(...future.oldOptions)
[16:12:26.261]             if (.Platform$OS.type == "windows") {
[16:12:26.261]                 old_names <- names(...future.oldEnvVars)
[16:12:26.261]                 envs <- base::Sys.getenv()
[16:12:26.261]                 names <- names(envs)
[16:12:26.261]                 common <- intersect(names, old_names)
[16:12:26.261]                 added <- setdiff(names, old_names)
[16:12:26.261]                 removed <- setdiff(old_names, names)
[16:12:26.261]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.261]                   envs[common]]
[16:12:26.261]                 NAMES <- toupper(changed)
[16:12:26.261]                 args <- list()
[16:12:26.261]                 for (kk in seq_along(NAMES)) {
[16:12:26.261]                   name <- changed[[kk]]
[16:12:26.261]                   NAME <- NAMES[[kk]]
[16:12:26.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.261]                     next
[16:12:26.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.261]                 }
[16:12:26.261]                 NAMES <- toupper(added)
[16:12:26.261]                 for (kk in seq_along(NAMES)) {
[16:12:26.261]                   name <- added[[kk]]
[16:12:26.261]                   NAME <- NAMES[[kk]]
[16:12:26.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.261]                     next
[16:12:26.261]                   args[[name]] <- ""
[16:12:26.261]                 }
[16:12:26.261]                 NAMES <- toupper(removed)
[16:12:26.261]                 for (kk in seq_along(NAMES)) {
[16:12:26.261]                   name <- removed[[kk]]
[16:12:26.261]                   NAME <- NAMES[[kk]]
[16:12:26.261]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.261]                     next
[16:12:26.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.261]                 }
[16:12:26.261]                 if (length(args) > 0) 
[16:12:26.261]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.261]             }
[16:12:26.261]             else {
[16:12:26.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.261]             }
[16:12:26.261]             {
[16:12:26.261]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.261]                   0L) {
[16:12:26.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.261]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.261]                   base::options(opts)
[16:12:26.261]                 }
[16:12:26.261]                 {
[16:12:26.261]                   {
[16:12:26.261]                     NULL
[16:12:26.261]                     RNGkind("Mersenne-Twister")
[16:12:26.261]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.261]                       inherits = FALSE)
[16:12:26.261]                   }
[16:12:26.261]                   options(future.plan = NULL)
[16:12:26.261]                   if (is.na(NA_character_)) 
[16:12:26.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.261]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.261]                   {
[16:12:26.261]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.261]                     if (!future$lazy) 
[16:12:26.261]                       future <- run(future)
[16:12:26.261]                     invisible(future)
[16:12:26.261]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.261]                 }
[16:12:26.261]             }
[16:12:26.261]         }
[16:12:26.261]     })
[16:12:26.261]     if (TRUE) {
[16:12:26.261]         base::sink(type = "output", split = FALSE)
[16:12:26.261]         if (TRUE) {
[16:12:26.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.261]         }
[16:12:26.261]         else {
[16:12:26.261]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.261]         }
[16:12:26.261]         base::close(...future.stdout)
[16:12:26.261]         ...future.stdout <- NULL
[16:12:26.261]     }
[16:12:26.261]     ...future.result$conditions <- ...future.conditions
[16:12:26.261]     ...future.result$finished <- base::Sys.time()
[16:12:26.261]     ...future.result
[16:12:26.261] }
[16:12:26.263] plan(): Setting new future strategy stack:
[16:12:26.263] List of future strategies:
[16:12:26.263] 1. sequential:
[16:12:26.263]    - args: function (..., envir = parent.frame())
[16:12:26.263]    - tweaked: FALSE
[16:12:26.263]    - call: NULL
[16:12:26.263] plan(): nbrOfWorkers() = 1
[16:12:26.264] plan(): Setting new future strategy stack:
[16:12:26.264] List of future strategies:
[16:12:26.264] 1. sequential:
[16:12:26.264]    - args: function (..., envir = parent.frame())
[16:12:26.264]    - tweaked: FALSE
[16:12:26.264]    - call: plan(strategy)
[16:12:26.265] plan(): nbrOfWorkers() = 1
[16:12:26.265] SequentialFuture started (and completed)
[16:12:26.265] - Launch lazy future ... done
[16:12:26.265] run() for ‘SequentialFuture’ ... done
[16:12:26.266] getGlobalsAndPackages() ...
[16:12:26.266] Searching for globals...
[16:12:26.266] 
[16:12:26.266] Searching for globals ... DONE
[16:12:26.266] - globals: [0] <none>
[16:12:26.266] getGlobalsAndPackages() ... DONE
[16:12:26.266] run() for ‘Future’ ...
[16:12:26.266] - state: ‘created’
[16:12:26.267] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.267] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.267]   - Field: ‘label’
[16:12:26.267]   - Field: ‘local’
[16:12:26.267]   - Field: ‘owner’
[16:12:26.267]   - Field: ‘envir’
[16:12:26.267]   - Field: ‘packages’
[16:12:26.268]   - Field: ‘gc’
[16:12:26.268]   - Field: ‘conditions’
[16:12:26.268]   - Field: ‘expr’
[16:12:26.268]   - Field: ‘uuid’
[16:12:26.268]   - Field: ‘seed’
[16:12:26.268]   - Field: ‘version’
[16:12:26.268]   - Field: ‘result’
[16:12:26.268]   - Field: ‘asynchronous’
[16:12:26.268]   - Field: ‘calls’
[16:12:26.268]   - Field: ‘globals’
[16:12:26.268]   - Field: ‘stdout’
[16:12:26.269]   - Field: ‘earlySignal’
[16:12:26.269]   - Field: ‘lazy’
[16:12:26.269]   - Field: ‘state’
[16:12:26.269] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.269] - Launch lazy future ...
[16:12:26.269] Packages needed by the future expression (n = 0): <none>
[16:12:26.269] Packages needed by future strategies (n = 0): <none>
[16:12:26.270] {
[16:12:26.270]     {
[16:12:26.270]         {
[16:12:26.270]             ...future.startTime <- base::Sys.time()
[16:12:26.270]             {
[16:12:26.270]                 {
[16:12:26.270]                   {
[16:12:26.270]                     base::local({
[16:12:26.270]                       has_future <- base::requireNamespace("future", 
[16:12:26.270]                         quietly = TRUE)
[16:12:26.270]                       if (has_future) {
[16:12:26.270]                         ns <- base::getNamespace("future")
[16:12:26.270]                         version <- ns[[".package"]][["version"]]
[16:12:26.270]                         if (is.null(version)) 
[16:12:26.270]                           version <- utils::packageVersion("future")
[16:12:26.270]                       }
[16:12:26.270]                       else {
[16:12:26.270]                         version <- NULL
[16:12:26.270]                       }
[16:12:26.270]                       if (!has_future || version < "1.8.0") {
[16:12:26.270]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.270]                           "", base::R.version$version.string), 
[16:12:26.270]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.270]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.270]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.270]                             "release", "version")], collapse = " "), 
[16:12:26.270]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.270]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.270]                           info)
[16:12:26.270]                         info <- base::paste(info, collapse = "; ")
[16:12:26.270]                         if (!has_future) {
[16:12:26.270]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.270]                             info)
[16:12:26.270]                         }
[16:12:26.270]                         else {
[16:12:26.270]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.270]                             info, version)
[16:12:26.270]                         }
[16:12:26.270]                         base::stop(msg)
[16:12:26.270]                       }
[16:12:26.270]                     })
[16:12:26.270]                   }
[16:12:26.270]                   options(future.plan = NULL)
[16:12:26.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.270]                 }
[16:12:26.270]                 ...future.workdir <- getwd()
[16:12:26.270]             }
[16:12:26.270]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.270]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.270]         }
[16:12:26.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.270]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.270]             base::names(...future.oldOptions))
[16:12:26.270]     }
[16:12:26.270]     if (FALSE) {
[16:12:26.270]     }
[16:12:26.270]     else {
[16:12:26.270]         if (TRUE) {
[16:12:26.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.270]                 open = "w")
[16:12:26.270]         }
[16:12:26.270]         else {
[16:12:26.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.270]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.270]         }
[16:12:26.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.270]             base::sink(type = "output", split = FALSE)
[16:12:26.270]             base::close(...future.stdout)
[16:12:26.270]         }, add = TRUE)
[16:12:26.270]     }
[16:12:26.270]     ...future.frame <- base::sys.nframe()
[16:12:26.270]     ...future.conditions <- base::list()
[16:12:26.270]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.270]     if (FALSE) {
[16:12:26.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.270]     }
[16:12:26.270]     ...future.result <- base::tryCatch({
[16:12:26.270]         base::withCallingHandlers({
[16:12:26.270]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.270]             future::FutureResult(value = ...future.value$value, 
[16:12:26.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.270]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.270]                     ...future.globalenv.names))
[16:12:26.270]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.270]         }, condition = base::local({
[16:12:26.270]             c <- base::c
[16:12:26.270]             inherits <- base::inherits
[16:12:26.270]             invokeRestart <- base::invokeRestart
[16:12:26.270]             length <- base::length
[16:12:26.270]             list <- base::list
[16:12:26.270]             seq.int <- base::seq.int
[16:12:26.270]             signalCondition <- base::signalCondition
[16:12:26.270]             sys.calls <- base::sys.calls
[16:12:26.270]             `[[` <- base::`[[`
[16:12:26.270]             `+` <- base::`+`
[16:12:26.270]             `<<-` <- base::`<<-`
[16:12:26.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.270]                   3L)]
[16:12:26.270]             }
[16:12:26.270]             function(cond) {
[16:12:26.270]                 is_error <- inherits(cond, "error")
[16:12:26.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.270]                   NULL)
[16:12:26.270]                 if (is_error) {
[16:12:26.270]                   sessionInformation <- function() {
[16:12:26.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.270]                       search = base::search(), system = base::Sys.info())
[16:12:26.270]                   }
[16:12:26.270]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.270]                     cond$call), session = sessionInformation(), 
[16:12:26.270]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.270]                   signalCondition(cond)
[16:12:26.270]                 }
[16:12:26.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.270]                 "immediateCondition"))) {
[16:12:26.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.270]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.270]                   if (TRUE && !signal) {
[16:12:26.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.270]                     {
[16:12:26.270]                       inherits <- base::inherits
[16:12:26.270]                       invokeRestart <- base::invokeRestart
[16:12:26.270]                       is.null <- base::is.null
[16:12:26.270]                       muffled <- FALSE
[16:12:26.270]                       if (inherits(cond, "message")) {
[16:12:26.270]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.270]                         if (muffled) 
[16:12:26.270]                           invokeRestart("muffleMessage")
[16:12:26.270]                       }
[16:12:26.270]                       else if (inherits(cond, "warning")) {
[16:12:26.270]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.270]                         if (muffled) 
[16:12:26.270]                           invokeRestart("muffleWarning")
[16:12:26.270]                       }
[16:12:26.270]                       else if (inherits(cond, "condition")) {
[16:12:26.270]                         if (!is.null(pattern)) {
[16:12:26.270]                           computeRestarts <- base::computeRestarts
[16:12:26.270]                           grepl <- base::grepl
[16:12:26.270]                           restarts <- computeRestarts(cond)
[16:12:26.270]                           for (restart in restarts) {
[16:12:26.270]                             name <- restart$name
[16:12:26.270]                             if (is.null(name)) 
[16:12:26.270]                               next
[16:12:26.270]                             if (!grepl(pattern, name)) 
[16:12:26.270]                               next
[16:12:26.270]                             invokeRestart(restart)
[16:12:26.270]                             muffled <- TRUE
[16:12:26.270]                             break
[16:12:26.270]                           }
[16:12:26.270]                         }
[16:12:26.270]                       }
[16:12:26.270]                       invisible(muffled)
[16:12:26.270]                     }
[16:12:26.270]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.270]                   }
[16:12:26.270]                 }
[16:12:26.270]                 else {
[16:12:26.270]                   if (TRUE) {
[16:12:26.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.270]                     {
[16:12:26.270]                       inherits <- base::inherits
[16:12:26.270]                       invokeRestart <- base::invokeRestart
[16:12:26.270]                       is.null <- base::is.null
[16:12:26.270]                       muffled <- FALSE
[16:12:26.270]                       if (inherits(cond, "message")) {
[16:12:26.270]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.270]                         if (muffled) 
[16:12:26.270]                           invokeRestart("muffleMessage")
[16:12:26.270]                       }
[16:12:26.270]                       else if (inherits(cond, "warning")) {
[16:12:26.270]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.270]                         if (muffled) 
[16:12:26.270]                           invokeRestart("muffleWarning")
[16:12:26.270]                       }
[16:12:26.270]                       else if (inherits(cond, "condition")) {
[16:12:26.270]                         if (!is.null(pattern)) {
[16:12:26.270]                           computeRestarts <- base::computeRestarts
[16:12:26.270]                           grepl <- base::grepl
[16:12:26.270]                           restarts <- computeRestarts(cond)
[16:12:26.270]                           for (restart in restarts) {
[16:12:26.270]                             name <- restart$name
[16:12:26.270]                             if (is.null(name)) 
[16:12:26.270]                               next
[16:12:26.270]                             if (!grepl(pattern, name)) 
[16:12:26.270]                               next
[16:12:26.270]                             invokeRestart(restart)
[16:12:26.270]                             muffled <- TRUE
[16:12:26.270]                             break
[16:12:26.270]                           }
[16:12:26.270]                         }
[16:12:26.270]                       }
[16:12:26.270]                       invisible(muffled)
[16:12:26.270]                     }
[16:12:26.270]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.270]                   }
[16:12:26.270]                 }
[16:12:26.270]             }
[16:12:26.270]         }))
[16:12:26.270]     }, error = function(ex) {
[16:12:26.270]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.270]                 ...future.rng), started = ...future.startTime, 
[16:12:26.270]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.270]             version = "1.8"), class = "FutureResult")
[16:12:26.270]     }, finally = {
[16:12:26.270]         if (!identical(...future.workdir, getwd())) 
[16:12:26.270]             setwd(...future.workdir)
[16:12:26.270]         {
[16:12:26.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.270]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.270]             }
[16:12:26.270]             base::options(...future.oldOptions)
[16:12:26.270]             if (.Platform$OS.type == "windows") {
[16:12:26.270]                 old_names <- names(...future.oldEnvVars)
[16:12:26.270]                 envs <- base::Sys.getenv()
[16:12:26.270]                 names <- names(envs)
[16:12:26.270]                 common <- intersect(names, old_names)
[16:12:26.270]                 added <- setdiff(names, old_names)
[16:12:26.270]                 removed <- setdiff(old_names, names)
[16:12:26.270]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.270]                   envs[common]]
[16:12:26.270]                 NAMES <- toupper(changed)
[16:12:26.270]                 args <- list()
[16:12:26.270]                 for (kk in seq_along(NAMES)) {
[16:12:26.270]                   name <- changed[[kk]]
[16:12:26.270]                   NAME <- NAMES[[kk]]
[16:12:26.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.270]                     next
[16:12:26.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.270]                 }
[16:12:26.270]                 NAMES <- toupper(added)
[16:12:26.270]                 for (kk in seq_along(NAMES)) {
[16:12:26.270]                   name <- added[[kk]]
[16:12:26.270]                   NAME <- NAMES[[kk]]
[16:12:26.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.270]                     next
[16:12:26.270]                   args[[name]] <- ""
[16:12:26.270]                 }
[16:12:26.270]                 NAMES <- toupper(removed)
[16:12:26.270]                 for (kk in seq_along(NAMES)) {
[16:12:26.270]                   name <- removed[[kk]]
[16:12:26.270]                   NAME <- NAMES[[kk]]
[16:12:26.270]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.270]                     next
[16:12:26.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.270]                 }
[16:12:26.270]                 if (length(args) > 0) 
[16:12:26.270]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.270]             }
[16:12:26.270]             else {
[16:12:26.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.270]             }
[16:12:26.270]             {
[16:12:26.270]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.270]                   0L) {
[16:12:26.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.270]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.270]                   base::options(opts)
[16:12:26.270]                 }
[16:12:26.270]                 {
[16:12:26.270]                   {
[16:12:26.270]                     NULL
[16:12:26.270]                     RNGkind("Mersenne-Twister")
[16:12:26.270]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.270]                       inherits = FALSE)
[16:12:26.270]                   }
[16:12:26.270]                   options(future.plan = NULL)
[16:12:26.270]                   if (is.na(NA_character_)) 
[16:12:26.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.270]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.270]                   {
[16:12:26.270]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.270]                     if (!future$lazy) 
[16:12:26.270]                       future <- run(future)
[16:12:26.270]                     invisible(future)
[16:12:26.270]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.270]                 }
[16:12:26.270]             }
[16:12:26.270]         }
[16:12:26.270]     })
[16:12:26.270]     if (TRUE) {
[16:12:26.270]         base::sink(type = "output", split = FALSE)
[16:12:26.270]         if (TRUE) {
[16:12:26.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.270]         }
[16:12:26.270]         else {
[16:12:26.270]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.270]         }
[16:12:26.270]         base::close(...future.stdout)
[16:12:26.270]         ...future.stdout <- NULL
[16:12:26.270]     }
[16:12:26.270]     ...future.result$conditions <- ...future.conditions
[16:12:26.270]     ...future.result$finished <- base::Sys.time()
[16:12:26.270]     ...future.result
[16:12:26.270] }
[16:12:26.271] plan(): Setting new future strategy stack:
[16:12:26.271] List of future strategies:
[16:12:26.271] 1. sequential:
[16:12:26.271]    - args: function (..., envir = parent.frame())
[16:12:26.271]    - tweaked: FALSE
[16:12:26.271]    - call: NULL
[16:12:26.272] plan(): nbrOfWorkers() = 1
[16:12:26.272] plan(): Setting new future strategy stack:
[16:12:26.272] List of future strategies:
[16:12:26.272] 1. sequential:
[16:12:26.272]    - args: function (..., envir = parent.frame())
[16:12:26.272]    - tweaked: FALSE
[16:12:26.272]    - call: plan(strategy)
[16:12:26.273] plan(): nbrOfWorkers() = 1
[16:12:26.273] SequentialFuture started (and completed)
[16:12:26.273] - Launch lazy future ... done
[16:12:26.273] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bae975c60> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baed9e7c8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bae975c60> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baed9e7c8> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:12:26.281] resolved() for ‘SequentialFuture’ ...
[16:12:26.281] - state: ‘finished’
[16:12:26.281] - run: TRUE
[16:12:26.281] - result: ‘FutureResult’
[16:12:26.281] resolved() for ‘SequentialFuture’ ... done
[16:12:26.281] resolved() for ‘SequentialFuture’ ...
[16:12:26.282] - state: ‘finished’
[16:12:26.282] - run: TRUE
[16:12:26.282] - result: ‘FutureResult’
[16:12:26.282] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:26.283] resolve() on list ...
[16:12:26.283]  recursive: 0
[16:12:26.283]  length: 6
[16:12:26.283]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:26.283] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.284] - nx: 6
[16:12:26.284] - relay: TRUE
[16:12:26.284] - stdout: TRUE
[16:12:26.284] - signal: TRUE
[16:12:26.284] - resignal: FALSE
[16:12:26.284] - force: TRUE
[16:12:26.284] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.284] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.284]  - until=2
[16:12:26.284]  - relaying element #2
[16:12:26.284] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.284] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.285] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.285]  length: 5 (resolved future 1)
[16:12:26.285] resolved() for ‘SequentialFuture’ ...
[16:12:26.285] - state: ‘finished’
[16:12:26.285] - run: TRUE
[16:12:26.285] - result: ‘FutureResult’
[16:12:26.285] resolved() for ‘SequentialFuture’ ... done
[16:12:26.285] Future #2
[16:12:26.286] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.286] - nx: 6
[16:12:26.286] - relay: TRUE
[16:12:26.286] - stdout: TRUE
[16:12:26.286] - signal: TRUE
[16:12:26.286] - resignal: FALSE
[16:12:26.286] - force: TRUE
[16:12:26.286] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.286] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.286]  - until=2
[16:12:26.286]  - relaying element #2
[16:12:26.287] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.287] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.287] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.287]  length: 4 (resolved future 2)
[16:12:26.287] resolved() for ‘SequentialFuture’ ...
[16:12:26.287] - state: ‘finished’
[16:12:26.287] - run: TRUE
[16:12:26.287] - result: ‘FutureResult’
[16:12:26.287] resolved() for ‘SequentialFuture’ ... done
[16:12:26.288] Future #3
[16:12:26.288] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.288] - nx: 6
[16:12:26.288] - relay: TRUE
[16:12:26.288] - stdout: TRUE
[16:12:26.288] - signal: TRUE
[16:12:26.288] - resignal: FALSE
[16:12:26.288] - force: TRUE
[16:12:26.288] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.288] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.288]  - until=3
[16:12:26.289]  - relaying element #3
[16:12:26.289] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.289] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.289] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.289]  length: 3 (resolved future 3)
[16:12:26.289] signalConditionsASAP(NULL, pos=4) ...
[16:12:26.289] - nx: 6
[16:12:26.289] - relay: TRUE
[16:12:26.289] - stdout: TRUE
[16:12:26.289] - signal: TRUE
[16:12:26.289] - resignal: FALSE
[16:12:26.290] - force: TRUE
[16:12:26.290] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.290] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.290]  - until=5
[16:12:26.290]  - relaying element #5
[16:12:26.290] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.290] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.290] signalConditionsASAP(NULL, pos=4) ... done
[16:12:26.290]  length: 2 (resolved future 4)
[16:12:26.290] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.290] - nx: 6
[16:12:26.290] - relay: TRUE
[16:12:26.291] - stdout: TRUE
[16:12:26.291] - signal: TRUE
[16:12:26.291] - resignal: FALSE
[16:12:26.291] - force: TRUE
[16:12:26.291] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.291] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.291]  - until=6
[16:12:26.291]  - relaying element #6
[16:12:26.291] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.291] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.291] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.291]  length: 1 (resolved future 5)
[16:12:26.292] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.292] - nx: 6
[16:12:26.292] - relay: TRUE
[16:12:26.292] - stdout: TRUE
[16:12:26.292] - signal: TRUE
[16:12:26.292] - resignal: FALSE
[16:12:26.292] - force: TRUE
[16:12:26.292] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.292] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.292]  - until=6
[16:12:26.292] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.292] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.293] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.293]  length: 0 (resolved future 6)
[16:12:26.293] Relaying remaining futures
[16:12:26.293] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.293] - nx: 6
[16:12:26.293] - relay: TRUE
[16:12:26.293] - stdout: TRUE
[16:12:26.293] - signal: TRUE
[16:12:26.293] - resignal: FALSE
[16:12:26.293] - force: TRUE
[16:12:26.293] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.293] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:26.294] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.294] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.294] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.294] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:12:26.296] getGlobalsAndPackages() ...
[16:12:26.296] Searching for globals...
[16:12:26.296] 
[16:12:26.296] Searching for globals ... DONE
[16:12:26.296] - globals: [0] <none>
[16:12:26.296] getGlobalsAndPackages() ... DONE
[16:12:26.297] run() for ‘Future’ ...
[16:12:26.297] - state: ‘created’
[16:12:26.297] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.297] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.297] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.297]   - Field: ‘label’
[16:12:26.297]   - Field: ‘local’
[16:12:26.298]   - Field: ‘owner’
[16:12:26.298]   - Field: ‘envir’
[16:12:26.298]   - Field: ‘packages’
[16:12:26.298]   - Field: ‘gc’
[16:12:26.298]   - Field: ‘conditions’
[16:12:26.298]   - Field: ‘expr’
[16:12:26.298]   - Field: ‘uuid’
[16:12:26.298]   - Field: ‘seed’
[16:12:26.298]   - Field: ‘version’
[16:12:26.298]   - Field: ‘result’
[16:12:26.298]   - Field: ‘asynchronous’
[16:12:26.299]   - Field: ‘calls’
[16:12:26.299]   - Field: ‘globals’
[16:12:26.299]   - Field: ‘stdout’
[16:12:26.299]   - Field: ‘earlySignal’
[16:12:26.299]   - Field: ‘lazy’
[16:12:26.299]   - Field: ‘state’
[16:12:26.299] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.299] - Launch lazy future ...
[16:12:26.299] Packages needed by the future expression (n = 0): <none>
[16:12:26.299] Packages needed by future strategies (n = 0): <none>
[16:12:26.300] {
[16:12:26.300]     {
[16:12:26.300]         {
[16:12:26.300]             ...future.startTime <- base::Sys.time()
[16:12:26.300]             {
[16:12:26.300]                 {
[16:12:26.300]                   {
[16:12:26.300]                     base::local({
[16:12:26.300]                       has_future <- base::requireNamespace("future", 
[16:12:26.300]                         quietly = TRUE)
[16:12:26.300]                       if (has_future) {
[16:12:26.300]                         ns <- base::getNamespace("future")
[16:12:26.300]                         version <- ns[[".package"]][["version"]]
[16:12:26.300]                         if (is.null(version)) 
[16:12:26.300]                           version <- utils::packageVersion("future")
[16:12:26.300]                       }
[16:12:26.300]                       else {
[16:12:26.300]                         version <- NULL
[16:12:26.300]                       }
[16:12:26.300]                       if (!has_future || version < "1.8.0") {
[16:12:26.300]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.300]                           "", base::R.version$version.string), 
[16:12:26.300]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.300]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.300]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.300]                             "release", "version")], collapse = " "), 
[16:12:26.300]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.300]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.300]                           info)
[16:12:26.300]                         info <- base::paste(info, collapse = "; ")
[16:12:26.300]                         if (!has_future) {
[16:12:26.300]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.300]                             info)
[16:12:26.300]                         }
[16:12:26.300]                         else {
[16:12:26.300]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.300]                             info, version)
[16:12:26.300]                         }
[16:12:26.300]                         base::stop(msg)
[16:12:26.300]                       }
[16:12:26.300]                     })
[16:12:26.300]                   }
[16:12:26.300]                   options(future.plan = NULL)
[16:12:26.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.300]                 }
[16:12:26.300]                 ...future.workdir <- getwd()
[16:12:26.300]             }
[16:12:26.300]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.300]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.300]         }
[16:12:26.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.300]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.300]             base::names(...future.oldOptions))
[16:12:26.300]     }
[16:12:26.300]     if (FALSE) {
[16:12:26.300]     }
[16:12:26.300]     else {
[16:12:26.300]         if (TRUE) {
[16:12:26.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.300]                 open = "w")
[16:12:26.300]         }
[16:12:26.300]         else {
[16:12:26.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.300]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.300]         }
[16:12:26.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.300]             base::sink(type = "output", split = FALSE)
[16:12:26.300]             base::close(...future.stdout)
[16:12:26.300]         }, add = TRUE)
[16:12:26.300]     }
[16:12:26.300]     ...future.frame <- base::sys.nframe()
[16:12:26.300]     ...future.conditions <- base::list()
[16:12:26.300]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.300]     if (FALSE) {
[16:12:26.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.300]     }
[16:12:26.300]     ...future.result <- base::tryCatch({
[16:12:26.300]         base::withCallingHandlers({
[16:12:26.300]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.300]             future::FutureResult(value = ...future.value$value, 
[16:12:26.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.300]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.300]                     ...future.globalenv.names))
[16:12:26.300]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.300]         }, condition = base::local({
[16:12:26.300]             c <- base::c
[16:12:26.300]             inherits <- base::inherits
[16:12:26.300]             invokeRestart <- base::invokeRestart
[16:12:26.300]             length <- base::length
[16:12:26.300]             list <- base::list
[16:12:26.300]             seq.int <- base::seq.int
[16:12:26.300]             signalCondition <- base::signalCondition
[16:12:26.300]             sys.calls <- base::sys.calls
[16:12:26.300]             `[[` <- base::`[[`
[16:12:26.300]             `+` <- base::`+`
[16:12:26.300]             `<<-` <- base::`<<-`
[16:12:26.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.300]                   3L)]
[16:12:26.300]             }
[16:12:26.300]             function(cond) {
[16:12:26.300]                 is_error <- inherits(cond, "error")
[16:12:26.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.300]                   NULL)
[16:12:26.300]                 if (is_error) {
[16:12:26.300]                   sessionInformation <- function() {
[16:12:26.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.300]                       search = base::search(), system = base::Sys.info())
[16:12:26.300]                   }
[16:12:26.300]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.300]                     cond$call), session = sessionInformation(), 
[16:12:26.300]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.300]                   signalCondition(cond)
[16:12:26.300]                 }
[16:12:26.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.300]                 "immediateCondition"))) {
[16:12:26.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.300]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.300]                   if (TRUE && !signal) {
[16:12:26.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.300]                     {
[16:12:26.300]                       inherits <- base::inherits
[16:12:26.300]                       invokeRestart <- base::invokeRestart
[16:12:26.300]                       is.null <- base::is.null
[16:12:26.300]                       muffled <- FALSE
[16:12:26.300]                       if (inherits(cond, "message")) {
[16:12:26.300]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.300]                         if (muffled) 
[16:12:26.300]                           invokeRestart("muffleMessage")
[16:12:26.300]                       }
[16:12:26.300]                       else if (inherits(cond, "warning")) {
[16:12:26.300]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.300]                         if (muffled) 
[16:12:26.300]                           invokeRestart("muffleWarning")
[16:12:26.300]                       }
[16:12:26.300]                       else if (inherits(cond, "condition")) {
[16:12:26.300]                         if (!is.null(pattern)) {
[16:12:26.300]                           computeRestarts <- base::computeRestarts
[16:12:26.300]                           grepl <- base::grepl
[16:12:26.300]                           restarts <- computeRestarts(cond)
[16:12:26.300]                           for (restart in restarts) {
[16:12:26.300]                             name <- restart$name
[16:12:26.300]                             if (is.null(name)) 
[16:12:26.300]                               next
[16:12:26.300]                             if (!grepl(pattern, name)) 
[16:12:26.300]                               next
[16:12:26.300]                             invokeRestart(restart)
[16:12:26.300]                             muffled <- TRUE
[16:12:26.300]                             break
[16:12:26.300]                           }
[16:12:26.300]                         }
[16:12:26.300]                       }
[16:12:26.300]                       invisible(muffled)
[16:12:26.300]                     }
[16:12:26.300]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.300]                   }
[16:12:26.300]                 }
[16:12:26.300]                 else {
[16:12:26.300]                   if (TRUE) {
[16:12:26.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.300]                     {
[16:12:26.300]                       inherits <- base::inherits
[16:12:26.300]                       invokeRestart <- base::invokeRestart
[16:12:26.300]                       is.null <- base::is.null
[16:12:26.300]                       muffled <- FALSE
[16:12:26.300]                       if (inherits(cond, "message")) {
[16:12:26.300]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.300]                         if (muffled) 
[16:12:26.300]                           invokeRestart("muffleMessage")
[16:12:26.300]                       }
[16:12:26.300]                       else if (inherits(cond, "warning")) {
[16:12:26.300]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.300]                         if (muffled) 
[16:12:26.300]                           invokeRestart("muffleWarning")
[16:12:26.300]                       }
[16:12:26.300]                       else if (inherits(cond, "condition")) {
[16:12:26.300]                         if (!is.null(pattern)) {
[16:12:26.300]                           computeRestarts <- base::computeRestarts
[16:12:26.300]                           grepl <- base::grepl
[16:12:26.300]                           restarts <- computeRestarts(cond)
[16:12:26.300]                           for (restart in restarts) {
[16:12:26.300]                             name <- restart$name
[16:12:26.300]                             if (is.null(name)) 
[16:12:26.300]                               next
[16:12:26.300]                             if (!grepl(pattern, name)) 
[16:12:26.300]                               next
[16:12:26.300]                             invokeRestart(restart)
[16:12:26.300]                             muffled <- TRUE
[16:12:26.300]                             break
[16:12:26.300]                           }
[16:12:26.300]                         }
[16:12:26.300]                       }
[16:12:26.300]                       invisible(muffled)
[16:12:26.300]                     }
[16:12:26.300]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.300]                   }
[16:12:26.300]                 }
[16:12:26.300]             }
[16:12:26.300]         }))
[16:12:26.300]     }, error = function(ex) {
[16:12:26.300]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.300]                 ...future.rng), started = ...future.startTime, 
[16:12:26.300]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.300]             version = "1.8"), class = "FutureResult")
[16:12:26.300]     }, finally = {
[16:12:26.300]         if (!identical(...future.workdir, getwd())) 
[16:12:26.300]             setwd(...future.workdir)
[16:12:26.300]         {
[16:12:26.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.300]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.300]             }
[16:12:26.300]             base::options(...future.oldOptions)
[16:12:26.300]             if (.Platform$OS.type == "windows") {
[16:12:26.300]                 old_names <- names(...future.oldEnvVars)
[16:12:26.300]                 envs <- base::Sys.getenv()
[16:12:26.300]                 names <- names(envs)
[16:12:26.300]                 common <- intersect(names, old_names)
[16:12:26.300]                 added <- setdiff(names, old_names)
[16:12:26.300]                 removed <- setdiff(old_names, names)
[16:12:26.300]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.300]                   envs[common]]
[16:12:26.300]                 NAMES <- toupper(changed)
[16:12:26.300]                 args <- list()
[16:12:26.300]                 for (kk in seq_along(NAMES)) {
[16:12:26.300]                   name <- changed[[kk]]
[16:12:26.300]                   NAME <- NAMES[[kk]]
[16:12:26.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.300]                     next
[16:12:26.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.300]                 }
[16:12:26.300]                 NAMES <- toupper(added)
[16:12:26.300]                 for (kk in seq_along(NAMES)) {
[16:12:26.300]                   name <- added[[kk]]
[16:12:26.300]                   NAME <- NAMES[[kk]]
[16:12:26.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.300]                     next
[16:12:26.300]                   args[[name]] <- ""
[16:12:26.300]                 }
[16:12:26.300]                 NAMES <- toupper(removed)
[16:12:26.300]                 for (kk in seq_along(NAMES)) {
[16:12:26.300]                   name <- removed[[kk]]
[16:12:26.300]                   NAME <- NAMES[[kk]]
[16:12:26.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.300]                     next
[16:12:26.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.300]                 }
[16:12:26.300]                 if (length(args) > 0) 
[16:12:26.300]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.300]             }
[16:12:26.300]             else {
[16:12:26.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.300]             }
[16:12:26.300]             {
[16:12:26.300]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.300]                   0L) {
[16:12:26.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.300]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.300]                   base::options(opts)
[16:12:26.300]                 }
[16:12:26.300]                 {
[16:12:26.300]                   {
[16:12:26.300]                     NULL
[16:12:26.300]                     RNGkind("Mersenne-Twister")
[16:12:26.300]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.300]                       inherits = FALSE)
[16:12:26.300]                   }
[16:12:26.300]                   options(future.plan = NULL)
[16:12:26.300]                   if (is.na(NA_character_)) 
[16:12:26.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.300]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.300]                   {
[16:12:26.300]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.300]                     if (!future$lazy) 
[16:12:26.300]                       future <- run(future)
[16:12:26.300]                     invisible(future)
[16:12:26.300]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.300]                 }
[16:12:26.300]             }
[16:12:26.300]         }
[16:12:26.300]     })
[16:12:26.300]     if (TRUE) {
[16:12:26.300]         base::sink(type = "output", split = FALSE)
[16:12:26.300]         if (TRUE) {
[16:12:26.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.300]         }
[16:12:26.300]         else {
[16:12:26.300]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.300]         }
[16:12:26.300]         base::close(...future.stdout)
[16:12:26.300]         ...future.stdout <- NULL
[16:12:26.300]     }
[16:12:26.300]     ...future.result$conditions <- ...future.conditions
[16:12:26.300]     ...future.result$finished <- base::Sys.time()
[16:12:26.300]     ...future.result
[16:12:26.300] }
[16:12:26.301] plan(): Setting new future strategy stack:
[16:12:26.302] List of future strategies:
[16:12:26.302] 1. sequential:
[16:12:26.302]    - args: function (..., envir = parent.frame())
[16:12:26.302]    - tweaked: FALSE
[16:12:26.302]    - call: NULL
[16:12:26.302] plan(): nbrOfWorkers() = 1
[16:12:26.303] plan(): Setting new future strategy stack:
[16:12:26.303] List of future strategies:
[16:12:26.303] 1. sequential:
[16:12:26.303]    - args: function (..., envir = parent.frame())
[16:12:26.303]    - tweaked: FALSE
[16:12:26.303]    - call: plan(strategy)
[16:12:26.303] plan(): nbrOfWorkers() = 1
[16:12:26.303] SequentialFuture started (and completed)
[16:12:26.303] - Launch lazy future ... done
[16:12:26.303] run() for ‘SequentialFuture’ ... done
[16:12:26.303] getGlobalsAndPackages() ...
[16:12:26.304] Searching for globals...
[16:12:26.304] 
[16:12:26.304] Searching for globals ... DONE
[16:12:26.304] - globals: [0] <none>
[16:12:26.304] getGlobalsAndPackages() ... DONE
[16:12:26.304] run() for ‘Future’ ...
[16:12:26.304] - state: ‘created’
[16:12:26.305] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.305] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.305]   - Field: ‘label’
[16:12:26.305]   - Field: ‘local’
[16:12:26.305]   - Field: ‘owner’
[16:12:26.306]   - Field: ‘envir’
[16:12:26.306]   - Field: ‘packages’
[16:12:26.306]   - Field: ‘gc’
[16:12:26.307]   - Field: ‘conditions’
[16:12:26.307]   - Field: ‘expr’
[16:12:26.307]   - Field: ‘uuid’
[16:12:26.307]   - Field: ‘seed’
[16:12:26.307]   - Field: ‘version’
[16:12:26.307]   - Field: ‘result’
[16:12:26.307]   - Field: ‘asynchronous’
[16:12:26.307]   - Field: ‘calls’
[16:12:26.307]   - Field: ‘globals’
[16:12:26.307]   - Field: ‘stdout’
[16:12:26.307]   - Field: ‘earlySignal’
[16:12:26.308]   - Field: ‘lazy’
[16:12:26.308]   - Field: ‘state’
[16:12:26.308] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.308] - Launch lazy future ...
[16:12:26.308] Packages needed by the future expression (n = 0): <none>
[16:12:26.308] Packages needed by future strategies (n = 0): <none>
[16:12:26.308] {
[16:12:26.308]     {
[16:12:26.308]         {
[16:12:26.308]             ...future.startTime <- base::Sys.time()
[16:12:26.308]             {
[16:12:26.308]                 {
[16:12:26.308]                   {
[16:12:26.308]                     base::local({
[16:12:26.308]                       has_future <- base::requireNamespace("future", 
[16:12:26.308]                         quietly = TRUE)
[16:12:26.308]                       if (has_future) {
[16:12:26.308]                         ns <- base::getNamespace("future")
[16:12:26.308]                         version <- ns[[".package"]][["version"]]
[16:12:26.308]                         if (is.null(version)) 
[16:12:26.308]                           version <- utils::packageVersion("future")
[16:12:26.308]                       }
[16:12:26.308]                       else {
[16:12:26.308]                         version <- NULL
[16:12:26.308]                       }
[16:12:26.308]                       if (!has_future || version < "1.8.0") {
[16:12:26.308]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.308]                           "", base::R.version$version.string), 
[16:12:26.308]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.308]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.308]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.308]                             "release", "version")], collapse = " "), 
[16:12:26.308]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.308]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.308]                           info)
[16:12:26.308]                         info <- base::paste(info, collapse = "; ")
[16:12:26.308]                         if (!has_future) {
[16:12:26.308]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.308]                             info)
[16:12:26.308]                         }
[16:12:26.308]                         else {
[16:12:26.308]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.308]                             info, version)
[16:12:26.308]                         }
[16:12:26.308]                         base::stop(msg)
[16:12:26.308]                       }
[16:12:26.308]                     })
[16:12:26.308]                   }
[16:12:26.308]                   options(future.plan = NULL)
[16:12:26.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.308]                 }
[16:12:26.308]                 ...future.workdir <- getwd()
[16:12:26.308]             }
[16:12:26.308]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.308]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.308]         }
[16:12:26.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.308]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.308]             base::names(...future.oldOptions))
[16:12:26.308]     }
[16:12:26.308]     if (FALSE) {
[16:12:26.308]     }
[16:12:26.308]     else {
[16:12:26.308]         if (TRUE) {
[16:12:26.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.308]                 open = "w")
[16:12:26.308]         }
[16:12:26.308]         else {
[16:12:26.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.308]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.308]         }
[16:12:26.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.308]             base::sink(type = "output", split = FALSE)
[16:12:26.308]             base::close(...future.stdout)
[16:12:26.308]         }, add = TRUE)
[16:12:26.308]     }
[16:12:26.308]     ...future.frame <- base::sys.nframe()
[16:12:26.308]     ...future.conditions <- base::list()
[16:12:26.308]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.308]     if (FALSE) {
[16:12:26.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.308]     }
[16:12:26.308]     ...future.result <- base::tryCatch({
[16:12:26.308]         base::withCallingHandlers({
[16:12:26.308]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.308]             future::FutureResult(value = ...future.value$value, 
[16:12:26.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.308]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.308]                     ...future.globalenv.names))
[16:12:26.308]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.308]         }, condition = base::local({
[16:12:26.308]             c <- base::c
[16:12:26.308]             inherits <- base::inherits
[16:12:26.308]             invokeRestart <- base::invokeRestart
[16:12:26.308]             length <- base::length
[16:12:26.308]             list <- base::list
[16:12:26.308]             seq.int <- base::seq.int
[16:12:26.308]             signalCondition <- base::signalCondition
[16:12:26.308]             sys.calls <- base::sys.calls
[16:12:26.308]             `[[` <- base::`[[`
[16:12:26.308]             `+` <- base::`+`
[16:12:26.308]             `<<-` <- base::`<<-`
[16:12:26.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.308]                   3L)]
[16:12:26.308]             }
[16:12:26.308]             function(cond) {
[16:12:26.308]                 is_error <- inherits(cond, "error")
[16:12:26.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.308]                   NULL)
[16:12:26.308]                 if (is_error) {
[16:12:26.308]                   sessionInformation <- function() {
[16:12:26.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.308]                       search = base::search(), system = base::Sys.info())
[16:12:26.308]                   }
[16:12:26.308]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.308]                     cond$call), session = sessionInformation(), 
[16:12:26.308]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.308]                   signalCondition(cond)
[16:12:26.308]                 }
[16:12:26.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.308]                 "immediateCondition"))) {
[16:12:26.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.308]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.308]                   if (TRUE && !signal) {
[16:12:26.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.308]                     {
[16:12:26.308]                       inherits <- base::inherits
[16:12:26.308]                       invokeRestart <- base::invokeRestart
[16:12:26.308]                       is.null <- base::is.null
[16:12:26.308]                       muffled <- FALSE
[16:12:26.308]                       if (inherits(cond, "message")) {
[16:12:26.308]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.308]                         if (muffled) 
[16:12:26.308]                           invokeRestart("muffleMessage")
[16:12:26.308]                       }
[16:12:26.308]                       else if (inherits(cond, "warning")) {
[16:12:26.308]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.308]                         if (muffled) 
[16:12:26.308]                           invokeRestart("muffleWarning")
[16:12:26.308]                       }
[16:12:26.308]                       else if (inherits(cond, "condition")) {
[16:12:26.308]                         if (!is.null(pattern)) {
[16:12:26.308]                           computeRestarts <- base::computeRestarts
[16:12:26.308]                           grepl <- base::grepl
[16:12:26.308]                           restarts <- computeRestarts(cond)
[16:12:26.308]                           for (restart in restarts) {
[16:12:26.308]                             name <- restart$name
[16:12:26.308]                             if (is.null(name)) 
[16:12:26.308]                               next
[16:12:26.308]                             if (!grepl(pattern, name)) 
[16:12:26.308]                               next
[16:12:26.308]                             invokeRestart(restart)
[16:12:26.308]                             muffled <- TRUE
[16:12:26.308]                             break
[16:12:26.308]                           }
[16:12:26.308]                         }
[16:12:26.308]                       }
[16:12:26.308]                       invisible(muffled)
[16:12:26.308]                     }
[16:12:26.308]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.308]                   }
[16:12:26.308]                 }
[16:12:26.308]                 else {
[16:12:26.308]                   if (TRUE) {
[16:12:26.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.308]                     {
[16:12:26.308]                       inherits <- base::inherits
[16:12:26.308]                       invokeRestart <- base::invokeRestart
[16:12:26.308]                       is.null <- base::is.null
[16:12:26.308]                       muffled <- FALSE
[16:12:26.308]                       if (inherits(cond, "message")) {
[16:12:26.308]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.308]                         if (muffled) 
[16:12:26.308]                           invokeRestart("muffleMessage")
[16:12:26.308]                       }
[16:12:26.308]                       else if (inherits(cond, "warning")) {
[16:12:26.308]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.308]                         if (muffled) 
[16:12:26.308]                           invokeRestart("muffleWarning")
[16:12:26.308]                       }
[16:12:26.308]                       else if (inherits(cond, "condition")) {
[16:12:26.308]                         if (!is.null(pattern)) {
[16:12:26.308]                           computeRestarts <- base::computeRestarts
[16:12:26.308]                           grepl <- base::grepl
[16:12:26.308]                           restarts <- computeRestarts(cond)
[16:12:26.308]                           for (restart in restarts) {
[16:12:26.308]                             name <- restart$name
[16:12:26.308]                             if (is.null(name)) 
[16:12:26.308]                               next
[16:12:26.308]                             if (!grepl(pattern, name)) 
[16:12:26.308]                               next
[16:12:26.308]                             invokeRestart(restart)
[16:12:26.308]                             muffled <- TRUE
[16:12:26.308]                             break
[16:12:26.308]                           }
[16:12:26.308]                         }
[16:12:26.308]                       }
[16:12:26.308]                       invisible(muffled)
[16:12:26.308]                     }
[16:12:26.308]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.308]                   }
[16:12:26.308]                 }
[16:12:26.308]             }
[16:12:26.308]         }))
[16:12:26.308]     }, error = function(ex) {
[16:12:26.308]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.308]                 ...future.rng), started = ...future.startTime, 
[16:12:26.308]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.308]             version = "1.8"), class = "FutureResult")
[16:12:26.308]     }, finally = {
[16:12:26.308]         if (!identical(...future.workdir, getwd())) 
[16:12:26.308]             setwd(...future.workdir)
[16:12:26.308]         {
[16:12:26.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.308]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.308]             }
[16:12:26.308]             base::options(...future.oldOptions)
[16:12:26.308]             if (.Platform$OS.type == "windows") {
[16:12:26.308]                 old_names <- names(...future.oldEnvVars)
[16:12:26.308]                 envs <- base::Sys.getenv()
[16:12:26.308]                 names <- names(envs)
[16:12:26.308]                 common <- intersect(names, old_names)
[16:12:26.308]                 added <- setdiff(names, old_names)
[16:12:26.308]                 removed <- setdiff(old_names, names)
[16:12:26.308]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.308]                   envs[common]]
[16:12:26.308]                 NAMES <- toupper(changed)
[16:12:26.308]                 args <- list()
[16:12:26.308]                 for (kk in seq_along(NAMES)) {
[16:12:26.308]                   name <- changed[[kk]]
[16:12:26.308]                   NAME <- NAMES[[kk]]
[16:12:26.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.308]                     next
[16:12:26.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.308]                 }
[16:12:26.308]                 NAMES <- toupper(added)
[16:12:26.308]                 for (kk in seq_along(NAMES)) {
[16:12:26.308]                   name <- added[[kk]]
[16:12:26.308]                   NAME <- NAMES[[kk]]
[16:12:26.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.308]                     next
[16:12:26.308]                   args[[name]] <- ""
[16:12:26.308]                 }
[16:12:26.308]                 NAMES <- toupper(removed)
[16:12:26.308]                 for (kk in seq_along(NAMES)) {
[16:12:26.308]                   name <- removed[[kk]]
[16:12:26.308]                   NAME <- NAMES[[kk]]
[16:12:26.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.308]                     next
[16:12:26.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.308]                 }
[16:12:26.308]                 if (length(args) > 0) 
[16:12:26.308]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.308]             }
[16:12:26.308]             else {
[16:12:26.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.308]             }
[16:12:26.308]             {
[16:12:26.308]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.308]                   0L) {
[16:12:26.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.308]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.308]                   base::options(opts)
[16:12:26.308]                 }
[16:12:26.308]                 {
[16:12:26.308]                   {
[16:12:26.308]                     NULL
[16:12:26.308]                     RNGkind("Mersenne-Twister")
[16:12:26.308]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.308]                       inherits = FALSE)
[16:12:26.308]                   }
[16:12:26.308]                   options(future.plan = NULL)
[16:12:26.308]                   if (is.na(NA_character_)) 
[16:12:26.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.308]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.308]                   {
[16:12:26.308]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.308]                     if (!future$lazy) 
[16:12:26.308]                       future <- run(future)
[16:12:26.308]                     invisible(future)
[16:12:26.308]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.308]                 }
[16:12:26.308]             }
[16:12:26.308]         }
[16:12:26.308]     })
[16:12:26.308]     if (TRUE) {
[16:12:26.308]         base::sink(type = "output", split = FALSE)
[16:12:26.308]         if (TRUE) {
[16:12:26.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.308]         }
[16:12:26.308]         else {
[16:12:26.308]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.308]         }
[16:12:26.308]         base::close(...future.stdout)
[16:12:26.308]         ...future.stdout <- NULL
[16:12:26.308]     }
[16:12:26.308]     ...future.result$conditions <- ...future.conditions
[16:12:26.308]     ...future.result$finished <- base::Sys.time()
[16:12:26.308]     ...future.result
[16:12:26.308] }
[16:12:26.310] plan(): Setting new future strategy stack:
[16:12:26.310] List of future strategies:
[16:12:26.310] 1. sequential:
[16:12:26.310]    - args: function (..., envir = parent.frame())
[16:12:26.310]    - tweaked: FALSE
[16:12:26.310]    - call: NULL
[16:12:26.311] plan(): nbrOfWorkers() = 1
[16:12:26.311] plan(): Setting new future strategy stack:
[16:12:26.311] List of future strategies:
[16:12:26.311] 1. sequential:
[16:12:26.311]    - args: function (..., envir = parent.frame())
[16:12:26.311]    - tweaked: FALSE
[16:12:26.311]    - call: plan(strategy)
[16:12:26.312] plan(): nbrOfWorkers() = 1
[16:12:26.312] SequentialFuture started (and completed)
[16:12:26.312] - Launch lazy future ... done
[16:12:26.312] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baed59948> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baf1b95b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baed59948> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baf1b95b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:12:26.317] resolved() for ‘SequentialFuture’ ...
[16:12:26.317] - state: ‘finished’
[16:12:26.317] - run: TRUE
[16:12:26.317] - result: ‘FutureResult’
[16:12:26.317] resolved() for ‘SequentialFuture’ ... done
[16:12:26.317] resolved() for ‘SequentialFuture’ ...
[16:12:26.317] - state: ‘finished’
[16:12:26.317] - run: TRUE
[16:12:26.317] - result: ‘FutureResult’
[16:12:26.318] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:26.319] resolve() on list ...
[16:12:26.319]  recursive: 0
[16:12:26.319]  length: 6
[16:12:26.320]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:26.320] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.320] - nx: 6
[16:12:26.320] - relay: TRUE
[16:12:26.320] - stdout: TRUE
[16:12:26.320] - signal: TRUE
[16:12:26.320] - resignal: FALSE
[16:12:26.320] - force: TRUE
[16:12:26.320] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.320] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.320]  - until=2
[16:12:26.321]  - relaying element #2
[16:12:26.321] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.321] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.321] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.321]  length: 5 (resolved future 1)
[16:12:26.321] resolved() for ‘SequentialFuture’ ...
[16:12:26.321] - state: ‘finished’
[16:12:26.321] - run: TRUE
[16:12:26.321] - result: ‘FutureResult’
[16:12:26.321] resolved() for ‘SequentialFuture’ ... done
[16:12:26.321] Future #2
[16:12:26.322] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.322] - nx: 6
[16:12:26.322] - relay: TRUE
[16:12:26.322] - stdout: TRUE
[16:12:26.322] - signal: TRUE
[16:12:26.322] - resignal: FALSE
[16:12:26.322] - force: TRUE
[16:12:26.322] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.322] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.322]  - until=2
[16:12:26.322]  - relaying element #2
[16:12:26.323] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.323] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.323] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.323]  length: 4 (resolved future 2)
[16:12:26.323] resolved() for ‘SequentialFuture’ ...
[16:12:26.323] - state: ‘finished’
[16:12:26.323] - run: TRUE
[16:12:26.323] - result: ‘FutureResult’
[16:12:26.323] resolved() for ‘SequentialFuture’ ... done
[16:12:26.323] Future #3
[16:12:26.324] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.324] - nx: 6
[16:12:26.324] - relay: TRUE
[16:12:26.324] - stdout: TRUE
[16:12:26.324] - signal: TRUE
[16:12:26.324] - resignal: FALSE
[16:12:26.324] - force: TRUE
[16:12:26.324] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.324] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.324]  - until=3
[16:12:26.324]  - relaying element #3
[16:12:26.325] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.325] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.325] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.325]  length: 3 (resolved future 3)
[16:12:26.325] signalConditionsASAP(NULL, pos=4) ...
[16:12:26.325] - nx: 6
[16:12:26.325] - relay: TRUE
[16:12:26.325] - stdout: TRUE
[16:12:26.325] - signal: TRUE
[16:12:26.325] - resignal: FALSE
[16:12:26.325] - force: TRUE
[16:12:26.325] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.326] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.326]  - until=5
[16:12:26.326]  - relaying element #5
[16:12:26.326] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.326] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.326] signalConditionsASAP(NULL, pos=4) ... done
[16:12:26.326]  length: 2 (resolved future 4)
[16:12:26.326] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.326] - nx: 6
[16:12:26.326] - relay: TRUE
[16:12:26.326] - stdout: TRUE
[16:12:26.326] - signal: TRUE
[16:12:26.326] - resignal: FALSE
[16:12:26.327] - force: TRUE
[16:12:26.327] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.327] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.327]  - until=6
[16:12:26.327]  - relaying element #6
[16:12:26.327] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.327] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.327] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.327]  length: 1 (resolved future 5)
[16:12:26.327] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.327] - nx: 6
[16:12:26.327] - relay: TRUE
[16:12:26.328] - stdout: TRUE
[16:12:26.328] - signal: TRUE
[16:12:26.328] - resignal: FALSE
[16:12:26.328] - force: TRUE
[16:12:26.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.328] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.328]  - until=6
[16:12:26.328] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.328] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.328] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.328]  length: 0 (resolved future 6)
[16:12:26.328] Relaying remaining futures
[16:12:26.329] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.329] - nx: 6
[16:12:26.329] - relay: TRUE
[16:12:26.329] - stdout: TRUE
[16:12:26.329] - signal: TRUE
[16:12:26.329] - resignal: FALSE
[16:12:26.329] - force: TRUE
[16:12:26.329] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.329] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:26.329] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.329] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.329] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.330] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:12:26.334] getGlobalsAndPackages() ...
[16:12:26.334] Searching for globals...
[16:12:26.334] 
[16:12:26.334] Searching for globals ... DONE
[16:12:26.334] - globals: [0] <none>
[16:12:26.334] getGlobalsAndPackages() ... DONE
[16:12:26.334] run() for ‘Future’ ...
[16:12:26.335] - state: ‘created’
[16:12:26.335] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.335] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.335] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.335]   - Field: ‘label’
[16:12:26.335]   - Field: ‘local’
[16:12:26.335]   - Field: ‘owner’
[16:12:26.335]   - Field: ‘envir’
[16:12:26.335]   - Field: ‘packages’
[16:12:26.336]   - Field: ‘gc’
[16:12:26.336]   - Field: ‘conditions’
[16:12:26.336]   - Field: ‘expr’
[16:12:26.336]   - Field: ‘uuid’
[16:12:26.336]   - Field: ‘seed’
[16:12:26.336]   - Field: ‘version’
[16:12:26.336]   - Field: ‘result’
[16:12:26.336]   - Field: ‘asynchronous’
[16:12:26.336]   - Field: ‘calls’
[16:12:26.336]   - Field: ‘globals’
[16:12:26.336]   - Field: ‘stdout’
[16:12:26.337]   - Field: ‘earlySignal’
[16:12:26.337]   - Field: ‘lazy’
[16:12:26.337]   - Field: ‘state’
[16:12:26.337] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.337] - Launch lazy future ...
[16:12:26.337] Packages needed by the future expression (n = 0): <none>
[16:12:26.337] Packages needed by future strategies (n = 0): <none>
[16:12:26.338] {
[16:12:26.338]     {
[16:12:26.338]         {
[16:12:26.338]             ...future.startTime <- base::Sys.time()
[16:12:26.338]             {
[16:12:26.338]                 {
[16:12:26.338]                   {
[16:12:26.338]                     base::local({
[16:12:26.338]                       has_future <- base::requireNamespace("future", 
[16:12:26.338]                         quietly = TRUE)
[16:12:26.338]                       if (has_future) {
[16:12:26.338]                         ns <- base::getNamespace("future")
[16:12:26.338]                         version <- ns[[".package"]][["version"]]
[16:12:26.338]                         if (is.null(version)) 
[16:12:26.338]                           version <- utils::packageVersion("future")
[16:12:26.338]                       }
[16:12:26.338]                       else {
[16:12:26.338]                         version <- NULL
[16:12:26.338]                       }
[16:12:26.338]                       if (!has_future || version < "1.8.0") {
[16:12:26.338]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.338]                           "", base::R.version$version.string), 
[16:12:26.338]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.338]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.338]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.338]                             "release", "version")], collapse = " "), 
[16:12:26.338]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.338]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.338]                           info)
[16:12:26.338]                         info <- base::paste(info, collapse = "; ")
[16:12:26.338]                         if (!has_future) {
[16:12:26.338]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.338]                             info)
[16:12:26.338]                         }
[16:12:26.338]                         else {
[16:12:26.338]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.338]                             info, version)
[16:12:26.338]                         }
[16:12:26.338]                         base::stop(msg)
[16:12:26.338]                       }
[16:12:26.338]                     })
[16:12:26.338]                   }
[16:12:26.338]                   options(future.plan = NULL)
[16:12:26.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.338]                 }
[16:12:26.338]                 ...future.workdir <- getwd()
[16:12:26.338]             }
[16:12:26.338]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.338]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.338]         }
[16:12:26.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.338]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.338]             base::names(...future.oldOptions))
[16:12:26.338]     }
[16:12:26.338]     if (FALSE) {
[16:12:26.338]     }
[16:12:26.338]     else {
[16:12:26.338]         if (TRUE) {
[16:12:26.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.338]                 open = "w")
[16:12:26.338]         }
[16:12:26.338]         else {
[16:12:26.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.338]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.338]         }
[16:12:26.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.338]             base::sink(type = "output", split = FALSE)
[16:12:26.338]             base::close(...future.stdout)
[16:12:26.338]         }, add = TRUE)
[16:12:26.338]     }
[16:12:26.338]     ...future.frame <- base::sys.nframe()
[16:12:26.338]     ...future.conditions <- base::list()
[16:12:26.338]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.338]     if (FALSE) {
[16:12:26.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.338]     }
[16:12:26.338]     ...future.result <- base::tryCatch({
[16:12:26.338]         base::withCallingHandlers({
[16:12:26.338]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.338]             future::FutureResult(value = ...future.value$value, 
[16:12:26.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.338]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.338]                     ...future.globalenv.names))
[16:12:26.338]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.338]         }, condition = base::local({
[16:12:26.338]             c <- base::c
[16:12:26.338]             inherits <- base::inherits
[16:12:26.338]             invokeRestart <- base::invokeRestart
[16:12:26.338]             length <- base::length
[16:12:26.338]             list <- base::list
[16:12:26.338]             seq.int <- base::seq.int
[16:12:26.338]             signalCondition <- base::signalCondition
[16:12:26.338]             sys.calls <- base::sys.calls
[16:12:26.338]             `[[` <- base::`[[`
[16:12:26.338]             `+` <- base::`+`
[16:12:26.338]             `<<-` <- base::`<<-`
[16:12:26.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.338]                   3L)]
[16:12:26.338]             }
[16:12:26.338]             function(cond) {
[16:12:26.338]                 is_error <- inherits(cond, "error")
[16:12:26.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.338]                   NULL)
[16:12:26.338]                 if (is_error) {
[16:12:26.338]                   sessionInformation <- function() {
[16:12:26.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.338]                       search = base::search(), system = base::Sys.info())
[16:12:26.338]                   }
[16:12:26.338]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.338]                     cond$call), session = sessionInformation(), 
[16:12:26.338]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.338]                   signalCondition(cond)
[16:12:26.338]                 }
[16:12:26.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.338]                 "immediateCondition"))) {
[16:12:26.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.338]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.338]                   if (TRUE && !signal) {
[16:12:26.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.338]                     {
[16:12:26.338]                       inherits <- base::inherits
[16:12:26.338]                       invokeRestart <- base::invokeRestart
[16:12:26.338]                       is.null <- base::is.null
[16:12:26.338]                       muffled <- FALSE
[16:12:26.338]                       if (inherits(cond, "message")) {
[16:12:26.338]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.338]                         if (muffled) 
[16:12:26.338]                           invokeRestart("muffleMessage")
[16:12:26.338]                       }
[16:12:26.338]                       else if (inherits(cond, "warning")) {
[16:12:26.338]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.338]                         if (muffled) 
[16:12:26.338]                           invokeRestart("muffleWarning")
[16:12:26.338]                       }
[16:12:26.338]                       else if (inherits(cond, "condition")) {
[16:12:26.338]                         if (!is.null(pattern)) {
[16:12:26.338]                           computeRestarts <- base::computeRestarts
[16:12:26.338]                           grepl <- base::grepl
[16:12:26.338]                           restarts <- computeRestarts(cond)
[16:12:26.338]                           for (restart in restarts) {
[16:12:26.338]                             name <- restart$name
[16:12:26.338]                             if (is.null(name)) 
[16:12:26.338]                               next
[16:12:26.338]                             if (!grepl(pattern, name)) 
[16:12:26.338]                               next
[16:12:26.338]                             invokeRestart(restart)
[16:12:26.338]                             muffled <- TRUE
[16:12:26.338]                             break
[16:12:26.338]                           }
[16:12:26.338]                         }
[16:12:26.338]                       }
[16:12:26.338]                       invisible(muffled)
[16:12:26.338]                     }
[16:12:26.338]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.338]                   }
[16:12:26.338]                 }
[16:12:26.338]                 else {
[16:12:26.338]                   if (TRUE) {
[16:12:26.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.338]                     {
[16:12:26.338]                       inherits <- base::inherits
[16:12:26.338]                       invokeRestart <- base::invokeRestart
[16:12:26.338]                       is.null <- base::is.null
[16:12:26.338]                       muffled <- FALSE
[16:12:26.338]                       if (inherits(cond, "message")) {
[16:12:26.338]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.338]                         if (muffled) 
[16:12:26.338]                           invokeRestart("muffleMessage")
[16:12:26.338]                       }
[16:12:26.338]                       else if (inherits(cond, "warning")) {
[16:12:26.338]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.338]                         if (muffled) 
[16:12:26.338]                           invokeRestart("muffleWarning")
[16:12:26.338]                       }
[16:12:26.338]                       else if (inherits(cond, "condition")) {
[16:12:26.338]                         if (!is.null(pattern)) {
[16:12:26.338]                           computeRestarts <- base::computeRestarts
[16:12:26.338]                           grepl <- base::grepl
[16:12:26.338]                           restarts <- computeRestarts(cond)
[16:12:26.338]                           for (restart in restarts) {
[16:12:26.338]                             name <- restart$name
[16:12:26.338]                             if (is.null(name)) 
[16:12:26.338]                               next
[16:12:26.338]                             if (!grepl(pattern, name)) 
[16:12:26.338]                               next
[16:12:26.338]                             invokeRestart(restart)
[16:12:26.338]                             muffled <- TRUE
[16:12:26.338]                             break
[16:12:26.338]                           }
[16:12:26.338]                         }
[16:12:26.338]                       }
[16:12:26.338]                       invisible(muffled)
[16:12:26.338]                     }
[16:12:26.338]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.338]                   }
[16:12:26.338]                 }
[16:12:26.338]             }
[16:12:26.338]         }))
[16:12:26.338]     }, error = function(ex) {
[16:12:26.338]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.338]                 ...future.rng), started = ...future.startTime, 
[16:12:26.338]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.338]             version = "1.8"), class = "FutureResult")
[16:12:26.338]     }, finally = {
[16:12:26.338]         if (!identical(...future.workdir, getwd())) 
[16:12:26.338]             setwd(...future.workdir)
[16:12:26.338]         {
[16:12:26.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.338]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.338]             }
[16:12:26.338]             base::options(...future.oldOptions)
[16:12:26.338]             if (.Platform$OS.type == "windows") {
[16:12:26.338]                 old_names <- names(...future.oldEnvVars)
[16:12:26.338]                 envs <- base::Sys.getenv()
[16:12:26.338]                 names <- names(envs)
[16:12:26.338]                 common <- intersect(names, old_names)
[16:12:26.338]                 added <- setdiff(names, old_names)
[16:12:26.338]                 removed <- setdiff(old_names, names)
[16:12:26.338]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.338]                   envs[common]]
[16:12:26.338]                 NAMES <- toupper(changed)
[16:12:26.338]                 args <- list()
[16:12:26.338]                 for (kk in seq_along(NAMES)) {
[16:12:26.338]                   name <- changed[[kk]]
[16:12:26.338]                   NAME <- NAMES[[kk]]
[16:12:26.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.338]                     next
[16:12:26.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.338]                 }
[16:12:26.338]                 NAMES <- toupper(added)
[16:12:26.338]                 for (kk in seq_along(NAMES)) {
[16:12:26.338]                   name <- added[[kk]]
[16:12:26.338]                   NAME <- NAMES[[kk]]
[16:12:26.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.338]                     next
[16:12:26.338]                   args[[name]] <- ""
[16:12:26.338]                 }
[16:12:26.338]                 NAMES <- toupper(removed)
[16:12:26.338]                 for (kk in seq_along(NAMES)) {
[16:12:26.338]                   name <- removed[[kk]]
[16:12:26.338]                   NAME <- NAMES[[kk]]
[16:12:26.338]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.338]                     next
[16:12:26.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.338]                 }
[16:12:26.338]                 if (length(args) > 0) 
[16:12:26.338]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.338]             }
[16:12:26.338]             else {
[16:12:26.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.338]             }
[16:12:26.338]             {
[16:12:26.338]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.338]                   0L) {
[16:12:26.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.338]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.338]                   base::options(opts)
[16:12:26.338]                 }
[16:12:26.338]                 {
[16:12:26.338]                   {
[16:12:26.338]                     NULL
[16:12:26.338]                     RNGkind("Mersenne-Twister")
[16:12:26.338]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.338]                       inherits = FALSE)
[16:12:26.338]                   }
[16:12:26.338]                   options(future.plan = NULL)
[16:12:26.338]                   if (is.na(NA_character_)) 
[16:12:26.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.338]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.338]                   {
[16:12:26.338]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.338]                     if (!future$lazy) 
[16:12:26.338]                       future <- run(future)
[16:12:26.338]                     invisible(future)
[16:12:26.338]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.338]                 }
[16:12:26.338]             }
[16:12:26.338]         }
[16:12:26.338]     })
[16:12:26.338]     if (TRUE) {
[16:12:26.338]         base::sink(type = "output", split = FALSE)
[16:12:26.338]         if (TRUE) {
[16:12:26.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.338]         }
[16:12:26.338]         else {
[16:12:26.338]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.338]         }
[16:12:26.338]         base::close(...future.stdout)
[16:12:26.338]         ...future.stdout <- NULL
[16:12:26.338]     }
[16:12:26.338]     ...future.result$conditions <- ...future.conditions
[16:12:26.338]     ...future.result$finished <- base::Sys.time()
[16:12:26.338]     ...future.result
[16:12:26.338] }
[16:12:26.339] plan(): Setting new future strategy stack:
[16:12:26.339] List of future strategies:
[16:12:26.339] 1. sequential:
[16:12:26.339]    - args: function (..., envir = parent.frame())
[16:12:26.339]    - tweaked: FALSE
[16:12:26.339]    - call: NULL
[16:12:26.340] plan(): nbrOfWorkers() = 1
[16:12:26.340] plan(): Setting new future strategy stack:
[16:12:26.340] List of future strategies:
[16:12:26.340] 1. sequential:
[16:12:26.340]    - args: function (..., envir = parent.frame())
[16:12:26.340]    - tweaked: FALSE
[16:12:26.340]    - call: plan(strategy)
[16:12:26.341] plan(): nbrOfWorkers() = 1
[16:12:26.341] SequentialFuture started (and completed)
[16:12:26.341] - Launch lazy future ... done
[16:12:26.341] run() for ‘SequentialFuture’ ... done
[16:12:26.341] getGlobalsAndPackages() ...
[16:12:26.341] Searching for globals...
[16:12:26.342] 
[16:12:26.342] Searching for globals ... DONE
[16:12:26.342] - globals: [0] <none>
[16:12:26.342] getGlobalsAndPackages() ... DONE
[16:12:26.342] run() for ‘Future’ ...
[16:12:26.342] - state: ‘created’
[16:12:26.342] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.343] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.343]   - Field: ‘label’
[16:12:26.343]   - Field: ‘local’
[16:12:26.343]   - Field: ‘owner’
[16:12:26.343]   - Field: ‘envir’
[16:12:26.343]   - Field: ‘packages’
[16:12:26.343]   - Field: ‘gc’
[16:12:26.343]   - Field: ‘conditions’
[16:12:26.343]   - Field: ‘expr’
[16:12:26.343]   - Field: ‘uuid’
[16:12:26.344]   - Field: ‘seed’
[16:12:26.344]   - Field: ‘version’
[16:12:26.344]   - Field: ‘result’
[16:12:26.344]   - Field: ‘asynchronous’
[16:12:26.344]   - Field: ‘calls’
[16:12:26.344]   - Field: ‘globals’
[16:12:26.344]   - Field: ‘stdout’
[16:12:26.344]   - Field: ‘earlySignal’
[16:12:26.344]   - Field: ‘lazy’
[16:12:26.344]   - Field: ‘state’
[16:12:26.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.344] - Launch lazy future ...
[16:12:26.345] Packages needed by the future expression (n = 0): <none>
[16:12:26.345] Packages needed by future strategies (n = 0): <none>
[16:12:26.345] {
[16:12:26.345]     {
[16:12:26.345]         {
[16:12:26.345]             ...future.startTime <- base::Sys.time()
[16:12:26.345]             {
[16:12:26.345]                 {
[16:12:26.345]                   {
[16:12:26.345]                     base::local({
[16:12:26.345]                       has_future <- base::requireNamespace("future", 
[16:12:26.345]                         quietly = TRUE)
[16:12:26.345]                       if (has_future) {
[16:12:26.345]                         ns <- base::getNamespace("future")
[16:12:26.345]                         version <- ns[[".package"]][["version"]]
[16:12:26.345]                         if (is.null(version)) 
[16:12:26.345]                           version <- utils::packageVersion("future")
[16:12:26.345]                       }
[16:12:26.345]                       else {
[16:12:26.345]                         version <- NULL
[16:12:26.345]                       }
[16:12:26.345]                       if (!has_future || version < "1.8.0") {
[16:12:26.345]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.345]                           "", base::R.version$version.string), 
[16:12:26.345]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.345]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.345]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.345]                             "release", "version")], collapse = " "), 
[16:12:26.345]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.345]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.345]                           info)
[16:12:26.345]                         info <- base::paste(info, collapse = "; ")
[16:12:26.345]                         if (!has_future) {
[16:12:26.345]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.345]                             info)
[16:12:26.345]                         }
[16:12:26.345]                         else {
[16:12:26.345]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.345]                             info, version)
[16:12:26.345]                         }
[16:12:26.345]                         base::stop(msg)
[16:12:26.345]                       }
[16:12:26.345]                     })
[16:12:26.345]                   }
[16:12:26.345]                   options(future.plan = NULL)
[16:12:26.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.345]                 }
[16:12:26.345]                 ...future.workdir <- getwd()
[16:12:26.345]             }
[16:12:26.345]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.345]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.345]         }
[16:12:26.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.345]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.345]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.345]             base::names(...future.oldOptions))
[16:12:26.345]     }
[16:12:26.345]     if (FALSE) {
[16:12:26.345]     }
[16:12:26.345]     else {
[16:12:26.345]         if (TRUE) {
[16:12:26.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.345]                 open = "w")
[16:12:26.345]         }
[16:12:26.345]         else {
[16:12:26.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.345]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.345]         }
[16:12:26.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.345]             base::sink(type = "output", split = FALSE)
[16:12:26.345]             base::close(...future.stdout)
[16:12:26.345]         }, add = TRUE)
[16:12:26.345]     }
[16:12:26.345]     ...future.frame <- base::sys.nframe()
[16:12:26.345]     ...future.conditions <- base::list()
[16:12:26.345]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.345]     if (FALSE) {
[16:12:26.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.345]     }
[16:12:26.345]     ...future.result <- base::tryCatch({
[16:12:26.345]         base::withCallingHandlers({
[16:12:26.345]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.345]             future::FutureResult(value = ...future.value$value, 
[16:12:26.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.345]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.345]                     ...future.globalenv.names))
[16:12:26.345]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.345]         }, condition = base::local({
[16:12:26.345]             c <- base::c
[16:12:26.345]             inherits <- base::inherits
[16:12:26.345]             invokeRestart <- base::invokeRestart
[16:12:26.345]             length <- base::length
[16:12:26.345]             list <- base::list
[16:12:26.345]             seq.int <- base::seq.int
[16:12:26.345]             signalCondition <- base::signalCondition
[16:12:26.345]             sys.calls <- base::sys.calls
[16:12:26.345]             `[[` <- base::`[[`
[16:12:26.345]             `+` <- base::`+`
[16:12:26.345]             `<<-` <- base::`<<-`
[16:12:26.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.345]                   3L)]
[16:12:26.345]             }
[16:12:26.345]             function(cond) {
[16:12:26.345]                 is_error <- inherits(cond, "error")
[16:12:26.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.345]                   NULL)
[16:12:26.345]                 if (is_error) {
[16:12:26.345]                   sessionInformation <- function() {
[16:12:26.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.345]                       search = base::search(), system = base::Sys.info())
[16:12:26.345]                   }
[16:12:26.345]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.345]                     cond$call), session = sessionInformation(), 
[16:12:26.345]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.345]                   signalCondition(cond)
[16:12:26.345]                 }
[16:12:26.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.345]                 "immediateCondition"))) {
[16:12:26.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.345]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.345]                   if (TRUE && !signal) {
[16:12:26.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.345]                     {
[16:12:26.345]                       inherits <- base::inherits
[16:12:26.345]                       invokeRestart <- base::invokeRestart
[16:12:26.345]                       is.null <- base::is.null
[16:12:26.345]                       muffled <- FALSE
[16:12:26.345]                       if (inherits(cond, "message")) {
[16:12:26.345]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.345]                         if (muffled) 
[16:12:26.345]                           invokeRestart("muffleMessage")
[16:12:26.345]                       }
[16:12:26.345]                       else if (inherits(cond, "warning")) {
[16:12:26.345]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.345]                         if (muffled) 
[16:12:26.345]                           invokeRestart("muffleWarning")
[16:12:26.345]                       }
[16:12:26.345]                       else if (inherits(cond, "condition")) {
[16:12:26.345]                         if (!is.null(pattern)) {
[16:12:26.345]                           computeRestarts <- base::computeRestarts
[16:12:26.345]                           grepl <- base::grepl
[16:12:26.345]                           restarts <- computeRestarts(cond)
[16:12:26.345]                           for (restart in restarts) {
[16:12:26.345]                             name <- restart$name
[16:12:26.345]                             if (is.null(name)) 
[16:12:26.345]                               next
[16:12:26.345]                             if (!grepl(pattern, name)) 
[16:12:26.345]                               next
[16:12:26.345]                             invokeRestart(restart)
[16:12:26.345]                             muffled <- TRUE
[16:12:26.345]                             break
[16:12:26.345]                           }
[16:12:26.345]                         }
[16:12:26.345]                       }
[16:12:26.345]                       invisible(muffled)
[16:12:26.345]                     }
[16:12:26.345]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.345]                   }
[16:12:26.345]                 }
[16:12:26.345]                 else {
[16:12:26.345]                   if (TRUE) {
[16:12:26.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.345]                     {
[16:12:26.345]                       inherits <- base::inherits
[16:12:26.345]                       invokeRestart <- base::invokeRestart
[16:12:26.345]                       is.null <- base::is.null
[16:12:26.345]                       muffled <- FALSE
[16:12:26.345]                       if (inherits(cond, "message")) {
[16:12:26.345]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.345]                         if (muffled) 
[16:12:26.345]                           invokeRestart("muffleMessage")
[16:12:26.345]                       }
[16:12:26.345]                       else if (inherits(cond, "warning")) {
[16:12:26.345]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.345]                         if (muffled) 
[16:12:26.345]                           invokeRestart("muffleWarning")
[16:12:26.345]                       }
[16:12:26.345]                       else if (inherits(cond, "condition")) {
[16:12:26.345]                         if (!is.null(pattern)) {
[16:12:26.345]                           computeRestarts <- base::computeRestarts
[16:12:26.345]                           grepl <- base::grepl
[16:12:26.345]                           restarts <- computeRestarts(cond)
[16:12:26.345]                           for (restart in restarts) {
[16:12:26.345]                             name <- restart$name
[16:12:26.345]                             if (is.null(name)) 
[16:12:26.345]                               next
[16:12:26.345]                             if (!grepl(pattern, name)) 
[16:12:26.345]                               next
[16:12:26.345]                             invokeRestart(restart)
[16:12:26.345]                             muffled <- TRUE
[16:12:26.345]                             break
[16:12:26.345]                           }
[16:12:26.345]                         }
[16:12:26.345]                       }
[16:12:26.345]                       invisible(muffled)
[16:12:26.345]                     }
[16:12:26.345]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.345]                   }
[16:12:26.345]                 }
[16:12:26.345]             }
[16:12:26.345]         }))
[16:12:26.345]     }, error = function(ex) {
[16:12:26.345]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.345]                 ...future.rng), started = ...future.startTime, 
[16:12:26.345]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.345]             version = "1.8"), class = "FutureResult")
[16:12:26.345]     }, finally = {
[16:12:26.345]         if (!identical(...future.workdir, getwd())) 
[16:12:26.345]             setwd(...future.workdir)
[16:12:26.345]         {
[16:12:26.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.345]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.345]             }
[16:12:26.345]             base::options(...future.oldOptions)
[16:12:26.345]             if (.Platform$OS.type == "windows") {
[16:12:26.345]                 old_names <- names(...future.oldEnvVars)
[16:12:26.345]                 envs <- base::Sys.getenv()
[16:12:26.345]                 names <- names(envs)
[16:12:26.345]                 common <- intersect(names, old_names)
[16:12:26.345]                 added <- setdiff(names, old_names)
[16:12:26.345]                 removed <- setdiff(old_names, names)
[16:12:26.345]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.345]                   envs[common]]
[16:12:26.345]                 NAMES <- toupper(changed)
[16:12:26.345]                 args <- list()
[16:12:26.345]                 for (kk in seq_along(NAMES)) {
[16:12:26.345]                   name <- changed[[kk]]
[16:12:26.345]                   NAME <- NAMES[[kk]]
[16:12:26.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.345]                     next
[16:12:26.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.345]                 }
[16:12:26.345]                 NAMES <- toupper(added)
[16:12:26.345]                 for (kk in seq_along(NAMES)) {
[16:12:26.345]                   name <- added[[kk]]
[16:12:26.345]                   NAME <- NAMES[[kk]]
[16:12:26.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.345]                     next
[16:12:26.345]                   args[[name]] <- ""
[16:12:26.345]                 }
[16:12:26.345]                 NAMES <- toupper(removed)
[16:12:26.345]                 for (kk in seq_along(NAMES)) {
[16:12:26.345]                   name <- removed[[kk]]
[16:12:26.345]                   NAME <- NAMES[[kk]]
[16:12:26.345]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.345]                     next
[16:12:26.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.345]                 }
[16:12:26.345]                 if (length(args) > 0) 
[16:12:26.345]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.345]             }
[16:12:26.345]             else {
[16:12:26.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.345]             }
[16:12:26.345]             {
[16:12:26.345]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.345]                   0L) {
[16:12:26.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.345]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.345]                   base::options(opts)
[16:12:26.345]                 }
[16:12:26.345]                 {
[16:12:26.345]                   {
[16:12:26.345]                     NULL
[16:12:26.345]                     RNGkind("Mersenne-Twister")
[16:12:26.345]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.345]                       inherits = FALSE)
[16:12:26.345]                   }
[16:12:26.345]                   options(future.plan = NULL)
[16:12:26.345]                   if (is.na(NA_character_)) 
[16:12:26.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.345]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.345]                   {
[16:12:26.345]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.345]                     if (!future$lazy) 
[16:12:26.345]                       future <- run(future)
[16:12:26.345]                     invisible(future)
[16:12:26.345]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.345]                 }
[16:12:26.345]             }
[16:12:26.345]         }
[16:12:26.345]     })
[16:12:26.345]     if (TRUE) {
[16:12:26.345]         base::sink(type = "output", split = FALSE)
[16:12:26.345]         if (TRUE) {
[16:12:26.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.345]         }
[16:12:26.345]         else {
[16:12:26.345]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.345]         }
[16:12:26.345]         base::close(...future.stdout)
[16:12:26.345]         ...future.stdout <- NULL
[16:12:26.345]     }
[16:12:26.345]     ...future.result$conditions <- ...future.conditions
[16:12:26.345]     ...future.result$finished <- base::Sys.time()
[16:12:26.345]     ...future.result
[16:12:26.345] }
[16:12:26.347] plan(): Setting new future strategy stack:
[16:12:26.347] List of future strategies:
[16:12:26.347] 1. sequential:
[16:12:26.347]    - args: function (..., envir = parent.frame())
[16:12:26.347]    - tweaked: FALSE
[16:12:26.347]    - call: NULL
[16:12:26.347] plan(): nbrOfWorkers() = 1
[16:12:26.348] plan(): Setting new future strategy stack:
[16:12:26.348] List of future strategies:
[16:12:26.348] 1. sequential:
[16:12:26.348]    - args: function (..., envir = parent.frame())
[16:12:26.348]    - tweaked: FALSE
[16:12:26.348]    - call: plan(strategy)
[16:12:26.348] plan(): nbrOfWorkers() = 1
[16:12:26.349] SequentialFuture started (and completed)
[16:12:26.349] - Launch lazy future ... done
[16:12:26.349] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bad828d48> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bae433288> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bad828d48> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bae433288> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:12:26.353] resolved() for ‘SequentialFuture’ ...
[16:12:26.353] - state: ‘finished’
[16:12:26.354] - run: TRUE
[16:12:26.354] - result: ‘FutureResult’
[16:12:26.354] resolved() for ‘SequentialFuture’ ... done
[16:12:26.354] resolved() for ‘SequentialFuture’ ...
[16:12:26.354] - state: ‘finished’
[16:12:26.354] - run: TRUE
[16:12:26.354] - result: ‘FutureResult’
[16:12:26.354] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:26.356] resolve() on list ...
[16:12:26.356]  recursive: 0
[16:12:26.356]  length: 6
[16:12:26.356]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:26.356] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.356] - nx: 6
[16:12:26.356] - relay: TRUE
[16:12:26.356] - stdout: TRUE
[16:12:26.356] - signal: TRUE
[16:12:26.356] - resignal: FALSE
[16:12:26.357] - force: TRUE
[16:12:26.357] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.357] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.357]  - until=2
[16:12:26.357]  - relaying element #2
[16:12:26.357] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.357] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.357] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.357]  length: 5 (resolved future 1)
[16:12:26.357] resolved() for ‘SequentialFuture’ ...
[16:12:26.357] - state: ‘finished’
[16:12:26.358] - run: TRUE
[16:12:26.358] - result: ‘FutureResult’
[16:12:26.358] resolved() for ‘SequentialFuture’ ... done
[16:12:26.358] Future #2
[16:12:26.358] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.358] - nx: 6
[16:12:26.358] - relay: TRUE
[16:12:26.358] - stdout: TRUE
[16:12:26.358] - signal: TRUE
[16:12:26.358] - resignal: FALSE
[16:12:26.358] - force: TRUE
[16:12:26.359] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.359] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.359]  - until=2
[16:12:26.359]  - relaying element #2
[16:12:26.359] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.359] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.359] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.359]  length: 4 (resolved future 2)
[16:12:26.359] resolved() for ‘SequentialFuture’ ...
[16:12:26.359] - state: ‘finished’
[16:12:26.360] - run: TRUE
[16:12:26.360] - result: ‘FutureResult’
[16:12:26.360] resolved() for ‘SequentialFuture’ ... done
[16:12:26.362] Future #3
[16:12:26.362] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.362] - nx: 6
[16:12:26.362] - relay: TRUE
[16:12:26.362] - stdout: TRUE
[16:12:26.362] - signal: TRUE
[16:12:26.362] - resignal: FALSE
[16:12:26.362] - force: TRUE
[16:12:26.362] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.362] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.362]  - until=3
[16:12:26.363]  - relaying element #3
[16:12:26.363] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.363] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.363]  length: 3 (resolved future 3)
[16:12:26.363] signalConditionsASAP(NULL, pos=4) ...
[16:12:26.363] - nx: 6
[16:12:26.363] - relay: TRUE
[16:12:26.363] - stdout: TRUE
[16:12:26.363] - signal: TRUE
[16:12:26.364] - resignal: FALSE
[16:12:26.364] - force: TRUE
[16:12:26.364] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.364]  - until=5
[16:12:26.364]  - relaying element #5
[16:12:26.364] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.364] signalConditionsASAP(NULL, pos=4) ... done
[16:12:26.364]  length: 2 (resolved future 4)
[16:12:26.364] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.365] - nx: 6
[16:12:26.365] - relay: TRUE
[16:12:26.365] - stdout: TRUE
[16:12:26.365] - signal: TRUE
[16:12:26.365] - resignal: FALSE
[16:12:26.365] - force: TRUE
[16:12:26.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.365]  - until=6
[16:12:26.365]  - relaying element #6
[16:12:26.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.366] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.366]  length: 1 (resolved future 5)
[16:12:26.366] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.366] - nx: 6
[16:12:26.366] - relay: TRUE
[16:12:26.366] - stdout: TRUE
[16:12:26.366] - signal: TRUE
[16:12:26.366] - resignal: FALSE
[16:12:26.366] - force: TRUE
[16:12:26.366] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.366] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.366]  - until=6
[16:12:26.367] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.367] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.367] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.367]  length: 0 (resolved future 6)
[16:12:26.367] Relaying remaining futures
[16:12:26.367] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.367] - nx: 6
[16:12:26.367] - relay: TRUE
[16:12:26.367] - stdout: TRUE
[16:12:26.367] - signal: TRUE
[16:12:26.367] - resignal: FALSE
[16:12:26.368] - force: TRUE
[16:12:26.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.368] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:26.368] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.368] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.368] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.368] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:12:26.371] getGlobalsAndPackages() ...
[16:12:26.371] Searching for globals...
[16:12:26.372] 
[16:12:26.372] Searching for globals ... DONE
[16:12:26.372] - globals: [0] <none>
[16:12:26.372] getGlobalsAndPackages() ... DONE
[16:12:26.372] run() for ‘Future’ ...
[16:12:26.372] - state: ‘created’
[16:12:26.372] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.373] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.373] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.373]   - Field: ‘label’
[16:12:26.373]   - Field: ‘local’
[16:12:26.373]   - Field: ‘owner’
[16:12:26.373]   - Field: ‘envir’
[16:12:26.373]   - Field: ‘packages’
[16:12:26.373]   - Field: ‘gc’
[16:12:26.374]   - Field: ‘conditions’
[16:12:26.374]   - Field: ‘expr’
[16:12:26.374]   - Field: ‘uuid’
[16:12:26.374]   - Field: ‘seed’
[16:12:26.374]   - Field: ‘version’
[16:12:26.374]   - Field: ‘result’
[16:12:26.374]   - Field: ‘asynchronous’
[16:12:26.374]   - Field: ‘calls’
[16:12:26.374]   - Field: ‘globals’
[16:12:26.374]   - Field: ‘stdout’
[16:12:26.374]   - Field: ‘earlySignal’
[16:12:26.375]   - Field: ‘lazy’
[16:12:26.375]   - Field: ‘state’
[16:12:26.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.375] - Launch lazy future ...
[16:12:26.375] Packages needed by the future expression (n = 0): <none>
[16:12:26.375] Packages needed by future strategies (n = 0): <none>
[16:12:26.375] {
[16:12:26.375]     {
[16:12:26.375]         {
[16:12:26.375]             ...future.startTime <- base::Sys.time()
[16:12:26.375]             {
[16:12:26.375]                 {
[16:12:26.375]                   {
[16:12:26.375]                     base::local({
[16:12:26.375]                       has_future <- base::requireNamespace("future", 
[16:12:26.375]                         quietly = TRUE)
[16:12:26.375]                       if (has_future) {
[16:12:26.375]                         ns <- base::getNamespace("future")
[16:12:26.375]                         version <- ns[[".package"]][["version"]]
[16:12:26.375]                         if (is.null(version)) 
[16:12:26.375]                           version <- utils::packageVersion("future")
[16:12:26.375]                       }
[16:12:26.375]                       else {
[16:12:26.375]                         version <- NULL
[16:12:26.375]                       }
[16:12:26.375]                       if (!has_future || version < "1.8.0") {
[16:12:26.375]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.375]                           "", base::R.version$version.string), 
[16:12:26.375]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.375]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.375]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.375]                             "release", "version")], collapse = " "), 
[16:12:26.375]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.375]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.375]                           info)
[16:12:26.375]                         info <- base::paste(info, collapse = "; ")
[16:12:26.375]                         if (!has_future) {
[16:12:26.375]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.375]                             info)
[16:12:26.375]                         }
[16:12:26.375]                         else {
[16:12:26.375]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.375]                             info, version)
[16:12:26.375]                         }
[16:12:26.375]                         base::stop(msg)
[16:12:26.375]                       }
[16:12:26.375]                     })
[16:12:26.375]                   }
[16:12:26.375]                   options(future.plan = NULL)
[16:12:26.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.375]                 }
[16:12:26.375]                 ...future.workdir <- getwd()
[16:12:26.375]             }
[16:12:26.375]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.375]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.375]         }
[16:12:26.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.375]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.375]             base::names(...future.oldOptions))
[16:12:26.375]     }
[16:12:26.375]     if (FALSE) {
[16:12:26.375]     }
[16:12:26.375]     else {
[16:12:26.375]         if (TRUE) {
[16:12:26.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.375]                 open = "w")
[16:12:26.375]         }
[16:12:26.375]         else {
[16:12:26.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.375]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.375]         }
[16:12:26.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.375]             base::sink(type = "output", split = FALSE)
[16:12:26.375]             base::close(...future.stdout)
[16:12:26.375]         }, add = TRUE)
[16:12:26.375]     }
[16:12:26.375]     ...future.frame <- base::sys.nframe()
[16:12:26.375]     ...future.conditions <- base::list()
[16:12:26.375]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.375]     if (FALSE) {
[16:12:26.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.375]     }
[16:12:26.375]     ...future.result <- base::tryCatch({
[16:12:26.375]         base::withCallingHandlers({
[16:12:26.375]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.375]             future::FutureResult(value = ...future.value$value, 
[16:12:26.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.375]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.375]                     ...future.globalenv.names))
[16:12:26.375]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.375]         }, condition = base::local({
[16:12:26.375]             c <- base::c
[16:12:26.375]             inherits <- base::inherits
[16:12:26.375]             invokeRestart <- base::invokeRestart
[16:12:26.375]             length <- base::length
[16:12:26.375]             list <- base::list
[16:12:26.375]             seq.int <- base::seq.int
[16:12:26.375]             signalCondition <- base::signalCondition
[16:12:26.375]             sys.calls <- base::sys.calls
[16:12:26.375]             `[[` <- base::`[[`
[16:12:26.375]             `+` <- base::`+`
[16:12:26.375]             `<<-` <- base::`<<-`
[16:12:26.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.375]                   3L)]
[16:12:26.375]             }
[16:12:26.375]             function(cond) {
[16:12:26.375]                 is_error <- inherits(cond, "error")
[16:12:26.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.375]                   NULL)
[16:12:26.375]                 if (is_error) {
[16:12:26.375]                   sessionInformation <- function() {
[16:12:26.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.375]                       search = base::search(), system = base::Sys.info())
[16:12:26.375]                   }
[16:12:26.375]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.375]                     cond$call), session = sessionInformation(), 
[16:12:26.375]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.375]                   signalCondition(cond)
[16:12:26.375]                 }
[16:12:26.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.375]                 "immediateCondition"))) {
[16:12:26.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.375]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.375]                   if (TRUE && !signal) {
[16:12:26.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.375]                     {
[16:12:26.375]                       inherits <- base::inherits
[16:12:26.375]                       invokeRestart <- base::invokeRestart
[16:12:26.375]                       is.null <- base::is.null
[16:12:26.375]                       muffled <- FALSE
[16:12:26.375]                       if (inherits(cond, "message")) {
[16:12:26.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.375]                         if (muffled) 
[16:12:26.375]                           invokeRestart("muffleMessage")
[16:12:26.375]                       }
[16:12:26.375]                       else if (inherits(cond, "warning")) {
[16:12:26.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.375]                         if (muffled) 
[16:12:26.375]                           invokeRestart("muffleWarning")
[16:12:26.375]                       }
[16:12:26.375]                       else if (inherits(cond, "condition")) {
[16:12:26.375]                         if (!is.null(pattern)) {
[16:12:26.375]                           computeRestarts <- base::computeRestarts
[16:12:26.375]                           grepl <- base::grepl
[16:12:26.375]                           restarts <- computeRestarts(cond)
[16:12:26.375]                           for (restart in restarts) {
[16:12:26.375]                             name <- restart$name
[16:12:26.375]                             if (is.null(name)) 
[16:12:26.375]                               next
[16:12:26.375]                             if (!grepl(pattern, name)) 
[16:12:26.375]                               next
[16:12:26.375]                             invokeRestart(restart)
[16:12:26.375]                             muffled <- TRUE
[16:12:26.375]                             break
[16:12:26.375]                           }
[16:12:26.375]                         }
[16:12:26.375]                       }
[16:12:26.375]                       invisible(muffled)
[16:12:26.375]                     }
[16:12:26.375]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.375]                   }
[16:12:26.375]                 }
[16:12:26.375]                 else {
[16:12:26.375]                   if (TRUE) {
[16:12:26.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.375]                     {
[16:12:26.375]                       inherits <- base::inherits
[16:12:26.375]                       invokeRestart <- base::invokeRestart
[16:12:26.375]                       is.null <- base::is.null
[16:12:26.375]                       muffled <- FALSE
[16:12:26.375]                       if (inherits(cond, "message")) {
[16:12:26.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.375]                         if (muffled) 
[16:12:26.375]                           invokeRestart("muffleMessage")
[16:12:26.375]                       }
[16:12:26.375]                       else if (inherits(cond, "warning")) {
[16:12:26.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.375]                         if (muffled) 
[16:12:26.375]                           invokeRestart("muffleWarning")
[16:12:26.375]                       }
[16:12:26.375]                       else if (inherits(cond, "condition")) {
[16:12:26.375]                         if (!is.null(pattern)) {
[16:12:26.375]                           computeRestarts <- base::computeRestarts
[16:12:26.375]                           grepl <- base::grepl
[16:12:26.375]                           restarts <- computeRestarts(cond)
[16:12:26.375]                           for (restart in restarts) {
[16:12:26.375]                             name <- restart$name
[16:12:26.375]                             if (is.null(name)) 
[16:12:26.375]                               next
[16:12:26.375]                             if (!grepl(pattern, name)) 
[16:12:26.375]                               next
[16:12:26.375]                             invokeRestart(restart)
[16:12:26.375]                             muffled <- TRUE
[16:12:26.375]                             break
[16:12:26.375]                           }
[16:12:26.375]                         }
[16:12:26.375]                       }
[16:12:26.375]                       invisible(muffled)
[16:12:26.375]                     }
[16:12:26.375]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.375]                   }
[16:12:26.375]                 }
[16:12:26.375]             }
[16:12:26.375]         }))
[16:12:26.375]     }, error = function(ex) {
[16:12:26.375]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.375]                 ...future.rng), started = ...future.startTime, 
[16:12:26.375]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.375]             version = "1.8"), class = "FutureResult")
[16:12:26.375]     }, finally = {
[16:12:26.375]         if (!identical(...future.workdir, getwd())) 
[16:12:26.375]             setwd(...future.workdir)
[16:12:26.375]         {
[16:12:26.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.375]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.375]             }
[16:12:26.375]             base::options(...future.oldOptions)
[16:12:26.375]             if (.Platform$OS.type == "windows") {
[16:12:26.375]                 old_names <- names(...future.oldEnvVars)
[16:12:26.375]                 envs <- base::Sys.getenv()
[16:12:26.375]                 names <- names(envs)
[16:12:26.375]                 common <- intersect(names, old_names)
[16:12:26.375]                 added <- setdiff(names, old_names)
[16:12:26.375]                 removed <- setdiff(old_names, names)
[16:12:26.375]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.375]                   envs[common]]
[16:12:26.375]                 NAMES <- toupper(changed)
[16:12:26.375]                 args <- list()
[16:12:26.375]                 for (kk in seq_along(NAMES)) {
[16:12:26.375]                   name <- changed[[kk]]
[16:12:26.375]                   NAME <- NAMES[[kk]]
[16:12:26.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.375]                     next
[16:12:26.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.375]                 }
[16:12:26.375]                 NAMES <- toupper(added)
[16:12:26.375]                 for (kk in seq_along(NAMES)) {
[16:12:26.375]                   name <- added[[kk]]
[16:12:26.375]                   NAME <- NAMES[[kk]]
[16:12:26.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.375]                     next
[16:12:26.375]                   args[[name]] <- ""
[16:12:26.375]                 }
[16:12:26.375]                 NAMES <- toupper(removed)
[16:12:26.375]                 for (kk in seq_along(NAMES)) {
[16:12:26.375]                   name <- removed[[kk]]
[16:12:26.375]                   NAME <- NAMES[[kk]]
[16:12:26.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.375]                     next
[16:12:26.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.375]                 }
[16:12:26.375]                 if (length(args) > 0) 
[16:12:26.375]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.375]             }
[16:12:26.375]             else {
[16:12:26.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.375]             }
[16:12:26.375]             {
[16:12:26.375]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.375]                   0L) {
[16:12:26.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.375]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.375]                   base::options(opts)
[16:12:26.375]                 }
[16:12:26.375]                 {
[16:12:26.375]                   {
[16:12:26.375]                     NULL
[16:12:26.375]                     RNGkind("Mersenne-Twister")
[16:12:26.375]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.375]                       inherits = FALSE)
[16:12:26.375]                   }
[16:12:26.375]                   options(future.plan = NULL)
[16:12:26.375]                   if (is.na(NA_character_)) 
[16:12:26.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.375]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.375]                   {
[16:12:26.375]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.375]                     if (!future$lazy) 
[16:12:26.375]                       future <- run(future)
[16:12:26.375]                     invisible(future)
[16:12:26.375]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.375]                 }
[16:12:26.375]             }
[16:12:26.375]         }
[16:12:26.375]     })
[16:12:26.375]     if (TRUE) {
[16:12:26.375]         base::sink(type = "output", split = FALSE)
[16:12:26.375]         if (TRUE) {
[16:12:26.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.375]         }
[16:12:26.375]         else {
[16:12:26.375]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.375]         }
[16:12:26.375]         base::close(...future.stdout)
[16:12:26.375]         ...future.stdout <- NULL
[16:12:26.375]     }
[16:12:26.375]     ...future.result$conditions <- ...future.conditions
[16:12:26.375]     ...future.result$finished <- base::Sys.time()
[16:12:26.375]     ...future.result
[16:12:26.375] }
[16:12:26.377] plan(): Setting new future strategy stack:
[16:12:26.377] List of future strategies:
[16:12:26.377] 1. sequential:
[16:12:26.377]    - args: function (..., envir = parent.frame())
[16:12:26.377]    - tweaked: FALSE
[16:12:26.377]    - call: NULL
[16:12:26.378] plan(): nbrOfWorkers() = 1
[16:12:26.378] plan(): Setting new future strategy stack:
[16:12:26.379] List of future strategies:
[16:12:26.379] 1. sequential:
[16:12:26.379]    - args: function (..., envir = parent.frame())
[16:12:26.379]    - tweaked: FALSE
[16:12:26.379]    - call: plan(strategy)
[16:12:26.379] plan(): nbrOfWorkers() = 1
[16:12:26.379] SequentialFuture started (and completed)
[16:12:26.379] - Launch lazy future ... done
[16:12:26.379] run() for ‘SequentialFuture’ ... done
[16:12:26.379] getGlobalsAndPackages() ...
[16:12:26.379] Searching for globals...
[16:12:26.380] 
[16:12:26.380] Searching for globals ... DONE
[16:12:26.380] - globals: [0] <none>
[16:12:26.380] getGlobalsAndPackages() ... DONE
[16:12:26.380] run() for ‘Future’ ...
[16:12:26.380] - state: ‘created’
[16:12:26.380] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.381] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.381]   - Field: ‘label’
[16:12:26.381]   - Field: ‘local’
[16:12:26.381]   - Field: ‘owner’
[16:12:26.381]   - Field: ‘envir’
[16:12:26.381]   - Field: ‘packages’
[16:12:26.381]   - Field: ‘gc’
[16:12:26.381]   - Field: ‘conditions’
[16:12:26.382]   - Field: ‘expr’
[16:12:26.382]   - Field: ‘uuid’
[16:12:26.382]   - Field: ‘seed’
[16:12:26.382]   - Field: ‘version’
[16:12:26.382]   - Field: ‘result’
[16:12:26.382]   - Field: ‘asynchronous’
[16:12:26.382]   - Field: ‘calls’
[16:12:26.382]   - Field: ‘globals’
[16:12:26.382]   - Field: ‘stdout’
[16:12:26.382]   - Field: ‘earlySignal’
[16:12:26.382]   - Field: ‘lazy’
[16:12:26.383]   - Field: ‘state’
[16:12:26.383] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.383] - Launch lazy future ...
[16:12:26.383] Packages needed by the future expression (n = 0): <none>
[16:12:26.383] Packages needed by future strategies (n = 0): <none>
[16:12:26.383] {
[16:12:26.383]     {
[16:12:26.383]         {
[16:12:26.383]             ...future.startTime <- base::Sys.time()
[16:12:26.383]             {
[16:12:26.383]                 {
[16:12:26.383]                   {
[16:12:26.383]                     base::local({
[16:12:26.383]                       has_future <- base::requireNamespace("future", 
[16:12:26.383]                         quietly = TRUE)
[16:12:26.383]                       if (has_future) {
[16:12:26.383]                         ns <- base::getNamespace("future")
[16:12:26.383]                         version <- ns[[".package"]][["version"]]
[16:12:26.383]                         if (is.null(version)) 
[16:12:26.383]                           version <- utils::packageVersion("future")
[16:12:26.383]                       }
[16:12:26.383]                       else {
[16:12:26.383]                         version <- NULL
[16:12:26.383]                       }
[16:12:26.383]                       if (!has_future || version < "1.8.0") {
[16:12:26.383]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.383]                           "", base::R.version$version.string), 
[16:12:26.383]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.383]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.383]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.383]                             "release", "version")], collapse = " "), 
[16:12:26.383]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.383]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.383]                           info)
[16:12:26.383]                         info <- base::paste(info, collapse = "; ")
[16:12:26.383]                         if (!has_future) {
[16:12:26.383]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.383]                             info)
[16:12:26.383]                         }
[16:12:26.383]                         else {
[16:12:26.383]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.383]                             info, version)
[16:12:26.383]                         }
[16:12:26.383]                         base::stop(msg)
[16:12:26.383]                       }
[16:12:26.383]                     })
[16:12:26.383]                   }
[16:12:26.383]                   options(future.plan = NULL)
[16:12:26.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.383]                 }
[16:12:26.383]                 ...future.workdir <- getwd()
[16:12:26.383]             }
[16:12:26.383]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.383]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.383]         }
[16:12:26.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.383]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.383]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.383]             base::names(...future.oldOptions))
[16:12:26.383]     }
[16:12:26.383]     if (FALSE) {
[16:12:26.383]     }
[16:12:26.383]     else {
[16:12:26.383]         if (TRUE) {
[16:12:26.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.383]                 open = "w")
[16:12:26.383]         }
[16:12:26.383]         else {
[16:12:26.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.383]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.383]         }
[16:12:26.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.383]             base::sink(type = "output", split = FALSE)
[16:12:26.383]             base::close(...future.stdout)
[16:12:26.383]         }, add = TRUE)
[16:12:26.383]     }
[16:12:26.383]     ...future.frame <- base::sys.nframe()
[16:12:26.383]     ...future.conditions <- base::list()
[16:12:26.383]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.383]     if (FALSE) {
[16:12:26.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.383]     }
[16:12:26.383]     ...future.result <- base::tryCatch({
[16:12:26.383]         base::withCallingHandlers({
[16:12:26.383]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.383]             future::FutureResult(value = ...future.value$value, 
[16:12:26.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.383]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.383]                     ...future.globalenv.names))
[16:12:26.383]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.383]         }, condition = base::local({
[16:12:26.383]             c <- base::c
[16:12:26.383]             inherits <- base::inherits
[16:12:26.383]             invokeRestart <- base::invokeRestart
[16:12:26.383]             length <- base::length
[16:12:26.383]             list <- base::list
[16:12:26.383]             seq.int <- base::seq.int
[16:12:26.383]             signalCondition <- base::signalCondition
[16:12:26.383]             sys.calls <- base::sys.calls
[16:12:26.383]             `[[` <- base::`[[`
[16:12:26.383]             `+` <- base::`+`
[16:12:26.383]             `<<-` <- base::`<<-`
[16:12:26.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.383]                   3L)]
[16:12:26.383]             }
[16:12:26.383]             function(cond) {
[16:12:26.383]                 is_error <- inherits(cond, "error")
[16:12:26.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.383]                   NULL)
[16:12:26.383]                 if (is_error) {
[16:12:26.383]                   sessionInformation <- function() {
[16:12:26.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.383]                       search = base::search(), system = base::Sys.info())
[16:12:26.383]                   }
[16:12:26.383]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.383]                     cond$call), session = sessionInformation(), 
[16:12:26.383]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.383]                   signalCondition(cond)
[16:12:26.383]                 }
[16:12:26.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.383]                 "immediateCondition"))) {
[16:12:26.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.383]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.383]                   if (TRUE && !signal) {
[16:12:26.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.383]                     {
[16:12:26.383]                       inherits <- base::inherits
[16:12:26.383]                       invokeRestart <- base::invokeRestart
[16:12:26.383]                       is.null <- base::is.null
[16:12:26.383]                       muffled <- FALSE
[16:12:26.383]                       if (inherits(cond, "message")) {
[16:12:26.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.383]                         if (muffled) 
[16:12:26.383]                           invokeRestart("muffleMessage")
[16:12:26.383]                       }
[16:12:26.383]                       else if (inherits(cond, "warning")) {
[16:12:26.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.383]                         if (muffled) 
[16:12:26.383]                           invokeRestart("muffleWarning")
[16:12:26.383]                       }
[16:12:26.383]                       else if (inherits(cond, "condition")) {
[16:12:26.383]                         if (!is.null(pattern)) {
[16:12:26.383]                           computeRestarts <- base::computeRestarts
[16:12:26.383]                           grepl <- base::grepl
[16:12:26.383]                           restarts <- computeRestarts(cond)
[16:12:26.383]                           for (restart in restarts) {
[16:12:26.383]                             name <- restart$name
[16:12:26.383]                             if (is.null(name)) 
[16:12:26.383]                               next
[16:12:26.383]                             if (!grepl(pattern, name)) 
[16:12:26.383]                               next
[16:12:26.383]                             invokeRestart(restart)
[16:12:26.383]                             muffled <- TRUE
[16:12:26.383]                             break
[16:12:26.383]                           }
[16:12:26.383]                         }
[16:12:26.383]                       }
[16:12:26.383]                       invisible(muffled)
[16:12:26.383]                     }
[16:12:26.383]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.383]                   }
[16:12:26.383]                 }
[16:12:26.383]                 else {
[16:12:26.383]                   if (TRUE) {
[16:12:26.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.383]                     {
[16:12:26.383]                       inherits <- base::inherits
[16:12:26.383]                       invokeRestart <- base::invokeRestart
[16:12:26.383]                       is.null <- base::is.null
[16:12:26.383]                       muffled <- FALSE
[16:12:26.383]                       if (inherits(cond, "message")) {
[16:12:26.383]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.383]                         if (muffled) 
[16:12:26.383]                           invokeRestart("muffleMessage")
[16:12:26.383]                       }
[16:12:26.383]                       else if (inherits(cond, "warning")) {
[16:12:26.383]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.383]                         if (muffled) 
[16:12:26.383]                           invokeRestart("muffleWarning")
[16:12:26.383]                       }
[16:12:26.383]                       else if (inherits(cond, "condition")) {
[16:12:26.383]                         if (!is.null(pattern)) {
[16:12:26.383]                           computeRestarts <- base::computeRestarts
[16:12:26.383]                           grepl <- base::grepl
[16:12:26.383]                           restarts <- computeRestarts(cond)
[16:12:26.383]                           for (restart in restarts) {
[16:12:26.383]                             name <- restart$name
[16:12:26.383]                             if (is.null(name)) 
[16:12:26.383]                               next
[16:12:26.383]                             if (!grepl(pattern, name)) 
[16:12:26.383]                               next
[16:12:26.383]                             invokeRestart(restart)
[16:12:26.383]                             muffled <- TRUE
[16:12:26.383]                             break
[16:12:26.383]                           }
[16:12:26.383]                         }
[16:12:26.383]                       }
[16:12:26.383]                       invisible(muffled)
[16:12:26.383]                     }
[16:12:26.383]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.383]                   }
[16:12:26.383]                 }
[16:12:26.383]             }
[16:12:26.383]         }))
[16:12:26.383]     }, error = function(ex) {
[16:12:26.383]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.383]                 ...future.rng), started = ...future.startTime, 
[16:12:26.383]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.383]             version = "1.8"), class = "FutureResult")
[16:12:26.383]     }, finally = {
[16:12:26.383]         if (!identical(...future.workdir, getwd())) 
[16:12:26.383]             setwd(...future.workdir)
[16:12:26.383]         {
[16:12:26.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.383]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.383]             }
[16:12:26.383]             base::options(...future.oldOptions)
[16:12:26.383]             if (.Platform$OS.type == "windows") {
[16:12:26.383]                 old_names <- names(...future.oldEnvVars)
[16:12:26.383]                 envs <- base::Sys.getenv()
[16:12:26.383]                 names <- names(envs)
[16:12:26.383]                 common <- intersect(names, old_names)
[16:12:26.383]                 added <- setdiff(names, old_names)
[16:12:26.383]                 removed <- setdiff(old_names, names)
[16:12:26.383]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.383]                   envs[common]]
[16:12:26.383]                 NAMES <- toupper(changed)
[16:12:26.383]                 args <- list()
[16:12:26.383]                 for (kk in seq_along(NAMES)) {
[16:12:26.383]                   name <- changed[[kk]]
[16:12:26.383]                   NAME <- NAMES[[kk]]
[16:12:26.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.383]                     next
[16:12:26.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.383]                 }
[16:12:26.383]                 NAMES <- toupper(added)
[16:12:26.383]                 for (kk in seq_along(NAMES)) {
[16:12:26.383]                   name <- added[[kk]]
[16:12:26.383]                   NAME <- NAMES[[kk]]
[16:12:26.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.383]                     next
[16:12:26.383]                   args[[name]] <- ""
[16:12:26.383]                 }
[16:12:26.383]                 NAMES <- toupper(removed)
[16:12:26.383]                 for (kk in seq_along(NAMES)) {
[16:12:26.383]                   name <- removed[[kk]]
[16:12:26.383]                   NAME <- NAMES[[kk]]
[16:12:26.383]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.383]                     next
[16:12:26.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.383]                 }
[16:12:26.383]                 if (length(args) > 0) 
[16:12:26.383]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.383]             }
[16:12:26.383]             else {
[16:12:26.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.383]             }
[16:12:26.383]             {
[16:12:26.383]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.383]                   0L) {
[16:12:26.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.383]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.383]                   base::options(opts)
[16:12:26.383]                 }
[16:12:26.383]                 {
[16:12:26.383]                   {
[16:12:26.383]                     NULL
[16:12:26.383]                     RNGkind("Mersenne-Twister")
[16:12:26.383]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.383]                       inherits = FALSE)
[16:12:26.383]                   }
[16:12:26.383]                   options(future.plan = NULL)
[16:12:26.383]                   if (is.na(NA_character_)) 
[16:12:26.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.383]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.383]                   {
[16:12:26.383]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.383]                     if (!future$lazy) 
[16:12:26.383]                       future <- run(future)
[16:12:26.383]                     invisible(future)
[16:12:26.383]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.383]                 }
[16:12:26.383]             }
[16:12:26.383]         }
[16:12:26.383]     })
[16:12:26.383]     if (TRUE) {
[16:12:26.383]         base::sink(type = "output", split = FALSE)
[16:12:26.383]         if (TRUE) {
[16:12:26.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.383]         }
[16:12:26.383]         else {
[16:12:26.383]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.383]         }
[16:12:26.383]         base::close(...future.stdout)
[16:12:26.383]         ...future.stdout <- NULL
[16:12:26.383]     }
[16:12:26.383]     ...future.result$conditions <- ...future.conditions
[16:12:26.383]     ...future.result$finished <- base::Sys.time()
[16:12:26.383]     ...future.result
[16:12:26.383] }
[16:12:26.385] plan(): Setting new future strategy stack:
[16:12:26.385] List of future strategies:
[16:12:26.385] 1. sequential:
[16:12:26.385]    - args: function (..., envir = parent.frame())
[16:12:26.385]    - tweaked: FALSE
[16:12:26.385]    - call: NULL
[16:12:26.386] plan(): nbrOfWorkers() = 1
[16:12:26.386] plan(): Setting new future strategy stack:
[16:12:26.386] List of future strategies:
[16:12:26.386] 1. sequential:
[16:12:26.386]    - args: function (..., envir = parent.frame())
[16:12:26.386]    - tweaked: FALSE
[16:12:26.386]    - call: plan(strategy)
[16:12:26.387] plan(): nbrOfWorkers() = 1
[16:12:26.387] SequentialFuture started (and completed)
[16:12:26.387] - Launch lazy future ... done
[16:12:26.387] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bae67bfa0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baeca23a8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bae67bfa0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baeca23a8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:26.393] resolved() for ‘SequentialFuture’ ...
[16:12:26.394] - state: ‘finished’
[16:12:26.394] - run: TRUE
[16:12:26.394] - result: ‘FutureResult’
[16:12:26.394] resolved() for ‘SequentialFuture’ ... done
[16:12:26.394] resolved() for ‘SequentialFuture’ ...
[16:12:26.394] - state: ‘finished’
[16:12:26.394] - run: TRUE
[16:12:26.394] - result: ‘FutureResult’
[16:12:26.394] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:26.396] resolve() on list ...
[16:12:26.396]  recursive: 0
[16:12:26.396]  length: 6
[16:12:26.396]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:26.396] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.397] - nx: 6
[16:12:26.397] - relay: TRUE
[16:12:26.397] - stdout: TRUE
[16:12:26.397] - signal: TRUE
[16:12:26.397] - resignal: FALSE
[16:12:26.397] - force: TRUE
[16:12:26.397] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.397] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.397]  - until=2
[16:12:26.397]  - relaying element #2
[16:12:26.397] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.397] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.398] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.398]  length: 5 (resolved future 1)
[16:12:26.398] resolved() for ‘SequentialFuture’ ...
[16:12:26.398] - state: ‘finished’
[16:12:26.398] - run: TRUE
[16:12:26.398] - result: ‘FutureResult’
[16:12:26.398] resolved() for ‘SequentialFuture’ ... done
[16:12:26.398] Future #2
[16:12:26.398] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.398] - nx: 6
[16:12:26.398] - relay: TRUE
[16:12:26.399] - stdout: TRUE
[16:12:26.399] - signal: TRUE
[16:12:26.399] - resignal: FALSE
[16:12:26.399] - force: TRUE
[16:12:26.399] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.399] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.399]  - until=2
[16:12:26.399]  - relaying element #2
[16:12:26.399] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.399] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.400] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.400]  length: 4 (resolved future 2)
[16:12:26.400] resolved() for ‘SequentialFuture’ ...
[16:12:26.400] - state: ‘finished’
[16:12:26.400] - run: TRUE
[16:12:26.400] - result: ‘FutureResult’
[16:12:26.400] resolved() for ‘SequentialFuture’ ... done
[16:12:26.400] Future #3
[16:12:26.400] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.400] - nx: 6
[16:12:26.400] - relay: TRUE
[16:12:26.401] - stdout: TRUE
[16:12:26.401] - signal: TRUE
[16:12:26.401] - resignal: FALSE
[16:12:26.401] - force: TRUE
[16:12:26.401] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.401] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.401]  - until=3
[16:12:26.401]  - relaying element #3
[16:12:26.401] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.401] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.402] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.402]  length: 3 (resolved future 3)
[16:12:26.402] signalConditionsASAP(NULL, pos=4) ...
[16:12:26.402] - nx: 6
[16:12:26.402] - relay: TRUE
[16:12:26.402] - stdout: TRUE
[16:12:26.402] - signal: TRUE
[16:12:26.402] - resignal: FALSE
[16:12:26.402] - force: TRUE
[16:12:26.402] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.402] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.402]  - until=5
[16:12:26.403]  - relaying element #5
[16:12:26.403] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.403] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.403] signalConditionsASAP(NULL, pos=4) ... done
[16:12:26.403]  length: 2 (resolved future 4)
[16:12:26.403] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.403] - nx: 6
[16:12:26.403] - relay: TRUE
[16:12:26.403] - stdout: TRUE
[16:12:26.403] - signal: TRUE
[16:12:26.403] - resignal: FALSE
[16:12:26.403] - force: TRUE
[16:12:26.404] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.404] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.404]  - until=6
[16:12:26.404]  - relaying element #6
[16:12:26.404] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.404] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.404] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.404]  length: 1 (resolved future 5)
[16:12:26.404] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.404] - nx: 6
[16:12:26.404] - relay: TRUE
[16:12:26.404] - stdout: TRUE
[16:12:26.405] - signal: TRUE
[16:12:26.405] - resignal: FALSE
[16:12:26.405] - force: TRUE
[16:12:26.405] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.405] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.405]  - until=6
[16:12:26.405] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.405] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.405] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.405]  length: 0 (resolved future 6)
[16:12:26.405] Relaying remaining futures
[16:12:26.405] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.406] - nx: 6
[16:12:26.406] - relay: TRUE
[16:12:26.406] - stdout: TRUE
[16:12:26.406] - signal: TRUE
[16:12:26.406] - resignal: FALSE
[16:12:26.406] - force: TRUE
[16:12:26.406] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.406] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:26.406] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.406] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.406] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.407] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:12:26.410] getGlobalsAndPackages() ...
[16:12:26.410] Searching for globals...
[16:12:26.410] 
[16:12:26.410] Searching for globals ... DONE
[16:12:26.410] - globals: [0] <none>
[16:12:26.411] getGlobalsAndPackages() ... DONE
[16:12:26.411] run() for ‘Future’ ...
[16:12:26.411] - state: ‘created’
[16:12:26.411] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.411] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.411]   - Field: ‘label’
[16:12:26.412]   - Field: ‘local’
[16:12:26.412]   - Field: ‘owner’
[16:12:26.412]   - Field: ‘envir’
[16:12:26.412]   - Field: ‘packages’
[16:12:26.412]   - Field: ‘gc’
[16:12:26.412]   - Field: ‘conditions’
[16:12:26.412]   - Field: ‘expr’
[16:12:26.412]   - Field: ‘uuid’
[16:12:26.412]   - Field: ‘seed’
[16:12:26.412]   - Field: ‘version’
[16:12:26.412]   - Field: ‘result’
[16:12:26.413]   - Field: ‘asynchronous’
[16:12:26.413]   - Field: ‘calls’
[16:12:26.413]   - Field: ‘globals’
[16:12:26.413]   - Field: ‘stdout’
[16:12:26.413]   - Field: ‘earlySignal’
[16:12:26.413]   - Field: ‘lazy’
[16:12:26.413]   - Field: ‘state’
[16:12:26.413] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.413] - Launch lazy future ...
[16:12:26.413] Packages needed by the future expression (n = 0): <none>
[16:12:26.414] Packages needed by future strategies (n = 0): <none>
[16:12:26.414] {
[16:12:26.414]     {
[16:12:26.414]         {
[16:12:26.414]             ...future.startTime <- base::Sys.time()
[16:12:26.414]             {
[16:12:26.414]                 {
[16:12:26.414]                   {
[16:12:26.414]                     base::local({
[16:12:26.414]                       has_future <- base::requireNamespace("future", 
[16:12:26.414]                         quietly = TRUE)
[16:12:26.414]                       if (has_future) {
[16:12:26.414]                         ns <- base::getNamespace("future")
[16:12:26.414]                         version <- ns[[".package"]][["version"]]
[16:12:26.414]                         if (is.null(version)) 
[16:12:26.414]                           version <- utils::packageVersion("future")
[16:12:26.414]                       }
[16:12:26.414]                       else {
[16:12:26.414]                         version <- NULL
[16:12:26.414]                       }
[16:12:26.414]                       if (!has_future || version < "1.8.0") {
[16:12:26.414]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.414]                           "", base::R.version$version.string), 
[16:12:26.414]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.414]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.414]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.414]                             "release", "version")], collapse = " "), 
[16:12:26.414]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.414]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.414]                           info)
[16:12:26.414]                         info <- base::paste(info, collapse = "; ")
[16:12:26.414]                         if (!has_future) {
[16:12:26.414]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.414]                             info)
[16:12:26.414]                         }
[16:12:26.414]                         else {
[16:12:26.414]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.414]                             info, version)
[16:12:26.414]                         }
[16:12:26.414]                         base::stop(msg)
[16:12:26.414]                       }
[16:12:26.414]                     })
[16:12:26.414]                   }
[16:12:26.414]                   options(future.plan = NULL)
[16:12:26.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.414]                 }
[16:12:26.414]                 ...future.workdir <- getwd()
[16:12:26.414]             }
[16:12:26.414]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.414]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.414]         }
[16:12:26.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.414]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.414]             base::names(...future.oldOptions))
[16:12:26.414]     }
[16:12:26.414]     if (FALSE) {
[16:12:26.414]     }
[16:12:26.414]     else {
[16:12:26.414]         if (TRUE) {
[16:12:26.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.414]                 open = "w")
[16:12:26.414]         }
[16:12:26.414]         else {
[16:12:26.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.414]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.414]         }
[16:12:26.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.414]             base::sink(type = "output", split = FALSE)
[16:12:26.414]             base::close(...future.stdout)
[16:12:26.414]         }, add = TRUE)
[16:12:26.414]     }
[16:12:26.414]     ...future.frame <- base::sys.nframe()
[16:12:26.414]     ...future.conditions <- base::list()
[16:12:26.414]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.414]     if (FALSE) {
[16:12:26.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.414]     }
[16:12:26.414]     ...future.result <- base::tryCatch({
[16:12:26.414]         base::withCallingHandlers({
[16:12:26.414]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.414]             future::FutureResult(value = ...future.value$value, 
[16:12:26.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.414]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.414]                     ...future.globalenv.names))
[16:12:26.414]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.414]         }, condition = base::local({
[16:12:26.414]             c <- base::c
[16:12:26.414]             inherits <- base::inherits
[16:12:26.414]             invokeRestart <- base::invokeRestart
[16:12:26.414]             length <- base::length
[16:12:26.414]             list <- base::list
[16:12:26.414]             seq.int <- base::seq.int
[16:12:26.414]             signalCondition <- base::signalCondition
[16:12:26.414]             sys.calls <- base::sys.calls
[16:12:26.414]             `[[` <- base::`[[`
[16:12:26.414]             `+` <- base::`+`
[16:12:26.414]             `<<-` <- base::`<<-`
[16:12:26.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.414]                   3L)]
[16:12:26.414]             }
[16:12:26.414]             function(cond) {
[16:12:26.414]                 is_error <- inherits(cond, "error")
[16:12:26.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.414]                   NULL)
[16:12:26.414]                 if (is_error) {
[16:12:26.414]                   sessionInformation <- function() {
[16:12:26.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.414]                       search = base::search(), system = base::Sys.info())
[16:12:26.414]                   }
[16:12:26.414]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.414]                     cond$call), session = sessionInformation(), 
[16:12:26.414]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.414]                   signalCondition(cond)
[16:12:26.414]                 }
[16:12:26.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.414]                 "immediateCondition"))) {
[16:12:26.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.414]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.414]                   if (TRUE && !signal) {
[16:12:26.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.414]                     {
[16:12:26.414]                       inherits <- base::inherits
[16:12:26.414]                       invokeRestart <- base::invokeRestart
[16:12:26.414]                       is.null <- base::is.null
[16:12:26.414]                       muffled <- FALSE
[16:12:26.414]                       if (inherits(cond, "message")) {
[16:12:26.414]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.414]                         if (muffled) 
[16:12:26.414]                           invokeRestart("muffleMessage")
[16:12:26.414]                       }
[16:12:26.414]                       else if (inherits(cond, "warning")) {
[16:12:26.414]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.414]                         if (muffled) 
[16:12:26.414]                           invokeRestart("muffleWarning")
[16:12:26.414]                       }
[16:12:26.414]                       else if (inherits(cond, "condition")) {
[16:12:26.414]                         if (!is.null(pattern)) {
[16:12:26.414]                           computeRestarts <- base::computeRestarts
[16:12:26.414]                           grepl <- base::grepl
[16:12:26.414]                           restarts <- computeRestarts(cond)
[16:12:26.414]                           for (restart in restarts) {
[16:12:26.414]                             name <- restart$name
[16:12:26.414]                             if (is.null(name)) 
[16:12:26.414]                               next
[16:12:26.414]                             if (!grepl(pattern, name)) 
[16:12:26.414]                               next
[16:12:26.414]                             invokeRestart(restart)
[16:12:26.414]                             muffled <- TRUE
[16:12:26.414]                             break
[16:12:26.414]                           }
[16:12:26.414]                         }
[16:12:26.414]                       }
[16:12:26.414]                       invisible(muffled)
[16:12:26.414]                     }
[16:12:26.414]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.414]                   }
[16:12:26.414]                 }
[16:12:26.414]                 else {
[16:12:26.414]                   if (TRUE) {
[16:12:26.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.414]                     {
[16:12:26.414]                       inherits <- base::inherits
[16:12:26.414]                       invokeRestart <- base::invokeRestart
[16:12:26.414]                       is.null <- base::is.null
[16:12:26.414]                       muffled <- FALSE
[16:12:26.414]                       if (inherits(cond, "message")) {
[16:12:26.414]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.414]                         if (muffled) 
[16:12:26.414]                           invokeRestart("muffleMessage")
[16:12:26.414]                       }
[16:12:26.414]                       else if (inherits(cond, "warning")) {
[16:12:26.414]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.414]                         if (muffled) 
[16:12:26.414]                           invokeRestart("muffleWarning")
[16:12:26.414]                       }
[16:12:26.414]                       else if (inherits(cond, "condition")) {
[16:12:26.414]                         if (!is.null(pattern)) {
[16:12:26.414]                           computeRestarts <- base::computeRestarts
[16:12:26.414]                           grepl <- base::grepl
[16:12:26.414]                           restarts <- computeRestarts(cond)
[16:12:26.414]                           for (restart in restarts) {
[16:12:26.414]                             name <- restart$name
[16:12:26.414]                             if (is.null(name)) 
[16:12:26.414]                               next
[16:12:26.414]                             if (!grepl(pattern, name)) 
[16:12:26.414]                               next
[16:12:26.414]                             invokeRestart(restart)
[16:12:26.414]                             muffled <- TRUE
[16:12:26.414]                             break
[16:12:26.414]                           }
[16:12:26.414]                         }
[16:12:26.414]                       }
[16:12:26.414]                       invisible(muffled)
[16:12:26.414]                     }
[16:12:26.414]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.414]                   }
[16:12:26.414]                 }
[16:12:26.414]             }
[16:12:26.414]         }))
[16:12:26.414]     }, error = function(ex) {
[16:12:26.414]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.414]                 ...future.rng), started = ...future.startTime, 
[16:12:26.414]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.414]             version = "1.8"), class = "FutureResult")
[16:12:26.414]     }, finally = {
[16:12:26.414]         if (!identical(...future.workdir, getwd())) 
[16:12:26.414]             setwd(...future.workdir)
[16:12:26.414]         {
[16:12:26.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.414]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.414]             }
[16:12:26.414]             base::options(...future.oldOptions)
[16:12:26.414]             if (.Platform$OS.type == "windows") {
[16:12:26.414]                 old_names <- names(...future.oldEnvVars)
[16:12:26.414]                 envs <- base::Sys.getenv()
[16:12:26.414]                 names <- names(envs)
[16:12:26.414]                 common <- intersect(names, old_names)
[16:12:26.414]                 added <- setdiff(names, old_names)
[16:12:26.414]                 removed <- setdiff(old_names, names)
[16:12:26.414]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.414]                   envs[common]]
[16:12:26.414]                 NAMES <- toupper(changed)
[16:12:26.414]                 args <- list()
[16:12:26.414]                 for (kk in seq_along(NAMES)) {
[16:12:26.414]                   name <- changed[[kk]]
[16:12:26.414]                   NAME <- NAMES[[kk]]
[16:12:26.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.414]                     next
[16:12:26.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.414]                 }
[16:12:26.414]                 NAMES <- toupper(added)
[16:12:26.414]                 for (kk in seq_along(NAMES)) {
[16:12:26.414]                   name <- added[[kk]]
[16:12:26.414]                   NAME <- NAMES[[kk]]
[16:12:26.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.414]                     next
[16:12:26.414]                   args[[name]] <- ""
[16:12:26.414]                 }
[16:12:26.414]                 NAMES <- toupper(removed)
[16:12:26.414]                 for (kk in seq_along(NAMES)) {
[16:12:26.414]                   name <- removed[[kk]]
[16:12:26.414]                   NAME <- NAMES[[kk]]
[16:12:26.414]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.414]                     next
[16:12:26.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.414]                 }
[16:12:26.414]                 if (length(args) > 0) 
[16:12:26.414]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.414]             }
[16:12:26.414]             else {
[16:12:26.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.414]             }
[16:12:26.414]             {
[16:12:26.414]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.414]                   0L) {
[16:12:26.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.414]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.414]                   base::options(opts)
[16:12:26.414]                 }
[16:12:26.414]                 {
[16:12:26.414]                   {
[16:12:26.414]                     NULL
[16:12:26.414]                     RNGkind("Mersenne-Twister")
[16:12:26.414]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.414]                       inherits = FALSE)
[16:12:26.414]                   }
[16:12:26.414]                   options(future.plan = NULL)
[16:12:26.414]                   if (is.na(NA_character_)) 
[16:12:26.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.414]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.414]                   {
[16:12:26.414]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.414]                     if (!future$lazy) 
[16:12:26.414]                       future <- run(future)
[16:12:26.414]                     invisible(future)
[16:12:26.414]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.414]                 }
[16:12:26.414]             }
[16:12:26.414]         }
[16:12:26.414]     })
[16:12:26.414]     if (TRUE) {
[16:12:26.414]         base::sink(type = "output", split = FALSE)
[16:12:26.414]         if (TRUE) {
[16:12:26.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.414]         }
[16:12:26.414]         else {
[16:12:26.414]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.414]         }
[16:12:26.414]         base::close(...future.stdout)
[16:12:26.414]         ...future.stdout <- NULL
[16:12:26.414]     }
[16:12:26.414]     ...future.result$conditions <- ...future.conditions
[16:12:26.414]     ...future.result$finished <- base::Sys.time()
[16:12:26.414]     ...future.result
[16:12:26.414] }
[16:12:26.417] plan(): Setting new future strategy stack:
[16:12:26.417] List of future strategies:
[16:12:26.417] 1. sequential:
[16:12:26.417]    - args: function (..., envir = parent.frame())
[16:12:26.417]    - tweaked: FALSE
[16:12:26.417]    - call: NULL
[16:12:26.417] plan(): nbrOfWorkers() = 1
[16:12:26.418] plan(): Setting new future strategy stack:
[16:12:26.418] List of future strategies:
[16:12:26.418] 1. sequential:
[16:12:26.418]    - args: function (..., envir = parent.frame())
[16:12:26.418]    - tweaked: FALSE
[16:12:26.418]    - call: plan(strategy)
[16:12:26.418] plan(): nbrOfWorkers() = 1
[16:12:26.419] SequentialFuture started (and completed)
[16:12:26.419] - Launch lazy future ... done
[16:12:26.419] run() for ‘SequentialFuture’ ... done
[16:12:26.419] getGlobalsAndPackages() ...
[16:12:26.419] Searching for globals...
[16:12:26.419] 
[16:12:26.419] Searching for globals ... DONE
[16:12:26.419] - globals: [0] <none>
[16:12:26.420] getGlobalsAndPackages() ... DONE
[16:12:26.420] run() for ‘Future’ ...
[16:12:26.420] - state: ‘created’
[16:12:26.420] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.420] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.420]   - Field: ‘label’
[16:12:26.421]   - Field: ‘local’
[16:12:26.421]   - Field: ‘owner’
[16:12:26.421]   - Field: ‘envir’
[16:12:26.421]   - Field: ‘packages’
[16:12:26.421]   - Field: ‘gc’
[16:12:26.421]   - Field: ‘conditions’
[16:12:26.421]   - Field: ‘expr’
[16:12:26.421]   - Field: ‘uuid’
[16:12:26.421]   - Field: ‘seed’
[16:12:26.421]   - Field: ‘version’
[16:12:26.422]   - Field: ‘result’
[16:12:26.422]   - Field: ‘asynchronous’
[16:12:26.422]   - Field: ‘calls’
[16:12:26.422]   - Field: ‘globals’
[16:12:26.422]   - Field: ‘stdout’
[16:12:26.422]   - Field: ‘earlySignal’
[16:12:26.422]   - Field: ‘lazy’
[16:12:26.422]   - Field: ‘state’
[16:12:26.422] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.422] - Launch lazy future ...
[16:12:26.422] Packages needed by the future expression (n = 0): <none>
[16:12:26.423] Packages needed by future strategies (n = 0): <none>
[16:12:26.423] {
[16:12:26.423]     {
[16:12:26.423]         {
[16:12:26.423]             ...future.startTime <- base::Sys.time()
[16:12:26.423]             {
[16:12:26.423]                 {
[16:12:26.423]                   {
[16:12:26.423]                     base::local({
[16:12:26.423]                       has_future <- base::requireNamespace("future", 
[16:12:26.423]                         quietly = TRUE)
[16:12:26.423]                       if (has_future) {
[16:12:26.423]                         ns <- base::getNamespace("future")
[16:12:26.423]                         version <- ns[[".package"]][["version"]]
[16:12:26.423]                         if (is.null(version)) 
[16:12:26.423]                           version <- utils::packageVersion("future")
[16:12:26.423]                       }
[16:12:26.423]                       else {
[16:12:26.423]                         version <- NULL
[16:12:26.423]                       }
[16:12:26.423]                       if (!has_future || version < "1.8.0") {
[16:12:26.423]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.423]                           "", base::R.version$version.string), 
[16:12:26.423]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.423]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.423]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.423]                             "release", "version")], collapse = " "), 
[16:12:26.423]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.423]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.423]                           info)
[16:12:26.423]                         info <- base::paste(info, collapse = "; ")
[16:12:26.423]                         if (!has_future) {
[16:12:26.423]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.423]                             info)
[16:12:26.423]                         }
[16:12:26.423]                         else {
[16:12:26.423]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.423]                             info, version)
[16:12:26.423]                         }
[16:12:26.423]                         base::stop(msg)
[16:12:26.423]                       }
[16:12:26.423]                     })
[16:12:26.423]                   }
[16:12:26.423]                   options(future.plan = NULL)
[16:12:26.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.423]                 }
[16:12:26.423]                 ...future.workdir <- getwd()
[16:12:26.423]             }
[16:12:26.423]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.423]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.423]         }
[16:12:26.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.423]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.423]             base::names(...future.oldOptions))
[16:12:26.423]     }
[16:12:26.423]     if (FALSE) {
[16:12:26.423]     }
[16:12:26.423]     else {
[16:12:26.423]         if (TRUE) {
[16:12:26.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.423]                 open = "w")
[16:12:26.423]         }
[16:12:26.423]         else {
[16:12:26.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.423]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.423]         }
[16:12:26.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.423]             base::sink(type = "output", split = FALSE)
[16:12:26.423]             base::close(...future.stdout)
[16:12:26.423]         }, add = TRUE)
[16:12:26.423]     }
[16:12:26.423]     ...future.frame <- base::sys.nframe()
[16:12:26.423]     ...future.conditions <- base::list()
[16:12:26.423]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.423]     if (FALSE) {
[16:12:26.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.423]     }
[16:12:26.423]     ...future.result <- base::tryCatch({
[16:12:26.423]         base::withCallingHandlers({
[16:12:26.423]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.423]             future::FutureResult(value = ...future.value$value, 
[16:12:26.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.423]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.423]                     ...future.globalenv.names))
[16:12:26.423]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.423]         }, condition = base::local({
[16:12:26.423]             c <- base::c
[16:12:26.423]             inherits <- base::inherits
[16:12:26.423]             invokeRestart <- base::invokeRestart
[16:12:26.423]             length <- base::length
[16:12:26.423]             list <- base::list
[16:12:26.423]             seq.int <- base::seq.int
[16:12:26.423]             signalCondition <- base::signalCondition
[16:12:26.423]             sys.calls <- base::sys.calls
[16:12:26.423]             `[[` <- base::`[[`
[16:12:26.423]             `+` <- base::`+`
[16:12:26.423]             `<<-` <- base::`<<-`
[16:12:26.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.423]                   3L)]
[16:12:26.423]             }
[16:12:26.423]             function(cond) {
[16:12:26.423]                 is_error <- inherits(cond, "error")
[16:12:26.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.423]                   NULL)
[16:12:26.423]                 if (is_error) {
[16:12:26.423]                   sessionInformation <- function() {
[16:12:26.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.423]                       search = base::search(), system = base::Sys.info())
[16:12:26.423]                   }
[16:12:26.423]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.423]                     cond$call), session = sessionInformation(), 
[16:12:26.423]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.423]                   signalCondition(cond)
[16:12:26.423]                 }
[16:12:26.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.423]                 "immediateCondition"))) {
[16:12:26.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.423]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.423]                   if (TRUE && !signal) {
[16:12:26.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.423]                     {
[16:12:26.423]                       inherits <- base::inherits
[16:12:26.423]                       invokeRestart <- base::invokeRestart
[16:12:26.423]                       is.null <- base::is.null
[16:12:26.423]                       muffled <- FALSE
[16:12:26.423]                       if (inherits(cond, "message")) {
[16:12:26.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.423]                         if (muffled) 
[16:12:26.423]                           invokeRestart("muffleMessage")
[16:12:26.423]                       }
[16:12:26.423]                       else if (inherits(cond, "warning")) {
[16:12:26.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.423]                         if (muffled) 
[16:12:26.423]                           invokeRestart("muffleWarning")
[16:12:26.423]                       }
[16:12:26.423]                       else if (inherits(cond, "condition")) {
[16:12:26.423]                         if (!is.null(pattern)) {
[16:12:26.423]                           computeRestarts <- base::computeRestarts
[16:12:26.423]                           grepl <- base::grepl
[16:12:26.423]                           restarts <- computeRestarts(cond)
[16:12:26.423]                           for (restart in restarts) {
[16:12:26.423]                             name <- restart$name
[16:12:26.423]                             if (is.null(name)) 
[16:12:26.423]                               next
[16:12:26.423]                             if (!grepl(pattern, name)) 
[16:12:26.423]                               next
[16:12:26.423]                             invokeRestart(restart)
[16:12:26.423]                             muffled <- TRUE
[16:12:26.423]                             break
[16:12:26.423]                           }
[16:12:26.423]                         }
[16:12:26.423]                       }
[16:12:26.423]                       invisible(muffled)
[16:12:26.423]                     }
[16:12:26.423]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.423]                   }
[16:12:26.423]                 }
[16:12:26.423]                 else {
[16:12:26.423]                   if (TRUE) {
[16:12:26.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.423]                     {
[16:12:26.423]                       inherits <- base::inherits
[16:12:26.423]                       invokeRestart <- base::invokeRestart
[16:12:26.423]                       is.null <- base::is.null
[16:12:26.423]                       muffled <- FALSE
[16:12:26.423]                       if (inherits(cond, "message")) {
[16:12:26.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.423]                         if (muffled) 
[16:12:26.423]                           invokeRestart("muffleMessage")
[16:12:26.423]                       }
[16:12:26.423]                       else if (inherits(cond, "warning")) {
[16:12:26.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.423]                         if (muffled) 
[16:12:26.423]                           invokeRestart("muffleWarning")
[16:12:26.423]                       }
[16:12:26.423]                       else if (inherits(cond, "condition")) {
[16:12:26.423]                         if (!is.null(pattern)) {
[16:12:26.423]                           computeRestarts <- base::computeRestarts
[16:12:26.423]                           grepl <- base::grepl
[16:12:26.423]                           restarts <- computeRestarts(cond)
[16:12:26.423]                           for (restart in restarts) {
[16:12:26.423]                             name <- restart$name
[16:12:26.423]                             if (is.null(name)) 
[16:12:26.423]                               next
[16:12:26.423]                             if (!grepl(pattern, name)) 
[16:12:26.423]                               next
[16:12:26.423]                             invokeRestart(restart)
[16:12:26.423]                             muffled <- TRUE
[16:12:26.423]                             break
[16:12:26.423]                           }
[16:12:26.423]                         }
[16:12:26.423]                       }
[16:12:26.423]                       invisible(muffled)
[16:12:26.423]                     }
[16:12:26.423]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.423]                   }
[16:12:26.423]                 }
[16:12:26.423]             }
[16:12:26.423]         }))
[16:12:26.423]     }, error = function(ex) {
[16:12:26.423]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.423]                 ...future.rng), started = ...future.startTime, 
[16:12:26.423]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.423]             version = "1.8"), class = "FutureResult")
[16:12:26.423]     }, finally = {
[16:12:26.423]         if (!identical(...future.workdir, getwd())) 
[16:12:26.423]             setwd(...future.workdir)
[16:12:26.423]         {
[16:12:26.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.423]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.423]             }
[16:12:26.423]             base::options(...future.oldOptions)
[16:12:26.423]             if (.Platform$OS.type == "windows") {
[16:12:26.423]                 old_names <- names(...future.oldEnvVars)
[16:12:26.423]                 envs <- base::Sys.getenv()
[16:12:26.423]                 names <- names(envs)
[16:12:26.423]                 common <- intersect(names, old_names)
[16:12:26.423]                 added <- setdiff(names, old_names)
[16:12:26.423]                 removed <- setdiff(old_names, names)
[16:12:26.423]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.423]                   envs[common]]
[16:12:26.423]                 NAMES <- toupper(changed)
[16:12:26.423]                 args <- list()
[16:12:26.423]                 for (kk in seq_along(NAMES)) {
[16:12:26.423]                   name <- changed[[kk]]
[16:12:26.423]                   NAME <- NAMES[[kk]]
[16:12:26.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.423]                     next
[16:12:26.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.423]                 }
[16:12:26.423]                 NAMES <- toupper(added)
[16:12:26.423]                 for (kk in seq_along(NAMES)) {
[16:12:26.423]                   name <- added[[kk]]
[16:12:26.423]                   NAME <- NAMES[[kk]]
[16:12:26.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.423]                     next
[16:12:26.423]                   args[[name]] <- ""
[16:12:26.423]                 }
[16:12:26.423]                 NAMES <- toupper(removed)
[16:12:26.423]                 for (kk in seq_along(NAMES)) {
[16:12:26.423]                   name <- removed[[kk]]
[16:12:26.423]                   NAME <- NAMES[[kk]]
[16:12:26.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.423]                     next
[16:12:26.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.423]                 }
[16:12:26.423]                 if (length(args) > 0) 
[16:12:26.423]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.423]             }
[16:12:26.423]             else {
[16:12:26.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.423]             }
[16:12:26.423]             {
[16:12:26.423]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.423]                   0L) {
[16:12:26.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.423]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.423]                   base::options(opts)
[16:12:26.423]                 }
[16:12:26.423]                 {
[16:12:26.423]                   {
[16:12:26.423]                     NULL
[16:12:26.423]                     RNGkind("Mersenne-Twister")
[16:12:26.423]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.423]                       inherits = FALSE)
[16:12:26.423]                   }
[16:12:26.423]                   options(future.plan = NULL)
[16:12:26.423]                   if (is.na(NA_character_)) 
[16:12:26.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.423]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.423]                   {
[16:12:26.423]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.423]                     if (!future$lazy) 
[16:12:26.423]                       future <- run(future)
[16:12:26.423]                     invisible(future)
[16:12:26.423]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.423]                 }
[16:12:26.423]             }
[16:12:26.423]         }
[16:12:26.423]     })
[16:12:26.423]     if (TRUE) {
[16:12:26.423]         base::sink(type = "output", split = FALSE)
[16:12:26.423]         if (TRUE) {
[16:12:26.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.423]         }
[16:12:26.423]         else {
[16:12:26.423]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.423]         }
[16:12:26.423]         base::close(...future.stdout)
[16:12:26.423]         ...future.stdout <- NULL
[16:12:26.423]     }
[16:12:26.423]     ...future.result$conditions <- ...future.conditions
[16:12:26.423]     ...future.result$finished <- base::Sys.time()
[16:12:26.423]     ...future.result
[16:12:26.423] }
[16:12:26.425] plan(): Setting new future strategy stack:
[16:12:26.425] List of future strategies:
[16:12:26.425] 1. sequential:
[16:12:26.425]    - args: function (..., envir = parent.frame())
[16:12:26.425]    - tweaked: FALSE
[16:12:26.425]    - call: NULL
[16:12:26.425] plan(): nbrOfWorkers() = 1
[16:12:26.426] plan(): Setting new future strategy stack:
[16:12:26.426] List of future strategies:
[16:12:26.426] 1. sequential:
[16:12:26.426]    - args: function (..., envir = parent.frame())
[16:12:26.426]    - tweaked: FALSE
[16:12:26.426]    - call: plan(strategy)
[16:12:26.426] plan(): nbrOfWorkers() = 1
[16:12:26.426] SequentialFuture started (and completed)
[16:12:26.427] - Launch lazy future ... done
[16:12:26.427] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baef1dbc0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bad5fe7c0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560baef1dbc0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x560bad5fe7c0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:26.432] resolved() for ‘SequentialFuture’ ...
[16:12:26.432] - state: ‘finished’
[16:12:26.432] - run: TRUE
[16:12:26.432] - result: ‘FutureResult’
[16:12:26.432] resolved() for ‘SequentialFuture’ ... done
[16:12:26.432] resolved() for ‘SequentialFuture’ ...
[16:12:26.432] - state: ‘finished’
[16:12:26.433] - run: TRUE
[16:12:26.433] - result: ‘FutureResult’
[16:12:26.433] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:26.435] resolve() on list ...
[16:12:26.435]  recursive: 0
[16:12:26.435]  length: 6
[16:12:26.435]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:26.435] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.435] - nx: 6
[16:12:26.435] - relay: TRUE
[16:12:26.435] - stdout: TRUE
[16:12:26.435] - signal: TRUE
[16:12:26.435] - resignal: FALSE
[16:12:26.435] - force: TRUE
[16:12:26.436] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.436] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.436]  - until=2
[16:12:26.436]  - relaying element #2
[16:12:26.436] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.436] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.436] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.436]  length: 5 (resolved future 1)
[16:12:26.436] resolved() for ‘SequentialFuture’ ...
[16:12:26.436] - state: ‘finished’
[16:12:26.436] - run: TRUE
[16:12:26.437] - result: ‘FutureResult’
[16:12:26.437] resolved() for ‘SequentialFuture’ ... done
[16:12:26.437] Future #2
[16:12:26.437] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.437] - nx: 6
[16:12:26.437] - relay: TRUE
[16:12:26.437] - stdout: TRUE
[16:12:26.437] - signal: TRUE
[16:12:26.437] - resignal: FALSE
[16:12:26.437] - force: TRUE
[16:12:26.437] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.437] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.438]  - until=2
[16:12:26.438]  - relaying element #2
[16:12:26.438] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.438] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.438] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.438]  length: 4 (resolved future 2)
[16:12:26.438] resolved() for ‘SequentialFuture’ ...
[16:12:26.438] - state: ‘finished’
[16:12:26.438] - run: TRUE
[16:12:26.438] - result: ‘FutureResult’
[16:12:26.439] resolved() for ‘SequentialFuture’ ... done
[16:12:26.439] Future #3
[16:12:26.439] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.439] - nx: 6
[16:12:26.439] - relay: TRUE
[16:12:26.439] - stdout: TRUE
[16:12:26.439] - signal: TRUE
[16:12:26.439] - resignal: FALSE
[16:12:26.439] - force: TRUE
[16:12:26.439] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.440] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.440]  - until=3
[16:12:26.440]  - relaying element #3
[16:12:26.440] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.440] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.440] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.440]  length: 3 (resolved future 3)
[16:12:26.440] signalConditionsASAP(NULL, pos=4) ...
[16:12:26.440] - nx: 6
[16:12:26.440] - relay: TRUE
[16:12:26.441] - stdout: TRUE
[16:12:26.441] - signal: TRUE
[16:12:26.441] - resignal: FALSE
[16:12:26.441] - force: TRUE
[16:12:26.441] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.441] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.441]  - until=5
[16:12:26.441]  - relaying element #5
[16:12:26.441] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.441] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.441] signalConditionsASAP(NULL, pos=4) ... done
[16:12:26.441]  length: 2 (resolved future 4)
[16:12:26.442] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.442] - nx: 6
[16:12:26.442] - relay: TRUE
[16:12:26.442] - stdout: TRUE
[16:12:26.442] - signal: TRUE
[16:12:26.442] - resignal: FALSE
[16:12:26.442] - force: TRUE
[16:12:26.442] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.442] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.442]  - until=6
[16:12:26.442]  - relaying element #6
[16:12:26.444] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.444] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.444] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.444]  length: 1 (resolved future 5)
[16:12:26.444] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.444] - nx: 6
[16:12:26.444] - relay: TRUE
[16:12:26.444] - stdout: TRUE
[16:12:26.444] - signal: TRUE
[16:12:26.444] - resignal: FALSE
[16:12:26.444] - force: TRUE
[16:12:26.445] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.445] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.445]  - until=6
[16:12:26.445] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.445] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.445] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.445]  length: 0 (resolved future 6)
[16:12:26.445] Relaying remaining futures
[16:12:26.445] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.445] - nx: 6
[16:12:26.445] - relay: TRUE
[16:12:26.445] - stdout: TRUE
[16:12:26.446] - signal: TRUE
[16:12:26.446] - resignal: FALSE
[16:12:26.446] - force: TRUE
[16:12:26.446] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.446] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:26.446] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.446] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.446] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.446] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[16:12:26.455] plan(): Setting new future strategy stack:
[16:12:26.455] List of future strategies:
[16:12:26.455] 1. sequential:
[16:12:26.455]    - args: function (..., envir = parent.frame())
[16:12:26.455]    - tweaked: FALSE
[16:12:26.455]    - call: plan(strategy)
[16:12:26.456] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:12:26.456] getGlobalsAndPackages() ...
[16:12:26.456] Searching for globals...
[16:12:26.456] 
[16:12:26.456] Searching for globals ... DONE
[16:12:26.457] - globals: [0] <none>
[16:12:26.457] getGlobalsAndPackages() ... DONE
[16:12:26.457] run() for ‘Future’ ...
[16:12:26.457] - state: ‘created’
[16:12:26.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.457]   - Field: ‘label’
[16:12:26.458]   - Field: ‘local’
[16:12:26.458]   - Field: ‘owner’
[16:12:26.458]   - Field: ‘envir’
[16:12:26.458]   - Field: ‘packages’
[16:12:26.458]   - Field: ‘gc’
[16:12:26.458]   - Field: ‘conditions’
[16:12:26.458]   - Field: ‘expr’
[16:12:26.458]   - Field: ‘uuid’
[16:12:26.458]   - Field: ‘seed’
[16:12:26.458]   - Field: ‘version’
[16:12:26.458]   - Field: ‘result’
[16:12:26.459]   - Field: ‘asynchronous’
[16:12:26.459]   - Field: ‘calls’
[16:12:26.459]   - Field: ‘globals’
[16:12:26.459]   - Field: ‘stdout’
[16:12:26.459]   - Field: ‘earlySignal’
[16:12:26.459]   - Field: ‘lazy’
[16:12:26.459]   - Field: ‘state’
[16:12:26.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.459] - Launch lazy future ...
[16:12:26.459] Packages needed by the future expression (n = 0): <none>
[16:12:26.460] Packages needed by future strategies (n = 0): <none>
[16:12:26.460] {
[16:12:26.460]     {
[16:12:26.460]         {
[16:12:26.460]             ...future.startTime <- base::Sys.time()
[16:12:26.460]             {
[16:12:26.460]                 {
[16:12:26.460]                   {
[16:12:26.460]                     base::local({
[16:12:26.460]                       has_future <- base::requireNamespace("future", 
[16:12:26.460]                         quietly = TRUE)
[16:12:26.460]                       if (has_future) {
[16:12:26.460]                         ns <- base::getNamespace("future")
[16:12:26.460]                         version <- ns[[".package"]][["version"]]
[16:12:26.460]                         if (is.null(version)) 
[16:12:26.460]                           version <- utils::packageVersion("future")
[16:12:26.460]                       }
[16:12:26.460]                       else {
[16:12:26.460]                         version <- NULL
[16:12:26.460]                       }
[16:12:26.460]                       if (!has_future || version < "1.8.0") {
[16:12:26.460]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.460]                           "", base::R.version$version.string), 
[16:12:26.460]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.460]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.460]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.460]                             "release", "version")], collapse = " "), 
[16:12:26.460]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.460]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.460]                           info)
[16:12:26.460]                         info <- base::paste(info, collapse = "; ")
[16:12:26.460]                         if (!has_future) {
[16:12:26.460]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.460]                             info)
[16:12:26.460]                         }
[16:12:26.460]                         else {
[16:12:26.460]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.460]                             info, version)
[16:12:26.460]                         }
[16:12:26.460]                         base::stop(msg)
[16:12:26.460]                       }
[16:12:26.460]                     })
[16:12:26.460]                   }
[16:12:26.460]                   options(future.plan = NULL)
[16:12:26.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.460]                 }
[16:12:26.460]                 ...future.workdir <- getwd()
[16:12:26.460]             }
[16:12:26.460]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.460]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.460]         }
[16:12:26.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.460]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.460]             base::names(...future.oldOptions))
[16:12:26.460]     }
[16:12:26.460]     if (FALSE) {
[16:12:26.460]     }
[16:12:26.460]     else {
[16:12:26.460]         if (TRUE) {
[16:12:26.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.460]                 open = "w")
[16:12:26.460]         }
[16:12:26.460]         else {
[16:12:26.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.460]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.460]         }
[16:12:26.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.460]             base::sink(type = "output", split = FALSE)
[16:12:26.460]             base::close(...future.stdout)
[16:12:26.460]         }, add = TRUE)
[16:12:26.460]     }
[16:12:26.460]     ...future.frame <- base::sys.nframe()
[16:12:26.460]     ...future.conditions <- base::list()
[16:12:26.460]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.460]     if (FALSE) {
[16:12:26.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.460]     }
[16:12:26.460]     ...future.result <- base::tryCatch({
[16:12:26.460]         base::withCallingHandlers({
[16:12:26.460]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.460]             future::FutureResult(value = ...future.value$value, 
[16:12:26.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.460]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.460]                     ...future.globalenv.names))
[16:12:26.460]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.460]         }, condition = base::local({
[16:12:26.460]             c <- base::c
[16:12:26.460]             inherits <- base::inherits
[16:12:26.460]             invokeRestart <- base::invokeRestart
[16:12:26.460]             length <- base::length
[16:12:26.460]             list <- base::list
[16:12:26.460]             seq.int <- base::seq.int
[16:12:26.460]             signalCondition <- base::signalCondition
[16:12:26.460]             sys.calls <- base::sys.calls
[16:12:26.460]             `[[` <- base::`[[`
[16:12:26.460]             `+` <- base::`+`
[16:12:26.460]             `<<-` <- base::`<<-`
[16:12:26.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.460]                   3L)]
[16:12:26.460]             }
[16:12:26.460]             function(cond) {
[16:12:26.460]                 is_error <- inherits(cond, "error")
[16:12:26.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.460]                   NULL)
[16:12:26.460]                 if (is_error) {
[16:12:26.460]                   sessionInformation <- function() {
[16:12:26.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.460]                       search = base::search(), system = base::Sys.info())
[16:12:26.460]                   }
[16:12:26.460]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.460]                     cond$call), session = sessionInformation(), 
[16:12:26.460]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.460]                   signalCondition(cond)
[16:12:26.460]                 }
[16:12:26.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.460]                 "immediateCondition"))) {
[16:12:26.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.460]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.460]                   if (TRUE && !signal) {
[16:12:26.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.460]                     {
[16:12:26.460]                       inherits <- base::inherits
[16:12:26.460]                       invokeRestart <- base::invokeRestart
[16:12:26.460]                       is.null <- base::is.null
[16:12:26.460]                       muffled <- FALSE
[16:12:26.460]                       if (inherits(cond, "message")) {
[16:12:26.460]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.460]                         if (muffled) 
[16:12:26.460]                           invokeRestart("muffleMessage")
[16:12:26.460]                       }
[16:12:26.460]                       else if (inherits(cond, "warning")) {
[16:12:26.460]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.460]                         if (muffled) 
[16:12:26.460]                           invokeRestart("muffleWarning")
[16:12:26.460]                       }
[16:12:26.460]                       else if (inherits(cond, "condition")) {
[16:12:26.460]                         if (!is.null(pattern)) {
[16:12:26.460]                           computeRestarts <- base::computeRestarts
[16:12:26.460]                           grepl <- base::grepl
[16:12:26.460]                           restarts <- computeRestarts(cond)
[16:12:26.460]                           for (restart in restarts) {
[16:12:26.460]                             name <- restart$name
[16:12:26.460]                             if (is.null(name)) 
[16:12:26.460]                               next
[16:12:26.460]                             if (!grepl(pattern, name)) 
[16:12:26.460]                               next
[16:12:26.460]                             invokeRestart(restart)
[16:12:26.460]                             muffled <- TRUE
[16:12:26.460]                             break
[16:12:26.460]                           }
[16:12:26.460]                         }
[16:12:26.460]                       }
[16:12:26.460]                       invisible(muffled)
[16:12:26.460]                     }
[16:12:26.460]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.460]                   }
[16:12:26.460]                 }
[16:12:26.460]                 else {
[16:12:26.460]                   if (TRUE) {
[16:12:26.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.460]                     {
[16:12:26.460]                       inherits <- base::inherits
[16:12:26.460]                       invokeRestart <- base::invokeRestart
[16:12:26.460]                       is.null <- base::is.null
[16:12:26.460]                       muffled <- FALSE
[16:12:26.460]                       if (inherits(cond, "message")) {
[16:12:26.460]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.460]                         if (muffled) 
[16:12:26.460]                           invokeRestart("muffleMessage")
[16:12:26.460]                       }
[16:12:26.460]                       else if (inherits(cond, "warning")) {
[16:12:26.460]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.460]                         if (muffled) 
[16:12:26.460]                           invokeRestart("muffleWarning")
[16:12:26.460]                       }
[16:12:26.460]                       else if (inherits(cond, "condition")) {
[16:12:26.460]                         if (!is.null(pattern)) {
[16:12:26.460]                           computeRestarts <- base::computeRestarts
[16:12:26.460]                           grepl <- base::grepl
[16:12:26.460]                           restarts <- computeRestarts(cond)
[16:12:26.460]                           for (restart in restarts) {
[16:12:26.460]                             name <- restart$name
[16:12:26.460]                             if (is.null(name)) 
[16:12:26.460]                               next
[16:12:26.460]                             if (!grepl(pattern, name)) 
[16:12:26.460]                               next
[16:12:26.460]                             invokeRestart(restart)
[16:12:26.460]                             muffled <- TRUE
[16:12:26.460]                             break
[16:12:26.460]                           }
[16:12:26.460]                         }
[16:12:26.460]                       }
[16:12:26.460]                       invisible(muffled)
[16:12:26.460]                     }
[16:12:26.460]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.460]                   }
[16:12:26.460]                 }
[16:12:26.460]             }
[16:12:26.460]         }))
[16:12:26.460]     }, error = function(ex) {
[16:12:26.460]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.460]                 ...future.rng), started = ...future.startTime, 
[16:12:26.460]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.460]             version = "1.8"), class = "FutureResult")
[16:12:26.460]     }, finally = {
[16:12:26.460]         if (!identical(...future.workdir, getwd())) 
[16:12:26.460]             setwd(...future.workdir)
[16:12:26.460]         {
[16:12:26.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.460]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.460]             }
[16:12:26.460]             base::options(...future.oldOptions)
[16:12:26.460]             if (.Platform$OS.type == "windows") {
[16:12:26.460]                 old_names <- names(...future.oldEnvVars)
[16:12:26.460]                 envs <- base::Sys.getenv()
[16:12:26.460]                 names <- names(envs)
[16:12:26.460]                 common <- intersect(names, old_names)
[16:12:26.460]                 added <- setdiff(names, old_names)
[16:12:26.460]                 removed <- setdiff(old_names, names)
[16:12:26.460]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.460]                   envs[common]]
[16:12:26.460]                 NAMES <- toupper(changed)
[16:12:26.460]                 args <- list()
[16:12:26.460]                 for (kk in seq_along(NAMES)) {
[16:12:26.460]                   name <- changed[[kk]]
[16:12:26.460]                   NAME <- NAMES[[kk]]
[16:12:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.460]                     next
[16:12:26.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.460]                 }
[16:12:26.460]                 NAMES <- toupper(added)
[16:12:26.460]                 for (kk in seq_along(NAMES)) {
[16:12:26.460]                   name <- added[[kk]]
[16:12:26.460]                   NAME <- NAMES[[kk]]
[16:12:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.460]                     next
[16:12:26.460]                   args[[name]] <- ""
[16:12:26.460]                 }
[16:12:26.460]                 NAMES <- toupper(removed)
[16:12:26.460]                 for (kk in seq_along(NAMES)) {
[16:12:26.460]                   name <- removed[[kk]]
[16:12:26.460]                   NAME <- NAMES[[kk]]
[16:12:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.460]                     next
[16:12:26.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.460]                 }
[16:12:26.460]                 if (length(args) > 0) 
[16:12:26.460]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.460]             }
[16:12:26.460]             else {
[16:12:26.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.460]             }
[16:12:26.460]             {
[16:12:26.460]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.460]                   0L) {
[16:12:26.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.460]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.460]                   base::options(opts)
[16:12:26.460]                 }
[16:12:26.460]                 {
[16:12:26.460]                   {
[16:12:26.460]                     NULL
[16:12:26.460]                     RNGkind("Mersenne-Twister")
[16:12:26.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.460]                       inherits = FALSE)
[16:12:26.460]                   }
[16:12:26.460]                   options(future.plan = NULL)
[16:12:26.460]                   if (is.na(NA_character_)) 
[16:12:26.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.460]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.460]                   {
[16:12:26.460]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.460]                     if (!future$lazy) 
[16:12:26.460]                       future <- run(future)
[16:12:26.460]                     invisible(future)
[16:12:26.460]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.460]                 }
[16:12:26.460]             }
[16:12:26.460]         }
[16:12:26.460]     })
[16:12:26.460]     if (TRUE) {
[16:12:26.460]         base::sink(type = "output", split = FALSE)
[16:12:26.460]         if (TRUE) {
[16:12:26.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.460]         }
[16:12:26.460]         else {
[16:12:26.460]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.460]         }
[16:12:26.460]         base::close(...future.stdout)
[16:12:26.460]         ...future.stdout <- NULL
[16:12:26.460]     }
[16:12:26.460]     ...future.result$conditions <- ...future.conditions
[16:12:26.460]     ...future.result$finished <- base::Sys.time()
[16:12:26.460]     ...future.result
[16:12:26.460] }
[16:12:26.462] plan(): Setting new future strategy stack:
[16:12:26.462] List of future strategies:
[16:12:26.462] 1. sequential:
[16:12:26.462]    - args: function (..., envir = parent.frame())
[16:12:26.462]    - tweaked: FALSE
[16:12:26.462]    - call: NULL
[16:12:26.462] plan(): nbrOfWorkers() = 1
[16:12:26.463] plan(): Setting new future strategy stack:
[16:12:26.463] List of future strategies:
[16:12:26.463] 1. sequential:
[16:12:26.463]    - args: function (..., envir = parent.frame())
[16:12:26.463]    - tweaked: FALSE
[16:12:26.463]    - call: plan(strategy)
[16:12:26.463] plan(): nbrOfWorkers() = 1
[16:12:26.463] SequentialFuture started (and completed)
[16:12:26.463] - Launch lazy future ... done
[16:12:26.464] run() for ‘SequentialFuture’ ... done
[16:12:26.464] getGlobalsAndPackages() ...
[16:12:26.464] Searching for globals...
[16:12:26.464] 
[16:12:26.464] Searching for globals ... DONE
[16:12:26.464] - globals: [0] <none>
[16:12:26.464] getGlobalsAndPackages() ... DONE
[16:12:26.465] run() for ‘Future’ ...
[16:12:26.465] - state: ‘created’
[16:12:26.465] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.465]   - Field: ‘label’
[16:12:26.465]   - Field: ‘local’
[16:12:26.465]   - Field: ‘owner’
[16:12:26.465]   - Field: ‘envir’
[16:12:26.466]   - Field: ‘packages’
[16:12:26.466]   - Field: ‘gc’
[16:12:26.466]   - Field: ‘conditions’
[16:12:26.466]   - Field: ‘expr’
[16:12:26.466]   - Field: ‘uuid’
[16:12:26.466]   - Field: ‘seed’
[16:12:26.466]   - Field: ‘version’
[16:12:26.466]   - Field: ‘result’
[16:12:26.466]   - Field: ‘asynchronous’
[16:12:26.466]   - Field: ‘calls’
[16:12:26.466]   - Field: ‘globals’
[16:12:26.466]   - Field: ‘stdout’
[16:12:26.467]   - Field: ‘earlySignal’
[16:12:26.467]   - Field: ‘lazy’
[16:12:26.467]   - Field: ‘state’
[16:12:26.468] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.468] - Launch lazy future ...
[16:12:26.468] Packages needed by the future expression (n = 0): <none>
[16:12:26.468] Packages needed by future strategies (n = 0): <none>
[16:12:26.469] {
[16:12:26.469]     {
[16:12:26.469]         {
[16:12:26.469]             ...future.startTime <- base::Sys.time()
[16:12:26.469]             {
[16:12:26.469]                 {
[16:12:26.469]                   {
[16:12:26.469]                     base::local({
[16:12:26.469]                       has_future <- base::requireNamespace("future", 
[16:12:26.469]                         quietly = TRUE)
[16:12:26.469]                       if (has_future) {
[16:12:26.469]                         ns <- base::getNamespace("future")
[16:12:26.469]                         version <- ns[[".package"]][["version"]]
[16:12:26.469]                         if (is.null(version)) 
[16:12:26.469]                           version <- utils::packageVersion("future")
[16:12:26.469]                       }
[16:12:26.469]                       else {
[16:12:26.469]                         version <- NULL
[16:12:26.469]                       }
[16:12:26.469]                       if (!has_future || version < "1.8.0") {
[16:12:26.469]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.469]                           "", base::R.version$version.string), 
[16:12:26.469]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.469]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.469]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.469]                             "release", "version")], collapse = " "), 
[16:12:26.469]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.469]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.469]                           info)
[16:12:26.469]                         info <- base::paste(info, collapse = "; ")
[16:12:26.469]                         if (!has_future) {
[16:12:26.469]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.469]                             info)
[16:12:26.469]                         }
[16:12:26.469]                         else {
[16:12:26.469]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.469]                             info, version)
[16:12:26.469]                         }
[16:12:26.469]                         base::stop(msg)
[16:12:26.469]                       }
[16:12:26.469]                     })
[16:12:26.469]                   }
[16:12:26.469]                   options(future.plan = NULL)
[16:12:26.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.469]                 }
[16:12:26.469]                 ...future.workdir <- getwd()
[16:12:26.469]             }
[16:12:26.469]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.469]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.469]         }
[16:12:26.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.469]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.469]             base::names(...future.oldOptions))
[16:12:26.469]     }
[16:12:26.469]     if (FALSE) {
[16:12:26.469]     }
[16:12:26.469]     else {
[16:12:26.469]         if (TRUE) {
[16:12:26.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.469]                 open = "w")
[16:12:26.469]         }
[16:12:26.469]         else {
[16:12:26.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.469]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.469]         }
[16:12:26.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.469]             base::sink(type = "output", split = FALSE)
[16:12:26.469]             base::close(...future.stdout)
[16:12:26.469]         }, add = TRUE)
[16:12:26.469]     }
[16:12:26.469]     ...future.frame <- base::sys.nframe()
[16:12:26.469]     ...future.conditions <- base::list()
[16:12:26.469]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.469]     if (FALSE) {
[16:12:26.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.469]     }
[16:12:26.469]     ...future.result <- base::tryCatch({
[16:12:26.469]         base::withCallingHandlers({
[16:12:26.469]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.469]             future::FutureResult(value = ...future.value$value, 
[16:12:26.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.469]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.469]                     ...future.globalenv.names))
[16:12:26.469]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.469]         }, condition = base::local({
[16:12:26.469]             c <- base::c
[16:12:26.469]             inherits <- base::inherits
[16:12:26.469]             invokeRestart <- base::invokeRestart
[16:12:26.469]             length <- base::length
[16:12:26.469]             list <- base::list
[16:12:26.469]             seq.int <- base::seq.int
[16:12:26.469]             signalCondition <- base::signalCondition
[16:12:26.469]             sys.calls <- base::sys.calls
[16:12:26.469]             `[[` <- base::`[[`
[16:12:26.469]             `+` <- base::`+`
[16:12:26.469]             `<<-` <- base::`<<-`
[16:12:26.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.469]                   3L)]
[16:12:26.469]             }
[16:12:26.469]             function(cond) {
[16:12:26.469]                 is_error <- inherits(cond, "error")
[16:12:26.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.469]                   NULL)
[16:12:26.469]                 if (is_error) {
[16:12:26.469]                   sessionInformation <- function() {
[16:12:26.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.469]                       search = base::search(), system = base::Sys.info())
[16:12:26.469]                   }
[16:12:26.469]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.469]                     cond$call), session = sessionInformation(), 
[16:12:26.469]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.469]                   signalCondition(cond)
[16:12:26.469]                 }
[16:12:26.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.469]                 "immediateCondition"))) {
[16:12:26.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.469]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.469]                   if (TRUE && !signal) {
[16:12:26.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.469]                     {
[16:12:26.469]                       inherits <- base::inherits
[16:12:26.469]                       invokeRestart <- base::invokeRestart
[16:12:26.469]                       is.null <- base::is.null
[16:12:26.469]                       muffled <- FALSE
[16:12:26.469]                       if (inherits(cond, "message")) {
[16:12:26.469]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.469]                         if (muffled) 
[16:12:26.469]                           invokeRestart("muffleMessage")
[16:12:26.469]                       }
[16:12:26.469]                       else if (inherits(cond, "warning")) {
[16:12:26.469]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.469]                         if (muffled) 
[16:12:26.469]                           invokeRestart("muffleWarning")
[16:12:26.469]                       }
[16:12:26.469]                       else if (inherits(cond, "condition")) {
[16:12:26.469]                         if (!is.null(pattern)) {
[16:12:26.469]                           computeRestarts <- base::computeRestarts
[16:12:26.469]                           grepl <- base::grepl
[16:12:26.469]                           restarts <- computeRestarts(cond)
[16:12:26.469]                           for (restart in restarts) {
[16:12:26.469]                             name <- restart$name
[16:12:26.469]                             if (is.null(name)) 
[16:12:26.469]                               next
[16:12:26.469]                             if (!grepl(pattern, name)) 
[16:12:26.469]                               next
[16:12:26.469]                             invokeRestart(restart)
[16:12:26.469]                             muffled <- TRUE
[16:12:26.469]                             break
[16:12:26.469]                           }
[16:12:26.469]                         }
[16:12:26.469]                       }
[16:12:26.469]                       invisible(muffled)
[16:12:26.469]                     }
[16:12:26.469]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.469]                   }
[16:12:26.469]                 }
[16:12:26.469]                 else {
[16:12:26.469]                   if (TRUE) {
[16:12:26.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.469]                     {
[16:12:26.469]                       inherits <- base::inherits
[16:12:26.469]                       invokeRestart <- base::invokeRestart
[16:12:26.469]                       is.null <- base::is.null
[16:12:26.469]                       muffled <- FALSE
[16:12:26.469]                       if (inherits(cond, "message")) {
[16:12:26.469]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.469]                         if (muffled) 
[16:12:26.469]                           invokeRestart("muffleMessage")
[16:12:26.469]                       }
[16:12:26.469]                       else if (inherits(cond, "warning")) {
[16:12:26.469]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.469]                         if (muffled) 
[16:12:26.469]                           invokeRestart("muffleWarning")
[16:12:26.469]                       }
[16:12:26.469]                       else if (inherits(cond, "condition")) {
[16:12:26.469]                         if (!is.null(pattern)) {
[16:12:26.469]                           computeRestarts <- base::computeRestarts
[16:12:26.469]                           grepl <- base::grepl
[16:12:26.469]                           restarts <- computeRestarts(cond)
[16:12:26.469]                           for (restart in restarts) {
[16:12:26.469]                             name <- restart$name
[16:12:26.469]                             if (is.null(name)) 
[16:12:26.469]                               next
[16:12:26.469]                             if (!grepl(pattern, name)) 
[16:12:26.469]                               next
[16:12:26.469]                             invokeRestart(restart)
[16:12:26.469]                             muffled <- TRUE
[16:12:26.469]                             break
[16:12:26.469]                           }
[16:12:26.469]                         }
[16:12:26.469]                       }
[16:12:26.469]                       invisible(muffled)
[16:12:26.469]                     }
[16:12:26.469]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.469]                   }
[16:12:26.469]                 }
[16:12:26.469]             }
[16:12:26.469]         }))
[16:12:26.469]     }, error = function(ex) {
[16:12:26.469]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.469]                 ...future.rng), started = ...future.startTime, 
[16:12:26.469]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.469]             version = "1.8"), class = "FutureResult")
[16:12:26.469]     }, finally = {
[16:12:26.469]         if (!identical(...future.workdir, getwd())) 
[16:12:26.469]             setwd(...future.workdir)
[16:12:26.469]         {
[16:12:26.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.469]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.469]             }
[16:12:26.469]             base::options(...future.oldOptions)
[16:12:26.469]             if (.Platform$OS.type == "windows") {
[16:12:26.469]                 old_names <- names(...future.oldEnvVars)
[16:12:26.469]                 envs <- base::Sys.getenv()
[16:12:26.469]                 names <- names(envs)
[16:12:26.469]                 common <- intersect(names, old_names)
[16:12:26.469]                 added <- setdiff(names, old_names)
[16:12:26.469]                 removed <- setdiff(old_names, names)
[16:12:26.469]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.469]                   envs[common]]
[16:12:26.469]                 NAMES <- toupper(changed)
[16:12:26.469]                 args <- list()
[16:12:26.469]                 for (kk in seq_along(NAMES)) {
[16:12:26.469]                   name <- changed[[kk]]
[16:12:26.469]                   NAME <- NAMES[[kk]]
[16:12:26.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.469]                     next
[16:12:26.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.469]                 }
[16:12:26.469]                 NAMES <- toupper(added)
[16:12:26.469]                 for (kk in seq_along(NAMES)) {
[16:12:26.469]                   name <- added[[kk]]
[16:12:26.469]                   NAME <- NAMES[[kk]]
[16:12:26.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.469]                     next
[16:12:26.469]                   args[[name]] <- ""
[16:12:26.469]                 }
[16:12:26.469]                 NAMES <- toupper(removed)
[16:12:26.469]                 for (kk in seq_along(NAMES)) {
[16:12:26.469]                   name <- removed[[kk]]
[16:12:26.469]                   NAME <- NAMES[[kk]]
[16:12:26.469]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.469]                     next
[16:12:26.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.469]                 }
[16:12:26.469]                 if (length(args) > 0) 
[16:12:26.469]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.469]             }
[16:12:26.469]             else {
[16:12:26.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.469]             }
[16:12:26.469]             {
[16:12:26.469]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.469]                   0L) {
[16:12:26.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.469]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.469]                   base::options(opts)
[16:12:26.469]                 }
[16:12:26.469]                 {
[16:12:26.469]                   {
[16:12:26.469]                     NULL
[16:12:26.469]                     RNGkind("Mersenne-Twister")
[16:12:26.469]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.469]                       inherits = FALSE)
[16:12:26.469]                   }
[16:12:26.469]                   options(future.plan = NULL)
[16:12:26.469]                   if (is.na(NA_character_)) 
[16:12:26.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.469]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.469]                   {
[16:12:26.469]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.469]                     if (!future$lazy) 
[16:12:26.469]                       future <- run(future)
[16:12:26.469]                     invisible(future)
[16:12:26.469]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.469]                 }
[16:12:26.469]             }
[16:12:26.469]         }
[16:12:26.469]     })
[16:12:26.469]     if (TRUE) {
[16:12:26.469]         base::sink(type = "output", split = FALSE)
[16:12:26.469]         if (TRUE) {
[16:12:26.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.469]         }
[16:12:26.469]         else {
[16:12:26.469]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.469]         }
[16:12:26.469]         base::close(...future.stdout)
[16:12:26.469]         ...future.stdout <- NULL
[16:12:26.469]     }
[16:12:26.469]     ...future.result$conditions <- ...future.conditions
[16:12:26.469]     ...future.result$finished <- base::Sys.time()
[16:12:26.469]     ...future.result
[16:12:26.469] }
[16:12:26.470] plan(): Setting new future strategy stack:
[16:12:26.471] List of future strategies:
[16:12:26.471] 1. sequential:
[16:12:26.471]    - args: function (..., envir = parent.frame())
[16:12:26.471]    - tweaked: FALSE
[16:12:26.471]    - call: NULL
[16:12:26.471] plan(): nbrOfWorkers() = 1
[16:12:26.472] plan(): Setting new future strategy stack:
[16:12:26.472] List of future strategies:
[16:12:26.472] 1. sequential:
[16:12:26.472]    - args: function (..., envir = parent.frame())
[16:12:26.472]    - tweaked: FALSE
[16:12:26.472]    - call: plan(strategy)
[16:12:26.472] plan(): nbrOfWorkers() = 1
[16:12:26.472] SequentialFuture started (and completed)
[16:12:26.472] - Launch lazy future ... done
[16:12:26.472] run() for ‘SequentialFuture’ ... done
[16:12:26.474] getGlobalsAndPackages() ...
[16:12:26.474] Searching for globals...
[16:12:26.475] - globals found: [1] ‘{’
[16:12:26.475] Searching for globals ... DONE
[16:12:26.475] Resolving globals: FALSE
[16:12:26.476] 
[16:12:26.476] 
[16:12:26.476] getGlobalsAndPackages() ... DONE
[16:12:26.476] run() for ‘Future’ ...
[16:12:26.476] - state: ‘created’
[16:12:26.476] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.476] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.477] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.477]   - Field: ‘label’
[16:12:26.477]   - Field: ‘local’
[16:12:26.477]   - Field: ‘owner’
[16:12:26.477]   - Field: ‘envir’
[16:12:26.477]   - Field: ‘packages’
[16:12:26.477]   - Field: ‘gc’
[16:12:26.477]   - Field: ‘conditions’
[16:12:26.477]   - Field: ‘expr’
[16:12:26.477]   - Field: ‘uuid’
[16:12:26.477]   - Field: ‘seed’
[16:12:26.478]   - Field: ‘version’
[16:12:26.478]   - Field: ‘result’
[16:12:26.478]   - Field: ‘asynchronous’
[16:12:26.478]   - Field: ‘calls’
[16:12:26.478]   - Field: ‘globals’
[16:12:26.478]   - Field: ‘stdout’
[16:12:26.478]   - Field: ‘earlySignal’
[16:12:26.478]   - Field: ‘lazy’
[16:12:26.478]   - Field: ‘state’
[16:12:26.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.478] - Launch lazy future ...
[16:12:26.479] Packages needed by the future expression (n = 0): <none>
[16:12:26.479] Packages needed by future strategies (n = 0): <none>
[16:12:26.479] {
[16:12:26.479]     {
[16:12:26.479]         {
[16:12:26.479]             ...future.startTime <- base::Sys.time()
[16:12:26.479]             {
[16:12:26.479]                 {
[16:12:26.479]                   {
[16:12:26.479]                     base::local({
[16:12:26.479]                       has_future <- base::requireNamespace("future", 
[16:12:26.479]                         quietly = TRUE)
[16:12:26.479]                       if (has_future) {
[16:12:26.479]                         ns <- base::getNamespace("future")
[16:12:26.479]                         version <- ns[[".package"]][["version"]]
[16:12:26.479]                         if (is.null(version)) 
[16:12:26.479]                           version <- utils::packageVersion("future")
[16:12:26.479]                       }
[16:12:26.479]                       else {
[16:12:26.479]                         version <- NULL
[16:12:26.479]                       }
[16:12:26.479]                       if (!has_future || version < "1.8.0") {
[16:12:26.479]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.479]                           "", base::R.version$version.string), 
[16:12:26.479]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.479]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.479]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.479]                             "release", "version")], collapse = " "), 
[16:12:26.479]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.479]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.479]                           info)
[16:12:26.479]                         info <- base::paste(info, collapse = "; ")
[16:12:26.479]                         if (!has_future) {
[16:12:26.479]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.479]                             info)
[16:12:26.479]                         }
[16:12:26.479]                         else {
[16:12:26.479]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.479]                             info, version)
[16:12:26.479]                         }
[16:12:26.479]                         base::stop(msg)
[16:12:26.479]                       }
[16:12:26.479]                     })
[16:12:26.479]                   }
[16:12:26.479]                   options(future.plan = NULL)
[16:12:26.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.479]                 }
[16:12:26.479]                 ...future.workdir <- getwd()
[16:12:26.479]             }
[16:12:26.479]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.479]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.479]         }
[16:12:26.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.479]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.479]             base::names(...future.oldOptions))
[16:12:26.479]     }
[16:12:26.479]     if (FALSE) {
[16:12:26.479]     }
[16:12:26.479]     else {
[16:12:26.479]         if (TRUE) {
[16:12:26.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.479]                 open = "w")
[16:12:26.479]         }
[16:12:26.479]         else {
[16:12:26.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.479]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.479]         }
[16:12:26.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.479]             base::sink(type = "output", split = FALSE)
[16:12:26.479]             base::close(...future.stdout)
[16:12:26.479]         }, add = TRUE)
[16:12:26.479]     }
[16:12:26.479]     ...future.frame <- base::sys.nframe()
[16:12:26.479]     ...future.conditions <- base::list()
[16:12:26.479]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.479]     if (FALSE) {
[16:12:26.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.479]     }
[16:12:26.479]     ...future.result <- base::tryCatch({
[16:12:26.479]         base::withCallingHandlers({
[16:12:26.479]             ...future.value <- base::withVisible(base::local({
[16:12:26.479]                 4
[16:12:26.479]             }))
[16:12:26.479]             future::FutureResult(value = ...future.value$value, 
[16:12:26.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.479]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.479]                     ...future.globalenv.names))
[16:12:26.479]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.479]         }, condition = base::local({
[16:12:26.479]             c <- base::c
[16:12:26.479]             inherits <- base::inherits
[16:12:26.479]             invokeRestart <- base::invokeRestart
[16:12:26.479]             length <- base::length
[16:12:26.479]             list <- base::list
[16:12:26.479]             seq.int <- base::seq.int
[16:12:26.479]             signalCondition <- base::signalCondition
[16:12:26.479]             sys.calls <- base::sys.calls
[16:12:26.479]             `[[` <- base::`[[`
[16:12:26.479]             `+` <- base::`+`
[16:12:26.479]             `<<-` <- base::`<<-`
[16:12:26.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.479]                   3L)]
[16:12:26.479]             }
[16:12:26.479]             function(cond) {
[16:12:26.479]                 is_error <- inherits(cond, "error")
[16:12:26.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.479]                   NULL)
[16:12:26.479]                 if (is_error) {
[16:12:26.479]                   sessionInformation <- function() {
[16:12:26.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.479]                       search = base::search(), system = base::Sys.info())
[16:12:26.479]                   }
[16:12:26.479]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.479]                     cond$call), session = sessionInformation(), 
[16:12:26.479]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.479]                   signalCondition(cond)
[16:12:26.479]                 }
[16:12:26.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.479]                 "immediateCondition"))) {
[16:12:26.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.479]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.479]                   if (TRUE && !signal) {
[16:12:26.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.479]                     {
[16:12:26.479]                       inherits <- base::inherits
[16:12:26.479]                       invokeRestart <- base::invokeRestart
[16:12:26.479]                       is.null <- base::is.null
[16:12:26.479]                       muffled <- FALSE
[16:12:26.479]                       if (inherits(cond, "message")) {
[16:12:26.479]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.479]                         if (muffled) 
[16:12:26.479]                           invokeRestart("muffleMessage")
[16:12:26.479]                       }
[16:12:26.479]                       else if (inherits(cond, "warning")) {
[16:12:26.479]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.479]                         if (muffled) 
[16:12:26.479]                           invokeRestart("muffleWarning")
[16:12:26.479]                       }
[16:12:26.479]                       else if (inherits(cond, "condition")) {
[16:12:26.479]                         if (!is.null(pattern)) {
[16:12:26.479]                           computeRestarts <- base::computeRestarts
[16:12:26.479]                           grepl <- base::grepl
[16:12:26.479]                           restarts <- computeRestarts(cond)
[16:12:26.479]                           for (restart in restarts) {
[16:12:26.479]                             name <- restart$name
[16:12:26.479]                             if (is.null(name)) 
[16:12:26.479]                               next
[16:12:26.479]                             if (!grepl(pattern, name)) 
[16:12:26.479]                               next
[16:12:26.479]                             invokeRestart(restart)
[16:12:26.479]                             muffled <- TRUE
[16:12:26.479]                             break
[16:12:26.479]                           }
[16:12:26.479]                         }
[16:12:26.479]                       }
[16:12:26.479]                       invisible(muffled)
[16:12:26.479]                     }
[16:12:26.479]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.479]                   }
[16:12:26.479]                 }
[16:12:26.479]                 else {
[16:12:26.479]                   if (TRUE) {
[16:12:26.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.479]                     {
[16:12:26.479]                       inherits <- base::inherits
[16:12:26.479]                       invokeRestart <- base::invokeRestart
[16:12:26.479]                       is.null <- base::is.null
[16:12:26.479]                       muffled <- FALSE
[16:12:26.479]                       if (inherits(cond, "message")) {
[16:12:26.479]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.479]                         if (muffled) 
[16:12:26.479]                           invokeRestart("muffleMessage")
[16:12:26.479]                       }
[16:12:26.479]                       else if (inherits(cond, "warning")) {
[16:12:26.479]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.479]                         if (muffled) 
[16:12:26.479]                           invokeRestart("muffleWarning")
[16:12:26.479]                       }
[16:12:26.479]                       else if (inherits(cond, "condition")) {
[16:12:26.479]                         if (!is.null(pattern)) {
[16:12:26.479]                           computeRestarts <- base::computeRestarts
[16:12:26.479]                           grepl <- base::grepl
[16:12:26.479]                           restarts <- computeRestarts(cond)
[16:12:26.479]                           for (restart in restarts) {
[16:12:26.479]                             name <- restart$name
[16:12:26.479]                             if (is.null(name)) 
[16:12:26.479]                               next
[16:12:26.479]                             if (!grepl(pattern, name)) 
[16:12:26.479]                               next
[16:12:26.479]                             invokeRestart(restart)
[16:12:26.479]                             muffled <- TRUE
[16:12:26.479]                             break
[16:12:26.479]                           }
[16:12:26.479]                         }
[16:12:26.479]                       }
[16:12:26.479]                       invisible(muffled)
[16:12:26.479]                     }
[16:12:26.479]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.479]                   }
[16:12:26.479]                 }
[16:12:26.479]             }
[16:12:26.479]         }))
[16:12:26.479]     }, error = function(ex) {
[16:12:26.479]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.479]                 ...future.rng), started = ...future.startTime, 
[16:12:26.479]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.479]             version = "1.8"), class = "FutureResult")
[16:12:26.479]     }, finally = {
[16:12:26.479]         if (!identical(...future.workdir, getwd())) 
[16:12:26.479]             setwd(...future.workdir)
[16:12:26.479]         {
[16:12:26.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.479]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.479]             }
[16:12:26.479]             base::options(...future.oldOptions)
[16:12:26.479]             if (.Platform$OS.type == "windows") {
[16:12:26.479]                 old_names <- names(...future.oldEnvVars)
[16:12:26.479]                 envs <- base::Sys.getenv()
[16:12:26.479]                 names <- names(envs)
[16:12:26.479]                 common <- intersect(names, old_names)
[16:12:26.479]                 added <- setdiff(names, old_names)
[16:12:26.479]                 removed <- setdiff(old_names, names)
[16:12:26.479]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.479]                   envs[common]]
[16:12:26.479]                 NAMES <- toupper(changed)
[16:12:26.479]                 args <- list()
[16:12:26.479]                 for (kk in seq_along(NAMES)) {
[16:12:26.479]                   name <- changed[[kk]]
[16:12:26.479]                   NAME <- NAMES[[kk]]
[16:12:26.479]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.479]                     next
[16:12:26.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.479]                 }
[16:12:26.479]                 NAMES <- toupper(added)
[16:12:26.479]                 for (kk in seq_along(NAMES)) {
[16:12:26.479]                   name <- added[[kk]]
[16:12:26.479]                   NAME <- NAMES[[kk]]
[16:12:26.479]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.479]                     next
[16:12:26.479]                   args[[name]] <- ""
[16:12:26.479]                 }
[16:12:26.479]                 NAMES <- toupper(removed)
[16:12:26.479]                 for (kk in seq_along(NAMES)) {
[16:12:26.479]                   name <- removed[[kk]]
[16:12:26.479]                   NAME <- NAMES[[kk]]
[16:12:26.479]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.479]                     next
[16:12:26.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.479]                 }
[16:12:26.479]                 if (length(args) > 0) 
[16:12:26.479]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.479]             }
[16:12:26.479]             else {
[16:12:26.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.479]             }
[16:12:26.479]             {
[16:12:26.479]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.479]                   0L) {
[16:12:26.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.479]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.479]                   base::options(opts)
[16:12:26.479]                 }
[16:12:26.479]                 {
[16:12:26.479]                   {
[16:12:26.479]                     NULL
[16:12:26.479]                     RNGkind("Mersenne-Twister")
[16:12:26.479]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.479]                       inherits = FALSE)
[16:12:26.479]                   }
[16:12:26.479]                   options(future.plan = NULL)
[16:12:26.479]                   if (is.na(NA_character_)) 
[16:12:26.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.479]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.479]                   {
[16:12:26.479]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.479]                     if (!future$lazy) 
[16:12:26.479]                       future <- run(future)
[16:12:26.479]                     invisible(future)
[16:12:26.479]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.479]                 }
[16:12:26.479]             }
[16:12:26.479]         }
[16:12:26.479]     })
[16:12:26.479]     if (TRUE) {
[16:12:26.479]         base::sink(type = "output", split = FALSE)
[16:12:26.479]         if (TRUE) {
[16:12:26.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.479]         }
[16:12:26.479]         else {
[16:12:26.479]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.479]         }
[16:12:26.479]         base::close(...future.stdout)
[16:12:26.479]         ...future.stdout <- NULL
[16:12:26.479]     }
[16:12:26.479]     ...future.result$conditions <- ...future.conditions
[16:12:26.479]     ...future.result$finished <- base::Sys.time()
[16:12:26.479]     ...future.result
[16:12:26.479] }
[16:12:26.481] plan(): Setting new future strategy stack:
[16:12:26.481] List of future strategies:
[16:12:26.481] 1. sequential:
[16:12:26.481]    - args: function (..., envir = parent.frame())
[16:12:26.481]    - tweaked: FALSE
[16:12:26.481]    - call: NULL
[16:12:26.481] plan(): nbrOfWorkers() = 1
[16:12:26.482] plan(): Setting new future strategy stack:
[16:12:26.482] List of future strategies:
[16:12:26.482] 1. sequential:
[16:12:26.482]    - args: function (..., envir = parent.frame())
[16:12:26.482]    - tweaked: FALSE
[16:12:26.482]    - call: plan(strategy)
[16:12:26.482] plan(): nbrOfWorkers() = 1
[16:12:26.483] SequentialFuture started (and completed)
[16:12:26.483] - Launch lazy future ... done
[16:12:26.483] run() for ‘SequentialFuture’ ... done
<environment: 0x560baeb39008> 
<environment: 0x560bae6aa7b0> 
[16:12:26.484] resolved() for ‘SequentialFuture’ ...
[16:12:26.484] - state: ‘finished’
[16:12:26.484] - run: TRUE
[16:12:26.484] - result: ‘FutureResult’
[16:12:26.485] resolved() for ‘SequentialFuture’ ... done
[16:12:26.485] resolved() for ‘SequentialFuture’ ...
[16:12:26.485] - state: ‘finished’
[16:12:26.485] - run: TRUE
[16:12:26.485] - result: ‘FutureResult’
[16:12:26.485] resolved() for ‘SequentialFuture’ ... done
[16:12:26.485] resolved() for ‘SequentialFuture’ ...
[16:12:26.485] - state: ‘finished’
[16:12:26.485] - run: TRUE
[16:12:26.485] - result: ‘FutureResult’
[16:12:26.485] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:26.487] resolve() on environment ...
[16:12:26.487]  recursive: 0
[16:12:26.487]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:26.487] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.488] - nx: 4
[16:12:26.488] - relay: TRUE
[16:12:26.488] - stdout: TRUE
[16:12:26.488] - signal: TRUE
[16:12:26.488] - resignal: FALSE
[16:12:26.488] - force: TRUE
[16:12:26.488] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.488] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.488]  - until=2
[16:12:26.488]  - relaying element #2
[16:12:26.488] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.488] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.489] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.489]  length: 3 (resolved future 1)
[16:12:26.489] resolved() for ‘SequentialFuture’ ...
[16:12:26.489] - state: ‘finished’
[16:12:26.489] - run: TRUE
[16:12:26.489] - result: ‘FutureResult’
[16:12:26.489] resolved() for ‘SequentialFuture’ ... done
[16:12:26.489] Future #2
[16:12:26.489] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.489] - nx: 4
[16:12:26.489] - relay: TRUE
[16:12:26.490] - stdout: TRUE
[16:12:26.490] - signal: TRUE
[16:12:26.490] - resignal: FALSE
[16:12:26.490] - force: TRUE
[16:12:26.490] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.490] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.490]  - until=2
[16:12:26.490]  - relaying element #2
[16:12:26.490] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.490] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.490] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.491]  length: 2 (resolved future 2)
[16:12:26.491] resolved() for ‘SequentialFuture’ ...
[16:12:26.491] - state: ‘finished’
[16:12:26.491] - run: TRUE
[16:12:26.491] - result: ‘FutureResult’
[16:12:26.491] resolved() for ‘SequentialFuture’ ... done
[16:12:26.491] Future #3
[16:12:26.491] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.491] - nx: 4
[16:12:26.491] - relay: TRUE
[16:12:26.492] - stdout: TRUE
[16:12:26.492] - signal: TRUE
[16:12:26.492] - resignal: FALSE
[16:12:26.492] - force: TRUE
[16:12:26.492] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.492] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.492]  - until=3
[16:12:26.492]  - relaying element #3
[16:12:26.492] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.492] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.492] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.493]  length: 1 (resolved future 3)
[16:12:26.493] resolved() for ‘SequentialFuture’ ...
[16:12:26.493] - state: ‘finished’
[16:12:26.493] - run: TRUE
[16:12:26.493] - result: ‘FutureResult’
[16:12:26.493] resolved() for ‘SequentialFuture’ ... done
[16:12:26.493] Future #4
[16:12:26.493] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.493] - nx: 4
[16:12:26.493] - relay: TRUE
[16:12:26.493] - stdout: TRUE
[16:12:26.494] - signal: TRUE
[16:12:26.494] - resignal: FALSE
[16:12:26.494] - force: TRUE
[16:12:26.494] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.494] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.494]  - until=4
[16:12:26.494]  - relaying element #4
[16:12:26.494] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.494] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.494] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.494]  length: 0 (resolved future 4)
[16:12:26.495] Relaying remaining futures
[16:12:26.495] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.495] - nx: 4
[16:12:26.495] - relay: TRUE
[16:12:26.495] - stdout: TRUE
[16:12:26.495] - signal: TRUE
[16:12:26.495] - resignal: FALSE
[16:12:26.495] - force: TRUE
[16:12:26.495] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.495] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:26.495] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.496] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.497] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.497] resolve() on environment ... DONE
<environment: 0x560baeab3628> 
Dimensions: c(1, 6)
[16:12:26.498] getGlobalsAndPackages() ...
[16:12:26.498] Searching for globals...
[16:12:26.498] 
[16:12:26.498] Searching for globals ... DONE
[16:12:26.498] - globals: [0] <none>
[16:12:26.498] getGlobalsAndPackages() ... DONE
[16:12:26.499] run() for ‘Future’ ...
[16:12:26.499] - state: ‘created’
[16:12:26.499] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.499] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.499]   - Field: ‘label’
[16:12:26.499]   - Field: ‘local’
[16:12:26.499]   - Field: ‘owner’
[16:12:26.500]   - Field: ‘envir’
[16:12:26.500]   - Field: ‘packages’
[16:12:26.500]   - Field: ‘gc’
[16:12:26.500]   - Field: ‘conditions’
[16:12:26.500]   - Field: ‘expr’
[16:12:26.500]   - Field: ‘uuid’
[16:12:26.500]   - Field: ‘seed’
[16:12:26.500]   - Field: ‘version’
[16:12:26.500]   - Field: ‘result’
[16:12:26.500]   - Field: ‘asynchronous’
[16:12:26.500]   - Field: ‘calls’
[16:12:26.501]   - Field: ‘globals’
[16:12:26.501]   - Field: ‘stdout’
[16:12:26.501]   - Field: ‘earlySignal’
[16:12:26.501]   - Field: ‘lazy’
[16:12:26.501]   - Field: ‘state’
[16:12:26.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.501] - Launch lazy future ...
[16:12:26.501] Packages needed by the future expression (n = 0): <none>
[16:12:26.501] Packages needed by future strategies (n = 0): <none>
[16:12:26.502] {
[16:12:26.502]     {
[16:12:26.502]         {
[16:12:26.502]             ...future.startTime <- base::Sys.time()
[16:12:26.502]             {
[16:12:26.502]                 {
[16:12:26.502]                   {
[16:12:26.502]                     base::local({
[16:12:26.502]                       has_future <- base::requireNamespace("future", 
[16:12:26.502]                         quietly = TRUE)
[16:12:26.502]                       if (has_future) {
[16:12:26.502]                         ns <- base::getNamespace("future")
[16:12:26.502]                         version <- ns[[".package"]][["version"]]
[16:12:26.502]                         if (is.null(version)) 
[16:12:26.502]                           version <- utils::packageVersion("future")
[16:12:26.502]                       }
[16:12:26.502]                       else {
[16:12:26.502]                         version <- NULL
[16:12:26.502]                       }
[16:12:26.502]                       if (!has_future || version < "1.8.0") {
[16:12:26.502]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.502]                           "", base::R.version$version.string), 
[16:12:26.502]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.502]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.502]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.502]                             "release", "version")], collapse = " "), 
[16:12:26.502]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.502]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.502]                           info)
[16:12:26.502]                         info <- base::paste(info, collapse = "; ")
[16:12:26.502]                         if (!has_future) {
[16:12:26.502]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.502]                             info)
[16:12:26.502]                         }
[16:12:26.502]                         else {
[16:12:26.502]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.502]                             info, version)
[16:12:26.502]                         }
[16:12:26.502]                         base::stop(msg)
[16:12:26.502]                       }
[16:12:26.502]                     })
[16:12:26.502]                   }
[16:12:26.502]                   options(future.plan = NULL)
[16:12:26.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.502]                 }
[16:12:26.502]                 ...future.workdir <- getwd()
[16:12:26.502]             }
[16:12:26.502]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.502]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.502]         }
[16:12:26.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.502]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.502]             base::names(...future.oldOptions))
[16:12:26.502]     }
[16:12:26.502]     if (FALSE) {
[16:12:26.502]     }
[16:12:26.502]     else {
[16:12:26.502]         if (TRUE) {
[16:12:26.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.502]                 open = "w")
[16:12:26.502]         }
[16:12:26.502]         else {
[16:12:26.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.502]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.502]         }
[16:12:26.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.502]             base::sink(type = "output", split = FALSE)
[16:12:26.502]             base::close(...future.stdout)
[16:12:26.502]         }, add = TRUE)
[16:12:26.502]     }
[16:12:26.502]     ...future.frame <- base::sys.nframe()
[16:12:26.502]     ...future.conditions <- base::list()
[16:12:26.502]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.502]     if (FALSE) {
[16:12:26.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.502]     }
[16:12:26.502]     ...future.result <- base::tryCatch({
[16:12:26.502]         base::withCallingHandlers({
[16:12:26.502]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.502]             future::FutureResult(value = ...future.value$value, 
[16:12:26.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.502]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.502]                     ...future.globalenv.names))
[16:12:26.502]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.502]         }, condition = base::local({
[16:12:26.502]             c <- base::c
[16:12:26.502]             inherits <- base::inherits
[16:12:26.502]             invokeRestart <- base::invokeRestart
[16:12:26.502]             length <- base::length
[16:12:26.502]             list <- base::list
[16:12:26.502]             seq.int <- base::seq.int
[16:12:26.502]             signalCondition <- base::signalCondition
[16:12:26.502]             sys.calls <- base::sys.calls
[16:12:26.502]             `[[` <- base::`[[`
[16:12:26.502]             `+` <- base::`+`
[16:12:26.502]             `<<-` <- base::`<<-`
[16:12:26.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.502]                   3L)]
[16:12:26.502]             }
[16:12:26.502]             function(cond) {
[16:12:26.502]                 is_error <- inherits(cond, "error")
[16:12:26.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.502]                   NULL)
[16:12:26.502]                 if (is_error) {
[16:12:26.502]                   sessionInformation <- function() {
[16:12:26.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.502]                       search = base::search(), system = base::Sys.info())
[16:12:26.502]                   }
[16:12:26.502]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.502]                     cond$call), session = sessionInformation(), 
[16:12:26.502]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.502]                   signalCondition(cond)
[16:12:26.502]                 }
[16:12:26.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.502]                 "immediateCondition"))) {
[16:12:26.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.502]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.502]                   if (TRUE && !signal) {
[16:12:26.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.502]                     {
[16:12:26.502]                       inherits <- base::inherits
[16:12:26.502]                       invokeRestart <- base::invokeRestart
[16:12:26.502]                       is.null <- base::is.null
[16:12:26.502]                       muffled <- FALSE
[16:12:26.502]                       if (inherits(cond, "message")) {
[16:12:26.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.502]                         if (muffled) 
[16:12:26.502]                           invokeRestart("muffleMessage")
[16:12:26.502]                       }
[16:12:26.502]                       else if (inherits(cond, "warning")) {
[16:12:26.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.502]                         if (muffled) 
[16:12:26.502]                           invokeRestart("muffleWarning")
[16:12:26.502]                       }
[16:12:26.502]                       else if (inherits(cond, "condition")) {
[16:12:26.502]                         if (!is.null(pattern)) {
[16:12:26.502]                           computeRestarts <- base::computeRestarts
[16:12:26.502]                           grepl <- base::grepl
[16:12:26.502]                           restarts <- computeRestarts(cond)
[16:12:26.502]                           for (restart in restarts) {
[16:12:26.502]                             name <- restart$name
[16:12:26.502]                             if (is.null(name)) 
[16:12:26.502]                               next
[16:12:26.502]                             if (!grepl(pattern, name)) 
[16:12:26.502]                               next
[16:12:26.502]                             invokeRestart(restart)
[16:12:26.502]                             muffled <- TRUE
[16:12:26.502]                             break
[16:12:26.502]                           }
[16:12:26.502]                         }
[16:12:26.502]                       }
[16:12:26.502]                       invisible(muffled)
[16:12:26.502]                     }
[16:12:26.502]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.502]                   }
[16:12:26.502]                 }
[16:12:26.502]                 else {
[16:12:26.502]                   if (TRUE) {
[16:12:26.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.502]                     {
[16:12:26.502]                       inherits <- base::inherits
[16:12:26.502]                       invokeRestart <- base::invokeRestart
[16:12:26.502]                       is.null <- base::is.null
[16:12:26.502]                       muffled <- FALSE
[16:12:26.502]                       if (inherits(cond, "message")) {
[16:12:26.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.502]                         if (muffled) 
[16:12:26.502]                           invokeRestart("muffleMessage")
[16:12:26.502]                       }
[16:12:26.502]                       else if (inherits(cond, "warning")) {
[16:12:26.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.502]                         if (muffled) 
[16:12:26.502]                           invokeRestart("muffleWarning")
[16:12:26.502]                       }
[16:12:26.502]                       else if (inherits(cond, "condition")) {
[16:12:26.502]                         if (!is.null(pattern)) {
[16:12:26.502]                           computeRestarts <- base::computeRestarts
[16:12:26.502]                           grepl <- base::grepl
[16:12:26.502]                           restarts <- computeRestarts(cond)
[16:12:26.502]                           for (restart in restarts) {
[16:12:26.502]                             name <- restart$name
[16:12:26.502]                             if (is.null(name)) 
[16:12:26.502]                               next
[16:12:26.502]                             if (!grepl(pattern, name)) 
[16:12:26.502]                               next
[16:12:26.502]                             invokeRestart(restart)
[16:12:26.502]                             muffled <- TRUE
[16:12:26.502]                             break
[16:12:26.502]                           }
[16:12:26.502]                         }
[16:12:26.502]                       }
[16:12:26.502]                       invisible(muffled)
[16:12:26.502]                     }
[16:12:26.502]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.502]                   }
[16:12:26.502]                 }
[16:12:26.502]             }
[16:12:26.502]         }))
[16:12:26.502]     }, error = function(ex) {
[16:12:26.502]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.502]                 ...future.rng), started = ...future.startTime, 
[16:12:26.502]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.502]             version = "1.8"), class = "FutureResult")
[16:12:26.502]     }, finally = {
[16:12:26.502]         if (!identical(...future.workdir, getwd())) 
[16:12:26.502]             setwd(...future.workdir)
[16:12:26.502]         {
[16:12:26.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.502]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.502]             }
[16:12:26.502]             base::options(...future.oldOptions)
[16:12:26.502]             if (.Platform$OS.type == "windows") {
[16:12:26.502]                 old_names <- names(...future.oldEnvVars)
[16:12:26.502]                 envs <- base::Sys.getenv()
[16:12:26.502]                 names <- names(envs)
[16:12:26.502]                 common <- intersect(names, old_names)
[16:12:26.502]                 added <- setdiff(names, old_names)
[16:12:26.502]                 removed <- setdiff(old_names, names)
[16:12:26.502]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.502]                   envs[common]]
[16:12:26.502]                 NAMES <- toupper(changed)
[16:12:26.502]                 args <- list()
[16:12:26.502]                 for (kk in seq_along(NAMES)) {
[16:12:26.502]                   name <- changed[[kk]]
[16:12:26.502]                   NAME <- NAMES[[kk]]
[16:12:26.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.502]                     next
[16:12:26.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.502]                 }
[16:12:26.502]                 NAMES <- toupper(added)
[16:12:26.502]                 for (kk in seq_along(NAMES)) {
[16:12:26.502]                   name <- added[[kk]]
[16:12:26.502]                   NAME <- NAMES[[kk]]
[16:12:26.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.502]                     next
[16:12:26.502]                   args[[name]] <- ""
[16:12:26.502]                 }
[16:12:26.502]                 NAMES <- toupper(removed)
[16:12:26.502]                 for (kk in seq_along(NAMES)) {
[16:12:26.502]                   name <- removed[[kk]]
[16:12:26.502]                   NAME <- NAMES[[kk]]
[16:12:26.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.502]                     next
[16:12:26.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.502]                 }
[16:12:26.502]                 if (length(args) > 0) 
[16:12:26.502]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.502]             }
[16:12:26.502]             else {
[16:12:26.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.502]             }
[16:12:26.502]             {
[16:12:26.502]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.502]                   0L) {
[16:12:26.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.502]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.502]                   base::options(opts)
[16:12:26.502]                 }
[16:12:26.502]                 {
[16:12:26.502]                   {
[16:12:26.502]                     NULL
[16:12:26.502]                     RNGkind("Mersenne-Twister")
[16:12:26.502]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.502]                       inherits = FALSE)
[16:12:26.502]                   }
[16:12:26.502]                   options(future.plan = NULL)
[16:12:26.502]                   if (is.na(NA_character_)) 
[16:12:26.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.502]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.502]                   {
[16:12:26.502]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.502]                     if (!future$lazy) 
[16:12:26.502]                       future <- run(future)
[16:12:26.502]                     invisible(future)
[16:12:26.502]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.502]                 }
[16:12:26.502]             }
[16:12:26.502]         }
[16:12:26.502]     })
[16:12:26.502]     if (TRUE) {
[16:12:26.502]         base::sink(type = "output", split = FALSE)
[16:12:26.502]         if (TRUE) {
[16:12:26.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.502]         }
[16:12:26.502]         else {
[16:12:26.502]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.502]         }
[16:12:26.502]         base::close(...future.stdout)
[16:12:26.502]         ...future.stdout <- NULL
[16:12:26.502]     }
[16:12:26.502]     ...future.result$conditions <- ...future.conditions
[16:12:26.502]     ...future.result$finished <- base::Sys.time()
[16:12:26.502]     ...future.result
[16:12:26.502] }
[16:12:26.503] plan(): Setting new future strategy stack:
[16:12:26.504] List of future strategies:
[16:12:26.504] 1. sequential:
[16:12:26.504]    - args: function (..., envir = parent.frame())
[16:12:26.504]    - tweaked: FALSE
[16:12:26.504]    - call: NULL
[16:12:26.504] plan(): nbrOfWorkers() = 1
[16:12:26.505] plan(): Setting new future strategy stack:
[16:12:26.505] List of future strategies:
[16:12:26.505] 1. sequential:
[16:12:26.505]    - args: function (..., envir = parent.frame())
[16:12:26.505]    - tweaked: FALSE
[16:12:26.505]    - call: plan(strategy)
[16:12:26.505] plan(): nbrOfWorkers() = 1
[16:12:26.505] SequentialFuture started (and completed)
[16:12:26.505] - Launch lazy future ... done
[16:12:26.505] run() for ‘SequentialFuture’ ... done
[16:12:26.506] getGlobalsAndPackages() ...
[16:12:26.506] Searching for globals...
[16:12:26.506] 
[16:12:26.506] Searching for globals ... DONE
[16:12:26.506] - globals: [0] <none>
[16:12:26.506] getGlobalsAndPackages() ... DONE
[16:12:26.506] run() for ‘Future’ ...
[16:12:26.506] - state: ‘created’
[16:12:26.507] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.507]   - Field: ‘label’
[16:12:26.507]   - Field: ‘local’
[16:12:26.507]   - Field: ‘owner’
[16:12:26.507]   - Field: ‘envir’
[16:12:26.507]   - Field: ‘packages’
[16:12:26.508]   - Field: ‘gc’
[16:12:26.508]   - Field: ‘conditions’
[16:12:26.508]   - Field: ‘expr’
[16:12:26.508]   - Field: ‘uuid’
[16:12:26.508]   - Field: ‘seed’
[16:12:26.508]   - Field: ‘version’
[16:12:26.508]   - Field: ‘result’
[16:12:26.508]   - Field: ‘asynchronous’
[16:12:26.508]   - Field: ‘calls’
[16:12:26.508]   - Field: ‘globals’
[16:12:26.508]   - Field: ‘stdout’
[16:12:26.509]   - Field: ‘earlySignal’
[16:12:26.509]   - Field: ‘lazy’
[16:12:26.509]   - Field: ‘state’
[16:12:26.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.509] - Launch lazy future ...
[16:12:26.509] Packages needed by the future expression (n = 0): <none>
[16:12:26.509] Packages needed by future strategies (n = 0): <none>
[16:12:26.510] {
[16:12:26.510]     {
[16:12:26.510]         {
[16:12:26.510]             ...future.startTime <- base::Sys.time()
[16:12:26.510]             {
[16:12:26.510]                 {
[16:12:26.510]                   {
[16:12:26.510]                     base::local({
[16:12:26.510]                       has_future <- base::requireNamespace("future", 
[16:12:26.510]                         quietly = TRUE)
[16:12:26.510]                       if (has_future) {
[16:12:26.510]                         ns <- base::getNamespace("future")
[16:12:26.510]                         version <- ns[[".package"]][["version"]]
[16:12:26.510]                         if (is.null(version)) 
[16:12:26.510]                           version <- utils::packageVersion("future")
[16:12:26.510]                       }
[16:12:26.510]                       else {
[16:12:26.510]                         version <- NULL
[16:12:26.510]                       }
[16:12:26.510]                       if (!has_future || version < "1.8.0") {
[16:12:26.510]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.510]                           "", base::R.version$version.string), 
[16:12:26.510]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.510]                             "release", "version")], collapse = " "), 
[16:12:26.510]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.510]                           info)
[16:12:26.510]                         info <- base::paste(info, collapse = "; ")
[16:12:26.510]                         if (!has_future) {
[16:12:26.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.510]                             info)
[16:12:26.510]                         }
[16:12:26.510]                         else {
[16:12:26.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.510]                             info, version)
[16:12:26.510]                         }
[16:12:26.510]                         base::stop(msg)
[16:12:26.510]                       }
[16:12:26.510]                     })
[16:12:26.510]                   }
[16:12:26.510]                   options(future.plan = NULL)
[16:12:26.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.510]                 }
[16:12:26.510]                 ...future.workdir <- getwd()
[16:12:26.510]             }
[16:12:26.510]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.510]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.510]         }
[16:12:26.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.510]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.510]             base::names(...future.oldOptions))
[16:12:26.510]     }
[16:12:26.510]     if (FALSE) {
[16:12:26.510]     }
[16:12:26.510]     else {
[16:12:26.510]         if (TRUE) {
[16:12:26.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.510]                 open = "w")
[16:12:26.510]         }
[16:12:26.510]         else {
[16:12:26.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.510]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.510]         }
[16:12:26.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.510]             base::sink(type = "output", split = FALSE)
[16:12:26.510]             base::close(...future.stdout)
[16:12:26.510]         }, add = TRUE)
[16:12:26.510]     }
[16:12:26.510]     ...future.frame <- base::sys.nframe()
[16:12:26.510]     ...future.conditions <- base::list()
[16:12:26.510]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.510]     if (FALSE) {
[16:12:26.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.510]     }
[16:12:26.510]     ...future.result <- base::tryCatch({
[16:12:26.510]         base::withCallingHandlers({
[16:12:26.510]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.510]             future::FutureResult(value = ...future.value$value, 
[16:12:26.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.510]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.510]                     ...future.globalenv.names))
[16:12:26.510]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.510]         }, condition = base::local({
[16:12:26.510]             c <- base::c
[16:12:26.510]             inherits <- base::inherits
[16:12:26.510]             invokeRestart <- base::invokeRestart
[16:12:26.510]             length <- base::length
[16:12:26.510]             list <- base::list
[16:12:26.510]             seq.int <- base::seq.int
[16:12:26.510]             signalCondition <- base::signalCondition
[16:12:26.510]             sys.calls <- base::sys.calls
[16:12:26.510]             `[[` <- base::`[[`
[16:12:26.510]             `+` <- base::`+`
[16:12:26.510]             `<<-` <- base::`<<-`
[16:12:26.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.510]                   3L)]
[16:12:26.510]             }
[16:12:26.510]             function(cond) {
[16:12:26.510]                 is_error <- inherits(cond, "error")
[16:12:26.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.510]                   NULL)
[16:12:26.510]                 if (is_error) {
[16:12:26.510]                   sessionInformation <- function() {
[16:12:26.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.510]                       search = base::search(), system = base::Sys.info())
[16:12:26.510]                   }
[16:12:26.510]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.510]                     cond$call), session = sessionInformation(), 
[16:12:26.510]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.510]                   signalCondition(cond)
[16:12:26.510]                 }
[16:12:26.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.510]                 "immediateCondition"))) {
[16:12:26.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.510]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.510]                   if (TRUE && !signal) {
[16:12:26.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.510]                     {
[16:12:26.510]                       inherits <- base::inherits
[16:12:26.510]                       invokeRestart <- base::invokeRestart
[16:12:26.510]                       is.null <- base::is.null
[16:12:26.510]                       muffled <- FALSE
[16:12:26.510]                       if (inherits(cond, "message")) {
[16:12:26.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.510]                         if (muffled) 
[16:12:26.510]                           invokeRestart("muffleMessage")
[16:12:26.510]                       }
[16:12:26.510]                       else if (inherits(cond, "warning")) {
[16:12:26.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.510]                         if (muffled) 
[16:12:26.510]                           invokeRestart("muffleWarning")
[16:12:26.510]                       }
[16:12:26.510]                       else if (inherits(cond, "condition")) {
[16:12:26.510]                         if (!is.null(pattern)) {
[16:12:26.510]                           computeRestarts <- base::computeRestarts
[16:12:26.510]                           grepl <- base::grepl
[16:12:26.510]                           restarts <- computeRestarts(cond)
[16:12:26.510]                           for (restart in restarts) {
[16:12:26.510]                             name <- restart$name
[16:12:26.510]                             if (is.null(name)) 
[16:12:26.510]                               next
[16:12:26.510]                             if (!grepl(pattern, name)) 
[16:12:26.510]                               next
[16:12:26.510]                             invokeRestart(restart)
[16:12:26.510]                             muffled <- TRUE
[16:12:26.510]                             break
[16:12:26.510]                           }
[16:12:26.510]                         }
[16:12:26.510]                       }
[16:12:26.510]                       invisible(muffled)
[16:12:26.510]                     }
[16:12:26.510]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.510]                   }
[16:12:26.510]                 }
[16:12:26.510]                 else {
[16:12:26.510]                   if (TRUE) {
[16:12:26.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.510]                     {
[16:12:26.510]                       inherits <- base::inherits
[16:12:26.510]                       invokeRestart <- base::invokeRestart
[16:12:26.510]                       is.null <- base::is.null
[16:12:26.510]                       muffled <- FALSE
[16:12:26.510]                       if (inherits(cond, "message")) {
[16:12:26.510]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.510]                         if (muffled) 
[16:12:26.510]                           invokeRestart("muffleMessage")
[16:12:26.510]                       }
[16:12:26.510]                       else if (inherits(cond, "warning")) {
[16:12:26.510]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.510]                         if (muffled) 
[16:12:26.510]                           invokeRestart("muffleWarning")
[16:12:26.510]                       }
[16:12:26.510]                       else if (inherits(cond, "condition")) {
[16:12:26.510]                         if (!is.null(pattern)) {
[16:12:26.510]                           computeRestarts <- base::computeRestarts
[16:12:26.510]                           grepl <- base::grepl
[16:12:26.510]                           restarts <- computeRestarts(cond)
[16:12:26.510]                           for (restart in restarts) {
[16:12:26.510]                             name <- restart$name
[16:12:26.510]                             if (is.null(name)) 
[16:12:26.510]                               next
[16:12:26.510]                             if (!grepl(pattern, name)) 
[16:12:26.510]                               next
[16:12:26.510]                             invokeRestart(restart)
[16:12:26.510]                             muffled <- TRUE
[16:12:26.510]                             break
[16:12:26.510]                           }
[16:12:26.510]                         }
[16:12:26.510]                       }
[16:12:26.510]                       invisible(muffled)
[16:12:26.510]                     }
[16:12:26.510]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.510]                   }
[16:12:26.510]                 }
[16:12:26.510]             }
[16:12:26.510]         }))
[16:12:26.510]     }, error = function(ex) {
[16:12:26.510]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.510]                 ...future.rng), started = ...future.startTime, 
[16:12:26.510]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.510]             version = "1.8"), class = "FutureResult")
[16:12:26.510]     }, finally = {
[16:12:26.510]         if (!identical(...future.workdir, getwd())) 
[16:12:26.510]             setwd(...future.workdir)
[16:12:26.510]         {
[16:12:26.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.510]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.510]             }
[16:12:26.510]             base::options(...future.oldOptions)
[16:12:26.510]             if (.Platform$OS.type == "windows") {
[16:12:26.510]                 old_names <- names(...future.oldEnvVars)
[16:12:26.510]                 envs <- base::Sys.getenv()
[16:12:26.510]                 names <- names(envs)
[16:12:26.510]                 common <- intersect(names, old_names)
[16:12:26.510]                 added <- setdiff(names, old_names)
[16:12:26.510]                 removed <- setdiff(old_names, names)
[16:12:26.510]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.510]                   envs[common]]
[16:12:26.510]                 NAMES <- toupper(changed)
[16:12:26.510]                 args <- list()
[16:12:26.510]                 for (kk in seq_along(NAMES)) {
[16:12:26.510]                   name <- changed[[kk]]
[16:12:26.510]                   NAME <- NAMES[[kk]]
[16:12:26.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.510]                     next
[16:12:26.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.510]                 }
[16:12:26.510]                 NAMES <- toupper(added)
[16:12:26.510]                 for (kk in seq_along(NAMES)) {
[16:12:26.510]                   name <- added[[kk]]
[16:12:26.510]                   NAME <- NAMES[[kk]]
[16:12:26.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.510]                     next
[16:12:26.510]                   args[[name]] <- ""
[16:12:26.510]                 }
[16:12:26.510]                 NAMES <- toupper(removed)
[16:12:26.510]                 for (kk in seq_along(NAMES)) {
[16:12:26.510]                   name <- removed[[kk]]
[16:12:26.510]                   NAME <- NAMES[[kk]]
[16:12:26.510]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.510]                     next
[16:12:26.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.510]                 }
[16:12:26.510]                 if (length(args) > 0) 
[16:12:26.510]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.510]             }
[16:12:26.510]             else {
[16:12:26.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.510]             }
[16:12:26.510]             {
[16:12:26.510]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.510]                   0L) {
[16:12:26.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.510]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.510]                   base::options(opts)
[16:12:26.510]                 }
[16:12:26.510]                 {
[16:12:26.510]                   {
[16:12:26.510]                     NULL
[16:12:26.510]                     RNGkind("Mersenne-Twister")
[16:12:26.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.510]                       inherits = FALSE)
[16:12:26.510]                   }
[16:12:26.510]                   options(future.plan = NULL)
[16:12:26.510]                   if (is.na(NA_character_)) 
[16:12:26.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.510]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.510]                   {
[16:12:26.510]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.510]                     if (!future$lazy) 
[16:12:26.510]                       future <- run(future)
[16:12:26.510]                     invisible(future)
[16:12:26.510]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.510]                 }
[16:12:26.510]             }
[16:12:26.510]         }
[16:12:26.510]     })
[16:12:26.510]     if (TRUE) {
[16:12:26.510]         base::sink(type = "output", split = FALSE)
[16:12:26.510]         if (TRUE) {
[16:12:26.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.510]         }
[16:12:26.510]         else {
[16:12:26.510]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.510]         }
[16:12:26.510]         base::close(...future.stdout)
[16:12:26.510]         ...future.stdout <- NULL
[16:12:26.510]     }
[16:12:26.510]     ...future.result$conditions <- ...future.conditions
[16:12:26.510]     ...future.result$finished <- base::Sys.time()
[16:12:26.510]     ...future.result
[16:12:26.510] }
[16:12:26.511] plan(): Setting new future strategy stack:
[16:12:26.511] List of future strategies:
[16:12:26.511] 1. sequential:
[16:12:26.511]    - args: function (..., envir = parent.frame())
[16:12:26.511]    - tweaked: FALSE
[16:12:26.511]    - call: NULL
[16:12:26.512] plan(): nbrOfWorkers() = 1
[16:12:26.512] plan(): Setting new future strategy stack:
[16:12:26.513] List of future strategies:
[16:12:26.513] 1. sequential:
[16:12:26.513]    - args: function (..., envir = parent.frame())
[16:12:26.513]    - tweaked: FALSE
[16:12:26.513]    - call: plan(strategy)
[16:12:26.513] plan(): nbrOfWorkers() = 1
[16:12:26.513] SequentialFuture started (and completed)
[16:12:26.513] - Launch lazy future ... done
[16:12:26.513] run() for ‘SequentialFuture’ ... done
[16:12:26.514] getGlobalsAndPackages() ...
[16:12:26.514] Searching for globals...
[16:12:26.514] - globals found: [1] ‘{’
[16:12:26.514] Searching for globals ... DONE
[16:12:26.514] Resolving globals: FALSE
[16:12:26.515] 
[16:12:26.515] 
[16:12:26.515] getGlobalsAndPackages() ... DONE
[16:12:26.515] run() for ‘Future’ ...
[16:12:26.515] - state: ‘created’
[16:12:26.515] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.515] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.516] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.516]   - Field: ‘label’
[16:12:26.516]   - Field: ‘local’
[16:12:26.516]   - Field: ‘owner’
[16:12:26.516]   - Field: ‘envir’
[16:12:26.516]   - Field: ‘packages’
[16:12:26.516]   - Field: ‘gc’
[16:12:26.516]   - Field: ‘conditions’
[16:12:26.516]   - Field: ‘expr’
[16:12:26.516]   - Field: ‘uuid’
[16:12:26.516]   - Field: ‘seed’
[16:12:26.517]   - Field: ‘version’
[16:12:26.517]   - Field: ‘result’
[16:12:26.517]   - Field: ‘asynchronous’
[16:12:26.517]   - Field: ‘calls’
[16:12:26.517]   - Field: ‘globals’
[16:12:26.517]   - Field: ‘stdout’
[16:12:26.517]   - Field: ‘earlySignal’
[16:12:26.517]   - Field: ‘lazy’
[16:12:26.517]   - Field: ‘state’
[16:12:26.517] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.517] - Launch lazy future ...
[16:12:26.518] Packages needed by the future expression (n = 0): <none>
[16:12:26.518] Packages needed by future strategies (n = 0): <none>
[16:12:26.518] {
[16:12:26.518]     {
[16:12:26.518]         {
[16:12:26.518]             ...future.startTime <- base::Sys.time()
[16:12:26.518]             {
[16:12:26.518]                 {
[16:12:26.518]                   {
[16:12:26.518]                     base::local({
[16:12:26.518]                       has_future <- base::requireNamespace("future", 
[16:12:26.518]                         quietly = TRUE)
[16:12:26.518]                       if (has_future) {
[16:12:26.518]                         ns <- base::getNamespace("future")
[16:12:26.518]                         version <- ns[[".package"]][["version"]]
[16:12:26.518]                         if (is.null(version)) 
[16:12:26.518]                           version <- utils::packageVersion("future")
[16:12:26.518]                       }
[16:12:26.518]                       else {
[16:12:26.518]                         version <- NULL
[16:12:26.518]                       }
[16:12:26.518]                       if (!has_future || version < "1.8.0") {
[16:12:26.518]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.518]                           "", base::R.version$version.string), 
[16:12:26.518]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.518]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.518]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.518]                             "release", "version")], collapse = " "), 
[16:12:26.518]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.518]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.518]                           info)
[16:12:26.518]                         info <- base::paste(info, collapse = "; ")
[16:12:26.518]                         if (!has_future) {
[16:12:26.518]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.518]                             info)
[16:12:26.518]                         }
[16:12:26.518]                         else {
[16:12:26.518]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.518]                             info, version)
[16:12:26.518]                         }
[16:12:26.518]                         base::stop(msg)
[16:12:26.518]                       }
[16:12:26.518]                     })
[16:12:26.518]                   }
[16:12:26.518]                   options(future.plan = NULL)
[16:12:26.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.518]                 }
[16:12:26.518]                 ...future.workdir <- getwd()
[16:12:26.518]             }
[16:12:26.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.518]         }
[16:12:26.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.518]             base::names(...future.oldOptions))
[16:12:26.518]     }
[16:12:26.518]     if (FALSE) {
[16:12:26.518]     }
[16:12:26.518]     else {
[16:12:26.518]         if (TRUE) {
[16:12:26.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.518]                 open = "w")
[16:12:26.518]         }
[16:12:26.518]         else {
[16:12:26.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.518]         }
[16:12:26.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.518]             base::sink(type = "output", split = FALSE)
[16:12:26.518]             base::close(...future.stdout)
[16:12:26.518]         }, add = TRUE)
[16:12:26.518]     }
[16:12:26.518]     ...future.frame <- base::sys.nframe()
[16:12:26.518]     ...future.conditions <- base::list()
[16:12:26.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.518]     if (FALSE) {
[16:12:26.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.518]     }
[16:12:26.518]     ...future.result <- base::tryCatch({
[16:12:26.518]         base::withCallingHandlers({
[16:12:26.518]             ...future.value <- base::withVisible(base::local({
[16:12:26.518]                 4
[16:12:26.518]             }))
[16:12:26.518]             future::FutureResult(value = ...future.value$value, 
[16:12:26.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.518]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.518]                     ...future.globalenv.names))
[16:12:26.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.518]         }, condition = base::local({
[16:12:26.518]             c <- base::c
[16:12:26.518]             inherits <- base::inherits
[16:12:26.518]             invokeRestart <- base::invokeRestart
[16:12:26.518]             length <- base::length
[16:12:26.518]             list <- base::list
[16:12:26.518]             seq.int <- base::seq.int
[16:12:26.518]             signalCondition <- base::signalCondition
[16:12:26.518]             sys.calls <- base::sys.calls
[16:12:26.518]             `[[` <- base::`[[`
[16:12:26.518]             `+` <- base::`+`
[16:12:26.518]             `<<-` <- base::`<<-`
[16:12:26.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.518]                   3L)]
[16:12:26.518]             }
[16:12:26.518]             function(cond) {
[16:12:26.518]                 is_error <- inherits(cond, "error")
[16:12:26.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.518]                   NULL)
[16:12:26.518]                 if (is_error) {
[16:12:26.518]                   sessionInformation <- function() {
[16:12:26.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.518]                       search = base::search(), system = base::Sys.info())
[16:12:26.518]                   }
[16:12:26.518]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.518]                     cond$call), session = sessionInformation(), 
[16:12:26.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.518]                   signalCondition(cond)
[16:12:26.518]                 }
[16:12:26.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.518]                 "immediateCondition"))) {
[16:12:26.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.518]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.518]                   if (TRUE && !signal) {
[16:12:26.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.518]                     {
[16:12:26.518]                       inherits <- base::inherits
[16:12:26.518]                       invokeRestart <- base::invokeRestart
[16:12:26.518]                       is.null <- base::is.null
[16:12:26.518]                       muffled <- FALSE
[16:12:26.518]                       if (inherits(cond, "message")) {
[16:12:26.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.518]                         if (muffled) 
[16:12:26.518]                           invokeRestart("muffleMessage")
[16:12:26.518]                       }
[16:12:26.518]                       else if (inherits(cond, "warning")) {
[16:12:26.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.518]                         if (muffled) 
[16:12:26.518]                           invokeRestart("muffleWarning")
[16:12:26.518]                       }
[16:12:26.518]                       else if (inherits(cond, "condition")) {
[16:12:26.518]                         if (!is.null(pattern)) {
[16:12:26.518]                           computeRestarts <- base::computeRestarts
[16:12:26.518]                           grepl <- base::grepl
[16:12:26.518]                           restarts <- computeRestarts(cond)
[16:12:26.518]                           for (restart in restarts) {
[16:12:26.518]                             name <- restart$name
[16:12:26.518]                             if (is.null(name)) 
[16:12:26.518]                               next
[16:12:26.518]                             if (!grepl(pattern, name)) 
[16:12:26.518]                               next
[16:12:26.518]                             invokeRestart(restart)
[16:12:26.518]                             muffled <- TRUE
[16:12:26.518]                             break
[16:12:26.518]                           }
[16:12:26.518]                         }
[16:12:26.518]                       }
[16:12:26.518]                       invisible(muffled)
[16:12:26.518]                     }
[16:12:26.518]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.518]                   }
[16:12:26.518]                 }
[16:12:26.518]                 else {
[16:12:26.518]                   if (TRUE) {
[16:12:26.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.518]                     {
[16:12:26.518]                       inherits <- base::inherits
[16:12:26.518]                       invokeRestart <- base::invokeRestart
[16:12:26.518]                       is.null <- base::is.null
[16:12:26.518]                       muffled <- FALSE
[16:12:26.518]                       if (inherits(cond, "message")) {
[16:12:26.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.518]                         if (muffled) 
[16:12:26.518]                           invokeRestart("muffleMessage")
[16:12:26.518]                       }
[16:12:26.518]                       else if (inherits(cond, "warning")) {
[16:12:26.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.518]                         if (muffled) 
[16:12:26.518]                           invokeRestart("muffleWarning")
[16:12:26.518]                       }
[16:12:26.518]                       else if (inherits(cond, "condition")) {
[16:12:26.518]                         if (!is.null(pattern)) {
[16:12:26.518]                           computeRestarts <- base::computeRestarts
[16:12:26.518]                           grepl <- base::grepl
[16:12:26.518]                           restarts <- computeRestarts(cond)
[16:12:26.518]                           for (restart in restarts) {
[16:12:26.518]                             name <- restart$name
[16:12:26.518]                             if (is.null(name)) 
[16:12:26.518]                               next
[16:12:26.518]                             if (!grepl(pattern, name)) 
[16:12:26.518]                               next
[16:12:26.518]                             invokeRestart(restart)
[16:12:26.518]                             muffled <- TRUE
[16:12:26.518]                             break
[16:12:26.518]                           }
[16:12:26.518]                         }
[16:12:26.518]                       }
[16:12:26.518]                       invisible(muffled)
[16:12:26.518]                     }
[16:12:26.518]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.518]                   }
[16:12:26.518]                 }
[16:12:26.518]             }
[16:12:26.518]         }))
[16:12:26.518]     }, error = function(ex) {
[16:12:26.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.518]                 ...future.rng), started = ...future.startTime, 
[16:12:26.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.518]             version = "1.8"), class = "FutureResult")
[16:12:26.518]     }, finally = {
[16:12:26.518]         if (!identical(...future.workdir, getwd())) 
[16:12:26.518]             setwd(...future.workdir)
[16:12:26.518]         {
[16:12:26.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.518]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.518]             }
[16:12:26.518]             base::options(...future.oldOptions)
[16:12:26.518]             if (.Platform$OS.type == "windows") {
[16:12:26.518]                 old_names <- names(...future.oldEnvVars)
[16:12:26.518]                 envs <- base::Sys.getenv()
[16:12:26.518]                 names <- names(envs)
[16:12:26.518]                 common <- intersect(names, old_names)
[16:12:26.518]                 added <- setdiff(names, old_names)
[16:12:26.518]                 removed <- setdiff(old_names, names)
[16:12:26.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.518]                   envs[common]]
[16:12:26.518]                 NAMES <- toupper(changed)
[16:12:26.518]                 args <- list()
[16:12:26.518]                 for (kk in seq_along(NAMES)) {
[16:12:26.518]                   name <- changed[[kk]]
[16:12:26.518]                   NAME <- NAMES[[kk]]
[16:12:26.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.518]                     next
[16:12:26.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.518]                 }
[16:12:26.518]                 NAMES <- toupper(added)
[16:12:26.518]                 for (kk in seq_along(NAMES)) {
[16:12:26.518]                   name <- added[[kk]]
[16:12:26.518]                   NAME <- NAMES[[kk]]
[16:12:26.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.518]                     next
[16:12:26.518]                   args[[name]] <- ""
[16:12:26.518]                 }
[16:12:26.518]                 NAMES <- toupper(removed)
[16:12:26.518]                 for (kk in seq_along(NAMES)) {
[16:12:26.518]                   name <- removed[[kk]]
[16:12:26.518]                   NAME <- NAMES[[kk]]
[16:12:26.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.518]                     next
[16:12:26.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.518]                 }
[16:12:26.518]                 if (length(args) > 0) 
[16:12:26.518]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.518]             }
[16:12:26.518]             else {
[16:12:26.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.518]             }
[16:12:26.518]             {
[16:12:26.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.518]                   0L) {
[16:12:26.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.518]                   base::options(opts)
[16:12:26.518]                 }
[16:12:26.518]                 {
[16:12:26.518]                   {
[16:12:26.518]                     NULL
[16:12:26.518]                     RNGkind("Mersenne-Twister")
[16:12:26.518]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.518]                       inherits = FALSE)
[16:12:26.518]                   }
[16:12:26.518]                   options(future.plan = NULL)
[16:12:26.518]                   if (is.na(NA_character_)) 
[16:12:26.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.518]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.518]                   {
[16:12:26.518]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.518]                     if (!future$lazy) 
[16:12:26.518]                       future <- run(future)
[16:12:26.518]                     invisible(future)
[16:12:26.518]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.518]                 }
[16:12:26.518]             }
[16:12:26.518]         }
[16:12:26.518]     })
[16:12:26.518]     if (TRUE) {
[16:12:26.518]         base::sink(type = "output", split = FALSE)
[16:12:26.518]         if (TRUE) {
[16:12:26.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.518]         }
[16:12:26.518]         else {
[16:12:26.518]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.518]         }
[16:12:26.518]         base::close(...future.stdout)
[16:12:26.518]         ...future.stdout <- NULL
[16:12:26.518]     }
[16:12:26.518]     ...future.result$conditions <- ...future.conditions
[16:12:26.518]     ...future.result$finished <- base::Sys.time()
[16:12:26.518]     ...future.result
[16:12:26.518] }
[16:12:26.520] plan(): Setting new future strategy stack:
[16:12:26.520] List of future strategies:
[16:12:26.520] 1. sequential:
[16:12:26.520]    - args: function (..., envir = parent.frame())
[16:12:26.520]    - tweaked: FALSE
[16:12:26.520]    - call: NULL
[16:12:26.520] plan(): nbrOfWorkers() = 1
[16:12:26.521] plan(): Setting new future strategy stack:
[16:12:26.521] List of future strategies:
[16:12:26.521] 1. sequential:
[16:12:26.521]    - args: function (..., envir = parent.frame())
[16:12:26.521]    - tweaked: FALSE
[16:12:26.521]    - call: plan(strategy)
[16:12:26.521] plan(): nbrOfWorkers() = 1
[16:12:26.521] SequentialFuture started (and completed)
[16:12:26.522] - Launch lazy future ... done
[16:12:26.522] run() for ‘SequentialFuture’ ... done
<environment: 0x560bae0c1f18> 
<environment: 0x560baef54b10> 
[16:12:26.523] resolved() for ‘SequentialFuture’ ...
[16:12:26.523] - state: ‘finished’
[16:12:26.523] - run: TRUE
[16:12:26.523] - result: ‘FutureResult’
[16:12:26.523] resolved() for ‘SequentialFuture’ ... done
[16:12:26.523] resolved() for ‘SequentialFuture’ ...
[16:12:26.523] - state: ‘finished’
[16:12:26.524] - run: TRUE
[16:12:26.524] - result: ‘FutureResult’
[16:12:26.524] resolved() for ‘SequentialFuture’ ... done
[16:12:26.524] resolved() for ‘SequentialFuture’ ...
[16:12:26.524] - state: ‘finished’
[16:12:26.524] - run: TRUE
[16:12:26.524] - result: ‘FutureResult’
[16:12:26.524] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:26.527] resolve() on environment ...
[16:12:26.527]  recursive: 0
[16:12:26.527]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:26.527] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.527] - nx: 4
[16:12:26.527] - relay: TRUE
[16:12:26.528] - stdout: TRUE
[16:12:26.528] - signal: TRUE
[16:12:26.528] - resignal: FALSE
[16:12:26.528] - force: TRUE
[16:12:26.528] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.528] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.528]  - until=2
[16:12:26.528]  - relaying element #2
[16:12:26.528] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.528] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.528] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.528]  length: 3 (resolved future 1)
[16:12:26.529] resolved() for ‘SequentialFuture’ ...
[16:12:26.529] - state: ‘finished’
[16:12:26.529] - run: TRUE
[16:12:26.529] - result: ‘FutureResult’
[16:12:26.529] resolved() for ‘SequentialFuture’ ... done
[16:12:26.529] Future #2
[16:12:26.529] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.529] - nx: 4
[16:12:26.529] - relay: TRUE
[16:12:26.529] - stdout: TRUE
[16:12:26.530] - signal: TRUE
[16:12:26.530] - resignal: FALSE
[16:12:26.530] - force: TRUE
[16:12:26.530] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.530] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.530]  - until=2
[16:12:26.530]  - relaying element #2
[16:12:26.530] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.530] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.530] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.530]  length: 2 (resolved future 2)
[16:12:26.531] resolved() for ‘SequentialFuture’ ...
[16:12:26.531] - state: ‘finished’
[16:12:26.531] - run: TRUE
[16:12:26.531] - result: ‘FutureResult’
[16:12:26.531] resolved() for ‘SequentialFuture’ ... done
[16:12:26.531] Future #3
[16:12:26.531] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.531] - nx: 4
[16:12:26.531] - relay: TRUE
[16:12:26.531] - stdout: TRUE
[16:12:26.531] - signal: TRUE
[16:12:26.532] - resignal: FALSE
[16:12:26.532] - force: TRUE
[16:12:26.532] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.532] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.532]  - until=3
[16:12:26.532]  - relaying element #3
[16:12:26.532] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.532] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.532] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.532]  length: 1 (resolved future 3)
[16:12:26.533] resolved() for ‘SequentialFuture’ ...
[16:12:26.533] - state: ‘finished’
[16:12:26.533] - run: TRUE
[16:12:26.533] - result: ‘FutureResult’
[16:12:26.533] resolved() for ‘SequentialFuture’ ... done
[16:12:26.533] Future #4
[16:12:26.533] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.533] - nx: 4
[16:12:26.533] - relay: TRUE
[16:12:26.533] - stdout: TRUE
[16:12:26.533] - signal: TRUE
[16:12:26.534] - resignal: FALSE
[16:12:26.534] - force: TRUE
[16:12:26.534] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.534] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.534]  - until=4
[16:12:26.534]  - relaying element #4
[16:12:26.534] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.534] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.534] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.534]  length: 0 (resolved future 4)
[16:12:26.535] Relaying remaining futures
[16:12:26.535] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.535] - nx: 4
[16:12:26.535] - relay: TRUE
[16:12:26.535] - stdout: TRUE
[16:12:26.535] - signal: TRUE
[16:12:26.535] - resignal: FALSE
[16:12:26.535] - force: TRUE
[16:12:26.535] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.535] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:26.535] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.535] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.536] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.536] resolve() on environment ... DONE
<environment: 0x560bae0815d8> 
Dimensions: c(2, 3)
[16:12:26.536] getGlobalsAndPackages() ...
[16:12:26.536] Searching for globals...
[16:12:26.537] 
[16:12:26.537] Searching for globals ... DONE
[16:12:26.537] - globals: [0] <none>
[16:12:26.537] getGlobalsAndPackages() ... DONE
[16:12:26.537] run() for ‘Future’ ...
[16:12:26.537] - state: ‘created’
[16:12:26.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.537] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.538] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.538]   - Field: ‘label’
[16:12:26.538]   - Field: ‘local’
[16:12:26.538]   - Field: ‘owner’
[16:12:26.538]   - Field: ‘envir’
[16:12:26.538]   - Field: ‘packages’
[16:12:26.538]   - Field: ‘gc’
[16:12:26.538]   - Field: ‘conditions’
[16:12:26.538]   - Field: ‘expr’
[16:12:26.538]   - Field: ‘uuid’
[16:12:26.538]   - Field: ‘seed’
[16:12:26.539]   - Field: ‘version’
[16:12:26.539]   - Field: ‘result’
[16:12:26.539]   - Field: ‘asynchronous’
[16:12:26.539]   - Field: ‘calls’
[16:12:26.539]   - Field: ‘globals’
[16:12:26.539]   - Field: ‘stdout’
[16:12:26.539]   - Field: ‘earlySignal’
[16:12:26.539]   - Field: ‘lazy’
[16:12:26.539]   - Field: ‘state’
[16:12:26.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.539] - Launch lazy future ...
[16:12:26.540] Packages needed by the future expression (n = 0): <none>
[16:12:26.540] Packages needed by future strategies (n = 0): <none>
[16:12:26.540] {
[16:12:26.540]     {
[16:12:26.540]         {
[16:12:26.540]             ...future.startTime <- base::Sys.time()
[16:12:26.540]             {
[16:12:26.540]                 {
[16:12:26.540]                   {
[16:12:26.540]                     base::local({
[16:12:26.540]                       has_future <- base::requireNamespace("future", 
[16:12:26.540]                         quietly = TRUE)
[16:12:26.540]                       if (has_future) {
[16:12:26.540]                         ns <- base::getNamespace("future")
[16:12:26.540]                         version <- ns[[".package"]][["version"]]
[16:12:26.540]                         if (is.null(version)) 
[16:12:26.540]                           version <- utils::packageVersion("future")
[16:12:26.540]                       }
[16:12:26.540]                       else {
[16:12:26.540]                         version <- NULL
[16:12:26.540]                       }
[16:12:26.540]                       if (!has_future || version < "1.8.0") {
[16:12:26.540]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.540]                           "", base::R.version$version.string), 
[16:12:26.540]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.540]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.540]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.540]                             "release", "version")], collapse = " "), 
[16:12:26.540]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.540]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.540]                           info)
[16:12:26.540]                         info <- base::paste(info, collapse = "; ")
[16:12:26.540]                         if (!has_future) {
[16:12:26.540]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.540]                             info)
[16:12:26.540]                         }
[16:12:26.540]                         else {
[16:12:26.540]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.540]                             info, version)
[16:12:26.540]                         }
[16:12:26.540]                         base::stop(msg)
[16:12:26.540]                       }
[16:12:26.540]                     })
[16:12:26.540]                   }
[16:12:26.540]                   options(future.plan = NULL)
[16:12:26.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.540]                 }
[16:12:26.540]                 ...future.workdir <- getwd()
[16:12:26.540]             }
[16:12:26.540]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.540]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.540]         }
[16:12:26.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.540]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.540]             base::names(...future.oldOptions))
[16:12:26.540]     }
[16:12:26.540]     if (FALSE) {
[16:12:26.540]     }
[16:12:26.540]     else {
[16:12:26.540]         if (TRUE) {
[16:12:26.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.540]                 open = "w")
[16:12:26.540]         }
[16:12:26.540]         else {
[16:12:26.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.540]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.540]         }
[16:12:26.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.540]             base::sink(type = "output", split = FALSE)
[16:12:26.540]             base::close(...future.stdout)
[16:12:26.540]         }, add = TRUE)
[16:12:26.540]     }
[16:12:26.540]     ...future.frame <- base::sys.nframe()
[16:12:26.540]     ...future.conditions <- base::list()
[16:12:26.540]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.540]     if (FALSE) {
[16:12:26.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.540]     }
[16:12:26.540]     ...future.result <- base::tryCatch({
[16:12:26.540]         base::withCallingHandlers({
[16:12:26.540]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.540]             future::FutureResult(value = ...future.value$value, 
[16:12:26.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.540]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.540]                     ...future.globalenv.names))
[16:12:26.540]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.540]         }, condition = base::local({
[16:12:26.540]             c <- base::c
[16:12:26.540]             inherits <- base::inherits
[16:12:26.540]             invokeRestart <- base::invokeRestart
[16:12:26.540]             length <- base::length
[16:12:26.540]             list <- base::list
[16:12:26.540]             seq.int <- base::seq.int
[16:12:26.540]             signalCondition <- base::signalCondition
[16:12:26.540]             sys.calls <- base::sys.calls
[16:12:26.540]             `[[` <- base::`[[`
[16:12:26.540]             `+` <- base::`+`
[16:12:26.540]             `<<-` <- base::`<<-`
[16:12:26.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.540]                   3L)]
[16:12:26.540]             }
[16:12:26.540]             function(cond) {
[16:12:26.540]                 is_error <- inherits(cond, "error")
[16:12:26.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.540]                   NULL)
[16:12:26.540]                 if (is_error) {
[16:12:26.540]                   sessionInformation <- function() {
[16:12:26.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.540]                       search = base::search(), system = base::Sys.info())
[16:12:26.540]                   }
[16:12:26.540]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.540]                     cond$call), session = sessionInformation(), 
[16:12:26.540]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.540]                   signalCondition(cond)
[16:12:26.540]                 }
[16:12:26.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.540]                 "immediateCondition"))) {
[16:12:26.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.540]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.540]                   if (TRUE && !signal) {
[16:12:26.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.540]                     {
[16:12:26.540]                       inherits <- base::inherits
[16:12:26.540]                       invokeRestart <- base::invokeRestart
[16:12:26.540]                       is.null <- base::is.null
[16:12:26.540]                       muffled <- FALSE
[16:12:26.540]                       if (inherits(cond, "message")) {
[16:12:26.540]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.540]                         if (muffled) 
[16:12:26.540]                           invokeRestart("muffleMessage")
[16:12:26.540]                       }
[16:12:26.540]                       else if (inherits(cond, "warning")) {
[16:12:26.540]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.540]                         if (muffled) 
[16:12:26.540]                           invokeRestart("muffleWarning")
[16:12:26.540]                       }
[16:12:26.540]                       else if (inherits(cond, "condition")) {
[16:12:26.540]                         if (!is.null(pattern)) {
[16:12:26.540]                           computeRestarts <- base::computeRestarts
[16:12:26.540]                           grepl <- base::grepl
[16:12:26.540]                           restarts <- computeRestarts(cond)
[16:12:26.540]                           for (restart in restarts) {
[16:12:26.540]                             name <- restart$name
[16:12:26.540]                             if (is.null(name)) 
[16:12:26.540]                               next
[16:12:26.540]                             if (!grepl(pattern, name)) 
[16:12:26.540]                               next
[16:12:26.540]                             invokeRestart(restart)
[16:12:26.540]                             muffled <- TRUE
[16:12:26.540]                             break
[16:12:26.540]                           }
[16:12:26.540]                         }
[16:12:26.540]                       }
[16:12:26.540]                       invisible(muffled)
[16:12:26.540]                     }
[16:12:26.540]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.540]                   }
[16:12:26.540]                 }
[16:12:26.540]                 else {
[16:12:26.540]                   if (TRUE) {
[16:12:26.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.540]                     {
[16:12:26.540]                       inherits <- base::inherits
[16:12:26.540]                       invokeRestart <- base::invokeRestart
[16:12:26.540]                       is.null <- base::is.null
[16:12:26.540]                       muffled <- FALSE
[16:12:26.540]                       if (inherits(cond, "message")) {
[16:12:26.540]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.540]                         if (muffled) 
[16:12:26.540]                           invokeRestart("muffleMessage")
[16:12:26.540]                       }
[16:12:26.540]                       else if (inherits(cond, "warning")) {
[16:12:26.540]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.540]                         if (muffled) 
[16:12:26.540]                           invokeRestart("muffleWarning")
[16:12:26.540]                       }
[16:12:26.540]                       else if (inherits(cond, "condition")) {
[16:12:26.540]                         if (!is.null(pattern)) {
[16:12:26.540]                           computeRestarts <- base::computeRestarts
[16:12:26.540]                           grepl <- base::grepl
[16:12:26.540]                           restarts <- computeRestarts(cond)
[16:12:26.540]                           for (restart in restarts) {
[16:12:26.540]                             name <- restart$name
[16:12:26.540]                             if (is.null(name)) 
[16:12:26.540]                               next
[16:12:26.540]                             if (!grepl(pattern, name)) 
[16:12:26.540]                               next
[16:12:26.540]                             invokeRestart(restart)
[16:12:26.540]                             muffled <- TRUE
[16:12:26.540]                             break
[16:12:26.540]                           }
[16:12:26.540]                         }
[16:12:26.540]                       }
[16:12:26.540]                       invisible(muffled)
[16:12:26.540]                     }
[16:12:26.540]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.540]                   }
[16:12:26.540]                 }
[16:12:26.540]             }
[16:12:26.540]         }))
[16:12:26.540]     }, error = function(ex) {
[16:12:26.540]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.540]                 ...future.rng), started = ...future.startTime, 
[16:12:26.540]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.540]             version = "1.8"), class = "FutureResult")
[16:12:26.540]     }, finally = {
[16:12:26.540]         if (!identical(...future.workdir, getwd())) 
[16:12:26.540]             setwd(...future.workdir)
[16:12:26.540]         {
[16:12:26.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.540]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.540]             }
[16:12:26.540]             base::options(...future.oldOptions)
[16:12:26.540]             if (.Platform$OS.type == "windows") {
[16:12:26.540]                 old_names <- names(...future.oldEnvVars)
[16:12:26.540]                 envs <- base::Sys.getenv()
[16:12:26.540]                 names <- names(envs)
[16:12:26.540]                 common <- intersect(names, old_names)
[16:12:26.540]                 added <- setdiff(names, old_names)
[16:12:26.540]                 removed <- setdiff(old_names, names)
[16:12:26.540]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.540]                   envs[common]]
[16:12:26.540]                 NAMES <- toupper(changed)
[16:12:26.540]                 args <- list()
[16:12:26.540]                 for (kk in seq_along(NAMES)) {
[16:12:26.540]                   name <- changed[[kk]]
[16:12:26.540]                   NAME <- NAMES[[kk]]
[16:12:26.540]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.540]                     next
[16:12:26.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.540]                 }
[16:12:26.540]                 NAMES <- toupper(added)
[16:12:26.540]                 for (kk in seq_along(NAMES)) {
[16:12:26.540]                   name <- added[[kk]]
[16:12:26.540]                   NAME <- NAMES[[kk]]
[16:12:26.540]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.540]                     next
[16:12:26.540]                   args[[name]] <- ""
[16:12:26.540]                 }
[16:12:26.540]                 NAMES <- toupper(removed)
[16:12:26.540]                 for (kk in seq_along(NAMES)) {
[16:12:26.540]                   name <- removed[[kk]]
[16:12:26.540]                   NAME <- NAMES[[kk]]
[16:12:26.540]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.540]                     next
[16:12:26.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.540]                 }
[16:12:26.540]                 if (length(args) > 0) 
[16:12:26.540]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.540]             }
[16:12:26.540]             else {
[16:12:26.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.540]             }
[16:12:26.540]             {
[16:12:26.540]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.540]                   0L) {
[16:12:26.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.540]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.540]                   base::options(opts)
[16:12:26.540]                 }
[16:12:26.540]                 {
[16:12:26.540]                   {
[16:12:26.540]                     NULL
[16:12:26.540]                     RNGkind("Mersenne-Twister")
[16:12:26.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.540]                       inherits = FALSE)
[16:12:26.540]                   }
[16:12:26.540]                   options(future.plan = NULL)
[16:12:26.540]                   if (is.na(NA_character_)) 
[16:12:26.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.540]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.540]                   {
[16:12:26.540]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.540]                     if (!future$lazy) 
[16:12:26.540]                       future <- run(future)
[16:12:26.540]                     invisible(future)
[16:12:26.540]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.540]                 }
[16:12:26.540]             }
[16:12:26.540]         }
[16:12:26.540]     })
[16:12:26.540]     if (TRUE) {
[16:12:26.540]         base::sink(type = "output", split = FALSE)
[16:12:26.540]         if (TRUE) {
[16:12:26.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.540]         }
[16:12:26.540]         else {
[16:12:26.540]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.540]         }
[16:12:26.540]         base::close(...future.stdout)
[16:12:26.540]         ...future.stdout <- NULL
[16:12:26.540]     }
[16:12:26.540]     ...future.result$conditions <- ...future.conditions
[16:12:26.540]     ...future.result$finished <- base::Sys.time()
[16:12:26.540]     ...future.result
[16:12:26.540] }
[16:12:26.542] plan(): Setting new future strategy stack:
[16:12:26.542] List of future strategies:
[16:12:26.542] 1. sequential:
[16:12:26.542]    - args: function (..., envir = parent.frame())
[16:12:26.542]    - tweaked: FALSE
[16:12:26.542]    - call: NULL
[16:12:26.542] plan(): nbrOfWorkers() = 1
[16:12:26.543] plan(): Setting new future strategy stack:
[16:12:26.543] List of future strategies:
[16:12:26.543] 1. sequential:
[16:12:26.543]    - args: function (..., envir = parent.frame())
[16:12:26.543]    - tweaked: FALSE
[16:12:26.543]    - call: plan(strategy)
[16:12:26.543] plan(): nbrOfWorkers() = 1
[16:12:26.543] SequentialFuture started (and completed)
[16:12:26.544] - Launch lazy future ... done
[16:12:26.544] run() for ‘SequentialFuture’ ... done
[16:12:26.544] getGlobalsAndPackages() ...
[16:12:26.544] Searching for globals...
[16:12:26.544] 
[16:12:26.544] Searching for globals ... DONE
[16:12:26.544] - globals: [0] <none>
[16:12:26.544] getGlobalsAndPackages() ... DONE
[16:12:26.545] run() for ‘Future’ ...
[16:12:26.545] - state: ‘created’
[16:12:26.545] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.545]   - Field: ‘label’
[16:12:26.545]   - Field: ‘local’
[16:12:26.545]   - Field: ‘owner’
[16:12:26.546]   - Field: ‘envir’
[16:12:26.546]   - Field: ‘packages’
[16:12:26.546]   - Field: ‘gc’
[16:12:26.546]   - Field: ‘conditions’
[16:12:26.546]   - Field: ‘expr’
[16:12:26.546]   - Field: ‘uuid’
[16:12:26.546]   - Field: ‘seed’
[16:12:26.546]   - Field: ‘version’
[16:12:26.546]   - Field: ‘result’
[16:12:26.546]   - Field: ‘asynchronous’
[16:12:26.546]   - Field: ‘calls’
[16:12:26.547]   - Field: ‘globals’
[16:12:26.547]   - Field: ‘stdout’
[16:12:26.547]   - Field: ‘earlySignal’
[16:12:26.547]   - Field: ‘lazy’
[16:12:26.547]   - Field: ‘state’
[16:12:26.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.547] - Launch lazy future ...
[16:12:26.547] Packages needed by the future expression (n = 0): <none>
[16:12:26.547] Packages needed by future strategies (n = 0): <none>
[16:12:26.548] {
[16:12:26.548]     {
[16:12:26.548]         {
[16:12:26.548]             ...future.startTime <- base::Sys.time()
[16:12:26.548]             {
[16:12:26.548]                 {
[16:12:26.548]                   {
[16:12:26.548]                     base::local({
[16:12:26.548]                       has_future <- base::requireNamespace("future", 
[16:12:26.548]                         quietly = TRUE)
[16:12:26.548]                       if (has_future) {
[16:12:26.548]                         ns <- base::getNamespace("future")
[16:12:26.548]                         version <- ns[[".package"]][["version"]]
[16:12:26.548]                         if (is.null(version)) 
[16:12:26.548]                           version <- utils::packageVersion("future")
[16:12:26.548]                       }
[16:12:26.548]                       else {
[16:12:26.548]                         version <- NULL
[16:12:26.548]                       }
[16:12:26.548]                       if (!has_future || version < "1.8.0") {
[16:12:26.548]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.548]                           "", base::R.version$version.string), 
[16:12:26.548]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.548]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.548]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.548]                             "release", "version")], collapse = " "), 
[16:12:26.548]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.548]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.548]                           info)
[16:12:26.548]                         info <- base::paste(info, collapse = "; ")
[16:12:26.548]                         if (!has_future) {
[16:12:26.548]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.548]                             info)
[16:12:26.548]                         }
[16:12:26.548]                         else {
[16:12:26.548]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.548]                             info, version)
[16:12:26.548]                         }
[16:12:26.548]                         base::stop(msg)
[16:12:26.548]                       }
[16:12:26.548]                     })
[16:12:26.548]                   }
[16:12:26.548]                   options(future.plan = NULL)
[16:12:26.548]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.548]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.548]                 }
[16:12:26.548]                 ...future.workdir <- getwd()
[16:12:26.548]             }
[16:12:26.548]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.548]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.548]         }
[16:12:26.548]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.548]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.548]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.548]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.548]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.548]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.548]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.548]             base::names(...future.oldOptions))
[16:12:26.548]     }
[16:12:26.548]     if (FALSE) {
[16:12:26.548]     }
[16:12:26.548]     else {
[16:12:26.548]         if (TRUE) {
[16:12:26.548]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.548]                 open = "w")
[16:12:26.548]         }
[16:12:26.548]         else {
[16:12:26.548]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.548]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.548]         }
[16:12:26.548]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.548]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.548]             base::sink(type = "output", split = FALSE)
[16:12:26.548]             base::close(...future.stdout)
[16:12:26.548]         }, add = TRUE)
[16:12:26.548]     }
[16:12:26.548]     ...future.frame <- base::sys.nframe()
[16:12:26.548]     ...future.conditions <- base::list()
[16:12:26.548]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.548]     if (FALSE) {
[16:12:26.548]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.548]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.548]     }
[16:12:26.548]     ...future.result <- base::tryCatch({
[16:12:26.548]         base::withCallingHandlers({
[16:12:26.548]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.548]             future::FutureResult(value = ...future.value$value, 
[16:12:26.548]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.548]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.548]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.548]                     ...future.globalenv.names))
[16:12:26.548]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.548]         }, condition = base::local({
[16:12:26.548]             c <- base::c
[16:12:26.548]             inherits <- base::inherits
[16:12:26.548]             invokeRestart <- base::invokeRestart
[16:12:26.548]             length <- base::length
[16:12:26.548]             list <- base::list
[16:12:26.548]             seq.int <- base::seq.int
[16:12:26.548]             signalCondition <- base::signalCondition
[16:12:26.548]             sys.calls <- base::sys.calls
[16:12:26.548]             `[[` <- base::`[[`
[16:12:26.548]             `+` <- base::`+`
[16:12:26.548]             `<<-` <- base::`<<-`
[16:12:26.548]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.548]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.548]                   3L)]
[16:12:26.548]             }
[16:12:26.548]             function(cond) {
[16:12:26.548]                 is_error <- inherits(cond, "error")
[16:12:26.548]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.548]                   NULL)
[16:12:26.548]                 if (is_error) {
[16:12:26.548]                   sessionInformation <- function() {
[16:12:26.548]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.548]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.548]                       search = base::search(), system = base::Sys.info())
[16:12:26.548]                   }
[16:12:26.548]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.548]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.548]                     cond$call), session = sessionInformation(), 
[16:12:26.548]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.548]                   signalCondition(cond)
[16:12:26.548]                 }
[16:12:26.548]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.548]                 "immediateCondition"))) {
[16:12:26.548]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.548]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.548]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.548]                   if (TRUE && !signal) {
[16:12:26.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.548]                     {
[16:12:26.548]                       inherits <- base::inherits
[16:12:26.548]                       invokeRestart <- base::invokeRestart
[16:12:26.548]                       is.null <- base::is.null
[16:12:26.548]                       muffled <- FALSE
[16:12:26.548]                       if (inherits(cond, "message")) {
[16:12:26.548]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.548]                         if (muffled) 
[16:12:26.548]                           invokeRestart("muffleMessage")
[16:12:26.548]                       }
[16:12:26.548]                       else if (inherits(cond, "warning")) {
[16:12:26.548]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.548]                         if (muffled) 
[16:12:26.548]                           invokeRestart("muffleWarning")
[16:12:26.548]                       }
[16:12:26.548]                       else if (inherits(cond, "condition")) {
[16:12:26.548]                         if (!is.null(pattern)) {
[16:12:26.548]                           computeRestarts <- base::computeRestarts
[16:12:26.548]                           grepl <- base::grepl
[16:12:26.548]                           restarts <- computeRestarts(cond)
[16:12:26.548]                           for (restart in restarts) {
[16:12:26.548]                             name <- restart$name
[16:12:26.548]                             if (is.null(name)) 
[16:12:26.548]                               next
[16:12:26.548]                             if (!grepl(pattern, name)) 
[16:12:26.548]                               next
[16:12:26.548]                             invokeRestart(restart)
[16:12:26.548]                             muffled <- TRUE
[16:12:26.548]                             break
[16:12:26.548]                           }
[16:12:26.548]                         }
[16:12:26.548]                       }
[16:12:26.548]                       invisible(muffled)
[16:12:26.548]                     }
[16:12:26.548]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.548]                   }
[16:12:26.548]                 }
[16:12:26.548]                 else {
[16:12:26.548]                   if (TRUE) {
[16:12:26.548]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.548]                     {
[16:12:26.548]                       inherits <- base::inherits
[16:12:26.548]                       invokeRestart <- base::invokeRestart
[16:12:26.548]                       is.null <- base::is.null
[16:12:26.548]                       muffled <- FALSE
[16:12:26.548]                       if (inherits(cond, "message")) {
[16:12:26.548]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.548]                         if (muffled) 
[16:12:26.548]                           invokeRestart("muffleMessage")
[16:12:26.548]                       }
[16:12:26.548]                       else if (inherits(cond, "warning")) {
[16:12:26.548]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.548]                         if (muffled) 
[16:12:26.548]                           invokeRestart("muffleWarning")
[16:12:26.548]                       }
[16:12:26.548]                       else if (inherits(cond, "condition")) {
[16:12:26.548]                         if (!is.null(pattern)) {
[16:12:26.548]                           computeRestarts <- base::computeRestarts
[16:12:26.548]                           grepl <- base::grepl
[16:12:26.548]                           restarts <- computeRestarts(cond)
[16:12:26.548]                           for (restart in restarts) {
[16:12:26.548]                             name <- restart$name
[16:12:26.548]                             if (is.null(name)) 
[16:12:26.548]                               next
[16:12:26.548]                             if (!grepl(pattern, name)) 
[16:12:26.548]                               next
[16:12:26.548]                             invokeRestart(restart)
[16:12:26.548]                             muffled <- TRUE
[16:12:26.548]                             break
[16:12:26.548]                           }
[16:12:26.548]                         }
[16:12:26.548]                       }
[16:12:26.548]                       invisible(muffled)
[16:12:26.548]                     }
[16:12:26.548]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.548]                   }
[16:12:26.548]                 }
[16:12:26.548]             }
[16:12:26.548]         }))
[16:12:26.548]     }, error = function(ex) {
[16:12:26.548]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.548]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.548]                 ...future.rng), started = ...future.startTime, 
[16:12:26.548]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.548]             version = "1.8"), class = "FutureResult")
[16:12:26.548]     }, finally = {
[16:12:26.548]         if (!identical(...future.workdir, getwd())) 
[16:12:26.548]             setwd(...future.workdir)
[16:12:26.548]         {
[16:12:26.548]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.548]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.548]             }
[16:12:26.548]             base::options(...future.oldOptions)
[16:12:26.548]             if (.Platform$OS.type == "windows") {
[16:12:26.548]                 old_names <- names(...future.oldEnvVars)
[16:12:26.548]                 envs <- base::Sys.getenv()
[16:12:26.548]                 names <- names(envs)
[16:12:26.548]                 common <- intersect(names, old_names)
[16:12:26.548]                 added <- setdiff(names, old_names)
[16:12:26.548]                 removed <- setdiff(old_names, names)
[16:12:26.548]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.548]                   envs[common]]
[16:12:26.548]                 NAMES <- toupper(changed)
[16:12:26.548]                 args <- list()
[16:12:26.548]                 for (kk in seq_along(NAMES)) {
[16:12:26.548]                   name <- changed[[kk]]
[16:12:26.548]                   NAME <- NAMES[[kk]]
[16:12:26.548]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.548]                     next
[16:12:26.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.548]                 }
[16:12:26.548]                 NAMES <- toupper(added)
[16:12:26.548]                 for (kk in seq_along(NAMES)) {
[16:12:26.548]                   name <- added[[kk]]
[16:12:26.548]                   NAME <- NAMES[[kk]]
[16:12:26.548]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.548]                     next
[16:12:26.548]                   args[[name]] <- ""
[16:12:26.548]                 }
[16:12:26.548]                 NAMES <- toupper(removed)
[16:12:26.548]                 for (kk in seq_along(NAMES)) {
[16:12:26.548]                   name <- removed[[kk]]
[16:12:26.548]                   NAME <- NAMES[[kk]]
[16:12:26.548]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.548]                     next
[16:12:26.548]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.548]                 }
[16:12:26.548]                 if (length(args) > 0) 
[16:12:26.548]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.548]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.548]             }
[16:12:26.548]             else {
[16:12:26.548]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.548]             }
[16:12:26.548]             {
[16:12:26.548]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.548]                   0L) {
[16:12:26.548]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.548]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.548]                   base::options(opts)
[16:12:26.548]                 }
[16:12:26.548]                 {
[16:12:26.548]                   {
[16:12:26.548]                     NULL
[16:12:26.548]                     RNGkind("Mersenne-Twister")
[16:12:26.548]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.548]                       inherits = FALSE)
[16:12:26.548]                   }
[16:12:26.548]                   options(future.plan = NULL)
[16:12:26.548]                   if (is.na(NA_character_)) 
[16:12:26.548]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.548]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.548]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.548]                   {
[16:12:26.548]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.548]                     if (!future$lazy) 
[16:12:26.548]                       future <- run(future)
[16:12:26.548]                     invisible(future)
[16:12:26.548]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.548]                 }
[16:12:26.548]             }
[16:12:26.548]         }
[16:12:26.548]     })
[16:12:26.548]     if (TRUE) {
[16:12:26.548]         base::sink(type = "output", split = FALSE)
[16:12:26.548]         if (TRUE) {
[16:12:26.548]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.548]         }
[16:12:26.548]         else {
[16:12:26.548]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.548]         }
[16:12:26.548]         base::close(...future.stdout)
[16:12:26.548]         ...future.stdout <- NULL
[16:12:26.548]     }
[16:12:26.548]     ...future.result$conditions <- ...future.conditions
[16:12:26.548]     ...future.result$finished <- base::Sys.time()
[16:12:26.548]     ...future.result
[16:12:26.548] }
[16:12:26.549] plan(): Setting new future strategy stack:
[16:12:26.549] List of future strategies:
[16:12:26.549] 1. sequential:
[16:12:26.549]    - args: function (..., envir = parent.frame())
[16:12:26.549]    - tweaked: FALSE
[16:12:26.549]    - call: NULL
[16:12:26.550] plan(): nbrOfWorkers() = 1
[16:12:26.551] plan(): Setting new future strategy stack:
[16:12:26.551] List of future strategies:
[16:12:26.551] 1. sequential:
[16:12:26.551]    - args: function (..., envir = parent.frame())
[16:12:26.551]    - tweaked: FALSE
[16:12:26.551]    - call: plan(strategy)
[16:12:26.552] plan(): nbrOfWorkers() = 1
[16:12:26.552] SequentialFuture started (and completed)
[16:12:26.553] - Launch lazy future ... done
[16:12:26.553] run() for ‘SequentialFuture’ ... done
[16:12:26.553] getGlobalsAndPackages() ...
[16:12:26.553] Searching for globals...
[16:12:26.554] - globals found: [1] ‘{’
[16:12:26.554] Searching for globals ... DONE
[16:12:26.554] Resolving globals: FALSE
[16:12:26.554] 
[16:12:26.554] 
[16:12:26.554] getGlobalsAndPackages() ... DONE
[16:12:26.554] run() for ‘Future’ ...
[16:12:26.554] - state: ‘created’
[16:12:26.555] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.555] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.555] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.555]   - Field: ‘label’
[16:12:26.555]   - Field: ‘local’
[16:12:26.555]   - Field: ‘owner’
[16:12:26.555]   - Field: ‘envir’
[16:12:26.555]   - Field: ‘packages’
[16:12:26.556]   - Field: ‘gc’
[16:12:26.556]   - Field: ‘conditions’
[16:12:26.556]   - Field: ‘expr’
[16:12:26.556]   - Field: ‘uuid’
[16:12:26.556]   - Field: ‘seed’
[16:12:26.556]   - Field: ‘version’
[16:12:26.556]   - Field: ‘result’
[16:12:26.556]   - Field: ‘asynchronous’
[16:12:26.556]   - Field: ‘calls’
[16:12:26.556]   - Field: ‘globals’
[16:12:26.556]   - Field: ‘stdout’
[16:12:26.557]   - Field: ‘earlySignal’
[16:12:26.557]   - Field: ‘lazy’
[16:12:26.557]   - Field: ‘state’
[16:12:26.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.557] - Launch lazy future ...
[16:12:26.557] Packages needed by the future expression (n = 0): <none>
[16:12:26.557] Packages needed by future strategies (n = 0): <none>
[16:12:26.558] {
[16:12:26.558]     {
[16:12:26.558]         {
[16:12:26.558]             ...future.startTime <- base::Sys.time()
[16:12:26.558]             {
[16:12:26.558]                 {
[16:12:26.558]                   {
[16:12:26.558]                     base::local({
[16:12:26.558]                       has_future <- base::requireNamespace("future", 
[16:12:26.558]                         quietly = TRUE)
[16:12:26.558]                       if (has_future) {
[16:12:26.558]                         ns <- base::getNamespace("future")
[16:12:26.558]                         version <- ns[[".package"]][["version"]]
[16:12:26.558]                         if (is.null(version)) 
[16:12:26.558]                           version <- utils::packageVersion("future")
[16:12:26.558]                       }
[16:12:26.558]                       else {
[16:12:26.558]                         version <- NULL
[16:12:26.558]                       }
[16:12:26.558]                       if (!has_future || version < "1.8.0") {
[16:12:26.558]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.558]                           "", base::R.version$version.string), 
[16:12:26.558]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.558]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.558]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.558]                             "release", "version")], collapse = " "), 
[16:12:26.558]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.558]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.558]                           info)
[16:12:26.558]                         info <- base::paste(info, collapse = "; ")
[16:12:26.558]                         if (!has_future) {
[16:12:26.558]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.558]                             info)
[16:12:26.558]                         }
[16:12:26.558]                         else {
[16:12:26.558]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.558]                             info, version)
[16:12:26.558]                         }
[16:12:26.558]                         base::stop(msg)
[16:12:26.558]                       }
[16:12:26.558]                     })
[16:12:26.558]                   }
[16:12:26.558]                   options(future.plan = NULL)
[16:12:26.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.558]                 }
[16:12:26.558]                 ...future.workdir <- getwd()
[16:12:26.558]             }
[16:12:26.558]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.558]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.558]         }
[16:12:26.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.558]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.558]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.558]             base::names(...future.oldOptions))
[16:12:26.558]     }
[16:12:26.558]     if (FALSE) {
[16:12:26.558]     }
[16:12:26.558]     else {
[16:12:26.558]         if (TRUE) {
[16:12:26.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.558]                 open = "w")
[16:12:26.558]         }
[16:12:26.558]         else {
[16:12:26.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.558]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.558]         }
[16:12:26.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.558]             base::sink(type = "output", split = FALSE)
[16:12:26.558]             base::close(...future.stdout)
[16:12:26.558]         }, add = TRUE)
[16:12:26.558]     }
[16:12:26.558]     ...future.frame <- base::sys.nframe()
[16:12:26.558]     ...future.conditions <- base::list()
[16:12:26.558]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.558]     if (FALSE) {
[16:12:26.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.558]     }
[16:12:26.558]     ...future.result <- base::tryCatch({
[16:12:26.558]         base::withCallingHandlers({
[16:12:26.558]             ...future.value <- base::withVisible(base::local({
[16:12:26.558]                 4
[16:12:26.558]             }))
[16:12:26.558]             future::FutureResult(value = ...future.value$value, 
[16:12:26.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.558]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.558]                     ...future.globalenv.names))
[16:12:26.558]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.558]         }, condition = base::local({
[16:12:26.558]             c <- base::c
[16:12:26.558]             inherits <- base::inherits
[16:12:26.558]             invokeRestart <- base::invokeRestart
[16:12:26.558]             length <- base::length
[16:12:26.558]             list <- base::list
[16:12:26.558]             seq.int <- base::seq.int
[16:12:26.558]             signalCondition <- base::signalCondition
[16:12:26.558]             sys.calls <- base::sys.calls
[16:12:26.558]             `[[` <- base::`[[`
[16:12:26.558]             `+` <- base::`+`
[16:12:26.558]             `<<-` <- base::`<<-`
[16:12:26.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.558]                   3L)]
[16:12:26.558]             }
[16:12:26.558]             function(cond) {
[16:12:26.558]                 is_error <- inherits(cond, "error")
[16:12:26.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.558]                   NULL)
[16:12:26.558]                 if (is_error) {
[16:12:26.558]                   sessionInformation <- function() {
[16:12:26.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.558]                       search = base::search(), system = base::Sys.info())
[16:12:26.558]                   }
[16:12:26.558]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.558]                     cond$call), session = sessionInformation(), 
[16:12:26.558]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.558]                   signalCondition(cond)
[16:12:26.558]                 }
[16:12:26.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.558]                 "immediateCondition"))) {
[16:12:26.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.558]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.558]                   if (TRUE && !signal) {
[16:12:26.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.558]                     {
[16:12:26.558]                       inherits <- base::inherits
[16:12:26.558]                       invokeRestart <- base::invokeRestart
[16:12:26.558]                       is.null <- base::is.null
[16:12:26.558]                       muffled <- FALSE
[16:12:26.558]                       if (inherits(cond, "message")) {
[16:12:26.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.558]                         if (muffled) 
[16:12:26.558]                           invokeRestart("muffleMessage")
[16:12:26.558]                       }
[16:12:26.558]                       else if (inherits(cond, "warning")) {
[16:12:26.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.558]                         if (muffled) 
[16:12:26.558]                           invokeRestart("muffleWarning")
[16:12:26.558]                       }
[16:12:26.558]                       else if (inherits(cond, "condition")) {
[16:12:26.558]                         if (!is.null(pattern)) {
[16:12:26.558]                           computeRestarts <- base::computeRestarts
[16:12:26.558]                           grepl <- base::grepl
[16:12:26.558]                           restarts <- computeRestarts(cond)
[16:12:26.558]                           for (restart in restarts) {
[16:12:26.558]                             name <- restart$name
[16:12:26.558]                             if (is.null(name)) 
[16:12:26.558]                               next
[16:12:26.558]                             if (!grepl(pattern, name)) 
[16:12:26.558]                               next
[16:12:26.558]                             invokeRestart(restart)
[16:12:26.558]                             muffled <- TRUE
[16:12:26.558]                             break
[16:12:26.558]                           }
[16:12:26.558]                         }
[16:12:26.558]                       }
[16:12:26.558]                       invisible(muffled)
[16:12:26.558]                     }
[16:12:26.558]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.558]                   }
[16:12:26.558]                 }
[16:12:26.558]                 else {
[16:12:26.558]                   if (TRUE) {
[16:12:26.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.558]                     {
[16:12:26.558]                       inherits <- base::inherits
[16:12:26.558]                       invokeRestart <- base::invokeRestart
[16:12:26.558]                       is.null <- base::is.null
[16:12:26.558]                       muffled <- FALSE
[16:12:26.558]                       if (inherits(cond, "message")) {
[16:12:26.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.558]                         if (muffled) 
[16:12:26.558]                           invokeRestart("muffleMessage")
[16:12:26.558]                       }
[16:12:26.558]                       else if (inherits(cond, "warning")) {
[16:12:26.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.558]                         if (muffled) 
[16:12:26.558]                           invokeRestart("muffleWarning")
[16:12:26.558]                       }
[16:12:26.558]                       else if (inherits(cond, "condition")) {
[16:12:26.558]                         if (!is.null(pattern)) {
[16:12:26.558]                           computeRestarts <- base::computeRestarts
[16:12:26.558]                           grepl <- base::grepl
[16:12:26.558]                           restarts <- computeRestarts(cond)
[16:12:26.558]                           for (restart in restarts) {
[16:12:26.558]                             name <- restart$name
[16:12:26.558]                             if (is.null(name)) 
[16:12:26.558]                               next
[16:12:26.558]                             if (!grepl(pattern, name)) 
[16:12:26.558]                               next
[16:12:26.558]                             invokeRestart(restart)
[16:12:26.558]                             muffled <- TRUE
[16:12:26.558]                             break
[16:12:26.558]                           }
[16:12:26.558]                         }
[16:12:26.558]                       }
[16:12:26.558]                       invisible(muffled)
[16:12:26.558]                     }
[16:12:26.558]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.558]                   }
[16:12:26.558]                 }
[16:12:26.558]             }
[16:12:26.558]         }))
[16:12:26.558]     }, error = function(ex) {
[16:12:26.558]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.558]                 ...future.rng), started = ...future.startTime, 
[16:12:26.558]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.558]             version = "1.8"), class = "FutureResult")
[16:12:26.558]     }, finally = {
[16:12:26.558]         if (!identical(...future.workdir, getwd())) 
[16:12:26.558]             setwd(...future.workdir)
[16:12:26.558]         {
[16:12:26.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.558]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.558]             }
[16:12:26.558]             base::options(...future.oldOptions)
[16:12:26.558]             if (.Platform$OS.type == "windows") {
[16:12:26.558]                 old_names <- names(...future.oldEnvVars)
[16:12:26.558]                 envs <- base::Sys.getenv()
[16:12:26.558]                 names <- names(envs)
[16:12:26.558]                 common <- intersect(names, old_names)
[16:12:26.558]                 added <- setdiff(names, old_names)
[16:12:26.558]                 removed <- setdiff(old_names, names)
[16:12:26.558]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.558]                   envs[common]]
[16:12:26.558]                 NAMES <- toupper(changed)
[16:12:26.558]                 args <- list()
[16:12:26.558]                 for (kk in seq_along(NAMES)) {
[16:12:26.558]                   name <- changed[[kk]]
[16:12:26.558]                   NAME <- NAMES[[kk]]
[16:12:26.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.558]                     next
[16:12:26.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.558]                 }
[16:12:26.558]                 NAMES <- toupper(added)
[16:12:26.558]                 for (kk in seq_along(NAMES)) {
[16:12:26.558]                   name <- added[[kk]]
[16:12:26.558]                   NAME <- NAMES[[kk]]
[16:12:26.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.558]                     next
[16:12:26.558]                   args[[name]] <- ""
[16:12:26.558]                 }
[16:12:26.558]                 NAMES <- toupper(removed)
[16:12:26.558]                 for (kk in seq_along(NAMES)) {
[16:12:26.558]                   name <- removed[[kk]]
[16:12:26.558]                   NAME <- NAMES[[kk]]
[16:12:26.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.558]                     next
[16:12:26.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.558]                 }
[16:12:26.558]                 if (length(args) > 0) 
[16:12:26.558]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.558]             }
[16:12:26.558]             else {
[16:12:26.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.558]             }
[16:12:26.558]             {
[16:12:26.558]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.558]                   0L) {
[16:12:26.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.558]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.558]                   base::options(opts)
[16:12:26.558]                 }
[16:12:26.558]                 {
[16:12:26.558]                   {
[16:12:26.558]                     NULL
[16:12:26.558]                     RNGkind("Mersenne-Twister")
[16:12:26.558]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.558]                       inherits = FALSE)
[16:12:26.558]                   }
[16:12:26.558]                   options(future.plan = NULL)
[16:12:26.558]                   if (is.na(NA_character_)) 
[16:12:26.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.558]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.558]                   {
[16:12:26.558]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.558]                     if (!future$lazy) 
[16:12:26.558]                       future <- run(future)
[16:12:26.558]                     invisible(future)
[16:12:26.558]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.558]                 }
[16:12:26.558]             }
[16:12:26.558]         }
[16:12:26.558]     })
[16:12:26.558]     if (TRUE) {
[16:12:26.558]         base::sink(type = "output", split = FALSE)
[16:12:26.558]         if (TRUE) {
[16:12:26.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.558]         }
[16:12:26.558]         else {
[16:12:26.558]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.558]         }
[16:12:26.558]         base::close(...future.stdout)
[16:12:26.558]         ...future.stdout <- NULL
[16:12:26.558]     }
[16:12:26.558]     ...future.result$conditions <- ...future.conditions
[16:12:26.558]     ...future.result$finished <- base::Sys.time()
[16:12:26.558]     ...future.result
[16:12:26.558] }
[16:12:26.559] plan(): Setting new future strategy stack:
[16:12:26.559] List of future strategies:
[16:12:26.559] 1. sequential:
[16:12:26.559]    - args: function (..., envir = parent.frame())
[16:12:26.559]    - tweaked: FALSE
[16:12:26.559]    - call: NULL
[16:12:26.560] plan(): nbrOfWorkers() = 1
[16:12:26.560] plan(): Setting new future strategy stack:
[16:12:26.560] List of future strategies:
[16:12:26.560] 1. sequential:
[16:12:26.560]    - args: function (..., envir = parent.frame())
[16:12:26.560]    - tweaked: FALSE
[16:12:26.560]    - call: plan(strategy)
[16:12:26.561] plan(): nbrOfWorkers() = 1
[16:12:26.561] SequentialFuture started (and completed)
[16:12:26.561] - Launch lazy future ... done
[16:12:26.561] run() for ‘SequentialFuture’ ... done
<environment: 0x560bae8d3b00> 
<environment: 0x560bae4fe6a0> 
[16:12:26.562] resolved() for ‘SequentialFuture’ ...
[16:12:26.562] - state: ‘finished’
[16:12:26.562] - run: TRUE
[16:12:26.563] - result: ‘FutureResult’
[16:12:26.563] resolved() for ‘SequentialFuture’ ... done
[16:12:26.563] resolved() for ‘SequentialFuture’ ...
[16:12:26.563] - state: ‘finished’
[16:12:26.563] - run: TRUE
[16:12:26.563] - result: ‘FutureResult’
[16:12:26.563] resolved() for ‘SequentialFuture’ ... done
[16:12:26.563] resolved() for ‘SequentialFuture’ ...
[16:12:26.563] - state: ‘finished’
[16:12:26.563] - run: TRUE
[16:12:26.563] - result: ‘FutureResult’
[16:12:26.564] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:26.565] resolve() on environment ...
[16:12:26.565]  recursive: 0
[16:12:26.565]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:26.565] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.565] - nx: 4
[16:12:26.566] - relay: TRUE
[16:12:26.566] - stdout: TRUE
[16:12:26.566] - signal: TRUE
[16:12:26.566] - resignal: FALSE
[16:12:26.566] - force: TRUE
[16:12:26.566] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.566] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.566]  - until=2
[16:12:26.566]  - relaying element #2
[16:12:26.566] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.566] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.566] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.567]  length: 3 (resolved future 1)
[16:12:26.567] resolved() for ‘SequentialFuture’ ...
[16:12:26.567] - state: ‘finished’
[16:12:26.567] - run: TRUE
[16:12:26.567] - result: ‘FutureResult’
[16:12:26.567] resolved() for ‘SequentialFuture’ ... done
[16:12:26.567] Future #2
[16:12:26.567] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.567] - nx: 4
[16:12:26.567] - relay: TRUE
[16:12:26.567] - stdout: TRUE
[16:12:26.568] - signal: TRUE
[16:12:26.568] - resignal: FALSE
[16:12:26.568] - force: TRUE
[16:12:26.568] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.568] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.568]  - until=2
[16:12:26.568]  - relaying element #2
[16:12:26.568] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.568] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.568] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.569]  length: 2 (resolved future 2)
[16:12:26.569] resolved() for ‘SequentialFuture’ ...
[16:12:26.569] - state: ‘finished’
[16:12:26.569] - run: TRUE
[16:12:26.569] - result: ‘FutureResult’
[16:12:26.569] resolved() for ‘SequentialFuture’ ... done
[16:12:26.569] Future #3
[16:12:26.569] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.569] - nx: 4
[16:12:26.569] - relay: TRUE
[16:12:26.569] - stdout: TRUE
[16:12:26.570] - signal: TRUE
[16:12:26.570] - resignal: FALSE
[16:12:26.570] - force: TRUE
[16:12:26.570] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.570] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.570]  - until=3
[16:12:26.570]  - relaying element #3
[16:12:26.570] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.570] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.570] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.570]  length: 1 (resolved future 3)
[16:12:26.571] resolved() for ‘SequentialFuture’ ...
[16:12:26.571] - state: ‘finished’
[16:12:26.571] - run: TRUE
[16:12:26.571] - result: ‘FutureResult’
[16:12:26.571] resolved() for ‘SequentialFuture’ ... done
[16:12:26.571] Future #4
[16:12:26.571] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.571] - nx: 4
[16:12:26.571] - relay: TRUE
[16:12:26.571] - stdout: TRUE
[16:12:26.571] - signal: TRUE
[16:12:26.572] - resignal: FALSE
[16:12:26.572] - force: TRUE
[16:12:26.572] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.572] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.572]  - until=4
[16:12:26.572]  - relaying element #4
[16:12:26.572] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.572] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.572] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.572]  length: 0 (resolved future 4)
[16:12:26.572] Relaying remaining futures
[16:12:26.573] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.573] - nx: 4
[16:12:26.573] - relay: TRUE
[16:12:26.573] - stdout: TRUE
[16:12:26.573] - signal: TRUE
[16:12:26.573] - resignal: FALSE
[16:12:26.573] - force: TRUE
[16:12:26.573] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.573] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:26.573] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.573] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.573] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.574] resolve() on environment ... DONE
<environment: 0x560bae91a260> 
Dimensions: c(2, 3, 1)
[16:12:26.574] getGlobalsAndPackages() ...
[16:12:26.574] Searching for globals...
[16:12:26.574] 
[16:12:26.575] Searching for globals ... DONE
[16:12:26.575] - globals: [0] <none>
[16:12:26.575] getGlobalsAndPackages() ... DONE
[16:12:26.575] run() for ‘Future’ ...
[16:12:26.575] - state: ‘created’
[16:12:26.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.577] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.577]   - Field: ‘label’
[16:12:26.577]   - Field: ‘local’
[16:12:26.577]   - Field: ‘owner’
[16:12:26.577]   - Field: ‘envir’
[16:12:26.577]   - Field: ‘packages’
[16:12:26.577]   - Field: ‘gc’
[16:12:26.578]   - Field: ‘conditions’
[16:12:26.578]   - Field: ‘expr’
[16:12:26.578]   - Field: ‘uuid’
[16:12:26.578]   - Field: ‘seed’
[16:12:26.578]   - Field: ‘version’
[16:12:26.578]   - Field: ‘result’
[16:12:26.578]   - Field: ‘asynchronous’
[16:12:26.578]   - Field: ‘calls’
[16:12:26.578]   - Field: ‘globals’
[16:12:26.578]   - Field: ‘stdout’
[16:12:26.578]   - Field: ‘earlySignal’
[16:12:26.579]   - Field: ‘lazy’
[16:12:26.579]   - Field: ‘state’
[16:12:26.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.579] - Launch lazy future ...
[16:12:26.579] Packages needed by the future expression (n = 0): <none>
[16:12:26.579] Packages needed by future strategies (n = 0): <none>
[16:12:26.580] {
[16:12:26.580]     {
[16:12:26.580]         {
[16:12:26.580]             ...future.startTime <- base::Sys.time()
[16:12:26.580]             {
[16:12:26.580]                 {
[16:12:26.580]                   {
[16:12:26.580]                     base::local({
[16:12:26.580]                       has_future <- base::requireNamespace("future", 
[16:12:26.580]                         quietly = TRUE)
[16:12:26.580]                       if (has_future) {
[16:12:26.580]                         ns <- base::getNamespace("future")
[16:12:26.580]                         version <- ns[[".package"]][["version"]]
[16:12:26.580]                         if (is.null(version)) 
[16:12:26.580]                           version <- utils::packageVersion("future")
[16:12:26.580]                       }
[16:12:26.580]                       else {
[16:12:26.580]                         version <- NULL
[16:12:26.580]                       }
[16:12:26.580]                       if (!has_future || version < "1.8.0") {
[16:12:26.580]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.580]                           "", base::R.version$version.string), 
[16:12:26.580]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.580]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.580]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.580]                             "release", "version")], collapse = " "), 
[16:12:26.580]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.580]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.580]                           info)
[16:12:26.580]                         info <- base::paste(info, collapse = "; ")
[16:12:26.580]                         if (!has_future) {
[16:12:26.580]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.580]                             info)
[16:12:26.580]                         }
[16:12:26.580]                         else {
[16:12:26.580]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.580]                             info, version)
[16:12:26.580]                         }
[16:12:26.580]                         base::stop(msg)
[16:12:26.580]                       }
[16:12:26.580]                     })
[16:12:26.580]                   }
[16:12:26.580]                   options(future.plan = NULL)
[16:12:26.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.580]                 }
[16:12:26.580]                 ...future.workdir <- getwd()
[16:12:26.580]             }
[16:12:26.580]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.580]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.580]         }
[16:12:26.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.580]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.580]             base::names(...future.oldOptions))
[16:12:26.580]     }
[16:12:26.580]     if (FALSE) {
[16:12:26.580]     }
[16:12:26.580]     else {
[16:12:26.580]         if (TRUE) {
[16:12:26.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.580]                 open = "w")
[16:12:26.580]         }
[16:12:26.580]         else {
[16:12:26.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.580]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.580]         }
[16:12:26.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.580]             base::sink(type = "output", split = FALSE)
[16:12:26.580]             base::close(...future.stdout)
[16:12:26.580]         }, add = TRUE)
[16:12:26.580]     }
[16:12:26.580]     ...future.frame <- base::sys.nframe()
[16:12:26.580]     ...future.conditions <- base::list()
[16:12:26.580]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.580]     if (FALSE) {
[16:12:26.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.580]     }
[16:12:26.580]     ...future.result <- base::tryCatch({
[16:12:26.580]         base::withCallingHandlers({
[16:12:26.580]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.580]             future::FutureResult(value = ...future.value$value, 
[16:12:26.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.580]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.580]                     ...future.globalenv.names))
[16:12:26.580]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.580]         }, condition = base::local({
[16:12:26.580]             c <- base::c
[16:12:26.580]             inherits <- base::inherits
[16:12:26.580]             invokeRestart <- base::invokeRestart
[16:12:26.580]             length <- base::length
[16:12:26.580]             list <- base::list
[16:12:26.580]             seq.int <- base::seq.int
[16:12:26.580]             signalCondition <- base::signalCondition
[16:12:26.580]             sys.calls <- base::sys.calls
[16:12:26.580]             `[[` <- base::`[[`
[16:12:26.580]             `+` <- base::`+`
[16:12:26.580]             `<<-` <- base::`<<-`
[16:12:26.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.580]                   3L)]
[16:12:26.580]             }
[16:12:26.580]             function(cond) {
[16:12:26.580]                 is_error <- inherits(cond, "error")
[16:12:26.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.580]                   NULL)
[16:12:26.580]                 if (is_error) {
[16:12:26.580]                   sessionInformation <- function() {
[16:12:26.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.580]                       search = base::search(), system = base::Sys.info())
[16:12:26.580]                   }
[16:12:26.580]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.580]                     cond$call), session = sessionInformation(), 
[16:12:26.580]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.580]                   signalCondition(cond)
[16:12:26.580]                 }
[16:12:26.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.580]                 "immediateCondition"))) {
[16:12:26.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.580]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.580]                   if (TRUE && !signal) {
[16:12:26.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.580]                     {
[16:12:26.580]                       inherits <- base::inherits
[16:12:26.580]                       invokeRestart <- base::invokeRestart
[16:12:26.580]                       is.null <- base::is.null
[16:12:26.580]                       muffled <- FALSE
[16:12:26.580]                       if (inherits(cond, "message")) {
[16:12:26.580]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.580]                         if (muffled) 
[16:12:26.580]                           invokeRestart("muffleMessage")
[16:12:26.580]                       }
[16:12:26.580]                       else if (inherits(cond, "warning")) {
[16:12:26.580]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.580]                         if (muffled) 
[16:12:26.580]                           invokeRestart("muffleWarning")
[16:12:26.580]                       }
[16:12:26.580]                       else if (inherits(cond, "condition")) {
[16:12:26.580]                         if (!is.null(pattern)) {
[16:12:26.580]                           computeRestarts <- base::computeRestarts
[16:12:26.580]                           grepl <- base::grepl
[16:12:26.580]                           restarts <- computeRestarts(cond)
[16:12:26.580]                           for (restart in restarts) {
[16:12:26.580]                             name <- restart$name
[16:12:26.580]                             if (is.null(name)) 
[16:12:26.580]                               next
[16:12:26.580]                             if (!grepl(pattern, name)) 
[16:12:26.580]                               next
[16:12:26.580]                             invokeRestart(restart)
[16:12:26.580]                             muffled <- TRUE
[16:12:26.580]                             break
[16:12:26.580]                           }
[16:12:26.580]                         }
[16:12:26.580]                       }
[16:12:26.580]                       invisible(muffled)
[16:12:26.580]                     }
[16:12:26.580]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.580]                   }
[16:12:26.580]                 }
[16:12:26.580]                 else {
[16:12:26.580]                   if (TRUE) {
[16:12:26.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.580]                     {
[16:12:26.580]                       inherits <- base::inherits
[16:12:26.580]                       invokeRestart <- base::invokeRestart
[16:12:26.580]                       is.null <- base::is.null
[16:12:26.580]                       muffled <- FALSE
[16:12:26.580]                       if (inherits(cond, "message")) {
[16:12:26.580]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.580]                         if (muffled) 
[16:12:26.580]                           invokeRestart("muffleMessage")
[16:12:26.580]                       }
[16:12:26.580]                       else if (inherits(cond, "warning")) {
[16:12:26.580]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.580]                         if (muffled) 
[16:12:26.580]                           invokeRestart("muffleWarning")
[16:12:26.580]                       }
[16:12:26.580]                       else if (inherits(cond, "condition")) {
[16:12:26.580]                         if (!is.null(pattern)) {
[16:12:26.580]                           computeRestarts <- base::computeRestarts
[16:12:26.580]                           grepl <- base::grepl
[16:12:26.580]                           restarts <- computeRestarts(cond)
[16:12:26.580]                           for (restart in restarts) {
[16:12:26.580]                             name <- restart$name
[16:12:26.580]                             if (is.null(name)) 
[16:12:26.580]                               next
[16:12:26.580]                             if (!grepl(pattern, name)) 
[16:12:26.580]                               next
[16:12:26.580]                             invokeRestart(restart)
[16:12:26.580]                             muffled <- TRUE
[16:12:26.580]                             break
[16:12:26.580]                           }
[16:12:26.580]                         }
[16:12:26.580]                       }
[16:12:26.580]                       invisible(muffled)
[16:12:26.580]                     }
[16:12:26.580]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.580]                   }
[16:12:26.580]                 }
[16:12:26.580]             }
[16:12:26.580]         }))
[16:12:26.580]     }, error = function(ex) {
[16:12:26.580]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.580]                 ...future.rng), started = ...future.startTime, 
[16:12:26.580]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.580]             version = "1.8"), class = "FutureResult")
[16:12:26.580]     }, finally = {
[16:12:26.580]         if (!identical(...future.workdir, getwd())) 
[16:12:26.580]             setwd(...future.workdir)
[16:12:26.580]         {
[16:12:26.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.580]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.580]             }
[16:12:26.580]             base::options(...future.oldOptions)
[16:12:26.580]             if (.Platform$OS.type == "windows") {
[16:12:26.580]                 old_names <- names(...future.oldEnvVars)
[16:12:26.580]                 envs <- base::Sys.getenv()
[16:12:26.580]                 names <- names(envs)
[16:12:26.580]                 common <- intersect(names, old_names)
[16:12:26.580]                 added <- setdiff(names, old_names)
[16:12:26.580]                 removed <- setdiff(old_names, names)
[16:12:26.580]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.580]                   envs[common]]
[16:12:26.580]                 NAMES <- toupper(changed)
[16:12:26.580]                 args <- list()
[16:12:26.580]                 for (kk in seq_along(NAMES)) {
[16:12:26.580]                   name <- changed[[kk]]
[16:12:26.580]                   NAME <- NAMES[[kk]]
[16:12:26.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.580]                     next
[16:12:26.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.580]                 }
[16:12:26.580]                 NAMES <- toupper(added)
[16:12:26.580]                 for (kk in seq_along(NAMES)) {
[16:12:26.580]                   name <- added[[kk]]
[16:12:26.580]                   NAME <- NAMES[[kk]]
[16:12:26.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.580]                     next
[16:12:26.580]                   args[[name]] <- ""
[16:12:26.580]                 }
[16:12:26.580]                 NAMES <- toupper(removed)
[16:12:26.580]                 for (kk in seq_along(NAMES)) {
[16:12:26.580]                   name <- removed[[kk]]
[16:12:26.580]                   NAME <- NAMES[[kk]]
[16:12:26.580]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.580]                     next
[16:12:26.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.580]                 }
[16:12:26.580]                 if (length(args) > 0) 
[16:12:26.580]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.580]             }
[16:12:26.580]             else {
[16:12:26.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.580]             }
[16:12:26.580]             {
[16:12:26.580]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.580]                   0L) {
[16:12:26.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.580]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.580]                   base::options(opts)
[16:12:26.580]                 }
[16:12:26.580]                 {
[16:12:26.580]                   {
[16:12:26.580]                     NULL
[16:12:26.580]                     RNGkind("Mersenne-Twister")
[16:12:26.580]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.580]                       inherits = FALSE)
[16:12:26.580]                   }
[16:12:26.580]                   options(future.plan = NULL)
[16:12:26.580]                   if (is.na(NA_character_)) 
[16:12:26.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.580]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.580]                   {
[16:12:26.580]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.580]                     if (!future$lazy) 
[16:12:26.580]                       future <- run(future)
[16:12:26.580]                     invisible(future)
[16:12:26.580]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.580]                 }
[16:12:26.580]             }
[16:12:26.580]         }
[16:12:26.580]     })
[16:12:26.580]     if (TRUE) {
[16:12:26.580]         base::sink(type = "output", split = FALSE)
[16:12:26.580]         if (TRUE) {
[16:12:26.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.580]         }
[16:12:26.580]         else {
[16:12:26.580]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.580]         }
[16:12:26.580]         base::close(...future.stdout)
[16:12:26.580]         ...future.stdout <- NULL
[16:12:26.580]     }
[16:12:26.580]     ...future.result$conditions <- ...future.conditions
[16:12:26.580]     ...future.result$finished <- base::Sys.time()
[16:12:26.580]     ...future.result
[16:12:26.580] }
[16:12:26.581] plan(): Setting new future strategy stack:
[16:12:26.581] List of future strategies:
[16:12:26.581] 1. sequential:
[16:12:26.581]    - args: function (..., envir = parent.frame())
[16:12:26.581]    - tweaked: FALSE
[16:12:26.581]    - call: NULL
[16:12:26.582] plan(): nbrOfWorkers() = 1
[16:12:26.582] plan(): Setting new future strategy stack:
[16:12:26.582] List of future strategies:
[16:12:26.582] 1. sequential:
[16:12:26.582]    - args: function (..., envir = parent.frame())
[16:12:26.582]    - tweaked: FALSE
[16:12:26.582]    - call: plan(strategy)
[16:12:26.583] plan(): nbrOfWorkers() = 1
[16:12:26.583] SequentialFuture started (and completed)
[16:12:26.583] - Launch lazy future ... done
[16:12:26.583] run() for ‘SequentialFuture’ ... done
[16:12:26.583] getGlobalsAndPackages() ...
[16:12:26.583] Searching for globals...
[16:12:26.584] 
[16:12:26.584] Searching for globals ... DONE
[16:12:26.584] - globals: [0] <none>
[16:12:26.584] getGlobalsAndPackages() ... DONE
[16:12:26.584] run() for ‘Future’ ...
[16:12:26.584] - state: ‘created’
[16:12:26.584] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.585]   - Field: ‘label’
[16:12:26.585]   - Field: ‘local’
[16:12:26.585]   - Field: ‘owner’
[16:12:26.585]   - Field: ‘envir’
[16:12:26.585]   - Field: ‘packages’
[16:12:26.585]   - Field: ‘gc’
[16:12:26.585]   - Field: ‘conditions’
[16:12:26.585]   - Field: ‘expr’
[16:12:26.585]   - Field: ‘uuid’
[16:12:26.586]   - Field: ‘seed’
[16:12:26.586]   - Field: ‘version’
[16:12:26.586]   - Field: ‘result’
[16:12:26.586]   - Field: ‘asynchronous’
[16:12:26.586]   - Field: ‘calls’
[16:12:26.586]   - Field: ‘globals’
[16:12:26.586]   - Field: ‘stdout’
[16:12:26.586]   - Field: ‘earlySignal’
[16:12:26.586]   - Field: ‘lazy’
[16:12:26.586]   - Field: ‘state’
[16:12:26.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.587] - Launch lazy future ...
[16:12:26.587] Packages needed by the future expression (n = 0): <none>
[16:12:26.587] Packages needed by future strategies (n = 0): <none>
[16:12:26.587] {
[16:12:26.587]     {
[16:12:26.587]         {
[16:12:26.587]             ...future.startTime <- base::Sys.time()
[16:12:26.587]             {
[16:12:26.587]                 {
[16:12:26.587]                   {
[16:12:26.587]                     base::local({
[16:12:26.587]                       has_future <- base::requireNamespace("future", 
[16:12:26.587]                         quietly = TRUE)
[16:12:26.587]                       if (has_future) {
[16:12:26.587]                         ns <- base::getNamespace("future")
[16:12:26.587]                         version <- ns[[".package"]][["version"]]
[16:12:26.587]                         if (is.null(version)) 
[16:12:26.587]                           version <- utils::packageVersion("future")
[16:12:26.587]                       }
[16:12:26.587]                       else {
[16:12:26.587]                         version <- NULL
[16:12:26.587]                       }
[16:12:26.587]                       if (!has_future || version < "1.8.0") {
[16:12:26.587]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.587]                           "", base::R.version$version.string), 
[16:12:26.587]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.587]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.587]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.587]                             "release", "version")], collapse = " "), 
[16:12:26.587]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.587]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.587]                           info)
[16:12:26.587]                         info <- base::paste(info, collapse = "; ")
[16:12:26.587]                         if (!has_future) {
[16:12:26.587]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.587]                             info)
[16:12:26.587]                         }
[16:12:26.587]                         else {
[16:12:26.587]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.587]                             info, version)
[16:12:26.587]                         }
[16:12:26.587]                         base::stop(msg)
[16:12:26.587]                       }
[16:12:26.587]                     })
[16:12:26.587]                   }
[16:12:26.587]                   options(future.plan = NULL)
[16:12:26.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.587]                 }
[16:12:26.587]                 ...future.workdir <- getwd()
[16:12:26.587]             }
[16:12:26.587]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.587]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.587]         }
[16:12:26.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.587]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.587]             base::names(...future.oldOptions))
[16:12:26.587]     }
[16:12:26.587]     if (FALSE) {
[16:12:26.587]     }
[16:12:26.587]     else {
[16:12:26.587]         if (TRUE) {
[16:12:26.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.587]                 open = "w")
[16:12:26.587]         }
[16:12:26.587]         else {
[16:12:26.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.587]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.587]         }
[16:12:26.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.587]             base::sink(type = "output", split = FALSE)
[16:12:26.587]             base::close(...future.stdout)
[16:12:26.587]         }, add = TRUE)
[16:12:26.587]     }
[16:12:26.587]     ...future.frame <- base::sys.nframe()
[16:12:26.587]     ...future.conditions <- base::list()
[16:12:26.587]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.587]     if (FALSE) {
[16:12:26.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.587]     }
[16:12:26.587]     ...future.result <- base::tryCatch({
[16:12:26.587]         base::withCallingHandlers({
[16:12:26.587]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.587]             future::FutureResult(value = ...future.value$value, 
[16:12:26.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.587]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.587]                     ...future.globalenv.names))
[16:12:26.587]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.587]         }, condition = base::local({
[16:12:26.587]             c <- base::c
[16:12:26.587]             inherits <- base::inherits
[16:12:26.587]             invokeRestart <- base::invokeRestart
[16:12:26.587]             length <- base::length
[16:12:26.587]             list <- base::list
[16:12:26.587]             seq.int <- base::seq.int
[16:12:26.587]             signalCondition <- base::signalCondition
[16:12:26.587]             sys.calls <- base::sys.calls
[16:12:26.587]             `[[` <- base::`[[`
[16:12:26.587]             `+` <- base::`+`
[16:12:26.587]             `<<-` <- base::`<<-`
[16:12:26.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.587]                   3L)]
[16:12:26.587]             }
[16:12:26.587]             function(cond) {
[16:12:26.587]                 is_error <- inherits(cond, "error")
[16:12:26.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.587]                   NULL)
[16:12:26.587]                 if (is_error) {
[16:12:26.587]                   sessionInformation <- function() {
[16:12:26.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.587]                       search = base::search(), system = base::Sys.info())
[16:12:26.587]                   }
[16:12:26.587]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.587]                     cond$call), session = sessionInformation(), 
[16:12:26.587]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.587]                   signalCondition(cond)
[16:12:26.587]                 }
[16:12:26.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.587]                 "immediateCondition"))) {
[16:12:26.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.587]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.587]                   if (TRUE && !signal) {
[16:12:26.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.587]                     {
[16:12:26.587]                       inherits <- base::inherits
[16:12:26.587]                       invokeRestart <- base::invokeRestart
[16:12:26.587]                       is.null <- base::is.null
[16:12:26.587]                       muffled <- FALSE
[16:12:26.587]                       if (inherits(cond, "message")) {
[16:12:26.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.587]                         if (muffled) 
[16:12:26.587]                           invokeRestart("muffleMessage")
[16:12:26.587]                       }
[16:12:26.587]                       else if (inherits(cond, "warning")) {
[16:12:26.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.587]                         if (muffled) 
[16:12:26.587]                           invokeRestart("muffleWarning")
[16:12:26.587]                       }
[16:12:26.587]                       else if (inherits(cond, "condition")) {
[16:12:26.587]                         if (!is.null(pattern)) {
[16:12:26.587]                           computeRestarts <- base::computeRestarts
[16:12:26.587]                           grepl <- base::grepl
[16:12:26.587]                           restarts <- computeRestarts(cond)
[16:12:26.587]                           for (restart in restarts) {
[16:12:26.587]                             name <- restart$name
[16:12:26.587]                             if (is.null(name)) 
[16:12:26.587]                               next
[16:12:26.587]                             if (!grepl(pattern, name)) 
[16:12:26.587]                               next
[16:12:26.587]                             invokeRestart(restart)
[16:12:26.587]                             muffled <- TRUE
[16:12:26.587]                             break
[16:12:26.587]                           }
[16:12:26.587]                         }
[16:12:26.587]                       }
[16:12:26.587]                       invisible(muffled)
[16:12:26.587]                     }
[16:12:26.587]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.587]                   }
[16:12:26.587]                 }
[16:12:26.587]                 else {
[16:12:26.587]                   if (TRUE) {
[16:12:26.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.587]                     {
[16:12:26.587]                       inherits <- base::inherits
[16:12:26.587]                       invokeRestart <- base::invokeRestart
[16:12:26.587]                       is.null <- base::is.null
[16:12:26.587]                       muffled <- FALSE
[16:12:26.587]                       if (inherits(cond, "message")) {
[16:12:26.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.587]                         if (muffled) 
[16:12:26.587]                           invokeRestart("muffleMessage")
[16:12:26.587]                       }
[16:12:26.587]                       else if (inherits(cond, "warning")) {
[16:12:26.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.587]                         if (muffled) 
[16:12:26.587]                           invokeRestart("muffleWarning")
[16:12:26.587]                       }
[16:12:26.587]                       else if (inherits(cond, "condition")) {
[16:12:26.587]                         if (!is.null(pattern)) {
[16:12:26.587]                           computeRestarts <- base::computeRestarts
[16:12:26.587]                           grepl <- base::grepl
[16:12:26.587]                           restarts <- computeRestarts(cond)
[16:12:26.587]                           for (restart in restarts) {
[16:12:26.587]                             name <- restart$name
[16:12:26.587]                             if (is.null(name)) 
[16:12:26.587]                               next
[16:12:26.587]                             if (!grepl(pattern, name)) 
[16:12:26.587]                               next
[16:12:26.587]                             invokeRestart(restart)
[16:12:26.587]                             muffled <- TRUE
[16:12:26.587]                             break
[16:12:26.587]                           }
[16:12:26.587]                         }
[16:12:26.587]                       }
[16:12:26.587]                       invisible(muffled)
[16:12:26.587]                     }
[16:12:26.587]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.587]                   }
[16:12:26.587]                 }
[16:12:26.587]             }
[16:12:26.587]         }))
[16:12:26.587]     }, error = function(ex) {
[16:12:26.587]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.587]                 ...future.rng), started = ...future.startTime, 
[16:12:26.587]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.587]             version = "1.8"), class = "FutureResult")
[16:12:26.587]     }, finally = {
[16:12:26.587]         if (!identical(...future.workdir, getwd())) 
[16:12:26.587]             setwd(...future.workdir)
[16:12:26.587]         {
[16:12:26.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.587]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.587]             }
[16:12:26.587]             base::options(...future.oldOptions)
[16:12:26.587]             if (.Platform$OS.type == "windows") {
[16:12:26.587]                 old_names <- names(...future.oldEnvVars)
[16:12:26.587]                 envs <- base::Sys.getenv()
[16:12:26.587]                 names <- names(envs)
[16:12:26.587]                 common <- intersect(names, old_names)
[16:12:26.587]                 added <- setdiff(names, old_names)
[16:12:26.587]                 removed <- setdiff(old_names, names)
[16:12:26.587]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.587]                   envs[common]]
[16:12:26.587]                 NAMES <- toupper(changed)
[16:12:26.587]                 args <- list()
[16:12:26.587]                 for (kk in seq_along(NAMES)) {
[16:12:26.587]                   name <- changed[[kk]]
[16:12:26.587]                   NAME <- NAMES[[kk]]
[16:12:26.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.587]                     next
[16:12:26.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.587]                 }
[16:12:26.587]                 NAMES <- toupper(added)
[16:12:26.587]                 for (kk in seq_along(NAMES)) {
[16:12:26.587]                   name <- added[[kk]]
[16:12:26.587]                   NAME <- NAMES[[kk]]
[16:12:26.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.587]                     next
[16:12:26.587]                   args[[name]] <- ""
[16:12:26.587]                 }
[16:12:26.587]                 NAMES <- toupper(removed)
[16:12:26.587]                 for (kk in seq_along(NAMES)) {
[16:12:26.587]                   name <- removed[[kk]]
[16:12:26.587]                   NAME <- NAMES[[kk]]
[16:12:26.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.587]                     next
[16:12:26.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.587]                 }
[16:12:26.587]                 if (length(args) > 0) 
[16:12:26.587]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.587]             }
[16:12:26.587]             else {
[16:12:26.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.587]             }
[16:12:26.587]             {
[16:12:26.587]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.587]                   0L) {
[16:12:26.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.587]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.587]                   base::options(opts)
[16:12:26.587]                 }
[16:12:26.587]                 {
[16:12:26.587]                   {
[16:12:26.587]                     NULL
[16:12:26.587]                     RNGkind("Mersenne-Twister")
[16:12:26.587]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.587]                       inherits = FALSE)
[16:12:26.587]                   }
[16:12:26.587]                   options(future.plan = NULL)
[16:12:26.587]                   if (is.na(NA_character_)) 
[16:12:26.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.587]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.587]                   {
[16:12:26.587]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.587]                     if (!future$lazy) 
[16:12:26.587]                       future <- run(future)
[16:12:26.587]                     invisible(future)
[16:12:26.587]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.587]                 }
[16:12:26.587]             }
[16:12:26.587]         }
[16:12:26.587]     })
[16:12:26.587]     if (TRUE) {
[16:12:26.587]         base::sink(type = "output", split = FALSE)
[16:12:26.587]         if (TRUE) {
[16:12:26.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.587]         }
[16:12:26.587]         else {
[16:12:26.587]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.587]         }
[16:12:26.587]         base::close(...future.stdout)
[16:12:26.587]         ...future.stdout <- NULL
[16:12:26.587]     }
[16:12:26.587]     ...future.result$conditions <- ...future.conditions
[16:12:26.587]     ...future.result$finished <- base::Sys.time()
[16:12:26.587]     ...future.result
[16:12:26.587] }
[16:12:26.589] plan(): Setting new future strategy stack:
[16:12:26.589] List of future strategies:
[16:12:26.589] 1. sequential:
[16:12:26.589]    - args: function (..., envir = parent.frame())
[16:12:26.589]    - tweaked: FALSE
[16:12:26.589]    - call: NULL
[16:12:26.589] plan(): nbrOfWorkers() = 1
[16:12:26.590] plan(): Setting new future strategy stack:
[16:12:26.590] List of future strategies:
[16:12:26.590] 1. sequential:
[16:12:26.590]    - args: function (..., envir = parent.frame())
[16:12:26.590]    - tweaked: FALSE
[16:12:26.590]    - call: plan(strategy)
[16:12:26.590] plan(): nbrOfWorkers() = 1
[16:12:26.591] SequentialFuture started (and completed)
[16:12:26.591] - Launch lazy future ... done
[16:12:26.591] run() for ‘SequentialFuture’ ... done
[16:12:26.591] getGlobalsAndPackages() ...
[16:12:26.591] Searching for globals...
[16:12:26.592] - globals found: [1] ‘{’
[16:12:26.592] Searching for globals ... DONE
[16:12:26.592] Resolving globals: FALSE
[16:12:26.592] 
[16:12:26.592] 
[16:12:26.592] getGlobalsAndPackages() ... DONE
[16:12:26.593] run() for ‘Future’ ...
[16:12:26.593] - state: ‘created’
[16:12:26.593] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.593] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.593]   - Field: ‘label’
[16:12:26.593]   - Field: ‘local’
[16:12:26.593]   - Field: ‘owner’
[16:12:26.593]   - Field: ‘envir’
[16:12:26.594]   - Field: ‘packages’
[16:12:26.594]   - Field: ‘gc’
[16:12:26.594]   - Field: ‘conditions’
[16:12:26.594]   - Field: ‘expr’
[16:12:26.594]   - Field: ‘uuid’
[16:12:26.594]   - Field: ‘seed’
[16:12:26.594]   - Field: ‘version’
[16:12:26.594]   - Field: ‘result’
[16:12:26.594]   - Field: ‘asynchronous’
[16:12:26.594]   - Field: ‘calls’
[16:12:26.594]   - Field: ‘globals’
[16:12:26.594]   - Field: ‘stdout’
[16:12:26.595]   - Field: ‘earlySignal’
[16:12:26.595]   - Field: ‘lazy’
[16:12:26.595]   - Field: ‘state’
[16:12:26.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.595] - Launch lazy future ...
[16:12:26.595] Packages needed by the future expression (n = 0): <none>
[16:12:26.595] Packages needed by future strategies (n = 0): <none>
[16:12:26.596] {
[16:12:26.596]     {
[16:12:26.596]         {
[16:12:26.596]             ...future.startTime <- base::Sys.time()
[16:12:26.596]             {
[16:12:26.596]                 {
[16:12:26.596]                   {
[16:12:26.596]                     base::local({
[16:12:26.596]                       has_future <- base::requireNamespace("future", 
[16:12:26.596]                         quietly = TRUE)
[16:12:26.596]                       if (has_future) {
[16:12:26.596]                         ns <- base::getNamespace("future")
[16:12:26.596]                         version <- ns[[".package"]][["version"]]
[16:12:26.596]                         if (is.null(version)) 
[16:12:26.596]                           version <- utils::packageVersion("future")
[16:12:26.596]                       }
[16:12:26.596]                       else {
[16:12:26.596]                         version <- NULL
[16:12:26.596]                       }
[16:12:26.596]                       if (!has_future || version < "1.8.0") {
[16:12:26.596]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.596]                           "", base::R.version$version.string), 
[16:12:26.596]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.596]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.596]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.596]                             "release", "version")], collapse = " "), 
[16:12:26.596]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.596]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.596]                           info)
[16:12:26.596]                         info <- base::paste(info, collapse = "; ")
[16:12:26.596]                         if (!has_future) {
[16:12:26.596]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.596]                             info)
[16:12:26.596]                         }
[16:12:26.596]                         else {
[16:12:26.596]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.596]                             info, version)
[16:12:26.596]                         }
[16:12:26.596]                         base::stop(msg)
[16:12:26.596]                       }
[16:12:26.596]                     })
[16:12:26.596]                   }
[16:12:26.596]                   options(future.plan = NULL)
[16:12:26.596]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.596]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.596]                 }
[16:12:26.596]                 ...future.workdir <- getwd()
[16:12:26.596]             }
[16:12:26.596]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.596]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.596]         }
[16:12:26.596]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.596]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.596]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.596]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.596]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.596]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.596]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.596]             base::names(...future.oldOptions))
[16:12:26.596]     }
[16:12:26.596]     if (FALSE) {
[16:12:26.596]     }
[16:12:26.596]     else {
[16:12:26.596]         if (TRUE) {
[16:12:26.596]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.596]                 open = "w")
[16:12:26.596]         }
[16:12:26.596]         else {
[16:12:26.596]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.596]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.596]         }
[16:12:26.596]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.596]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.596]             base::sink(type = "output", split = FALSE)
[16:12:26.596]             base::close(...future.stdout)
[16:12:26.596]         }, add = TRUE)
[16:12:26.596]     }
[16:12:26.596]     ...future.frame <- base::sys.nframe()
[16:12:26.596]     ...future.conditions <- base::list()
[16:12:26.596]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.596]     if (FALSE) {
[16:12:26.596]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.596]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.596]     }
[16:12:26.596]     ...future.result <- base::tryCatch({
[16:12:26.596]         base::withCallingHandlers({
[16:12:26.596]             ...future.value <- base::withVisible(base::local({
[16:12:26.596]                 4
[16:12:26.596]             }))
[16:12:26.596]             future::FutureResult(value = ...future.value$value, 
[16:12:26.596]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.596]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.596]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.596]                     ...future.globalenv.names))
[16:12:26.596]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.596]         }, condition = base::local({
[16:12:26.596]             c <- base::c
[16:12:26.596]             inherits <- base::inherits
[16:12:26.596]             invokeRestart <- base::invokeRestart
[16:12:26.596]             length <- base::length
[16:12:26.596]             list <- base::list
[16:12:26.596]             seq.int <- base::seq.int
[16:12:26.596]             signalCondition <- base::signalCondition
[16:12:26.596]             sys.calls <- base::sys.calls
[16:12:26.596]             `[[` <- base::`[[`
[16:12:26.596]             `+` <- base::`+`
[16:12:26.596]             `<<-` <- base::`<<-`
[16:12:26.596]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.596]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.596]                   3L)]
[16:12:26.596]             }
[16:12:26.596]             function(cond) {
[16:12:26.596]                 is_error <- inherits(cond, "error")
[16:12:26.596]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.596]                   NULL)
[16:12:26.596]                 if (is_error) {
[16:12:26.596]                   sessionInformation <- function() {
[16:12:26.596]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.596]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.596]                       search = base::search(), system = base::Sys.info())
[16:12:26.596]                   }
[16:12:26.596]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.596]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.596]                     cond$call), session = sessionInformation(), 
[16:12:26.596]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.596]                   signalCondition(cond)
[16:12:26.596]                 }
[16:12:26.596]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.596]                 "immediateCondition"))) {
[16:12:26.596]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.596]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.596]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.596]                   if (TRUE && !signal) {
[16:12:26.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.596]                     {
[16:12:26.596]                       inherits <- base::inherits
[16:12:26.596]                       invokeRestart <- base::invokeRestart
[16:12:26.596]                       is.null <- base::is.null
[16:12:26.596]                       muffled <- FALSE
[16:12:26.596]                       if (inherits(cond, "message")) {
[16:12:26.596]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.596]                         if (muffled) 
[16:12:26.596]                           invokeRestart("muffleMessage")
[16:12:26.596]                       }
[16:12:26.596]                       else if (inherits(cond, "warning")) {
[16:12:26.596]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.596]                         if (muffled) 
[16:12:26.596]                           invokeRestart("muffleWarning")
[16:12:26.596]                       }
[16:12:26.596]                       else if (inherits(cond, "condition")) {
[16:12:26.596]                         if (!is.null(pattern)) {
[16:12:26.596]                           computeRestarts <- base::computeRestarts
[16:12:26.596]                           grepl <- base::grepl
[16:12:26.596]                           restarts <- computeRestarts(cond)
[16:12:26.596]                           for (restart in restarts) {
[16:12:26.596]                             name <- restart$name
[16:12:26.596]                             if (is.null(name)) 
[16:12:26.596]                               next
[16:12:26.596]                             if (!grepl(pattern, name)) 
[16:12:26.596]                               next
[16:12:26.596]                             invokeRestart(restart)
[16:12:26.596]                             muffled <- TRUE
[16:12:26.596]                             break
[16:12:26.596]                           }
[16:12:26.596]                         }
[16:12:26.596]                       }
[16:12:26.596]                       invisible(muffled)
[16:12:26.596]                     }
[16:12:26.596]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.596]                   }
[16:12:26.596]                 }
[16:12:26.596]                 else {
[16:12:26.596]                   if (TRUE) {
[16:12:26.596]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.596]                     {
[16:12:26.596]                       inherits <- base::inherits
[16:12:26.596]                       invokeRestart <- base::invokeRestart
[16:12:26.596]                       is.null <- base::is.null
[16:12:26.596]                       muffled <- FALSE
[16:12:26.596]                       if (inherits(cond, "message")) {
[16:12:26.596]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.596]                         if (muffled) 
[16:12:26.596]                           invokeRestart("muffleMessage")
[16:12:26.596]                       }
[16:12:26.596]                       else if (inherits(cond, "warning")) {
[16:12:26.596]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.596]                         if (muffled) 
[16:12:26.596]                           invokeRestart("muffleWarning")
[16:12:26.596]                       }
[16:12:26.596]                       else if (inherits(cond, "condition")) {
[16:12:26.596]                         if (!is.null(pattern)) {
[16:12:26.596]                           computeRestarts <- base::computeRestarts
[16:12:26.596]                           grepl <- base::grepl
[16:12:26.596]                           restarts <- computeRestarts(cond)
[16:12:26.596]                           for (restart in restarts) {
[16:12:26.596]                             name <- restart$name
[16:12:26.596]                             if (is.null(name)) 
[16:12:26.596]                               next
[16:12:26.596]                             if (!grepl(pattern, name)) 
[16:12:26.596]                               next
[16:12:26.596]                             invokeRestart(restart)
[16:12:26.596]                             muffled <- TRUE
[16:12:26.596]                             break
[16:12:26.596]                           }
[16:12:26.596]                         }
[16:12:26.596]                       }
[16:12:26.596]                       invisible(muffled)
[16:12:26.596]                     }
[16:12:26.596]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.596]                   }
[16:12:26.596]                 }
[16:12:26.596]             }
[16:12:26.596]         }))
[16:12:26.596]     }, error = function(ex) {
[16:12:26.596]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.596]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.596]                 ...future.rng), started = ...future.startTime, 
[16:12:26.596]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.596]             version = "1.8"), class = "FutureResult")
[16:12:26.596]     }, finally = {
[16:12:26.596]         if (!identical(...future.workdir, getwd())) 
[16:12:26.596]             setwd(...future.workdir)
[16:12:26.596]         {
[16:12:26.596]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.596]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.596]             }
[16:12:26.596]             base::options(...future.oldOptions)
[16:12:26.596]             if (.Platform$OS.type == "windows") {
[16:12:26.596]                 old_names <- names(...future.oldEnvVars)
[16:12:26.596]                 envs <- base::Sys.getenv()
[16:12:26.596]                 names <- names(envs)
[16:12:26.596]                 common <- intersect(names, old_names)
[16:12:26.596]                 added <- setdiff(names, old_names)
[16:12:26.596]                 removed <- setdiff(old_names, names)
[16:12:26.596]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.596]                   envs[common]]
[16:12:26.596]                 NAMES <- toupper(changed)
[16:12:26.596]                 args <- list()
[16:12:26.596]                 for (kk in seq_along(NAMES)) {
[16:12:26.596]                   name <- changed[[kk]]
[16:12:26.596]                   NAME <- NAMES[[kk]]
[16:12:26.596]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.596]                     next
[16:12:26.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.596]                 }
[16:12:26.596]                 NAMES <- toupper(added)
[16:12:26.596]                 for (kk in seq_along(NAMES)) {
[16:12:26.596]                   name <- added[[kk]]
[16:12:26.596]                   NAME <- NAMES[[kk]]
[16:12:26.596]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.596]                     next
[16:12:26.596]                   args[[name]] <- ""
[16:12:26.596]                 }
[16:12:26.596]                 NAMES <- toupper(removed)
[16:12:26.596]                 for (kk in seq_along(NAMES)) {
[16:12:26.596]                   name <- removed[[kk]]
[16:12:26.596]                   NAME <- NAMES[[kk]]
[16:12:26.596]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.596]                     next
[16:12:26.596]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.596]                 }
[16:12:26.596]                 if (length(args) > 0) 
[16:12:26.596]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.596]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.596]             }
[16:12:26.596]             else {
[16:12:26.596]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.596]             }
[16:12:26.596]             {
[16:12:26.596]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.596]                   0L) {
[16:12:26.596]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.596]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.596]                   base::options(opts)
[16:12:26.596]                 }
[16:12:26.596]                 {
[16:12:26.596]                   {
[16:12:26.596]                     NULL
[16:12:26.596]                     RNGkind("Mersenne-Twister")
[16:12:26.596]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.596]                       inherits = FALSE)
[16:12:26.596]                   }
[16:12:26.596]                   options(future.plan = NULL)
[16:12:26.596]                   if (is.na(NA_character_)) 
[16:12:26.596]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.596]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.596]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.596]                   {
[16:12:26.596]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.596]                     if (!future$lazy) 
[16:12:26.596]                       future <- run(future)
[16:12:26.596]                     invisible(future)
[16:12:26.596]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.596]                 }
[16:12:26.596]             }
[16:12:26.596]         }
[16:12:26.596]     })
[16:12:26.596]     if (TRUE) {
[16:12:26.596]         base::sink(type = "output", split = FALSE)
[16:12:26.596]         if (TRUE) {
[16:12:26.596]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.596]         }
[16:12:26.596]         else {
[16:12:26.596]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.596]         }
[16:12:26.596]         base::close(...future.stdout)
[16:12:26.596]         ...future.stdout <- NULL
[16:12:26.596]     }
[16:12:26.596]     ...future.result$conditions <- ...future.conditions
[16:12:26.596]     ...future.result$finished <- base::Sys.time()
[16:12:26.596]     ...future.result
[16:12:26.596] }
[16:12:26.597] plan(): Setting new future strategy stack:
[16:12:26.597] List of future strategies:
[16:12:26.597] 1. sequential:
[16:12:26.597]    - args: function (..., envir = parent.frame())
[16:12:26.597]    - tweaked: FALSE
[16:12:26.597]    - call: NULL
[16:12:26.598] plan(): nbrOfWorkers() = 1
[16:12:26.598] plan(): Setting new future strategy stack:
[16:12:26.598] List of future strategies:
[16:12:26.598] 1. sequential:
[16:12:26.598]    - args: function (..., envir = parent.frame())
[16:12:26.598]    - tweaked: FALSE
[16:12:26.598]    - call: plan(strategy)
[16:12:26.599] plan(): nbrOfWorkers() = 1
[16:12:26.599] SequentialFuture started (and completed)
[16:12:26.599] - Launch lazy future ... done
[16:12:26.599] run() for ‘SequentialFuture’ ... done
<environment: 0x560baefb9500> 
<environment: 0x560baee257d0> 
[16:12:26.600] resolved() for ‘SequentialFuture’ ...
[16:12:26.600] - state: ‘finished’
[16:12:26.601] - run: TRUE
[16:12:26.601] - result: ‘FutureResult’
[16:12:26.601] resolved() for ‘SequentialFuture’ ... done
[16:12:26.601] resolved() for ‘SequentialFuture’ ...
[16:12:26.601] - state: ‘finished’
[16:12:26.601] - run: TRUE
[16:12:26.601] - result: ‘FutureResult’
[16:12:26.601] resolved() for ‘SequentialFuture’ ... done
[16:12:26.601] resolved() for ‘SequentialFuture’ ...
[16:12:26.601] - state: ‘finished’
[16:12:26.601] - run: TRUE
[16:12:26.602] - result: ‘FutureResult’
[16:12:26.602] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:26.603] resolve() on environment ...
[16:12:26.603]  recursive: 0
[16:12:26.605]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:26.605] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.605] - nx: 4
[16:12:26.605] - relay: TRUE
[16:12:26.605] - stdout: TRUE
[16:12:26.605] - signal: TRUE
[16:12:26.605] - resignal: FALSE
[16:12:26.605] - force: TRUE
[16:12:26.605] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.605] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.605]  - until=2
[16:12:26.605]  - relaying element #2
[16:12:26.606] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.606] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.606] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.606]  length: 3 (resolved future 1)
[16:12:26.606] resolved() for ‘SequentialFuture’ ...
[16:12:26.606] - state: ‘finished’
[16:12:26.606] - run: TRUE
[16:12:26.606] - result: ‘FutureResult’
[16:12:26.606] resolved() for ‘SequentialFuture’ ... done
[16:12:26.606] Future #2
[16:12:26.607] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.607] - nx: 4
[16:12:26.607] - relay: TRUE
[16:12:26.607] - stdout: TRUE
[16:12:26.607] - signal: TRUE
[16:12:26.607] - resignal: FALSE
[16:12:26.607] - force: TRUE
[16:12:26.607] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.607] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.607]  - until=2
[16:12:26.607]  - relaying element #2
[16:12:26.608] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.608] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.608] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.608]  length: 2 (resolved future 2)
[16:12:26.608] resolved() for ‘SequentialFuture’ ...
[16:12:26.608] - state: ‘finished’
[16:12:26.608] - run: TRUE
[16:12:26.608] - result: ‘FutureResult’
[16:12:26.608] resolved() for ‘SequentialFuture’ ... done
[16:12:26.608] Future #3
[16:12:26.609] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.609] - nx: 4
[16:12:26.609] - relay: TRUE
[16:12:26.609] - stdout: TRUE
[16:12:26.609] - signal: TRUE
[16:12:26.609] - resignal: FALSE
[16:12:26.609] - force: TRUE
[16:12:26.609] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.609] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.609]  - until=3
[16:12:26.609]  - relaying element #3
[16:12:26.609] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.610] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.610] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.610]  length: 1 (resolved future 3)
[16:12:26.610] resolved() for ‘SequentialFuture’ ...
[16:12:26.610] - state: ‘finished’
[16:12:26.610] - run: TRUE
[16:12:26.610] - result: ‘FutureResult’
[16:12:26.610] resolved() for ‘SequentialFuture’ ... done
[16:12:26.610] Future #4
[16:12:26.610] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.611] - nx: 4
[16:12:26.611] - relay: TRUE
[16:12:26.611] - stdout: TRUE
[16:12:26.611] - signal: TRUE
[16:12:26.611] - resignal: FALSE
[16:12:26.611] - force: TRUE
[16:12:26.611] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.611] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.611]  - until=4
[16:12:26.611]  - relaying element #4
[16:12:26.611] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.611] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.612] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.612]  length: 0 (resolved future 4)
[16:12:26.612] Relaying remaining futures
[16:12:26.612] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.612] - nx: 4
[16:12:26.612] - relay: TRUE
[16:12:26.612] - stdout: TRUE
[16:12:26.612] - signal: TRUE
[16:12:26.612] - resignal: FALSE
[16:12:26.612] - force: TRUE
[16:12:26.612] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.612] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:26.613] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.613] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.613] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.613] resolve() on environment ... DONE
<environment: 0x560baeff2328> 
Dimensions: c(2, 1, 3, 1)
[16:12:26.613] getGlobalsAndPackages() ...
[16:12:26.613] Searching for globals...
[16:12:26.614] 
[16:12:26.614] Searching for globals ... DONE
[16:12:26.614] - globals: [0] <none>
[16:12:26.614] getGlobalsAndPackages() ... DONE
[16:12:26.614] run() for ‘Future’ ...
[16:12:26.614] - state: ‘created’
[16:12:26.614] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.615] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.615]   - Field: ‘label’
[16:12:26.615]   - Field: ‘local’
[16:12:26.615]   - Field: ‘owner’
[16:12:26.615]   - Field: ‘envir’
[16:12:26.615]   - Field: ‘packages’
[16:12:26.615]   - Field: ‘gc’
[16:12:26.615]   - Field: ‘conditions’
[16:12:26.615]   - Field: ‘expr’
[16:12:26.616]   - Field: ‘uuid’
[16:12:26.616]   - Field: ‘seed’
[16:12:26.616]   - Field: ‘version’
[16:12:26.616]   - Field: ‘result’
[16:12:26.616]   - Field: ‘asynchronous’
[16:12:26.616]   - Field: ‘calls’
[16:12:26.616]   - Field: ‘globals’
[16:12:26.616]   - Field: ‘stdout’
[16:12:26.616]   - Field: ‘earlySignal’
[16:12:26.616]   - Field: ‘lazy’
[16:12:26.616]   - Field: ‘state’
[16:12:26.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.617] - Launch lazy future ...
[16:12:26.617] Packages needed by the future expression (n = 0): <none>
[16:12:26.617] Packages needed by future strategies (n = 0): <none>
[16:12:26.617] {
[16:12:26.617]     {
[16:12:26.617]         {
[16:12:26.617]             ...future.startTime <- base::Sys.time()
[16:12:26.617]             {
[16:12:26.617]                 {
[16:12:26.617]                   {
[16:12:26.617]                     base::local({
[16:12:26.617]                       has_future <- base::requireNamespace("future", 
[16:12:26.617]                         quietly = TRUE)
[16:12:26.617]                       if (has_future) {
[16:12:26.617]                         ns <- base::getNamespace("future")
[16:12:26.617]                         version <- ns[[".package"]][["version"]]
[16:12:26.617]                         if (is.null(version)) 
[16:12:26.617]                           version <- utils::packageVersion("future")
[16:12:26.617]                       }
[16:12:26.617]                       else {
[16:12:26.617]                         version <- NULL
[16:12:26.617]                       }
[16:12:26.617]                       if (!has_future || version < "1.8.0") {
[16:12:26.617]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.617]                           "", base::R.version$version.string), 
[16:12:26.617]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.617]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.617]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.617]                             "release", "version")], collapse = " "), 
[16:12:26.617]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.617]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.617]                           info)
[16:12:26.617]                         info <- base::paste(info, collapse = "; ")
[16:12:26.617]                         if (!has_future) {
[16:12:26.617]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.617]                             info)
[16:12:26.617]                         }
[16:12:26.617]                         else {
[16:12:26.617]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.617]                             info, version)
[16:12:26.617]                         }
[16:12:26.617]                         base::stop(msg)
[16:12:26.617]                       }
[16:12:26.617]                     })
[16:12:26.617]                   }
[16:12:26.617]                   options(future.plan = NULL)
[16:12:26.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.617]                 }
[16:12:26.617]                 ...future.workdir <- getwd()
[16:12:26.617]             }
[16:12:26.617]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.617]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.617]         }
[16:12:26.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.617]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.617]             base::names(...future.oldOptions))
[16:12:26.617]     }
[16:12:26.617]     if (FALSE) {
[16:12:26.617]     }
[16:12:26.617]     else {
[16:12:26.617]         if (TRUE) {
[16:12:26.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.617]                 open = "w")
[16:12:26.617]         }
[16:12:26.617]         else {
[16:12:26.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.617]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.617]         }
[16:12:26.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.617]             base::sink(type = "output", split = FALSE)
[16:12:26.617]             base::close(...future.stdout)
[16:12:26.617]         }, add = TRUE)
[16:12:26.617]     }
[16:12:26.617]     ...future.frame <- base::sys.nframe()
[16:12:26.617]     ...future.conditions <- base::list()
[16:12:26.617]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.617]     if (FALSE) {
[16:12:26.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.617]     }
[16:12:26.617]     ...future.result <- base::tryCatch({
[16:12:26.617]         base::withCallingHandlers({
[16:12:26.617]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.617]             future::FutureResult(value = ...future.value$value, 
[16:12:26.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.617]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.617]                     ...future.globalenv.names))
[16:12:26.617]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.617]         }, condition = base::local({
[16:12:26.617]             c <- base::c
[16:12:26.617]             inherits <- base::inherits
[16:12:26.617]             invokeRestart <- base::invokeRestart
[16:12:26.617]             length <- base::length
[16:12:26.617]             list <- base::list
[16:12:26.617]             seq.int <- base::seq.int
[16:12:26.617]             signalCondition <- base::signalCondition
[16:12:26.617]             sys.calls <- base::sys.calls
[16:12:26.617]             `[[` <- base::`[[`
[16:12:26.617]             `+` <- base::`+`
[16:12:26.617]             `<<-` <- base::`<<-`
[16:12:26.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.617]                   3L)]
[16:12:26.617]             }
[16:12:26.617]             function(cond) {
[16:12:26.617]                 is_error <- inherits(cond, "error")
[16:12:26.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.617]                   NULL)
[16:12:26.617]                 if (is_error) {
[16:12:26.617]                   sessionInformation <- function() {
[16:12:26.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.617]                       search = base::search(), system = base::Sys.info())
[16:12:26.617]                   }
[16:12:26.617]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.617]                     cond$call), session = sessionInformation(), 
[16:12:26.617]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.617]                   signalCondition(cond)
[16:12:26.617]                 }
[16:12:26.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.617]                 "immediateCondition"))) {
[16:12:26.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.617]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.617]                   if (TRUE && !signal) {
[16:12:26.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.617]                     {
[16:12:26.617]                       inherits <- base::inherits
[16:12:26.617]                       invokeRestart <- base::invokeRestart
[16:12:26.617]                       is.null <- base::is.null
[16:12:26.617]                       muffled <- FALSE
[16:12:26.617]                       if (inherits(cond, "message")) {
[16:12:26.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.617]                         if (muffled) 
[16:12:26.617]                           invokeRestart("muffleMessage")
[16:12:26.617]                       }
[16:12:26.617]                       else if (inherits(cond, "warning")) {
[16:12:26.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.617]                         if (muffled) 
[16:12:26.617]                           invokeRestart("muffleWarning")
[16:12:26.617]                       }
[16:12:26.617]                       else if (inherits(cond, "condition")) {
[16:12:26.617]                         if (!is.null(pattern)) {
[16:12:26.617]                           computeRestarts <- base::computeRestarts
[16:12:26.617]                           grepl <- base::grepl
[16:12:26.617]                           restarts <- computeRestarts(cond)
[16:12:26.617]                           for (restart in restarts) {
[16:12:26.617]                             name <- restart$name
[16:12:26.617]                             if (is.null(name)) 
[16:12:26.617]                               next
[16:12:26.617]                             if (!grepl(pattern, name)) 
[16:12:26.617]                               next
[16:12:26.617]                             invokeRestart(restart)
[16:12:26.617]                             muffled <- TRUE
[16:12:26.617]                             break
[16:12:26.617]                           }
[16:12:26.617]                         }
[16:12:26.617]                       }
[16:12:26.617]                       invisible(muffled)
[16:12:26.617]                     }
[16:12:26.617]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.617]                   }
[16:12:26.617]                 }
[16:12:26.617]                 else {
[16:12:26.617]                   if (TRUE) {
[16:12:26.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.617]                     {
[16:12:26.617]                       inherits <- base::inherits
[16:12:26.617]                       invokeRestart <- base::invokeRestart
[16:12:26.617]                       is.null <- base::is.null
[16:12:26.617]                       muffled <- FALSE
[16:12:26.617]                       if (inherits(cond, "message")) {
[16:12:26.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.617]                         if (muffled) 
[16:12:26.617]                           invokeRestart("muffleMessage")
[16:12:26.617]                       }
[16:12:26.617]                       else if (inherits(cond, "warning")) {
[16:12:26.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.617]                         if (muffled) 
[16:12:26.617]                           invokeRestart("muffleWarning")
[16:12:26.617]                       }
[16:12:26.617]                       else if (inherits(cond, "condition")) {
[16:12:26.617]                         if (!is.null(pattern)) {
[16:12:26.617]                           computeRestarts <- base::computeRestarts
[16:12:26.617]                           grepl <- base::grepl
[16:12:26.617]                           restarts <- computeRestarts(cond)
[16:12:26.617]                           for (restart in restarts) {
[16:12:26.617]                             name <- restart$name
[16:12:26.617]                             if (is.null(name)) 
[16:12:26.617]                               next
[16:12:26.617]                             if (!grepl(pattern, name)) 
[16:12:26.617]                               next
[16:12:26.617]                             invokeRestart(restart)
[16:12:26.617]                             muffled <- TRUE
[16:12:26.617]                             break
[16:12:26.617]                           }
[16:12:26.617]                         }
[16:12:26.617]                       }
[16:12:26.617]                       invisible(muffled)
[16:12:26.617]                     }
[16:12:26.617]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.617]                   }
[16:12:26.617]                 }
[16:12:26.617]             }
[16:12:26.617]         }))
[16:12:26.617]     }, error = function(ex) {
[16:12:26.617]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.617]                 ...future.rng), started = ...future.startTime, 
[16:12:26.617]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.617]             version = "1.8"), class = "FutureResult")
[16:12:26.617]     }, finally = {
[16:12:26.617]         if (!identical(...future.workdir, getwd())) 
[16:12:26.617]             setwd(...future.workdir)
[16:12:26.617]         {
[16:12:26.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.617]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.617]             }
[16:12:26.617]             base::options(...future.oldOptions)
[16:12:26.617]             if (.Platform$OS.type == "windows") {
[16:12:26.617]                 old_names <- names(...future.oldEnvVars)
[16:12:26.617]                 envs <- base::Sys.getenv()
[16:12:26.617]                 names <- names(envs)
[16:12:26.617]                 common <- intersect(names, old_names)
[16:12:26.617]                 added <- setdiff(names, old_names)
[16:12:26.617]                 removed <- setdiff(old_names, names)
[16:12:26.617]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.617]                   envs[common]]
[16:12:26.617]                 NAMES <- toupper(changed)
[16:12:26.617]                 args <- list()
[16:12:26.617]                 for (kk in seq_along(NAMES)) {
[16:12:26.617]                   name <- changed[[kk]]
[16:12:26.617]                   NAME <- NAMES[[kk]]
[16:12:26.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.617]                     next
[16:12:26.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.617]                 }
[16:12:26.617]                 NAMES <- toupper(added)
[16:12:26.617]                 for (kk in seq_along(NAMES)) {
[16:12:26.617]                   name <- added[[kk]]
[16:12:26.617]                   NAME <- NAMES[[kk]]
[16:12:26.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.617]                     next
[16:12:26.617]                   args[[name]] <- ""
[16:12:26.617]                 }
[16:12:26.617]                 NAMES <- toupper(removed)
[16:12:26.617]                 for (kk in seq_along(NAMES)) {
[16:12:26.617]                   name <- removed[[kk]]
[16:12:26.617]                   NAME <- NAMES[[kk]]
[16:12:26.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.617]                     next
[16:12:26.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.617]                 }
[16:12:26.617]                 if (length(args) > 0) 
[16:12:26.617]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.617]             }
[16:12:26.617]             else {
[16:12:26.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.617]             }
[16:12:26.617]             {
[16:12:26.617]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.617]                   0L) {
[16:12:26.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.617]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.617]                   base::options(opts)
[16:12:26.617]                 }
[16:12:26.617]                 {
[16:12:26.617]                   {
[16:12:26.617]                     NULL
[16:12:26.617]                     RNGkind("Mersenne-Twister")
[16:12:26.617]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.617]                       inherits = FALSE)
[16:12:26.617]                   }
[16:12:26.617]                   options(future.plan = NULL)
[16:12:26.617]                   if (is.na(NA_character_)) 
[16:12:26.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.617]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.617]                   {
[16:12:26.617]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.617]                     if (!future$lazy) 
[16:12:26.617]                       future <- run(future)
[16:12:26.617]                     invisible(future)
[16:12:26.617]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.617]                 }
[16:12:26.617]             }
[16:12:26.617]         }
[16:12:26.617]     })
[16:12:26.617]     if (TRUE) {
[16:12:26.617]         base::sink(type = "output", split = FALSE)
[16:12:26.617]         if (TRUE) {
[16:12:26.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.617]         }
[16:12:26.617]         else {
[16:12:26.617]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.617]         }
[16:12:26.617]         base::close(...future.stdout)
[16:12:26.617]         ...future.stdout <- NULL
[16:12:26.617]     }
[16:12:26.617]     ...future.result$conditions <- ...future.conditions
[16:12:26.617]     ...future.result$finished <- base::Sys.time()
[16:12:26.617]     ...future.result
[16:12:26.617] }
[16:12:26.619] plan(): Setting new future strategy stack:
[16:12:26.619] List of future strategies:
[16:12:26.619] 1. sequential:
[16:12:26.619]    - args: function (..., envir = parent.frame())
[16:12:26.619]    - tweaked: FALSE
[16:12:26.619]    - call: NULL
[16:12:26.619] plan(): nbrOfWorkers() = 1
[16:12:26.620] plan(): Setting new future strategy stack:
[16:12:26.620] List of future strategies:
[16:12:26.620] 1. sequential:
[16:12:26.620]    - args: function (..., envir = parent.frame())
[16:12:26.620]    - tweaked: FALSE
[16:12:26.620]    - call: plan(strategy)
[16:12:26.621] plan(): nbrOfWorkers() = 1
[16:12:26.621] SequentialFuture started (and completed)
[16:12:26.621] - Launch lazy future ... done
[16:12:26.621] run() for ‘SequentialFuture’ ... done
[16:12:26.621] getGlobalsAndPackages() ...
[16:12:26.621] Searching for globals...
[16:12:26.621] 
[16:12:26.622] Searching for globals ... DONE
[16:12:26.622] - globals: [0] <none>
[16:12:26.622] getGlobalsAndPackages() ... DONE
[16:12:26.622] run() for ‘Future’ ...
[16:12:26.622] - state: ‘created’
[16:12:26.622] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.622] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.623]   - Field: ‘label’
[16:12:26.623]   - Field: ‘local’
[16:12:26.623]   - Field: ‘owner’
[16:12:26.623]   - Field: ‘envir’
[16:12:26.623]   - Field: ‘packages’
[16:12:26.623]   - Field: ‘gc’
[16:12:26.623]   - Field: ‘conditions’
[16:12:26.623]   - Field: ‘expr’
[16:12:26.623]   - Field: ‘uuid’
[16:12:26.623]   - Field: ‘seed’
[16:12:26.623]   - Field: ‘version’
[16:12:26.624]   - Field: ‘result’
[16:12:26.624]   - Field: ‘asynchronous’
[16:12:26.624]   - Field: ‘calls’
[16:12:26.624]   - Field: ‘globals’
[16:12:26.624]   - Field: ‘stdout’
[16:12:26.624]   - Field: ‘earlySignal’
[16:12:26.624]   - Field: ‘lazy’
[16:12:26.624]   - Field: ‘state’
[16:12:26.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.624] - Launch lazy future ...
[16:12:26.625] Packages needed by the future expression (n = 0): <none>
[16:12:26.625] Packages needed by future strategies (n = 0): <none>
[16:12:26.625] {
[16:12:26.625]     {
[16:12:26.625]         {
[16:12:26.625]             ...future.startTime <- base::Sys.time()
[16:12:26.625]             {
[16:12:26.625]                 {
[16:12:26.625]                   {
[16:12:26.625]                     base::local({
[16:12:26.625]                       has_future <- base::requireNamespace("future", 
[16:12:26.625]                         quietly = TRUE)
[16:12:26.625]                       if (has_future) {
[16:12:26.625]                         ns <- base::getNamespace("future")
[16:12:26.625]                         version <- ns[[".package"]][["version"]]
[16:12:26.625]                         if (is.null(version)) 
[16:12:26.625]                           version <- utils::packageVersion("future")
[16:12:26.625]                       }
[16:12:26.625]                       else {
[16:12:26.625]                         version <- NULL
[16:12:26.625]                       }
[16:12:26.625]                       if (!has_future || version < "1.8.0") {
[16:12:26.625]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.625]                           "", base::R.version$version.string), 
[16:12:26.625]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.625]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.625]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.625]                             "release", "version")], collapse = " "), 
[16:12:26.625]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.625]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.625]                           info)
[16:12:26.625]                         info <- base::paste(info, collapse = "; ")
[16:12:26.625]                         if (!has_future) {
[16:12:26.625]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.625]                             info)
[16:12:26.625]                         }
[16:12:26.625]                         else {
[16:12:26.625]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.625]                             info, version)
[16:12:26.625]                         }
[16:12:26.625]                         base::stop(msg)
[16:12:26.625]                       }
[16:12:26.625]                     })
[16:12:26.625]                   }
[16:12:26.625]                   options(future.plan = NULL)
[16:12:26.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.625]                 }
[16:12:26.625]                 ...future.workdir <- getwd()
[16:12:26.625]             }
[16:12:26.625]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.625]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.625]         }
[16:12:26.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.625]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.625]             base::names(...future.oldOptions))
[16:12:26.625]     }
[16:12:26.625]     if (FALSE) {
[16:12:26.625]     }
[16:12:26.625]     else {
[16:12:26.625]         if (TRUE) {
[16:12:26.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.625]                 open = "w")
[16:12:26.625]         }
[16:12:26.625]         else {
[16:12:26.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.625]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.625]         }
[16:12:26.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.625]             base::sink(type = "output", split = FALSE)
[16:12:26.625]             base::close(...future.stdout)
[16:12:26.625]         }, add = TRUE)
[16:12:26.625]     }
[16:12:26.625]     ...future.frame <- base::sys.nframe()
[16:12:26.625]     ...future.conditions <- base::list()
[16:12:26.625]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.625]     if (FALSE) {
[16:12:26.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.625]     }
[16:12:26.625]     ...future.result <- base::tryCatch({
[16:12:26.625]         base::withCallingHandlers({
[16:12:26.625]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.625]             future::FutureResult(value = ...future.value$value, 
[16:12:26.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.625]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.625]                     ...future.globalenv.names))
[16:12:26.625]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.625]         }, condition = base::local({
[16:12:26.625]             c <- base::c
[16:12:26.625]             inherits <- base::inherits
[16:12:26.625]             invokeRestart <- base::invokeRestart
[16:12:26.625]             length <- base::length
[16:12:26.625]             list <- base::list
[16:12:26.625]             seq.int <- base::seq.int
[16:12:26.625]             signalCondition <- base::signalCondition
[16:12:26.625]             sys.calls <- base::sys.calls
[16:12:26.625]             `[[` <- base::`[[`
[16:12:26.625]             `+` <- base::`+`
[16:12:26.625]             `<<-` <- base::`<<-`
[16:12:26.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.625]                   3L)]
[16:12:26.625]             }
[16:12:26.625]             function(cond) {
[16:12:26.625]                 is_error <- inherits(cond, "error")
[16:12:26.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.625]                   NULL)
[16:12:26.625]                 if (is_error) {
[16:12:26.625]                   sessionInformation <- function() {
[16:12:26.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.625]                       search = base::search(), system = base::Sys.info())
[16:12:26.625]                   }
[16:12:26.625]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.625]                     cond$call), session = sessionInformation(), 
[16:12:26.625]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.625]                   signalCondition(cond)
[16:12:26.625]                 }
[16:12:26.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.625]                 "immediateCondition"))) {
[16:12:26.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.625]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.625]                   if (TRUE && !signal) {
[16:12:26.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.625]                     {
[16:12:26.625]                       inherits <- base::inherits
[16:12:26.625]                       invokeRestart <- base::invokeRestart
[16:12:26.625]                       is.null <- base::is.null
[16:12:26.625]                       muffled <- FALSE
[16:12:26.625]                       if (inherits(cond, "message")) {
[16:12:26.625]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.625]                         if (muffled) 
[16:12:26.625]                           invokeRestart("muffleMessage")
[16:12:26.625]                       }
[16:12:26.625]                       else if (inherits(cond, "warning")) {
[16:12:26.625]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.625]                         if (muffled) 
[16:12:26.625]                           invokeRestart("muffleWarning")
[16:12:26.625]                       }
[16:12:26.625]                       else if (inherits(cond, "condition")) {
[16:12:26.625]                         if (!is.null(pattern)) {
[16:12:26.625]                           computeRestarts <- base::computeRestarts
[16:12:26.625]                           grepl <- base::grepl
[16:12:26.625]                           restarts <- computeRestarts(cond)
[16:12:26.625]                           for (restart in restarts) {
[16:12:26.625]                             name <- restart$name
[16:12:26.625]                             if (is.null(name)) 
[16:12:26.625]                               next
[16:12:26.625]                             if (!grepl(pattern, name)) 
[16:12:26.625]                               next
[16:12:26.625]                             invokeRestart(restart)
[16:12:26.625]                             muffled <- TRUE
[16:12:26.625]                             break
[16:12:26.625]                           }
[16:12:26.625]                         }
[16:12:26.625]                       }
[16:12:26.625]                       invisible(muffled)
[16:12:26.625]                     }
[16:12:26.625]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.625]                   }
[16:12:26.625]                 }
[16:12:26.625]                 else {
[16:12:26.625]                   if (TRUE) {
[16:12:26.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.625]                     {
[16:12:26.625]                       inherits <- base::inherits
[16:12:26.625]                       invokeRestart <- base::invokeRestart
[16:12:26.625]                       is.null <- base::is.null
[16:12:26.625]                       muffled <- FALSE
[16:12:26.625]                       if (inherits(cond, "message")) {
[16:12:26.625]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.625]                         if (muffled) 
[16:12:26.625]                           invokeRestart("muffleMessage")
[16:12:26.625]                       }
[16:12:26.625]                       else if (inherits(cond, "warning")) {
[16:12:26.625]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.625]                         if (muffled) 
[16:12:26.625]                           invokeRestart("muffleWarning")
[16:12:26.625]                       }
[16:12:26.625]                       else if (inherits(cond, "condition")) {
[16:12:26.625]                         if (!is.null(pattern)) {
[16:12:26.625]                           computeRestarts <- base::computeRestarts
[16:12:26.625]                           grepl <- base::grepl
[16:12:26.625]                           restarts <- computeRestarts(cond)
[16:12:26.625]                           for (restart in restarts) {
[16:12:26.625]                             name <- restart$name
[16:12:26.625]                             if (is.null(name)) 
[16:12:26.625]                               next
[16:12:26.625]                             if (!grepl(pattern, name)) 
[16:12:26.625]                               next
[16:12:26.625]                             invokeRestart(restart)
[16:12:26.625]                             muffled <- TRUE
[16:12:26.625]                             break
[16:12:26.625]                           }
[16:12:26.625]                         }
[16:12:26.625]                       }
[16:12:26.625]                       invisible(muffled)
[16:12:26.625]                     }
[16:12:26.625]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.625]                   }
[16:12:26.625]                 }
[16:12:26.625]             }
[16:12:26.625]         }))
[16:12:26.625]     }, error = function(ex) {
[16:12:26.625]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.625]                 ...future.rng), started = ...future.startTime, 
[16:12:26.625]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.625]             version = "1.8"), class = "FutureResult")
[16:12:26.625]     }, finally = {
[16:12:26.625]         if (!identical(...future.workdir, getwd())) 
[16:12:26.625]             setwd(...future.workdir)
[16:12:26.625]         {
[16:12:26.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.625]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.625]             }
[16:12:26.625]             base::options(...future.oldOptions)
[16:12:26.625]             if (.Platform$OS.type == "windows") {
[16:12:26.625]                 old_names <- names(...future.oldEnvVars)
[16:12:26.625]                 envs <- base::Sys.getenv()
[16:12:26.625]                 names <- names(envs)
[16:12:26.625]                 common <- intersect(names, old_names)
[16:12:26.625]                 added <- setdiff(names, old_names)
[16:12:26.625]                 removed <- setdiff(old_names, names)
[16:12:26.625]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.625]                   envs[common]]
[16:12:26.625]                 NAMES <- toupper(changed)
[16:12:26.625]                 args <- list()
[16:12:26.625]                 for (kk in seq_along(NAMES)) {
[16:12:26.625]                   name <- changed[[kk]]
[16:12:26.625]                   NAME <- NAMES[[kk]]
[16:12:26.625]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.625]                     next
[16:12:26.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.625]                 }
[16:12:26.625]                 NAMES <- toupper(added)
[16:12:26.625]                 for (kk in seq_along(NAMES)) {
[16:12:26.625]                   name <- added[[kk]]
[16:12:26.625]                   NAME <- NAMES[[kk]]
[16:12:26.625]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.625]                     next
[16:12:26.625]                   args[[name]] <- ""
[16:12:26.625]                 }
[16:12:26.625]                 NAMES <- toupper(removed)
[16:12:26.625]                 for (kk in seq_along(NAMES)) {
[16:12:26.625]                   name <- removed[[kk]]
[16:12:26.625]                   NAME <- NAMES[[kk]]
[16:12:26.625]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.625]                     next
[16:12:26.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.625]                 }
[16:12:26.625]                 if (length(args) > 0) 
[16:12:26.625]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.625]             }
[16:12:26.625]             else {
[16:12:26.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.625]             }
[16:12:26.625]             {
[16:12:26.625]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.625]                   0L) {
[16:12:26.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.625]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.625]                   base::options(opts)
[16:12:26.625]                 }
[16:12:26.625]                 {
[16:12:26.625]                   {
[16:12:26.625]                     NULL
[16:12:26.625]                     RNGkind("Mersenne-Twister")
[16:12:26.625]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.625]                       inherits = FALSE)
[16:12:26.625]                   }
[16:12:26.625]                   options(future.plan = NULL)
[16:12:26.625]                   if (is.na(NA_character_)) 
[16:12:26.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.625]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.625]                   {
[16:12:26.625]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.625]                     if (!future$lazy) 
[16:12:26.625]                       future <- run(future)
[16:12:26.625]                     invisible(future)
[16:12:26.625]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.625]                 }
[16:12:26.625]             }
[16:12:26.625]         }
[16:12:26.625]     })
[16:12:26.625]     if (TRUE) {
[16:12:26.625]         base::sink(type = "output", split = FALSE)
[16:12:26.625]         if (TRUE) {
[16:12:26.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.625]         }
[16:12:26.625]         else {
[16:12:26.625]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.625]         }
[16:12:26.625]         base::close(...future.stdout)
[16:12:26.625]         ...future.stdout <- NULL
[16:12:26.625]     }
[16:12:26.625]     ...future.result$conditions <- ...future.conditions
[16:12:26.625]     ...future.result$finished <- base::Sys.time()
[16:12:26.625]     ...future.result
[16:12:26.625] }
[16:12:26.627] plan(): Setting new future strategy stack:
[16:12:26.627] List of future strategies:
[16:12:26.627] 1. sequential:
[16:12:26.627]    - args: function (..., envir = parent.frame())
[16:12:26.627]    - tweaked: FALSE
[16:12:26.627]    - call: NULL
[16:12:26.627] plan(): nbrOfWorkers() = 1
[16:12:26.628] plan(): Setting new future strategy stack:
[16:12:26.628] List of future strategies:
[16:12:26.628] 1. sequential:
[16:12:26.628]    - args: function (..., envir = parent.frame())
[16:12:26.628]    - tweaked: FALSE
[16:12:26.628]    - call: plan(strategy)
[16:12:26.628] plan(): nbrOfWorkers() = 1
[16:12:26.628] SequentialFuture started (and completed)
[16:12:26.629] - Launch lazy future ... done
[16:12:26.629] run() for ‘SequentialFuture’ ... done
[16:12:26.630] getGlobalsAndPackages() ...
[16:12:26.630] Searching for globals...
[16:12:26.631] - globals found: [1] ‘{’
[16:12:26.631] Searching for globals ... DONE
[16:12:26.631] Resolving globals: FALSE
[16:12:26.631] 
[16:12:26.631] 
[16:12:26.631] getGlobalsAndPackages() ... DONE
[16:12:26.632] run() for ‘Future’ ...
[16:12:26.632] - state: ‘created’
[16:12:26.632] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.632] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.632]   - Field: ‘label’
[16:12:26.632]   - Field: ‘local’
[16:12:26.633]   - Field: ‘owner’
[16:12:26.633]   - Field: ‘envir’
[16:12:26.633]   - Field: ‘packages’
[16:12:26.633]   - Field: ‘gc’
[16:12:26.633]   - Field: ‘conditions’
[16:12:26.633]   - Field: ‘expr’
[16:12:26.633]   - Field: ‘uuid’
[16:12:26.633]   - Field: ‘seed’
[16:12:26.633]   - Field: ‘version’
[16:12:26.633]   - Field: ‘result’
[16:12:26.633]   - Field: ‘asynchronous’
[16:12:26.634]   - Field: ‘calls’
[16:12:26.634]   - Field: ‘globals’
[16:12:26.634]   - Field: ‘stdout’
[16:12:26.634]   - Field: ‘earlySignal’
[16:12:26.634]   - Field: ‘lazy’
[16:12:26.634]   - Field: ‘state’
[16:12:26.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.634] - Launch lazy future ...
[16:12:26.634] Packages needed by the future expression (n = 0): <none>
[16:12:26.634] Packages needed by future strategies (n = 0): <none>
[16:12:26.635] {
[16:12:26.635]     {
[16:12:26.635]         {
[16:12:26.635]             ...future.startTime <- base::Sys.time()
[16:12:26.635]             {
[16:12:26.635]                 {
[16:12:26.635]                   {
[16:12:26.635]                     base::local({
[16:12:26.635]                       has_future <- base::requireNamespace("future", 
[16:12:26.635]                         quietly = TRUE)
[16:12:26.635]                       if (has_future) {
[16:12:26.635]                         ns <- base::getNamespace("future")
[16:12:26.635]                         version <- ns[[".package"]][["version"]]
[16:12:26.635]                         if (is.null(version)) 
[16:12:26.635]                           version <- utils::packageVersion("future")
[16:12:26.635]                       }
[16:12:26.635]                       else {
[16:12:26.635]                         version <- NULL
[16:12:26.635]                       }
[16:12:26.635]                       if (!has_future || version < "1.8.0") {
[16:12:26.635]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.635]                           "", base::R.version$version.string), 
[16:12:26.635]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.635]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.635]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.635]                             "release", "version")], collapse = " "), 
[16:12:26.635]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.635]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.635]                           info)
[16:12:26.635]                         info <- base::paste(info, collapse = "; ")
[16:12:26.635]                         if (!has_future) {
[16:12:26.635]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.635]                             info)
[16:12:26.635]                         }
[16:12:26.635]                         else {
[16:12:26.635]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.635]                             info, version)
[16:12:26.635]                         }
[16:12:26.635]                         base::stop(msg)
[16:12:26.635]                       }
[16:12:26.635]                     })
[16:12:26.635]                   }
[16:12:26.635]                   options(future.plan = NULL)
[16:12:26.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.635]                 }
[16:12:26.635]                 ...future.workdir <- getwd()
[16:12:26.635]             }
[16:12:26.635]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.635]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.635]         }
[16:12:26.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.635]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.635]             base::names(...future.oldOptions))
[16:12:26.635]     }
[16:12:26.635]     if (FALSE) {
[16:12:26.635]     }
[16:12:26.635]     else {
[16:12:26.635]         if (TRUE) {
[16:12:26.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.635]                 open = "w")
[16:12:26.635]         }
[16:12:26.635]         else {
[16:12:26.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.635]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.635]         }
[16:12:26.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.635]             base::sink(type = "output", split = FALSE)
[16:12:26.635]             base::close(...future.stdout)
[16:12:26.635]         }, add = TRUE)
[16:12:26.635]     }
[16:12:26.635]     ...future.frame <- base::sys.nframe()
[16:12:26.635]     ...future.conditions <- base::list()
[16:12:26.635]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.635]     if (FALSE) {
[16:12:26.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.635]     }
[16:12:26.635]     ...future.result <- base::tryCatch({
[16:12:26.635]         base::withCallingHandlers({
[16:12:26.635]             ...future.value <- base::withVisible(base::local({
[16:12:26.635]                 4
[16:12:26.635]             }))
[16:12:26.635]             future::FutureResult(value = ...future.value$value, 
[16:12:26.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.635]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.635]                     ...future.globalenv.names))
[16:12:26.635]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.635]         }, condition = base::local({
[16:12:26.635]             c <- base::c
[16:12:26.635]             inherits <- base::inherits
[16:12:26.635]             invokeRestart <- base::invokeRestart
[16:12:26.635]             length <- base::length
[16:12:26.635]             list <- base::list
[16:12:26.635]             seq.int <- base::seq.int
[16:12:26.635]             signalCondition <- base::signalCondition
[16:12:26.635]             sys.calls <- base::sys.calls
[16:12:26.635]             `[[` <- base::`[[`
[16:12:26.635]             `+` <- base::`+`
[16:12:26.635]             `<<-` <- base::`<<-`
[16:12:26.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.635]                   3L)]
[16:12:26.635]             }
[16:12:26.635]             function(cond) {
[16:12:26.635]                 is_error <- inherits(cond, "error")
[16:12:26.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.635]                   NULL)
[16:12:26.635]                 if (is_error) {
[16:12:26.635]                   sessionInformation <- function() {
[16:12:26.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.635]                       search = base::search(), system = base::Sys.info())
[16:12:26.635]                   }
[16:12:26.635]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.635]                     cond$call), session = sessionInformation(), 
[16:12:26.635]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.635]                   signalCondition(cond)
[16:12:26.635]                 }
[16:12:26.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.635]                 "immediateCondition"))) {
[16:12:26.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.635]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.635]                   if (TRUE && !signal) {
[16:12:26.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.635]                     {
[16:12:26.635]                       inherits <- base::inherits
[16:12:26.635]                       invokeRestart <- base::invokeRestart
[16:12:26.635]                       is.null <- base::is.null
[16:12:26.635]                       muffled <- FALSE
[16:12:26.635]                       if (inherits(cond, "message")) {
[16:12:26.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.635]                         if (muffled) 
[16:12:26.635]                           invokeRestart("muffleMessage")
[16:12:26.635]                       }
[16:12:26.635]                       else if (inherits(cond, "warning")) {
[16:12:26.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.635]                         if (muffled) 
[16:12:26.635]                           invokeRestart("muffleWarning")
[16:12:26.635]                       }
[16:12:26.635]                       else if (inherits(cond, "condition")) {
[16:12:26.635]                         if (!is.null(pattern)) {
[16:12:26.635]                           computeRestarts <- base::computeRestarts
[16:12:26.635]                           grepl <- base::grepl
[16:12:26.635]                           restarts <- computeRestarts(cond)
[16:12:26.635]                           for (restart in restarts) {
[16:12:26.635]                             name <- restart$name
[16:12:26.635]                             if (is.null(name)) 
[16:12:26.635]                               next
[16:12:26.635]                             if (!grepl(pattern, name)) 
[16:12:26.635]                               next
[16:12:26.635]                             invokeRestart(restart)
[16:12:26.635]                             muffled <- TRUE
[16:12:26.635]                             break
[16:12:26.635]                           }
[16:12:26.635]                         }
[16:12:26.635]                       }
[16:12:26.635]                       invisible(muffled)
[16:12:26.635]                     }
[16:12:26.635]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.635]                   }
[16:12:26.635]                 }
[16:12:26.635]                 else {
[16:12:26.635]                   if (TRUE) {
[16:12:26.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.635]                     {
[16:12:26.635]                       inherits <- base::inherits
[16:12:26.635]                       invokeRestart <- base::invokeRestart
[16:12:26.635]                       is.null <- base::is.null
[16:12:26.635]                       muffled <- FALSE
[16:12:26.635]                       if (inherits(cond, "message")) {
[16:12:26.635]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.635]                         if (muffled) 
[16:12:26.635]                           invokeRestart("muffleMessage")
[16:12:26.635]                       }
[16:12:26.635]                       else if (inherits(cond, "warning")) {
[16:12:26.635]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.635]                         if (muffled) 
[16:12:26.635]                           invokeRestart("muffleWarning")
[16:12:26.635]                       }
[16:12:26.635]                       else if (inherits(cond, "condition")) {
[16:12:26.635]                         if (!is.null(pattern)) {
[16:12:26.635]                           computeRestarts <- base::computeRestarts
[16:12:26.635]                           grepl <- base::grepl
[16:12:26.635]                           restarts <- computeRestarts(cond)
[16:12:26.635]                           for (restart in restarts) {
[16:12:26.635]                             name <- restart$name
[16:12:26.635]                             if (is.null(name)) 
[16:12:26.635]                               next
[16:12:26.635]                             if (!grepl(pattern, name)) 
[16:12:26.635]                               next
[16:12:26.635]                             invokeRestart(restart)
[16:12:26.635]                             muffled <- TRUE
[16:12:26.635]                             break
[16:12:26.635]                           }
[16:12:26.635]                         }
[16:12:26.635]                       }
[16:12:26.635]                       invisible(muffled)
[16:12:26.635]                     }
[16:12:26.635]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.635]                   }
[16:12:26.635]                 }
[16:12:26.635]             }
[16:12:26.635]         }))
[16:12:26.635]     }, error = function(ex) {
[16:12:26.635]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.635]                 ...future.rng), started = ...future.startTime, 
[16:12:26.635]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.635]             version = "1.8"), class = "FutureResult")
[16:12:26.635]     }, finally = {
[16:12:26.635]         if (!identical(...future.workdir, getwd())) 
[16:12:26.635]             setwd(...future.workdir)
[16:12:26.635]         {
[16:12:26.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.635]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.635]             }
[16:12:26.635]             base::options(...future.oldOptions)
[16:12:26.635]             if (.Platform$OS.type == "windows") {
[16:12:26.635]                 old_names <- names(...future.oldEnvVars)
[16:12:26.635]                 envs <- base::Sys.getenv()
[16:12:26.635]                 names <- names(envs)
[16:12:26.635]                 common <- intersect(names, old_names)
[16:12:26.635]                 added <- setdiff(names, old_names)
[16:12:26.635]                 removed <- setdiff(old_names, names)
[16:12:26.635]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.635]                   envs[common]]
[16:12:26.635]                 NAMES <- toupper(changed)
[16:12:26.635]                 args <- list()
[16:12:26.635]                 for (kk in seq_along(NAMES)) {
[16:12:26.635]                   name <- changed[[kk]]
[16:12:26.635]                   NAME <- NAMES[[kk]]
[16:12:26.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.635]                     next
[16:12:26.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.635]                 }
[16:12:26.635]                 NAMES <- toupper(added)
[16:12:26.635]                 for (kk in seq_along(NAMES)) {
[16:12:26.635]                   name <- added[[kk]]
[16:12:26.635]                   NAME <- NAMES[[kk]]
[16:12:26.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.635]                     next
[16:12:26.635]                   args[[name]] <- ""
[16:12:26.635]                 }
[16:12:26.635]                 NAMES <- toupper(removed)
[16:12:26.635]                 for (kk in seq_along(NAMES)) {
[16:12:26.635]                   name <- removed[[kk]]
[16:12:26.635]                   NAME <- NAMES[[kk]]
[16:12:26.635]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.635]                     next
[16:12:26.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.635]                 }
[16:12:26.635]                 if (length(args) > 0) 
[16:12:26.635]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.635]             }
[16:12:26.635]             else {
[16:12:26.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.635]             }
[16:12:26.635]             {
[16:12:26.635]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.635]                   0L) {
[16:12:26.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.635]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.635]                   base::options(opts)
[16:12:26.635]                 }
[16:12:26.635]                 {
[16:12:26.635]                   {
[16:12:26.635]                     NULL
[16:12:26.635]                     RNGkind("Mersenne-Twister")
[16:12:26.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.635]                       inherits = FALSE)
[16:12:26.635]                   }
[16:12:26.635]                   options(future.plan = NULL)
[16:12:26.635]                   if (is.na(NA_character_)) 
[16:12:26.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.635]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.635]                   {
[16:12:26.635]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.635]                     if (!future$lazy) 
[16:12:26.635]                       future <- run(future)
[16:12:26.635]                     invisible(future)
[16:12:26.635]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.635]                 }
[16:12:26.635]             }
[16:12:26.635]         }
[16:12:26.635]     })
[16:12:26.635]     if (TRUE) {
[16:12:26.635]         base::sink(type = "output", split = FALSE)
[16:12:26.635]         if (TRUE) {
[16:12:26.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.635]         }
[16:12:26.635]         else {
[16:12:26.635]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.635]         }
[16:12:26.635]         base::close(...future.stdout)
[16:12:26.635]         ...future.stdout <- NULL
[16:12:26.635]     }
[16:12:26.635]     ...future.result$conditions <- ...future.conditions
[16:12:26.635]     ...future.result$finished <- base::Sys.time()
[16:12:26.635]     ...future.result
[16:12:26.635] }
[16:12:26.637] plan(): Setting new future strategy stack:
[16:12:26.637] List of future strategies:
[16:12:26.637] 1. sequential:
[16:12:26.637]    - args: function (..., envir = parent.frame())
[16:12:26.637]    - tweaked: FALSE
[16:12:26.637]    - call: NULL
[16:12:26.637] plan(): nbrOfWorkers() = 1
[16:12:26.638] plan(): Setting new future strategy stack:
[16:12:26.638] List of future strategies:
[16:12:26.638] 1. sequential:
[16:12:26.638]    - args: function (..., envir = parent.frame())
[16:12:26.638]    - tweaked: FALSE
[16:12:26.638]    - call: plan(strategy)
[16:12:26.638] plan(): nbrOfWorkers() = 1
[16:12:26.638] SequentialFuture started (and completed)
[16:12:26.638] - Launch lazy future ... done
[16:12:26.638] run() for ‘SequentialFuture’ ... done
<environment: 0x560bae64f3f0> 
<environment: 0x560bae47c8e8> 
[16:12:26.640] resolved() for ‘SequentialFuture’ ...
[16:12:26.640] - state: ‘finished’
[16:12:26.640] - run: TRUE
[16:12:26.640] - result: ‘FutureResult’
[16:12:26.640] resolved() for ‘SequentialFuture’ ... done
[16:12:26.640] resolved() for ‘SequentialFuture’ ...
[16:12:26.640] - state: ‘finished’
[16:12:26.640] - run: TRUE
[16:12:26.641] - result: ‘FutureResult’
[16:12:26.641] resolved() for ‘SequentialFuture’ ... done
[16:12:26.641] resolved() for ‘SequentialFuture’ ...
[16:12:26.641] - state: ‘finished’
[16:12:26.641] - run: TRUE
[16:12:26.641] - result: ‘FutureResult’
[16:12:26.641] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:26.642] resolve() on environment ...
[16:12:26.642]  recursive: 0
[16:12:26.643]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:26.643] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.643] - nx: 4
[16:12:26.643] - relay: TRUE
[16:12:26.643] - stdout: TRUE
[16:12:26.643] - signal: TRUE
[16:12:26.643] - resignal: FALSE
[16:12:26.643] - force: TRUE
[16:12:26.643] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.643] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.644]  - until=2
[16:12:26.644]  - relaying element #2
[16:12:26.644] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.644] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.644] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.644]  length: 3 (resolved future 1)
[16:12:26.644] resolved() for ‘SequentialFuture’ ...
[16:12:26.644] - state: ‘finished’
[16:12:26.644] - run: TRUE
[16:12:26.644] - result: ‘FutureResult’
[16:12:26.644] resolved() for ‘SequentialFuture’ ... done
[16:12:26.645] Future #2
[16:12:26.645] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.645] - nx: 4
[16:12:26.645] - relay: TRUE
[16:12:26.645] - stdout: TRUE
[16:12:26.645] - signal: TRUE
[16:12:26.645] - resignal: FALSE
[16:12:26.645] - force: TRUE
[16:12:26.645] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:26.645] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:26.645]  - until=2
[16:12:26.645]  - relaying element #2
[16:12:26.646] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.646] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.646] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.646]  length: 2 (resolved future 2)
[16:12:26.646] resolved() for ‘SequentialFuture’ ...
[16:12:26.646] - state: ‘finished’
[16:12:26.646] - run: TRUE
[16:12:26.646] - result: ‘FutureResult’
[16:12:26.646] resolved() for ‘SequentialFuture’ ... done
[16:12:26.646] Future #3
[16:12:26.647] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.647] - nx: 4
[16:12:26.647] - relay: TRUE
[16:12:26.647] - stdout: TRUE
[16:12:26.647] - signal: TRUE
[16:12:26.647] - resignal: FALSE
[16:12:26.647] - force: TRUE
[16:12:26.647] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:26.647] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:26.647]  - until=3
[16:12:26.647]  - relaying element #3
[16:12:26.648] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.648] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.648] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.648]  length: 1 (resolved future 3)
[16:12:26.648] resolved() for ‘SequentialFuture’ ...
[16:12:26.648] - state: ‘finished’
[16:12:26.648] - run: TRUE
[16:12:26.648] - result: ‘FutureResult’
[16:12:26.648] resolved() for ‘SequentialFuture’ ... done
[16:12:26.648] Future #4
[16:12:26.649] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.649] - nx: 4
[16:12:26.649] - relay: TRUE
[16:12:26.649] - stdout: TRUE
[16:12:26.649] - signal: TRUE
[16:12:26.649] - resignal: FALSE
[16:12:26.649] - force: TRUE
[16:12:26.649] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:26.649] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:26.649]  - until=4
[16:12:26.649]  - relaying element #4
[16:12:26.649] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.650] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.650] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.650]  length: 0 (resolved future 4)
[16:12:26.650] Relaying remaining futures
[16:12:26.650] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.650] - nx: 4
[16:12:26.650] - relay: TRUE
[16:12:26.650] - stdout: TRUE
[16:12:26.650] - signal: TRUE
[16:12:26.650] - resignal: FALSE
[16:12:26.650] - force: TRUE
[16:12:26.650] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.651] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:26.651] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:26.651] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:26.651] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.651] resolve() on environment ... DONE
<environment: 0x560bae6c1860> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[16:12:26.652] plan(): Setting new future strategy stack:
[16:12:26.652] List of future strategies:
[16:12:26.652] 1. sequential:
[16:12:26.652]    - args: function (..., envir = parent.frame())
[16:12:26.652]    - tweaked: FALSE
[16:12:26.652]    - call: plan(strategy)
[16:12:26.652] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[16:12:26.653] getGlobalsAndPackages() ...
[16:12:26.653] Searching for globals...
[16:12:26.653] 
[16:12:26.654] Searching for globals ... DONE
[16:12:26.654] - globals: [0] <none>
[16:12:26.654] getGlobalsAndPackages() ... DONE
[16:12:26.655] run() for ‘Future’ ...
[16:12:26.655] - state: ‘created’
[16:12:26.655] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.655] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.655]   - Field: ‘label’
[16:12:26.655]   - Field: ‘local’
[16:12:26.656]   - Field: ‘owner’
[16:12:26.656]   - Field: ‘envir’
[16:12:26.656]   - Field: ‘packages’
[16:12:26.656]   - Field: ‘gc’
[16:12:26.656]   - Field: ‘conditions’
[16:12:26.656]   - Field: ‘expr’
[16:12:26.656]   - Field: ‘uuid’
[16:12:26.656]   - Field: ‘seed’
[16:12:26.656]   - Field: ‘version’
[16:12:26.656]   - Field: ‘result’
[16:12:26.656]   - Field: ‘asynchronous’
[16:12:26.657]   - Field: ‘calls’
[16:12:26.657]   - Field: ‘globals’
[16:12:26.657]   - Field: ‘stdout’
[16:12:26.657]   - Field: ‘earlySignal’
[16:12:26.657]   - Field: ‘lazy’
[16:12:26.657]   - Field: ‘state’
[16:12:26.657] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.657] - Launch lazy future ...
[16:12:26.657] Packages needed by the future expression (n = 0): <none>
[16:12:26.657] Packages needed by future strategies (n = 0): <none>
[16:12:26.658] {
[16:12:26.658]     {
[16:12:26.658]         {
[16:12:26.658]             ...future.startTime <- base::Sys.time()
[16:12:26.658]             {
[16:12:26.658]                 {
[16:12:26.658]                   {
[16:12:26.658]                     base::local({
[16:12:26.658]                       has_future <- base::requireNamespace("future", 
[16:12:26.658]                         quietly = TRUE)
[16:12:26.658]                       if (has_future) {
[16:12:26.658]                         ns <- base::getNamespace("future")
[16:12:26.658]                         version <- ns[[".package"]][["version"]]
[16:12:26.658]                         if (is.null(version)) 
[16:12:26.658]                           version <- utils::packageVersion("future")
[16:12:26.658]                       }
[16:12:26.658]                       else {
[16:12:26.658]                         version <- NULL
[16:12:26.658]                       }
[16:12:26.658]                       if (!has_future || version < "1.8.0") {
[16:12:26.658]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.658]                           "", base::R.version$version.string), 
[16:12:26.658]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.658]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.658]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.658]                             "release", "version")], collapse = " "), 
[16:12:26.658]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.658]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.658]                           info)
[16:12:26.658]                         info <- base::paste(info, collapse = "; ")
[16:12:26.658]                         if (!has_future) {
[16:12:26.658]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.658]                             info)
[16:12:26.658]                         }
[16:12:26.658]                         else {
[16:12:26.658]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.658]                             info, version)
[16:12:26.658]                         }
[16:12:26.658]                         base::stop(msg)
[16:12:26.658]                       }
[16:12:26.658]                     })
[16:12:26.658]                   }
[16:12:26.658]                   options(future.plan = NULL)
[16:12:26.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.658]                 }
[16:12:26.658]                 ...future.workdir <- getwd()
[16:12:26.658]             }
[16:12:26.658]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.658]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.658]         }
[16:12:26.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.658]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.658]             base::names(...future.oldOptions))
[16:12:26.658]     }
[16:12:26.658]     if (FALSE) {
[16:12:26.658]     }
[16:12:26.658]     else {
[16:12:26.658]         if (TRUE) {
[16:12:26.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.658]                 open = "w")
[16:12:26.658]         }
[16:12:26.658]         else {
[16:12:26.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.658]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.658]         }
[16:12:26.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.658]             base::sink(type = "output", split = FALSE)
[16:12:26.658]             base::close(...future.stdout)
[16:12:26.658]         }, add = TRUE)
[16:12:26.658]     }
[16:12:26.658]     ...future.frame <- base::sys.nframe()
[16:12:26.658]     ...future.conditions <- base::list()
[16:12:26.658]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.658]     if (FALSE) {
[16:12:26.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.658]     }
[16:12:26.658]     ...future.result <- base::tryCatch({
[16:12:26.658]         base::withCallingHandlers({
[16:12:26.658]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.658]             future::FutureResult(value = ...future.value$value, 
[16:12:26.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.658]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.658]                     ...future.globalenv.names))
[16:12:26.658]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.658]         }, condition = base::local({
[16:12:26.658]             c <- base::c
[16:12:26.658]             inherits <- base::inherits
[16:12:26.658]             invokeRestart <- base::invokeRestart
[16:12:26.658]             length <- base::length
[16:12:26.658]             list <- base::list
[16:12:26.658]             seq.int <- base::seq.int
[16:12:26.658]             signalCondition <- base::signalCondition
[16:12:26.658]             sys.calls <- base::sys.calls
[16:12:26.658]             `[[` <- base::`[[`
[16:12:26.658]             `+` <- base::`+`
[16:12:26.658]             `<<-` <- base::`<<-`
[16:12:26.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.658]                   3L)]
[16:12:26.658]             }
[16:12:26.658]             function(cond) {
[16:12:26.658]                 is_error <- inherits(cond, "error")
[16:12:26.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.658]                   NULL)
[16:12:26.658]                 if (is_error) {
[16:12:26.658]                   sessionInformation <- function() {
[16:12:26.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.658]                       search = base::search(), system = base::Sys.info())
[16:12:26.658]                   }
[16:12:26.658]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.658]                     cond$call), session = sessionInformation(), 
[16:12:26.658]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.658]                   signalCondition(cond)
[16:12:26.658]                 }
[16:12:26.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.658]                 "immediateCondition"))) {
[16:12:26.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.658]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.658]                   if (TRUE && !signal) {
[16:12:26.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.658]                     {
[16:12:26.658]                       inherits <- base::inherits
[16:12:26.658]                       invokeRestart <- base::invokeRestart
[16:12:26.658]                       is.null <- base::is.null
[16:12:26.658]                       muffled <- FALSE
[16:12:26.658]                       if (inherits(cond, "message")) {
[16:12:26.658]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.658]                         if (muffled) 
[16:12:26.658]                           invokeRestart("muffleMessage")
[16:12:26.658]                       }
[16:12:26.658]                       else if (inherits(cond, "warning")) {
[16:12:26.658]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.658]                         if (muffled) 
[16:12:26.658]                           invokeRestart("muffleWarning")
[16:12:26.658]                       }
[16:12:26.658]                       else if (inherits(cond, "condition")) {
[16:12:26.658]                         if (!is.null(pattern)) {
[16:12:26.658]                           computeRestarts <- base::computeRestarts
[16:12:26.658]                           grepl <- base::grepl
[16:12:26.658]                           restarts <- computeRestarts(cond)
[16:12:26.658]                           for (restart in restarts) {
[16:12:26.658]                             name <- restart$name
[16:12:26.658]                             if (is.null(name)) 
[16:12:26.658]                               next
[16:12:26.658]                             if (!grepl(pattern, name)) 
[16:12:26.658]                               next
[16:12:26.658]                             invokeRestart(restart)
[16:12:26.658]                             muffled <- TRUE
[16:12:26.658]                             break
[16:12:26.658]                           }
[16:12:26.658]                         }
[16:12:26.658]                       }
[16:12:26.658]                       invisible(muffled)
[16:12:26.658]                     }
[16:12:26.658]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.658]                   }
[16:12:26.658]                 }
[16:12:26.658]                 else {
[16:12:26.658]                   if (TRUE) {
[16:12:26.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.658]                     {
[16:12:26.658]                       inherits <- base::inherits
[16:12:26.658]                       invokeRestart <- base::invokeRestart
[16:12:26.658]                       is.null <- base::is.null
[16:12:26.658]                       muffled <- FALSE
[16:12:26.658]                       if (inherits(cond, "message")) {
[16:12:26.658]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.658]                         if (muffled) 
[16:12:26.658]                           invokeRestart("muffleMessage")
[16:12:26.658]                       }
[16:12:26.658]                       else if (inherits(cond, "warning")) {
[16:12:26.658]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.658]                         if (muffled) 
[16:12:26.658]                           invokeRestart("muffleWarning")
[16:12:26.658]                       }
[16:12:26.658]                       else if (inherits(cond, "condition")) {
[16:12:26.658]                         if (!is.null(pattern)) {
[16:12:26.658]                           computeRestarts <- base::computeRestarts
[16:12:26.658]                           grepl <- base::grepl
[16:12:26.658]                           restarts <- computeRestarts(cond)
[16:12:26.658]                           for (restart in restarts) {
[16:12:26.658]                             name <- restart$name
[16:12:26.658]                             if (is.null(name)) 
[16:12:26.658]                               next
[16:12:26.658]                             if (!grepl(pattern, name)) 
[16:12:26.658]                               next
[16:12:26.658]                             invokeRestart(restart)
[16:12:26.658]                             muffled <- TRUE
[16:12:26.658]                             break
[16:12:26.658]                           }
[16:12:26.658]                         }
[16:12:26.658]                       }
[16:12:26.658]                       invisible(muffled)
[16:12:26.658]                     }
[16:12:26.658]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.658]                   }
[16:12:26.658]                 }
[16:12:26.658]             }
[16:12:26.658]         }))
[16:12:26.658]     }, error = function(ex) {
[16:12:26.658]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.658]                 ...future.rng), started = ...future.startTime, 
[16:12:26.658]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.658]             version = "1.8"), class = "FutureResult")
[16:12:26.658]     }, finally = {
[16:12:26.658]         if (!identical(...future.workdir, getwd())) 
[16:12:26.658]             setwd(...future.workdir)
[16:12:26.658]         {
[16:12:26.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.658]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.658]             }
[16:12:26.658]             base::options(...future.oldOptions)
[16:12:26.658]             if (.Platform$OS.type == "windows") {
[16:12:26.658]                 old_names <- names(...future.oldEnvVars)
[16:12:26.658]                 envs <- base::Sys.getenv()
[16:12:26.658]                 names <- names(envs)
[16:12:26.658]                 common <- intersect(names, old_names)
[16:12:26.658]                 added <- setdiff(names, old_names)
[16:12:26.658]                 removed <- setdiff(old_names, names)
[16:12:26.658]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.658]                   envs[common]]
[16:12:26.658]                 NAMES <- toupper(changed)
[16:12:26.658]                 args <- list()
[16:12:26.658]                 for (kk in seq_along(NAMES)) {
[16:12:26.658]                   name <- changed[[kk]]
[16:12:26.658]                   NAME <- NAMES[[kk]]
[16:12:26.658]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.658]                     next
[16:12:26.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.658]                 }
[16:12:26.658]                 NAMES <- toupper(added)
[16:12:26.658]                 for (kk in seq_along(NAMES)) {
[16:12:26.658]                   name <- added[[kk]]
[16:12:26.658]                   NAME <- NAMES[[kk]]
[16:12:26.658]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.658]                     next
[16:12:26.658]                   args[[name]] <- ""
[16:12:26.658]                 }
[16:12:26.658]                 NAMES <- toupper(removed)
[16:12:26.658]                 for (kk in seq_along(NAMES)) {
[16:12:26.658]                   name <- removed[[kk]]
[16:12:26.658]                   NAME <- NAMES[[kk]]
[16:12:26.658]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.658]                     next
[16:12:26.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.658]                 }
[16:12:26.658]                 if (length(args) > 0) 
[16:12:26.658]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.658]             }
[16:12:26.658]             else {
[16:12:26.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.658]             }
[16:12:26.658]             {
[16:12:26.658]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.658]                   0L) {
[16:12:26.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.658]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.658]                   base::options(opts)
[16:12:26.658]                 }
[16:12:26.658]                 {
[16:12:26.658]                   {
[16:12:26.658]                     NULL
[16:12:26.658]                     RNGkind("Mersenne-Twister")
[16:12:26.658]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.658]                       inherits = FALSE)
[16:12:26.658]                   }
[16:12:26.658]                   options(future.plan = NULL)
[16:12:26.658]                   if (is.na(NA_character_)) 
[16:12:26.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.658]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.658]                   {
[16:12:26.658]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.658]                     if (!future$lazy) 
[16:12:26.658]                       future <- run(future)
[16:12:26.658]                     invisible(future)
[16:12:26.658]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.658]                 }
[16:12:26.658]             }
[16:12:26.658]         }
[16:12:26.658]     })
[16:12:26.658]     if (TRUE) {
[16:12:26.658]         base::sink(type = "output", split = FALSE)
[16:12:26.658]         if (TRUE) {
[16:12:26.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.658]         }
[16:12:26.658]         else {
[16:12:26.658]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.658]         }
[16:12:26.658]         base::close(...future.stdout)
[16:12:26.658]         ...future.stdout <- NULL
[16:12:26.658]     }
[16:12:26.658]     ...future.result$conditions <- ...future.conditions
[16:12:26.658]     ...future.result$finished <- base::Sys.time()
[16:12:26.658]     ...future.result
[16:12:26.658] }
[16:12:26.660] plan(): Setting new future strategy stack:
[16:12:26.660] List of future strategies:
[16:12:26.660] 1. sequential:
[16:12:26.660]    - args: function (..., envir = parent.frame())
[16:12:26.660]    - tweaked: FALSE
[16:12:26.660]    - call: NULL
[16:12:26.660] plan(): nbrOfWorkers() = 1
[16:12:26.661] plan(): Setting new future strategy stack:
[16:12:26.661] List of future strategies:
[16:12:26.661] 1. sequential:
[16:12:26.661]    - args: function (..., envir = parent.frame())
[16:12:26.661]    - tweaked: FALSE
[16:12:26.661]    - call: plan(strategy)
[16:12:26.661] plan(): nbrOfWorkers() = 1
[16:12:26.661] SequentialFuture started (and completed)
[16:12:26.661] - Launch lazy future ... done
[16:12:26.661] run() for ‘SequentialFuture’ ... done
[16:12:26.662] getGlobalsAndPackages() ...
[16:12:26.662] Searching for globals...
[16:12:26.662] 
[16:12:26.662] Searching for globals ... DONE
[16:12:26.662] - globals: [0] <none>
[16:12:26.662] getGlobalsAndPackages() ... DONE
[16:12:26.662] run() for ‘Future’ ...
[16:12:26.663] - state: ‘created’
[16:12:26.663] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.663] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.663]   - Field: ‘label’
[16:12:26.663]   - Field: ‘local’
[16:12:26.663]   - Field: ‘owner’
[16:12:26.663]   - Field: ‘envir’
[16:12:26.663]   - Field: ‘packages’
[16:12:26.664]   - Field: ‘gc’
[16:12:26.664]   - Field: ‘conditions’
[16:12:26.664]   - Field: ‘expr’
[16:12:26.664]   - Field: ‘uuid’
[16:12:26.664]   - Field: ‘seed’
[16:12:26.664]   - Field: ‘version’
[16:12:26.664]   - Field: ‘result’
[16:12:26.664]   - Field: ‘asynchronous’
[16:12:26.664]   - Field: ‘calls’
[16:12:26.664]   - Field: ‘globals’
[16:12:26.664]   - Field: ‘stdout’
[16:12:26.665]   - Field: ‘earlySignal’
[16:12:26.665]   - Field: ‘lazy’
[16:12:26.665]   - Field: ‘state’
[16:12:26.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.665] - Launch lazy future ...
[16:12:26.665] Packages needed by the future expression (n = 0): <none>
[16:12:26.665] Packages needed by future strategies (n = 0): <none>
[16:12:26.666] {
[16:12:26.666]     {
[16:12:26.666]         {
[16:12:26.666]             ...future.startTime <- base::Sys.time()
[16:12:26.666]             {
[16:12:26.666]                 {
[16:12:26.666]                   {
[16:12:26.666]                     base::local({
[16:12:26.666]                       has_future <- base::requireNamespace("future", 
[16:12:26.666]                         quietly = TRUE)
[16:12:26.666]                       if (has_future) {
[16:12:26.666]                         ns <- base::getNamespace("future")
[16:12:26.666]                         version <- ns[[".package"]][["version"]]
[16:12:26.666]                         if (is.null(version)) 
[16:12:26.666]                           version <- utils::packageVersion("future")
[16:12:26.666]                       }
[16:12:26.666]                       else {
[16:12:26.666]                         version <- NULL
[16:12:26.666]                       }
[16:12:26.666]                       if (!has_future || version < "1.8.0") {
[16:12:26.666]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.666]                           "", base::R.version$version.string), 
[16:12:26.666]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.666]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.666]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.666]                             "release", "version")], collapse = " "), 
[16:12:26.666]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.666]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.666]                           info)
[16:12:26.666]                         info <- base::paste(info, collapse = "; ")
[16:12:26.666]                         if (!has_future) {
[16:12:26.666]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.666]                             info)
[16:12:26.666]                         }
[16:12:26.666]                         else {
[16:12:26.666]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.666]                             info, version)
[16:12:26.666]                         }
[16:12:26.666]                         base::stop(msg)
[16:12:26.666]                       }
[16:12:26.666]                     })
[16:12:26.666]                   }
[16:12:26.666]                   options(future.plan = NULL)
[16:12:26.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.666]                 }
[16:12:26.666]                 ...future.workdir <- getwd()
[16:12:26.666]             }
[16:12:26.666]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.666]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.666]         }
[16:12:26.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.666]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.666]             base::names(...future.oldOptions))
[16:12:26.666]     }
[16:12:26.666]     if (FALSE) {
[16:12:26.666]     }
[16:12:26.666]     else {
[16:12:26.666]         if (TRUE) {
[16:12:26.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.666]                 open = "w")
[16:12:26.666]         }
[16:12:26.666]         else {
[16:12:26.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.666]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.666]         }
[16:12:26.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.666]             base::sink(type = "output", split = FALSE)
[16:12:26.666]             base::close(...future.stdout)
[16:12:26.666]         }, add = TRUE)
[16:12:26.666]     }
[16:12:26.666]     ...future.frame <- base::sys.nframe()
[16:12:26.666]     ...future.conditions <- base::list()
[16:12:26.666]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.666]     if (FALSE) {
[16:12:26.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.666]     }
[16:12:26.666]     ...future.result <- base::tryCatch({
[16:12:26.666]         base::withCallingHandlers({
[16:12:26.666]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.666]             future::FutureResult(value = ...future.value$value, 
[16:12:26.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.666]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.666]                     ...future.globalenv.names))
[16:12:26.666]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.666]         }, condition = base::local({
[16:12:26.666]             c <- base::c
[16:12:26.666]             inherits <- base::inherits
[16:12:26.666]             invokeRestart <- base::invokeRestart
[16:12:26.666]             length <- base::length
[16:12:26.666]             list <- base::list
[16:12:26.666]             seq.int <- base::seq.int
[16:12:26.666]             signalCondition <- base::signalCondition
[16:12:26.666]             sys.calls <- base::sys.calls
[16:12:26.666]             `[[` <- base::`[[`
[16:12:26.666]             `+` <- base::`+`
[16:12:26.666]             `<<-` <- base::`<<-`
[16:12:26.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.666]                   3L)]
[16:12:26.666]             }
[16:12:26.666]             function(cond) {
[16:12:26.666]                 is_error <- inherits(cond, "error")
[16:12:26.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.666]                   NULL)
[16:12:26.666]                 if (is_error) {
[16:12:26.666]                   sessionInformation <- function() {
[16:12:26.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.666]                       search = base::search(), system = base::Sys.info())
[16:12:26.666]                   }
[16:12:26.666]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.666]                     cond$call), session = sessionInformation(), 
[16:12:26.666]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.666]                   signalCondition(cond)
[16:12:26.666]                 }
[16:12:26.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.666]                 "immediateCondition"))) {
[16:12:26.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.666]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.666]                   if (TRUE && !signal) {
[16:12:26.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.666]                     {
[16:12:26.666]                       inherits <- base::inherits
[16:12:26.666]                       invokeRestart <- base::invokeRestart
[16:12:26.666]                       is.null <- base::is.null
[16:12:26.666]                       muffled <- FALSE
[16:12:26.666]                       if (inherits(cond, "message")) {
[16:12:26.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.666]                         if (muffled) 
[16:12:26.666]                           invokeRestart("muffleMessage")
[16:12:26.666]                       }
[16:12:26.666]                       else if (inherits(cond, "warning")) {
[16:12:26.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.666]                         if (muffled) 
[16:12:26.666]                           invokeRestart("muffleWarning")
[16:12:26.666]                       }
[16:12:26.666]                       else if (inherits(cond, "condition")) {
[16:12:26.666]                         if (!is.null(pattern)) {
[16:12:26.666]                           computeRestarts <- base::computeRestarts
[16:12:26.666]                           grepl <- base::grepl
[16:12:26.666]                           restarts <- computeRestarts(cond)
[16:12:26.666]                           for (restart in restarts) {
[16:12:26.666]                             name <- restart$name
[16:12:26.666]                             if (is.null(name)) 
[16:12:26.666]                               next
[16:12:26.666]                             if (!grepl(pattern, name)) 
[16:12:26.666]                               next
[16:12:26.666]                             invokeRestart(restart)
[16:12:26.666]                             muffled <- TRUE
[16:12:26.666]                             break
[16:12:26.666]                           }
[16:12:26.666]                         }
[16:12:26.666]                       }
[16:12:26.666]                       invisible(muffled)
[16:12:26.666]                     }
[16:12:26.666]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.666]                   }
[16:12:26.666]                 }
[16:12:26.666]                 else {
[16:12:26.666]                   if (TRUE) {
[16:12:26.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.666]                     {
[16:12:26.666]                       inherits <- base::inherits
[16:12:26.666]                       invokeRestart <- base::invokeRestart
[16:12:26.666]                       is.null <- base::is.null
[16:12:26.666]                       muffled <- FALSE
[16:12:26.666]                       if (inherits(cond, "message")) {
[16:12:26.666]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.666]                         if (muffled) 
[16:12:26.666]                           invokeRestart("muffleMessage")
[16:12:26.666]                       }
[16:12:26.666]                       else if (inherits(cond, "warning")) {
[16:12:26.666]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.666]                         if (muffled) 
[16:12:26.666]                           invokeRestart("muffleWarning")
[16:12:26.666]                       }
[16:12:26.666]                       else if (inherits(cond, "condition")) {
[16:12:26.666]                         if (!is.null(pattern)) {
[16:12:26.666]                           computeRestarts <- base::computeRestarts
[16:12:26.666]                           grepl <- base::grepl
[16:12:26.666]                           restarts <- computeRestarts(cond)
[16:12:26.666]                           for (restart in restarts) {
[16:12:26.666]                             name <- restart$name
[16:12:26.666]                             if (is.null(name)) 
[16:12:26.666]                               next
[16:12:26.666]                             if (!grepl(pattern, name)) 
[16:12:26.666]                               next
[16:12:26.666]                             invokeRestart(restart)
[16:12:26.666]                             muffled <- TRUE
[16:12:26.666]                             break
[16:12:26.666]                           }
[16:12:26.666]                         }
[16:12:26.666]                       }
[16:12:26.666]                       invisible(muffled)
[16:12:26.666]                     }
[16:12:26.666]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.666]                   }
[16:12:26.666]                 }
[16:12:26.666]             }
[16:12:26.666]         }))
[16:12:26.666]     }, error = function(ex) {
[16:12:26.666]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.666]                 ...future.rng), started = ...future.startTime, 
[16:12:26.666]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.666]             version = "1.8"), class = "FutureResult")
[16:12:26.666]     }, finally = {
[16:12:26.666]         if (!identical(...future.workdir, getwd())) 
[16:12:26.666]             setwd(...future.workdir)
[16:12:26.666]         {
[16:12:26.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.666]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.666]             }
[16:12:26.666]             base::options(...future.oldOptions)
[16:12:26.666]             if (.Platform$OS.type == "windows") {
[16:12:26.666]                 old_names <- names(...future.oldEnvVars)
[16:12:26.666]                 envs <- base::Sys.getenv()
[16:12:26.666]                 names <- names(envs)
[16:12:26.666]                 common <- intersect(names, old_names)
[16:12:26.666]                 added <- setdiff(names, old_names)
[16:12:26.666]                 removed <- setdiff(old_names, names)
[16:12:26.666]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.666]                   envs[common]]
[16:12:26.666]                 NAMES <- toupper(changed)
[16:12:26.666]                 args <- list()
[16:12:26.666]                 for (kk in seq_along(NAMES)) {
[16:12:26.666]                   name <- changed[[kk]]
[16:12:26.666]                   NAME <- NAMES[[kk]]
[16:12:26.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.666]                     next
[16:12:26.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.666]                 }
[16:12:26.666]                 NAMES <- toupper(added)
[16:12:26.666]                 for (kk in seq_along(NAMES)) {
[16:12:26.666]                   name <- added[[kk]]
[16:12:26.666]                   NAME <- NAMES[[kk]]
[16:12:26.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.666]                     next
[16:12:26.666]                   args[[name]] <- ""
[16:12:26.666]                 }
[16:12:26.666]                 NAMES <- toupper(removed)
[16:12:26.666]                 for (kk in seq_along(NAMES)) {
[16:12:26.666]                   name <- removed[[kk]]
[16:12:26.666]                   NAME <- NAMES[[kk]]
[16:12:26.666]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.666]                     next
[16:12:26.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.666]                 }
[16:12:26.666]                 if (length(args) > 0) 
[16:12:26.666]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.666]             }
[16:12:26.666]             else {
[16:12:26.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.666]             }
[16:12:26.666]             {
[16:12:26.666]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.666]                   0L) {
[16:12:26.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.666]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.666]                   base::options(opts)
[16:12:26.666]                 }
[16:12:26.666]                 {
[16:12:26.666]                   {
[16:12:26.666]                     NULL
[16:12:26.666]                     RNGkind("Mersenne-Twister")
[16:12:26.666]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.666]                       inherits = FALSE)
[16:12:26.666]                   }
[16:12:26.666]                   options(future.plan = NULL)
[16:12:26.666]                   if (is.na(NA_character_)) 
[16:12:26.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.666]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.666]                   {
[16:12:26.666]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.666]                     if (!future$lazy) 
[16:12:26.666]                       future <- run(future)
[16:12:26.666]                     invisible(future)
[16:12:26.666]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.666]                 }
[16:12:26.666]             }
[16:12:26.666]         }
[16:12:26.666]     })
[16:12:26.666]     if (TRUE) {
[16:12:26.666]         base::sink(type = "output", split = FALSE)
[16:12:26.666]         if (TRUE) {
[16:12:26.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.666]         }
[16:12:26.666]         else {
[16:12:26.666]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.666]         }
[16:12:26.666]         base::close(...future.stdout)
[16:12:26.666]         ...future.stdout <- NULL
[16:12:26.666]     }
[16:12:26.666]     ...future.result$conditions <- ...future.conditions
[16:12:26.666]     ...future.result$finished <- base::Sys.time()
[16:12:26.666]     ...future.result
[16:12:26.666] }
[16:12:26.667] plan(): Setting new future strategy stack:
[16:12:26.667] List of future strategies:
[16:12:26.667] 1. sequential:
[16:12:26.667]    - args: function (..., envir = parent.frame())
[16:12:26.667]    - tweaked: FALSE
[16:12:26.667]    - call: NULL
[16:12:26.668] plan(): nbrOfWorkers() = 1
[16:12:26.668] plan(): Setting new future strategy stack:
[16:12:26.668] List of future strategies:
[16:12:26.668] 1. sequential:
[16:12:26.668]    - args: function (..., envir = parent.frame())
[16:12:26.668]    - tweaked: FALSE
[16:12:26.668]    - call: plan(strategy)
[16:12:26.669] plan(): nbrOfWorkers() = 1
[16:12:26.669] SequentialFuture started (and completed)
[16:12:26.669] - Launch lazy future ... done
[16:12:26.669] run() for ‘SequentialFuture’ ... done
[16:12:26.670] getGlobalsAndPackages() ...
[16:12:26.670] Searching for globals...
[16:12:26.670] - globals found: [1] ‘{’
[16:12:26.670] Searching for globals ... DONE
[16:12:26.670] Resolving globals: FALSE
[16:12:26.671] 
[16:12:26.671] 
[16:12:26.671] getGlobalsAndPackages() ... DONE
[16:12:26.671] run() for ‘Future’ ...
[16:12:26.671] - state: ‘created’
[16:12:26.671] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.672] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.672] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.672]   - Field: ‘label’
[16:12:26.672]   - Field: ‘local’
[16:12:26.672]   - Field: ‘owner’
[16:12:26.672]   - Field: ‘envir’
[16:12:26.672]   - Field: ‘packages’
[16:12:26.672]   - Field: ‘gc’
[16:12:26.672]   - Field: ‘conditions’
[16:12:26.672]   - Field: ‘expr’
[16:12:26.673]   - Field: ‘uuid’
[16:12:26.673]   - Field: ‘seed’
[16:12:26.673]   - Field: ‘version’
[16:12:26.673]   - Field: ‘result’
[16:12:26.673]   - Field: ‘asynchronous’
[16:12:26.673]   - Field: ‘calls’
[16:12:26.673]   - Field: ‘globals’
[16:12:26.673]   - Field: ‘stdout’
[16:12:26.673]   - Field: ‘earlySignal’
[16:12:26.673]   - Field: ‘lazy’
[16:12:26.673]   - Field: ‘state’
[16:12:26.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.674] - Launch lazy future ...
[16:12:26.674] Packages needed by the future expression (n = 0): <none>
[16:12:26.674] Packages needed by future strategies (n = 0): <none>
[16:12:26.674] {
[16:12:26.674]     {
[16:12:26.674]         {
[16:12:26.674]             ...future.startTime <- base::Sys.time()
[16:12:26.674]             {
[16:12:26.674]                 {
[16:12:26.674]                   {
[16:12:26.674]                     base::local({
[16:12:26.674]                       has_future <- base::requireNamespace("future", 
[16:12:26.674]                         quietly = TRUE)
[16:12:26.674]                       if (has_future) {
[16:12:26.674]                         ns <- base::getNamespace("future")
[16:12:26.674]                         version <- ns[[".package"]][["version"]]
[16:12:26.674]                         if (is.null(version)) 
[16:12:26.674]                           version <- utils::packageVersion("future")
[16:12:26.674]                       }
[16:12:26.674]                       else {
[16:12:26.674]                         version <- NULL
[16:12:26.674]                       }
[16:12:26.674]                       if (!has_future || version < "1.8.0") {
[16:12:26.674]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.674]                           "", base::R.version$version.string), 
[16:12:26.674]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.674]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.674]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.674]                             "release", "version")], collapse = " "), 
[16:12:26.674]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.674]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.674]                           info)
[16:12:26.674]                         info <- base::paste(info, collapse = "; ")
[16:12:26.674]                         if (!has_future) {
[16:12:26.674]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.674]                             info)
[16:12:26.674]                         }
[16:12:26.674]                         else {
[16:12:26.674]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.674]                             info, version)
[16:12:26.674]                         }
[16:12:26.674]                         base::stop(msg)
[16:12:26.674]                       }
[16:12:26.674]                     })
[16:12:26.674]                   }
[16:12:26.674]                   options(future.plan = NULL)
[16:12:26.674]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.674]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.674]                 }
[16:12:26.674]                 ...future.workdir <- getwd()
[16:12:26.674]             }
[16:12:26.674]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.674]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.674]         }
[16:12:26.674]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.674]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.674]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.674]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.674]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.674]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.674]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.674]             base::names(...future.oldOptions))
[16:12:26.674]     }
[16:12:26.674]     if (FALSE) {
[16:12:26.674]     }
[16:12:26.674]     else {
[16:12:26.674]         if (TRUE) {
[16:12:26.674]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.674]                 open = "w")
[16:12:26.674]         }
[16:12:26.674]         else {
[16:12:26.674]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.674]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.674]         }
[16:12:26.674]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.674]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.674]             base::sink(type = "output", split = FALSE)
[16:12:26.674]             base::close(...future.stdout)
[16:12:26.674]         }, add = TRUE)
[16:12:26.674]     }
[16:12:26.674]     ...future.frame <- base::sys.nframe()
[16:12:26.674]     ...future.conditions <- base::list()
[16:12:26.674]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.674]     if (FALSE) {
[16:12:26.674]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.674]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.674]     }
[16:12:26.674]     ...future.result <- base::tryCatch({
[16:12:26.674]         base::withCallingHandlers({
[16:12:26.674]             ...future.value <- base::withVisible(base::local({
[16:12:26.674]                 4
[16:12:26.674]             }))
[16:12:26.674]             future::FutureResult(value = ...future.value$value, 
[16:12:26.674]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.674]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.674]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.674]                     ...future.globalenv.names))
[16:12:26.674]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.674]         }, condition = base::local({
[16:12:26.674]             c <- base::c
[16:12:26.674]             inherits <- base::inherits
[16:12:26.674]             invokeRestart <- base::invokeRestart
[16:12:26.674]             length <- base::length
[16:12:26.674]             list <- base::list
[16:12:26.674]             seq.int <- base::seq.int
[16:12:26.674]             signalCondition <- base::signalCondition
[16:12:26.674]             sys.calls <- base::sys.calls
[16:12:26.674]             `[[` <- base::`[[`
[16:12:26.674]             `+` <- base::`+`
[16:12:26.674]             `<<-` <- base::`<<-`
[16:12:26.674]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.674]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.674]                   3L)]
[16:12:26.674]             }
[16:12:26.674]             function(cond) {
[16:12:26.674]                 is_error <- inherits(cond, "error")
[16:12:26.674]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.674]                   NULL)
[16:12:26.674]                 if (is_error) {
[16:12:26.674]                   sessionInformation <- function() {
[16:12:26.674]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.674]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.674]                       search = base::search(), system = base::Sys.info())
[16:12:26.674]                   }
[16:12:26.674]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.674]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.674]                     cond$call), session = sessionInformation(), 
[16:12:26.674]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.674]                   signalCondition(cond)
[16:12:26.674]                 }
[16:12:26.674]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.674]                 "immediateCondition"))) {
[16:12:26.674]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.674]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.674]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.674]                   if (TRUE && !signal) {
[16:12:26.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.674]                     {
[16:12:26.674]                       inherits <- base::inherits
[16:12:26.674]                       invokeRestart <- base::invokeRestart
[16:12:26.674]                       is.null <- base::is.null
[16:12:26.674]                       muffled <- FALSE
[16:12:26.674]                       if (inherits(cond, "message")) {
[16:12:26.674]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.674]                         if (muffled) 
[16:12:26.674]                           invokeRestart("muffleMessage")
[16:12:26.674]                       }
[16:12:26.674]                       else if (inherits(cond, "warning")) {
[16:12:26.674]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.674]                         if (muffled) 
[16:12:26.674]                           invokeRestart("muffleWarning")
[16:12:26.674]                       }
[16:12:26.674]                       else if (inherits(cond, "condition")) {
[16:12:26.674]                         if (!is.null(pattern)) {
[16:12:26.674]                           computeRestarts <- base::computeRestarts
[16:12:26.674]                           grepl <- base::grepl
[16:12:26.674]                           restarts <- computeRestarts(cond)
[16:12:26.674]                           for (restart in restarts) {
[16:12:26.674]                             name <- restart$name
[16:12:26.674]                             if (is.null(name)) 
[16:12:26.674]                               next
[16:12:26.674]                             if (!grepl(pattern, name)) 
[16:12:26.674]                               next
[16:12:26.674]                             invokeRestart(restart)
[16:12:26.674]                             muffled <- TRUE
[16:12:26.674]                             break
[16:12:26.674]                           }
[16:12:26.674]                         }
[16:12:26.674]                       }
[16:12:26.674]                       invisible(muffled)
[16:12:26.674]                     }
[16:12:26.674]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.674]                   }
[16:12:26.674]                 }
[16:12:26.674]                 else {
[16:12:26.674]                   if (TRUE) {
[16:12:26.674]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.674]                     {
[16:12:26.674]                       inherits <- base::inherits
[16:12:26.674]                       invokeRestart <- base::invokeRestart
[16:12:26.674]                       is.null <- base::is.null
[16:12:26.674]                       muffled <- FALSE
[16:12:26.674]                       if (inherits(cond, "message")) {
[16:12:26.674]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.674]                         if (muffled) 
[16:12:26.674]                           invokeRestart("muffleMessage")
[16:12:26.674]                       }
[16:12:26.674]                       else if (inherits(cond, "warning")) {
[16:12:26.674]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.674]                         if (muffled) 
[16:12:26.674]                           invokeRestart("muffleWarning")
[16:12:26.674]                       }
[16:12:26.674]                       else if (inherits(cond, "condition")) {
[16:12:26.674]                         if (!is.null(pattern)) {
[16:12:26.674]                           computeRestarts <- base::computeRestarts
[16:12:26.674]                           grepl <- base::grepl
[16:12:26.674]                           restarts <- computeRestarts(cond)
[16:12:26.674]                           for (restart in restarts) {
[16:12:26.674]                             name <- restart$name
[16:12:26.674]                             if (is.null(name)) 
[16:12:26.674]                               next
[16:12:26.674]                             if (!grepl(pattern, name)) 
[16:12:26.674]                               next
[16:12:26.674]                             invokeRestart(restart)
[16:12:26.674]                             muffled <- TRUE
[16:12:26.674]                             break
[16:12:26.674]                           }
[16:12:26.674]                         }
[16:12:26.674]                       }
[16:12:26.674]                       invisible(muffled)
[16:12:26.674]                     }
[16:12:26.674]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.674]                   }
[16:12:26.674]                 }
[16:12:26.674]             }
[16:12:26.674]         }))
[16:12:26.674]     }, error = function(ex) {
[16:12:26.674]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.674]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.674]                 ...future.rng), started = ...future.startTime, 
[16:12:26.674]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.674]             version = "1.8"), class = "FutureResult")
[16:12:26.674]     }, finally = {
[16:12:26.674]         if (!identical(...future.workdir, getwd())) 
[16:12:26.674]             setwd(...future.workdir)
[16:12:26.674]         {
[16:12:26.674]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.674]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.674]             }
[16:12:26.674]             base::options(...future.oldOptions)
[16:12:26.674]             if (.Platform$OS.type == "windows") {
[16:12:26.674]                 old_names <- names(...future.oldEnvVars)
[16:12:26.674]                 envs <- base::Sys.getenv()
[16:12:26.674]                 names <- names(envs)
[16:12:26.674]                 common <- intersect(names, old_names)
[16:12:26.674]                 added <- setdiff(names, old_names)
[16:12:26.674]                 removed <- setdiff(old_names, names)
[16:12:26.674]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.674]                   envs[common]]
[16:12:26.674]                 NAMES <- toupper(changed)
[16:12:26.674]                 args <- list()
[16:12:26.674]                 for (kk in seq_along(NAMES)) {
[16:12:26.674]                   name <- changed[[kk]]
[16:12:26.674]                   NAME <- NAMES[[kk]]
[16:12:26.674]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.674]                     next
[16:12:26.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.674]                 }
[16:12:26.674]                 NAMES <- toupper(added)
[16:12:26.674]                 for (kk in seq_along(NAMES)) {
[16:12:26.674]                   name <- added[[kk]]
[16:12:26.674]                   NAME <- NAMES[[kk]]
[16:12:26.674]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.674]                     next
[16:12:26.674]                   args[[name]] <- ""
[16:12:26.674]                 }
[16:12:26.674]                 NAMES <- toupper(removed)
[16:12:26.674]                 for (kk in seq_along(NAMES)) {
[16:12:26.674]                   name <- removed[[kk]]
[16:12:26.674]                   NAME <- NAMES[[kk]]
[16:12:26.674]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.674]                     next
[16:12:26.674]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.674]                 }
[16:12:26.674]                 if (length(args) > 0) 
[16:12:26.674]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.674]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.674]             }
[16:12:26.674]             else {
[16:12:26.674]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.674]             }
[16:12:26.674]             {
[16:12:26.674]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.674]                   0L) {
[16:12:26.674]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.674]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.674]                   base::options(opts)
[16:12:26.674]                 }
[16:12:26.674]                 {
[16:12:26.674]                   {
[16:12:26.674]                     NULL
[16:12:26.674]                     RNGkind("Mersenne-Twister")
[16:12:26.674]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.674]                       inherits = FALSE)
[16:12:26.674]                   }
[16:12:26.674]                   options(future.plan = NULL)
[16:12:26.674]                   if (is.na(NA_character_)) 
[16:12:26.674]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.674]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.674]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.674]                   {
[16:12:26.674]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.674]                     if (!future$lazy) 
[16:12:26.674]                       future <- run(future)
[16:12:26.674]                     invisible(future)
[16:12:26.674]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.674]                 }
[16:12:26.674]             }
[16:12:26.674]         }
[16:12:26.674]     })
[16:12:26.674]     if (TRUE) {
[16:12:26.674]         base::sink(type = "output", split = FALSE)
[16:12:26.674]         if (TRUE) {
[16:12:26.674]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.674]         }
[16:12:26.674]         else {
[16:12:26.674]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.674]         }
[16:12:26.674]         base::close(...future.stdout)
[16:12:26.674]         ...future.stdout <- NULL
[16:12:26.674]     }
[16:12:26.674]     ...future.result$conditions <- ...future.conditions
[16:12:26.674]     ...future.result$finished <- base::Sys.time()
[16:12:26.674]     ...future.result
[16:12:26.674] }
[16:12:26.676] plan(): Setting new future strategy stack:
[16:12:26.676] List of future strategies:
[16:12:26.676] 1. sequential:
[16:12:26.676]    - args: function (..., envir = parent.frame())
[16:12:26.676]    - tweaked: FALSE
[16:12:26.676]    - call: NULL
[16:12:26.677] plan(): nbrOfWorkers() = 1
[16:12:26.677] plan(): Setting new future strategy stack:
[16:12:26.677] List of future strategies:
[16:12:26.677] 1. sequential:
[16:12:26.677]    - args: function (..., envir = parent.frame())
[16:12:26.677]    - tweaked: FALSE
[16:12:26.677]    - call: plan(strategy)
[16:12:26.678] plan(): nbrOfWorkers() = 1
[16:12:26.678] SequentialFuture started (and completed)
[16:12:26.678] - Launch lazy future ... done
[16:12:26.678] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560baefe42d8> 
Classes 'listenv', 'environment' <environment: 0x560baef39b30> 
[16:12:26.683] resolved() for ‘SequentialFuture’ ...
[16:12:26.683] - state: ‘finished’
[16:12:26.683] - run: TRUE
[16:12:26.683] - result: ‘FutureResult’
[16:12:26.683] resolved() for ‘SequentialFuture’ ... done
[16:12:26.683] resolved() for ‘SequentialFuture’ ...
[16:12:26.683] - state: ‘finished’
[16:12:26.683] - run: TRUE
[16:12:26.683] - result: ‘FutureResult’
[16:12:26.683] resolved() for ‘SequentialFuture’ ... done
[16:12:26.684] resolved() for ‘SequentialFuture’ ...
[16:12:26.684] - state: ‘finished’
[16:12:26.684] - run: TRUE
[16:12:26.684] - result: ‘FutureResult’
[16:12:26.684] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:26.686] resolve() on list environment ...
[16:12:26.686]  recursive: 0
[16:12:26.687]  length: 6
[16:12:26.687]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:26.687] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.687] - nx: 6
[16:12:26.687] - relay: TRUE
[16:12:26.687] - stdout: TRUE
[16:12:26.687] - signal: TRUE
[16:12:26.687] - resignal: FALSE
[16:12:26.687] - force: TRUE
[16:12:26.687] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.687] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.688]  - until=2
[16:12:26.688]  - relaying element #2
[16:12:26.688] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.688] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.688] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.688]  length: 5 (resolved future 1)
[16:12:26.688] resolved() for ‘SequentialFuture’ ...
[16:12:26.688] - state: ‘finished’
[16:12:26.688] - run: TRUE
[16:12:26.688] - result: ‘FutureResult’
[16:12:26.689] resolved() for ‘SequentialFuture’ ... done
[16:12:26.689] Future #2
[16:12:26.689] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.689] - nx: 6
[16:12:26.689] - relay: TRUE
[16:12:26.689] - stdout: TRUE
[16:12:26.689] - signal: TRUE
[16:12:26.689] - resignal: FALSE
[16:12:26.689] - force: TRUE
[16:12:26.689] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.689] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.689]  - until=2
[16:12:26.690]  - relaying element #2
[16:12:26.690] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.690] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.690] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.690]  length: 4 (resolved future 2)
[16:12:26.690] resolved() for ‘SequentialFuture’ ...
[16:12:26.690] - state: ‘finished’
[16:12:26.690] - run: TRUE
[16:12:26.690] - result: ‘FutureResult’
[16:12:26.690] resolved() for ‘SequentialFuture’ ... done
[16:12:26.691] Future #3
[16:12:26.691] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.691] - nx: 6
[16:12:26.691] - relay: TRUE
[16:12:26.691] - stdout: TRUE
[16:12:26.691] - signal: TRUE
[16:12:26.691] - resignal: FALSE
[16:12:26.691] - force: TRUE
[16:12:26.691] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.691] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.691]  - until=3
[16:12:26.692]  - relaying element #3
[16:12:26.692] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.692] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.692] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.692]  length: 3 (resolved future 3)
[16:12:26.692] resolved() for ‘SequentialFuture’ ...
[16:12:26.692] - state: ‘finished’
[16:12:26.692] - run: TRUE
[16:12:26.692] - result: ‘FutureResult’
[16:12:26.692] resolved() for ‘SequentialFuture’ ... done
[16:12:26.693] Future #4
[16:12:26.693] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.693] - nx: 6
[16:12:26.693] - relay: TRUE
[16:12:26.693] - stdout: TRUE
[16:12:26.693] - signal: TRUE
[16:12:26.693] - resignal: FALSE
[16:12:26.693] - force: TRUE
[16:12:26.693] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.693] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.693]  - until=4
[16:12:26.694]  - relaying element #4
[16:12:26.694] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.694] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.694] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.694]  length: 2 (resolved future 4)
[16:12:26.694] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.694] - nx: 6
[16:12:26.694] - relay: TRUE
[16:12:26.694] - stdout: TRUE
[16:12:26.694] - signal: TRUE
[16:12:26.694] - resignal: FALSE
[16:12:26.695] - force: TRUE
[16:12:26.695] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.695] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.695]  - until=6
[16:12:26.695]  - relaying element #6
[16:12:26.695] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.695] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.695] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.695]  length: 1 (resolved future 5)
[16:12:26.695] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.695] - nx: 6
[16:12:26.696] - relay: TRUE
[16:12:26.696] - stdout: TRUE
[16:12:26.696] - signal: TRUE
[16:12:26.696] - resignal: FALSE
[16:12:26.696] - force: TRUE
[16:12:26.696] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.696] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.696]  - until=6
[16:12:26.696] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.696] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.696] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.696]  length: 0 (resolved future 6)
[16:12:26.697] Relaying remaining futures
[16:12:26.697] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.697] - nx: 6
[16:12:26.697] - relay: TRUE
[16:12:26.697] - stdout: TRUE
[16:12:26.697] - signal: TRUE
[16:12:26.697] - resignal: FALSE
[16:12:26.697] - force: TRUE
[16:12:26.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.697] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:26.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.697] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.698] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.698] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bad2f6c90> 
Dimensions: c(1, 6)
[16:12:26.698] getGlobalsAndPackages() ...
[16:12:26.698] Searching for globals...
[16:12:26.699] 
[16:12:26.699] Searching for globals ... DONE
[16:12:26.699] - globals: [0] <none>
[16:12:26.699] getGlobalsAndPackages() ... DONE
[16:12:26.699] run() for ‘Future’ ...
[16:12:26.699] - state: ‘created’
[16:12:26.699] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.700] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.700]   - Field: ‘label’
[16:12:26.700]   - Field: ‘local’
[16:12:26.700]   - Field: ‘owner’
[16:12:26.700]   - Field: ‘envir’
[16:12:26.700]   - Field: ‘packages’
[16:12:26.700]   - Field: ‘gc’
[16:12:26.700]   - Field: ‘conditions’
[16:12:26.700]   - Field: ‘expr’
[16:12:26.701]   - Field: ‘uuid’
[16:12:26.701]   - Field: ‘seed’
[16:12:26.701]   - Field: ‘version’
[16:12:26.701]   - Field: ‘result’
[16:12:26.701]   - Field: ‘asynchronous’
[16:12:26.701]   - Field: ‘calls’
[16:12:26.701]   - Field: ‘globals’
[16:12:26.701]   - Field: ‘stdout’
[16:12:26.701]   - Field: ‘earlySignal’
[16:12:26.701]   - Field: ‘lazy’
[16:12:26.701]   - Field: ‘state’
[16:12:26.702] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.702] - Launch lazy future ...
[16:12:26.702] Packages needed by the future expression (n = 0): <none>
[16:12:26.702] Packages needed by future strategies (n = 0): <none>
[16:12:26.725] {
[16:12:26.725]     {
[16:12:26.725]         {
[16:12:26.725]             ...future.startTime <- base::Sys.time()
[16:12:26.725]             {
[16:12:26.725]                 {
[16:12:26.725]                   {
[16:12:26.725]                     base::local({
[16:12:26.725]                       has_future <- base::requireNamespace("future", 
[16:12:26.725]                         quietly = TRUE)
[16:12:26.725]                       if (has_future) {
[16:12:26.725]                         ns <- base::getNamespace("future")
[16:12:26.725]                         version <- ns[[".package"]][["version"]]
[16:12:26.725]                         if (is.null(version)) 
[16:12:26.725]                           version <- utils::packageVersion("future")
[16:12:26.725]                       }
[16:12:26.725]                       else {
[16:12:26.725]                         version <- NULL
[16:12:26.725]                       }
[16:12:26.725]                       if (!has_future || version < "1.8.0") {
[16:12:26.725]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.725]                           "", base::R.version$version.string), 
[16:12:26.725]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.725]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.725]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.725]                             "release", "version")], collapse = " "), 
[16:12:26.725]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.725]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.725]                           info)
[16:12:26.725]                         info <- base::paste(info, collapse = "; ")
[16:12:26.725]                         if (!has_future) {
[16:12:26.725]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.725]                             info)
[16:12:26.725]                         }
[16:12:26.725]                         else {
[16:12:26.725]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.725]                             info, version)
[16:12:26.725]                         }
[16:12:26.725]                         base::stop(msg)
[16:12:26.725]                       }
[16:12:26.725]                     })
[16:12:26.725]                   }
[16:12:26.725]                   options(future.plan = NULL)
[16:12:26.725]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.725]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.725]                 }
[16:12:26.725]                 ...future.workdir <- getwd()
[16:12:26.725]             }
[16:12:26.725]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.725]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.725]         }
[16:12:26.725]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.725]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.725]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.725]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.725]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.725]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.725]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.725]             base::names(...future.oldOptions))
[16:12:26.725]     }
[16:12:26.725]     if (FALSE) {
[16:12:26.725]     }
[16:12:26.725]     else {
[16:12:26.725]         if (TRUE) {
[16:12:26.725]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.725]                 open = "w")
[16:12:26.725]         }
[16:12:26.725]         else {
[16:12:26.725]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.725]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.725]         }
[16:12:26.725]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.725]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.725]             base::sink(type = "output", split = FALSE)
[16:12:26.725]             base::close(...future.stdout)
[16:12:26.725]         }, add = TRUE)
[16:12:26.725]     }
[16:12:26.725]     ...future.frame <- base::sys.nframe()
[16:12:26.725]     ...future.conditions <- base::list()
[16:12:26.725]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.725]     if (FALSE) {
[16:12:26.725]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.725]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.725]     }
[16:12:26.725]     ...future.result <- base::tryCatch({
[16:12:26.725]         base::withCallingHandlers({
[16:12:26.725]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.725]             future::FutureResult(value = ...future.value$value, 
[16:12:26.725]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.725]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.725]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.725]                     ...future.globalenv.names))
[16:12:26.725]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.725]         }, condition = base::local({
[16:12:26.725]             c <- base::c
[16:12:26.725]             inherits <- base::inherits
[16:12:26.725]             invokeRestart <- base::invokeRestart
[16:12:26.725]             length <- base::length
[16:12:26.725]             list <- base::list
[16:12:26.725]             seq.int <- base::seq.int
[16:12:26.725]             signalCondition <- base::signalCondition
[16:12:26.725]             sys.calls <- base::sys.calls
[16:12:26.725]             `[[` <- base::`[[`
[16:12:26.725]             `+` <- base::`+`
[16:12:26.725]             `<<-` <- base::`<<-`
[16:12:26.725]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.725]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.725]                   3L)]
[16:12:26.725]             }
[16:12:26.725]             function(cond) {
[16:12:26.725]                 is_error <- inherits(cond, "error")
[16:12:26.725]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.725]                   NULL)
[16:12:26.725]                 if (is_error) {
[16:12:26.725]                   sessionInformation <- function() {
[16:12:26.725]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.725]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.725]                       search = base::search(), system = base::Sys.info())
[16:12:26.725]                   }
[16:12:26.725]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.725]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.725]                     cond$call), session = sessionInformation(), 
[16:12:26.725]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.725]                   signalCondition(cond)
[16:12:26.725]                 }
[16:12:26.725]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.725]                 "immediateCondition"))) {
[16:12:26.725]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.725]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.725]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.725]                   if (TRUE && !signal) {
[16:12:26.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.725]                     {
[16:12:26.725]                       inherits <- base::inherits
[16:12:26.725]                       invokeRestart <- base::invokeRestart
[16:12:26.725]                       is.null <- base::is.null
[16:12:26.725]                       muffled <- FALSE
[16:12:26.725]                       if (inherits(cond, "message")) {
[16:12:26.725]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.725]                         if (muffled) 
[16:12:26.725]                           invokeRestart("muffleMessage")
[16:12:26.725]                       }
[16:12:26.725]                       else if (inherits(cond, "warning")) {
[16:12:26.725]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.725]                         if (muffled) 
[16:12:26.725]                           invokeRestart("muffleWarning")
[16:12:26.725]                       }
[16:12:26.725]                       else if (inherits(cond, "condition")) {
[16:12:26.725]                         if (!is.null(pattern)) {
[16:12:26.725]                           computeRestarts <- base::computeRestarts
[16:12:26.725]                           grepl <- base::grepl
[16:12:26.725]                           restarts <- computeRestarts(cond)
[16:12:26.725]                           for (restart in restarts) {
[16:12:26.725]                             name <- restart$name
[16:12:26.725]                             if (is.null(name)) 
[16:12:26.725]                               next
[16:12:26.725]                             if (!grepl(pattern, name)) 
[16:12:26.725]                               next
[16:12:26.725]                             invokeRestart(restart)
[16:12:26.725]                             muffled <- TRUE
[16:12:26.725]                             break
[16:12:26.725]                           }
[16:12:26.725]                         }
[16:12:26.725]                       }
[16:12:26.725]                       invisible(muffled)
[16:12:26.725]                     }
[16:12:26.725]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.725]                   }
[16:12:26.725]                 }
[16:12:26.725]                 else {
[16:12:26.725]                   if (TRUE) {
[16:12:26.725]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.725]                     {
[16:12:26.725]                       inherits <- base::inherits
[16:12:26.725]                       invokeRestart <- base::invokeRestart
[16:12:26.725]                       is.null <- base::is.null
[16:12:26.725]                       muffled <- FALSE
[16:12:26.725]                       if (inherits(cond, "message")) {
[16:12:26.725]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.725]                         if (muffled) 
[16:12:26.725]                           invokeRestart("muffleMessage")
[16:12:26.725]                       }
[16:12:26.725]                       else if (inherits(cond, "warning")) {
[16:12:26.725]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.725]                         if (muffled) 
[16:12:26.725]                           invokeRestart("muffleWarning")
[16:12:26.725]                       }
[16:12:26.725]                       else if (inherits(cond, "condition")) {
[16:12:26.725]                         if (!is.null(pattern)) {
[16:12:26.725]                           computeRestarts <- base::computeRestarts
[16:12:26.725]                           grepl <- base::grepl
[16:12:26.725]                           restarts <- computeRestarts(cond)
[16:12:26.725]                           for (restart in restarts) {
[16:12:26.725]                             name <- restart$name
[16:12:26.725]                             if (is.null(name)) 
[16:12:26.725]                               next
[16:12:26.725]                             if (!grepl(pattern, name)) 
[16:12:26.725]                               next
[16:12:26.725]                             invokeRestart(restart)
[16:12:26.725]                             muffled <- TRUE
[16:12:26.725]                             break
[16:12:26.725]                           }
[16:12:26.725]                         }
[16:12:26.725]                       }
[16:12:26.725]                       invisible(muffled)
[16:12:26.725]                     }
[16:12:26.725]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.725]                   }
[16:12:26.725]                 }
[16:12:26.725]             }
[16:12:26.725]         }))
[16:12:26.725]     }, error = function(ex) {
[16:12:26.725]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.725]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.725]                 ...future.rng), started = ...future.startTime, 
[16:12:26.725]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.725]             version = "1.8"), class = "FutureResult")
[16:12:26.725]     }, finally = {
[16:12:26.725]         if (!identical(...future.workdir, getwd())) 
[16:12:26.725]             setwd(...future.workdir)
[16:12:26.725]         {
[16:12:26.725]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.725]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.725]             }
[16:12:26.725]             base::options(...future.oldOptions)
[16:12:26.725]             if (.Platform$OS.type == "windows") {
[16:12:26.725]                 old_names <- names(...future.oldEnvVars)
[16:12:26.725]                 envs <- base::Sys.getenv()
[16:12:26.725]                 names <- names(envs)
[16:12:26.725]                 common <- intersect(names, old_names)
[16:12:26.725]                 added <- setdiff(names, old_names)
[16:12:26.725]                 removed <- setdiff(old_names, names)
[16:12:26.725]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.725]                   envs[common]]
[16:12:26.725]                 NAMES <- toupper(changed)
[16:12:26.725]                 args <- list()
[16:12:26.725]                 for (kk in seq_along(NAMES)) {
[16:12:26.725]                   name <- changed[[kk]]
[16:12:26.725]                   NAME <- NAMES[[kk]]
[16:12:26.725]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.725]                     next
[16:12:26.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.725]                 }
[16:12:26.725]                 NAMES <- toupper(added)
[16:12:26.725]                 for (kk in seq_along(NAMES)) {
[16:12:26.725]                   name <- added[[kk]]
[16:12:26.725]                   NAME <- NAMES[[kk]]
[16:12:26.725]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.725]                     next
[16:12:26.725]                   args[[name]] <- ""
[16:12:26.725]                 }
[16:12:26.725]                 NAMES <- toupper(removed)
[16:12:26.725]                 for (kk in seq_along(NAMES)) {
[16:12:26.725]                   name <- removed[[kk]]
[16:12:26.725]                   NAME <- NAMES[[kk]]
[16:12:26.725]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.725]                     next
[16:12:26.725]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.725]                 }
[16:12:26.725]                 if (length(args) > 0) 
[16:12:26.725]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.725]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.725]             }
[16:12:26.725]             else {
[16:12:26.725]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.725]             }
[16:12:26.725]             {
[16:12:26.725]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.725]                   0L) {
[16:12:26.725]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.725]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.725]                   base::options(opts)
[16:12:26.725]                 }
[16:12:26.725]                 {
[16:12:26.725]                   {
[16:12:26.725]                     NULL
[16:12:26.725]                     RNGkind("Mersenne-Twister")
[16:12:26.725]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.725]                       inherits = FALSE)
[16:12:26.725]                   }
[16:12:26.725]                   options(future.plan = NULL)
[16:12:26.725]                   if (is.na(NA_character_)) 
[16:12:26.725]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.725]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.725]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.725]                   {
[16:12:26.725]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.725]                     if (!future$lazy) 
[16:12:26.725]                       future <- run(future)
[16:12:26.725]                     invisible(future)
[16:12:26.725]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.725]                 }
[16:12:26.725]             }
[16:12:26.725]         }
[16:12:26.725]     })
[16:12:26.725]     if (TRUE) {
[16:12:26.725]         base::sink(type = "output", split = FALSE)
[16:12:26.725]         if (TRUE) {
[16:12:26.725]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.725]         }
[16:12:26.725]         else {
[16:12:26.725]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.725]         }
[16:12:26.725]         base::close(...future.stdout)
[16:12:26.725]         ...future.stdout <- NULL
[16:12:26.725]     }
[16:12:26.725]     ...future.result$conditions <- ...future.conditions
[16:12:26.725]     ...future.result$finished <- base::Sys.time()
[16:12:26.725]     ...future.result
[16:12:26.725] }
[16:12:26.726] plan(): Setting new future strategy stack:
[16:12:26.726] List of future strategies:
[16:12:26.726] 1. sequential:
[16:12:26.726]    - args: function (..., envir = parent.frame())
[16:12:26.726]    - tweaked: FALSE
[16:12:26.726]    - call: NULL
[16:12:26.727] plan(): nbrOfWorkers() = 1
[16:12:26.728] plan(): Setting new future strategy stack:
[16:12:26.728] List of future strategies:
[16:12:26.728] 1. sequential:
[16:12:26.728]    - args: function (..., envir = parent.frame())
[16:12:26.728]    - tweaked: FALSE
[16:12:26.728]    - call: plan(strategy)
[16:12:26.728] plan(): nbrOfWorkers() = 1
[16:12:26.728] SequentialFuture started (and completed)
[16:12:26.728] - Launch lazy future ... done
[16:12:26.729] run() for ‘SequentialFuture’ ... done
[16:12:26.729] getGlobalsAndPackages() ...
[16:12:26.729] Searching for globals...
[16:12:26.729] 
[16:12:26.729] Searching for globals ... DONE
[16:12:26.729] - globals: [0] <none>
[16:12:26.729] getGlobalsAndPackages() ... DONE
[16:12:26.730] run() for ‘Future’ ...
[16:12:26.730] - state: ‘created’
[16:12:26.730] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.730] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.730]   - Field: ‘label’
[16:12:26.730]   - Field: ‘local’
[16:12:26.730]   - Field: ‘owner’
[16:12:26.731]   - Field: ‘envir’
[16:12:26.731]   - Field: ‘packages’
[16:12:26.731]   - Field: ‘gc’
[16:12:26.731]   - Field: ‘conditions’
[16:12:26.731]   - Field: ‘expr’
[16:12:26.731]   - Field: ‘uuid’
[16:12:26.731]   - Field: ‘seed’
[16:12:26.731]   - Field: ‘version’
[16:12:26.731]   - Field: ‘result’
[16:12:26.731]   - Field: ‘asynchronous’
[16:12:26.731]   - Field: ‘calls’
[16:12:26.732]   - Field: ‘globals’
[16:12:26.732]   - Field: ‘stdout’
[16:12:26.732]   - Field: ‘earlySignal’
[16:12:26.732]   - Field: ‘lazy’
[16:12:26.732]   - Field: ‘state’
[16:12:26.732] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.732] - Launch lazy future ...
[16:12:26.732] Packages needed by the future expression (n = 0): <none>
[16:12:26.732] Packages needed by future strategies (n = 0): <none>
[16:12:26.733] {
[16:12:26.733]     {
[16:12:26.733]         {
[16:12:26.733]             ...future.startTime <- base::Sys.time()
[16:12:26.733]             {
[16:12:26.733]                 {
[16:12:26.733]                   {
[16:12:26.733]                     base::local({
[16:12:26.733]                       has_future <- base::requireNamespace("future", 
[16:12:26.733]                         quietly = TRUE)
[16:12:26.733]                       if (has_future) {
[16:12:26.733]                         ns <- base::getNamespace("future")
[16:12:26.733]                         version <- ns[[".package"]][["version"]]
[16:12:26.733]                         if (is.null(version)) 
[16:12:26.733]                           version <- utils::packageVersion("future")
[16:12:26.733]                       }
[16:12:26.733]                       else {
[16:12:26.733]                         version <- NULL
[16:12:26.733]                       }
[16:12:26.733]                       if (!has_future || version < "1.8.0") {
[16:12:26.733]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.733]                           "", base::R.version$version.string), 
[16:12:26.733]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.733]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.733]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.733]                             "release", "version")], collapse = " "), 
[16:12:26.733]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.733]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.733]                           info)
[16:12:26.733]                         info <- base::paste(info, collapse = "; ")
[16:12:26.733]                         if (!has_future) {
[16:12:26.733]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.733]                             info)
[16:12:26.733]                         }
[16:12:26.733]                         else {
[16:12:26.733]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.733]                             info, version)
[16:12:26.733]                         }
[16:12:26.733]                         base::stop(msg)
[16:12:26.733]                       }
[16:12:26.733]                     })
[16:12:26.733]                   }
[16:12:26.733]                   options(future.plan = NULL)
[16:12:26.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.733]                 }
[16:12:26.733]                 ...future.workdir <- getwd()
[16:12:26.733]             }
[16:12:26.733]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.733]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.733]         }
[16:12:26.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.733]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.733]             base::names(...future.oldOptions))
[16:12:26.733]     }
[16:12:26.733]     if (FALSE) {
[16:12:26.733]     }
[16:12:26.733]     else {
[16:12:26.733]         if (TRUE) {
[16:12:26.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.733]                 open = "w")
[16:12:26.733]         }
[16:12:26.733]         else {
[16:12:26.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.733]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.733]         }
[16:12:26.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.733]             base::sink(type = "output", split = FALSE)
[16:12:26.733]             base::close(...future.stdout)
[16:12:26.733]         }, add = TRUE)
[16:12:26.733]     }
[16:12:26.733]     ...future.frame <- base::sys.nframe()
[16:12:26.733]     ...future.conditions <- base::list()
[16:12:26.733]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.733]     if (FALSE) {
[16:12:26.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.733]     }
[16:12:26.733]     ...future.result <- base::tryCatch({
[16:12:26.733]         base::withCallingHandlers({
[16:12:26.733]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.733]             future::FutureResult(value = ...future.value$value, 
[16:12:26.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.733]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.733]                     ...future.globalenv.names))
[16:12:26.733]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.733]         }, condition = base::local({
[16:12:26.733]             c <- base::c
[16:12:26.733]             inherits <- base::inherits
[16:12:26.733]             invokeRestart <- base::invokeRestart
[16:12:26.733]             length <- base::length
[16:12:26.733]             list <- base::list
[16:12:26.733]             seq.int <- base::seq.int
[16:12:26.733]             signalCondition <- base::signalCondition
[16:12:26.733]             sys.calls <- base::sys.calls
[16:12:26.733]             `[[` <- base::`[[`
[16:12:26.733]             `+` <- base::`+`
[16:12:26.733]             `<<-` <- base::`<<-`
[16:12:26.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.733]                   3L)]
[16:12:26.733]             }
[16:12:26.733]             function(cond) {
[16:12:26.733]                 is_error <- inherits(cond, "error")
[16:12:26.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.733]                   NULL)
[16:12:26.733]                 if (is_error) {
[16:12:26.733]                   sessionInformation <- function() {
[16:12:26.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.733]                       search = base::search(), system = base::Sys.info())
[16:12:26.733]                   }
[16:12:26.733]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.733]                     cond$call), session = sessionInformation(), 
[16:12:26.733]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.733]                   signalCondition(cond)
[16:12:26.733]                 }
[16:12:26.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.733]                 "immediateCondition"))) {
[16:12:26.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.733]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.733]                   if (TRUE && !signal) {
[16:12:26.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.733]                     {
[16:12:26.733]                       inherits <- base::inherits
[16:12:26.733]                       invokeRestart <- base::invokeRestart
[16:12:26.733]                       is.null <- base::is.null
[16:12:26.733]                       muffled <- FALSE
[16:12:26.733]                       if (inherits(cond, "message")) {
[16:12:26.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.733]                         if (muffled) 
[16:12:26.733]                           invokeRestart("muffleMessage")
[16:12:26.733]                       }
[16:12:26.733]                       else if (inherits(cond, "warning")) {
[16:12:26.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.733]                         if (muffled) 
[16:12:26.733]                           invokeRestart("muffleWarning")
[16:12:26.733]                       }
[16:12:26.733]                       else if (inherits(cond, "condition")) {
[16:12:26.733]                         if (!is.null(pattern)) {
[16:12:26.733]                           computeRestarts <- base::computeRestarts
[16:12:26.733]                           grepl <- base::grepl
[16:12:26.733]                           restarts <- computeRestarts(cond)
[16:12:26.733]                           for (restart in restarts) {
[16:12:26.733]                             name <- restart$name
[16:12:26.733]                             if (is.null(name)) 
[16:12:26.733]                               next
[16:12:26.733]                             if (!grepl(pattern, name)) 
[16:12:26.733]                               next
[16:12:26.733]                             invokeRestart(restart)
[16:12:26.733]                             muffled <- TRUE
[16:12:26.733]                             break
[16:12:26.733]                           }
[16:12:26.733]                         }
[16:12:26.733]                       }
[16:12:26.733]                       invisible(muffled)
[16:12:26.733]                     }
[16:12:26.733]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.733]                   }
[16:12:26.733]                 }
[16:12:26.733]                 else {
[16:12:26.733]                   if (TRUE) {
[16:12:26.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.733]                     {
[16:12:26.733]                       inherits <- base::inherits
[16:12:26.733]                       invokeRestart <- base::invokeRestart
[16:12:26.733]                       is.null <- base::is.null
[16:12:26.733]                       muffled <- FALSE
[16:12:26.733]                       if (inherits(cond, "message")) {
[16:12:26.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.733]                         if (muffled) 
[16:12:26.733]                           invokeRestart("muffleMessage")
[16:12:26.733]                       }
[16:12:26.733]                       else if (inherits(cond, "warning")) {
[16:12:26.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.733]                         if (muffled) 
[16:12:26.733]                           invokeRestart("muffleWarning")
[16:12:26.733]                       }
[16:12:26.733]                       else if (inherits(cond, "condition")) {
[16:12:26.733]                         if (!is.null(pattern)) {
[16:12:26.733]                           computeRestarts <- base::computeRestarts
[16:12:26.733]                           grepl <- base::grepl
[16:12:26.733]                           restarts <- computeRestarts(cond)
[16:12:26.733]                           for (restart in restarts) {
[16:12:26.733]                             name <- restart$name
[16:12:26.733]                             if (is.null(name)) 
[16:12:26.733]                               next
[16:12:26.733]                             if (!grepl(pattern, name)) 
[16:12:26.733]                               next
[16:12:26.733]                             invokeRestart(restart)
[16:12:26.733]                             muffled <- TRUE
[16:12:26.733]                             break
[16:12:26.733]                           }
[16:12:26.733]                         }
[16:12:26.733]                       }
[16:12:26.733]                       invisible(muffled)
[16:12:26.733]                     }
[16:12:26.733]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.733]                   }
[16:12:26.733]                 }
[16:12:26.733]             }
[16:12:26.733]         }))
[16:12:26.733]     }, error = function(ex) {
[16:12:26.733]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.733]                 ...future.rng), started = ...future.startTime, 
[16:12:26.733]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.733]             version = "1.8"), class = "FutureResult")
[16:12:26.733]     }, finally = {
[16:12:26.733]         if (!identical(...future.workdir, getwd())) 
[16:12:26.733]             setwd(...future.workdir)
[16:12:26.733]         {
[16:12:26.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.733]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.733]             }
[16:12:26.733]             base::options(...future.oldOptions)
[16:12:26.733]             if (.Platform$OS.type == "windows") {
[16:12:26.733]                 old_names <- names(...future.oldEnvVars)
[16:12:26.733]                 envs <- base::Sys.getenv()
[16:12:26.733]                 names <- names(envs)
[16:12:26.733]                 common <- intersect(names, old_names)
[16:12:26.733]                 added <- setdiff(names, old_names)
[16:12:26.733]                 removed <- setdiff(old_names, names)
[16:12:26.733]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.733]                   envs[common]]
[16:12:26.733]                 NAMES <- toupper(changed)
[16:12:26.733]                 args <- list()
[16:12:26.733]                 for (kk in seq_along(NAMES)) {
[16:12:26.733]                   name <- changed[[kk]]
[16:12:26.733]                   NAME <- NAMES[[kk]]
[16:12:26.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.733]                     next
[16:12:26.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.733]                 }
[16:12:26.733]                 NAMES <- toupper(added)
[16:12:26.733]                 for (kk in seq_along(NAMES)) {
[16:12:26.733]                   name <- added[[kk]]
[16:12:26.733]                   NAME <- NAMES[[kk]]
[16:12:26.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.733]                     next
[16:12:26.733]                   args[[name]] <- ""
[16:12:26.733]                 }
[16:12:26.733]                 NAMES <- toupper(removed)
[16:12:26.733]                 for (kk in seq_along(NAMES)) {
[16:12:26.733]                   name <- removed[[kk]]
[16:12:26.733]                   NAME <- NAMES[[kk]]
[16:12:26.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.733]                     next
[16:12:26.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.733]                 }
[16:12:26.733]                 if (length(args) > 0) 
[16:12:26.733]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.733]             }
[16:12:26.733]             else {
[16:12:26.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.733]             }
[16:12:26.733]             {
[16:12:26.733]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.733]                   0L) {
[16:12:26.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.733]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.733]                   base::options(opts)
[16:12:26.733]                 }
[16:12:26.733]                 {
[16:12:26.733]                   {
[16:12:26.733]                     NULL
[16:12:26.733]                     RNGkind("Mersenne-Twister")
[16:12:26.733]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.733]                       inherits = FALSE)
[16:12:26.733]                   }
[16:12:26.733]                   options(future.plan = NULL)
[16:12:26.733]                   if (is.na(NA_character_)) 
[16:12:26.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.733]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.733]                   {
[16:12:26.733]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.733]                     if (!future$lazy) 
[16:12:26.733]                       future <- run(future)
[16:12:26.733]                     invisible(future)
[16:12:26.733]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.733]                 }
[16:12:26.733]             }
[16:12:26.733]         }
[16:12:26.733]     })
[16:12:26.733]     if (TRUE) {
[16:12:26.733]         base::sink(type = "output", split = FALSE)
[16:12:26.733]         if (TRUE) {
[16:12:26.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.733]         }
[16:12:26.733]         else {
[16:12:26.733]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.733]         }
[16:12:26.733]         base::close(...future.stdout)
[16:12:26.733]         ...future.stdout <- NULL
[16:12:26.733]     }
[16:12:26.733]     ...future.result$conditions <- ...future.conditions
[16:12:26.733]     ...future.result$finished <- base::Sys.time()
[16:12:26.733]     ...future.result
[16:12:26.733] }
[16:12:26.734] plan(): Setting new future strategy stack:
[16:12:26.735] List of future strategies:
[16:12:26.735] 1. sequential:
[16:12:26.735]    - args: function (..., envir = parent.frame())
[16:12:26.735]    - tweaked: FALSE
[16:12:26.735]    - call: NULL
[16:12:26.735] plan(): nbrOfWorkers() = 1
[16:12:26.736] plan(): Setting new future strategy stack:
[16:12:26.736] List of future strategies:
[16:12:26.736] 1. sequential:
[16:12:26.736]    - args: function (..., envir = parent.frame())
[16:12:26.736]    - tweaked: FALSE
[16:12:26.736]    - call: plan(strategy)
[16:12:26.736] plan(): nbrOfWorkers() = 1
[16:12:26.736] SequentialFuture started (and completed)
[16:12:26.736] - Launch lazy future ... done
[16:12:26.736] run() for ‘SequentialFuture’ ... done
[16:12:26.737] getGlobalsAndPackages() ...
[16:12:26.737] Searching for globals...
[16:12:26.737] - globals found: [1] ‘{’
[16:12:26.737] Searching for globals ... DONE
[16:12:26.738] Resolving globals: FALSE
[16:12:26.738] 
[16:12:26.738] 
[16:12:26.738] getGlobalsAndPackages() ... DONE
[16:12:26.738] run() for ‘Future’ ...
[16:12:26.738] - state: ‘created’
[16:12:26.738] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.739] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.739]   - Field: ‘label’
[16:12:26.739]   - Field: ‘local’
[16:12:26.739]   - Field: ‘owner’
[16:12:26.739]   - Field: ‘envir’
[16:12:26.739]   - Field: ‘packages’
[16:12:26.739]   - Field: ‘gc’
[16:12:26.739]   - Field: ‘conditions’
[16:12:26.740]   - Field: ‘expr’
[16:12:26.740]   - Field: ‘uuid’
[16:12:26.740]   - Field: ‘seed’
[16:12:26.740]   - Field: ‘version’
[16:12:26.740]   - Field: ‘result’
[16:12:26.740]   - Field: ‘asynchronous’
[16:12:26.740]   - Field: ‘calls’
[16:12:26.740]   - Field: ‘globals’
[16:12:26.740]   - Field: ‘stdout’
[16:12:26.740]   - Field: ‘earlySignal’
[16:12:26.740]   - Field: ‘lazy’
[16:12:26.741]   - Field: ‘state’
[16:12:26.741] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.741] - Launch lazy future ...
[16:12:26.741] Packages needed by the future expression (n = 0): <none>
[16:12:26.741] Packages needed by future strategies (n = 0): <none>
[16:12:26.741] {
[16:12:26.741]     {
[16:12:26.741]         {
[16:12:26.741]             ...future.startTime <- base::Sys.time()
[16:12:26.741]             {
[16:12:26.741]                 {
[16:12:26.741]                   {
[16:12:26.741]                     base::local({
[16:12:26.741]                       has_future <- base::requireNamespace("future", 
[16:12:26.741]                         quietly = TRUE)
[16:12:26.741]                       if (has_future) {
[16:12:26.741]                         ns <- base::getNamespace("future")
[16:12:26.741]                         version <- ns[[".package"]][["version"]]
[16:12:26.741]                         if (is.null(version)) 
[16:12:26.741]                           version <- utils::packageVersion("future")
[16:12:26.741]                       }
[16:12:26.741]                       else {
[16:12:26.741]                         version <- NULL
[16:12:26.741]                       }
[16:12:26.741]                       if (!has_future || version < "1.8.0") {
[16:12:26.741]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.741]                           "", base::R.version$version.string), 
[16:12:26.741]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.741]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.741]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.741]                             "release", "version")], collapse = " "), 
[16:12:26.741]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.741]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.741]                           info)
[16:12:26.741]                         info <- base::paste(info, collapse = "; ")
[16:12:26.741]                         if (!has_future) {
[16:12:26.741]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.741]                             info)
[16:12:26.741]                         }
[16:12:26.741]                         else {
[16:12:26.741]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.741]                             info, version)
[16:12:26.741]                         }
[16:12:26.741]                         base::stop(msg)
[16:12:26.741]                       }
[16:12:26.741]                     })
[16:12:26.741]                   }
[16:12:26.741]                   options(future.plan = NULL)
[16:12:26.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.741]                 }
[16:12:26.741]                 ...future.workdir <- getwd()
[16:12:26.741]             }
[16:12:26.741]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.741]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.741]         }
[16:12:26.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.741]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.741]             base::names(...future.oldOptions))
[16:12:26.741]     }
[16:12:26.741]     if (FALSE) {
[16:12:26.741]     }
[16:12:26.741]     else {
[16:12:26.741]         if (TRUE) {
[16:12:26.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.741]                 open = "w")
[16:12:26.741]         }
[16:12:26.741]         else {
[16:12:26.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.741]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.741]         }
[16:12:26.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.741]             base::sink(type = "output", split = FALSE)
[16:12:26.741]             base::close(...future.stdout)
[16:12:26.741]         }, add = TRUE)
[16:12:26.741]     }
[16:12:26.741]     ...future.frame <- base::sys.nframe()
[16:12:26.741]     ...future.conditions <- base::list()
[16:12:26.741]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.741]     if (FALSE) {
[16:12:26.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.741]     }
[16:12:26.741]     ...future.result <- base::tryCatch({
[16:12:26.741]         base::withCallingHandlers({
[16:12:26.741]             ...future.value <- base::withVisible(base::local({
[16:12:26.741]                 4
[16:12:26.741]             }))
[16:12:26.741]             future::FutureResult(value = ...future.value$value, 
[16:12:26.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.741]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.741]                     ...future.globalenv.names))
[16:12:26.741]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.741]         }, condition = base::local({
[16:12:26.741]             c <- base::c
[16:12:26.741]             inherits <- base::inherits
[16:12:26.741]             invokeRestart <- base::invokeRestart
[16:12:26.741]             length <- base::length
[16:12:26.741]             list <- base::list
[16:12:26.741]             seq.int <- base::seq.int
[16:12:26.741]             signalCondition <- base::signalCondition
[16:12:26.741]             sys.calls <- base::sys.calls
[16:12:26.741]             `[[` <- base::`[[`
[16:12:26.741]             `+` <- base::`+`
[16:12:26.741]             `<<-` <- base::`<<-`
[16:12:26.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.741]                   3L)]
[16:12:26.741]             }
[16:12:26.741]             function(cond) {
[16:12:26.741]                 is_error <- inherits(cond, "error")
[16:12:26.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.741]                   NULL)
[16:12:26.741]                 if (is_error) {
[16:12:26.741]                   sessionInformation <- function() {
[16:12:26.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.741]                       search = base::search(), system = base::Sys.info())
[16:12:26.741]                   }
[16:12:26.741]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.741]                     cond$call), session = sessionInformation(), 
[16:12:26.741]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.741]                   signalCondition(cond)
[16:12:26.741]                 }
[16:12:26.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.741]                 "immediateCondition"))) {
[16:12:26.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.741]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.741]                   if (TRUE && !signal) {
[16:12:26.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.741]                     {
[16:12:26.741]                       inherits <- base::inherits
[16:12:26.741]                       invokeRestart <- base::invokeRestart
[16:12:26.741]                       is.null <- base::is.null
[16:12:26.741]                       muffled <- FALSE
[16:12:26.741]                       if (inherits(cond, "message")) {
[16:12:26.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.741]                         if (muffled) 
[16:12:26.741]                           invokeRestart("muffleMessage")
[16:12:26.741]                       }
[16:12:26.741]                       else if (inherits(cond, "warning")) {
[16:12:26.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.741]                         if (muffled) 
[16:12:26.741]                           invokeRestart("muffleWarning")
[16:12:26.741]                       }
[16:12:26.741]                       else if (inherits(cond, "condition")) {
[16:12:26.741]                         if (!is.null(pattern)) {
[16:12:26.741]                           computeRestarts <- base::computeRestarts
[16:12:26.741]                           grepl <- base::grepl
[16:12:26.741]                           restarts <- computeRestarts(cond)
[16:12:26.741]                           for (restart in restarts) {
[16:12:26.741]                             name <- restart$name
[16:12:26.741]                             if (is.null(name)) 
[16:12:26.741]                               next
[16:12:26.741]                             if (!grepl(pattern, name)) 
[16:12:26.741]                               next
[16:12:26.741]                             invokeRestart(restart)
[16:12:26.741]                             muffled <- TRUE
[16:12:26.741]                             break
[16:12:26.741]                           }
[16:12:26.741]                         }
[16:12:26.741]                       }
[16:12:26.741]                       invisible(muffled)
[16:12:26.741]                     }
[16:12:26.741]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.741]                   }
[16:12:26.741]                 }
[16:12:26.741]                 else {
[16:12:26.741]                   if (TRUE) {
[16:12:26.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.741]                     {
[16:12:26.741]                       inherits <- base::inherits
[16:12:26.741]                       invokeRestart <- base::invokeRestart
[16:12:26.741]                       is.null <- base::is.null
[16:12:26.741]                       muffled <- FALSE
[16:12:26.741]                       if (inherits(cond, "message")) {
[16:12:26.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.741]                         if (muffled) 
[16:12:26.741]                           invokeRestart("muffleMessage")
[16:12:26.741]                       }
[16:12:26.741]                       else if (inherits(cond, "warning")) {
[16:12:26.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.741]                         if (muffled) 
[16:12:26.741]                           invokeRestart("muffleWarning")
[16:12:26.741]                       }
[16:12:26.741]                       else if (inherits(cond, "condition")) {
[16:12:26.741]                         if (!is.null(pattern)) {
[16:12:26.741]                           computeRestarts <- base::computeRestarts
[16:12:26.741]                           grepl <- base::grepl
[16:12:26.741]                           restarts <- computeRestarts(cond)
[16:12:26.741]                           for (restart in restarts) {
[16:12:26.741]                             name <- restart$name
[16:12:26.741]                             if (is.null(name)) 
[16:12:26.741]                               next
[16:12:26.741]                             if (!grepl(pattern, name)) 
[16:12:26.741]                               next
[16:12:26.741]                             invokeRestart(restart)
[16:12:26.741]                             muffled <- TRUE
[16:12:26.741]                             break
[16:12:26.741]                           }
[16:12:26.741]                         }
[16:12:26.741]                       }
[16:12:26.741]                       invisible(muffled)
[16:12:26.741]                     }
[16:12:26.741]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.741]                   }
[16:12:26.741]                 }
[16:12:26.741]             }
[16:12:26.741]         }))
[16:12:26.741]     }, error = function(ex) {
[16:12:26.741]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.741]                 ...future.rng), started = ...future.startTime, 
[16:12:26.741]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.741]             version = "1.8"), class = "FutureResult")
[16:12:26.741]     }, finally = {
[16:12:26.741]         if (!identical(...future.workdir, getwd())) 
[16:12:26.741]             setwd(...future.workdir)
[16:12:26.741]         {
[16:12:26.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.741]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.741]             }
[16:12:26.741]             base::options(...future.oldOptions)
[16:12:26.741]             if (.Platform$OS.type == "windows") {
[16:12:26.741]                 old_names <- names(...future.oldEnvVars)
[16:12:26.741]                 envs <- base::Sys.getenv()
[16:12:26.741]                 names <- names(envs)
[16:12:26.741]                 common <- intersect(names, old_names)
[16:12:26.741]                 added <- setdiff(names, old_names)
[16:12:26.741]                 removed <- setdiff(old_names, names)
[16:12:26.741]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.741]                   envs[common]]
[16:12:26.741]                 NAMES <- toupper(changed)
[16:12:26.741]                 args <- list()
[16:12:26.741]                 for (kk in seq_along(NAMES)) {
[16:12:26.741]                   name <- changed[[kk]]
[16:12:26.741]                   NAME <- NAMES[[kk]]
[16:12:26.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.741]                     next
[16:12:26.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.741]                 }
[16:12:26.741]                 NAMES <- toupper(added)
[16:12:26.741]                 for (kk in seq_along(NAMES)) {
[16:12:26.741]                   name <- added[[kk]]
[16:12:26.741]                   NAME <- NAMES[[kk]]
[16:12:26.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.741]                     next
[16:12:26.741]                   args[[name]] <- ""
[16:12:26.741]                 }
[16:12:26.741]                 NAMES <- toupper(removed)
[16:12:26.741]                 for (kk in seq_along(NAMES)) {
[16:12:26.741]                   name <- removed[[kk]]
[16:12:26.741]                   NAME <- NAMES[[kk]]
[16:12:26.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.741]                     next
[16:12:26.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.741]                 }
[16:12:26.741]                 if (length(args) > 0) 
[16:12:26.741]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.741]             }
[16:12:26.741]             else {
[16:12:26.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.741]             }
[16:12:26.741]             {
[16:12:26.741]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.741]                   0L) {
[16:12:26.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.741]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.741]                   base::options(opts)
[16:12:26.741]                 }
[16:12:26.741]                 {
[16:12:26.741]                   {
[16:12:26.741]                     NULL
[16:12:26.741]                     RNGkind("Mersenne-Twister")
[16:12:26.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.741]                       inherits = FALSE)
[16:12:26.741]                   }
[16:12:26.741]                   options(future.plan = NULL)
[16:12:26.741]                   if (is.na(NA_character_)) 
[16:12:26.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.741]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.741]                   {
[16:12:26.741]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.741]                     if (!future$lazy) 
[16:12:26.741]                       future <- run(future)
[16:12:26.741]                     invisible(future)
[16:12:26.741]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.741]                 }
[16:12:26.741]             }
[16:12:26.741]         }
[16:12:26.741]     })
[16:12:26.741]     if (TRUE) {
[16:12:26.741]         base::sink(type = "output", split = FALSE)
[16:12:26.741]         if (TRUE) {
[16:12:26.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.741]         }
[16:12:26.741]         else {
[16:12:26.741]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.741]         }
[16:12:26.741]         base::close(...future.stdout)
[16:12:26.741]         ...future.stdout <- NULL
[16:12:26.741]     }
[16:12:26.741]     ...future.result$conditions <- ...future.conditions
[16:12:26.741]     ...future.result$finished <- base::Sys.time()
[16:12:26.741]     ...future.result
[16:12:26.741] }
[16:12:26.743] plan(): Setting new future strategy stack:
[16:12:26.743] List of future strategies:
[16:12:26.743] 1. sequential:
[16:12:26.743]    - args: function (..., envir = parent.frame())
[16:12:26.743]    - tweaked: FALSE
[16:12:26.743]    - call: NULL
[16:12:26.744] plan(): nbrOfWorkers() = 1
[16:12:26.744] plan(): Setting new future strategy stack:
[16:12:26.744] List of future strategies:
[16:12:26.744] 1. sequential:
[16:12:26.744]    - args: function (..., envir = parent.frame())
[16:12:26.744]    - tweaked: FALSE
[16:12:26.744]    - call: plan(strategy)
[16:12:26.745] plan(): nbrOfWorkers() = 1
[16:12:26.745] SequentialFuture started (and completed)
[16:12:26.745] - Launch lazy future ... done
[16:12:26.745] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560baed940b8> 
Classes 'listenv', 'environment' <environment: 0x560baec35c98> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:12:26.749] resolved() for ‘SequentialFuture’ ...
[16:12:26.749] - state: ‘finished’
[16:12:26.749] - run: TRUE
[16:12:26.749] - result: ‘FutureResult’
[16:12:26.749] resolved() for ‘SequentialFuture’ ... done
[16:12:26.749] resolved() for ‘SequentialFuture’ ...
[16:12:26.749] - state: ‘finished’
[16:12:26.749] - run: TRUE
[16:12:26.749] - result: ‘FutureResult’
[16:12:26.749] resolved() for ‘SequentialFuture’ ... done
[16:12:26.750] resolved() for ‘SequentialFuture’ ...
[16:12:26.750] - state: ‘finished’
[16:12:26.750] - run: TRUE
[16:12:26.750] - result: ‘FutureResult’
[16:12:26.750] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:26.752] resolve() on list environment ...
[16:12:26.752]  recursive: 0
[16:12:26.754]  length: 6
[16:12:26.754]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:26.754] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.754] - nx: 6
[16:12:26.755] - relay: TRUE
[16:12:26.755] - stdout: TRUE
[16:12:26.755] - signal: TRUE
[16:12:26.755] - resignal: FALSE
[16:12:26.755] - force: TRUE
[16:12:26.755] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.755] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.755]  - until=2
[16:12:26.755]  - relaying element #2
[16:12:26.755] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.755] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.756] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.756]  length: 5 (resolved future 1)
[16:12:26.756] resolved() for ‘SequentialFuture’ ...
[16:12:26.756] - state: ‘finished’
[16:12:26.756] - run: TRUE
[16:12:26.756] - result: ‘FutureResult’
[16:12:26.756] resolved() for ‘SequentialFuture’ ... done
[16:12:26.756] Future #2
[16:12:26.756] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.756] - nx: 6
[16:12:26.757] - relay: TRUE
[16:12:26.757] - stdout: TRUE
[16:12:26.757] - signal: TRUE
[16:12:26.757] - resignal: FALSE
[16:12:26.757] - force: TRUE
[16:12:26.757] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.757] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.757]  - until=2
[16:12:26.757]  - relaying element #2
[16:12:26.757] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.757] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.758] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.758]  length: 4 (resolved future 2)
[16:12:26.758] resolved() for ‘SequentialFuture’ ...
[16:12:26.758] - state: ‘finished’
[16:12:26.758] - run: TRUE
[16:12:26.758] - result: ‘FutureResult’
[16:12:26.758] resolved() for ‘SequentialFuture’ ... done
[16:12:26.758] Future #3
[16:12:26.758] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.758] - nx: 6
[16:12:26.759] - relay: TRUE
[16:12:26.759] - stdout: TRUE
[16:12:26.759] - signal: TRUE
[16:12:26.759] - resignal: FALSE
[16:12:26.759] - force: TRUE
[16:12:26.759] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.759] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.759]  - until=3
[16:12:26.759]  - relaying element #3
[16:12:26.759] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.759] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.760] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.760]  length: 3 (resolved future 3)
[16:12:26.760] resolved() for ‘SequentialFuture’ ...
[16:12:26.760] - state: ‘finished’
[16:12:26.760] - run: TRUE
[16:12:26.760] - result: ‘FutureResult’
[16:12:26.760] resolved() for ‘SequentialFuture’ ... done
[16:12:26.760] Future #4
[16:12:26.760] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.760] - nx: 6
[16:12:26.761] - relay: TRUE
[16:12:26.761] - stdout: TRUE
[16:12:26.761] - signal: TRUE
[16:12:26.761] - resignal: FALSE
[16:12:26.761] - force: TRUE
[16:12:26.761] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.761] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.761]  - until=4
[16:12:26.761]  - relaying element #4
[16:12:26.761] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.761] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.762] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.762]  length: 2 (resolved future 4)
[16:12:26.762] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.762] - nx: 6
[16:12:26.762] - relay: TRUE
[16:12:26.762] - stdout: TRUE
[16:12:26.762] - signal: TRUE
[16:12:26.762] - resignal: FALSE
[16:12:26.762] - force: TRUE
[16:12:26.762] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.762] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.762]  - until=6
[16:12:26.763]  - relaying element #6
[16:12:26.763] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.763] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.763] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.763]  length: 1 (resolved future 5)
[16:12:26.763] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.763] - nx: 6
[16:12:26.763] - relay: TRUE
[16:12:26.763] - stdout: TRUE
[16:12:26.763] - signal: TRUE
[16:12:26.763] - resignal: FALSE
[16:12:26.763] - force: TRUE
[16:12:26.764] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.764] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.764]  - until=6
[16:12:26.764] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.764] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.764] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.764]  length: 0 (resolved future 6)
[16:12:26.764] Relaying remaining futures
[16:12:26.764] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.764] - nx: 6
[16:12:26.764] - relay: TRUE
[16:12:26.764] - stdout: TRUE
[16:12:26.765] - signal: TRUE
[16:12:26.765] - resignal: FALSE
[16:12:26.765] - force: TRUE
[16:12:26.765] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.765] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:26.765] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.765] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.765] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.765] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560baf0b7928> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:12:26.767] getGlobalsAndPackages() ...
[16:12:26.767] Searching for globals...
[16:12:26.767] 
[16:12:26.768] Searching for globals ... DONE
[16:12:26.768] - globals: [0] <none>
[16:12:26.768] getGlobalsAndPackages() ... DONE
[16:12:26.768] run() for ‘Future’ ...
[16:12:26.768] - state: ‘created’
[16:12:26.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.768] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.769]   - Field: ‘label’
[16:12:26.769]   - Field: ‘local’
[16:12:26.769]   - Field: ‘owner’
[16:12:26.769]   - Field: ‘envir’
[16:12:26.769]   - Field: ‘packages’
[16:12:26.769]   - Field: ‘gc’
[16:12:26.769]   - Field: ‘conditions’
[16:12:26.769]   - Field: ‘expr’
[16:12:26.769]   - Field: ‘uuid’
[16:12:26.769]   - Field: ‘seed’
[16:12:26.770]   - Field: ‘version’
[16:12:26.770]   - Field: ‘result’
[16:12:26.770]   - Field: ‘asynchronous’
[16:12:26.770]   - Field: ‘calls’
[16:12:26.770]   - Field: ‘globals’
[16:12:26.770]   - Field: ‘stdout’
[16:12:26.770]   - Field: ‘earlySignal’
[16:12:26.770]   - Field: ‘lazy’
[16:12:26.770]   - Field: ‘state’
[16:12:26.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.770] - Launch lazy future ...
[16:12:26.771] Packages needed by the future expression (n = 0): <none>
[16:12:26.771] Packages needed by future strategies (n = 0): <none>
[16:12:26.771] {
[16:12:26.771]     {
[16:12:26.771]         {
[16:12:26.771]             ...future.startTime <- base::Sys.time()
[16:12:26.771]             {
[16:12:26.771]                 {
[16:12:26.771]                   {
[16:12:26.771]                     base::local({
[16:12:26.771]                       has_future <- base::requireNamespace("future", 
[16:12:26.771]                         quietly = TRUE)
[16:12:26.771]                       if (has_future) {
[16:12:26.771]                         ns <- base::getNamespace("future")
[16:12:26.771]                         version <- ns[[".package"]][["version"]]
[16:12:26.771]                         if (is.null(version)) 
[16:12:26.771]                           version <- utils::packageVersion("future")
[16:12:26.771]                       }
[16:12:26.771]                       else {
[16:12:26.771]                         version <- NULL
[16:12:26.771]                       }
[16:12:26.771]                       if (!has_future || version < "1.8.0") {
[16:12:26.771]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.771]                           "", base::R.version$version.string), 
[16:12:26.771]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.771]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.771]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.771]                             "release", "version")], collapse = " "), 
[16:12:26.771]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.771]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.771]                           info)
[16:12:26.771]                         info <- base::paste(info, collapse = "; ")
[16:12:26.771]                         if (!has_future) {
[16:12:26.771]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.771]                             info)
[16:12:26.771]                         }
[16:12:26.771]                         else {
[16:12:26.771]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.771]                             info, version)
[16:12:26.771]                         }
[16:12:26.771]                         base::stop(msg)
[16:12:26.771]                       }
[16:12:26.771]                     })
[16:12:26.771]                   }
[16:12:26.771]                   options(future.plan = NULL)
[16:12:26.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.771]                 }
[16:12:26.771]                 ...future.workdir <- getwd()
[16:12:26.771]             }
[16:12:26.771]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.771]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.771]         }
[16:12:26.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.771]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.771]             base::names(...future.oldOptions))
[16:12:26.771]     }
[16:12:26.771]     if (FALSE) {
[16:12:26.771]     }
[16:12:26.771]     else {
[16:12:26.771]         if (TRUE) {
[16:12:26.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.771]                 open = "w")
[16:12:26.771]         }
[16:12:26.771]         else {
[16:12:26.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.771]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.771]         }
[16:12:26.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.771]             base::sink(type = "output", split = FALSE)
[16:12:26.771]             base::close(...future.stdout)
[16:12:26.771]         }, add = TRUE)
[16:12:26.771]     }
[16:12:26.771]     ...future.frame <- base::sys.nframe()
[16:12:26.771]     ...future.conditions <- base::list()
[16:12:26.771]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.771]     if (FALSE) {
[16:12:26.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.771]     }
[16:12:26.771]     ...future.result <- base::tryCatch({
[16:12:26.771]         base::withCallingHandlers({
[16:12:26.771]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.771]             future::FutureResult(value = ...future.value$value, 
[16:12:26.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.771]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.771]                     ...future.globalenv.names))
[16:12:26.771]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.771]         }, condition = base::local({
[16:12:26.771]             c <- base::c
[16:12:26.771]             inherits <- base::inherits
[16:12:26.771]             invokeRestart <- base::invokeRestart
[16:12:26.771]             length <- base::length
[16:12:26.771]             list <- base::list
[16:12:26.771]             seq.int <- base::seq.int
[16:12:26.771]             signalCondition <- base::signalCondition
[16:12:26.771]             sys.calls <- base::sys.calls
[16:12:26.771]             `[[` <- base::`[[`
[16:12:26.771]             `+` <- base::`+`
[16:12:26.771]             `<<-` <- base::`<<-`
[16:12:26.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.771]                   3L)]
[16:12:26.771]             }
[16:12:26.771]             function(cond) {
[16:12:26.771]                 is_error <- inherits(cond, "error")
[16:12:26.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.771]                   NULL)
[16:12:26.771]                 if (is_error) {
[16:12:26.771]                   sessionInformation <- function() {
[16:12:26.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.771]                       search = base::search(), system = base::Sys.info())
[16:12:26.771]                   }
[16:12:26.771]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.771]                     cond$call), session = sessionInformation(), 
[16:12:26.771]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.771]                   signalCondition(cond)
[16:12:26.771]                 }
[16:12:26.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.771]                 "immediateCondition"))) {
[16:12:26.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.771]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.771]                   if (TRUE && !signal) {
[16:12:26.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.771]                     {
[16:12:26.771]                       inherits <- base::inherits
[16:12:26.771]                       invokeRestart <- base::invokeRestart
[16:12:26.771]                       is.null <- base::is.null
[16:12:26.771]                       muffled <- FALSE
[16:12:26.771]                       if (inherits(cond, "message")) {
[16:12:26.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.771]                         if (muffled) 
[16:12:26.771]                           invokeRestart("muffleMessage")
[16:12:26.771]                       }
[16:12:26.771]                       else if (inherits(cond, "warning")) {
[16:12:26.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.771]                         if (muffled) 
[16:12:26.771]                           invokeRestart("muffleWarning")
[16:12:26.771]                       }
[16:12:26.771]                       else if (inherits(cond, "condition")) {
[16:12:26.771]                         if (!is.null(pattern)) {
[16:12:26.771]                           computeRestarts <- base::computeRestarts
[16:12:26.771]                           grepl <- base::grepl
[16:12:26.771]                           restarts <- computeRestarts(cond)
[16:12:26.771]                           for (restart in restarts) {
[16:12:26.771]                             name <- restart$name
[16:12:26.771]                             if (is.null(name)) 
[16:12:26.771]                               next
[16:12:26.771]                             if (!grepl(pattern, name)) 
[16:12:26.771]                               next
[16:12:26.771]                             invokeRestart(restart)
[16:12:26.771]                             muffled <- TRUE
[16:12:26.771]                             break
[16:12:26.771]                           }
[16:12:26.771]                         }
[16:12:26.771]                       }
[16:12:26.771]                       invisible(muffled)
[16:12:26.771]                     }
[16:12:26.771]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.771]                   }
[16:12:26.771]                 }
[16:12:26.771]                 else {
[16:12:26.771]                   if (TRUE) {
[16:12:26.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.771]                     {
[16:12:26.771]                       inherits <- base::inherits
[16:12:26.771]                       invokeRestart <- base::invokeRestart
[16:12:26.771]                       is.null <- base::is.null
[16:12:26.771]                       muffled <- FALSE
[16:12:26.771]                       if (inherits(cond, "message")) {
[16:12:26.771]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.771]                         if (muffled) 
[16:12:26.771]                           invokeRestart("muffleMessage")
[16:12:26.771]                       }
[16:12:26.771]                       else if (inherits(cond, "warning")) {
[16:12:26.771]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.771]                         if (muffled) 
[16:12:26.771]                           invokeRestart("muffleWarning")
[16:12:26.771]                       }
[16:12:26.771]                       else if (inherits(cond, "condition")) {
[16:12:26.771]                         if (!is.null(pattern)) {
[16:12:26.771]                           computeRestarts <- base::computeRestarts
[16:12:26.771]                           grepl <- base::grepl
[16:12:26.771]                           restarts <- computeRestarts(cond)
[16:12:26.771]                           for (restart in restarts) {
[16:12:26.771]                             name <- restart$name
[16:12:26.771]                             if (is.null(name)) 
[16:12:26.771]                               next
[16:12:26.771]                             if (!grepl(pattern, name)) 
[16:12:26.771]                               next
[16:12:26.771]                             invokeRestart(restart)
[16:12:26.771]                             muffled <- TRUE
[16:12:26.771]                             break
[16:12:26.771]                           }
[16:12:26.771]                         }
[16:12:26.771]                       }
[16:12:26.771]                       invisible(muffled)
[16:12:26.771]                     }
[16:12:26.771]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.771]                   }
[16:12:26.771]                 }
[16:12:26.771]             }
[16:12:26.771]         }))
[16:12:26.771]     }, error = function(ex) {
[16:12:26.771]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.771]                 ...future.rng), started = ...future.startTime, 
[16:12:26.771]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.771]             version = "1.8"), class = "FutureResult")
[16:12:26.771]     }, finally = {
[16:12:26.771]         if (!identical(...future.workdir, getwd())) 
[16:12:26.771]             setwd(...future.workdir)
[16:12:26.771]         {
[16:12:26.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.771]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.771]             }
[16:12:26.771]             base::options(...future.oldOptions)
[16:12:26.771]             if (.Platform$OS.type == "windows") {
[16:12:26.771]                 old_names <- names(...future.oldEnvVars)
[16:12:26.771]                 envs <- base::Sys.getenv()
[16:12:26.771]                 names <- names(envs)
[16:12:26.771]                 common <- intersect(names, old_names)
[16:12:26.771]                 added <- setdiff(names, old_names)
[16:12:26.771]                 removed <- setdiff(old_names, names)
[16:12:26.771]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.771]                   envs[common]]
[16:12:26.771]                 NAMES <- toupper(changed)
[16:12:26.771]                 args <- list()
[16:12:26.771]                 for (kk in seq_along(NAMES)) {
[16:12:26.771]                   name <- changed[[kk]]
[16:12:26.771]                   NAME <- NAMES[[kk]]
[16:12:26.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.771]                     next
[16:12:26.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.771]                 }
[16:12:26.771]                 NAMES <- toupper(added)
[16:12:26.771]                 for (kk in seq_along(NAMES)) {
[16:12:26.771]                   name <- added[[kk]]
[16:12:26.771]                   NAME <- NAMES[[kk]]
[16:12:26.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.771]                     next
[16:12:26.771]                   args[[name]] <- ""
[16:12:26.771]                 }
[16:12:26.771]                 NAMES <- toupper(removed)
[16:12:26.771]                 for (kk in seq_along(NAMES)) {
[16:12:26.771]                   name <- removed[[kk]]
[16:12:26.771]                   NAME <- NAMES[[kk]]
[16:12:26.771]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.771]                     next
[16:12:26.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.771]                 }
[16:12:26.771]                 if (length(args) > 0) 
[16:12:26.771]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.771]             }
[16:12:26.771]             else {
[16:12:26.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.771]             }
[16:12:26.771]             {
[16:12:26.771]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.771]                   0L) {
[16:12:26.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.771]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.771]                   base::options(opts)
[16:12:26.771]                 }
[16:12:26.771]                 {
[16:12:26.771]                   {
[16:12:26.771]                     NULL
[16:12:26.771]                     RNGkind("Mersenne-Twister")
[16:12:26.771]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.771]                       inherits = FALSE)
[16:12:26.771]                   }
[16:12:26.771]                   options(future.plan = NULL)
[16:12:26.771]                   if (is.na(NA_character_)) 
[16:12:26.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.771]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.771]                   {
[16:12:26.771]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.771]                     if (!future$lazy) 
[16:12:26.771]                       future <- run(future)
[16:12:26.771]                     invisible(future)
[16:12:26.771]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.771]                 }
[16:12:26.771]             }
[16:12:26.771]         }
[16:12:26.771]     })
[16:12:26.771]     if (TRUE) {
[16:12:26.771]         base::sink(type = "output", split = FALSE)
[16:12:26.771]         if (TRUE) {
[16:12:26.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.771]         }
[16:12:26.771]         else {
[16:12:26.771]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.771]         }
[16:12:26.771]         base::close(...future.stdout)
[16:12:26.771]         ...future.stdout <- NULL
[16:12:26.771]     }
[16:12:26.771]     ...future.result$conditions <- ...future.conditions
[16:12:26.771]     ...future.result$finished <- base::Sys.time()
[16:12:26.771]     ...future.result
[16:12:26.771] }
[16:12:26.773] plan(): Setting new future strategy stack:
[16:12:26.773] List of future strategies:
[16:12:26.773] 1. sequential:
[16:12:26.773]    - args: function (..., envir = parent.frame())
[16:12:26.773]    - tweaked: FALSE
[16:12:26.773]    - call: NULL
[16:12:26.773] plan(): nbrOfWorkers() = 1
[16:12:26.774] plan(): Setting new future strategy stack:
[16:12:26.774] List of future strategies:
[16:12:26.774] 1. sequential:
[16:12:26.774]    - args: function (..., envir = parent.frame())
[16:12:26.774]    - tweaked: FALSE
[16:12:26.774]    - call: plan(strategy)
[16:12:26.774] plan(): nbrOfWorkers() = 1
[16:12:26.775] SequentialFuture started (and completed)
[16:12:26.775] - Launch lazy future ... done
[16:12:26.775] run() for ‘SequentialFuture’ ... done
[16:12:26.775] getGlobalsAndPackages() ...
[16:12:26.775] Searching for globals...
[16:12:26.775] 
[16:12:26.775] Searching for globals ... DONE
[16:12:26.775] - globals: [0] <none>
[16:12:26.776] getGlobalsAndPackages() ... DONE
[16:12:26.776] run() for ‘Future’ ...
[16:12:26.776] - state: ‘created’
[16:12:26.776] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.776] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.776] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.776]   - Field: ‘label’
[16:12:26.777]   - Field: ‘local’
[16:12:26.777]   - Field: ‘owner’
[16:12:26.777]   - Field: ‘envir’
[16:12:26.777]   - Field: ‘packages’
[16:12:26.777]   - Field: ‘gc’
[16:12:26.777]   - Field: ‘conditions’
[16:12:26.777]   - Field: ‘expr’
[16:12:26.777]   - Field: ‘uuid’
[16:12:26.777]   - Field: ‘seed’
[16:12:26.777]   - Field: ‘version’
[16:12:26.777]   - Field: ‘result’
[16:12:26.778]   - Field: ‘asynchronous’
[16:12:26.778]   - Field: ‘calls’
[16:12:26.778]   - Field: ‘globals’
[16:12:26.778]   - Field: ‘stdout’
[16:12:26.778]   - Field: ‘earlySignal’
[16:12:26.778]   - Field: ‘lazy’
[16:12:26.778]   - Field: ‘state’
[16:12:26.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.778] - Launch lazy future ...
[16:12:26.778] Packages needed by the future expression (n = 0): <none>
[16:12:26.779] Packages needed by future strategies (n = 0): <none>
[16:12:26.780] {
[16:12:26.780]     {
[16:12:26.780]         {
[16:12:26.780]             ...future.startTime <- base::Sys.time()
[16:12:26.780]             {
[16:12:26.780]                 {
[16:12:26.780]                   {
[16:12:26.780]                     base::local({
[16:12:26.780]                       has_future <- base::requireNamespace("future", 
[16:12:26.780]                         quietly = TRUE)
[16:12:26.780]                       if (has_future) {
[16:12:26.780]                         ns <- base::getNamespace("future")
[16:12:26.780]                         version <- ns[[".package"]][["version"]]
[16:12:26.780]                         if (is.null(version)) 
[16:12:26.780]                           version <- utils::packageVersion("future")
[16:12:26.780]                       }
[16:12:26.780]                       else {
[16:12:26.780]                         version <- NULL
[16:12:26.780]                       }
[16:12:26.780]                       if (!has_future || version < "1.8.0") {
[16:12:26.780]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.780]                           "", base::R.version$version.string), 
[16:12:26.780]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.780]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.780]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.780]                             "release", "version")], collapse = " "), 
[16:12:26.780]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.780]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.780]                           info)
[16:12:26.780]                         info <- base::paste(info, collapse = "; ")
[16:12:26.780]                         if (!has_future) {
[16:12:26.780]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.780]                             info)
[16:12:26.780]                         }
[16:12:26.780]                         else {
[16:12:26.780]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.780]                             info, version)
[16:12:26.780]                         }
[16:12:26.780]                         base::stop(msg)
[16:12:26.780]                       }
[16:12:26.780]                     })
[16:12:26.780]                   }
[16:12:26.780]                   options(future.plan = NULL)
[16:12:26.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.780]                 }
[16:12:26.780]                 ...future.workdir <- getwd()
[16:12:26.780]             }
[16:12:26.780]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.780]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.780]         }
[16:12:26.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.780]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.780]             base::names(...future.oldOptions))
[16:12:26.780]     }
[16:12:26.780]     if (FALSE) {
[16:12:26.780]     }
[16:12:26.780]     else {
[16:12:26.780]         if (TRUE) {
[16:12:26.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.780]                 open = "w")
[16:12:26.780]         }
[16:12:26.780]         else {
[16:12:26.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.780]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.780]         }
[16:12:26.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.780]             base::sink(type = "output", split = FALSE)
[16:12:26.780]             base::close(...future.stdout)
[16:12:26.780]         }, add = TRUE)
[16:12:26.780]     }
[16:12:26.780]     ...future.frame <- base::sys.nframe()
[16:12:26.780]     ...future.conditions <- base::list()
[16:12:26.780]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.780]     if (FALSE) {
[16:12:26.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.780]     }
[16:12:26.780]     ...future.result <- base::tryCatch({
[16:12:26.780]         base::withCallingHandlers({
[16:12:26.780]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.780]             future::FutureResult(value = ...future.value$value, 
[16:12:26.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.780]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.780]                     ...future.globalenv.names))
[16:12:26.780]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.780]         }, condition = base::local({
[16:12:26.780]             c <- base::c
[16:12:26.780]             inherits <- base::inherits
[16:12:26.780]             invokeRestart <- base::invokeRestart
[16:12:26.780]             length <- base::length
[16:12:26.780]             list <- base::list
[16:12:26.780]             seq.int <- base::seq.int
[16:12:26.780]             signalCondition <- base::signalCondition
[16:12:26.780]             sys.calls <- base::sys.calls
[16:12:26.780]             `[[` <- base::`[[`
[16:12:26.780]             `+` <- base::`+`
[16:12:26.780]             `<<-` <- base::`<<-`
[16:12:26.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.780]                   3L)]
[16:12:26.780]             }
[16:12:26.780]             function(cond) {
[16:12:26.780]                 is_error <- inherits(cond, "error")
[16:12:26.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.780]                   NULL)
[16:12:26.780]                 if (is_error) {
[16:12:26.780]                   sessionInformation <- function() {
[16:12:26.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.780]                       search = base::search(), system = base::Sys.info())
[16:12:26.780]                   }
[16:12:26.780]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.780]                     cond$call), session = sessionInformation(), 
[16:12:26.780]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.780]                   signalCondition(cond)
[16:12:26.780]                 }
[16:12:26.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.780]                 "immediateCondition"))) {
[16:12:26.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.780]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.780]                   if (TRUE && !signal) {
[16:12:26.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.780]                     {
[16:12:26.780]                       inherits <- base::inherits
[16:12:26.780]                       invokeRestart <- base::invokeRestart
[16:12:26.780]                       is.null <- base::is.null
[16:12:26.780]                       muffled <- FALSE
[16:12:26.780]                       if (inherits(cond, "message")) {
[16:12:26.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.780]                         if (muffled) 
[16:12:26.780]                           invokeRestart("muffleMessage")
[16:12:26.780]                       }
[16:12:26.780]                       else if (inherits(cond, "warning")) {
[16:12:26.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.780]                         if (muffled) 
[16:12:26.780]                           invokeRestart("muffleWarning")
[16:12:26.780]                       }
[16:12:26.780]                       else if (inherits(cond, "condition")) {
[16:12:26.780]                         if (!is.null(pattern)) {
[16:12:26.780]                           computeRestarts <- base::computeRestarts
[16:12:26.780]                           grepl <- base::grepl
[16:12:26.780]                           restarts <- computeRestarts(cond)
[16:12:26.780]                           for (restart in restarts) {
[16:12:26.780]                             name <- restart$name
[16:12:26.780]                             if (is.null(name)) 
[16:12:26.780]                               next
[16:12:26.780]                             if (!grepl(pattern, name)) 
[16:12:26.780]                               next
[16:12:26.780]                             invokeRestart(restart)
[16:12:26.780]                             muffled <- TRUE
[16:12:26.780]                             break
[16:12:26.780]                           }
[16:12:26.780]                         }
[16:12:26.780]                       }
[16:12:26.780]                       invisible(muffled)
[16:12:26.780]                     }
[16:12:26.780]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.780]                   }
[16:12:26.780]                 }
[16:12:26.780]                 else {
[16:12:26.780]                   if (TRUE) {
[16:12:26.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.780]                     {
[16:12:26.780]                       inherits <- base::inherits
[16:12:26.780]                       invokeRestart <- base::invokeRestart
[16:12:26.780]                       is.null <- base::is.null
[16:12:26.780]                       muffled <- FALSE
[16:12:26.780]                       if (inherits(cond, "message")) {
[16:12:26.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.780]                         if (muffled) 
[16:12:26.780]                           invokeRestart("muffleMessage")
[16:12:26.780]                       }
[16:12:26.780]                       else if (inherits(cond, "warning")) {
[16:12:26.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.780]                         if (muffled) 
[16:12:26.780]                           invokeRestart("muffleWarning")
[16:12:26.780]                       }
[16:12:26.780]                       else if (inherits(cond, "condition")) {
[16:12:26.780]                         if (!is.null(pattern)) {
[16:12:26.780]                           computeRestarts <- base::computeRestarts
[16:12:26.780]                           grepl <- base::grepl
[16:12:26.780]                           restarts <- computeRestarts(cond)
[16:12:26.780]                           for (restart in restarts) {
[16:12:26.780]                             name <- restart$name
[16:12:26.780]                             if (is.null(name)) 
[16:12:26.780]                               next
[16:12:26.780]                             if (!grepl(pattern, name)) 
[16:12:26.780]                               next
[16:12:26.780]                             invokeRestart(restart)
[16:12:26.780]                             muffled <- TRUE
[16:12:26.780]                             break
[16:12:26.780]                           }
[16:12:26.780]                         }
[16:12:26.780]                       }
[16:12:26.780]                       invisible(muffled)
[16:12:26.780]                     }
[16:12:26.780]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.780]                   }
[16:12:26.780]                 }
[16:12:26.780]             }
[16:12:26.780]         }))
[16:12:26.780]     }, error = function(ex) {
[16:12:26.780]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.780]                 ...future.rng), started = ...future.startTime, 
[16:12:26.780]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.780]             version = "1.8"), class = "FutureResult")
[16:12:26.780]     }, finally = {
[16:12:26.780]         if (!identical(...future.workdir, getwd())) 
[16:12:26.780]             setwd(...future.workdir)
[16:12:26.780]         {
[16:12:26.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.780]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.780]             }
[16:12:26.780]             base::options(...future.oldOptions)
[16:12:26.780]             if (.Platform$OS.type == "windows") {
[16:12:26.780]                 old_names <- names(...future.oldEnvVars)
[16:12:26.780]                 envs <- base::Sys.getenv()
[16:12:26.780]                 names <- names(envs)
[16:12:26.780]                 common <- intersect(names, old_names)
[16:12:26.780]                 added <- setdiff(names, old_names)
[16:12:26.780]                 removed <- setdiff(old_names, names)
[16:12:26.780]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.780]                   envs[common]]
[16:12:26.780]                 NAMES <- toupper(changed)
[16:12:26.780]                 args <- list()
[16:12:26.780]                 for (kk in seq_along(NAMES)) {
[16:12:26.780]                   name <- changed[[kk]]
[16:12:26.780]                   NAME <- NAMES[[kk]]
[16:12:26.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.780]                     next
[16:12:26.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.780]                 }
[16:12:26.780]                 NAMES <- toupper(added)
[16:12:26.780]                 for (kk in seq_along(NAMES)) {
[16:12:26.780]                   name <- added[[kk]]
[16:12:26.780]                   NAME <- NAMES[[kk]]
[16:12:26.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.780]                     next
[16:12:26.780]                   args[[name]] <- ""
[16:12:26.780]                 }
[16:12:26.780]                 NAMES <- toupper(removed)
[16:12:26.780]                 for (kk in seq_along(NAMES)) {
[16:12:26.780]                   name <- removed[[kk]]
[16:12:26.780]                   NAME <- NAMES[[kk]]
[16:12:26.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.780]                     next
[16:12:26.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.780]                 }
[16:12:26.780]                 if (length(args) > 0) 
[16:12:26.780]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.780]             }
[16:12:26.780]             else {
[16:12:26.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.780]             }
[16:12:26.780]             {
[16:12:26.780]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.780]                   0L) {
[16:12:26.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.780]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.780]                   base::options(opts)
[16:12:26.780]                 }
[16:12:26.780]                 {
[16:12:26.780]                   {
[16:12:26.780]                     NULL
[16:12:26.780]                     RNGkind("Mersenne-Twister")
[16:12:26.780]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.780]                       inherits = FALSE)
[16:12:26.780]                   }
[16:12:26.780]                   options(future.plan = NULL)
[16:12:26.780]                   if (is.na(NA_character_)) 
[16:12:26.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.780]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.780]                   {
[16:12:26.780]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.780]                     if (!future$lazy) 
[16:12:26.780]                       future <- run(future)
[16:12:26.780]                     invisible(future)
[16:12:26.780]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.780]                 }
[16:12:26.780]             }
[16:12:26.780]         }
[16:12:26.780]     })
[16:12:26.780]     if (TRUE) {
[16:12:26.780]         base::sink(type = "output", split = FALSE)
[16:12:26.780]         if (TRUE) {
[16:12:26.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.780]         }
[16:12:26.780]         else {
[16:12:26.780]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.780]         }
[16:12:26.780]         base::close(...future.stdout)
[16:12:26.780]         ...future.stdout <- NULL
[16:12:26.780]     }
[16:12:26.780]     ...future.result$conditions <- ...future.conditions
[16:12:26.780]     ...future.result$finished <- base::Sys.time()
[16:12:26.780]     ...future.result
[16:12:26.780] }
[16:12:26.782] plan(): Setting new future strategy stack:
[16:12:26.782] List of future strategies:
[16:12:26.782] 1. sequential:
[16:12:26.782]    - args: function (..., envir = parent.frame())
[16:12:26.782]    - tweaked: FALSE
[16:12:26.782]    - call: NULL
[16:12:26.782] plan(): nbrOfWorkers() = 1
[16:12:26.783] plan(): Setting new future strategy stack:
[16:12:26.783] List of future strategies:
[16:12:26.783] 1. sequential:
[16:12:26.783]    - args: function (..., envir = parent.frame())
[16:12:26.783]    - tweaked: FALSE
[16:12:26.783]    - call: plan(strategy)
[16:12:26.783] plan(): nbrOfWorkers() = 1
[16:12:26.783] SequentialFuture started (and completed)
[16:12:26.783] - Launch lazy future ... done
[16:12:26.784] run() for ‘SequentialFuture’ ... done
[16:12:26.784] getGlobalsAndPackages() ...
[16:12:26.784] Searching for globals...
[16:12:26.785] - globals found: [1] ‘{’
[16:12:26.785] Searching for globals ... DONE
[16:12:26.785] Resolving globals: FALSE
[16:12:26.785] 
[16:12:26.785] 
[16:12:26.785] getGlobalsAndPackages() ... DONE
[16:12:26.785] run() for ‘Future’ ...
[16:12:26.785] - state: ‘created’
[16:12:26.786] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.786] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.786]   - Field: ‘label’
[16:12:26.786]   - Field: ‘local’
[16:12:26.786]   - Field: ‘owner’
[16:12:26.786]   - Field: ‘envir’
[16:12:26.786]   - Field: ‘packages’
[16:12:26.787]   - Field: ‘gc’
[16:12:26.787]   - Field: ‘conditions’
[16:12:26.787]   - Field: ‘expr’
[16:12:26.787]   - Field: ‘uuid’
[16:12:26.787]   - Field: ‘seed’
[16:12:26.787]   - Field: ‘version’
[16:12:26.787]   - Field: ‘result’
[16:12:26.787]   - Field: ‘asynchronous’
[16:12:26.787]   - Field: ‘calls’
[16:12:26.787]   - Field: ‘globals’
[16:12:26.787]   - Field: ‘stdout’
[16:12:26.787]   - Field: ‘earlySignal’
[16:12:26.788]   - Field: ‘lazy’
[16:12:26.788]   - Field: ‘state’
[16:12:26.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.788] - Launch lazy future ...
[16:12:26.788] Packages needed by the future expression (n = 0): <none>
[16:12:26.788] Packages needed by future strategies (n = 0): <none>
[16:12:26.789] {
[16:12:26.789]     {
[16:12:26.789]         {
[16:12:26.789]             ...future.startTime <- base::Sys.time()
[16:12:26.789]             {
[16:12:26.789]                 {
[16:12:26.789]                   {
[16:12:26.789]                     base::local({
[16:12:26.789]                       has_future <- base::requireNamespace("future", 
[16:12:26.789]                         quietly = TRUE)
[16:12:26.789]                       if (has_future) {
[16:12:26.789]                         ns <- base::getNamespace("future")
[16:12:26.789]                         version <- ns[[".package"]][["version"]]
[16:12:26.789]                         if (is.null(version)) 
[16:12:26.789]                           version <- utils::packageVersion("future")
[16:12:26.789]                       }
[16:12:26.789]                       else {
[16:12:26.789]                         version <- NULL
[16:12:26.789]                       }
[16:12:26.789]                       if (!has_future || version < "1.8.0") {
[16:12:26.789]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.789]                           "", base::R.version$version.string), 
[16:12:26.789]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.789]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.789]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.789]                             "release", "version")], collapse = " "), 
[16:12:26.789]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.789]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.789]                           info)
[16:12:26.789]                         info <- base::paste(info, collapse = "; ")
[16:12:26.789]                         if (!has_future) {
[16:12:26.789]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.789]                             info)
[16:12:26.789]                         }
[16:12:26.789]                         else {
[16:12:26.789]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.789]                             info, version)
[16:12:26.789]                         }
[16:12:26.789]                         base::stop(msg)
[16:12:26.789]                       }
[16:12:26.789]                     })
[16:12:26.789]                   }
[16:12:26.789]                   options(future.plan = NULL)
[16:12:26.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.789]                 }
[16:12:26.789]                 ...future.workdir <- getwd()
[16:12:26.789]             }
[16:12:26.789]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.789]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.789]         }
[16:12:26.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.789]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.789]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.789]             base::names(...future.oldOptions))
[16:12:26.789]     }
[16:12:26.789]     if (FALSE) {
[16:12:26.789]     }
[16:12:26.789]     else {
[16:12:26.789]         if (TRUE) {
[16:12:26.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.789]                 open = "w")
[16:12:26.789]         }
[16:12:26.789]         else {
[16:12:26.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.789]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.789]         }
[16:12:26.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.789]             base::sink(type = "output", split = FALSE)
[16:12:26.789]             base::close(...future.stdout)
[16:12:26.789]         }, add = TRUE)
[16:12:26.789]     }
[16:12:26.789]     ...future.frame <- base::sys.nframe()
[16:12:26.789]     ...future.conditions <- base::list()
[16:12:26.789]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.789]     if (FALSE) {
[16:12:26.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.789]     }
[16:12:26.789]     ...future.result <- base::tryCatch({
[16:12:26.789]         base::withCallingHandlers({
[16:12:26.789]             ...future.value <- base::withVisible(base::local({
[16:12:26.789]                 4
[16:12:26.789]             }))
[16:12:26.789]             future::FutureResult(value = ...future.value$value, 
[16:12:26.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.789]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.789]                     ...future.globalenv.names))
[16:12:26.789]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.789]         }, condition = base::local({
[16:12:26.789]             c <- base::c
[16:12:26.789]             inherits <- base::inherits
[16:12:26.789]             invokeRestart <- base::invokeRestart
[16:12:26.789]             length <- base::length
[16:12:26.789]             list <- base::list
[16:12:26.789]             seq.int <- base::seq.int
[16:12:26.789]             signalCondition <- base::signalCondition
[16:12:26.789]             sys.calls <- base::sys.calls
[16:12:26.789]             `[[` <- base::`[[`
[16:12:26.789]             `+` <- base::`+`
[16:12:26.789]             `<<-` <- base::`<<-`
[16:12:26.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.789]                   3L)]
[16:12:26.789]             }
[16:12:26.789]             function(cond) {
[16:12:26.789]                 is_error <- inherits(cond, "error")
[16:12:26.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.789]                   NULL)
[16:12:26.789]                 if (is_error) {
[16:12:26.789]                   sessionInformation <- function() {
[16:12:26.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.789]                       search = base::search(), system = base::Sys.info())
[16:12:26.789]                   }
[16:12:26.789]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.789]                     cond$call), session = sessionInformation(), 
[16:12:26.789]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.789]                   signalCondition(cond)
[16:12:26.789]                 }
[16:12:26.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.789]                 "immediateCondition"))) {
[16:12:26.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.789]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.789]                   if (TRUE && !signal) {
[16:12:26.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.789]                     {
[16:12:26.789]                       inherits <- base::inherits
[16:12:26.789]                       invokeRestart <- base::invokeRestart
[16:12:26.789]                       is.null <- base::is.null
[16:12:26.789]                       muffled <- FALSE
[16:12:26.789]                       if (inherits(cond, "message")) {
[16:12:26.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.789]                         if (muffled) 
[16:12:26.789]                           invokeRestart("muffleMessage")
[16:12:26.789]                       }
[16:12:26.789]                       else if (inherits(cond, "warning")) {
[16:12:26.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.789]                         if (muffled) 
[16:12:26.789]                           invokeRestart("muffleWarning")
[16:12:26.789]                       }
[16:12:26.789]                       else if (inherits(cond, "condition")) {
[16:12:26.789]                         if (!is.null(pattern)) {
[16:12:26.789]                           computeRestarts <- base::computeRestarts
[16:12:26.789]                           grepl <- base::grepl
[16:12:26.789]                           restarts <- computeRestarts(cond)
[16:12:26.789]                           for (restart in restarts) {
[16:12:26.789]                             name <- restart$name
[16:12:26.789]                             if (is.null(name)) 
[16:12:26.789]                               next
[16:12:26.789]                             if (!grepl(pattern, name)) 
[16:12:26.789]                               next
[16:12:26.789]                             invokeRestart(restart)
[16:12:26.789]                             muffled <- TRUE
[16:12:26.789]                             break
[16:12:26.789]                           }
[16:12:26.789]                         }
[16:12:26.789]                       }
[16:12:26.789]                       invisible(muffled)
[16:12:26.789]                     }
[16:12:26.789]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.789]                   }
[16:12:26.789]                 }
[16:12:26.789]                 else {
[16:12:26.789]                   if (TRUE) {
[16:12:26.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.789]                     {
[16:12:26.789]                       inherits <- base::inherits
[16:12:26.789]                       invokeRestart <- base::invokeRestart
[16:12:26.789]                       is.null <- base::is.null
[16:12:26.789]                       muffled <- FALSE
[16:12:26.789]                       if (inherits(cond, "message")) {
[16:12:26.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.789]                         if (muffled) 
[16:12:26.789]                           invokeRestart("muffleMessage")
[16:12:26.789]                       }
[16:12:26.789]                       else if (inherits(cond, "warning")) {
[16:12:26.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.789]                         if (muffled) 
[16:12:26.789]                           invokeRestart("muffleWarning")
[16:12:26.789]                       }
[16:12:26.789]                       else if (inherits(cond, "condition")) {
[16:12:26.789]                         if (!is.null(pattern)) {
[16:12:26.789]                           computeRestarts <- base::computeRestarts
[16:12:26.789]                           grepl <- base::grepl
[16:12:26.789]                           restarts <- computeRestarts(cond)
[16:12:26.789]                           for (restart in restarts) {
[16:12:26.789]                             name <- restart$name
[16:12:26.789]                             if (is.null(name)) 
[16:12:26.789]                               next
[16:12:26.789]                             if (!grepl(pattern, name)) 
[16:12:26.789]                               next
[16:12:26.789]                             invokeRestart(restart)
[16:12:26.789]                             muffled <- TRUE
[16:12:26.789]                             break
[16:12:26.789]                           }
[16:12:26.789]                         }
[16:12:26.789]                       }
[16:12:26.789]                       invisible(muffled)
[16:12:26.789]                     }
[16:12:26.789]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.789]                   }
[16:12:26.789]                 }
[16:12:26.789]             }
[16:12:26.789]         }))
[16:12:26.789]     }, error = function(ex) {
[16:12:26.789]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.789]                 ...future.rng), started = ...future.startTime, 
[16:12:26.789]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.789]             version = "1.8"), class = "FutureResult")
[16:12:26.789]     }, finally = {
[16:12:26.789]         if (!identical(...future.workdir, getwd())) 
[16:12:26.789]             setwd(...future.workdir)
[16:12:26.789]         {
[16:12:26.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.789]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.789]             }
[16:12:26.789]             base::options(...future.oldOptions)
[16:12:26.789]             if (.Platform$OS.type == "windows") {
[16:12:26.789]                 old_names <- names(...future.oldEnvVars)
[16:12:26.789]                 envs <- base::Sys.getenv()
[16:12:26.789]                 names <- names(envs)
[16:12:26.789]                 common <- intersect(names, old_names)
[16:12:26.789]                 added <- setdiff(names, old_names)
[16:12:26.789]                 removed <- setdiff(old_names, names)
[16:12:26.789]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.789]                   envs[common]]
[16:12:26.789]                 NAMES <- toupper(changed)
[16:12:26.789]                 args <- list()
[16:12:26.789]                 for (kk in seq_along(NAMES)) {
[16:12:26.789]                   name <- changed[[kk]]
[16:12:26.789]                   NAME <- NAMES[[kk]]
[16:12:26.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.789]                     next
[16:12:26.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.789]                 }
[16:12:26.789]                 NAMES <- toupper(added)
[16:12:26.789]                 for (kk in seq_along(NAMES)) {
[16:12:26.789]                   name <- added[[kk]]
[16:12:26.789]                   NAME <- NAMES[[kk]]
[16:12:26.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.789]                     next
[16:12:26.789]                   args[[name]] <- ""
[16:12:26.789]                 }
[16:12:26.789]                 NAMES <- toupper(removed)
[16:12:26.789]                 for (kk in seq_along(NAMES)) {
[16:12:26.789]                   name <- removed[[kk]]
[16:12:26.789]                   NAME <- NAMES[[kk]]
[16:12:26.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.789]                     next
[16:12:26.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.789]                 }
[16:12:26.789]                 if (length(args) > 0) 
[16:12:26.789]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.789]             }
[16:12:26.789]             else {
[16:12:26.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.789]             }
[16:12:26.789]             {
[16:12:26.789]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.789]                   0L) {
[16:12:26.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.789]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.789]                   base::options(opts)
[16:12:26.789]                 }
[16:12:26.789]                 {
[16:12:26.789]                   {
[16:12:26.789]                     NULL
[16:12:26.789]                     RNGkind("Mersenne-Twister")
[16:12:26.789]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.789]                       inherits = FALSE)
[16:12:26.789]                   }
[16:12:26.789]                   options(future.plan = NULL)
[16:12:26.789]                   if (is.na(NA_character_)) 
[16:12:26.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.789]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.789]                   {
[16:12:26.789]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.789]                     if (!future$lazy) 
[16:12:26.789]                       future <- run(future)
[16:12:26.789]                     invisible(future)
[16:12:26.789]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.789]                 }
[16:12:26.789]             }
[16:12:26.789]         }
[16:12:26.789]     })
[16:12:26.789]     if (TRUE) {
[16:12:26.789]         base::sink(type = "output", split = FALSE)
[16:12:26.789]         if (TRUE) {
[16:12:26.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.789]         }
[16:12:26.789]         else {
[16:12:26.789]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.789]         }
[16:12:26.789]         base::close(...future.stdout)
[16:12:26.789]         ...future.stdout <- NULL
[16:12:26.789]     }
[16:12:26.789]     ...future.result$conditions <- ...future.conditions
[16:12:26.789]     ...future.result$finished <- base::Sys.time()
[16:12:26.789]     ...future.result
[16:12:26.789] }
[16:12:26.790] plan(): Setting new future strategy stack:
[16:12:26.790] List of future strategies:
[16:12:26.790] 1. sequential:
[16:12:26.790]    - args: function (..., envir = parent.frame())
[16:12:26.790]    - tweaked: FALSE
[16:12:26.790]    - call: NULL
[16:12:26.791] plan(): nbrOfWorkers() = 1
[16:12:26.791] plan(): Setting new future strategy stack:
[16:12:26.791] List of future strategies:
[16:12:26.791] 1. sequential:
[16:12:26.791]    - args: function (..., envir = parent.frame())
[16:12:26.791]    - tweaked: FALSE
[16:12:26.791]    - call: plan(strategy)
[16:12:26.792] plan(): nbrOfWorkers() = 1
[16:12:26.792] SequentialFuture started (and completed)
[16:12:26.792] - Launch lazy future ... done
[16:12:26.792] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560baea5ce68> 
Classes 'listenv', 'environment' <environment: 0x560bae5f2c28> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:12:26.795] resolved() for ‘SequentialFuture’ ...
[16:12:26.796] - state: ‘finished’
[16:12:26.796] - run: TRUE
[16:12:26.796] - result: ‘FutureResult’
[16:12:26.796] resolved() for ‘SequentialFuture’ ... done
[16:12:26.796] resolved() for ‘SequentialFuture’ ...
[16:12:26.796] - state: ‘finished’
[16:12:26.796] - run: TRUE
[16:12:26.796] - result: ‘FutureResult’
[16:12:26.796] resolved() for ‘SequentialFuture’ ... done
[16:12:26.796] resolved() for ‘SequentialFuture’ ...
[16:12:26.796] - state: ‘finished’
[16:12:26.797] - run: TRUE
[16:12:26.797] - result: ‘FutureResult’
[16:12:26.797] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:26.799] resolve() on list environment ...
[16:12:26.799]  recursive: 0
[16:12:26.800]  length: 6
[16:12:26.800]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:26.800] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.800] - nx: 6
[16:12:26.800] - relay: TRUE
[16:12:26.800] - stdout: TRUE
[16:12:26.800] - signal: TRUE
[16:12:26.801] - resignal: FALSE
[16:12:26.801] - force: TRUE
[16:12:26.801] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.801] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.801]  - until=2
[16:12:26.801]  - relaying element #2
[16:12:26.801] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.801] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.801] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.801]  length: 5 (resolved future 1)
[16:12:26.801] resolved() for ‘SequentialFuture’ ...
[16:12:26.801] - state: ‘finished’
[16:12:26.802] - run: TRUE
[16:12:26.802] - result: ‘FutureResult’
[16:12:26.802] resolved() for ‘SequentialFuture’ ... done
[16:12:26.802] Future #2
[16:12:26.802] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.802] - nx: 6
[16:12:26.802] - relay: TRUE
[16:12:26.802] - stdout: TRUE
[16:12:26.802] - signal: TRUE
[16:12:26.802] - resignal: FALSE
[16:12:26.802] - force: TRUE
[16:12:26.803] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.803] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.803]  - until=2
[16:12:26.803]  - relaying element #2
[16:12:26.803] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.803] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.803] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.803]  length: 4 (resolved future 2)
[16:12:26.803] resolved() for ‘SequentialFuture’ ...
[16:12:26.803] - state: ‘finished’
[16:12:26.804] - run: TRUE
[16:12:26.804] - result: ‘FutureResult’
[16:12:26.804] resolved() for ‘SequentialFuture’ ... done
[16:12:26.804] Future #3
[16:12:26.804] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.804] - nx: 6
[16:12:26.804] - relay: TRUE
[16:12:26.804] - stdout: TRUE
[16:12:26.804] - signal: TRUE
[16:12:26.804] - resignal: FALSE
[16:12:26.804] - force: TRUE
[16:12:26.805] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.805] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.805]  - until=3
[16:12:26.805]  - relaying element #3
[16:12:26.805] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.805] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.805] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.806]  length: 3 (resolved future 3)
[16:12:26.806] resolved() for ‘SequentialFuture’ ...
[16:12:26.806] - state: ‘finished’
[16:12:26.806] - run: TRUE
[16:12:26.807] - result: ‘FutureResult’
[16:12:26.807] resolved() for ‘SequentialFuture’ ... done
[16:12:26.807] Future #4
[16:12:26.807] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.807] - nx: 6
[16:12:26.807] - relay: TRUE
[16:12:26.807] - stdout: TRUE
[16:12:26.807] - signal: TRUE
[16:12:26.807] - resignal: FALSE
[16:12:26.807] - force: TRUE
[16:12:26.807] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.808] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.808]  - until=4
[16:12:26.808]  - relaying element #4
[16:12:26.808] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.808] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.808] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.808]  length: 2 (resolved future 4)
[16:12:26.808] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.808] - nx: 6
[16:12:26.808] - relay: TRUE
[16:12:26.808] - stdout: TRUE
[16:12:26.809] - signal: TRUE
[16:12:26.809] - resignal: FALSE
[16:12:26.809] - force: TRUE
[16:12:26.809] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.809] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.809]  - until=6
[16:12:26.809]  - relaying element #6
[16:12:26.809] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.809] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.809] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.809]  length: 1 (resolved future 5)
[16:12:26.809] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.810] - nx: 6
[16:12:26.810] - relay: TRUE
[16:12:26.810] - stdout: TRUE
[16:12:26.810] - signal: TRUE
[16:12:26.810] - resignal: FALSE
[16:12:26.810] - force: TRUE
[16:12:26.810] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.810] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.810]  - until=6
[16:12:26.810] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.810] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.810] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.811]  length: 0 (resolved future 6)
[16:12:26.811] Relaying remaining futures
[16:12:26.811] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.811] - nx: 6
[16:12:26.811] - relay: TRUE
[16:12:26.811] - stdout: TRUE
[16:12:26.811] - signal: TRUE
[16:12:26.811] - resignal: FALSE
[16:12:26.811] - force: TRUE
[16:12:26.811] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.811] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:26.811] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.812] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.812] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.812] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560baec5dd08> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:12:26.814] getGlobalsAndPackages() ...
[16:12:26.814] Searching for globals...
[16:12:26.814] 
[16:12:26.814] Searching for globals ... DONE
[16:12:26.814] - globals: [0] <none>
[16:12:26.814] getGlobalsAndPackages() ... DONE
[16:12:26.814] run() for ‘Future’ ...
[16:12:26.815] - state: ‘created’
[16:12:26.815] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.815] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.815] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.815]   - Field: ‘label’
[16:12:26.815]   - Field: ‘local’
[16:12:26.815]   - Field: ‘owner’
[16:12:26.815]   - Field: ‘envir’
[16:12:26.815]   - Field: ‘packages’
[16:12:26.816]   - Field: ‘gc’
[16:12:26.816]   - Field: ‘conditions’
[16:12:26.816]   - Field: ‘expr’
[16:12:26.816]   - Field: ‘uuid’
[16:12:26.816]   - Field: ‘seed’
[16:12:26.816]   - Field: ‘version’
[16:12:26.816]   - Field: ‘result’
[16:12:26.816]   - Field: ‘asynchronous’
[16:12:26.816]   - Field: ‘calls’
[16:12:26.816]   - Field: ‘globals’
[16:12:26.816]   - Field: ‘stdout’
[16:12:26.817]   - Field: ‘earlySignal’
[16:12:26.817]   - Field: ‘lazy’
[16:12:26.817]   - Field: ‘state’
[16:12:26.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.817] - Launch lazy future ...
[16:12:26.817] Packages needed by the future expression (n = 0): <none>
[16:12:26.817] Packages needed by future strategies (n = 0): <none>
[16:12:26.818] {
[16:12:26.818]     {
[16:12:26.818]         {
[16:12:26.818]             ...future.startTime <- base::Sys.time()
[16:12:26.818]             {
[16:12:26.818]                 {
[16:12:26.818]                   {
[16:12:26.818]                     base::local({
[16:12:26.818]                       has_future <- base::requireNamespace("future", 
[16:12:26.818]                         quietly = TRUE)
[16:12:26.818]                       if (has_future) {
[16:12:26.818]                         ns <- base::getNamespace("future")
[16:12:26.818]                         version <- ns[[".package"]][["version"]]
[16:12:26.818]                         if (is.null(version)) 
[16:12:26.818]                           version <- utils::packageVersion("future")
[16:12:26.818]                       }
[16:12:26.818]                       else {
[16:12:26.818]                         version <- NULL
[16:12:26.818]                       }
[16:12:26.818]                       if (!has_future || version < "1.8.0") {
[16:12:26.818]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.818]                           "", base::R.version$version.string), 
[16:12:26.818]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.818]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.818]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.818]                             "release", "version")], collapse = " "), 
[16:12:26.818]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.818]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.818]                           info)
[16:12:26.818]                         info <- base::paste(info, collapse = "; ")
[16:12:26.818]                         if (!has_future) {
[16:12:26.818]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.818]                             info)
[16:12:26.818]                         }
[16:12:26.818]                         else {
[16:12:26.818]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.818]                             info, version)
[16:12:26.818]                         }
[16:12:26.818]                         base::stop(msg)
[16:12:26.818]                       }
[16:12:26.818]                     })
[16:12:26.818]                   }
[16:12:26.818]                   options(future.plan = NULL)
[16:12:26.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.818]                 }
[16:12:26.818]                 ...future.workdir <- getwd()
[16:12:26.818]             }
[16:12:26.818]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.818]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.818]         }
[16:12:26.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.818]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.818]             base::names(...future.oldOptions))
[16:12:26.818]     }
[16:12:26.818]     if (FALSE) {
[16:12:26.818]     }
[16:12:26.818]     else {
[16:12:26.818]         if (TRUE) {
[16:12:26.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.818]                 open = "w")
[16:12:26.818]         }
[16:12:26.818]         else {
[16:12:26.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.818]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.818]         }
[16:12:26.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.818]             base::sink(type = "output", split = FALSE)
[16:12:26.818]             base::close(...future.stdout)
[16:12:26.818]         }, add = TRUE)
[16:12:26.818]     }
[16:12:26.818]     ...future.frame <- base::sys.nframe()
[16:12:26.818]     ...future.conditions <- base::list()
[16:12:26.818]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.818]     if (FALSE) {
[16:12:26.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.818]     }
[16:12:26.818]     ...future.result <- base::tryCatch({
[16:12:26.818]         base::withCallingHandlers({
[16:12:26.818]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.818]             future::FutureResult(value = ...future.value$value, 
[16:12:26.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.818]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.818]                     ...future.globalenv.names))
[16:12:26.818]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.818]         }, condition = base::local({
[16:12:26.818]             c <- base::c
[16:12:26.818]             inherits <- base::inherits
[16:12:26.818]             invokeRestart <- base::invokeRestart
[16:12:26.818]             length <- base::length
[16:12:26.818]             list <- base::list
[16:12:26.818]             seq.int <- base::seq.int
[16:12:26.818]             signalCondition <- base::signalCondition
[16:12:26.818]             sys.calls <- base::sys.calls
[16:12:26.818]             `[[` <- base::`[[`
[16:12:26.818]             `+` <- base::`+`
[16:12:26.818]             `<<-` <- base::`<<-`
[16:12:26.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.818]                   3L)]
[16:12:26.818]             }
[16:12:26.818]             function(cond) {
[16:12:26.818]                 is_error <- inherits(cond, "error")
[16:12:26.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.818]                   NULL)
[16:12:26.818]                 if (is_error) {
[16:12:26.818]                   sessionInformation <- function() {
[16:12:26.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.818]                       search = base::search(), system = base::Sys.info())
[16:12:26.818]                   }
[16:12:26.818]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.818]                     cond$call), session = sessionInformation(), 
[16:12:26.818]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.818]                   signalCondition(cond)
[16:12:26.818]                 }
[16:12:26.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.818]                 "immediateCondition"))) {
[16:12:26.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.818]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.818]                   if (TRUE && !signal) {
[16:12:26.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.818]                     {
[16:12:26.818]                       inherits <- base::inherits
[16:12:26.818]                       invokeRestart <- base::invokeRestart
[16:12:26.818]                       is.null <- base::is.null
[16:12:26.818]                       muffled <- FALSE
[16:12:26.818]                       if (inherits(cond, "message")) {
[16:12:26.818]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.818]                         if (muffled) 
[16:12:26.818]                           invokeRestart("muffleMessage")
[16:12:26.818]                       }
[16:12:26.818]                       else if (inherits(cond, "warning")) {
[16:12:26.818]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.818]                         if (muffled) 
[16:12:26.818]                           invokeRestart("muffleWarning")
[16:12:26.818]                       }
[16:12:26.818]                       else if (inherits(cond, "condition")) {
[16:12:26.818]                         if (!is.null(pattern)) {
[16:12:26.818]                           computeRestarts <- base::computeRestarts
[16:12:26.818]                           grepl <- base::grepl
[16:12:26.818]                           restarts <- computeRestarts(cond)
[16:12:26.818]                           for (restart in restarts) {
[16:12:26.818]                             name <- restart$name
[16:12:26.818]                             if (is.null(name)) 
[16:12:26.818]                               next
[16:12:26.818]                             if (!grepl(pattern, name)) 
[16:12:26.818]                               next
[16:12:26.818]                             invokeRestart(restart)
[16:12:26.818]                             muffled <- TRUE
[16:12:26.818]                             break
[16:12:26.818]                           }
[16:12:26.818]                         }
[16:12:26.818]                       }
[16:12:26.818]                       invisible(muffled)
[16:12:26.818]                     }
[16:12:26.818]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.818]                   }
[16:12:26.818]                 }
[16:12:26.818]                 else {
[16:12:26.818]                   if (TRUE) {
[16:12:26.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.818]                     {
[16:12:26.818]                       inherits <- base::inherits
[16:12:26.818]                       invokeRestart <- base::invokeRestart
[16:12:26.818]                       is.null <- base::is.null
[16:12:26.818]                       muffled <- FALSE
[16:12:26.818]                       if (inherits(cond, "message")) {
[16:12:26.818]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.818]                         if (muffled) 
[16:12:26.818]                           invokeRestart("muffleMessage")
[16:12:26.818]                       }
[16:12:26.818]                       else if (inherits(cond, "warning")) {
[16:12:26.818]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.818]                         if (muffled) 
[16:12:26.818]                           invokeRestart("muffleWarning")
[16:12:26.818]                       }
[16:12:26.818]                       else if (inherits(cond, "condition")) {
[16:12:26.818]                         if (!is.null(pattern)) {
[16:12:26.818]                           computeRestarts <- base::computeRestarts
[16:12:26.818]                           grepl <- base::grepl
[16:12:26.818]                           restarts <- computeRestarts(cond)
[16:12:26.818]                           for (restart in restarts) {
[16:12:26.818]                             name <- restart$name
[16:12:26.818]                             if (is.null(name)) 
[16:12:26.818]                               next
[16:12:26.818]                             if (!grepl(pattern, name)) 
[16:12:26.818]                               next
[16:12:26.818]                             invokeRestart(restart)
[16:12:26.818]                             muffled <- TRUE
[16:12:26.818]                             break
[16:12:26.818]                           }
[16:12:26.818]                         }
[16:12:26.818]                       }
[16:12:26.818]                       invisible(muffled)
[16:12:26.818]                     }
[16:12:26.818]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.818]                   }
[16:12:26.818]                 }
[16:12:26.818]             }
[16:12:26.818]         }))
[16:12:26.818]     }, error = function(ex) {
[16:12:26.818]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.818]                 ...future.rng), started = ...future.startTime, 
[16:12:26.818]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.818]             version = "1.8"), class = "FutureResult")
[16:12:26.818]     }, finally = {
[16:12:26.818]         if (!identical(...future.workdir, getwd())) 
[16:12:26.818]             setwd(...future.workdir)
[16:12:26.818]         {
[16:12:26.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.818]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.818]             }
[16:12:26.818]             base::options(...future.oldOptions)
[16:12:26.818]             if (.Platform$OS.type == "windows") {
[16:12:26.818]                 old_names <- names(...future.oldEnvVars)
[16:12:26.818]                 envs <- base::Sys.getenv()
[16:12:26.818]                 names <- names(envs)
[16:12:26.818]                 common <- intersect(names, old_names)
[16:12:26.818]                 added <- setdiff(names, old_names)
[16:12:26.818]                 removed <- setdiff(old_names, names)
[16:12:26.818]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.818]                   envs[common]]
[16:12:26.818]                 NAMES <- toupper(changed)
[16:12:26.818]                 args <- list()
[16:12:26.818]                 for (kk in seq_along(NAMES)) {
[16:12:26.818]                   name <- changed[[kk]]
[16:12:26.818]                   NAME <- NAMES[[kk]]
[16:12:26.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.818]                     next
[16:12:26.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.818]                 }
[16:12:26.818]                 NAMES <- toupper(added)
[16:12:26.818]                 for (kk in seq_along(NAMES)) {
[16:12:26.818]                   name <- added[[kk]]
[16:12:26.818]                   NAME <- NAMES[[kk]]
[16:12:26.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.818]                     next
[16:12:26.818]                   args[[name]] <- ""
[16:12:26.818]                 }
[16:12:26.818]                 NAMES <- toupper(removed)
[16:12:26.818]                 for (kk in seq_along(NAMES)) {
[16:12:26.818]                   name <- removed[[kk]]
[16:12:26.818]                   NAME <- NAMES[[kk]]
[16:12:26.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.818]                     next
[16:12:26.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.818]                 }
[16:12:26.818]                 if (length(args) > 0) 
[16:12:26.818]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.818]             }
[16:12:26.818]             else {
[16:12:26.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.818]             }
[16:12:26.818]             {
[16:12:26.818]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.818]                   0L) {
[16:12:26.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.818]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.818]                   base::options(opts)
[16:12:26.818]                 }
[16:12:26.818]                 {
[16:12:26.818]                   {
[16:12:26.818]                     NULL
[16:12:26.818]                     RNGkind("Mersenne-Twister")
[16:12:26.818]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.818]                       inherits = FALSE)
[16:12:26.818]                   }
[16:12:26.818]                   options(future.plan = NULL)
[16:12:26.818]                   if (is.na(NA_character_)) 
[16:12:26.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.818]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.818]                   {
[16:12:26.818]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.818]                     if (!future$lazy) 
[16:12:26.818]                       future <- run(future)
[16:12:26.818]                     invisible(future)
[16:12:26.818]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.818]                 }
[16:12:26.818]             }
[16:12:26.818]         }
[16:12:26.818]     })
[16:12:26.818]     if (TRUE) {
[16:12:26.818]         base::sink(type = "output", split = FALSE)
[16:12:26.818]         if (TRUE) {
[16:12:26.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.818]         }
[16:12:26.818]         else {
[16:12:26.818]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.818]         }
[16:12:26.818]         base::close(...future.stdout)
[16:12:26.818]         ...future.stdout <- NULL
[16:12:26.818]     }
[16:12:26.818]     ...future.result$conditions <- ...future.conditions
[16:12:26.818]     ...future.result$finished <- base::Sys.time()
[16:12:26.818]     ...future.result
[16:12:26.818] }
[16:12:26.819] plan(): Setting new future strategy stack:
[16:12:26.819] List of future strategies:
[16:12:26.819] 1. sequential:
[16:12:26.819]    - args: function (..., envir = parent.frame())
[16:12:26.819]    - tweaked: FALSE
[16:12:26.819]    - call: NULL
[16:12:26.820] plan(): nbrOfWorkers() = 1
[16:12:26.820] plan(): Setting new future strategy stack:
[16:12:26.820] List of future strategies:
[16:12:26.820] 1. sequential:
[16:12:26.820]    - args: function (..., envir = parent.frame())
[16:12:26.820]    - tweaked: FALSE
[16:12:26.820]    - call: plan(strategy)
[16:12:26.821] plan(): nbrOfWorkers() = 1
[16:12:26.821] SequentialFuture started (and completed)
[16:12:26.821] - Launch lazy future ... done
[16:12:26.821] run() for ‘SequentialFuture’ ... done
[16:12:26.821] getGlobalsAndPackages() ...
[16:12:26.821] Searching for globals...
[16:12:26.822] 
[16:12:26.822] Searching for globals ... DONE
[16:12:26.822] - globals: [0] <none>
[16:12:26.822] getGlobalsAndPackages() ... DONE
[16:12:26.822] run() for ‘Future’ ...
[16:12:26.822] - state: ‘created’
[16:12:26.822] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.823] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.823]   - Field: ‘label’
[16:12:26.823]   - Field: ‘local’
[16:12:26.823]   - Field: ‘owner’
[16:12:26.823]   - Field: ‘envir’
[16:12:26.823]   - Field: ‘packages’
[16:12:26.823]   - Field: ‘gc’
[16:12:26.823]   - Field: ‘conditions’
[16:12:26.823]   - Field: ‘expr’
[16:12:26.823]   - Field: ‘uuid’
[16:12:26.824]   - Field: ‘seed’
[16:12:26.824]   - Field: ‘version’
[16:12:26.824]   - Field: ‘result’
[16:12:26.824]   - Field: ‘asynchronous’
[16:12:26.824]   - Field: ‘calls’
[16:12:26.824]   - Field: ‘globals’
[16:12:26.824]   - Field: ‘stdout’
[16:12:26.824]   - Field: ‘earlySignal’
[16:12:26.824]   - Field: ‘lazy’
[16:12:26.824]   - Field: ‘state’
[16:12:26.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.825] - Launch lazy future ...
[16:12:26.825] Packages needed by the future expression (n = 0): <none>
[16:12:26.825] Packages needed by future strategies (n = 0): <none>
[16:12:26.825] {
[16:12:26.825]     {
[16:12:26.825]         {
[16:12:26.825]             ...future.startTime <- base::Sys.time()
[16:12:26.825]             {
[16:12:26.825]                 {
[16:12:26.825]                   {
[16:12:26.825]                     base::local({
[16:12:26.825]                       has_future <- base::requireNamespace("future", 
[16:12:26.825]                         quietly = TRUE)
[16:12:26.825]                       if (has_future) {
[16:12:26.825]                         ns <- base::getNamespace("future")
[16:12:26.825]                         version <- ns[[".package"]][["version"]]
[16:12:26.825]                         if (is.null(version)) 
[16:12:26.825]                           version <- utils::packageVersion("future")
[16:12:26.825]                       }
[16:12:26.825]                       else {
[16:12:26.825]                         version <- NULL
[16:12:26.825]                       }
[16:12:26.825]                       if (!has_future || version < "1.8.0") {
[16:12:26.825]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.825]                           "", base::R.version$version.string), 
[16:12:26.825]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.825]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.825]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.825]                             "release", "version")], collapse = " "), 
[16:12:26.825]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.825]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.825]                           info)
[16:12:26.825]                         info <- base::paste(info, collapse = "; ")
[16:12:26.825]                         if (!has_future) {
[16:12:26.825]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.825]                             info)
[16:12:26.825]                         }
[16:12:26.825]                         else {
[16:12:26.825]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.825]                             info, version)
[16:12:26.825]                         }
[16:12:26.825]                         base::stop(msg)
[16:12:26.825]                       }
[16:12:26.825]                     })
[16:12:26.825]                   }
[16:12:26.825]                   options(future.plan = NULL)
[16:12:26.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.825]                 }
[16:12:26.825]                 ...future.workdir <- getwd()
[16:12:26.825]             }
[16:12:26.825]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.825]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.825]         }
[16:12:26.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.825]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.825]             base::names(...future.oldOptions))
[16:12:26.825]     }
[16:12:26.825]     if (FALSE) {
[16:12:26.825]     }
[16:12:26.825]     else {
[16:12:26.825]         if (TRUE) {
[16:12:26.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.825]                 open = "w")
[16:12:26.825]         }
[16:12:26.825]         else {
[16:12:26.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.825]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.825]         }
[16:12:26.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.825]             base::sink(type = "output", split = FALSE)
[16:12:26.825]             base::close(...future.stdout)
[16:12:26.825]         }, add = TRUE)
[16:12:26.825]     }
[16:12:26.825]     ...future.frame <- base::sys.nframe()
[16:12:26.825]     ...future.conditions <- base::list()
[16:12:26.825]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.825]     if (FALSE) {
[16:12:26.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.825]     }
[16:12:26.825]     ...future.result <- base::tryCatch({
[16:12:26.825]         base::withCallingHandlers({
[16:12:26.825]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.825]             future::FutureResult(value = ...future.value$value, 
[16:12:26.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.825]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.825]                     ...future.globalenv.names))
[16:12:26.825]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.825]         }, condition = base::local({
[16:12:26.825]             c <- base::c
[16:12:26.825]             inherits <- base::inherits
[16:12:26.825]             invokeRestart <- base::invokeRestart
[16:12:26.825]             length <- base::length
[16:12:26.825]             list <- base::list
[16:12:26.825]             seq.int <- base::seq.int
[16:12:26.825]             signalCondition <- base::signalCondition
[16:12:26.825]             sys.calls <- base::sys.calls
[16:12:26.825]             `[[` <- base::`[[`
[16:12:26.825]             `+` <- base::`+`
[16:12:26.825]             `<<-` <- base::`<<-`
[16:12:26.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.825]                   3L)]
[16:12:26.825]             }
[16:12:26.825]             function(cond) {
[16:12:26.825]                 is_error <- inherits(cond, "error")
[16:12:26.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.825]                   NULL)
[16:12:26.825]                 if (is_error) {
[16:12:26.825]                   sessionInformation <- function() {
[16:12:26.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.825]                       search = base::search(), system = base::Sys.info())
[16:12:26.825]                   }
[16:12:26.825]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.825]                     cond$call), session = sessionInformation(), 
[16:12:26.825]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.825]                   signalCondition(cond)
[16:12:26.825]                 }
[16:12:26.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.825]                 "immediateCondition"))) {
[16:12:26.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.825]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.825]                   if (TRUE && !signal) {
[16:12:26.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.825]                     {
[16:12:26.825]                       inherits <- base::inherits
[16:12:26.825]                       invokeRestart <- base::invokeRestart
[16:12:26.825]                       is.null <- base::is.null
[16:12:26.825]                       muffled <- FALSE
[16:12:26.825]                       if (inherits(cond, "message")) {
[16:12:26.825]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.825]                         if (muffled) 
[16:12:26.825]                           invokeRestart("muffleMessage")
[16:12:26.825]                       }
[16:12:26.825]                       else if (inherits(cond, "warning")) {
[16:12:26.825]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.825]                         if (muffled) 
[16:12:26.825]                           invokeRestart("muffleWarning")
[16:12:26.825]                       }
[16:12:26.825]                       else if (inherits(cond, "condition")) {
[16:12:26.825]                         if (!is.null(pattern)) {
[16:12:26.825]                           computeRestarts <- base::computeRestarts
[16:12:26.825]                           grepl <- base::grepl
[16:12:26.825]                           restarts <- computeRestarts(cond)
[16:12:26.825]                           for (restart in restarts) {
[16:12:26.825]                             name <- restart$name
[16:12:26.825]                             if (is.null(name)) 
[16:12:26.825]                               next
[16:12:26.825]                             if (!grepl(pattern, name)) 
[16:12:26.825]                               next
[16:12:26.825]                             invokeRestart(restart)
[16:12:26.825]                             muffled <- TRUE
[16:12:26.825]                             break
[16:12:26.825]                           }
[16:12:26.825]                         }
[16:12:26.825]                       }
[16:12:26.825]                       invisible(muffled)
[16:12:26.825]                     }
[16:12:26.825]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.825]                   }
[16:12:26.825]                 }
[16:12:26.825]                 else {
[16:12:26.825]                   if (TRUE) {
[16:12:26.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.825]                     {
[16:12:26.825]                       inherits <- base::inherits
[16:12:26.825]                       invokeRestart <- base::invokeRestart
[16:12:26.825]                       is.null <- base::is.null
[16:12:26.825]                       muffled <- FALSE
[16:12:26.825]                       if (inherits(cond, "message")) {
[16:12:26.825]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.825]                         if (muffled) 
[16:12:26.825]                           invokeRestart("muffleMessage")
[16:12:26.825]                       }
[16:12:26.825]                       else if (inherits(cond, "warning")) {
[16:12:26.825]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.825]                         if (muffled) 
[16:12:26.825]                           invokeRestart("muffleWarning")
[16:12:26.825]                       }
[16:12:26.825]                       else if (inherits(cond, "condition")) {
[16:12:26.825]                         if (!is.null(pattern)) {
[16:12:26.825]                           computeRestarts <- base::computeRestarts
[16:12:26.825]                           grepl <- base::grepl
[16:12:26.825]                           restarts <- computeRestarts(cond)
[16:12:26.825]                           for (restart in restarts) {
[16:12:26.825]                             name <- restart$name
[16:12:26.825]                             if (is.null(name)) 
[16:12:26.825]                               next
[16:12:26.825]                             if (!grepl(pattern, name)) 
[16:12:26.825]                               next
[16:12:26.825]                             invokeRestart(restart)
[16:12:26.825]                             muffled <- TRUE
[16:12:26.825]                             break
[16:12:26.825]                           }
[16:12:26.825]                         }
[16:12:26.825]                       }
[16:12:26.825]                       invisible(muffled)
[16:12:26.825]                     }
[16:12:26.825]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.825]                   }
[16:12:26.825]                 }
[16:12:26.825]             }
[16:12:26.825]         }))
[16:12:26.825]     }, error = function(ex) {
[16:12:26.825]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.825]                 ...future.rng), started = ...future.startTime, 
[16:12:26.825]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.825]             version = "1.8"), class = "FutureResult")
[16:12:26.825]     }, finally = {
[16:12:26.825]         if (!identical(...future.workdir, getwd())) 
[16:12:26.825]             setwd(...future.workdir)
[16:12:26.825]         {
[16:12:26.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.825]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.825]             }
[16:12:26.825]             base::options(...future.oldOptions)
[16:12:26.825]             if (.Platform$OS.type == "windows") {
[16:12:26.825]                 old_names <- names(...future.oldEnvVars)
[16:12:26.825]                 envs <- base::Sys.getenv()
[16:12:26.825]                 names <- names(envs)
[16:12:26.825]                 common <- intersect(names, old_names)
[16:12:26.825]                 added <- setdiff(names, old_names)
[16:12:26.825]                 removed <- setdiff(old_names, names)
[16:12:26.825]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.825]                   envs[common]]
[16:12:26.825]                 NAMES <- toupper(changed)
[16:12:26.825]                 args <- list()
[16:12:26.825]                 for (kk in seq_along(NAMES)) {
[16:12:26.825]                   name <- changed[[kk]]
[16:12:26.825]                   NAME <- NAMES[[kk]]
[16:12:26.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.825]                     next
[16:12:26.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.825]                 }
[16:12:26.825]                 NAMES <- toupper(added)
[16:12:26.825]                 for (kk in seq_along(NAMES)) {
[16:12:26.825]                   name <- added[[kk]]
[16:12:26.825]                   NAME <- NAMES[[kk]]
[16:12:26.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.825]                     next
[16:12:26.825]                   args[[name]] <- ""
[16:12:26.825]                 }
[16:12:26.825]                 NAMES <- toupper(removed)
[16:12:26.825]                 for (kk in seq_along(NAMES)) {
[16:12:26.825]                   name <- removed[[kk]]
[16:12:26.825]                   NAME <- NAMES[[kk]]
[16:12:26.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.825]                     next
[16:12:26.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.825]                 }
[16:12:26.825]                 if (length(args) > 0) 
[16:12:26.825]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.825]             }
[16:12:26.825]             else {
[16:12:26.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.825]             }
[16:12:26.825]             {
[16:12:26.825]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.825]                   0L) {
[16:12:26.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.825]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.825]                   base::options(opts)
[16:12:26.825]                 }
[16:12:26.825]                 {
[16:12:26.825]                   {
[16:12:26.825]                     NULL
[16:12:26.825]                     RNGkind("Mersenne-Twister")
[16:12:26.825]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.825]                       inherits = FALSE)
[16:12:26.825]                   }
[16:12:26.825]                   options(future.plan = NULL)
[16:12:26.825]                   if (is.na(NA_character_)) 
[16:12:26.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.825]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.825]                   {
[16:12:26.825]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.825]                     if (!future$lazy) 
[16:12:26.825]                       future <- run(future)
[16:12:26.825]                     invisible(future)
[16:12:26.825]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.825]                 }
[16:12:26.825]             }
[16:12:26.825]         }
[16:12:26.825]     })
[16:12:26.825]     if (TRUE) {
[16:12:26.825]         base::sink(type = "output", split = FALSE)
[16:12:26.825]         if (TRUE) {
[16:12:26.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.825]         }
[16:12:26.825]         else {
[16:12:26.825]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.825]         }
[16:12:26.825]         base::close(...future.stdout)
[16:12:26.825]         ...future.stdout <- NULL
[16:12:26.825]     }
[16:12:26.825]     ...future.result$conditions <- ...future.conditions
[16:12:26.825]     ...future.result$finished <- base::Sys.time()
[16:12:26.825]     ...future.result
[16:12:26.825] }
[16:12:26.827] plan(): Setting new future strategy stack:
[16:12:26.827] List of future strategies:
[16:12:26.827] 1. sequential:
[16:12:26.827]    - args: function (..., envir = parent.frame())
[16:12:26.827]    - tweaked: FALSE
[16:12:26.827]    - call: NULL
[16:12:26.827] plan(): nbrOfWorkers() = 1
[16:12:26.828] plan(): Setting new future strategy stack:
[16:12:26.828] List of future strategies:
[16:12:26.828] 1. sequential:
[16:12:26.828]    - args: function (..., envir = parent.frame())
[16:12:26.828]    - tweaked: FALSE
[16:12:26.828]    - call: plan(strategy)
[16:12:26.828] plan(): nbrOfWorkers() = 1
[16:12:26.829] SequentialFuture started (and completed)
[16:12:26.829] - Launch lazy future ... done
[16:12:26.829] run() for ‘SequentialFuture’ ... done
[16:12:26.829] getGlobalsAndPackages() ...
[16:12:26.829] Searching for globals...
[16:12:26.830] - globals found: [1] ‘{’
[16:12:26.830] Searching for globals ... DONE
[16:12:26.830] Resolving globals: FALSE
[16:12:26.830] 
[16:12:26.830] 
[16:12:26.830] getGlobalsAndPackages() ... DONE
[16:12:26.831] run() for ‘Future’ ...
[16:12:26.831] - state: ‘created’
[16:12:26.831] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.831] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.831]   - Field: ‘label’
[16:12:26.831]   - Field: ‘local’
[16:12:26.831]   - Field: ‘owner’
[16:12:26.832]   - Field: ‘envir’
[16:12:26.832]   - Field: ‘packages’
[16:12:26.832]   - Field: ‘gc’
[16:12:26.832]   - Field: ‘conditions’
[16:12:26.832]   - Field: ‘expr’
[16:12:26.832]   - Field: ‘uuid’
[16:12:26.833]   - Field: ‘seed’
[16:12:26.833]   - Field: ‘version’
[16:12:26.833]   - Field: ‘result’
[16:12:26.833]   - Field: ‘asynchronous’
[16:12:26.833]   - Field: ‘calls’
[16:12:26.834]   - Field: ‘globals’
[16:12:26.834]   - Field: ‘stdout’
[16:12:26.834]   - Field: ‘earlySignal’
[16:12:26.834]   - Field: ‘lazy’
[16:12:26.834]   - Field: ‘state’
[16:12:26.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.834] - Launch lazy future ...
[16:12:26.834] Packages needed by the future expression (n = 0): <none>
[16:12:26.834] Packages needed by future strategies (n = 0): <none>
[16:12:26.835] {
[16:12:26.835]     {
[16:12:26.835]         {
[16:12:26.835]             ...future.startTime <- base::Sys.time()
[16:12:26.835]             {
[16:12:26.835]                 {
[16:12:26.835]                   {
[16:12:26.835]                     base::local({
[16:12:26.835]                       has_future <- base::requireNamespace("future", 
[16:12:26.835]                         quietly = TRUE)
[16:12:26.835]                       if (has_future) {
[16:12:26.835]                         ns <- base::getNamespace("future")
[16:12:26.835]                         version <- ns[[".package"]][["version"]]
[16:12:26.835]                         if (is.null(version)) 
[16:12:26.835]                           version <- utils::packageVersion("future")
[16:12:26.835]                       }
[16:12:26.835]                       else {
[16:12:26.835]                         version <- NULL
[16:12:26.835]                       }
[16:12:26.835]                       if (!has_future || version < "1.8.0") {
[16:12:26.835]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.835]                           "", base::R.version$version.string), 
[16:12:26.835]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.835]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.835]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.835]                             "release", "version")], collapse = " "), 
[16:12:26.835]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.835]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.835]                           info)
[16:12:26.835]                         info <- base::paste(info, collapse = "; ")
[16:12:26.835]                         if (!has_future) {
[16:12:26.835]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.835]                             info)
[16:12:26.835]                         }
[16:12:26.835]                         else {
[16:12:26.835]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.835]                             info, version)
[16:12:26.835]                         }
[16:12:26.835]                         base::stop(msg)
[16:12:26.835]                       }
[16:12:26.835]                     })
[16:12:26.835]                   }
[16:12:26.835]                   options(future.plan = NULL)
[16:12:26.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.835]                 }
[16:12:26.835]                 ...future.workdir <- getwd()
[16:12:26.835]             }
[16:12:26.835]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.835]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.835]         }
[16:12:26.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.835]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.835]             base::names(...future.oldOptions))
[16:12:26.835]     }
[16:12:26.835]     if (FALSE) {
[16:12:26.835]     }
[16:12:26.835]     else {
[16:12:26.835]         if (TRUE) {
[16:12:26.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.835]                 open = "w")
[16:12:26.835]         }
[16:12:26.835]         else {
[16:12:26.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.835]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.835]         }
[16:12:26.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.835]             base::sink(type = "output", split = FALSE)
[16:12:26.835]             base::close(...future.stdout)
[16:12:26.835]         }, add = TRUE)
[16:12:26.835]     }
[16:12:26.835]     ...future.frame <- base::sys.nframe()
[16:12:26.835]     ...future.conditions <- base::list()
[16:12:26.835]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.835]     if (FALSE) {
[16:12:26.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.835]     }
[16:12:26.835]     ...future.result <- base::tryCatch({
[16:12:26.835]         base::withCallingHandlers({
[16:12:26.835]             ...future.value <- base::withVisible(base::local({
[16:12:26.835]                 4
[16:12:26.835]             }))
[16:12:26.835]             future::FutureResult(value = ...future.value$value, 
[16:12:26.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.835]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.835]                     ...future.globalenv.names))
[16:12:26.835]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.835]         }, condition = base::local({
[16:12:26.835]             c <- base::c
[16:12:26.835]             inherits <- base::inherits
[16:12:26.835]             invokeRestart <- base::invokeRestart
[16:12:26.835]             length <- base::length
[16:12:26.835]             list <- base::list
[16:12:26.835]             seq.int <- base::seq.int
[16:12:26.835]             signalCondition <- base::signalCondition
[16:12:26.835]             sys.calls <- base::sys.calls
[16:12:26.835]             `[[` <- base::`[[`
[16:12:26.835]             `+` <- base::`+`
[16:12:26.835]             `<<-` <- base::`<<-`
[16:12:26.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.835]                   3L)]
[16:12:26.835]             }
[16:12:26.835]             function(cond) {
[16:12:26.835]                 is_error <- inherits(cond, "error")
[16:12:26.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.835]                   NULL)
[16:12:26.835]                 if (is_error) {
[16:12:26.835]                   sessionInformation <- function() {
[16:12:26.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.835]                       search = base::search(), system = base::Sys.info())
[16:12:26.835]                   }
[16:12:26.835]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.835]                     cond$call), session = sessionInformation(), 
[16:12:26.835]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.835]                   signalCondition(cond)
[16:12:26.835]                 }
[16:12:26.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.835]                 "immediateCondition"))) {
[16:12:26.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.835]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.835]                   if (TRUE && !signal) {
[16:12:26.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.835]                     {
[16:12:26.835]                       inherits <- base::inherits
[16:12:26.835]                       invokeRestart <- base::invokeRestart
[16:12:26.835]                       is.null <- base::is.null
[16:12:26.835]                       muffled <- FALSE
[16:12:26.835]                       if (inherits(cond, "message")) {
[16:12:26.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.835]                         if (muffled) 
[16:12:26.835]                           invokeRestart("muffleMessage")
[16:12:26.835]                       }
[16:12:26.835]                       else if (inherits(cond, "warning")) {
[16:12:26.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.835]                         if (muffled) 
[16:12:26.835]                           invokeRestart("muffleWarning")
[16:12:26.835]                       }
[16:12:26.835]                       else if (inherits(cond, "condition")) {
[16:12:26.835]                         if (!is.null(pattern)) {
[16:12:26.835]                           computeRestarts <- base::computeRestarts
[16:12:26.835]                           grepl <- base::grepl
[16:12:26.835]                           restarts <- computeRestarts(cond)
[16:12:26.835]                           for (restart in restarts) {
[16:12:26.835]                             name <- restart$name
[16:12:26.835]                             if (is.null(name)) 
[16:12:26.835]                               next
[16:12:26.835]                             if (!grepl(pattern, name)) 
[16:12:26.835]                               next
[16:12:26.835]                             invokeRestart(restart)
[16:12:26.835]                             muffled <- TRUE
[16:12:26.835]                             break
[16:12:26.835]                           }
[16:12:26.835]                         }
[16:12:26.835]                       }
[16:12:26.835]                       invisible(muffled)
[16:12:26.835]                     }
[16:12:26.835]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.835]                   }
[16:12:26.835]                 }
[16:12:26.835]                 else {
[16:12:26.835]                   if (TRUE) {
[16:12:26.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.835]                     {
[16:12:26.835]                       inherits <- base::inherits
[16:12:26.835]                       invokeRestart <- base::invokeRestart
[16:12:26.835]                       is.null <- base::is.null
[16:12:26.835]                       muffled <- FALSE
[16:12:26.835]                       if (inherits(cond, "message")) {
[16:12:26.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.835]                         if (muffled) 
[16:12:26.835]                           invokeRestart("muffleMessage")
[16:12:26.835]                       }
[16:12:26.835]                       else if (inherits(cond, "warning")) {
[16:12:26.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.835]                         if (muffled) 
[16:12:26.835]                           invokeRestart("muffleWarning")
[16:12:26.835]                       }
[16:12:26.835]                       else if (inherits(cond, "condition")) {
[16:12:26.835]                         if (!is.null(pattern)) {
[16:12:26.835]                           computeRestarts <- base::computeRestarts
[16:12:26.835]                           grepl <- base::grepl
[16:12:26.835]                           restarts <- computeRestarts(cond)
[16:12:26.835]                           for (restart in restarts) {
[16:12:26.835]                             name <- restart$name
[16:12:26.835]                             if (is.null(name)) 
[16:12:26.835]                               next
[16:12:26.835]                             if (!grepl(pattern, name)) 
[16:12:26.835]                               next
[16:12:26.835]                             invokeRestart(restart)
[16:12:26.835]                             muffled <- TRUE
[16:12:26.835]                             break
[16:12:26.835]                           }
[16:12:26.835]                         }
[16:12:26.835]                       }
[16:12:26.835]                       invisible(muffled)
[16:12:26.835]                     }
[16:12:26.835]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.835]                   }
[16:12:26.835]                 }
[16:12:26.835]             }
[16:12:26.835]         }))
[16:12:26.835]     }, error = function(ex) {
[16:12:26.835]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.835]                 ...future.rng), started = ...future.startTime, 
[16:12:26.835]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.835]             version = "1.8"), class = "FutureResult")
[16:12:26.835]     }, finally = {
[16:12:26.835]         if (!identical(...future.workdir, getwd())) 
[16:12:26.835]             setwd(...future.workdir)
[16:12:26.835]         {
[16:12:26.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.835]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.835]             }
[16:12:26.835]             base::options(...future.oldOptions)
[16:12:26.835]             if (.Platform$OS.type == "windows") {
[16:12:26.835]                 old_names <- names(...future.oldEnvVars)
[16:12:26.835]                 envs <- base::Sys.getenv()
[16:12:26.835]                 names <- names(envs)
[16:12:26.835]                 common <- intersect(names, old_names)
[16:12:26.835]                 added <- setdiff(names, old_names)
[16:12:26.835]                 removed <- setdiff(old_names, names)
[16:12:26.835]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.835]                   envs[common]]
[16:12:26.835]                 NAMES <- toupper(changed)
[16:12:26.835]                 args <- list()
[16:12:26.835]                 for (kk in seq_along(NAMES)) {
[16:12:26.835]                   name <- changed[[kk]]
[16:12:26.835]                   NAME <- NAMES[[kk]]
[16:12:26.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.835]                     next
[16:12:26.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.835]                 }
[16:12:26.835]                 NAMES <- toupper(added)
[16:12:26.835]                 for (kk in seq_along(NAMES)) {
[16:12:26.835]                   name <- added[[kk]]
[16:12:26.835]                   NAME <- NAMES[[kk]]
[16:12:26.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.835]                     next
[16:12:26.835]                   args[[name]] <- ""
[16:12:26.835]                 }
[16:12:26.835]                 NAMES <- toupper(removed)
[16:12:26.835]                 for (kk in seq_along(NAMES)) {
[16:12:26.835]                   name <- removed[[kk]]
[16:12:26.835]                   NAME <- NAMES[[kk]]
[16:12:26.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.835]                     next
[16:12:26.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.835]                 }
[16:12:26.835]                 if (length(args) > 0) 
[16:12:26.835]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.835]             }
[16:12:26.835]             else {
[16:12:26.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.835]             }
[16:12:26.835]             {
[16:12:26.835]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.835]                   0L) {
[16:12:26.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.835]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.835]                   base::options(opts)
[16:12:26.835]                 }
[16:12:26.835]                 {
[16:12:26.835]                   {
[16:12:26.835]                     NULL
[16:12:26.835]                     RNGkind("Mersenne-Twister")
[16:12:26.835]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.835]                       inherits = FALSE)
[16:12:26.835]                   }
[16:12:26.835]                   options(future.plan = NULL)
[16:12:26.835]                   if (is.na(NA_character_)) 
[16:12:26.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.835]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.835]                   {
[16:12:26.835]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.835]                     if (!future$lazy) 
[16:12:26.835]                       future <- run(future)
[16:12:26.835]                     invisible(future)
[16:12:26.835]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.835]                 }
[16:12:26.835]             }
[16:12:26.835]         }
[16:12:26.835]     })
[16:12:26.835]     if (TRUE) {
[16:12:26.835]         base::sink(type = "output", split = FALSE)
[16:12:26.835]         if (TRUE) {
[16:12:26.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.835]         }
[16:12:26.835]         else {
[16:12:26.835]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.835]         }
[16:12:26.835]         base::close(...future.stdout)
[16:12:26.835]         ...future.stdout <- NULL
[16:12:26.835]     }
[16:12:26.835]     ...future.result$conditions <- ...future.conditions
[16:12:26.835]     ...future.result$finished <- base::Sys.time()
[16:12:26.835]     ...future.result
[16:12:26.835] }
[16:12:26.836] plan(): Setting new future strategy stack:
[16:12:26.837] List of future strategies:
[16:12:26.837] 1. sequential:
[16:12:26.837]    - args: function (..., envir = parent.frame())
[16:12:26.837]    - tweaked: FALSE
[16:12:26.837]    - call: NULL
[16:12:26.837] plan(): nbrOfWorkers() = 1
[16:12:26.838] plan(): Setting new future strategy stack:
[16:12:26.838] List of future strategies:
[16:12:26.838] 1. sequential:
[16:12:26.838]    - args: function (..., envir = parent.frame())
[16:12:26.838]    - tweaked: FALSE
[16:12:26.838]    - call: plan(strategy)
[16:12:26.838] plan(): nbrOfWorkers() = 1
[16:12:26.838] SequentialFuture started (and completed)
[16:12:26.838] - Launch lazy future ... done
[16:12:26.838] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560baca68408> 
Classes 'listenv', 'environment' <environment: 0x560bad213358> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:26.842] resolved() for ‘SequentialFuture’ ...
[16:12:26.842] - state: ‘finished’
[16:12:26.842] - run: TRUE
[16:12:26.842] - result: ‘FutureResult’
[16:12:26.842] resolved() for ‘SequentialFuture’ ... done
[16:12:26.843] resolved() for ‘SequentialFuture’ ...
[16:12:26.843] - state: ‘finished’
[16:12:26.843] - run: TRUE
[16:12:26.843] - result: ‘FutureResult’
[16:12:26.843] resolved() for ‘SequentialFuture’ ... done
[16:12:26.843] resolved() for ‘SequentialFuture’ ...
[16:12:26.843] - state: ‘finished’
[16:12:26.843] - run: TRUE
[16:12:26.843] - result: ‘FutureResult’
[16:12:26.843] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:26.846] resolve() on list environment ...
[16:12:26.846]  recursive: 0
[16:12:26.847]  length: 6
[16:12:26.847]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:26.847] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.847] - nx: 6
[16:12:26.847] - relay: TRUE
[16:12:26.847] - stdout: TRUE
[16:12:26.847] - signal: TRUE
[16:12:26.847] - resignal: FALSE
[16:12:26.847] - force: TRUE
[16:12:26.847] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.848] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.848]  - until=2
[16:12:26.848]  - relaying element #2
[16:12:26.848] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.848] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.848] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.848]  length: 5 (resolved future 1)
[16:12:26.848] resolved() for ‘SequentialFuture’ ...
[16:12:26.848] - state: ‘finished’
[16:12:26.848] - run: TRUE
[16:12:26.848] - result: ‘FutureResult’
[16:12:26.849] resolved() for ‘SequentialFuture’ ... done
[16:12:26.849] Future #2
[16:12:26.849] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.849] - nx: 6
[16:12:26.849] - relay: TRUE
[16:12:26.849] - stdout: TRUE
[16:12:26.849] - signal: TRUE
[16:12:26.849] - resignal: FALSE
[16:12:26.849] - force: TRUE
[16:12:26.849] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.849] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.850]  - until=2
[16:12:26.850]  - relaying element #2
[16:12:26.850] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.850] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.850] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.850]  length: 4 (resolved future 2)
[16:12:26.850] resolved() for ‘SequentialFuture’ ...
[16:12:26.850] - state: ‘finished’
[16:12:26.850] - run: TRUE
[16:12:26.850] - result: ‘FutureResult’
[16:12:26.851] resolved() for ‘SequentialFuture’ ... done
[16:12:26.851] Future #3
[16:12:26.851] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.851] - nx: 6
[16:12:26.851] - relay: TRUE
[16:12:26.851] - stdout: TRUE
[16:12:26.851] - signal: TRUE
[16:12:26.851] - resignal: FALSE
[16:12:26.851] - force: TRUE
[16:12:26.851] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.851] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.852]  - until=3
[16:12:26.852]  - relaying element #3
[16:12:26.852] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.852] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.852] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.852]  length: 3 (resolved future 3)
[16:12:26.852] resolved() for ‘SequentialFuture’ ...
[16:12:26.852] - state: ‘finished’
[16:12:26.852] - run: TRUE
[16:12:26.853] - result: ‘FutureResult’
[16:12:26.853] resolved() for ‘SequentialFuture’ ... done
[16:12:26.853] Future #4
[16:12:26.853] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.853] - nx: 6
[16:12:26.853] - relay: TRUE
[16:12:26.853] - stdout: TRUE
[16:12:26.853] - signal: TRUE
[16:12:26.853] - resignal: FALSE
[16:12:26.853] - force: TRUE
[16:12:26.853] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.853] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.854]  - until=4
[16:12:26.854]  - relaying element #4
[16:12:26.854] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.854] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.854] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.854]  length: 2 (resolved future 4)
[16:12:26.854] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.854] - nx: 6
[16:12:26.854] - relay: TRUE
[16:12:26.854] - stdout: TRUE
[16:12:26.855] - signal: TRUE
[16:12:26.855] - resignal: FALSE
[16:12:26.855] - force: TRUE
[16:12:26.855] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.855] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.855]  - until=6
[16:12:26.855]  - relaying element #6
[16:12:26.855] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.855] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.855] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.855]  length: 1 (resolved future 5)
[16:12:26.855] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.856] - nx: 6
[16:12:26.856] - relay: TRUE
[16:12:26.856] - stdout: TRUE
[16:12:26.856] - signal: TRUE
[16:12:26.856] - resignal: FALSE
[16:12:26.856] - force: TRUE
[16:12:26.856] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.856] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.856]  - until=6
[16:12:26.856] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.856] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.857] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.858]  length: 0 (resolved future 6)
[16:12:26.858] Relaying remaining futures
[16:12:26.858] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.858] - nx: 6
[16:12:26.858] - relay: TRUE
[16:12:26.858] - stdout: TRUE
[16:12:26.858] - signal: TRUE
[16:12:26.858] - resignal: FALSE
[16:12:26.858] - force: TRUE
[16:12:26.858] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.858] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:26.859] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.859] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.859] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.859] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bae6ca9f0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:12:26.861] getGlobalsAndPackages() ...
[16:12:26.861] Searching for globals...
[16:12:26.861] 
[16:12:26.861] Searching for globals ... DONE
[16:12:26.861] - globals: [0] <none>
[16:12:26.862] getGlobalsAndPackages() ... DONE
[16:12:26.862] run() for ‘Future’ ...
[16:12:26.862] - state: ‘created’
[16:12:26.862] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.862] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.862]   - Field: ‘label’
[16:12:26.863]   - Field: ‘local’
[16:12:26.863]   - Field: ‘owner’
[16:12:26.863]   - Field: ‘envir’
[16:12:26.863]   - Field: ‘packages’
[16:12:26.863]   - Field: ‘gc’
[16:12:26.863]   - Field: ‘conditions’
[16:12:26.863]   - Field: ‘expr’
[16:12:26.863]   - Field: ‘uuid’
[16:12:26.863]   - Field: ‘seed’
[16:12:26.863]   - Field: ‘version’
[16:12:26.863]   - Field: ‘result’
[16:12:26.864]   - Field: ‘asynchronous’
[16:12:26.864]   - Field: ‘calls’
[16:12:26.864]   - Field: ‘globals’
[16:12:26.864]   - Field: ‘stdout’
[16:12:26.864]   - Field: ‘earlySignal’
[16:12:26.864]   - Field: ‘lazy’
[16:12:26.864]   - Field: ‘state’
[16:12:26.864] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.864] - Launch lazy future ...
[16:12:26.864] Packages needed by the future expression (n = 0): <none>
[16:12:26.865] Packages needed by future strategies (n = 0): <none>
[16:12:26.865] {
[16:12:26.865]     {
[16:12:26.865]         {
[16:12:26.865]             ...future.startTime <- base::Sys.time()
[16:12:26.865]             {
[16:12:26.865]                 {
[16:12:26.865]                   {
[16:12:26.865]                     base::local({
[16:12:26.865]                       has_future <- base::requireNamespace("future", 
[16:12:26.865]                         quietly = TRUE)
[16:12:26.865]                       if (has_future) {
[16:12:26.865]                         ns <- base::getNamespace("future")
[16:12:26.865]                         version <- ns[[".package"]][["version"]]
[16:12:26.865]                         if (is.null(version)) 
[16:12:26.865]                           version <- utils::packageVersion("future")
[16:12:26.865]                       }
[16:12:26.865]                       else {
[16:12:26.865]                         version <- NULL
[16:12:26.865]                       }
[16:12:26.865]                       if (!has_future || version < "1.8.0") {
[16:12:26.865]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.865]                           "", base::R.version$version.string), 
[16:12:26.865]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.865]                             "release", "version")], collapse = " "), 
[16:12:26.865]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.865]                           info)
[16:12:26.865]                         info <- base::paste(info, collapse = "; ")
[16:12:26.865]                         if (!has_future) {
[16:12:26.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.865]                             info)
[16:12:26.865]                         }
[16:12:26.865]                         else {
[16:12:26.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.865]                             info, version)
[16:12:26.865]                         }
[16:12:26.865]                         base::stop(msg)
[16:12:26.865]                       }
[16:12:26.865]                     })
[16:12:26.865]                   }
[16:12:26.865]                   options(future.plan = NULL)
[16:12:26.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.865]                 }
[16:12:26.865]                 ...future.workdir <- getwd()
[16:12:26.865]             }
[16:12:26.865]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.865]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.865]         }
[16:12:26.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.865]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.865]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.865]             base::names(...future.oldOptions))
[16:12:26.865]     }
[16:12:26.865]     if (FALSE) {
[16:12:26.865]     }
[16:12:26.865]     else {
[16:12:26.865]         if (TRUE) {
[16:12:26.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.865]                 open = "w")
[16:12:26.865]         }
[16:12:26.865]         else {
[16:12:26.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.865]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.865]         }
[16:12:26.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.865]             base::sink(type = "output", split = FALSE)
[16:12:26.865]             base::close(...future.stdout)
[16:12:26.865]         }, add = TRUE)
[16:12:26.865]     }
[16:12:26.865]     ...future.frame <- base::sys.nframe()
[16:12:26.865]     ...future.conditions <- base::list()
[16:12:26.865]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.865]     if (FALSE) {
[16:12:26.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.865]     }
[16:12:26.865]     ...future.result <- base::tryCatch({
[16:12:26.865]         base::withCallingHandlers({
[16:12:26.865]             ...future.value <- base::withVisible(base::local(2))
[16:12:26.865]             future::FutureResult(value = ...future.value$value, 
[16:12:26.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.865]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.865]                     ...future.globalenv.names))
[16:12:26.865]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.865]         }, condition = base::local({
[16:12:26.865]             c <- base::c
[16:12:26.865]             inherits <- base::inherits
[16:12:26.865]             invokeRestart <- base::invokeRestart
[16:12:26.865]             length <- base::length
[16:12:26.865]             list <- base::list
[16:12:26.865]             seq.int <- base::seq.int
[16:12:26.865]             signalCondition <- base::signalCondition
[16:12:26.865]             sys.calls <- base::sys.calls
[16:12:26.865]             `[[` <- base::`[[`
[16:12:26.865]             `+` <- base::`+`
[16:12:26.865]             `<<-` <- base::`<<-`
[16:12:26.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.865]                   3L)]
[16:12:26.865]             }
[16:12:26.865]             function(cond) {
[16:12:26.865]                 is_error <- inherits(cond, "error")
[16:12:26.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.865]                   NULL)
[16:12:26.865]                 if (is_error) {
[16:12:26.865]                   sessionInformation <- function() {
[16:12:26.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.865]                       search = base::search(), system = base::Sys.info())
[16:12:26.865]                   }
[16:12:26.865]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.865]                     cond$call), session = sessionInformation(), 
[16:12:26.865]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.865]                   signalCondition(cond)
[16:12:26.865]                 }
[16:12:26.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.865]                 "immediateCondition"))) {
[16:12:26.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.865]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.865]                   if (TRUE && !signal) {
[16:12:26.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.865]                     {
[16:12:26.865]                       inherits <- base::inherits
[16:12:26.865]                       invokeRestart <- base::invokeRestart
[16:12:26.865]                       is.null <- base::is.null
[16:12:26.865]                       muffled <- FALSE
[16:12:26.865]                       if (inherits(cond, "message")) {
[16:12:26.865]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.865]                         if (muffled) 
[16:12:26.865]                           invokeRestart("muffleMessage")
[16:12:26.865]                       }
[16:12:26.865]                       else if (inherits(cond, "warning")) {
[16:12:26.865]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.865]                         if (muffled) 
[16:12:26.865]                           invokeRestart("muffleWarning")
[16:12:26.865]                       }
[16:12:26.865]                       else if (inherits(cond, "condition")) {
[16:12:26.865]                         if (!is.null(pattern)) {
[16:12:26.865]                           computeRestarts <- base::computeRestarts
[16:12:26.865]                           grepl <- base::grepl
[16:12:26.865]                           restarts <- computeRestarts(cond)
[16:12:26.865]                           for (restart in restarts) {
[16:12:26.865]                             name <- restart$name
[16:12:26.865]                             if (is.null(name)) 
[16:12:26.865]                               next
[16:12:26.865]                             if (!grepl(pattern, name)) 
[16:12:26.865]                               next
[16:12:26.865]                             invokeRestart(restart)
[16:12:26.865]                             muffled <- TRUE
[16:12:26.865]                             break
[16:12:26.865]                           }
[16:12:26.865]                         }
[16:12:26.865]                       }
[16:12:26.865]                       invisible(muffled)
[16:12:26.865]                     }
[16:12:26.865]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.865]                   }
[16:12:26.865]                 }
[16:12:26.865]                 else {
[16:12:26.865]                   if (TRUE) {
[16:12:26.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.865]                     {
[16:12:26.865]                       inherits <- base::inherits
[16:12:26.865]                       invokeRestart <- base::invokeRestart
[16:12:26.865]                       is.null <- base::is.null
[16:12:26.865]                       muffled <- FALSE
[16:12:26.865]                       if (inherits(cond, "message")) {
[16:12:26.865]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.865]                         if (muffled) 
[16:12:26.865]                           invokeRestart("muffleMessage")
[16:12:26.865]                       }
[16:12:26.865]                       else if (inherits(cond, "warning")) {
[16:12:26.865]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.865]                         if (muffled) 
[16:12:26.865]                           invokeRestart("muffleWarning")
[16:12:26.865]                       }
[16:12:26.865]                       else if (inherits(cond, "condition")) {
[16:12:26.865]                         if (!is.null(pattern)) {
[16:12:26.865]                           computeRestarts <- base::computeRestarts
[16:12:26.865]                           grepl <- base::grepl
[16:12:26.865]                           restarts <- computeRestarts(cond)
[16:12:26.865]                           for (restart in restarts) {
[16:12:26.865]                             name <- restart$name
[16:12:26.865]                             if (is.null(name)) 
[16:12:26.865]                               next
[16:12:26.865]                             if (!grepl(pattern, name)) 
[16:12:26.865]                               next
[16:12:26.865]                             invokeRestart(restart)
[16:12:26.865]                             muffled <- TRUE
[16:12:26.865]                             break
[16:12:26.865]                           }
[16:12:26.865]                         }
[16:12:26.865]                       }
[16:12:26.865]                       invisible(muffled)
[16:12:26.865]                     }
[16:12:26.865]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.865]                   }
[16:12:26.865]                 }
[16:12:26.865]             }
[16:12:26.865]         }))
[16:12:26.865]     }, error = function(ex) {
[16:12:26.865]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.865]                 ...future.rng), started = ...future.startTime, 
[16:12:26.865]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.865]             version = "1.8"), class = "FutureResult")
[16:12:26.865]     }, finally = {
[16:12:26.865]         if (!identical(...future.workdir, getwd())) 
[16:12:26.865]             setwd(...future.workdir)
[16:12:26.865]         {
[16:12:26.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.865]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.865]             }
[16:12:26.865]             base::options(...future.oldOptions)
[16:12:26.865]             if (.Platform$OS.type == "windows") {
[16:12:26.865]                 old_names <- names(...future.oldEnvVars)
[16:12:26.865]                 envs <- base::Sys.getenv()
[16:12:26.865]                 names <- names(envs)
[16:12:26.865]                 common <- intersect(names, old_names)
[16:12:26.865]                 added <- setdiff(names, old_names)
[16:12:26.865]                 removed <- setdiff(old_names, names)
[16:12:26.865]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.865]                   envs[common]]
[16:12:26.865]                 NAMES <- toupper(changed)
[16:12:26.865]                 args <- list()
[16:12:26.865]                 for (kk in seq_along(NAMES)) {
[16:12:26.865]                   name <- changed[[kk]]
[16:12:26.865]                   NAME <- NAMES[[kk]]
[16:12:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.865]                     next
[16:12:26.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.865]                 }
[16:12:26.865]                 NAMES <- toupper(added)
[16:12:26.865]                 for (kk in seq_along(NAMES)) {
[16:12:26.865]                   name <- added[[kk]]
[16:12:26.865]                   NAME <- NAMES[[kk]]
[16:12:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.865]                     next
[16:12:26.865]                   args[[name]] <- ""
[16:12:26.865]                 }
[16:12:26.865]                 NAMES <- toupper(removed)
[16:12:26.865]                 for (kk in seq_along(NAMES)) {
[16:12:26.865]                   name <- removed[[kk]]
[16:12:26.865]                   NAME <- NAMES[[kk]]
[16:12:26.865]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.865]                     next
[16:12:26.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.865]                 }
[16:12:26.865]                 if (length(args) > 0) 
[16:12:26.865]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.865]             }
[16:12:26.865]             else {
[16:12:26.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.865]             }
[16:12:26.865]             {
[16:12:26.865]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.865]                   0L) {
[16:12:26.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.865]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.865]                   base::options(opts)
[16:12:26.865]                 }
[16:12:26.865]                 {
[16:12:26.865]                   {
[16:12:26.865]                     NULL
[16:12:26.865]                     RNGkind("Mersenne-Twister")
[16:12:26.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.865]                       inherits = FALSE)
[16:12:26.865]                   }
[16:12:26.865]                   options(future.plan = NULL)
[16:12:26.865]                   if (is.na(NA_character_)) 
[16:12:26.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.865]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.865]                   {
[16:12:26.865]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.865]                     if (!future$lazy) 
[16:12:26.865]                       future <- run(future)
[16:12:26.865]                     invisible(future)
[16:12:26.865]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.865]                 }
[16:12:26.865]             }
[16:12:26.865]         }
[16:12:26.865]     })
[16:12:26.865]     if (TRUE) {
[16:12:26.865]         base::sink(type = "output", split = FALSE)
[16:12:26.865]         if (TRUE) {
[16:12:26.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.865]         }
[16:12:26.865]         else {
[16:12:26.865]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.865]         }
[16:12:26.865]         base::close(...future.stdout)
[16:12:26.865]         ...future.stdout <- NULL
[16:12:26.865]     }
[16:12:26.865]     ...future.result$conditions <- ...future.conditions
[16:12:26.865]     ...future.result$finished <- base::Sys.time()
[16:12:26.865]     ...future.result
[16:12:26.865] }
[16:12:26.867] plan(): Setting new future strategy stack:
[16:12:26.867] List of future strategies:
[16:12:26.867] 1. sequential:
[16:12:26.867]    - args: function (..., envir = parent.frame())
[16:12:26.867]    - tweaked: FALSE
[16:12:26.867]    - call: NULL
[16:12:26.867] plan(): nbrOfWorkers() = 1
[16:12:26.868] plan(): Setting new future strategy stack:
[16:12:26.868] List of future strategies:
[16:12:26.868] 1. sequential:
[16:12:26.868]    - args: function (..., envir = parent.frame())
[16:12:26.868]    - tweaked: FALSE
[16:12:26.868]    - call: plan(strategy)
[16:12:26.868] plan(): nbrOfWorkers() = 1
[16:12:26.869] SequentialFuture started (and completed)
[16:12:26.869] - Launch lazy future ... done
[16:12:26.869] run() for ‘SequentialFuture’ ... done
[16:12:26.869] getGlobalsAndPackages() ...
[16:12:26.869] Searching for globals...
[16:12:26.869] 
[16:12:26.869] Searching for globals ... DONE
[16:12:26.869] - globals: [0] <none>
[16:12:26.870] getGlobalsAndPackages() ... DONE
[16:12:26.870] run() for ‘Future’ ...
[16:12:26.870] - state: ‘created’
[16:12:26.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.870] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.870]   - Field: ‘label’
[16:12:26.871]   - Field: ‘local’
[16:12:26.871]   - Field: ‘owner’
[16:12:26.871]   - Field: ‘envir’
[16:12:26.871]   - Field: ‘packages’
[16:12:26.871]   - Field: ‘gc’
[16:12:26.871]   - Field: ‘conditions’
[16:12:26.871]   - Field: ‘expr’
[16:12:26.871]   - Field: ‘uuid’
[16:12:26.871]   - Field: ‘seed’
[16:12:26.871]   - Field: ‘version’
[16:12:26.871]   - Field: ‘result’
[16:12:26.872]   - Field: ‘asynchronous’
[16:12:26.872]   - Field: ‘calls’
[16:12:26.872]   - Field: ‘globals’
[16:12:26.872]   - Field: ‘stdout’
[16:12:26.872]   - Field: ‘earlySignal’
[16:12:26.872]   - Field: ‘lazy’
[16:12:26.872]   - Field: ‘state’
[16:12:26.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.872] - Launch lazy future ...
[16:12:26.872] Packages needed by the future expression (n = 0): <none>
[16:12:26.873] Packages needed by future strategies (n = 0): <none>
[16:12:26.873] {
[16:12:26.873]     {
[16:12:26.873]         {
[16:12:26.873]             ...future.startTime <- base::Sys.time()
[16:12:26.873]             {
[16:12:26.873]                 {
[16:12:26.873]                   {
[16:12:26.873]                     base::local({
[16:12:26.873]                       has_future <- base::requireNamespace("future", 
[16:12:26.873]                         quietly = TRUE)
[16:12:26.873]                       if (has_future) {
[16:12:26.873]                         ns <- base::getNamespace("future")
[16:12:26.873]                         version <- ns[[".package"]][["version"]]
[16:12:26.873]                         if (is.null(version)) 
[16:12:26.873]                           version <- utils::packageVersion("future")
[16:12:26.873]                       }
[16:12:26.873]                       else {
[16:12:26.873]                         version <- NULL
[16:12:26.873]                       }
[16:12:26.873]                       if (!has_future || version < "1.8.0") {
[16:12:26.873]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.873]                           "", base::R.version$version.string), 
[16:12:26.873]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.873]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.873]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.873]                             "release", "version")], collapse = " "), 
[16:12:26.873]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.873]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.873]                           info)
[16:12:26.873]                         info <- base::paste(info, collapse = "; ")
[16:12:26.873]                         if (!has_future) {
[16:12:26.873]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.873]                             info)
[16:12:26.873]                         }
[16:12:26.873]                         else {
[16:12:26.873]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.873]                             info, version)
[16:12:26.873]                         }
[16:12:26.873]                         base::stop(msg)
[16:12:26.873]                       }
[16:12:26.873]                     })
[16:12:26.873]                   }
[16:12:26.873]                   options(future.plan = NULL)
[16:12:26.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.873]                 }
[16:12:26.873]                 ...future.workdir <- getwd()
[16:12:26.873]             }
[16:12:26.873]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.873]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.873]         }
[16:12:26.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.873]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.873]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.873]             base::names(...future.oldOptions))
[16:12:26.873]     }
[16:12:26.873]     if (FALSE) {
[16:12:26.873]     }
[16:12:26.873]     else {
[16:12:26.873]         if (TRUE) {
[16:12:26.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.873]                 open = "w")
[16:12:26.873]         }
[16:12:26.873]         else {
[16:12:26.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.873]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.873]         }
[16:12:26.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.873]             base::sink(type = "output", split = FALSE)
[16:12:26.873]             base::close(...future.stdout)
[16:12:26.873]         }, add = TRUE)
[16:12:26.873]     }
[16:12:26.873]     ...future.frame <- base::sys.nframe()
[16:12:26.873]     ...future.conditions <- base::list()
[16:12:26.873]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.873]     if (FALSE) {
[16:12:26.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.873]     }
[16:12:26.873]     ...future.result <- base::tryCatch({
[16:12:26.873]         base::withCallingHandlers({
[16:12:26.873]             ...future.value <- base::withVisible(base::local(NULL))
[16:12:26.873]             future::FutureResult(value = ...future.value$value, 
[16:12:26.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.873]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.873]                     ...future.globalenv.names))
[16:12:26.873]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.873]         }, condition = base::local({
[16:12:26.873]             c <- base::c
[16:12:26.873]             inherits <- base::inherits
[16:12:26.873]             invokeRestart <- base::invokeRestart
[16:12:26.873]             length <- base::length
[16:12:26.873]             list <- base::list
[16:12:26.873]             seq.int <- base::seq.int
[16:12:26.873]             signalCondition <- base::signalCondition
[16:12:26.873]             sys.calls <- base::sys.calls
[16:12:26.873]             `[[` <- base::`[[`
[16:12:26.873]             `+` <- base::`+`
[16:12:26.873]             `<<-` <- base::`<<-`
[16:12:26.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.873]                   3L)]
[16:12:26.873]             }
[16:12:26.873]             function(cond) {
[16:12:26.873]                 is_error <- inherits(cond, "error")
[16:12:26.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.873]                   NULL)
[16:12:26.873]                 if (is_error) {
[16:12:26.873]                   sessionInformation <- function() {
[16:12:26.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.873]                       search = base::search(), system = base::Sys.info())
[16:12:26.873]                   }
[16:12:26.873]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.873]                     cond$call), session = sessionInformation(), 
[16:12:26.873]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.873]                   signalCondition(cond)
[16:12:26.873]                 }
[16:12:26.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.873]                 "immediateCondition"))) {
[16:12:26.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.873]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.873]                   if (TRUE && !signal) {
[16:12:26.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.873]                     {
[16:12:26.873]                       inherits <- base::inherits
[16:12:26.873]                       invokeRestart <- base::invokeRestart
[16:12:26.873]                       is.null <- base::is.null
[16:12:26.873]                       muffled <- FALSE
[16:12:26.873]                       if (inherits(cond, "message")) {
[16:12:26.873]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.873]                         if (muffled) 
[16:12:26.873]                           invokeRestart("muffleMessage")
[16:12:26.873]                       }
[16:12:26.873]                       else if (inherits(cond, "warning")) {
[16:12:26.873]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.873]                         if (muffled) 
[16:12:26.873]                           invokeRestart("muffleWarning")
[16:12:26.873]                       }
[16:12:26.873]                       else if (inherits(cond, "condition")) {
[16:12:26.873]                         if (!is.null(pattern)) {
[16:12:26.873]                           computeRestarts <- base::computeRestarts
[16:12:26.873]                           grepl <- base::grepl
[16:12:26.873]                           restarts <- computeRestarts(cond)
[16:12:26.873]                           for (restart in restarts) {
[16:12:26.873]                             name <- restart$name
[16:12:26.873]                             if (is.null(name)) 
[16:12:26.873]                               next
[16:12:26.873]                             if (!grepl(pattern, name)) 
[16:12:26.873]                               next
[16:12:26.873]                             invokeRestart(restart)
[16:12:26.873]                             muffled <- TRUE
[16:12:26.873]                             break
[16:12:26.873]                           }
[16:12:26.873]                         }
[16:12:26.873]                       }
[16:12:26.873]                       invisible(muffled)
[16:12:26.873]                     }
[16:12:26.873]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.873]                   }
[16:12:26.873]                 }
[16:12:26.873]                 else {
[16:12:26.873]                   if (TRUE) {
[16:12:26.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.873]                     {
[16:12:26.873]                       inherits <- base::inherits
[16:12:26.873]                       invokeRestart <- base::invokeRestart
[16:12:26.873]                       is.null <- base::is.null
[16:12:26.873]                       muffled <- FALSE
[16:12:26.873]                       if (inherits(cond, "message")) {
[16:12:26.873]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.873]                         if (muffled) 
[16:12:26.873]                           invokeRestart("muffleMessage")
[16:12:26.873]                       }
[16:12:26.873]                       else if (inherits(cond, "warning")) {
[16:12:26.873]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.873]                         if (muffled) 
[16:12:26.873]                           invokeRestart("muffleWarning")
[16:12:26.873]                       }
[16:12:26.873]                       else if (inherits(cond, "condition")) {
[16:12:26.873]                         if (!is.null(pattern)) {
[16:12:26.873]                           computeRestarts <- base::computeRestarts
[16:12:26.873]                           grepl <- base::grepl
[16:12:26.873]                           restarts <- computeRestarts(cond)
[16:12:26.873]                           for (restart in restarts) {
[16:12:26.873]                             name <- restart$name
[16:12:26.873]                             if (is.null(name)) 
[16:12:26.873]                               next
[16:12:26.873]                             if (!grepl(pattern, name)) 
[16:12:26.873]                               next
[16:12:26.873]                             invokeRestart(restart)
[16:12:26.873]                             muffled <- TRUE
[16:12:26.873]                             break
[16:12:26.873]                           }
[16:12:26.873]                         }
[16:12:26.873]                       }
[16:12:26.873]                       invisible(muffled)
[16:12:26.873]                     }
[16:12:26.873]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.873]                   }
[16:12:26.873]                 }
[16:12:26.873]             }
[16:12:26.873]         }))
[16:12:26.873]     }, error = function(ex) {
[16:12:26.873]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.873]                 ...future.rng), started = ...future.startTime, 
[16:12:26.873]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.873]             version = "1.8"), class = "FutureResult")
[16:12:26.873]     }, finally = {
[16:12:26.873]         if (!identical(...future.workdir, getwd())) 
[16:12:26.873]             setwd(...future.workdir)
[16:12:26.873]         {
[16:12:26.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.873]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.873]             }
[16:12:26.873]             base::options(...future.oldOptions)
[16:12:26.873]             if (.Platform$OS.type == "windows") {
[16:12:26.873]                 old_names <- names(...future.oldEnvVars)
[16:12:26.873]                 envs <- base::Sys.getenv()
[16:12:26.873]                 names <- names(envs)
[16:12:26.873]                 common <- intersect(names, old_names)
[16:12:26.873]                 added <- setdiff(names, old_names)
[16:12:26.873]                 removed <- setdiff(old_names, names)
[16:12:26.873]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.873]                   envs[common]]
[16:12:26.873]                 NAMES <- toupper(changed)
[16:12:26.873]                 args <- list()
[16:12:26.873]                 for (kk in seq_along(NAMES)) {
[16:12:26.873]                   name <- changed[[kk]]
[16:12:26.873]                   NAME <- NAMES[[kk]]
[16:12:26.873]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.873]                     next
[16:12:26.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.873]                 }
[16:12:26.873]                 NAMES <- toupper(added)
[16:12:26.873]                 for (kk in seq_along(NAMES)) {
[16:12:26.873]                   name <- added[[kk]]
[16:12:26.873]                   NAME <- NAMES[[kk]]
[16:12:26.873]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.873]                     next
[16:12:26.873]                   args[[name]] <- ""
[16:12:26.873]                 }
[16:12:26.873]                 NAMES <- toupper(removed)
[16:12:26.873]                 for (kk in seq_along(NAMES)) {
[16:12:26.873]                   name <- removed[[kk]]
[16:12:26.873]                   NAME <- NAMES[[kk]]
[16:12:26.873]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.873]                     next
[16:12:26.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.873]                 }
[16:12:26.873]                 if (length(args) > 0) 
[16:12:26.873]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.873]             }
[16:12:26.873]             else {
[16:12:26.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.873]             }
[16:12:26.873]             {
[16:12:26.873]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.873]                   0L) {
[16:12:26.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.873]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.873]                   base::options(opts)
[16:12:26.873]                 }
[16:12:26.873]                 {
[16:12:26.873]                   {
[16:12:26.873]                     NULL
[16:12:26.873]                     RNGkind("Mersenne-Twister")
[16:12:26.873]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.873]                       inherits = FALSE)
[16:12:26.873]                   }
[16:12:26.873]                   options(future.plan = NULL)
[16:12:26.873]                   if (is.na(NA_character_)) 
[16:12:26.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.873]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.873]                   {
[16:12:26.873]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.873]                     if (!future$lazy) 
[16:12:26.873]                       future <- run(future)
[16:12:26.873]                     invisible(future)
[16:12:26.873]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.873]                 }
[16:12:26.873]             }
[16:12:26.873]         }
[16:12:26.873]     })
[16:12:26.873]     if (TRUE) {
[16:12:26.873]         base::sink(type = "output", split = FALSE)
[16:12:26.873]         if (TRUE) {
[16:12:26.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.873]         }
[16:12:26.873]         else {
[16:12:26.873]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.873]         }
[16:12:26.873]         base::close(...future.stdout)
[16:12:26.873]         ...future.stdout <- NULL
[16:12:26.873]     }
[16:12:26.873]     ...future.result$conditions <- ...future.conditions
[16:12:26.873]     ...future.result$finished <- base::Sys.time()
[16:12:26.873]     ...future.result
[16:12:26.873] }
[16:12:26.875] plan(): Setting new future strategy stack:
[16:12:26.875] List of future strategies:
[16:12:26.875] 1. sequential:
[16:12:26.875]    - args: function (..., envir = parent.frame())
[16:12:26.875]    - tweaked: FALSE
[16:12:26.875]    - call: NULL
[16:12:26.875] plan(): nbrOfWorkers() = 1
[16:12:26.876] plan(): Setting new future strategy stack:
[16:12:26.876] List of future strategies:
[16:12:26.876] 1. sequential:
[16:12:26.876]    - args: function (..., envir = parent.frame())
[16:12:26.876]    - tweaked: FALSE
[16:12:26.876]    - call: plan(strategy)
[16:12:26.876] plan(): nbrOfWorkers() = 1
[16:12:26.877] SequentialFuture started (and completed)
[16:12:26.877] - Launch lazy future ... done
[16:12:26.877] run() for ‘SequentialFuture’ ... done
[16:12:26.877] getGlobalsAndPackages() ...
[16:12:26.877] Searching for globals...
[16:12:26.878] - globals found: [1] ‘{’
[16:12:26.878] Searching for globals ... DONE
[16:12:26.878] Resolving globals: FALSE
[16:12:26.878] 
[16:12:26.878] 
[16:12:26.878] getGlobalsAndPackages() ... DONE
[16:12:26.879] run() for ‘Future’ ...
[16:12:26.879] - state: ‘created’
[16:12:26.879] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:12:26.879] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:12:26.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:12:26.879]   - Field: ‘label’
[16:12:26.879]   - Field: ‘local’
[16:12:26.880]   - Field: ‘owner’
[16:12:26.880]   - Field: ‘envir’
[16:12:26.880]   - Field: ‘packages’
[16:12:26.880]   - Field: ‘gc’
[16:12:26.880]   - Field: ‘conditions’
[16:12:26.880]   - Field: ‘expr’
[16:12:26.880]   - Field: ‘uuid’
[16:12:26.880]   - Field: ‘seed’
[16:12:26.880]   - Field: ‘version’
[16:12:26.880]   - Field: ‘result’
[16:12:26.880]   - Field: ‘asynchronous’
[16:12:26.881]   - Field: ‘calls’
[16:12:26.881]   - Field: ‘globals’
[16:12:26.881]   - Field: ‘stdout’
[16:12:26.881]   - Field: ‘earlySignal’
[16:12:26.881]   - Field: ‘lazy’
[16:12:26.881]   - Field: ‘state’
[16:12:26.881] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:12:26.881] - Launch lazy future ...
[16:12:26.881] Packages needed by the future expression (n = 0): <none>
[16:12:26.882] Packages needed by future strategies (n = 0): <none>
[16:12:26.882] {
[16:12:26.882]     {
[16:12:26.882]         {
[16:12:26.882]             ...future.startTime <- base::Sys.time()
[16:12:26.882]             {
[16:12:26.882]                 {
[16:12:26.882]                   {
[16:12:26.882]                     base::local({
[16:12:26.882]                       has_future <- base::requireNamespace("future", 
[16:12:26.882]                         quietly = TRUE)
[16:12:26.882]                       if (has_future) {
[16:12:26.882]                         ns <- base::getNamespace("future")
[16:12:26.882]                         version <- ns[[".package"]][["version"]]
[16:12:26.882]                         if (is.null(version)) 
[16:12:26.882]                           version <- utils::packageVersion("future")
[16:12:26.882]                       }
[16:12:26.882]                       else {
[16:12:26.882]                         version <- NULL
[16:12:26.882]                       }
[16:12:26.882]                       if (!has_future || version < "1.8.0") {
[16:12:26.882]                         info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.882]                           "", base::R.version$version.string), 
[16:12:26.882]                           platform = base::sprintf("%s (%s-bit)", 
[16:12:26.882]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.882]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.882]                             "release", "version")], collapse = " "), 
[16:12:26.882]                           hostname = base::Sys.info()[["nodename"]])
[16:12:26.882]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.882]                           info)
[16:12:26.882]                         info <- base::paste(info, collapse = "; ")
[16:12:26.882]                         if (!has_future) {
[16:12:26.882]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.882]                             info)
[16:12:26.882]                         }
[16:12:26.882]                         else {
[16:12:26.882]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.882]                             info, version)
[16:12:26.882]                         }
[16:12:26.882]                         base::stop(msg)
[16:12:26.882]                       }
[16:12:26.882]                     })
[16:12:26.882]                   }
[16:12:26.882]                   options(future.plan = NULL)
[16:12:26.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.882]                 }
[16:12:26.882]                 ...future.workdir <- getwd()
[16:12:26.882]             }
[16:12:26.882]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.882]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.882]         }
[16:12:26.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.882]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.882]             base::names(...future.oldOptions))
[16:12:26.882]     }
[16:12:26.882]     if (FALSE) {
[16:12:26.882]     }
[16:12:26.882]     else {
[16:12:26.882]         if (TRUE) {
[16:12:26.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.882]                 open = "w")
[16:12:26.882]         }
[16:12:26.882]         else {
[16:12:26.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.882]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.882]         }
[16:12:26.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.882]             base::sink(type = "output", split = FALSE)
[16:12:26.882]             base::close(...future.stdout)
[16:12:26.882]         }, add = TRUE)
[16:12:26.882]     }
[16:12:26.882]     ...future.frame <- base::sys.nframe()
[16:12:26.882]     ...future.conditions <- base::list()
[16:12:26.882]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.882]     if (FALSE) {
[16:12:26.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.882]     }
[16:12:26.882]     ...future.result <- base::tryCatch({
[16:12:26.882]         base::withCallingHandlers({
[16:12:26.882]             ...future.value <- base::withVisible(base::local({
[16:12:26.882]                 4
[16:12:26.882]             }))
[16:12:26.882]             future::FutureResult(value = ...future.value$value, 
[16:12:26.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.882]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.882]                     ...future.globalenv.names))
[16:12:26.882]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.882]         }, condition = base::local({
[16:12:26.882]             c <- base::c
[16:12:26.882]             inherits <- base::inherits
[16:12:26.882]             invokeRestart <- base::invokeRestart
[16:12:26.882]             length <- base::length
[16:12:26.882]             list <- base::list
[16:12:26.882]             seq.int <- base::seq.int
[16:12:26.882]             signalCondition <- base::signalCondition
[16:12:26.882]             sys.calls <- base::sys.calls
[16:12:26.882]             `[[` <- base::`[[`
[16:12:26.882]             `+` <- base::`+`
[16:12:26.882]             `<<-` <- base::`<<-`
[16:12:26.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.882]                   3L)]
[16:12:26.882]             }
[16:12:26.882]             function(cond) {
[16:12:26.882]                 is_error <- inherits(cond, "error")
[16:12:26.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.882]                   NULL)
[16:12:26.882]                 if (is_error) {
[16:12:26.882]                   sessionInformation <- function() {
[16:12:26.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.882]                       search = base::search(), system = base::Sys.info())
[16:12:26.882]                   }
[16:12:26.882]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.882]                     cond$call), session = sessionInformation(), 
[16:12:26.882]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.882]                   signalCondition(cond)
[16:12:26.882]                 }
[16:12:26.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.882]                 "immediateCondition"))) {
[16:12:26.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.882]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.882]                   if (TRUE && !signal) {
[16:12:26.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.882]                     {
[16:12:26.882]                       inherits <- base::inherits
[16:12:26.882]                       invokeRestart <- base::invokeRestart
[16:12:26.882]                       is.null <- base::is.null
[16:12:26.882]                       muffled <- FALSE
[16:12:26.882]                       if (inherits(cond, "message")) {
[16:12:26.882]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.882]                         if (muffled) 
[16:12:26.882]                           invokeRestart("muffleMessage")
[16:12:26.882]                       }
[16:12:26.882]                       else if (inherits(cond, "warning")) {
[16:12:26.882]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.882]                         if (muffled) 
[16:12:26.882]                           invokeRestart("muffleWarning")
[16:12:26.882]                       }
[16:12:26.882]                       else if (inherits(cond, "condition")) {
[16:12:26.882]                         if (!is.null(pattern)) {
[16:12:26.882]                           computeRestarts <- base::computeRestarts
[16:12:26.882]                           grepl <- base::grepl
[16:12:26.882]                           restarts <- computeRestarts(cond)
[16:12:26.882]                           for (restart in restarts) {
[16:12:26.882]                             name <- restart$name
[16:12:26.882]                             if (is.null(name)) 
[16:12:26.882]                               next
[16:12:26.882]                             if (!grepl(pattern, name)) 
[16:12:26.882]                               next
[16:12:26.882]                             invokeRestart(restart)
[16:12:26.882]                             muffled <- TRUE
[16:12:26.882]                             break
[16:12:26.882]                           }
[16:12:26.882]                         }
[16:12:26.882]                       }
[16:12:26.882]                       invisible(muffled)
[16:12:26.882]                     }
[16:12:26.882]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.882]                   }
[16:12:26.882]                 }
[16:12:26.882]                 else {
[16:12:26.882]                   if (TRUE) {
[16:12:26.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.882]                     {
[16:12:26.882]                       inherits <- base::inherits
[16:12:26.882]                       invokeRestart <- base::invokeRestart
[16:12:26.882]                       is.null <- base::is.null
[16:12:26.882]                       muffled <- FALSE
[16:12:26.882]                       if (inherits(cond, "message")) {
[16:12:26.882]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.882]                         if (muffled) 
[16:12:26.882]                           invokeRestart("muffleMessage")
[16:12:26.882]                       }
[16:12:26.882]                       else if (inherits(cond, "warning")) {
[16:12:26.882]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.882]                         if (muffled) 
[16:12:26.882]                           invokeRestart("muffleWarning")
[16:12:26.882]                       }
[16:12:26.882]                       else if (inherits(cond, "condition")) {
[16:12:26.882]                         if (!is.null(pattern)) {
[16:12:26.882]                           computeRestarts <- base::computeRestarts
[16:12:26.882]                           grepl <- base::grepl
[16:12:26.882]                           restarts <- computeRestarts(cond)
[16:12:26.882]                           for (restart in restarts) {
[16:12:26.882]                             name <- restart$name
[16:12:26.882]                             if (is.null(name)) 
[16:12:26.882]                               next
[16:12:26.882]                             if (!grepl(pattern, name)) 
[16:12:26.882]                               next
[16:12:26.882]                             invokeRestart(restart)
[16:12:26.882]                             muffled <- TRUE
[16:12:26.882]                             break
[16:12:26.882]                           }
[16:12:26.882]                         }
[16:12:26.882]                       }
[16:12:26.882]                       invisible(muffled)
[16:12:26.882]                     }
[16:12:26.882]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.882]                   }
[16:12:26.882]                 }
[16:12:26.882]             }
[16:12:26.882]         }))
[16:12:26.882]     }, error = function(ex) {
[16:12:26.882]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.882]                 ...future.rng), started = ...future.startTime, 
[16:12:26.882]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.882]             version = "1.8"), class = "FutureResult")
[16:12:26.882]     }, finally = {
[16:12:26.882]         if (!identical(...future.workdir, getwd())) 
[16:12:26.882]             setwd(...future.workdir)
[16:12:26.882]         {
[16:12:26.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.882]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.882]             }
[16:12:26.882]             base::options(...future.oldOptions)
[16:12:26.882]             if (.Platform$OS.type == "windows") {
[16:12:26.882]                 old_names <- names(...future.oldEnvVars)
[16:12:26.882]                 envs <- base::Sys.getenv()
[16:12:26.882]                 names <- names(envs)
[16:12:26.882]                 common <- intersect(names, old_names)
[16:12:26.882]                 added <- setdiff(names, old_names)
[16:12:26.882]                 removed <- setdiff(old_names, names)
[16:12:26.882]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.882]                   envs[common]]
[16:12:26.882]                 NAMES <- toupper(changed)
[16:12:26.882]                 args <- list()
[16:12:26.882]                 for (kk in seq_along(NAMES)) {
[16:12:26.882]                   name <- changed[[kk]]
[16:12:26.882]                   NAME <- NAMES[[kk]]
[16:12:26.882]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.882]                     next
[16:12:26.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.882]                 }
[16:12:26.882]                 NAMES <- toupper(added)
[16:12:26.882]                 for (kk in seq_along(NAMES)) {
[16:12:26.882]                   name <- added[[kk]]
[16:12:26.882]                   NAME <- NAMES[[kk]]
[16:12:26.882]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.882]                     next
[16:12:26.882]                   args[[name]] <- ""
[16:12:26.882]                 }
[16:12:26.882]                 NAMES <- toupper(removed)
[16:12:26.882]                 for (kk in seq_along(NAMES)) {
[16:12:26.882]                   name <- removed[[kk]]
[16:12:26.882]                   NAME <- NAMES[[kk]]
[16:12:26.882]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.882]                     next
[16:12:26.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.882]                 }
[16:12:26.882]                 if (length(args) > 0) 
[16:12:26.882]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.882]             }
[16:12:26.882]             else {
[16:12:26.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.882]             }
[16:12:26.882]             {
[16:12:26.882]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.882]                   0L) {
[16:12:26.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.882]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.882]                   base::options(opts)
[16:12:26.882]                 }
[16:12:26.882]                 {
[16:12:26.882]                   {
[16:12:26.882]                     NULL
[16:12:26.882]                     RNGkind("Mersenne-Twister")
[16:12:26.882]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:12:26.882]                       inherits = FALSE)
[16:12:26.882]                   }
[16:12:26.882]                   options(future.plan = NULL)
[16:12:26.882]                   if (is.na(NA_character_)) 
[16:12:26.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.882]                   future::plan(list(function (..., envir = parent.frame()) 
[16:12:26.882]                   {
[16:12:26.882]                     future <- SequentialFuture(..., envir = envir)
[16:12:26.882]                     if (!future$lazy) 
[16:12:26.882]                       future <- run(future)
[16:12:26.882]                     invisible(future)
[16:12:26.882]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.882]                 }
[16:12:26.882]             }
[16:12:26.882]         }
[16:12:26.882]     })
[16:12:26.882]     if (TRUE) {
[16:12:26.882]         base::sink(type = "output", split = FALSE)
[16:12:26.882]         if (TRUE) {
[16:12:26.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.882]         }
[16:12:26.882]         else {
[16:12:26.882]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.882]         }
[16:12:26.882]         base::close(...future.stdout)
[16:12:26.882]         ...future.stdout <- NULL
[16:12:26.882]     }
[16:12:26.882]     ...future.result$conditions <- ...future.conditions
[16:12:26.882]     ...future.result$finished <- base::Sys.time()
[16:12:26.882]     ...future.result
[16:12:26.882] }
[16:12:26.884] plan(): Setting new future strategy stack:
[16:12:26.884] List of future strategies:
[16:12:26.884] 1. sequential:
[16:12:26.884]    - args: function (..., envir = parent.frame())
[16:12:26.884]    - tweaked: FALSE
[16:12:26.884]    - call: NULL
[16:12:26.884] plan(): nbrOfWorkers() = 1
[16:12:26.885] plan(): Setting new future strategy stack:
[16:12:26.885] List of future strategies:
[16:12:26.885] 1. sequential:
[16:12:26.885]    - args: function (..., envir = parent.frame())
[16:12:26.885]    - tweaked: FALSE
[16:12:26.885]    - call: plan(strategy)
[16:12:26.885] plan(): nbrOfWorkers() = 1
[16:12:26.885] SequentialFuture started (and completed)
[16:12:26.886] - Launch lazy future ... done
[16:12:26.886] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560bad65c228> 
Classes 'listenv', 'environment' <environment: 0x560bae67bbe8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:26.892] resolved() for ‘SequentialFuture’ ...
[16:12:26.892] - state: ‘finished’
[16:12:26.892] - run: TRUE
[16:12:26.892] - result: ‘FutureResult’
[16:12:26.892] resolved() for ‘SequentialFuture’ ... done
[16:12:26.893] resolved() for ‘SequentialFuture’ ...
[16:12:26.893] - state: ‘finished’
[16:12:26.893] - run: TRUE
[16:12:26.893] - result: ‘FutureResult’
[16:12:26.893] resolved() for ‘SequentialFuture’ ... done
[16:12:26.893] resolved() for ‘SequentialFuture’ ...
[16:12:26.893] - state: ‘finished’
[16:12:26.893] - run: TRUE
[16:12:26.893] - result: ‘FutureResult’
[16:12:26.893] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:26.896] resolve() on list environment ...
[16:12:26.896]  recursive: 0
[16:12:26.897]  length: 6
[16:12:26.897]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:26.897] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.898] - nx: 6
[16:12:26.898] - relay: TRUE
[16:12:26.898] - stdout: TRUE
[16:12:26.898] - signal: TRUE
[16:12:26.898] - resignal: FALSE
[16:12:26.898] - force: TRUE
[16:12:26.898] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.898] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.898]  - until=2
[16:12:26.898]  - relaying element #2
[16:12:26.898] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.899] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.899] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.899]  length: 5 (resolved future 1)
[16:12:26.899] resolved() for ‘SequentialFuture’ ...
[16:12:26.899] - state: ‘finished’
[16:12:26.899] - run: TRUE
[16:12:26.899] - result: ‘FutureResult’
[16:12:26.899] resolved() for ‘SequentialFuture’ ... done
[16:12:26.899] Future #2
[16:12:26.900] signalConditionsASAP(SequentialFuture, pos=2) ...
[16:12:26.900] - nx: 6
[16:12:26.900] - relay: TRUE
[16:12:26.900] - stdout: TRUE
[16:12:26.900] - signal: TRUE
[16:12:26.900] - resignal: FALSE
[16:12:26.900] - force: TRUE
[16:12:26.900] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.900] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.900]  - until=2
[16:12:26.900]  - relaying element #2
[16:12:26.901] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.901] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.901] signalConditionsASAP(SequentialFuture, pos=2) ... done
[16:12:26.901]  length: 4 (resolved future 2)
[16:12:26.901] resolved() for ‘SequentialFuture’ ...
[16:12:26.901] - state: ‘finished’
[16:12:26.901] - run: TRUE
[16:12:26.901] - result: ‘FutureResult’
[16:12:26.901] resolved() for ‘SequentialFuture’ ... done
[16:12:26.902] Future #3
[16:12:26.902] signalConditionsASAP(SequentialFuture, pos=3) ...
[16:12:26.902] - nx: 6
[16:12:26.902] - relay: TRUE
[16:12:26.902] - stdout: TRUE
[16:12:26.902] - signal: TRUE
[16:12:26.902] - resignal: FALSE
[16:12:26.902] - force: TRUE
[16:12:26.902] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.902] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.902]  - until=3
[16:12:26.903]  - relaying element #3
[16:12:26.903] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.903] signalConditionsASAP(SequentialFuture, pos=3) ... done
[16:12:26.903]  length: 3 (resolved future 3)
[16:12:26.903] resolved() for ‘SequentialFuture’ ...
[16:12:26.903] - state: ‘finished’
[16:12:26.903] - run: TRUE
[16:12:26.903] - result: ‘FutureResult’
[16:12:26.903] resolved() for ‘SequentialFuture’ ... done
[16:12:26.904] Future #4
[16:12:26.904] signalConditionsASAP(SequentialFuture, pos=4) ...
[16:12:26.904] - nx: 6
[16:12:26.904] - relay: TRUE
[16:12:26.904] - stdout: TRUE
[16:12:26.904] - signal: TRUE
[16:12:26.904] - resignal: FALSE
[16:12:26.904] - force: TRUE
[16:12:26.904] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.905]  - until=4
[16:12:26.905]  - relaying element #4
[16:12:26.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.905] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.905] signalConditionsASAP(SequentialFuture, pos=4) ... done
[16:12:26.905]  length: 2 (resolved future 4)
[16:12:26.905] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.905] - nx: 6
[16:12:26.905] - relay: TRUE
[16:12:26.905] - stdout: TRUE
[16:12:26.905] - signal: TRUE
[16:12:26.906] - resignal: FALSE
[16:12:26.906] - force: TRUE
[16:12:26.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.906] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.906]  - until=6
[16:12:26.906]  - relaying element #6
[16:12:26.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.906] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.906] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.906]  length: 1 (resolved future 5)
[16:12:26.906] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.907] - nx: 6
[16:12:26.907] - relay: TRUE
[16:12:26.907] - stdout: TRUE
[16:12:26.907] - signal: TRUE
[16:12:26.907] - resignal: FALSE
[16:12:26.907] - force: TRUE
[16:12:26.907] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.907] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.907]  - until=6
[16:12:26.907] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.907] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.907] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.908]  length: 0 (resolved future 6)
[16:12:26.908] Relaying remaining futures
[16:12:26.908] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.908] - nx: 6
[16:12:26.908] - relay: TRUE
[16:12:26.908] - stdout: TRUE
[16:12:26.908] - signal: TRUE
[16:12:26.908] - resignal: FALSE
[16:12:26.908] - force: TRUE
[16:12:26.908] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.908] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:26.909] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.909] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.909] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.909] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bae441480> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[16:12:26.913] plan(): Setting new future strategy stack:
[16:12:26.913] List of future strategies:
[16:12:26.913] 1. multicore:
[16:12:26.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:26.913]    - tweaked: FALSE
[16:12:26.913]    - call: plan(strategy)
[16:12:26.918] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:12:26.918] getGlobalsAndPackages() ...
[16:12:26.918] Searching for globals...
[16:12:26.918] 
[16:12:26.918] Searching for globals ... DONE
[16:12:26.918] - globals: [0] <none>
[16:12:26.919] getGlobalsAndPackages() ... DONE
[16:12:26.919] run() for ‘Future’ ...
[16:12:26.919] - state: ‘created’
[16:12:26.919] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:26.923] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:26.923] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:26.923]   - Field: ‘label’
[16:12:26.923]   - Field: ‘local’
[16:12:26.923]   - Field: ‘owner’
[16:12:26.924]   - Field: ‘envir’
[16:12:26.924]   - Field: ‘workers’
[16:12:26.924]   - Field: ‘packages’
[16:12:26.924]   - Field: ‘gc’
[16:12:26.924]   - Field: ‘job’
[16:12:26.924]   - Field: ‘conditions’
[16:12:26.924]   - Field: ‘expr’
[16:12:26.924]   - Field: ‘uuid’
[16:12:26.924]   - Field: ‘seed’
[16:12:26.925]   - Field: ‘version’
[16:12:26.925]   - Field: ‘result’
[16:12:26.925]   - Field: ‘asynchronous’
[16:12:26.925]   - Field: ‘calls’
[16:12:26.925]   - Field: ‘globals’
[16:12:26.925]   - Field: ‘stdout’
[16:12:26.925]   - Field: ‘earlySignal’
[16:12:26.925]   - Field: ‘lazy’
[16:12:26.925]   - Field: ‘state’
[16:12:26.925] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:26.926] - Launch lazy future ...
[16:12:26.927] Packages needed by the future expression (n = 0): <none>
[16:12:26.927] Packages needed by future strategies (n = 0): <none>
[16:12:26.927] {
[16:12:26.927]     {
[16:12:26.927]         {
[16:12:26.927]             ...future.startTime <- base::Sys.time()
[16:12:26.927]             {
[16:12:26.927]                 {
[16:12:26.927]                   {
[16:12:26.927]                     {
[16:12:26.927]                       base::local({
[16:12:26.927]                         has_future <- base::requireNamespace("future", 
[16:12:26.927]                           quietly = TRUE)
[16:12:26.927]                         if (has_future) {
[16:12:26.927]                           ns <- base::getNamespace("future")
[16:12:26.927]                           version <- ns[[".package"]][["version"]]
[16:12:26.927]                           if (is.null(version)) 
[16:12:26.927]                             version <- utils::packageVersion("future")
[16:12:26.927]                         }
[16:12:26.927]                         else {
[16:12:26.927]                           version <- NULL
[16:12:26.927]                         }
[16:12:26.927]                         if (!has_future || version < "1.8.0") {
[16:12:26.927]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.927]                             "", base::R.version$version.string), 
[16:12:26.927]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:26.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.927]                               "release", "version")], collapse = " "), 
[16:12:26.927]                             hostname = base::Sys.info()[["nodename"]])
[16:12:26.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.927]                             info)
[16:12:26.927]                           info <- base::paste(info, collapse = "; ")
[16:12:26.927]                           if (!has_future) {
[16:12:26.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.927]                               info)
[16:12:26.927]                           }
[16:12:26.927]                           else {
[16:12:26.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.927]                               info, version)
[16:12:26.927]                           }
[16:12:26.927]                           base::stop(msg)
[16:12:26.927]                         }
[16:12:26.927]                       })
[16:12:26.927]                     }
[16:12:26.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:26.927]                     base::options(mc.cores = 1L)
[16:12:26.927]                   }
[16:12:26.927]                   options(future.plan = NULL)
[16:12:26.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.927]                 }
[16:12:26.927]                 ...future.workdir <- getwd()
[16:12:26.927]             }
[16:12:26.927]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.927]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.927]         }
[16:12:26.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.927]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.927]             base::names(...future.oldOptions))
[16:12:26.927]     }
[16:12:26.927]     if (FALSE) {
[16:12:26.927]     }
[16:12:26.927]     else {
[16:12:26.927]         if (TRUE) {
[16:12:26.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.927]                 open = "w")
[16:12:26.927]         }
[16:12:26.927]         else {
[16:12:26.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.927]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.927]         }
[16:12:26.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.927]             base::sink(type = "output", split = FALSE)
[16:12:26.927]             base::close(...future.stdout)
[16:12:26.927]         }, add = TRUE)
[16:12:26.927]     }
[16:12:26.927]     ...future.frame <- base::sys.nframe()
[16:12:26.927]     ...future.conditions <- base::list()
[16:12:26.927]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.927]     if (FALSE) {
[16:12:26.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.927]     }
[16:12:26.927]     ...future.result <- base::tryCatch({
[16:12:26.927]         base::withCallingHandlers({
[16:12:26.927]             ...future.value <- base::withVisible(base::local({
[16:12:26.927]                 withCallingHandlers({
[16:12:26.927]                   2
[16:12:26.927]                 }, immediateCondition = function(cond) {
[16:12:26.927]                   save_rds <- function (object, pathname, ...) 
[16:12:26.927]                   {
[16:12:26.927]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:26.927]                     if (file_test("-f", pathname_tmp)) {
[16:12:26.927]                       fi_tmp <- file.info(pathname_tmp)
[16:12:26.927]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:26.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:26.927]                         fi_tmp[["mtime"]])
[16:12:26.927]                     }
[16:12:26.927]                     tryCatch({
[16:12:26.927]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:26.927]                     }, error = function(ex) {
[16:12:26.927]                       msg <- conditionMessage(ex)
[16:12:26.927]                       fi_tmp <- file.info(pathname_tmp)
[16:12:26.927]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:26.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:26.927]                         fi_tmp[["mtime"]], msg)
[16:12:26.927]                       ex$message <- msg
[16:12:26.927]                       stop(ex)
[16:12:26.927]                     })
[16:12:26.927]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:26.927]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:26.927]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:26.927]                       fi_tmp <- file.info(pathname_tmp)
[16:12:26.927]                       fi <- file.info(pathname)
[16:12:26.927]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:26.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:26.927]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:26.927]                         fi[["size"]], fi[["mtime"]])
[16:12:26.927]                       stop(msg)
[16:12:26.927]                     }
[16:12:26.927]                     invisible(pathname)
[16:12:26.927]                   }
[16:12:26.927]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:26.927]                     rootPath = tempdir()) 
[16:12:26.927]                   {
[16:12:26.927]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:26.927]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:26.927]                       tmpdir = path, fileext = ".rds")
[16:12:26.927]                     save_rds(obj, file)
[16:12:26.927]                   }
[16:12:26.927]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:26.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.927]                   {
[16:12:26.927]                     inherits <- base::inherits
[16:12:26.927]                     invokeRestart <- base::invokeRestart
[16:12:26.927]                     is.null <- base::is.null
[16:12:26.927]                     muffled <- FALSE
[16:12:26.927]                     if (inherits(cond, "message")) {
[16:12:26.927]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:26.927]                       if (muffled) 
[16:12:26.927]                         invokeRestart("muffleMessage")
[16:12:26.927]                     }
[16:12:26.927]                     else if (inherits(cond, "warning")) {
[16:12:26.927]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:26.927]                       if (muffled) 
[16:12:26.927]                         invokeRestart("muffleWarning")
[16:12:26.927]                     }
[16:12:26.927]                     else if (inherits(cond, "condition")) {
[16:12:26.927]                       if (!is.null(pattern)) {
[16:12:26.927]                         computeRestarts <- base::computeRestarts
[16:12:26.927]                         grepl <- base::grepl
[16:12:26.927]                         restarts <- computeRestarts(cond)
[16:12:26.927]                         for (restart in restarts) {
[16:12:26.927]                           name <- restart$name
[16:12:26.927]                           if (is.null(name)) 
[16:12:26.927]                             next
[16:12:26.927]                           if (!grepl(pattern, name)) 
[16:12:26.927]                             next
[16:12:26.927]                           invokeRestart(restart)
[16:12:26.927]                           muffled <- TRUE
[16:12:26.927]                           break
[16:12:26.927]                         }
[16:12:26.927]                       }
[16:12:26.927]                     }
[16:12:26.927]                     invisible(muffled)
[16:12:26.927]                   }
[16:12:26.927]                   muffleCondition(cond)
[16:12:26.927]                 })
[16:12:26.927]             }))
[16:12:26.927]             future::FutureResult(value = ...future.value$value, 
[16:12:26.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.927]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.927]                     ...future.globalenv.names))
[16:12:26.927]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.927]         }, condition = base::local({
[16:12:26.927]             c <- base::c
[16:12:26.927]             inherits <- base::inherits
[16:12:26.927]             invokeRestart <- base::invokeRestart
[16:12:26.927]             length <- base::length
[16:12:26.927]             list <- base::list
[16:12:26.927]             seq.int <- base::seq.int
[16:12:26.927]             signalCondition <- base::signalCondition
[16:12:26.927]             sys.calls <- base::sys.calls
[16:12:26.927]             `[[` <- base::`[[`
[16:12:26.927]             `+` <- base::`+`
[16:12:26.927]             `<<-` <- base::`<<-`
[16:12:26.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.927]                   3L)]
[16:12:26.927]             }
[16:12:26.927]             function(cond) {
[16:12:26.927]                 is_error <- inherits(cond, "error")
[16:12:26.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.927]                   NULL)
[16:12:26.927]                 if (is_error) {
[16:12:26.927]                   sessionInformation <- function() {
[16:12:26.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.927]                       search = base::search(), system = base::Sys.info())
[16:12:26.927]                   }
[16:12:26.927]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.927]                     cond$call), session = sessionInformation(), 
[16:12:26.927]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.927]                   signalCondition(cond)
[16:12:26.927]                 }
[16:12:26.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.927]                 "immediateCondition"))) {
[16:12:26.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.927]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.927]                   if (TRUE && !signal) {
[16:12:26.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.927]                     {
[16:12:26.927]                       inherits <- base::inherits
[16:12:26.927]                       invokeRestart <- base::invokeRestart
[16:12:26.927]                       is.null <- base::is.null
[16:12:26.927]                       muffled <- FALSE
[16:12:26.927]                       if (inherits(cond, "message")) {
[16:12:26.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.927]                         if (muffled) 
[16:12:26.927]                           invokeRestart("muffleMessage")
[16:12:26.927]                       }
[16:12:26.927]                       else if (inherits(cond, "warning")) {
[16:12:26.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.927]                         if (muffled) 
[16:12:26.927]                           invokeRestart("muffleWarning")
[16:12:26.927]                       }
[16:12:26.927]                       else if (inherits(cond, "condition")) {
[16:12:26.927]                         if (!is.null(pattern)) {
[16:12:26.927]                           computeRestarts <- base::computeRestarts
[16:12:26.927]                           grepl <- base::grepl
[16:12:26.927]                           restarts <- computeRestarts(cond)
[16:12:26.927]                           for (restart in restarts) {
[16:12:26.927]                             name <- restart$name
[16:12:26.927]                             if (is.null(name)) 
[16:12:26.927]                               next
[16:12:26.927]                             if (!grepl(pattern, name)) 
[16:12:26.927]                               next
[16:12:26.927]                             invokeRestart(restart)
[16:12:26.927]                             muffled <- TRUE
[16:12:26.927]                             break
[16:12:26.927]                           }
[16:12:26.927]                         }
[16:12:26.927]                       }
[16:12:26.927]                       invisible(muffled)
[16:12:26.927]                     }
[16:12:26.927]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.927]                   }
[16:12:26.927]                 }
[16:12:26.927]                 else {
[16:12:26.927]                   if (TRUE) {
[16:12:26.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.927]                     {
[16:12:26.927]                       inherits <- base::inherits
[16:12:26.927]                       invokeRestart <- base::invokeRestart
[16:12:26.927]                       is.null <- base::is.null
[16:12:26.927]                       muffled <- FALSE
[16:12:26.927]                       if (inherits(cond, "message")) {
[16:12:26.927]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.927]                         if (muffled) 
[16:12:26.927]                           invokeRestart("muffleMessage")
[16:12:26.927]                       }
[16:12:26.927]                       else if (inherits(cond, "warning")) {
[16:12:26.927]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.927]                         if (muffled) 
[16:12:26.927]                           invokeRestart("muffleWarning")
[16:12:26.927]                       }
[16:12:26.927]                       else if (inherits(cond, "condition")) {
[16:12:26.927]                         if (!is.null(pattern)) {
[16:12:26.927]                           computeRestarts <- base::computeRestarts
[16:12:26.927]                           grepl <- base::grepl
[16:12:26.927]                           restarts <- computeRestarts(cond)
[16:12:26.927]                           for (restart in restarts) {
[16:12:26.927]                             name <- restart$name
[16:12:26.927]                             if (is.null(name)) 
[16:12:26.927]                               next
[16:12:26.927]                             if (!grepl(pattern, name)) 
[16:12:26.927]                               next
[16:12:26.927]                             invokeRestart(restart)
[16:12:26.927]                             muffled <- TRUE
[16:12:26.927]                             break
[16:12:26.927]                           }
[16:12:26.927]                         }
[16:12:26.927]                       }
[16:12:26.927]                       invisible(muffled)
[16:12:26.927]                     }
[16:12:26.927]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.927]                   }
[16:12:26.927]                 }
[16:12:26.927]             }
[16:12:26.927]         }))
[16:12:26.927]     }, error = function(ex) {
[16:12:26.927]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.927]                 ...future.rng), started = ...future.startTime, 
[16:12:26.927]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.927]             version = "1.8"), class = "FutureResult")
[16:12:26.927]     }, finally = {
[16:12:26.927]         if (!identical(...future.workdir, getwd())) 
[16:12:26.927]             setwd(...future.workdir)
[16:12:26.927]         {
[16:12:26.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.927]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.927]             }
[16:12:26.927]             base::options(...future.oldOptions)
[16:12:26.927]             if (.Platform$OS.type == "windows") {
[16:12:26.927]                 old_names <- names(...future.oldEnvVars)
[16:12:26.927]                 envs <- base::Sys.getenv()
[16:12:26.927]                 names <- names(envs)
[16:12:26.927]                 common <- intersect(names, old_names)
[16:12:26.927]                 added <- setdiff(names, old_names)
[16:12:26.927]                 removed <- setdiff(old_names, names)
[16:12:26.927]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.927]                   envs[common]]
[16:12:26.927]                 NAMES <- toupper(changed)
[16:12:26.927]                 args <- list()
[16:12:26.927]                 for (kk in seq_along(NAMES)) {
[16:12:26.927]                   name <- changed[[kk]]
[16:12:26.927]                   NAME <- NAMES[[kk]]
[16:12:26.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.927]                     next
[16:12:26.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.927]                 }
[16:12:26.927]                 NAMES <- toupper(added)
[16:12:26.927]                 for (kk in seq_along(NAMES)) {
[16:12:26.927]                   name <- added[[kk]]
[16:12:26.927]                   NAME <- NAMES[[kk]]
[16:12:26.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.927]                     next
[16:12:26.927]                   args[[name]] <- ""
[16:12:26.927]                 }
[16:12:26.927]                 NAMES <- toupper(removed)
[16:12:26.927]                 for (kk in seq_along(NAMES)) {
[16:12:26.927]                   name <- removed[[kk]]
[16:12:26.927]                   NAME <- NAMES[[kk]]
[16:12:26.927]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.927]                     next
[16:12:26.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.927]                 }
[16:12:26.927]                 if (length(args) > 0) 
[16:12:26.927]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.927]             }
[16:12:26.927]             else {
[16:12:26.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.927]             }
[16:12:26.927]             {
[16:12:26.927]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.927]                   0L) {
[16:12:26.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.927]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.927]                   base::options(opts)
[16:12:26.927]                 }
[16:12:26.927]                 {
[16:12:26.927]                   {
[16:12:26.927]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:26.927]                     NULL
[16:12:26.927]                   }
[16:12:26.927]                   options(future.plan = NULL)
[16:12:26.927]                   if (is.na(NA_character_)) 
[16:12:26.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.927]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:26.927]                     envir = parent.frame()) 
[16:12:26.927]                   {
[16:12:26.927]                     default_workers <- missing(workers)
[16:12:26.927]                     if (is.function(workers)) 
[16:12:26.927]                       workers <- workers()
[16:12:26.927]                     workers <- structure(as.integer(workers), 
[16:12:26.927]                       class = class(workers))
[16:12:26.927]                     stop_if_not(is.finite(workers), workers >= 
[16:12:26.927]                       1L)
[16:12:26.927]                     if ((workers == 1L && !inherits(workers, 
[16:12:26.927]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:26.927]                       if (default_workers) 
[16:12:26.927]                         supportsMulticore(warn = TRUE)
[16:12:26.927]                       return(sequential(..., envir = envir))
[16:12:26.927]                     }
[16:12:26.927]                     oopts <- options(mc.cores = workers)
[16:12:26.927]                     on.exit(options(oopts))
[16:12:26.927]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:26.927]                       envir = envir)
[16:12:26.927]                     if (!future$lazy) 
[16:12:26.927]                       future <- run(future)
[16:12:26.927]                     invisible(future)
[16:12:26.927]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.927]                 }
[16:12:26.927]             }
[16:12:26.927]         }
[16:12:26.927]     })
[16:12:26.927]     if (TRUE) {
[16:12:26.927]         base::sink(type = "output", split = FALSE)
[16:12:26.927]         if (TRUE) {
[16:12:26.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.927]         }
[16:12:26.927]         else {
[16:12:26.927]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.927]         }
[16:12:26.927]         base::close(...future.stdout)
[16:12:26.927]         ...future.stdout <- NULL
[16:12:26.927]     }
[16:12:26.927]     ...future.result$conditions <- ...future.conditions
[16:12:26.927]     ...future.result$finished <- base::Sys.time()
[16:12:26.927]     ...future.result
[16:12:26.927] }
[16:12:26.930] requestCore(): workers = 2
[16:12:26.932] MulticoreFuture started
[16:12:26.933] - Launch lazy future ... done
[16:12:26.933] plan(): Setting new future strategy stack:
[16:12:26.933] run() for ‘MulticoreFuture’ ... done
[16:12:26.934] getGlobalsAndPackages() ...
[16:12:26.934] Searching for globals...
[16:12:26.933] List of future strategies:
[16:12:26.933] 1. sequential:
[16:12:26.933]    - args: function (..., envir = parent.frame())
[16:12:26.933]    - tweaked: FALSE
[16:12:26.933]    - call: NULL
[16:12:26.934] plan(): nbrOfWorkers() = 1
[16:12:26.935] 
[16:12:26.935] Searching for globals ... DONE
[16:12:26.935] - globals: [0] <none>
[16:12:26.936] getGlobalsAndPackages() ... DONE
[16:12:26.936] plan(): Setting new future strategy stack:
[16:12:26.936] run() for ‘Future’ ...
[16:12:26.937] - state: ‘created’
[16:12:26.937] List of future strategies:
[16:12:26.937] 1. multicore:
[16:12:26.937]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:26.937]    - tweaked: FALSE
[16:12:26.937]    - call: plan(strategy)
[16:12:26.937] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:26.941] plan(): nbrOfWorkers() = 2
[16:12:26.941] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:26.942] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:26.942]   - Field: ‘label’
[16:12:26.942]   - Field: ‘local’
[16:12:26.942]   - Field: ‘owner’
[16:12:26.942]   - Field: ‘envir’
[16:12:26.943]   - Field: ‘workers’
[16:12:26.943]   - Field: ‘packages’
[16:12:26.943]   - Field: ‘gc’
[16:12:26.943]   - Field: ‘job’
[16:12:26.943]   - Field: ‘conditions’
[16:12:26.943]   - Field: ‘expr’
[16:12:26.943]   - Field: ‘uuid’
[16:12:26.944]   - Field: ‘seed’
[16:12:26.944]   - Field: ‘version’
[16:12:26.944]   - Field: ‘result’
[16:12:26.944]   - Field: ‘asynchronous’
[16:12:26.944]   - Field: ‘calls’
[16:12:26.944]   - Field: ‘globals’
[16:12:26.945]   - Field: ‘stdout’
[16:12:26.945]   - Field: ‘earlySignal’
[16:12:26.945]   - Field: ‘lazy’
[16:12:26.945]   - Field: ‘state’
[16:12:26.945] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:26.945] - Launch lazy future ...
[16:12:26.946] Packages needed by the future expression (n = 0): <none>
[16:12:26.946] Packages needed by future strategies (n = 0): <none>
[16:12:26.947] {
[16:12:26.947]     {
[16:12:26.947]         {
[16:12:26.947]             ...future.startTime <- base::Sys.time()
[16:12:26.947]             {
[16:12:26.947]                 {
[16:12:26.947]                   {
[16:12:26.947]                     {
[16:12:26.947]                       base::local({
[16:12:26.947]                         has_future <- base::requireNamespace("future", 
[16:12:26.947]                           quietly = TRUE)
[16:12:26.947]                         if (has_future) {
[16:12:26.947]                           ns <- base::getNamespace("future")
[16:12:26.947]                           version <- ns[[".package"]][["version"]]
[16:12:26.947]                           if (is.null(version)) 
[16:12:26.947]                             version <- utils::packageVersion("future")
[16:12:26.947]                         }
[16:12:26.947]                         else {
[16:12:26.947]                           version <- NULL
[16:12:26.947]                         }
[16:12:26.947]                         if (!has_future || version < "1.8.0") {
[16:12:26.947]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:26.947]                             "", base::R.version$version.string), 
[16:12:26.947]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:26.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:26.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:26.947]                               "release", "version")], collapse = " "), 
[16:12:26.947]                             hostname = base::Sys.info()[["nodename"]])
[16:12:26.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:26.947]                             info)
[16:12:26.947]                           info <- base::paste(info, collapse = "; ")
[16:12:26.947]                           if (!has_future) {
[16:12:26.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:26.947]                               info)
[16:12:26.947]                           }
[16:12:26.947]                           else {
[16:12:26.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:26.947]                               info, version)
[16:12:26.947]                           }
[16:12:26.947]                           base::stop(msg)
[16:12:26.947]                         }
[16:12:26.947]                       })
[16:12:26.947]                     }
[16:12:26.947]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:26.947]                     base::options(mc.cores = 1L)
[16:12:26.947]                   }
[16:12:26.947]                   options(future.plan = NULL)
[16:12:26.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:26.947]                 }
[16:12:26.947]                 ...future.workdir <- getwd()
[16:12:26.947]             }
[16:12:26.947]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:26.947]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:26.947]         }
[16:12:26.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:26.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:26.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:26.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:26.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:26.947]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:26.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:26.947]             base::names(...future.oldOptions))
[16:12:26.947]     }
[16:12:26.947]     if (FALSE) {
[16:12:26.947]     }
[16:12:26.947]     else {
[16:12:26.947]         if (TRUE) {
[16:12:26.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:26.947]                 open = "w")
[16:12:26.947]         }
[16:12:26.947]         else {
[16:12:26.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:26.947]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:26.947]         }
[16:12:26.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:26.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:26.947]             base::sink(type = "output", split = FALSE)
[16:12:26.947]             base::close(...future.stdout)
[16:12:26.947]         }, add = TRUE)
[16:12:26.947]     }
[16:12:26.947]     ...future.frame <- base::sys.nframe()
[16:12:26.947]     ...future.conditions <- base::list()
[16:12:26.947]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:26.947]     if (FALSE) {
[16:12:26.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:26.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:26.947]     }
[16:12:26.947]     ...future.result <- base::tryCatch({
[16:12:26.947]         base::withCallingHandlers({
[16:12:26.947]             ...future.value <- base::withVisible(base::local({
[16:12:26.947]                 withCallingHandlers({
[16:12:26.947]                   NULL
[16:12:26.947]                 }, immediateCondition = function(cond) {
[16:12:26.947]                   save_rds <- function (object, pathname, ...) 
[16:12:26.947]                   {
[16:12:26.947]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:26.947]                     if (file_test("-f", pathname_tmp)) {
[16:12:26.947]                       fi_tmp <- file.info(pathname_tmp)
[16:12:26.947]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:26.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:26.947]                         fi_tmp[["mtime"]])
[16:12:26.947]                     }
[16:12:26.947]                     tryCatch({
[16:12:26.947]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:26.947]                     }, error = function(ex) {
[16:12:26.947]                       msg <- conditionMessage(ex)
[16:12:26.947]                       fi_tmp <- file.info(pathname_tmp)
[16:12:26.947]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:26.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:26.947]                         fi_tmp[["mtime"]], msg)
[16:12:26.947]                       ex$message <- msg
[16:12:26.947]                       stop(ex)
[16:12:26.947]                     })
[16:12:26.947]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:26.947]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:26.947]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:26.947]                       fi_tmp <- file.info(pathname_tmp)
[16:12:26.947]                       fi <- file.info(pathname)
[16:12:26.947]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:26.947]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:26.947]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:26.947]                         fi[["size"]], fi[["mtime"]])
[16:12:26.947]                       stop(msg)
[16:12:26.947]                     }
[16:12:26.947]                     invisible(pathname)
[16:12:26.947]                   }
[16:12:26.947]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:26.947]                     rootPath = tempdir()) 
[16:12:26.947]                   {
[16:12:26.947]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:26.947]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:26.947]                       tmpdir = path, fileext = ".rds")
[16:12:26.947]                     save_rds(obj, file)
[16:12:26.947]                   }
[16:12:26.947]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:26.947]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.947]                   {
[16:12:26.947]                     inherits <- base::inherits
[16:12:26.947]                     invokeRestart <- base::invokeRestart
[16:12:26.947]                     is.null <- base::is.null
[16:12:26.947]                     muffled <- FALSE
[16:12:26.947]                     if (inherits(cond, "message")) {
[16:12:26.947]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:26.947]                       if (muffled) 
[16:12:26.947]                         invokeRestart("muffleMessage")
[16:12:26.947]                     }
[16:12:26.947]                     else if (inherits(cond, "warning")) {
[16:12:26.947]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:26.947]                       if (muffled) 
[16:12:26.947]                         invokeRestart("muffleWarning")
[16:12:26.947]                     }
[16:12:26.947]                     else if (inherits(cond, "condition")) {
[16:12:26.947]                       if (!is.null(pattern)) {
[16:12:26.947]                         computeRestarts <- base::computeRestarts
[16:12:26.947]                         grepl <- base::grepl
[16:12:26.947]                         restarts <- computeRestarts(cond)
[16:12:26.947]                         for (restart in restarts) {
[16:12:26.947]                           name <- restart$name
[16:12:26.947]                           if (is.null(name)) 
[16:12:26.947]                             next
[16:12:26.947]                           if (!grepl(pattern, name)) 
[16:12:26.947]                             next
[16:12:26.947]                           invokeRestart(restart)
[16:12:26.947]                           muffled <- TRUE
[16:12:26.947]                           break
[16:12:26.947]                         }
[16:12:26.947]                       }
[16:12:26.947]                     }
[16:12:26.947]                     invisible(muffled)
[16:12:26.947]                   }
[16:12:26.947]                   muffleCondition(cond)
[16:12:26.947]                 })
[16:12:26.947]             }))
[16:12:26.947]             future::FutureResult(value = ...future.value$value, 
[16:12:26.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.947]                   ...future.rng), globalenv = if (FALSE) 
[16:12:26.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:26.947]                     ...future.globalenv.names))
[16:12:26.947]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:26.947]         }, condition = base::local({
[16:12:26.947]             c <- base::c
[16:12:26.947]             inherits <- base::inherits
[16:12:26.947]             invokeRestart <- base::invokeRestart
[16:12:26.947]             length <- base::length
[16:12:26.947]             list <- base::list
[16:12:26.947]             seq.int <- base::seq.int
[16:12:26.947]             signalCondition <- base::signalCondition
[16:12:26.947]             sys.calls <- base::sys.calls
[16:12:26.947]             `[[` <- base::`[[`
[16:12:26.947]             `+` <- base::`+`
[16:12:26.947]             `<<-` <- base::`<<-`
[16:12:26.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:26.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:26.947]                   3L)]
[16:12:26.947]             }
[16:12:26.947]             function(cond) {
[16:12:26.947]                 is_error <- inherits(cond, "error")
[16:12:26.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:26.947]                   NULL)
[16:12:26.947]                 if (is_error) {
[16:12:26.947]                   sessionInformation <- function() {
[16:12:26.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:26.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:26.947]                       search = base::search(), system = base::Sys.info())
[16:12:26.947]                   }
[16:12:26.947]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:26.947]                     cond$call), session = sessionInformation(), 
[16:12:26.947]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:26.947]                   signalCondition(cond)
[16:12:26.947]                 }
[16:12:26.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:26.947]                 "immediateCondition"))) {
[16:12:26.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:26.947]                   ...future.conditions[[length(...future.conditions) + 
[16:12:26.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:26.947]                   if (TRUE && !signal) {
[16:12:26.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.947]                     {
[16:12:26.947]                       inherits <- base::inherits
[16:12:26.947]                       invokeRestart <- base::invokeRestart
[16:12:26.947]                       is.null <- base::is.null
[16:12:26.947]                       muffled <- FALSE
[16:12:26.947]                       if (inherits(cond, "message")) {
[16:12:26.947]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.947]                         if (muffled) 
[16:12:26.947]                           invokeRestart("muffleMessage")
[16:12:26.947]                       }
[16:12:26.947]                       else if (inherits(cond, "warning")) {
[16:12:26.947]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.947]                         if (muffled) 
[16:12:26.947]                           invokeRestart("muffleWarning")
[16:12:26.947]                       }
[16:12:26.947]                       else if (inherits(cond, "condition")) {
[16:12:26.947]                         if (!is.null(pattern)) {
[16:12:26.947]                           computeRestarts <- base::computeRestarts
[16:12:26.947]                           grepl <- base::grepl
[16:12:26.947]                           restarts <- computeRestarts(cond)
[16:12:26.947]                           for (restart in restarts) {
[16:12:26.947]                             name <- restart$name
[16:12:26.947]                             if (is.null(name)) 
[16:12:26.947]                               next
[16:12:26.947]                             if (!grepl(pattern, name)) 
[16:12:26.947]                               next
[16:12:26.947]                             invokeRestart(restart)
[16:12:26.947]                             muffled <- TRUE
[16:12:26.947]                             break
[16:12:26.947]                           }
[16:12:26.947]                         }
[16:12:26.947]                       }
[16:12:26.947]                       invisible(muffled)
[16:12:26.947]                     }
[16:12:26.947]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.947]                   }
[16:12:26.947]                 }
[16:12:26.947]                 else {
[16:12:26.947]                   if (TRUE) {
[16:12:26.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:26.947]                     {
[16:12:26.947]                       inherits <- base::inherits
[16:12:26.947]                       invokeRestart <- base::invokeRestart
[16:12:26.947]                       is.null <- base::is.null
[16:12:26.947]                       muffled <- FALSE
[16:12:26.947]                       if (inherits(cond, "message")) {
[16:12:26.947]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:26.947]                         if (muffled) 
[16:12:26.947]                           invokeRestart("muffleMessage")
[16:12:26.947]                       }
[16:12:26.947]                       else if (inherits(cond, "warning")) {
[16:12:26.947]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:26.947]                         if (muffled) 
[16:12:26.947]                           invokeRestart("muffleWarning")
[16:12:26.947]                       }
[16:12:26.947]                       else if (inherits(cond, "condition")) {
[16:12:26.947]                         if (!is.null(pattern)) {
[16:12:26.947]                           computeRestarts <- base::computeRestarts
[16:12:26.947]                           grepl <- base::grepl
[16:12:26.947]                           restarts <- computeRestarts(cond)
[16:12:26.947]                           for (restart in restarts) {
[16:12:26.947]                             name <- restart$name
[16:12:26.947]                             if (is.null(name)) 
[16:12:26.947]                               next
[16:12:26.947]                             if (!grepl(pattern, name)) 
[16:12:26.947]                               next
[16:12:26.947]                             invokeRestart(restart)
[16:12:26.947]                             muffled <- TRUE
[16:12:26.947]                             break
[16:12:26.947]                           }
[16:12:26.947]                         }
[16:12:26.947]                       }
[16:12:26.947]                       invisible(muffled)
[16:12:26.947]                     }
[16:12:26.947]                     muffleCondition(cond, pattern = "^muffle")
[16:12:26.947]                   }
[16:12:26.947]                 }
[16:12:26.947]             }
[16:12:26.947]         }))
[16:12:26.947]     }, error = function(ex) {
[16:12:26.947]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:26.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:26.947]                 ...future.rng), started = ...future.startTime, 
[16:12:26.947]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:26.947]             version = "1.8"), class = "FutureResult")
[16:12:26.947]     }, finally = {
[16:12:26.947]         if (!identical(...future.workdir, getwd())) 
[16:12:26.947]             setwd(...future.workdir)
[16:12:26.947]         {
[16:12:26.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:26.947]                 ...future.oldOptions$nwarnings <- NULL
[16:12:26.947]             }
[16:12:26.947]             base::options(...future.oldOptions)
[16:12:26.947]             if (.Platform$OS.type == "windows") {
[16:12:26.947]                 old_names <- names(...future.oldEnvVars)
[16:12:26.947]                 envs <- base::Sys.getenv()
[16:12:26.947]                 names <- names(envs)
[16:12:26.947]                 common <- intersect(names, old_names)
[16:12:26.947]                 added <- setdiff(names, old_names)
[16:12:26.947]                 removed <- setdiff(old_names, names)
[16:12:26.947]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:26.947]                   envs[common]]
[16:12:26.947]                 NAMES <- toupper(changed)
[16:12:26.947]                 args <- list()
[16:12:26.947]                 for (kk in seq_along(NAMES)) {
[16:12:26.947]                   name <- changed[[kk]]
[16:12:26.947]                   NAME <- NAMES[[kk]]
[16:12:26.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.947]                     next
[16:12:26.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.947]                 }
[16:12:26.947]                 NAMES <- toupper(added)
[16:12:26.947]                 for (kk in seq_along(NAMES)) {
[16:12:26.947]                   name <- added[[kk]]
[16:12:26.947]                   NAME <- NAMES[[kk]]
[16:12:26.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.947]                     next
[16:12:26.947]                   args[[name]] <- ""
[16:12:26.947]                 }
[16:12:26.947]                 NAMES <- toupper(removed)
[16:12:26.947]                 for (kk in seq_along(NAMES)) {
[16:12:26.947]                   name <- removed[[kk]]
[16:12:26.947]                   NAME <- NAMES[[kk]]
[16:12:26.947]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:26.947]                     next
[16:12:26.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:26.947]                 }
[16:12:26.947]                 if (length(args) > 0) 
[16:12:26.947]                   base::do.call(base::Sys.setenv, args = args)
[16:12:26.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:26.947]             }
[16:12:26.947]             else {
[16:12:26.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:26.947]             }
[16:12:26.947]             {
[16:12:26.947]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:26.947]                   0L) {
[16:12:26.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:26.947]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:26.947]                   base::options(opts)
[16:12:26.947]                 }
[16:12:26.947]                 {
[16:12:26.947]                   {
[16:12:26.947]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:26.947]                     NULL
[16:12:26.947]                   }
[16:12:26.947]                   options(future.plan = NULL)
[16:12:26.947]                   if (is.na(NA_character_)) 
[16:12:26.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:26.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:26.947]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:26.947]                     envir = parent.frame()) 
[16:12:26.947]                   {
[16:12:26.947]                     default_workers <- missing(workers)
[16:12:26.947]                     if (is.function(workers)) 
[16:12:26.947]                       workers <- workers()
[16:12:26.947]                     workers <- structure(as.integer(workers), 
[16:12:26.947]                       class = class(workers))
[16:12:26.947]                     stop_if_not(is.finite(workers), workers >= 
[16:12:26.947]                       1L)
[16:12:26.947]                     if ((workers == 1L && !inherits(workers, 
[16:12:26.947]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:26.947]                       if (default_workers) 
[16:12:26.947]                         supportsMulticore(warn = TRUE)
[16:12:26.947]                       return(sequential(..., envir = envir))
[16:12:26.947]                     }
[16:12:26.947]                     oopts <- options(mc.cores = workers)
[16:12:26.947]                     on.exit(options(oopts))
[16:12:26.947]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:26.947]                       envir = envir)
[16:12:26.947]                     if (!future$lazy) 
[16:12:26.947]                       future <- run(future)
[16:12:26.947]                     invisible(future)
[16:12:26.947]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:26.947]                 }
[16:12:26.947]             }
[16:12:26.947]         }
[16:12:26.947]     })
[16:12:26.947]     if (TRUE) {
[16:12:26.947]         base::sink(type = "output", split = FALSE)
[16:12:26.947]         if (TRUE) {
[16:12:26.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:26.947]         }
[16:12:26.947]         else {
[16:12:26.947]             ...future.result["stdout"] <- base::list(NULL)
[16:12:26.947]         }
[16:12:26.947]         base::close(...future.stdout)
[16:12:26.947]         ...future.stdout <- NULL
[16:12:26.947]     }
[16:12:26.947]     ...future.result$conditions <- ...future.conditions
[16:12:26.947]     ...future.result$finished <- base::Sys.time()
[16:12:26.947]     ...future.result
[16:12:26.947] }
[16:12:26.951] requestCore(): workers = 2
[16:12:26.957] MulticoreFuture started
[16:12:26.957] - Launch lazy future ... done
[16:12:26.957] run() for ‘MulticoreFuture’ ... done
List of 6
[16:12:26.958] plan(): Setting new future strategy stack:
 $ a:[16:12:26.958] List of future strategies:
[16:12:26.958] 1. sequential:
[16:12:26.958]    - args: function (..., envir = parent.frame())
[16:12:26.958]    - tweaked: FALSE
[16:12:26.958]    - call: NULL
 num 1
 $ b:[16:12:26.959] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bad68d470> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae5e3a98> 
 $  : NULL
 $  : NULL
 $  :[16:12:26.961] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[16:12:26.961] List of future strategies:
[16:12:26.961] 1. multicore:
[16:12:26.961]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:26.961]    - tweaked: FALSE
[16:12:26.961]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bad68d470> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae5e3a98> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:12:26.966] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:26.968] resolve() on list ...
[16:12:26.968]  recursive: 0
[16:12:26.968]  length: 6
[16:12:26.968]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:26.968] signalConditionsASAP(numeric, pos=1) ...
[16:12:26.968] - nx: 6
[16:12:26.973] - relay: TRUE
[16:12:26.973] - stdout: TRUE
[16:12:26.974] - signal: TRUE
[16:12:26.974] - resignal: FALSE
[16:12:26.974] - force: TRUE
[16:12:26.974] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.975] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.975]  - until=2
[16:12:26.975]  - relaying element #2
[16:12:26.975] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.976] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.976] signalConditionsASAP(NULL, pos=1) ... done
[16:12:26.976]  length: 5 (resolved future 1)
[16:12:26.977] Future #2
[16:12:26.979] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:26.979] - nx: 6
[16:12:26.979] - relay: TRUE
[16:12:26.979] - stdout: TRUE
[16:12:26.979] - signal: TRUE
[16:12:26.980] - resignal: FALSE
[16:12:26.980] - force: TRUE
[16:12:26.980] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.980] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:26.980]  - until=2
[16:12:26.980]  - relaying element #2
[16:12:26.981] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.981] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.981] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:26.981]  length: 4 (resolved future 2)
[16:12:26.982] Future #3
[16:12:26.983] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:26.983] - nx: 6
[16:12:26.983] - relay: TRUE
[16:12:26.983] - stdout: TRUE
[16:12:26.983] - signal: TRUE
[16:12:26.984] - resignal: FALSE
[16:12:26.984] - force: TRUE
[16:12:26.984] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.984] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:26.984]  - until=3
[16:12:26.984]  - relaying element #3
[16:12:26.985] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.985] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.985] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:26.985]  length: 3 (resolved future 3)
[16:12:26.985] signalConditionsASAP(NULL, pos=4) ...
[16:12:26.986] - nx: 6
[16:12:26.986] - relay: TRUE
[16:12:26.986] - stdout: TRUE
[16:12:26.986] - signal: TRUE
[16:12:26.986] - resignal: FALSE
[16:12:26.986] - force: TRUE
[16:12:26.986] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.986] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.986]  - until=5
[16:12:26.987]  - relaying element #5
[16:12:26.987] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.987] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.987] signalConditionsASAP(NULL, pos=4) ... done
[16:12:26.987]  length: 2 (resolved future 4)
[16:12:26.987] signalConditionsASAP(NULL, pos=5) ...
[16:12:26.987] - nx: 6
[16:12:26.987] - relay: TRUE
[16:12:26.987] - stdout: TRUE
[16:12:26.987] - signal: TRUE
[16:12:26.988] - resignal: FALSE
[16:12:26.988] - force: TRUE
[16:12:26.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:26.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.988]  - until=6
[16:12:26.988]  - relaying element #6
[16:12:26.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.988] signalConditionsASAP(NULL, pos=5) ... done
[16:12:26.988]  length: 1 (resolved future 5)
[16:12:26.989] signalConditionsASAP(numeric, pos=6) ...
[16:12:26.989] - nx: 6
[16:12:26.989] - relay: TRUE
[16:12:26.989] - stdout: TRUE
[16:12:26.989] - signal: TRUE
[16:12:26.989] - resignal: FALSE
[16:12:26.989] - force: TRUE
[16:12:26.989] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:26.989] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.989]  - until=6
[16:12:26.990] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.990] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.990] signalConditionsASAP(numeric, pos=6) ... done
[16:12:26.990]  length: 0 (resolved future 6)
[16:12:26.990] Relaying remaining futures
[16:12:26.990] signalConditionsASAP(NULL, pos=0) ...
[16:12:26.990] - nx: 6
[16:12:26.990] - relay: TRUE
[16:12:26.990] - stdout: TRUE
[16:12:26.990] - signal: TRUE
[16:12:26.991] - resignal: FALSE
[16:12:26.991] - force: TRUE
[16:12:26.991] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.991] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:26.991] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:26.991] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:26.991] signalConditionsASAP(NULL, pos=0) ... done
[16:12:26.991] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:12:26.994] getGlobalsAndPackages() ...
[16:12:26.994] Searching for globals...
[16:12:26.994] 
[16:12:26.994] Searching for globals ... DONE
[16:12:26.994] - globals: [0] <none>
[16:12:26.995] getGlobalsAndPackages() ... DONE
[16:12:26.995] run() for ‘Future’ ...
[16:12:26.995] - state: ‘created’
[16:12:26.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:26.999] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:26.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:26.999]   - Field: ‘label’
[16:12:26.999]   - Field: ‘local’
[16:12:26.999]   - Field: ‘owner’
[16:12:27.000]   - Field: ‘envir’
[16:12:27.000]   - Field: ‘workers’
[16:12:27.000]   - Field: ‘packages’
[16:12:27.000]   - Field: ‘gc’
[16:12:27.000]   - Field: ‘job’
[16:12:27.000]   - Field: ‘conditions’
[16:12:27.000]   - Field: ‘expr’
[16:12:27.000]   - Field: ‘uuid’
[16:12:27.000]   - Field: ‘seed’
[16:12:27.001]   - Field: ‘version’
[16:12:27.001]   - Field: ‘result’
[16:12:27.001]   - Field: ‘asynchronous’
[16:12:27.001]   - Field: ‘calls’
[16:12:27.001]   - Field: ‘globals’
[16:12:27.001]   - Field: ‘stdout’
[16:12:27.001]   - Field: ‘earlySignal’
[16:12:27.001]   - Field: ‘lazy’
[16:12:27.001]   - Field: ‘state’
[16:12:27.001] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.002] - Launch lazy future ...
[16:12:27.002] Packages needed by the future expression (n = 0): <none>
[16:12:27.002] Packages needed by future strategies (n = 0): <none>
[16:12:27.002] {
[16:12:27.002]     {
[16:12:27.002]         {
[16:12:27.002]             ...future.startTime <- base::Sys.time()
[16:12:27.002]             {
[16:12:27.002]                 {
[16:12:27.002]                   {
[16:12:27.002]                     {
[16:12:27.002]                       base::local({
[16:12:27.002]                         has_future <- base::requireNamespace("future", 
[16:12:27.002]                           quietly = TRUE)
[16:12:27.002]                         if (has_future) {
[16:12:27.002]                           ns <- base::getNamespace("future")
[16:12:27.002]                           version <- ns[[".package"]][["version"]]
[16:12:27.002]                           if (is.null(version)) 
[16:12:27.002]                             version <- utils::packageVersion("future")
[16:12:27.002]                         }
[16:12:27.002]                         else {
[16:12:27.002]                           version <- NULL
[16:12:27.002]                         }
[16:12:27.002]                         if (!has_future || version < "1.8.0") {
[16:12:27.002]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.002]                             "", base::R.version$version.string), 
[16:12:27.002]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.002]                               "release", "version")], collapse = " "), 
[16:12:27.002]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.002]                             info)
[16:12:27.002]                           info <- base::paste(info, collapse = "; ")
[16:12:27.002]                           if (!has_future) {
[16:12:27.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.002]                               info)
[16:12:27.002]                           }
[16:12:27.002]                           else {
[16:12:27.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.002]                               info, version)
[16:12:27.002]                           }
[16:12:27.002]                           base::stop(msg)
[16:12:27.002]                         }
[16:12:27.002]                       })
[16:12:27.002]                     }
[16:12:27.002]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.002]                     base::options(mc.cores = 1L)
[16:12:27.002]                   }
[16:12:27.002]                   options(future.plan = NULL)
[16:12:27.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.002]                 }
[16:12:27.002]                 ...future.workdir <- getwd()
[16:12:27.002]             }
[16:12:27.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.002]         }
[16:12:27.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.002]             base::names(...future.oldOptions))
[16:12:27.002]     }
[16:12:27.002]     if (FALSE) {
[16:12:27.002]     }
[16:12:27.002]     else {
[16:12:27.002]         if (TRUE) {
[16:12:27.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.002]                 open = "w")
[16:12:27.002]         }
[16:12:27.002]         else {
[16:12:27.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.002]         }
[16:12:27.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.002]             base::sink(type = "output", split = FALSE)
[16:12:27.002]             base::close(...future.stdout)
[16:12:27.002]         }, add = TRUE)
[16:12:27.002]     }
[16:12:27.002]     ...future.frame <- base::sys.nframe()
[16:12:27.002]     ...future.conditions <- base::list()
[16:12:27.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.002]     if (FALSE) {
[16:12:27.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.002]     }
[16:12:27.002]     ...future.result <- base::tryCatch({
[16:12:27.002]         base::withCallingHandlers({
[16:12:27.002]             ...future.value <- base::withVisible(base::local({
[16:12:27.002]                 withCallingHandlers({
[16:12:27.002]                   2
[16:12:27.002]                 }, immediateCondition = function(cond) {
[16:12:27.002]                   save_rds <- function (object, pathname, ...) 
[16:12:27.002]                   {
[16:12:27.002]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.002]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.002]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.002]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.002]                         fi_tmp[["mtime"]])
[16:12:27.002]                     }
[16:12:27.002]                     tryCatch({
[16:12:27.002]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.002]                     }, error = function(ex) {
[16:12:27.002]                       msg <- conditionMessage(ex)
[16:12:27.002]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.002]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.002]                         fi_tmp[["mtime"]], msg)
[16:12:27.002]                       ex$message <- msg
[16:12:27.002]                       stop(ex)
[16:12:27.002]                     })
[16:12:27.002]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.002]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.002]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.002]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.002]                       fi <- file.info(pathname)
[16:12:27.002]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.002]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.002]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.002]                         fi[["size"]], fi[["mtime"]])
[16:12:27.002]                       stop(msg)
[16:12:27.002]                     }
[16:12:27.002]                     invisible(pathname)
[16:12:27.002]                   }
[16:12:27.002]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.002]                     rootPath = tempdir()) 
[16:12:27.002]                   {
[16:12:27.002]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.002]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.002]                       tmpdir = path, fileext = ".rds")
[16:12:27.002]                     save_rds(obj, file)
[16:12:27.002]                   }
[16:12:27.002]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.002]                   {
[16:12:27.002]                     inherits <- base::inherits
[16:12:27.002]                     invokeRestart <- base::invokeRestart
[16:12:27.002]                     is.null <- base::is.null
[16:12:27.002]                     muffled <- FALSE
[16:12:27.002]                     if (inherits(cond, "message")) {
[16:12:27.002]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.002]                       if (muffled) 
[16:12:27.002]                         invokeRestart("muffleMessage")
[16:12:27.002]                     }
[16:12:27.002]                     else if (inherits(cond, "warning")) {
[16:12:27.002]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.002]                       if (muffled) 
[16:12:27.002]                         invokeRestart("muffleWarning")
[16:12:27.002]                     }
[16:12:27.002]                     else if (inherits(cond, "condition")) {
[16:12:27.002]                       if (!is.null(pattern)) {
[16:12:27.002]                         computeRestarts <- base::computeRestarts
[16:12:27.002]                         grepl <- base::grepl
[16:12:27.002]                         restarts <- computeRestarts(cond)
[16:12:27.002]                         for (restart in restarts) {
[16:12:27.002]                           name <- restart$name
[16:12:27.002]                           if (is.null(name)) 
[16:12:27.002]                             next
[16:12:27.002]                           if (!grepl(pattern, name)) 
[16:12:27.002]                             next
[16:12:27.002]                           invokeRestart(restart)
[16:12:27.002]                           muffled <- TRUE
[16:12:27.002]                           break
[16:12:27.002]                         }
[16:12:27.002]                       }
[16:12:27.002]                     }
[16:12:27.002]                     invisible(muffled)
[16:12:27.002]                   }
[16:12:27.002]                   muffleCondition(cond)
[16:12:27.002]                 })
[16:12:27.002]             }))
[16:12:27.002]             future::FutureResult(value = ...future.value$value, 
[16:12:27.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.002]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.002]                     ...future.globalenv.names))
[16:12:27.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.002]         }, condition = base::local({
[16:12:27.002]             c <- base::c
[16:12:27.002]             inherits <- base::inherits
[16:12:27.002]             invokeRestart <- base::invokeRestart
[16:12:27.002]             length <- base::length
[16:12:27.002]             list <- base::list
[16:12:27.002]             seq.int <- base::seq.int
[16:12:27.002]             signalCondition <- base::signalCondition
[16:12:27.002]             sys.calls <- base::sys.calls
[16:12:27.002]             `[[` <- base::`[[`
[16:12:27.002]             `+` <- base::`+`
[16:12:27.002]             `<<-` <- base::`<<-`
[16:12:27.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.002]                   3L)]
[16:12:27.002]             }
[16:12:27.002]             function(cond) {
[16:12:27.002]                 is_error <- inherits(cond, "error")
[16:12:27.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.002]                   NULL)
[16:12:27.002]                 if (is_error) {
[16:12:27.002]                   sessionInformation <- function() {
[16:12:27.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.002]                       search = base::search(), system = base::Sys.info())
[16:12:27.002]                   }
[16:12:27.002]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.002]                     cond$call), session = sessionInformation(), 
[16:12:27.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.002]                   signalCondition(cond)
[16:12:27.002]                 }
[16:12:27.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.002]                 "immediateCondition"))) {
[16:12:27.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.002]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.002]                   if (TRUE && !signal) {
[16:12:27.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.002]                     {
[16:12:27.002]                       inherits <- base::inherits
[16:12:27.002]                       invokeRestart <- base::invokeRestart
[16:12:27.002]                       is.null <- base::is.null
[16:12:27.002]                       muffled <- FALSE
[16:12:27.002]                       if (inherits(cond, "message")) {
[16:12:27.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.002]                         if (muffled) 
[16:12:27.002]                           invokeRestart("muffleMessage")
[16:12:27.002]                       }
[16:12:27.002]                       else if (inherits(cond, "warning")) {
[16:12:27.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.002]                         if (muffled) 
[16:12:27.002]                           invokeRestart("muffleWarning")
[16:12:27.002]                       }
[16:12:27.002]                       else if (inherits(cond, "condition")) {
[16:12:27.002]                         if (!is.null(pattern)) {
[16:12:27.002]                           computeRestarts <- base::computeRestarts
[16:12:27.002]                           grepl <- base::grepl
[16:12:27.002]                           restarts <- computeRestarts(cond)
[16:12:27.002]                           for (restart in restarts) {
[16:12:27.002]                             name <- restart$name
[16:12:27.002]                             if (is.null(name)) 
[16:12:27.002]                               next
[16:12:27.002]                             if (!grepl(pattern, name)) 
[16:12:27.002]                               next
[16:12:27.002]                             invokeRestart(restart)
[16:12:27.002]                             muffled <- TRUE
[16:12:27.002]                             break
[16:12:27.002]                           }
[16:12:27.002]                         }
[16:12:27.002]                       }
[16:12:27.002]                       invisible(muffled)
[16:12:27.002]                     }
[16:12:27.002]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.002]                   }
[16:12:27.002]                 }
[16:12:27.002]                 else {
[16:12:27.002]                   if (TRUE) {
[16:12:27.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.002]                     {
[16:12:27.002]                       inherits <- base::inherits
[16:12:27.002]                       invokeRestart <- base::invokeRestart
[16:12:27.002]                       is.null <- base::is.null
[16:12:27.002]                       muffled <- FALSE
[16:12:27.002]                       if (inherits(cond, "message")) {
[16:12:27.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.002]                         if (muffled) 
[16:12:27.002]                           invokeRestart("muffleMessage")
[16:12:27.002]                       }
[16:12:27.002]                       else if (inherits(cond, "warning")) {
[16:12:27.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.002]                         if (muffled) 
[16:12:27.002]                           invokeRestart("muffleWarning")
[16:12:27.002]                       }
[16:12:27.002]                       else if (inherits(cond, "condition")) {
[16:12:27.002]                         if (!is.null(pattern)) {
[16:12:27.002]                           computeRestarts <- base::computeRestarts
[16:12:27.002]                           grepl <- base::grepl
[16:12:27.002]                           restarts <- computeRestarts(cond)
[16:12:27.002]                           for (restart in restarts) {
[16:12:27.002]                             name <- restart$name
[16:12:27.002]                             if (is.null(name)) 
[16:12:27.002]                               next
[16:12:27.002]                             if (!grepl(pattern, name)) 
[16:12:27.002]                               next
[16:12:27.002]                             invokeRestart(restart)
[16:12:27.002]                             muffled <- TRUE
[16:12:27.002]                             break
[16:12:27.002]                           }
[16:12:27.002]                         }
[16:12:27.002]                       }
[16:12:27.002]                       invisible(muffled)
[16:12:27.002]                     }
[16:12:27.002]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.002]                   }
[16:12:27.002]                 }
[16:12:27.002]             }
[16:12:27.002]         }))
[16:12:27.002]     }, error = function(ex) {
[16:12:27.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.002]                 ...future.rng), started = ...future.startTime, 
[16:12:27.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.002]             version = "1.8"), class = "FutureResult")
[16:12:27.002]     }, finally = {
[16:12:27.002]         if (!identical(...future.workdir, getwd())) 
[16:12:27.002]             setwd(...future.workdir)
[16:12:27.002]         {
[16:12:27.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.002]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.002]             }
[16:12:27.002]             base::options(...future.oldOptions)
[16:12:27.002]             if (.Platform$OS.type == "windows") {
[16:12:27.002]                 old_names <- names(...future.oldEnvVars)
[16:12:27.002]                 envs <- base::Sys.getenv()
[16:12:27.002]                 names <- names(envs)
[16:12:27.002]                 common <- intersect(names, old_names)
[16:12:27.002]                 added <- setdiff(names, old_names)
[16:12:27.002]                 removed <- setdiff(old_names, names)
[16:12:27.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.002]                   envs[common]]
[16:12:27.002]                 NAMES <- toupper(changed)
[16:12:27.002]                 args <- list()
[16:12:27.002]                 for (kk in seq_along(NAMES)) {
[16:12:27.002]                   name <- changed[[kk]]
[16:12:27.002]                   NAME <- NAMES[[kk]]
[16:12:27.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.002]                     next
[16:12:27.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.002]                 }
[16:12:27.002]                 NAMES <- toupper(added)
[16:12:27.002]                 for (kk in seq_along(NAMES)) {
[16:12:27.002]                   name <- added[[kk]]
[16:12:27.002]                   NAME <- NAMES[[kk]]
[16:12:27.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.002]                     next
[16:12:27.002]                   args[[name]] <- ""
[16:12:27.002]                 }
[16:12:27.002]                 NAMES <- toupper(removed)
[16:12:27.002]                 for (kk in seq_along(NAMES)) {
[16:12:27.002]                   name <- removed[[kk]]
[16:12:27.002]                   NAME <- NAMES[[kk]]
[16:12:27.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.002]                     next
[16:12:27.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.002]                 }
[16:12:27.002]                 if (length(args) > 0) 
[16:12:27.002]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.002]             }
[16:12:27.002]             else {
[16:12:27.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.002]             }
[16:12:27.002]             {
[16:12:27.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.002]                   0L) {
[16:12:27.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.002]                   base::options(opts)
[16:12:27.002]                 }
[16:12:27.002]                 {
[16:12:27.002]                   {
[16:12:27.002]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.002]                     NULL
[16:12:27.002]                   }
[16:12:27.002]                   options(future.plan = NULL)
[16:12:27.002]                   if (is.na(NA_character_)) 
[16:12:27.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.002]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.002]                     envir = parent.frame()) 
[16:12:27.002]                   {
[16:12:27.002]                     default_workers <- missing(workers)
[16:12:27.002]                     if (is.function(workers)) 
[16:12:27.002]                       workers <- workers()
[16:12:27.002]                     workers <- structure(as.integer(workers), 
[16:12:27.002]                       class = class(workers))
[16:12:27.002]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.002]                       1L)
[16:12:27.002]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.002]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.002]                       if (default_workers) 
[16:12:27.002]                         supportsMulticore(warn = TRUE)
[16:12:27.002]                       return(sequential(..., envir = envir))
[16:12:27.002]                     }
[16:12:27.002]                     oopts <- options(mc.cores = workers)
[16:12:27.002]                     on.exit(options(oopts))
[16:12:27.002]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.002]                       envir = envir)
[16:12:27.002]                     if (!future$lazy) 
[16:12:27.002]                       future <- run(future)
[16:12:27.002]                     invisible(future)
[16:12:27.002]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.002]                 }
[16:12:27.002]             }
[16:12:27.002]         }
[16:12:27.002]     })
[16:12:27.002]     if (TRUE) {
[16:12:27.002]         base::sink(type = "output", split = FALSE)
[16:12:27.002]         if (TRUE) {
[16:12:27.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.002]         }
[16:12:27.002]         else {
[16:12:27.002]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.002]         }
[16:12:27.002]         base::close(...future.stdout)
[16:12:27.002]         ...future.stdout <- NULL
[16:12:27.002]     }
[16:12:27.002]     ...future.result$conditions <- ...future.conditions
[16:12:27.002]     ...future.result$finished <- base::Sys.time()
[16:12:27.002]     ...future.result
[16:12:27.002] }
[16:12:27.005] requestCore(): workers = 2
[16:12:27.006] MulticoreFuture started
[16:12:27.007] - Launch lazy future ... done
[16:12:27.007] run() for ‘MulticoreFuture’ ... done
[16:12:27.007] getGlobalsAndPackages() ...
[16:12:27.008] Searching for globals...
[16:12:27.008] plan(): Setting new future strategy stack:
[16:12:27.008] 
[16:12:27.008] List of future strategies:
[16:12:27.008] 1. sequential:
[16:12:27.008]    - args: function (..., envir = parent.frame())
[16:12:27.008]    - tweaked: FALSE
[16:12:27.008]    - call: NULL
[16:12:27.009] Searching for globals ... DONE
[16:12:27.009] - globals: [0] <none>
[16:12:27.009] plan(): nbrOfWorkers() = 1
[16:12:27.009] getGlobalsAndPackages() ... DONE
[16:12:27.009] run() for ‘Future’ ...
[16:12:27.010] - state: ‘created’
[16:12:27.010] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.011] plan(): Setting new future strategy stack:
[16:12:27.011] List of future strategies:
[16:12:27.011] 1. multicore:
[16:12:27.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.011]    - tweaked: FALSE
[16:12:27.011]    - call: plan(strategy)
[16:12:27.015] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.015] plan(): nbrOfWorkers() = 2
[16:12:27.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.015]   - Field: ‘label’
[16:12:27.015]   - Field: ‘local’
[16:12:27.015]   - Field: ‘owner’
[16:12:27.016]   - Field: ‘envir’
[16:12:27.016]   - Field: ‘workers’
[16:12:27.016]   - Field: ‘packages’
[16:12:27.016]   - Field: ‘gc’
[16:12:27.016]   - Field: ‘job’
[16:12:27.016]   - Field: ‘conditions’
[16:12:27.017]   - Field: ‘expr’
[16:12:27.017]   - Field: ‘uuid’
[16:12:27.021]   - Field: ‘seed’
[16:12:27.021]   - Field: ‘version’
[16:12:27.021]   - Field: ‘result’
[16:12:27.022]   - Field: ‘asynchronous’
[16:12:27.022]   - Field: ‘calls’
[16:12:27.022]   - Field: ‘globals’
[16:12:27.023]   - Field: ‘stdout’
[16:12:27.023]   - Field: ‘earlySignal’
[16:12:27.023]   - Field: ‘lazy’
[16:12:27.023]   - Field: ‘state’
[16:12:27.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.024] - Launch lazy future ...
[16:12:27.025] Packages needed by the future expression (n = 0): <none>
[16:12:27.025] Packages needed by future strategies (n = 0): <none>
[16:12:27.026] {
[16:12:27.026]     {
[16:12:27.026]         {
[16:12:27.026]             ...future.startTime <- base::Sys.time()
[16:12:27.026]             {
[16:12:27.026]                 {
[16:12:27.026]                   {
[16:12:27.026]                     {
[16:12:27.026]                       base::local({
[16:12:27.026]                         has_future <- base::requireNamespace("future", 
[16:12:27.026]                           quietly = TRUE)
[16:12:27.026]                         if (has_future) {
[16:12:27.026]                           ns <- base::getNamespace("future")
[16:12:27.026]                           version <- ns[[".package"]][["version"]]
[16:12:27.026]                           if (is.null(version)) 
[16:12:27.026]                             version <- utils::packageVersion("future")
[16:12:27.026]                         }
[16:12:27.026]                         else {
[16:12:27.026]                           version <- NULL
[16:12:27.026]                         }
[16:12:27.026]                         if (!has_future || version < "1.8.0") {
[16:12:27.026]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.026]                             "", base::R.version$version.string), 
[16:12:27.026]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.026]                               "release", "version")], collapse = " "), 
[16:12:27.026]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.026]                             info)
[16:12:27.026]                           info <- base::paste(info, collapse = "; ")
[16:12:27.026]                           if (!has_future) {
[16:12:27.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.026]                               info)
[16:12:27.026]                           }
[16:12:27.026]                           else {
[16:12:27.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.026]                               info, version)
[16:12:27.026]                           }
[16:12:27.026]                           base::stop(msg)
[16:12:27.026]                         }
[16:12:27.026]                       })
[16:12:27.026]                     }
[16:12:27.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.026]                     base::options(mc.cores = 1L)
[16:12:27.026]                   }
[16:12:27.026]                   options(future.plan = NULL)
[16:12:27.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.026]                 }
[16:12:27.026]                 ...future.workdir <- getwd()
[16:12:27.026]             }
[16:12:27.026]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.026]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.026]         }
[16:12:27.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.026]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.026]             base::names(...future.oldOptions))
[16:12:27.026]     }
[16:12:27.026]     if (FALSE) {
[16:12:27.026]     }
[16:12:27.026]     else {
[16:12:27.026]         if (TRUE) {
[16:12:27.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.026]                 open = "w")
[16:12:27.026]         }
[16:12:27.026]         else {
[16:12:27.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.026]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.026]         }
[16:12:27.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.026]             base::sink(type = "output", split = FALSE)
[16:12:27.026]             base::close(...future.stdout)
[16:12:27.026]         }, add = TRUE)
[16:12:27.026]     }
[16:12:27.026]     ...future.frame <- base::sys.nframe()
[16:12:27.026]     ...future.conditions <- base::list()
[16:12:27.026]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.026]     if (FALSE) {
[16:12:27.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.026]     }
[16:12:27.026]     ...future.result <- base::tryCatch({
[16:12:27.026]         base::withCallingHandlers({
[16:12:27.026]             ...future.value <- base::withVisible(base::local({
[16:12:27.026]                 withCallingHandlers({
[16:12:27.026]                   NULL
[16:12:27.026]                 }, immediateCondition = function(cond) {
[16:12:27.026]                   save_rds <- function (object, pathname, ...) 
[16:12:27.026]                   {
[16:12:27.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.026]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.026]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.026]                         fi_tmp[["mtime"]])
[16:12:27.026]                     }
[16:12:27.026]                     tryCatch({
[16:12:27.026]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.026]                     }, error = function(ex) {
[16:12:27.026]                       msg <- conditionMessage(ex)
[16:12:27.026]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.026]                         fi_tmp[["mtime"]], msg)
[16:12:27.026]                       ex$message <- msg
[16:12:27.026]                       stop(ex)
[16:12:27.026]                     })
[16:12:27.026]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.026]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.026]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.026]                       fi <- file.info(pathname)
[16:12:27.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.026]                         fi[["size"]], fi[["mtime"]])
[16:12:27.026]                       stop(msg)
[16:12:27.026]                     }
[16:12:27.026]                     invisible(pathname)
[16:12:27.026]                   }
[16:12:27.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.026]                     rootPath = tempdir()) 
[16:12:27.026]                   {
[16:12:27.026]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.026]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.026]                       tmpdir = path, fileext = ".rds")
[16:12:27.026]                     save_rds(obj, file)
[16:12:27.026]                   }
[16:12:27.026]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.026]                   {
[16:12:27.026]                     inherits <- base::inherits
[16:12:27.026]                     invokeRestart <- base::invokeRestart
[16:12:27.026]                     is.null <- base::is.null
[16:12:27.026]                     muffled <- FALSE
[16:12:27.026]                     if (inherits(cond, "message")) {
[16:12:27.026]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.026]                       if (muffled) 
[16:12:27.026]                         invokeRestart("muffleMessage")
[16:12:27.026]                     }
[16:12:27.026]                     else if (inherits(cond, "warning")) {
[16:12:27.026]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.026]                       if (muffled) 
[16:12:27.026]                         invokeRestart("muffleWarning")
[16:12:27.026]                     }
[16:12:27.026]                     else if (inherits(cond, "condition")) {
[16:12:27.026]                       if (!is.null(pattern)) {
[16:12:27.026]                         computeRestarts <- base::computeRestarts
[16:12:27.026]                         grepl <- base::grepl
[16:12:27.026]                         restarts <- computeRestarts(cond)
[16:12:27.026]                         for (restart in restarts) {
[16:12:27.026]                           name <- restart$name
[16:12:27.026]                           if (is.null(name)) 
[16:12:27.026]                             next
[16:12:27.026]                           if (!grepl(pattern, name)) 
[16:12:27.026]                             next
[16:12:27.026]                           invokeRestart(restart)
[16:12:27.026]                           muffled <- TRUE
[16:12:27.026]                           break
[16:12:27.026]                         }
[16:12:27.026]                       }
[16:12:27.026]                     }
[16:12:27.026]                     invisible(muffled)
[16:12:27.026]                   }
[16:12:27.026]                   muffleCondition(cond)
[16:12:27.026]                 })
[16:12:27.026]             }))
[16:12:27.026]             future::FutureResult(value = ...future.value$value, 
[16:12:27.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.026]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.026]                     ...future.globalenv.names))
[16:12:27.026]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.026]         }, condition = base::local({
[16:12:27.026]             c <- base::c
[16:12:27.026]             inherits <- base::inherits
[16:12:27.026]             invokeRestart <- base::invokeRestart
[16:12:27.026]             length <- base::length
[16:12:27.026]             list <- base::list
[16:12:27.026]             seq.int <- base::seq.int
[16:12:27.026]             signalCondition <- base::signalCondition
[16:12:27.026]             sys.calls <- base::sys.calls
[16:12:27.026]             `[[` <- base::`[[`
[16:12:27.026]             `+` <- base::`+`
[16:12:27.026]             `<<-` <- base::`<<-`
[16:12:27.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.026]                   3L)]
[16:12:27.026]             }
[16:12:27.026]             function(cond) {
[16:12:27.026]                 is_error <- inherits(cond, "error")
[16:12:27.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.026]                   NULL)
[16:12:27.026]                 if (is_error) {
[16:12:27.026]                   sessionInformation <- function() {
[16:12:27.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.026]                       search = base::search(), system = base::Sys.info())
[16:12:27.026]                   }
[16:12:27.026]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.026]                     cond$call), session = sessionInformation(), 
[16:12:27.026]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.026]                   signalCondition(cond)
[16:12:27.026]                 }
[16:12:27.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.026]                 "immediateCondition"))) {
[16:12:27.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.026]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.026]                   if (TRUE && !signal) {
[16:12:27.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.026]                     {
[16:12:27.026]                       inherits <- base::inherits
[16:12:27.026]                       invokeRestart <- base::invokeRestart
[16:12:27.026]                       is.null <- base::is.null
[16:12:27.026]                       muffled <- FALSE
[16:12:27.026]                       if (inherits(cond, "message")) {
[16:12:27.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.026]                         if (muffled) 
[16:12:27.026]                           invokeRestart("muffleMessage")
[16:12:27.026]                       }
[16:12:27.026]                       else if (inherits(cond, "warning")) {
[16:12:27.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.026]                         if (muffled) 
[16:12:27.026]                           invokeRestart("muffleWarning")
[16:12:27.026]                       }
[16:12:27.026]                       else if (inherits(cond, "condition")) {
[16:12:27.026]                         if (!is.null(pattern)) {
[16:12:27.026]                           computeRestarts <- base::computeRestarts
[16:12:27.026]                           grepl <- base::grepl
[16:12:27.026]                           restarts <- computeRestarts(cond)
[16:12:27.026]                           for (restart in restarts) {
[16:12:27.026]                             name <- restart$name
[16:12:27.026]                             if (is.null(name)) 
[16:12:27.026]                               next
[16:12:27.026]                             if (!grepl(pattern, name)) 
[16:12:27.026]                               next
[16:12:27.026]                             invokeRestart(restart)
[16:12:27.026]                             muffled <- TRUE
[16:12:27.026]                             break
[16:12:27.026]                           }
[16:12:27.026]                         }
[16:12:27.026]                       }
[16:12:27.026]                       invisible(muffled)
[16:12:27.026]                     }
[16:12:27.026]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.026]                   }
[16:12:27.026]                 }
[16:12:27.026]                 else {
[16:12:27.026]                   if (TRUE) {
[16:12:27.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.026]                     {
[16:12:27.026]                       inherits <- base::inherits
[16:12:27.026]                       invokeRestart <- base::invokeRestart
[16:12:27.026]                       is.null <- base::is.null
[16:12:27.026]                       muffled <- FALSE
[16:12:27.026]                       if (inherits(cond, "message")) {
[16:12:27.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.026]                         if (muffled) 
[16:12:27.026]                           invokeRestart("muffleMessage")
[16:12:27.026]                       }
[16:12:27.026]                       else if (inherits(cond, "warning")) {
[16:12:27.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.026]                         if (muffled) 
[16:12:27.026]                           invokeRestart("muffleWarning")
[16:12:27.026]                       }
[16:12:27.026]                       else if (inherits(cond, "condition")) {
[16:12:27.026]                         if (!is.null(pattern)) {
[16:12:27.026]                           computeRestarts <- base::computeRestarts
[16:12:27.026]                           grepl <- base::grepl
[16:12:27.026]                           restarts <- computeRestarts(cond)
[16:12:27.026]                           for (restart in restarts) {
[16:12:27.026]                             name <- restart$name
[16:12:27.026]                             if (is.null(name)) 
[16:12:27.026]                               next
[16:12:27.026]                             if (!grepl(pattern, name)) 
[16:12:27.026]                               next
[16:12:27.026]                             invokeRestart(restart)
[16:12:27.026]                             muffled <- TRUE
[16:12:27.026]                             break
[16:12:27.026]                           }
[16:12:27.026]                         }
[16:12:27.026]                       }
[16:12:27.026]                       invisible(muffled)
[16:12:27.026]                     }
[16:12:27.026]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.026]                   }
[16:12:27.026]                 }
[16:12:27.026]             }
[16:12:27.026]         }))
[16:12:27.026]     }, error = function(ex) {
[16:12:27.026]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.026]                 ...future.rng), started = ...future.startTime, 
[16:12:27.026]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.026]             version = "1.8"), class = "FutureResult")
[16:12:27.026]     }, finally = {
[16:12:27.026]         if (!identical(...future.workdir, getwd())) 
[16:12:27.026]             setwd(...future.workdir)
[16:12:27.026]         {
[16:12:27.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.026]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.026]             }
[16:12:27.026]             base::options(...future.oldOptions)
[16:12:27.026]             if (.Platform$OS.type == "windows") {
[16:12:27.026]                 old_names <- names(...future.oldEnvVars)
[16:12:27.026]                 envs <- base::Sys.getenv()
[16:12:27.026]                 names <- names(envs)
[16:12:27.026]                 common <- intersect(names, old_names)
[16:12:27.026]                 added <- setdiff(names, old_names)
[16:12:27.026]                 removed <- setdiff(old_names, names)
[16:12:27.026]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.026]                   envs[common]]
[16:12:27.026]                 NAMES <- toupper(changed)
[16:12:27.026]                 args <- list()
[16:12:27.026]                 for (kk in seq_along(NAMES)) {
[16:12:27.026]                   name <- changed[[kk]]
[16:12:27.026]                   NAME <- NAMES[[kk]]
[16:12:27.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.026]                     next
[16:12:27.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.026]                 }
[16:12:27.026]                 NAMES <- toupper(added)
[16:12:27.026]                 for (kk in seq_along(NAMES)) {
[16:12:27.026]                   name <- added[[kk]]
[16:12:27.026]                   NAME <- NAMES[[kk]]
[16:12:27.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.026]                     next
[16:12:27.026]                   args[[name]] <- ""
[16:12:27.026]                 }
[16:12:27.026]                 NAMES <- toupper(removed)
[16:12:27.026]                 for (kk in seq_along(NAMES)) {
[16:12:27.026]                   name <- removed[[kk]]
[16:12:27.026]                   NAME <- NAMES[[kk]]
[16:12:27.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.026]                     next
[16:12:27.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.026]                 }
[16:12:27.026]                 if (length(args) > 0) 
[16:12:27.026]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.026]             }
[16:12:27.026]             else {
[16:12:27.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.026]             }
[16:12:27.026]             {
[16:12:27.026]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.026]                   0L) {
[16:12:27.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.026]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.026]                   base::options(opts)
[16:12:27.026]                 }
[16:12:27.026]                 {
[16:12:27.026]                   {
[16:12:27.026]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.026]                     NULL
[16:12:27.026]                   }
[16:12:27.026]                   options(future.plan = NULL)
[16:12:27.026]                   if (is.na(NA_character_)) 
[16:12:27.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.026]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.026]                     envir = parent.frame()) 
[16:12:27.026]                   {
[16:12:27.026]                     default_workers <- missing(workers)
[16:12:27.026]                     if (is.function(workers)) 
[16:12:27.026]                       workers <- workers()
[16:12:27.026]                     workers <- structure(as.integer(workers), 
[16:12:27.026]                       class = class(workers))
[16:12:27.026]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.026]                       1L)
[16:12:27.026]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.026]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.026]                       if (default_workers) 
[16:12:27.026]                         supportsMulticore(warn = TRUE)
[16:12:27.026]                       return(sequential(..., envir = envir))
[16:12:27.026]                     }
[16:12:27.026]                     oopts <- options(mc.cores = workers)
[16:12:27.026]                     on.exit(options(oopts))
[16:12:27.026]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.026]                       envir = envir)
[16:12:27.026]                     if (!future$lazy) 
[16:12:27.026]                       future <- run(future)
[16:12:27.026]                     invisible(future)
[16:12:27.026]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.026]                 }
[16:12:27.026]             }
[16:12:27.026]         }
[16:12:27.026]     })
[16:12:27.026]     if (TRUE) {
[16:12:27.026]         base::sink(type = "output", split = FALSE)
[16:12:27.026]         if (TRUE) {
[16:12:27.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.026]         }
[16:12:27.026]         else {
[16:12:27.026]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.026]         }
[16:12:27.026]         base::close(...future.stdout)
[16:12:27.026]         ...future.stdout <- NULL
[16:12:27.026]     }
[16:12:27.026]     ...future.result$conditions <- ...future.conditions
[16:12:27.026]     ...future.result$finished <- base::Sys.time()
[16:12:27.026]     ...future.result
[16:12:27.026] }
[16:12:27.029] requestCore(): workers = 2
[16:12:27.031] MulticoreFuture started
[16:12:27.031] - Launch lazy future ... done
[16:12:27.031] run() for ‘MulticoreFuture’ ... done
List of 6
[16:12:27.032] plan(): Setting new future strategy stack:
 $ a:[16:12:27.032] List of future strategies:
[16:12:27.032] 1. sequential:
[16:12:27.032]    - args: function (..., envir = parent.frame())
[16:12:27.032]    - tweaked: FALSE
[16:12:27.032]    - call: NULL
 num 1
 $ b:[16:12:27.033] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baea86c08> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baee8e668> 
 $  : NULL
 $  :[16:12:27.036] plan(): Setting new future strategy stack:
 NULL
 $  : num 6
[16:12:27.036] List of future strategies:
[16:12:27.036] 1. multicore:
[16:12:27.036]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.036]    - tweaked: FALSE
[16:12:27.036]    - call: plan(strategy)
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baea86c08> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baee8e668> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ :[16:12:27.041] plan(): nbrOfWorkers() = 2
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:27.045] resolve() on list ...
[16:12:27.045]  recursive: 0
[16:12:27.045]  length: 6
[16:12:27.046]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:27.046] signalConditionsASAP(numeric, pos=1) ...
[16:12:27.046] - nx: 6
[16:12:27.046] - relay: TRUE
[16:12:27.046] - stdout: TRUE
[16:12:27.046] - signal: TRUE
[16:12:27.046] - resignal: FALSE
[16:12:27.047] - force: TRUE
[16:12:27.047] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.047] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.047]  - until=2
[16:12:27.047]  - relaying element #2
[16:12:27.047] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.047] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.048] signalConditionsASAP(NULL, pos=1) ... done
[16:12:27.048]  length: 5 (resolved future 1)
[16:12:27.048] Future #2
[16:12:27.049] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:27.049] - nx: 6
[16:12:27.050] - relay: TRUE
[16:12:27.050] - stdout: TRUE
[16:12:27.050] - signal: TRUE
[16:12:27.050] - resignal: FALSE
[16:12:27.050] - force: TRUE
[16:12:27.050] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.050] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.050]  - until=2
[16:12:27.051]  - relaying element #2
[16:12:27.051] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.051] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.051] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:27.051]  length: 4 (resolved future 2)
[16:12:27.052] Future #3
[16:12:27.052] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:27.053] - nx: 6
[16:12:27.053] - relay: TRUE
[16:12:27.053] - stdout: TRUE
[16:12:27.053] - signal: TRUE
[16:12:27.053] - resignal: FALSE
[16:12:27.053] - force: TRUE
[16:12:27.053] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.053] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.054]  - until=3
[16:12:27.054]  - relaying element #3
[16:12:27.054] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.054] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.054] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:27.054]  length: 3 (resolved future 3)
[16:12:27.054] signalConditionsASAP(NULL, pos=4) ...
[16:12:27.055] - nx: 6
[16:12:27.055] - relay: TRUE
[16:12:27.055] - stdout: TRUE
[16:12:27.055] - signal: TRUE
[16:12:27.055] - resignal: FALSE
[16:12:27.055] - force: TRUE
[16:12:27.055] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.055] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.055]  - until=5
[16:12:27.056]  - relaying element #5
[16:12:27.056] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.056] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.056] signalConditionsASAP(NULL, pos=4) ... done
[16:12:27.056]  length: 2 (resolved future 4)
[16:12:27.056] signalConditionsASAP(NULL, pos=5) ...
[16:12:27.056] - nx: 6
[16:12:27.056] - relay: TRUE
[16:12:27.056] - stdout: TRUE
[16:12:27.057] - signal: TRUE
[16:12:27.057] - resignal: FALSE
[16:12:27.057] - force: TRUE
[16:12:27.057] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.057] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.057]  - until=6
[16:12:27.057]  - relaying element #6
[16:12:27.057] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.057] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.058] signalConditionsASAP(NULL, pos=5) ... done
[16:12:27.058]  length: 1 (resolved future 5)
[16:12:27.058] signalConditionsASAP(numeric, pos=6) ...
[16:12:27.058] - nx: 6
[16:12:27.058] - relay: TRUE
[16:12:27.058] - stdout: TRUE
[16:12:27.058] - signal: TRUE
[16:12:27.058] - resignal: FALSE
[16:12:27.058] - force: TRUE
[16:12:27.058] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.058] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.059]  - until=6
[16:12:27.059] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.059] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.059] signalConditionsASAP(numeric, pos=6) ... done
[16:12:27.059]  length: 0 (resolved future 6)
[16:12:27.059] Relaying remaining futures
[16:12:27.059] signalConditionsASAP(NULL, pos=0) ...
[16:12:27.059] - nx: 6
[16:12:27.059] - relay: TRUE
[16:12:27.059] - stdout: TRUE
[16:12:27.060] - signal: TRUE
[16:12:27.060] - resignal: FALSE
[16:12:27.060] - force: TRUE
[16:12:27.060] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:27.060] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.060] signalConditionsASAP(NULL, pos=0) ... done
[16:12:27.061] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:12:27.067] getGlobalsAndPackages() ...
[16:12:27.067] Searching for globals...
[16:12:27.067] 
[16:12:27.068] Searching for globals ... DONE
[16:12:27.068] - globals: [0] <none>
[16:12:27.068] getGlobalsAndPackages() ... DONE
[16:12:27.068] run() for ‘Future’ ...
[16:12:27.068] - state: ‘created’
[16:12:27.068] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.072] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.073]   - Field: ‘label’
[16:12:27.073]   - Field: ‘local’
[16:12:27.073]   - Field: ‘owner’
[16:12:27.073]   - Field: ‘envir’
[16:12:27.073]   - Field: ‘workers’
[16:12:27.073]   - Field: ‘packages’
[16:12:27.073]   - Field: ‘gc’
[16:12:27.073]   - Field: ‘job’
[16:12:27.074]   - Field: ‘conditions’
[16:12:27.074]   - Field: ‘expr’
[16:12:27.074]   - Field: ‘uuid’
[16:12:27.074]   - Field: ‘seed’
[16:12:27.074]   - Field: ‘version’
[16:12:27.074]   - Field: ‘result’
[16:12:27.074]   - Field: ‘asynchronous’
[16:12:27.074]   - Field: ‘calls’
[16:12:27.074]   - Field: ‘globals’
[16:12:27.074]   - Field: ‘stdout’
[16:12:27.074]   - Field: ‘earlySignal’
[16:12:27.075]   - Field: ‘lazy’
[16:12:27.075]   - Field: ‘state’
[16:12:27.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.075] - Launch lazy future ...
[16:12:27.075] Packages needed by the future expression (n = 0): <none>
[16:12:27.075] Packages needed by future strategies (n = 0): <none>
[16:12:27.076] {
[16:12:27.076]     {
[16:12:27.076]         {
[16:12:27.076]             ...future.startTime <- base::Sys.time()
[16:12:27.076]             {
[16:12:27.076]                 {
[16:12:27.076]                   {
[16:12:27.076]                     {
[16:12:27.076]                       base::local({
[16:12:27.076]                         has_future <- base::requireNamespace("future", 
[16:12:27.076]                           quietly = TRUE)
[16:12:27.076]                         if (has_future) {
[16:12:27.076]                           ns <- base::getNamespace("future")
[16:12:27.076]                           version <- ns[[".package"]][["version"]]
[16:12:27.076]                           if (is.null(version)) 
[16:12:27.076]                             version <- utils::packageVersion("future")
[16:12:27.076]                         }
[16:12:27.076]                         else {
[16:12:27.076]                           version <- NULL
[16:12:27.076]                         }
[16:12:27.076]                         if (!has_future || version < "1.8.0") {
[16:12:27.076]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.076]                             "", base::R.version$version.string), 
[16:12:27.076]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.076]                               "release", "version")], collapse = " "), 
[16:12:27.076]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.076]                             info)
[16:12:27.076]                           info <- base::paste(info, collapse = "; ")
[16:12:27.076]                           if (!has_future) {
[16:12:27.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.076]                               info)
[16:12:27.076]                           }
[16:12:27.076]                           else {
[16:12:27.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.076]                               info, version)
[16:12:27.076]                           }
[16:12:27.076]                           base::stop(msg)
[16:12:27.076]                         }
[16:12:27.076]                       })
[16:12:27.076]                     }
[16:12:27.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.076]                     base::options(mc.cores = 1L)
[16:12:27.076]                   }
[16:12:27.076]                   options(future.plan = NULL)
[16:12:27.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.076]                 }
[16:12:27.076]                 ...future.workdir <- getwd()
[16:12:27.076]             }
[16:12:27.076]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.076]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.076]         }
[16:12:27.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.076]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.076]             base::names(...future.oldOptions))
[16:12:27.076]     }
[16:12:27.076]     if (FALSE) {
[16:12:27.076]     }
[16:12:27.076]     else {
[16:12:27.076]         if (TRUE) {
[16:12:27.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.076]                 open = "w")
[16:12:27.076]         }
[16:12:27.076]         else {
[16:12:27.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.076]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.076]         }
[16:12:27.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.076]             base::sink(type = "output", split = FALSE)
[16:12:27.076]             base::close(...future.stdout)
[16:12:27.076]         }, add = TRUE)
[16:12:27.076]     }
[16:12:27.076]     ...future.frame <- base::sys.nframe()
[16:12:27.076]     ...future.conditions <- base::list()
[16:12:27.076]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.076]     if (FALSE) {
[16:12:27.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.076]     }
[16:12:27.076]     ...future.result <- base::tryCatch({
[16:12:27.076]         base::withCallingHandlers({
[16:12:27.076]             ...future.value <- base::withVisible(base::local({
[16:12:27.076]                 withCallingHandlers({
[16:12:27.076]                   2
[16:12:27.076]                 }, immediateCondition = function(cond) {
[16:12:27.076]                   save_rds <- function (object, pathname, ...) 
[16:12:27.076]                   {
[16:12:27.076]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.076]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.076]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.076]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.076]                         fi_tmp[["mtime"]])
[16:12:27.076]                     }
[16:12:27.076]                     tryCatch({
[16:12:27.076]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.076]                     }, error = function(ex) {
[16:12:27.076]                       msg <- conditionMessage(ex)
[16:12:27.076]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.076]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.076]                         fi_tmp[["mtime"]], msg)
[16:12:27.076]                       ex$message <- msg
[16:12:27.076]                       stop(ex)
[16:12:27.076]                     })
[16:12:27.076]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.076]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.076]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.076]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.076]                       fi <- file.info(pathname)
[16:12:27.076]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.076]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.076]                         fi[["size"]], fi[["mtime"]])
[16:12:27.076]                       stop(msg)
[16:12:27.076]                     }
[16:12:27.076]                     invisible(pathname)
[16:12:27.076]                   }
[16:12:27.076]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.076]                     rootPath = tempdir()) 
[16:12:27.076]                   {
[16:12:27.076]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.076]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.076]                       tmpdir = path, fileext = ".rds")
[16:12:27.076]                     save_rds(obj, file)
[16:12:27.076]                   }
[16:12:27.076]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.076]                   {
[16:12:27.076]                     inherits <- base::inherits
[16:12:27.076]                     invokeRestart <- base::invokeRestart
[16:12:27.076]                     is.null <- base::is.null
[16:12:27.076]                     muffled <- FALSE
[16:12:27.076]                     if (inherits(cond, "message")) {
[16:12:27.076]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.076]                       if (muffled) 
[16:12:27.076]                         invokeRestart("muffleMessage")
[16:12:27.076]                     }
[16:12:27.076]                     else if (inherits(cond, "warning")) {
[16:12:27.076]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.076]                       if (muffled) 
[16:12:27.076]                         invokeRestart("muffleWarning")
[16:12:27.076]                     }
[16:12:27.076]                     else if (inherits(cond, "condition")) {
[16:12:27.076]                       if (!is.null(pattern)) {
[16:12:27.076]                         computeRestarts <- base::computeRestarts
[16:12:27.076]                         grepl <- base::grepl
[16:12:27.076]                         restarts <- computeRestarts(cond)
[16:12:27.076]                         for (restart in restarts) {
[16:12:27.076]                           name <- restart$name
[16:12:27.076]                           if (is.null(name)) 
[16:12:27.076]                             next
[16:12:27.076]                           if (!grepl(pattern, name)) 
[16:12:27.076]                             next
[16:12:27.076]                           invokeRestart(restart)
[16:12:27.076]                           muffled <- TRUE
[16:12:27.076]                           break
[16:12:27.076]                         }
[16:12:27.076]                       }
[16:12:27.076]                     }
[16:12:27.076]                     invisible(muffled)
[16:12:27.076]                   }
[16:12:27.076]                   muffleCondition(cond)
[16:12:27.076]                 })
[16:12:27.076]             }))
[16:12:27.076]             future::FutureResult(value = ...future.value$value, 
[16:12:27.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.076]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.076]                     ...future.globalenv.names))
[16:12:27.076]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.076]         }, condition = base::local({
[16:12:27.076]             c <- base::c
[16:12:27.076]             inherits <- base::inherits
[16:12:27.076]             invokeRestart <- base::invokeRestart
[16:12:27.076]             length <- base::length
[16:12:27.076]             list <- base::list
[16:12:27.076]             seq.int <- base::seq.int
[16:12:27.076]             signalCondition <- base::signalCondition
[16:12:27.076]             sys.calls <- base::sys.calls
[16:12:27.076]             `[[` <- base::`[[`
[16:12:27.076]             `+` <- base::`+`
[16:12:27.076]             `<<-` <- base::`<<-`
[16:12:27.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.076]                   3L)]
[16:12:27.076]             }
[16:12:27.076]             function(cond) {
[16:12:27.076]                 is_error <- inherits(cond, "error")
[16:12:27.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.076]                   NULL)
[16:12:27.076]                 if (is_error) {
[16:12:27.076]                   sessionInformation <- function() {
[16:12:27.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.076]                       search = base::search(), system = base::Sys.info())
[16:12:27.076]                   }
[16:12:27.076]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.076]                     cond$call), session = sessionInformation(), 
[16:12:27.076]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.076]                   signalCondition(cond)
[16:12:27.076]                 }
[16:12:27.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.076]                 "immediateCondition"))) {
[16:12:27.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.076]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.076]                   if (TRUE && !signal) {
[16:12:27.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.076]                     {
[16:12:27.076]                       inherits <- base::inherits
[16:12:27.076]                       invokeRestart <- base::invokeRestart
[16:12:27.076]                       is.null <- base::is.null
[16:12:27.076]                       muffled <- FALSE
[16:12:27.076]                       if (inherits(cond, "message")) {
[16:12:27.076]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.076]                         if (muffled) 
[16:12:27.076]                           invokeRestart("muffleMessage")
[16:12:27.076]                       }
[16:12:27.076]                       else if (inherits(cond, "warning")) {
[16:12:27.076]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.076]                         if (muffled) 
[16:12:27.076]                           invokeRestart("muffleWarning")
[16:12:27.076]                       }
[16:12:27.076]                       else if (inherits(cond, "condition")) {
[16:12:27.076]                         if (!is.null(pattern)) {
[16:12:27.076]                           computeRestarts <- base::computeRestarts
[16:12:27.076]                           grepl <- base::grepl
[16:12:27.076]                           restarts <- computeRestarts(cond)
[16:12:27.076]                           for (restart in restarts) {
[16:12:27.076]                             name <- restart$name
[16:12:27.076]                             if (is.null(name)) 
[16:12:27.076]                               next
[16:12:27.076]                             if (!grepl(pattern, name)) 
[16:12:27.076]                               next
[16:12:27.076]                             invokeRestart(restart)
[16:12:27.076]                             muffled <- TRUE
[16:12:27.076]                             break
[16:12:27.076]                           }
[16:12:27.076]                         }
[16:12:27.076]                       }
[16:12:27.076]                       invisible(muffled)
[16:12:27.076]                     }
[16:12:27.076]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.076]                   }
[16:12:27.076]                 }
[16:12:27.076]                 else {
[16:12:27.076]                   if (TRUE) {
[16:12:27.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.076]                     {
[16:12:27.076]                       inherits <- base::inherits
[16:12:27.076]                       invokeRestart <- base::invokeRestart
[16:12:27.076]                       is.null <- base::is.null
[16:12:27.076]                       muffled <- FALSE
[16:12:27.076]                       if (inherits(cond, "message")) {
[16:12:27.076]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.076]                         if (muffled) 
[16:12:27.076]                           invokeRestart("muffleMessage")
[16:12:27.076]                       }
[16:12:27.076]                       else if (inherits(cond, "warning")) {
[16:12:27.076]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.076]                         if (muffled) 
[16:12:27.076]                           invokeRestart("muffleWarning")
[16:12:27.076]                       }
[16:12:27.076]                       else if (inherits(cond, "condition")) {
[16:12:27.076]                         if (!is.null(pattern)) {
[16:12:27.076]                           computeRestarts <- base::computeRestarts
[16:12:27.076]                           grepl <- base::grepl
[16:12:27.076]                           restarts <- computeRestarts(cond)
[16:12:27.076]                           for (restart in restarts) {
[16:12:27.076]                             name <- restart$name
[16:12:27.076]                             if (is.null(name)) 
[16:12:27.076]                               next
[16:12:27.076]                             if (!grepl(pattern, name)) 
[16:12:27.076]                               next
[16:12:27.076]                             invokeRestart(restart)
[16:12:27.076]                             muffled <- TRUE
[16:12:27.076]                             break
[16:12:27.076]                           }
[16:12:27.076]                         }
[16:12:27.076]                       }
[16:12:27.076]                       invisible(muffled)
[16:12:27.076]                     }
[16:12:27.076]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.076]                   }
[16:12:27.076]                 }
[16:12:27.076]             }
[16:12:27.076]         }))
[16:12:27.076]     }, error = function(ex) {
[16:12:27.076]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.076]                 ...future.rng), started = ...future.startTime, 
[16:12:27.076]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.076]             version = "1.8"), class = "FutureResult")
[16:12:27.076]     }, finally = {
[16:12:27.076]         if (!identical(...future.workdir, getwd())) 
[16:12:27.076]             setwd(...future.workdir)
[16:12:27.076]         {
[16:12:27.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.076]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.076]             }
[16:12:27.076]             base::options(...future.oldOptions)
[16:12:27.076]             if (.Platform$OS.type == "windows") {
[16:12:27.076]                 old_names <- names(...future.oldEnvVars)
[16:12:27.076]                 envs <- base::Sys.getenv()
[16:12:27.076]                 names <- names(envs)
[16:12:27.076]                 common <- intersect(names, old_names)
[16:12:27.076]                 added <- setdiff(names, old_names)
[16:12:27.076]                 removed <- setdiff(old_names, names)
[16:12:27.076]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.076]                   envs[common]]
[16:12:27.076]                 NAMES <- toupper(changed)
[16:12:27.076]                 args <- list()
[16:12:27.076]                 for (kk in seq_along(NAMES)) {
[16:12:27.076]                   name <- changed[[kk]]
[16:12:27.076]                   NAME <- NAMES[[kk]]
[16:12:27.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.076]                     next
[16:12:27.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.076]                 }
[16:12:27.076]                 NAMES <- toupper(added)
[16:12:27.076]                 for (kk in seq_along(NAMES)) {
[16:12:27.076]                   name <- added[[kk]]
[16:12:27.076]                   NAME <- NAMES[[kk]]
[16:12:27.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.076]                     next
[16:12:27.076]                   args[[name]] <- ""
[16:12:27.076]                 }
[16:12:27.076]                 NAMES <- toupper(removed)
[16:12:27.076]                 for (kk in seq_along(NAMES)) {
[16:12:27.076]                   name <- removed[[kk]]
[16:12:27.076]                   NAME <- NAMES[[kk]]
[16:12:27.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.076]                     next
[16:12:27.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.076]                 }
[16:12:27.076]                 if (length(args) > 0) 
[16:12:27.076]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.076]             }
[16:12:27.076]             else {
[16:12:27.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.076]             }
[16:12:27.076]             {
[16:12:27.076]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.076]                   0L) {
[16:12:27.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.076]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.076]                   base::options(opts)
[16:12:27.076]                 }
[16:12:27.076]                 {
[16:12:27.076]                   {
[16:12:27.076]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.076]                     NULL
[16:12:27.076]                   }
[16:12:27.076]                   options(future.plan = NULL)
[16:12:27.076]                   if (is.na(NA_character_)) 
[16:12:27.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.076]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.076]                     envir = parent.frame()) 
[16:12:27.076]                   {
[16:12:27.076]                     default_workers <- missing(workers)
[16:12:27.076]                     if (is.function(workers)) 
[16:12:27.076]                       workers <- workers()
[16:12:27.076]                     workers <- structure(as.integer(workers), 
[16:12:27.076]                       class = class(workers))
[16:12:27.076]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.076]                       1L)
[16:12:27.076]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.076]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.076]                       if (default_workers) 
[16:12:27.076]                         supportsMulticore(warn = TRUE)
[16:12:27.076]                       return(sequential(..., envir = envir))
[16:12:27.076]                     }
[16:12:27.076]                     oopts <- options(mc.cores = workers)
[16:12:27.076]                     on.exit(options(oopts))
[16:12:27.076]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.076]                       envir = envir)
[16:12:27.076]                     if (!future$lazy) 
[16:12:27.076]                       future <- run(future)
[16:12:27.076]                     invisible(future)
[16:12:27.076]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.076]                 }
[16:12:27.076]             }
[16:12:27.076]         }
[16:12:27.076]     })
[16:12:27.076]     if (TRUE) {
[16:12:27.076]         base::sink(type = "output", split = FALSE)
[16:12:27.076]         if (TRUE) {
[16:12:27.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.076]         }
[16:12:27.076]         else {
[16:12:27.076]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.076]         }
[16:12:27.076]         base::close(...future.stdout)
[16:12:27.076]         ...future.stdout <- NULL
[16:12:27.076]     }
[16:12:27.076]     ...future.result$conditions <- ...future.conditions
[16:12:27.076]     ...future.result$finished <- base::Sys.time()
[16:12:27.076]     ...future.result
[16:12:27.076] }
[16:12:27.078] requestCore(): workers = 2
[16:12:27.080] MulticoreFuture started
[16:12:27.080] - Launch lazy future ... done
[16:12:27.081] run() for ‘MulticoreFuture’ ... done
[16:12:27.081] getGlobalsAndPackages() ...
[16:12:27.081] Searching for globals...
[16:12:27.081] plan(): Setting new future strategy stack:
[16:12:27.082] 
[16:12:27.081] List of future strategies:
[16:12:27.081] 1. sequential:
[16:12:27.081]    - args: function (..., envir = parent.frame())
[16:12:27.081]    - tweaked: FALSE
[16:12:27.081]    - call: NULL
[16:12:27.082] Searching for globals ... DONE
[16:12:27.082] plan(): nbrOfWorkers() = 1
[16:12:27.082] - globals: [0] <none>
[16:12:27.083] getGlobalsAndPackages() ... DONE
[16:12:27.083] run() for ‘Future’ ...
[16:12:27.083] - state: ‘created’
[16:12:27.084] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.084] plan(): Setting new future strategy stack:
[16:12:27.084] List of future strategies:
[16:12:27.084] 1. multicore:
[16:12:27.084]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.084]    - tweaked: FALSE
[16:12:27.084]    - call: plan(strategy)
[16:12:27.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.089] plan(): nbrOfWorkers() = 2
[16:12:27.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.089]   - Field: ‘label’
[16:12:27.089]   - Field: ‘local’
[16:12:27.089]   - Field: ‘owner’
[16:12:27.090]   - Field: ‘envir’
[16:12:27.090]   - Field: ‘workers’
[16:12:27.090]   - Field: ‘packages’
[16:12:27.090]   - Field: ‘gc’
[16:12:27.090]   - Field: ‘job’
[16:12:27.090]   - Field: ‘conditions’
[16:12:27.090]   - Field: ‘expr’
[16:12:27.091]   - Field: ‘uuid’
[16:12:27.091]   - Field: ‘seed’
[16:12:27.091]   - Field: ‘version’
[16:12:27.091]   - Field: ‘result’
[16:12:27.091]   - Field: ‘asynchronous’
[16:12:27.091]   - Field: ‘calls’
[16:12:27.092]   - Field: ‘globals’
[16:12:27.092]   - Field: ‘stdout’
[16:12:27.092]   - Field: ‘earlySignal’
[16:12:27.092]   - Field: ‘lazy’
[16:12:27.092]   - Field: ‘state’
[16:12:27.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.092] - Launch lazy future ...
[16:12:27.093] Packages needed by the future expression (n = 0): <none>
[16:12:27.093] Packages needed by future strategies (n = 0): <none>
[16:12:27.094] {
[16:12:27.094]     {
[16:12:27.094]         {
[16:12:27.094]             ...future.startTime <- base::Sys.time()
[16:12:27.094]             {
[16:12:27.094]                 {
[16:12:27.094]                   {
[16:12:27.094]                     {
[16:12:27.094]                       base::local({
[16:12:27.094]                         has_future <- base::requireNamespace("future", 
[16:12:27.094]                           quietly = TRUE)
[16:12:27.094]                         if (has_future) {
[16:12:27.094]                           ns <- base::getNamespace("future")
[16:12:27.094]                           version <- ns[[".package"]][["version"]]
[16:12:27.094]                           if (is.null(version)) 
[16:12:27.094]                             version <- utils::packageVersion("future")
[16:12:27.094]                         }
[16:12:27.094]                         else {
[16:12:27.094]                           version <- NULL
[16:12:27.094]                         }
[16:12:27.094]                         if (!has_future || version < "1.8.0") {
[16:12:27.094]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.094]                             "", base::R.version$version.string), 
[16:12:27.094]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.094]                               "release", "version")], collapse = " "), 
[16:12:27.094]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.094]                             info)
[16:12:27.094]                           info <- base::paste(info, collapse = "; ")
[16:12:27.094]                           if (!has_future) {
[16:12:27.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.094]                               info)
[16:12:27.094]                           }
[16:12:27.094]                           else {
[16:12:27.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.094]                               info, version)
[16:12:27.094]                           }
[16:12:27.094]                           base::stop(msg)
[16:12:27.094]                         }
[16:12:27.094]                       })
[16:12:27.094]                     }
[16:12:27.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.094]                     base::options(mc.cores = 1L)
[16:12:27.094]                   }
[16:12:27.094]                   options(future.plan = NULL)
[16:12:27.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.094]                 }
[16:12:27.094]                 ...future.workdir <- getwd()
[16:12:27.094]             }
[16:12:27.094]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.094]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.094]         }
[16:12:27.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.094]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.094]             base::names(...future.oldOptions))
[16:12:27.094]     }
[16:12:27.094]     if (FALSE) {
[16:12:27.094]     }
[16:12:27.094]     else {
[16:12:27.094]         if (TRUE) {
[16:12:27.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.094]                 open = "w")
[16:12:27.094]         }
[16:12:27.094]         else {
[16:12:27.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.094]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.094]         }
[16:12:27.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.094]             base::sink(type = "output", split = FALSE)
[16:12:27.094]             base::close(...future.stdout)
[16:12:27.094]         }, add = TRUE)
[16:12:27.094]     }
[16:12:27.094]     ...future.frame <- base::sys.nframe()
[16:12:27.094]     ...future.conditions <- base::list()
[16:12:27.094]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.094]     if (FALSE) {
[16:12:27.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.094]     }
[16:12:27.094]     ...future.result <- base::tryCatch({
[16:12:27.094]         base::withCallingHandlers({
[16:12:27.094]             ...future.value <- base::withVisible(base::local({
[16:12:27.094]                 withCallingHandlers({
[16:12:27.094]                   NULL
[16:12:27.094]                 }, immediateCondition = function(cond) {
[16:12:27.094]                   save_rds <- function (object, pathname, ...) 
[16:12:27.094]                   {
[16:12:27.094]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.094]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.094]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.094]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.094]                         fi_tmp[["mtime"]])
[16:12:27.094]                     }
[16:12:27.094]                     tryCatch({
[16:12:27.094]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.094]                     }, error = function(ex) {
[16:12:27.094]                       msg <- conditionMessage(ex)
[16:12:27.094]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.094]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.094]                         fi_tmp[["mtime"]], msg)
[16:12:27.094]                       ex$message <- msg
[16:12:27.094]                       stop(ex)
[16:12:27.094]                     })
[16:12:27.094]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.094]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.094]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.094]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.094]                       fi <- file.info(pathname)
[16:12:27.094]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.094]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.094]                         fi[["size"]], fi[["mtime"]])
[16:12:27.094]                       stop(msg)
[16:12:27.094]                     }
[16:12:27.094]                     invisible(pathname)
[16:12:27.094]                   }
[16:12:27.094]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.094]                     rootPath = tempdir()) 
[16:12:27.094]                   {
[16:12:27.094]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.094]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.094]                       tmpdir = path, fileext = ".rds")
[16:12:27.094]                     save_rds(obj, file)
[16:12:27.094]                   }
[16:12:27.094]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.094]                   {
[16:12:27.094]                     inherits <- base::inherits
[16:12:27.094]                     invokeRestart <- base::invokeRestart
[16:12:27.094]                     is.null <- base::is.null
[16:12:27.094]                     muffled <- FALSE
[16:12:27.094]                     if (inherits(cond, "message")) {
[16:12:27.094]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.094]                       if (muffled) 
[16:12:27.094]                         invokeRestart("muffleMessage")
[16:12:27.094]                     }
[16:12:27.094]                     else if (inherits(cond, "warning")) {
[16:12:27.094]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.094]                       if (muffled) 
[16:12:27.094]                         invokeRestart("muffleWarning")
[16:12:27.094]                     }
[16:12:27.094]                     else if (inherits(cond, "condition")) {
[16:12:27.094]                       if (!is.null(pattern)) {
[16:12:27.094]                         computeRestarts <- base::computeRestarts
[16:12:27.094]                         grepl <- base::grepl
[16:12:27.094]                         restarts <- computeRestarts(cond)
[16:12:27.094]                         for (restart in restarts) {
[16:12:27.094]                           name <- restart$name
[16:12:27.094]                           if (is.null(name)) 
[16:12:27.094]                             next
[16:12:27.094]                           if (!grepl(pattern, name)) 
[16:12:27.094]                             next
[16:12:27.094]                           invokeRestart(restart)
[16:12:27.094]                           muffled <- TRUE
[16:12:27.094]                           break
[16:12:27.094]                         }
[16:12:27.094]                       }
[16:12:27.094]                     }
[16:12:27.094]                     invisible(muffled)
[16:12:27.094]                   }
[16:12:27.094]                   muffleCondition(cond)
[16:12:27.094]                 })
[16:12:27.094]             }))
[16:12:27.094]             future::FutureResult(value = ...future.value$value, 
[16:12:27.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.094]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.094]                     ...future.globalenv.names))
[16:12:27.094]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.094]         }, condition = base::local({
[16:12:27.094]             c <- base::c
[16:12:27.094]             inherits <- base::inherits
[16:12:27.094]             invokeRestart <- base::invokeRestart
[16:12:27.094]             length <- base::length
[16:12:27.094]             list <- base::list
[16:12:27.094]             seq.int <- base::seq.int
[16:12:27.094]             signalCondition <- base::signalCondition
[16:12:27.094]             sys.calls <- base::sys.calls
[16:12:27.094]             `[[` <- base::`[[`
[16:12:27.094]             `+` <- base::`+`
[16:12:27.094]             `<<-` <- base::`<<-`
[16:12:27.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.094]                   3L)]
[16:12:27.094]             }
[16:12:27.094]             function(cond) {
[16:12:27.094]                 is_error <- inherits(cond, "error")
[16:12:27.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.094]                   NULL)
[16:12:27.094]                 if (is_error) {
[16:12:27.094]                   sessionInformation <- function() {
[16:12:27.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.094]                       search = base::search(), system = base::Sys.info())
[16:12:27.094]                   }
[16:12:27.094]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.094]                     cond$call), session = sessionInformation(), 
[16:12:27.094]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.094]                   signalCondition(cond)
[16:12:27.094]                 }
[16:12:27.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.094]                 "immediateCondition"))) {
[16:12:27.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.094]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.094]                   if (TRUE && !signal) {
[16:12:27.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.094]                     {
[16:12:27.094]                       inherits <- base::inherits
[16:12:27.094]                       invokeRestart <- base::invokeRestart
[16:12:27.094]                       is.null <- base::is.null
[16:12:27.094]                       muffled <- FALSE
[16:12:27.094]                       if (inherits(cond, "message")) {
[16:12:27.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.094]                         if (muffled) 
[16:12:27.094]                           invokeRestart("muffleMessage")
[16:12:27.094]                       }
[16:12:27.094]                       else if (inherits(cond, "warning")) {
[16:12:27.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.094]                         if (muffled) 
[16:12:27.094]                           invokeRestart("muffleWarning")
[16:12:27.094]                       }
[16:12:27.094]                       else if (inherits(cond, "condition")) {
[16:12:27.094]                         if (!is.null(pattern)) {
[16:12:27.094]                           computeRestarts <- base::computeRestarts
[16:12:27.094]                           grepl <- base::grepl
[16:12:27.094]                           restarts <- computeRestarts(cond)
[16:12:27.094]                           for (restart in restarts) {
[16:12:27.094]                             name <- restart$name
[16:12:27.094]                             if (is.null(name)) 
[16:12:27.094]                               next
[16:12:27.094]                             if (!grepl(pattern, name)) 
[16:12:27.094]                               next
[16:12:27.094]                             invokeRestart(restart)
[16:12:27.094]                             muffled <- TRUE
[16:12:27.094]                             break
[16:12:27.094]                           }
[16:12:27.094]                         }
[16:12:27.094]                       }
[16:12:27.094]                       invisible(muffled)
[16:12:27.094]                     }
[16:12:27.094]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.094]                   }
[16:12:27.094]                 }
[16:12:27.094]                 else {
[16:12:27.094]                   if (TRUE) {
[16:12:27.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.094]                     {
[16:12:27.094]                       inherits <- base::inherits
[16:12:27.094]                       invokeRestart <- base::invokeRestart
[16:12:27.094]                       is.null <- base::is.null
[16:12:27.094]                       muffled <- FALSE
[16:12:27.094]                       if (inherits(cond, "message")) {
[16:12:27.094]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.094]                         if (muffled) 
[16:12:27.094]                           invokeRestart("muffleMessage")
[16:12:27.094]                       }
[16:12:27.094]                       else if (inherits(cond, "warning")) {
[16:12:27.094]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.094]                         if (muffled) 
[16:12:27.094]                           invokeRestart("muffleWarning")
[16:12:27.094]                       }
[16:12:27.094]                       else if (inherits(cond, "condition")) {
[16:12:27.094]                         if (!is.null(pattern)) {
[16:12:27.094]                           computeRestarts <- base::computeRestarts
[16:12:27.094]                           grepl <- base::grepl
[16:12:27.094]                           restarts <- computeRestarts(cond)
[16:12:27.094]                           for (restart in restarts) {
[16:12:27.094]                             name <- restart$name
[16:12:27.094]                             if (is.null(name)) 
[16:12:27.094]                               next
[16:12:27.094]                             if (!grepl(pattern, name)) 
[16:12:27.094]                               next
[16:12:27.094]                             invokeRestart(restart)
[16:12:27.094]                             muffled <- TRUE
[16:12:27.094]                             break
[16:12:27.094]                           }
[16:12:27.094]                         }
[16:12:27.094]                       }
[16:12:27.094]                       invisible(muffled)
[16:12:27.094]                     }
[16:12:27.094]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.094]                   }
[16:12:27.094]                 }
[16:12:27.094]             }
[16:12:27.094]         }))
[16:12:27.094]     }, error = function(ex) {
[16:12:27.094]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.094]                 ...future.rng), started = ...future.startTime, 
[16:12:27.094]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.094]             version = "1.8"), class = "FutureResult")
[16:12:27.094]     }, finally = {
[16:12:27.094]         if (!identical(...future.workdir, getwd())) 
[16:12:27.094]             setwd(...future.workdir)
[16:12:27.094]         {
[16:12:27.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.094]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.094]             }
[16:12:27.094]             base::options(...future.oldOptions)
[16:12:27.094]             if (.Platform$OS.type == "windows") {
[16:12:27.094]                 old_names <- names(...future.oldEnvVars)
[16:12:27.094]                 envs <- base::Sys.getenv()
[16:12:27.094]                 names <- names(envs)
[16:12:27.094]                 common <- intersect(names, old_names)
[16:12:27.094]                 added <- setdiff(names, old_names)
[16:12:27.094]                 removed <- setdiff(old_names, names)
[16:12:27.094]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.094]                   envs[common]]
[16:12:27.094]                 NAMES <- toupper(changed)
[16:12:27.094]                 args <- list()
[16:12:27.094]                 for (kk in seq_along(NAMES)) {
[16:12:27.094]                   name <- changed[[kk]]
[16:12:27.094]                   NAME <- NAMES[[kk]]
[16:12:27.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.094]                     next
[16:12:27.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.094]                 }
[16:12:27.094]                 NAMES <- toupper(added)
[16:12:27.094]                 for (kk in seq_along(NAMES)) {
[16:12:27.094]                   name <- added[[kk]]
[16:12:27.094]                   NAME <- NAMES[[kk]]
[16:12:27.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.094]                     next
[16:12:27.094]                   args[[name]] <- ""
[16:12:27.094]                 }
[16:12:27.094]                 NAMES <- toupper(removed)
[16:12:27.094]                 for (kk in seq_along(NAMES)) {
[16:12:27.094]                   name <- removed[[kk]]
[16:12:27.094]                   NAME <- NAMES[[kk]]
[16:12:27.094]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.094]                     next
[16:12:27.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.094]                 }
[16:12:27.094]                 if (length(args) > 0) 
[16:12:27.094]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.094]             }
[16:12:27.094]             else {
[16:12:27.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.094]             }
[16:12:27.094]             {
[16:12:27.094]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.094]                   0L) {
[16:12:27.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.094]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.094]                   base::options(opts)
[16:12:27.094]                 }
[16:12:27.094]                 {
[16:12:27.094]                   {
[16:12:27.094]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.094]                     NULL
[16:12:27.094]                   }
[16:12:27.094]                   options(future.plan = NULL)
[16:12:27.094]                   if (is.na(NA_character_)) 
[16:12:27.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.094]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.094]                     envir = parent.frame()) 
[16:12:27.094]                   {
[16:12:27.094]                     default_workers <- missing(workers)
[16:12:27.094]                     if (is.function(workers)) 
[16:12:27.094]                       workers <- workers()
[16:12:27.094]                     workers <- structure(as.integer(workers), 
[16:12:27.094]                       class = class(workers))
[16:12:27.094]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.094]                       1L)
[16:12:27.094]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.094]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.094]                       if (default_workers) 
[16:12:27.094]                         supportsMulticore(warn = TRUE)
[16:12:27.094]                       return(sequential(..., envir = envir))
[16:12:27.094]                     }
[16:12:27.094]                     oopts <- options(mc.cores = workers)
[16:12:27.094]                     on.exit(options(oopts))
[16:12:27.094]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.094]                       envir = envir)
[16:12:27.094]                     if (!future$lazy) 
[16:12:27.094]                       future <- run(future)
[16:12:27.094]                     invisible(future)
[16:12:27.094]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.094]                 }
[16:12:27.094]             }
[16:12:27.094]         }
[16:12:27.094]     })
[16:12:27.094]     if (TRUE) {
[16:12:27.094]         base::sink(type = "output", split = FALSE)
[16:12:27.094]         if (TRUE) {
[16:12:27.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.094]         }
[16:12:27.094]         else {
[16:12:27.094]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.094]         }
[16:12:27.094]         base::close(...future.stdout)
[16:12:27.094]         ...future.stdout <- NULL
[16:12:27.094]     }
[16:12:27.094]     ...future.result$conditions <- ...future.conditions
[16:12:27.094]     ...future.result$finished <- base::Sys.time()
[16:12:27.094]     ...future.result
[16:12:27.094] }
[16:12:27.098] requestCore(): workers = 2
[16:12:27.099] MulticoreFuture started
[16:12:27.100] - Launch lazy future ... done
[16:12:27.100] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[16:12:27.101] plan(): Setting new future strategy stack:
 num 1
[16:12:27.101] List of future strategies:
[16:12:27.101] 1. sequential:
[16:12:27.101]    - args: function (..., envir = parent.frame())
[16:12:27.101]    - tweaked: FALSE
[16:12:27.101]    - call: NULL
 $ b:[16:12:27.102] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae0d5d58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae438210> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:12:27.104] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:12:27.104] List of future strategies:
[16:12:27.104] 1. multicore:
[16:12:27.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.104]    - tweaked: FALSE
[16:12:27.104]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae0d5d58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae438210> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:12:27.109] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:27.111] resolve() on list ...
[16:12:27.112]  recursive: 0
[16:12:27.112]  length: 6
[16:12:27.112]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:27.112] signalConditionsASAP(numeric, pos=1) ...
[16:12:27.112] - nx: 6
[16:12:27.112] - relay: TRUE
[16:12:27.112] - stdout: TRUE
[16:12:27.113] - signal: TRUE
[16:12:27.113] - resignal: FALSE
[16:12:27.113] - force: TRUE
[16:12:27.113] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.113] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.113]  - until=2
[16:12:27.113]  - relaying element #2
[16:12:27.114] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.114] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.114] signalConditionsASAP(NULL, pos=1) ... done
[16:12:27.114]  length: 5 (resolved future 1)
[16:12:27.114] Future #2
[16:12:27.115] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:27.115] - nx: 6
[16:12:27.119] - relay: TRUE
[16:12:27.120] - stdout: TRUE
[16:12:27.120] - signal: TRUE
[16:12:27.120] - resignal: FALSE
[16:12:27.120] - force: TRUE
[16:12:27.121] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.121]  - until=2
[16:12:27.121]  - relaying element #2
[16:12:27.122] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.122] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.122] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:27.123]  length: 4 (resolved future 2)
[16:12:27.123] Future #3
[16:12:27.124] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:27.124] - nx: 6
[16:12:27.124] - relay: TRUE
[16:12:27.124] - stdout: TRUE
[16:12:27.125] - signal: TRUE
[16:12:27.125] - resignal: FALSE
[16:12:27.125] - force: TRUE
[16:12:27.125] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.125] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.125]  - until=3
[16:12:27.125]  - relaying element #3
[16:12:27.126] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.126] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.126] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:27.126]  length: 3 (resolved future 3)
[16:12:27.126] signalConditionsASAP(NULL, pos=4) ...
[16:12:27.126] - nx: 6
[16:12:27.126] - relay: TRUE
[16:12:27.127] - stdout: TRUE
[16:12:27.127] - signal: TRUE
[16:12:27.127] - resignal: FALSE
[16:12:27.127] - force: TRUE
[16:12:27.127] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.127] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.127]  - until=5
[16:12:27.127]  - relaying element #5
[16:12:27.128] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.128] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.128] signalConditionsASAP(NULL, pos=4) ... done
[16:12:27.128]  length: 2 (resolved future 4)
[16:12:27.128] signalConditionsASAP(NULL, pos=5) ...
[16:12:27.128] - nx: 6
[16:12:27.128] - relay: TRUE
[16:12:27.128] - stdout: TRUE
[16:12:27.128] - signal: TRUE
[16:12:27.129] - resignal: FALSE
[16:12:27.129] - force: TRUE
[16:12:27.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.129] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.129]  - until=6
[16:12:27.129]  - relaying element #6
[16:12:27.129] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.129] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.129] signalConditionsASAP(NULL, pos=5) ... done
[16:12:27.130]  length: 1 (resolved future 5)
[16:12:27.130] signalConditionsASAP(numeric, pos=6) ...
[16:12:27.130] - nx: 6
[16:12:27.130] - relay: TRUE
[16:12:27.130] - stdout: TRUE
[16:12:27.130] - signal: TRUE
[16:12:27.130] - resignal: FALSE
[16:12:27.130] - force: TRUE
[16:12:27.130] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.130] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.131]  - until=6
[16:12:27.131] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.131] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.131] signalConditionsASAP(numeric, pos=6) ... done
[16:12:27.131]  length: 0 (resolved future 6)
[16:12:27.131] Relaying remaining futures
[16:12:27.131] signalConditionsASAP(NULL, pos=0) ...
[16:12:27.131] - nx: 6
[16:12:27.131] - relay: TRUE
[16:12:27.131] - stdout: TRUE
[16:12:27.132] - signal: TRUE
[16:12:27.132] - resignal: FALSE
[16:12:27.132] - force: TRUE
[16:12:27.132] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.132] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:27.132] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.132] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.132] signalConditionsASAP(NULL, pos=0) ... done
[16:12:27.132] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:12:27.136] getGlobalsAndPackages() ...
[16:12:27.136] Searching for globals...
[16:12:27.137] 
[16:12:27.137] Searching for globals ... DONE
[16:12:27.137] - globals: [0] <none>
[16:12:27.137] getGlobalsAndPackages() ... DONE
[16:12:27.137] run() for ‘Future’ ...
[16:12:27.137] - state: ‘created’
[16:12:27.138] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.141] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.142]   - Field: ‘label’
[16:12:27.142]   - Field: ‘local’
[16:12:27.142]   - Field: ‘owner’
[16:12:27.142]   - Field: ‘envir’
[16:12:27.142]   - Field: ‘workers’
[16:12:27.142]   - Field: ‘packages’
[16:12:27.142]   - Field: ‘gc’
[16:12:27.142]   - Field: ‘job’
[16:12:27.142]   - Field: ‘conditions’
[16:12:27.143]   - Field: ‘expr’
[16:12:27.143]   - Field: ‘uuid’
[16:12:27.143]   - Field: ‘seed’
[16:12:27.143]   - Field: ‘version’
[16:12:27.143]   - Field: ‘result’
[16:12:27.143]   - Field: ‘asynchronous’
[16:12:27.143]   - Field: ‘calls’
[16:12:27.143]   - Field: ‘globals’
[16:12:27.143]   - Field: ‘stdout’
[16:12:27.143]   - Field: ‘earlySignal’
[16:12:27.143]   - Field: ‘lazy’
[16:12:27.144]   - Field: ‘state’
[16:12:27.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.144] - Launch lazy future ...
[16:12:27.144] Packages needed by the future expression (n = 0): <none>
[16:12:27.144] Packages needed by future strategies (n = 0): <none>
[16:12:27.145] {
[16:12:27.145]     {
[16:12:27.145]         {
[16:12:27.145]             ...future.startTime <- base::Sys.time()
[16:12:27.145]             {
[16:12:27.145]                 {
[16:12:27.145]                   {
[16:12:27.145]                     {
[16:12:27.145]                       base::local({
[16:12:27.145]                         has_future <- base::requireNamespace("future", 
[16:12:27.145]                           quietly = TRUE)
[16:12:27.145]                         if (has_future) {
[16:12:27.145]                           ns <- base::getNamespace("future")
[16:12:27.145]                           version <- ns[[".package"]][["version"]]
[16:12:27.145]                           if (is.null(version)) 
[16:12:27.145]                             version <- utils::packageVersion("future")
[16:12:27.145]                         }
[16:12:27.145]                         else {
[16:12:27.145]                           version <- NULL
[16:12:27.145]                         }
[16:12:27.145]                         if (!has_future || version < "1.8.0") {
[16:12:27.145]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.145]                             "", base::R.version$version.string), 
[16:12:27.145]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.145]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.145]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.145]                               "release", "version")], collapse = " "), 
[16:12:27.145]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.145]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.145]                             info)
[16:12:27.145]                           info <- base::paste(info, collapse = "; ")
[16:12:27.145]                           if (!has_future) {
[16:12:27.145]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.145]                               info)
[16:12:27.145]                           }
[16:12:27.145]                           else {
[16:12:27.145]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.145]                               info, version)
[16:12:27.145]                           }
[16:12:27.145]                           base::stop(msg)
[16:12:27.145]                         }
[16:12:27.145]                       })
[16:12:27.145]                     }
[16:12:27.145]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.145]                     base::options(mc.cores = 1L)
[16:12:27.145]                   }
[16:12:27.145]                   options(future.plan = NULL)
[16:12:27.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.145]                 }
[16:12:27.145]                 ...future.workdir <- getwd()
[16:12:27.145]             }
[16:12:27.145]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.145]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.145]         }
[16:12:27.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.145]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.145]             base::names(...future.oldOptions))
[16:12:27.145]     }
[16:12:27.145]     if (FALSE) {
[16:12:27.145]     }
[16:12:27.145]     else {
[16:12:27.145]         if (TRUE) {
[16:12:27.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.145]                 open = "w")
[16:12:27.145]         }
[16:12:27.145]         else {
[16:12:27.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.145]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.145]         }
[16:12:27.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.145]             base::sink(type = "output", split = FALSE)
[16:12:27.145]             base::close(...future.stdout)
[16:12:27.145]         }, add = TRUE)
[16:12:27.145]     }
[16:12:27.145]     ...future.frame <- base::sys.nframe()
[16:12:27.145]     ...future.conditions <- base::list()
[16:12:27.145]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.145]     if (FALSE) {
[16:12:27.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.145]     }
[16:12:27.145]     ...future.result <- base::tryCatch({
[16:12:27.145]         base::withCallingHandlers({
[16:12:27.145]             ...future.value <- base::withVisible(base::local({
[16:12:27.145]                 withCallingHandlers({
[16:12:27.145]                   2
[16:12:27.145]                 }, immediateCondition = function(cond) {
[16:12:27.145]                   save_rds <- function (object, pathname, ...) 
[16:12:27.145]                   {
[16:12:27.145]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.145]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.145]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.145]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.145]                         fi_tmp[["mtime"]])
[16:12:27.145]                     }
[16:12:27.145]                     tryCatch({
[16:12:27.145]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.145]                     }, error = function(ex) {
[16:12:27.145]                       msg <- conditionMessage(ex)
[16:12:27.145]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.145]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.145]                         fi_tmp[["mtime"]], msg)
[16:12:27.145]                       ex$message <- msg
[16:12:27.145]                       stop(ex)
[16:12:27.145]                     })
[16:12:27.145]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.145]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.145]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.145]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.145]                       fi <- file.info(pathname)
[16:12:27.145]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.145]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.145]                         fi[["size"]], fi[["mtime"]])
[16:12:27.145]                       stop(msg)
[16:12:27.145]                     }
[16:12:27.145]                     invisible(pathname)
[16:12:27.145]                   }
[16:12:27.145]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.145]                     rootPath = tempdir()) 
[16:12:27.145]                   {
[16:12:27.145]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.145]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.145]                       tmpdir = path, fileext = ".rds")
[16:12:27.145]                     save_rds(obj, file)
[16:12:27.145]                   }
[16:12:27.145]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.145]                   {
[16:12:27.145]                     inherits <- base::inherits
[16:12:27.145]                     invokeRestart <- base::invokeRestart
[16:12:27.145]                     is.null <- base::is.null
[16:12:27.145]                     muffled <- FALSE
[16:12:27.145]                     if (inherits(cond, "message")) {
[16:12:27.145]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.145]                       if (muffled) 
[16:12:27.145]                         invokeRestart("muffleMessage")
[16:12:27.145]                     }
[16:12:27.145]                     else if (inherits(cond, "warning")) {
[16:12:27.145]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.145]                       if (muffled) 
[16:12:27.145]                         invokeRestart("muffleWarning")
[16:12:27.145]                     }
[16:12:27.145]                     else if (inherits(cond, "condition")) {
[16:12:27.145]                       if (!is.null(pattern)) {
[16:12:27.145]                         computeRestarts <- base::computeRestarts
[16:12:27.145]                         grepl <- base::grepl
[16:12:27.145]                         restarts <- computeRestarts(cond)
[16:12:27.145]                         for (restart in restarts) {
[16:12:27.145]                           name <- restart$name
[16:12:27.145]                           if (is.null(name)) 
[16:12:27.145]                             next
[16:12:27.145]                           if (!grepl(pattern, name)) 
[16:12:27.145]                             next
[16:12:27.145]                           invokeRestart(restart)
[16:12:27.145]                           muffled <- TRUE
[16:12:27.145]                           break
[16:12:27.145]                         }
[16:12:27.145]                       }
[16:12:27.145]                     }
[16:12:27.145]                     invisible(muffled)
[16:12:27.145]                   }
[16:12:27.145]                   muffleCondition(cond)
[16:12:27.145]                 })
[16:12:27.145]             }))
[16:12:27.145]             future::FutureResult(value = ...future.value$value, 
[16:12:27.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.145]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.145]                     ...future.globalenv.names))
[16:12:27.145]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.145]         }, condition = base::local({
[16:12:27.145]             c <- base::c
[16:12:27.145]             inherits <- base::inherits
[16:12:27.145]             invokeRestart <- base::invokeRestart
[16:12:27.145]             length <- base::length
[16:12:27.145]             list <- base::list
[16:12:27.145]             seq.int <- base::seq.int
[16:12:27.145]             signalCondition <- base::signalCondition
[16:12:27.145]             sys.calls <- base::sys.calls
[16:12:27.145]             `[[` <- base::`[[`
[16:12:27.145]             `+` <- base::`+`
[16:12:27.145]             `<<-` <- base::`<<-`
[16:12:27.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.145]                   3L)]
[16:12:27.145]             }
[16:12:27.145]             function(cond) {
[16:12:27.145]                 is_error <- inherits(cond, "error")
[16:12:27.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.145]                   NULL)
[16:12:27.145]                 if (is_error) {
[16:12:27.145]                   sessionInformation <- function() {
[16:12:27.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.145]                       search = base::search(), system = base::Sys.info())
[16:12:27.145]                   }
[16:12:27.145]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.145]                     cond$call), session = sessionInformation(), 
[16:12:27.145]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.145]                   signalCondition(cond)
[16:12:27.145]                 }
[16:12:27.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.145]                 "immediateCondition"))) {
[16:12:27.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.145]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.145]                   if (TRUE && !signal) {
[16:12:27.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.145]                     {
[16:12:27.145]                       inherits <- base::inherits
[16:12:27.145]                       invokeRestart <- base::invokeRestart
[16:12:27.145]                       is.null <- base::is.null
[16:12:27.145]                       muffled <- FALSE
[16:12:27.145]                       if (inherits(cond, "message")) {
[16:12:27.145]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.145]                         if (muffled) 
[16:12:27.145]                           invokeRestart("muffleMessage")
[16:12:27.145]                       }
[16:12:27.145]                       else if (inherits(cond, "warning")) {
[16:12:27.145]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.145]                         if (muffled) 
[16:12:27.145]                           invokeRestart("muffleWarning")
[16:12:27.145]                       }
[16:12:27.145]                       else if (inherits(cond, "condition")) {
[16:12:27.145]                         if (!is.null(pattern)) {
[16:12:27.145]                           computeRestarts <- base::computeRestarts
[16:12:27.145]                           grepl <- base::grepl
[16:12:27.145]                           restarts <- computeRestarts(cond)
[16:12:27.145]                           for (restart in restarts) {
[16:12:27.145]                             name <- restart$name
[16:12:27.145]                             if (is.null(name)) 
[16:12:27.145]                               next
[16:12:27.145]                             if (!grepl(pattern, name)) 
[16:12:27.145]                               next
[16:12:27.145]                             invokeRestart(restart)
[16:12:27.145]                             muffled <- TRUE
[16:12:27.145]                             break
[16:12:27.145]                           }
[16:12:27.145]                         }
[16:12:27.145]                       }
[16:12:27.145]                       invisible(muffled)
[16:12:27.145]                     }
[16:12:27.145]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.145]                   }
[16:12:27.145]                 }
[16:12:27.145]                 else {
[16:12:27.145]                   if (TRUE) {
[16:12:27.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.145]                     {
[16:12:27.145]                       inherits <- base::inherits
[16:12:27.145]                       invokeRestart <- base::invokeRestart
[16:12:27.145]                       is.null <- base::is.null
[16:12:27.145]                       muffled <- FALSE
[16:12:27.145]                       if (inherits(cond, "message")) {
[16:12:27.145]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.145]                         if (muffled) 
[16:12:27.145]                           invokeRestart("muffleMessage")
[16:12:27.145]                       }
[16:12:27.145]                       else if (inherits(cond, "warning")) {
[16:12:27.145]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.145]                         if (muffled) 
[16:12:27.145]                           invokeRestart("muffleWarning")
[16:12:27.145]                       }
[16:12:27.145]                       else if (inherits(cond, "condition")) {
[16:12:27.145]                         if (!is.null(pattern)) {
[16:12:27.145]                           computeRestarts <- base::computeRestarts
[16:12:27.145]                           grepl <- base::grepl
[16:12:27.145]                           restarts <- computeRestarts(cond)
[16:12:27.145]                           for (restart in restarts) {
[16:12:27.145]                             name <- restart$name
[16:12:27.145]                             if (is.null(name)) 
[16:12:27.145]                               next
[16:12:27.145]                             if (!grepl(pattern, name)) 
[16:12:27.145]                               next
[16:12:27.145]                             invokeRestart(restart)
[16:12:27.145]                             muffled <- TRUE
[16:12:27.145]                             break
[16:12:27.145]                           }
[16:12:27.145]                         }
[16:12:27.145]                       }
[16:12:27.145]                       invisible(muffled)
[16:12:27.145]                     }
[16:12:27.145]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.145]                   }
[16:12:27.145]                 }
[16:12:27.145]             }
[16:12:27.145]         }))
[16:12:27.145]     }, error = function(ex) {
[16:12:27.145]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.145]                 ...future.rng), started = ...future.startTime, 
[16:12:27.145]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.145]             version = "1.8"), class = "FutureResult")
[16:12:27.145]     }, finally = {
[16:12:27.145]         if (!identical(...future.workdir, getwd())) 
[16:12:27.145]             setwd(...future.workdir)
[16:12:27.145]         {
[16:12:27.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.145]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.145]             }
[16:12:27.145]             base::options(...future.oldOptions)
[16:12:27.145]             if (.Platform$OS.type == "windows") {
[16:12:27.145]                 old_names <- names(...future.oldEnvVars)
[16:12:27.145]                 envs <- base::Sys.getenv()
[16:12:27.145]                 names <- names(envs)
[16:12:27.145]                 common <- intersect(names, old_names)
[16:12:27.145]                 added <- setdiff(names, old_names)
[16:12:27.145]                 removed <- setdiff(old_names, names)
[16:12:27.145]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.145]                   envs[common]]
[16:12:27.145]                 NAMES <- toupper(changed)
[16:12:27.145]                 args <- list()
[16:12:27.145]                 for (kk in seq_along(NAMES)) {
[16:12:27.145]                   name <- changed[[kk]]
[16:12:27.145]                   NAME <- NAMES[[kk]]
[16:12:27.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.145]                     next
[16:12:27.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.145]                 }
[16:12:27.145]                 NAMES <- toupper(added)
[16:12:27.145]                 for (kk in seq_along(NAMES)) {
[16:12:27.145]                   name <- added[[kk]]
[16:12:27.145]                   NAME <- NAMES[[kk]]
[16:12:27.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.145]                     next
[16:12:27.145]                   args[[name]] <- ""
[16:12:27.145]                 }
[16:12:27.145]                 NAMES <- toupper(removed)
[16:12:27.145]                 for (kk in seq_along(NAMES)) {
[16:12:27.145]                   name <- removed[[kk]]
[16:12:27.145]                   NAME <- NAMES[[kk]]
[16:12:27.145]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.145]                     next
[16:12:27.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.145]                 }
[16:12:27.145]                 if (length(args) > 0) 
[16:12:27.145]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.145]             }
[16:12:27.145]             else {
[16:12:27.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.145]             }
[16:12:27.145]             {
[16:12:27.145]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.145]                   0L) {
[16:12:27.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.145]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.145]                   base::options(opts)
[16:12:27.145]                 }
[16:12:27.145]                 {
[16:12:27.145]                   {
[16:12:27.145]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.145]                     NULL
[16:12:27.145]                   }
[16:12:27.145]                   options(future.plan = NULL)
[16:12:27.145]                   if (is.na(NA_character_)) 
[16:12:27.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.145]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.145]                     envir = parent.frame()) 
[16:12:27.145]                   {
[16:12:27.145]                     default_workers <- missing(workers)
[16:12:27.145]                     if (is.function(workers)) 
[16:12:27.145]                       workers <- workers()
[16:12:27.145]                     workers <- structure(as.integer(workers), 
[16:12:27.145]                       class = class(workers))
[16:12:27.145]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.145]                       1L)
[16:12:27.145]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.145]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.145]                       if (default_workers) 
[16:12:27.145]                         supportsMulticore(warn = TRUE)
[16:12:27.145]                       return(sequential(..., envir = envir))
[16:12:27.145]                     }
[16:12:27.145]                     oopts <- options(mc.cores = workers)
[16:12:27.145]                     on.exit(options(oopts))
[16:12:27.145]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.145]                       envir = envir)
[16:12:27.145]                     if (!future$lazy) 
[16:12:27.145]                       future <- run(future)
[16:12:27.145]                     invisible(future)
[16:12:27.145]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.145]                 }
[16:12:27.145]             }
[16:12:27.145]         }
[16:12:27.145]     })
[16:12:27.145]     if (TRUE) {
[16:12:27.145]         base::sink(type = "output", split = FALSE)
[16:12:27.145]         if (TRUE) {
[16:12:27.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.145]         }
[16:12:27.145]         else {
[16:12:27.145]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.145]         }
[16:12:27.145]         base::close(...future.stdout)
[16:12:27.145]         ...future.stdout <- NULL
[16:12:27.145]     }
[16:12:27.145]     ...future.result$conditions <- ...future.conditions
[16:12:27.145]     ...future.result$finished <- base::Sys.time()
[16:12:27.145]     ...future.result
[16:12:27.145] }
[16:12:27.147] requestCore(): workers = 2
[16:12:27.149] MulticoreFuture started
[16:12:27.149] - Launch lazy future ... done
[16:12:27.149] run() for ‘MulticoreFuture’ ... done
[16:12:27.150] getGlobalsAndPackages() ...
[16:12:27.150] Searching for globals...
[16:12:27.150] plan(): Setting new future strategy stack:
[16:12:27.150] List of future strategies:
[16:12:27.150] 1. sequential:
[16:12:27.150]    - args: function (..., envir = parent.frame())
[16:12:27.150]    - tweaked: FALSE
[16:12:27.150]    - call: NULL
[16:12:27.151] 
[16:12:27.151] Searching for globals ... DONE
[16:12:27.151] plan(): nbrOfWorkers() = 1
[16:12:27.151] - globals: [0] <none>
[16:12:27.151] getGlobalsAndPackages() ... DONE
[16:12:27.152] run() for ‘Future’ ...
[16:12:27.152] - state: ‘created’
[16:12:27.152] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.153] plan(): Setting new future strategy stack:
[16:12:27.153] List of future strategies:
[16:12:27.153] 1. multicore:
[16:12:27.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.153]    - tweaked: FALSE
[16:12:27.153]    - call: plan(strategy)
[16:12:27.157] plan(): nbrOfWorkers() = 2
[16:12:27.158] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.158] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.158]   - Field: ‘label’
[16:12:27.158]   - Field: ‘local’
[16:12:27.158]   - Field: ‘owner’
[16:12:27.159]   - Field: ‘envir’
[16:12:27.159]   - Field: ‘workers’
[16:12:27.159]   - Field: ‘packages’
[16:12:27.159]   - Field: ‘gc’
[16:12:27.159]   - Field: ‘job’
[16:12:27.159]   - Field: ‘conditions’
[16:12:27.160]   - Field: ‘expr’
[16:12:27.160]   - Field: ‘uuid’
[16:12:27.160]   - Field: ‘seed’
[16:12:27.160]   - Field: ‘version’
[16:12:27.160]   - Field: ‘result’
[16:12:27.160]   - Field: ‘asynchronous’
[16:12:27.160]   - Field: ‘calls’
[16:12:27.164]   - Field: ‘globals’
[16:12:27.165]   - Field: ‘stdout’
[16:12:27.165]   - Field: ‘earlySignal’
[16:12:27.165]   - Field: ‘lazy’
[16:12:27.165]   - Field: ‘state’
[16:12:27.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.166] - Launch lazy future ...
[16:12:27.167] Packages needed by the future expression (n = 0): <none>
[16:12:27.167] Packages needed by future strategies (n = 0): <none>
[16:12:27.169] {
[16:12:27.169]     {
[16:12:27.169]         {
[16:12:27.169]             ...future.startTime <- base::Sys.time()
[16:12:27.169]             {
[16:12:27.169]                 {
[16:12:27.169]                   {
[16:12:27.169]                     {
[16:12:27.169]                       base::local({
[16:12:27.169]                         has_future <- base::requireNamespace("future", 
[16:12:27.169]                           quietly = TRUE)
[16:12:27.169]                         if (has_future) {
[16:12:27.169]                           ns <- base::getNamespace("future")
[16:12:27.169]                           version <- ns[[".package"]][["version"]]
[16:12:27.169]                           if (is.null(version)) 
[16:12:27.169]                             version <- utils::packageVersion("future")
[16:12:27.169]                         }
[16:12:27.169]                         else {
[16:12:27.169]                           version <- NULL
[16:12:27.169]                         }
[16:12:27.169]                         if (!has_future || version < "1.8.0") {
[16:12:27.169]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.169]                             "", base::R.version$version.string), 
[16:12:27.169]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.169]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.169]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.169]                               "release", "version")], collapse = " "), 
[16:12:27.169]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.169]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.169]                             info)
[16:12:27.169]                           info <- base::paste(info, collapse = "; ")
[16:12:27.169]                           if (!has_future) {
[16:12:27.169]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.169]                               info)
[16:12:27.169]                           }
[16:12:27.169]                           else {
[16:12:27.169]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.169]                               info, version)
[16:12:27.169]                           }
[16:12:27.169]                           base::stop(msg)
[16:12:27.169]                         }
[16:12:27.169]                       })
[16:12:27.169]                     }
[16:12:27.169]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.169]                     base::options(mc.cores = 1L)
[16:12:27.169]                   }
[16:12:27.169]                   options(future.plan = NULL)
[16:12:27.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.169]                 }
[16:12:27.169]                 ...future.workdir <- getwd()
[16:12:27.169]             }
[16:12:27.169]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.169]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.169]         }
[16:12:27.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.169]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.169]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.169]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.169]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.169]             base::names(...future.oldOptions))
[16:12:27.169]     }
[16:12:27.169]     if (FALSE) {
[16:12:27.169]     }
[16:12:27.169]     else {
[16:12:27.169]         if (TRUE) {
[16:12:27.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.169]                 open = "w")
[16:12:27.169]         }
[16:12:27.169]         else {
[16:12:27.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.169]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.169]         }
[16:12:27.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.169]             base::sink(type = "output", split = FALSE)
[16:12:27.169]             base::close(...future.stdout)
[16:12:27.169]         }, add = TRUE)
[16:12:27.169]     }
[16:12:27.169]     ...future.frame <- base::sys.nframe()
[16:12:27.169]     ...future.conditions <- base::list()
[16:12:27.169]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.169]     if (FALSE) {
[16:12:27.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.169]     }
[16:12:27.169]     ...future.result <- base::tryCatch({
[16:12:27.169]         base::withCallingHandlers({
[16:12:27.169]             ...future.value <- base::withVisible(base::local({
[16:12:27.169]                 withCallingHandlers({
[16:12:27.169]                   NULL
[16:12:27.169]                 }, immediateCondition = function(cond) {
[16:12:27.169]                   save_rds <- function (object, pathname, ...) 
[16:12:27.169]                   {
[16:12:27.169]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.169]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.169]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.169]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.169]                         fi_tmp[["mtime"]])
[16:12:27.169]                     }
[16:12:27.169]                     tryCatch({
[16:12:27.169]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.169]                     }, error = function(ex) {
[16:12:27.169]                       msg <- conditionMessage(ex)
[16:12:27.169]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.169]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.169]                         fi_tmp[["mtime"]], msg)
[16:12:27.169]                       ex$message <- msg
[16:12:27.169]                       stop(ex)
[16:12:27.169]                     })
[16:12:27.169]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.169]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.169]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.169]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.169]                       fi <- file.info(pathname)
[16:12:27.169]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.169]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.169]                         fi[["size"]], fi[["mtime"]])
[16:12:27.169]                       stop(msg)
[16:12:27.169]                     }
[16:12:27.169]                     invisible(pathname)
[16:12:27.169]                   }
[16:12:27.169]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.169]                     rootPath = tempdir()) 
[16:12:27.169]                   {
[16:12:27.169]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.169]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.169]                       tmpdir = path, fileext = ".rds")
[16:12:27.169]                     save_rds(obj, file)
[16:12:27.169]                   }
[16:12:27.169]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.169]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.169]                   {
[16:12:27.169]                     inherits <- base::inherits
[16:12:27.169]                     invokeRestart <- base::invokeRestart
[16:12:27.169]                     is.null <- base::is.null
[16:12:27.169]                     muffled <- FALSE
[16:12:27.169]                     if (inherits(cond, "message")) {
[16:12:27.169]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.169]                       if (muffled) 
[16:12:27.169]                         invokeRestart("muffleMessage")
[16:12:27.169]                     }
[16:12:27.169]                     else if (inherits(cond, "warning")) {
[16:12:27.169]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.169]                       if (muffled) 
[16:12:27.169]                         invokeRestart("muffleWarning")
[16:12:27.169]                     }
[16:12:27.169]                     else if (inherits(cond, "condition")) {
[16:12:27.169]                       if (!is.null(pattern)) {
[16:12:27.169]                         computeRestarts <- base::computeRestarts
[16:12:27.169]                         grepl <- base::grepl
[16:12:27.169]                         restarts <- computeRestarts(cond)
[16:12:27.169]                         for (restart in restarts) {
[16:12:27.169]                           name <- restart$name
[16:12:27.169]                           if (is.null(name)) 
[16:12:27.169]                             next
[16:12:27.169]                           if (!grepl(pattern, name)) 
[16:12:27.169]                             next
[16:12:27.169]                           invokeRestart(restart)
[16:12:27.169]                           muffled <- TRUE
[16:12:27.169]                           break
[16:12:27.169]                         }
[16:12:27.169]                       }
[16:12:27.169]                     }
[16:12:27.169]                     invisible(muffled)
[16:12:27.169]                   }
[16:12:27.169]                   muffleCondition(cond)
[16:12:27.169]                 })
[16:12:27.169]             }))
[16:12:27.169]             future::FutureResult(value = ...future.value$value, 
[16:12:27.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.169]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.169]                     ...future.globalenv.names))
[16:12:27.169]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.169]         }, condition = base::local({
[16:12:27.169]             c <- base::c
[16:12:27.169]             inherits <- base::inherits
[16:12:27.169]             invokeRestart <- base::invokeRestart
[16:12:27.169]             length <- base::length
[16:12:27.169]             list <- base::list
[16:12:27.169]             seq.int <- base::seq.int
[16:12:27.169]             signalCondition <- base::signalCondition
[16:12:27.169]             sys.calls <- base::sys.calls
[16:12:27.169]             `[[` <- base::`[[`
[16:12:27.169]             `+` <- base::`+`
[16:12:27.169]             `<<-` <- base::`<<-`
[16:12:27.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.169]                   3L)]
[16:12:27.169]             }
[16:12:27.169]             function(cond) {
[16:12:27.169]                 is_error <- inherits(cond, "error")
[16:12:27.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.169]                   NULL)
[16:12:27.169]                 if (is_error) {
[16:12:27.169]                   sessionInformation <- function() {
[16:12:27.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.169]                       search = base::search(), system = base::Sys.info())
[16:12:27.169]                   }
[16:12:27.169]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.169]                     cond$call), session = sessionInformation(), 
[16:12:27.169]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.169]                   signalCondition(cond)
[16:12:27.169]                 }
[16:12:27.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.169]                 "immediateCondition"))) {
[16:12:27.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.169]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.169]                   if (TRUE && !signal) {
[16:12:27.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.169]                     {
[16:12:27.169]                       inherits <- base::inherits
[16:12:27.169]                       invokeRestart <- base::invokeRestart
[16:12:27.169]                       is.null <- base::is.null
[16:12:27.169]                       muffled <- FALSE
[16:12:27.169]                       if (inherits(cond, "message")) {
[16:12:27.169]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.169]                         if (muffled) 
[16:12:27.169]                           invokeRestart("muffleMessage")
[16:12:27.169]                       }
[16:12:27.169]                       else if (inherits(cond, "warning")) {
[16:12:27.169]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.169]                         if (muffled) 
[16:12:27.169]                           invokeRestart("muffleWarning")
[16:12:27.169]                       }
[16:12:27.169]                       else if (inherits(cond, "condition")) {
[16:12:27.169]                         if (!is.null(pattern)) {
[16:12:27.169]                           computeRestarts <- base::computeRestarts
[16:12:27.169]                           grepl <- base::grepl
[16:12:27.169]                           restarts <- computeRestarts(cond)
[16:12:27.169]                           for (restart in restarts) {
[16:12:27.169]                             name <- restart$name
[16:12:27.169]                             if (is.null(name)) 
[16:12:27.169]                               next
[16:12:27.169]                             if (!grepl(pattern, name)) 
[16:12:27.169]                               next
[16:12:27.169]                             invokeRestart(restart)
[16:12:27.169]                             muffled <- TRUE
[16:12:27.169]                             break
[16:12:27.169]                           }
[16:12:27.169]                         }
[16:12:27.169]                       }
[16:12:27.169]                       invisible(muffled)
[16:12:27.169]                     }
[16:12:27.169]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.169]                   }
[16:12:27.169]                 }
[16:12:27.169]                 else {
[16:12:27.169]                   if (TRUE) {
[16:12:27.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.169]                     {
[16:12:27.169]                       inherits <- base::inherits
[16:12:27.169]                       invokeRestart <- base::invokeRestart
[16:12:27.169]                       is.null <- base::is.null
[16:12:27.169]                       muffled <- FALSE
[16:12:27.169]                       if (inherits(cond, "message")) {
[16:12:27.169]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.169]                         if (muffled) 
[16:12:27.169]                           invokeRestart("muffleMessage")
[16:12:27.169]                       }
[16:12:27.169]                       else if (inherits(cond, "warning")) {
[16:12:27.169]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.169]                         if (muffled) 
[16:12:27.169]                           invokeRestart("muffleWarning")
[16:12:27.169]                       }
[16:12:27.169]                       else if (inherits(cond, "condition")) {
[16:12:27.169]                         if (!is.null(pattern)) {
[16:12:27.169]                           computeRestarts <- base::computeRestarts
[16:12:27.169]                           grepl <- base::grepl
[16:12:27.169]                           restarts <- computeRestarts(cond)
[16:12:27.169]                           for (restart in restarts) {
[16:12:27.169]                             name <- restart$name
[16:12:27.169]                             if (is.null(name)) 
[16:12:27.169]                               next
[16:12:27.169]                             if (!grepl(pattern, name)) 
[16:12:27.169]                               next
[16:12:27.169]                             invokeRestart(restart)
[16:12:27.169]                             muffled <- TRUE
[16:12:27.169]                             break
[16:12:27.169]                           }
[16:12:27.169]                         }
[16:12:27.169]                       }
[16:12:27.169]                       invisible(muffled)
[16:12:27.169]                     }
[16:12:27.169]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.169]                   }
[16:12:27.169]                 }
[16:12:27.169]             }
[16:12:27.169]         }))
[16:12:27.169]     }, error = function(ex) {
[16:12:27.169]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.169]                 ...future.rng), started = ...future.startTime, 
[16:12:27.169]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.169]             version = "1.8"), class = "FutureResult")
[16:12:27.169]     }, finally = {
[16:12:27.169]         if (!identical(...future.workdir, getwd())) 
[16:12:27.169]             setwd(...future.workdir)
[16:12:27.169]         {
[16:12:27.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.169]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.169]             }
[16:12:27.169]             base::options(...future.oldOptions)
[16:12:27.169]             if (.Platform$OS.type == "windows") {
[16:12:27.169]                 old_names <- names(...future.oldEnvVars)
[16:12:27.169]                 envs <- base::Sys.getenv()
[16:12:27.169]                 names <- names(envs)
[16:12:27.169]                 common <- intersect(names, old_names)
[16:12:27.169]                 added <- setdiff(names, old_names)
[16:12:27.169]                 removed <- setdiff(old_names, names)
[16:12:27.169]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.169]                   envs[common]]
[16:12:27.169]                 NAMES <- toupper(changed)
[16:12:27.169]                 args <- list()
[16:12:27.169]                 for (kk in seq_along(NAMES)) {
[16:12:27.169]                   name <- changed[[kk]]
[16:12:27.169]                   NAME <- NAMES[[kk]]
[16:12:27.169]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.169]                     next
[16:12:27.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.169]                 }
[16:12:27.169]                 NAMES <- toupper(added)
[16:12:27.169]                 for (kk in seq_along(NAMES)) {
[16:12:27.169]                   name <- added[[kk]]
[16:12:27.169]                   NAME <- NAMES[[kk]]
[16:12:27.169]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.169]                     next
[16:12:27.169]                   args[[name]] <- ""
[16:12:27.169]                 }
[16:12:27.169]                 NAMES <- toupper(removed)
[16:12:27.169]                 for (kk in seq_along(NAMES)) {
[16:12:27.169]                   name <- removed[[kk]]
[16:12:27.169]                   NAME <- NAMES[[kk]]
[16:12:27.169]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.169]                     next
[16:12:27.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.169]                 }
[16:12:27.169]                 if (length(args) > 0) 
[16:12:27.169]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.169]             }
[16:12:27.169]             else {
[16:12:27.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.169]             }
[16:12:27.169]             {
[16:12:27.169]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.169]                   0L) {
[16:12:27.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.169]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.169]                   base::options(opts)
[16:12:27.169]                 }
[16:12:27.169]                 {
[16:12:27.169]                   {
[16:12:27.169]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.169]                     NULL
[16:12:27.169]                   }
[16:12:27.169]                   options(future.plan = NULL)
[16:12:27.169]                   if (is.na(NA_character_)) 
[16:12:27.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.169]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.169]                     envir = parent.frame()) 
[16:12:27.169]                   {
[16:12:27.169]                     default_workers <- missing(workers)
[16:12:27.169]                     if (is.function(workers)) 
[16:12:27.169]                       workers <- workers()
[16:12:27.169]                     workers <- structure(as.integer(workers), 
[16:12:27.169]                       class = class(workers))
[16:12:27.169]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.169]                       1L)
[16:12:27.169]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.169]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.169]                       if (default_workers) 
[16:12:27.169]                         supportsMulticore(warn = TRUE)
[16:12:27.169]                       return(sequential(..., envir = envir))
[16:12:27.169]                     }
[16:12:27.169]                     oopts <- options(mc.cores = workers)
[16:12:27.169]                     on.exit(options(oopts))
[16:12:27.169]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.169]                       envir = envir)
[16:12:27.169]                     if (!future$lazy) 
[16:12:27.169]                       future <- run(future)
[16:12:27.169]                     invisible(future)
[16:12:27.169]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.169]                 }
[16:12:27.169]             }
[16:12:27.169]         }
[16:12:27.169]     })
[16:12:27.169]     if (TRUE) {
[16:12:27.169]         base::sink(type = "output", split = FALSE)
[16:12:27.169]         if (TRUE) {
[16:12:27.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.169]         }
[16:12:27.169]         else {
[16:12:27.169]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.169]         }
[16:12:27.169]         base::close(...future.stdout)
[16:12:27.169]         ...future.stdout <- NULL
[16:12:27.169]     }
[16:12:27.169]     ...future.result$conditions <- ...future.conditions
[16:12:27.169]     ...future.result$finished <- base::Sys.time()
[16:12:27.169]     ...future.result
[16:12:27.169] }
[16:12:27.172] requestCore(): workers = 2
[16:12:27.174] MulticoreFuture started
[16:12:27.174] - Launch lazy future ... done
[16:12:27.175] run() for ‘MulticoreFuture’ ... done
[16:12:27.175] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:12:27.175] List of future strategies:
[16:12:27.175] 1. sequential:
[16:12:27.175]    - args: function (..., envir = parent.frame())
[16:12:27.175]    - tweaked: FALSE
[16:12:27.175]    - call: NULL
[16:12:27.177] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baea11bc0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baedf8250> 
 $  : NULL
 $  : NULL
 $  :[16:12:27.179] plan(): Setting new future strategy stack:
[16:12:27.179] List of future strategies:
[16:12:27.179] 1. multicore:
[16:12:27.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.179]    - tweaked: FALSE
[16:12:27.179]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baea11bc0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baedf8250> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ :[16:12:27.185] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:27.189] resolve() on list ...
[16:12:27.189]  recursive: 0
[16:12:27.189]  length: 6
[16:12:27.190]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:27.190] signalConditionsASAP(numeric, pos=1) ...
[16:12:27.190] - nx: 6
[16:12:27.190] - relay: TRUE
[16:12:27.190] - stdout: TRUE
[16:12:27.190] - signal: TRUE
[16:12:27.190] - resignal: FALSE
[16:12:27.191] - force: TRUE
[16:12:27.191] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.191] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.191]  - until=2
[16:12:27.191]  - relaying element #2
[16:12:27.191] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.191] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.192] signalConditionsASAP(NULL, pos=1) ... done
[16:12:27.192]  length: 5 (resolved future 1)
[16:12:27.192] Future #2
[16:12:27.193] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:27.193] - nx: 6
[16:12:27.193] - relay: TRUE
[16:12:27.193] - stdout: TRUE
[16:12:27.194] - signal: TRUE
[16:12:27.194] - resignal: FALSE
[16:12:27.194] - force: TRUE
[16:12:27.194] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.194] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.194]  - until=2
[16:12:27.195]  - relaying element #2
[16:12:27.195] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.195] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.195] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:27.195]  length: 4 (resolved future 2)
[16:12:27.196] Future #3
[16:12:27.196] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:27.196] - nx: 6
[16:12:27.197] - relay: TRUE
[16:12:27.197] - stdout: TRUE
[16:12:27.197] - signal: TRUE
[16:12:27.197] - resignal: FALSE
[16:12:27.197] - force: TRUE
[16:12:27.197] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.197] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.198]  - until=3
[16:12:27.198]  - relaying element #3
[16:12:27.198] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.198] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.198] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:27.198]  length: 3 (resolved future 3)
[16:12:27.198] signalConditionsASAP(NULL, pos=4) ...
[16:12:27.198] - nx: 6
[16:12:27.199] - relay: TRUE
[16:12:27.199] - stdout: TRUE
[16:12:27.199] - signal: TRUE
[16:12:27.199] - resignal: FALSE
[16:12:27.199] - force: TRUE
[16:12:27.199] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.199] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.199]  - until=5
[16:12:27.199]  - relaying element #5
[16:12:27.200] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.200] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.200] signalConditionsASAP(NULL, pos=4) ... done
[16:12:27.200]  length: 2 (resolved future 4)
[16:12:27.200] signalConditionsASAP(NULL, pos=5) ...
[16:12:27.200] - nx: 6
[16:12:27.200] - relay: TRUE
[16:12:27.200] - stdout: TRUE
[16:12:27.200] - signal: TRUE
[16:12:27.201] - resignal: FALSE
[16:12:27.201] - force: TRUE
[16:12:27.201] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.201] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.201]  - until=6
[16:12:27.201]  - relaying element #6
[16:12:27.201] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.201] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.201] signalConditionsASAP(NULL, pos=5) ... done
[16:12:27.202]  length: 1 (resolved future 5)
[16:12:27.202] signalConditionsASAP(numeric, pos=6) ...
[16:12:27.202] - nx: 6
[16:12:27.202] - relay: TRUE
[16:12:27.202] - stdout: TRUE
[16:12:27.202] - signal: TRUE
[16:12:27.202] - resignal: FALSE
[16:12:27.202] - force: TRUE
[16:12:27.202] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.202]  - until=6
[16:12:27.203] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.203] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.203] signalConditionsASAP(numeric, pos=6) ... done
[16:12:27.203]  length: 0 (resolved future 6)
[16:12:27.203] Relaying remaining futures
[16:12:27.203] signalConditionsASAP(NULL, pos=0) ...
[16:12:27.203] - nx: 6
[16:12:27.203] - relay: TRUE
[16:12:27.203] - stdout: TRUE
[16:12:27.203] - signal: TRUE
[16:12:27.204] - resignal: FALSE
[16:12:27.204] - force: TRUE
[16:12:27.204] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.204] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:27.204] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.204] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.204] signalConditionsASAP(NULL, pos=0) ... done
[16:12:27.204] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:12:27.211] getGlobalsAndPackages() ...
[16:12:27.211] Searching for globals...
[16:12:27.212] 
[16:12:27.212] Searching for globals ... DONE
[16:12:27.212] - globals: [0] <none>
[16:12:27.212] getGlobalsAndPackages() ... DONE
[16:12:27.212] run() for ‘Future’ ...
[16:12:27.212] - state: ‘created’
[16:12:27.213] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.217] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.217] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.217]   - Field: ‘label’
[16:12:27.217]   - Field: ‘local’
[16:12:27.217]   - Field: ‘owner’
[16:12:27.217]   - Field: ‘envir’
[16:12:27.217]   - Field: ‘workers’
[16:12:27.217]   - Field: ‘packages’
[16:12:27.217]   - Field: ‘gc’
[16:12:27.218]   - Field: ‘job’
[16:12:27.218]   - Field: ‘conditions’
[16:12:27.218]   - Field: ‘expr’
[16:12:27.218]   - Field: ‘uuid’
[16:12:27.218]   - Field: ‘seed’
[16:12:27.218]   - Field: ‘version’
[16:12:27.218]   - Field: ‘result’
[16:12:27.218]   - Field: ‘asynchronous’
[16:12:27.218]   - Field: ‘calls’
[16:12:27.218]   - Field: ‘globals’
[16:12:27.219]   - Field: ‘stdout’
[16:12:27.219]   - Field: ‘earlySignal’
[16:12:27.219]   - Field: ‘lazy’
[16:12:27.219]   - Field: ‘state’
[16:12:27.219] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.219] - Launch lazy future ...
[16:12:27.219] Packages needed by the future expression (n = 0): <none>
[16:12:27.219] Packages needed by future strategies (n = 0): <none>
[16:12:27.220] {
[16:12:27.220]     {
[16:12:27.220]         {
[16:12:27.220]             ...future.startTime <- base::Sys.time()
[16:12:27.220]             {
[16:12:27.220]                 {
[16:12:27.220]                   {
[16:12:27.220]                     {
[16:12:27.220]                       base::local({
[16:12:27.220]                         has_future <- base::requireNamespace("future", 
[16:12:27.220]                           quietly = TRUE)
[16:12:27.220]                         if (has_future) {
[16:12:27.220]                           ns <- base::getNamespace("future")
[16:12:27.220]                           version <- ns[[".package"]][["version"]]
[16:12:27.220]                           if (is.null(version)) 
[16:12:27.220]                             version <- utils::packageVersion("future")
[16:12:27.220]                         }
[16:12:27.220]                         else {
[16:12:27.220]                           version <- NULL
[16:12:27.220]                         }
[16:12:27.220]                         if (!has_future || version < "1.8.0") {
[16:12:27.220]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.220]                             "", base::R.version$version.string), 
[16:12:27.220]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.220]                               "release", "version")], collapse = " "), 
[16:12:27.220]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.220]                             info)
[16:12:27.220]                           info <- base::paste(info, collapse = "; ")
[16:12:27.220]                           if (!has_future) {
[16:12:27.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.220]                               info)
[16:12:27.220]                           }
[16:12:27.220]                           else {
[16:12:27.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.220]                               info, version)
[16:12:27.220]                           }
[16:12:27.220]                           base::stop(msg)
[16:12:27.220]                         }
[16:12:27.220]                       })
[16:12:27.220]                     }
[16:12:27.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.220]                     base::options(mc.cores = 1L)
[16:12:27.220]                   }
[16:12:27.220]                   options(future.plan = NULL)
[16:12:27.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.220]                 }
[16:12:27.220]                 ...future.workdir <- getwd()
[16:12:27.220]             }
[16:12:27.220]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.220]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.220]         }
[16:12:27.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.220]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.220]             base::names(...future.oldOptions))
[16:12:27.220]     }
[16:12:27.220]     if (FALSE) {
[16:12:27.220]     }
[16:12:27.220]     else {
[16:12:27.220]         if (TRUE) {
[16:12:27.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.220]                 open = "w")
[16:12:27.220]         }
[16:12:27.220]         else {
[16:12:27.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.220]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.220]         }
[16:12:27.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.220]             base::sink(type = "output", split = FALSE)
[16:12:27.220]             base::close(...future.stdout)
[16:12:27.220]         }, add = TRUE)
[16:12:27.220]     }
[16:12:27.220]     ...future.frame <- base::sys.nframe()
[16:12:27.220]     ...future.conditions <- base::list()
[16:12:27.220]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.220]     if (FALSE) {
[16:12:27.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.220]     }
[16:12:27.220]     ...future.result <- base::tryCatch({
[16:12:27.220]         base::withCallingHandlers({
[16:12:27.220]             ...future.value <- base::withVisible(base::local({
[16:12:27.220]                 withCallingHandlers({
[16:12:27.220]                   2
[16:12:27.220]                 }, immediateCondition = function(cond) {
[16:12:27.220]                   save_rds <- function (object, pathname, ...) 
[16:12:27.220]                   {
[16:12:27.220]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.220]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.220]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.220]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.220]                         fi_tmp[["mtime"]])
[16:12:27.220]                     }
[16:12:27.220]                     tryCatch({
[16:12:27.220]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.220]                     }, error = function(ex) {
[16:12:27.220]                       msg <- conditionMessage(ex)
[16:12:27.220]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.220]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.220]                         fi_tmp[["mtime"]], msg)
[16:12:27.220]                       ex$message <- msg
[16:12:27.220]                       stop(ex)
[16:12:27.220]                     })
[16:12:27.220]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.220]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.220]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.220]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.220]                       fi <- file.info(pathname)
[16:12:27.220]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.220]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.220]                         fi[["size"]], fi[["mtime"]])
[16:12:27.220]                       stop(msg)
[16:12:27.220]                     }
[16:12:27.220]                     invisible(pathname)
[16:12:27.220]                   }
[16:12:27.220]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.220]                     rootPath = tempdir()) 
[16:12:27.220]                   {
[16:12:27.220]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.220]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.220]                       tmpdir = path, fileext = ".rds")
[16:12:27.220]                     save_rds(obj, file)
[16:12:27.220]                   }
[16:12:27.220]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.220]                   {
[16:12:27.220]                     inherits <- base::inherits
[16:12:27.220]                     invokeRestart <- base::invokeRestart
[16:12:27.220]                     is.null <- base::is.null
[16:12:27.220]                     muffled <- FALSE
[16:12:27.220]                     if (inherits(cond, "message")) {
[16:12:27.220]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.220]                       if (muffled) 
[16:12:27.220]                         invokeRestart("muffleMessage")
[16:12:27.220]                     }
[16:12:27.220]                     else if (inherits(cond, "warning")) {
[16:12:27.220]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.220]                       if (muffled) 
[16:12:27.220]                         invokeRestart("muffleWarning")
[16:12:27.220]                     }
[16:12:27.220]                     else if (inherits(cond, "condition")) {
[16:12:27.220]                       if (!is.null(pattern)) {
[16:12:27.220]                         computeRestarts <- base::computeRestarts
[16:12:27.220]                         grepl <- base::grepl
[16:12:27.220]                         restarts <- computeRestarts(cond)
[16:12:27.220]                         for (restart in restarts) {
[16:12:27.220]                           name <- restart$name
[16:12:27.220]                           if (is.null(name)) 
[16:12:27.220]                             next
[16:12:27.220]                           if (!grepl(pattern, name)) 
[16:12:27.220]                             next
[16:12:27.220]                           invokeRestart(restart)
[16:12:27.220]                           muffled <- TRUE
[16:12:27.220]                           break
[16:12:27.220]                         }
[16:12:27.220]                       }
[16:12:27.220]                     }
[16:12:27.220]                     invisible(muffled)
[16:12:27.220]                   }
[16:12:27.220]                   muffleCondition(cond)
[16:12:27.220]                 })
[16:12:27.220]             }))
[16:12:27.220]             future::FutureResult(value = ...future.value$value, 
[16:12:27.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.220]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.220]                     ...future.globalenv.names))
[16:12:27.220]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.220]         }, condition = base::local({
[16:12:27.220]             c <- base::c
[16:12:27.220]             inherits <- base::inherits
[16:12:27.220]             invokeRestart <- base::invokeRestart
[16:12:27.220]             length <- base::length
[16:12:27.220]             list <- base::list
[16:12:27.220]             seq.int <- base::seq.int
[16:12:27.220]             signalCondition <- base::signalCondition
[16:12:27.220]             sys.calls <- base::sys.calls
[16:12:27.220]             `[[` <- base::`[[`
[16:12:27.220]             `+` <- base::`+`
[16:12:27.220]             `<<-` <- base::`<<-`
[16:12:27.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.220]                   3L)]
[16:12:27.220]             }
[16:12:27.220]             function(cond) {
[16:12:27.220]                 is_error <- inherits(cond, "error")
[16:12:27.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.220]                   NULL)
[16:12:27.220]                 if (is_error) {
[16:12:27.220]                   sessionInformation <- function() {
[16:12:27.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.220]                       search = base::search(), system = base::Sys.info())
[16:12:27.220]                   }
[16:12:27.220]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.220]                     cond$call), session = sessionInformation(), 
[16:12:27.220]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.220]                   signalCondition(cond)
[16:12:27.220]                 }
[16:12:27.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.220]                 "immediateCondition"))) {
[16:12:27.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.220]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.220]                   if (TRUE && !signal) {
[16:12:27.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.220]                     {
[16:12:27.220]                       inherits <- base::inherits
[16:12:27.220]                       invokeRestart <- base::invokeRestart
[16:12:27.220]                       is.null <- base::is.null
[16:12:27.220]                       muffled <- FALSE
[16:12:27.220]                       if (inherits(cond, "message")) {
[16:12:27.220]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.220]                         if (muffled) 
[16:12:27.220]                           invokeRestart("muffleMessage")
[16:12:27.220]                       }
[16:12:27.220]                       else if (inherits(cond, "warning")) {
[16:12:27.220]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.220]                         if (muffled) 
[16:12:27.220]                           invokeRestart("muffleWarning")
[16:12:27.220]                       }
[16:12:27.220]                       else if (inherits(cond, "condition")) {
[16:12:27.220]                         if (!is.null(pattern)) {
[16:12:27.220]                           computeRestarts <- base::computeRestarts
[16:12:27.220]                           grepl <- base::grepl
[16:12:27.220]                           restarts <- computeRestarts(cond)
[16:12:27.220]                           for (restart in restarts) {
[16:12:27.220]                             name <- restart$name
[16:12:27.220]                             if (is.null(name)) 
[16:12:27.220]                               next
[16:12:27.220]                             if (!grepl(pattern, name)) 
[16:12:27.220]                               next
[16:12:27.220]                             invokeRestart(restart)
[16:12:27.220]                             muffled <- TRUE
[16:12:27.220]                             break
[16:12:27.220]                           }
[16:12:27.220]                         }
[16:12:27.220]                       }
[16:12:27.220]                       invisible(muffled)
[16:12:27.220]                     }
[16:12:27.220]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.220]                   }
[16:12:27.220]                 }
[16:12:27.220]                 else {
[16:12:27.220]                   if (TRUE) {
[16:12:27.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.220]                     {
[16:12:27.220]                       inherits <- base::inherits
[16:12:27.220]                       invokeRestart <- base::invokeRestart
[16:12:27.220]                       is.null <- base::is.null
[16:12:27.220]                       muffled <- FALSE
[16:12:27.220]                       if (inherits(cond, "message")) {
[16:12:27.220]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.220]                         if (muffled) 
[16:12:27.220]                           invokeRestart("muffleMessage")
[16:12:27.220]                       }
[16:12:27.220]                       else if (inherits(cond, "warning")) {
[16:12:27.220]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.220]                         if (muffled) 
[16:12:27.220]                           invokeRestart("muffleWarning")
[16:12:27.220]                       }
[16:12:27.220]                       else if (inherits(cond, "condition")) {
[16:12:27.220]                         if (!is.null(pattern)) {
[16:12:27.220]                           computeRestarts <- base::computeRestarts
[16:12:27.220]                           grepl <- base::grepl
[16:12:27.220]                           restarts <- computeRestarts(cond)
[16:12:27.220]                           for (restart in restarts) {
[16:12:27.220]                             name <- restart$name
[16:12:27.220]                             if (is.null(name)) 
[16:12:27.220]                               next
[16:12:27.220]                             if (!grepl(pattern, name)) 
[16:12:27.220]                               next
[16:12:27.220]                             invokeRestart(restart)
[16:12:27.220]                             muffled <- TRUE
[16:12:27.220]                             break
[16:12:27.220]                           }
[16:12:27.220]                         }
[16:12:27.220]                       }
[16:12:27.220]                       invisible(muffled)
[16:12:27.220]                     }
[16:12:27.220]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.220]                   }
[16:12:27.220]                 }
[16:12:27.220]             }
[16:12:27.220]         }))
[16:12:27.220]     }, error = function(ex) {
[16:12:27.220]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.220]                 ...future.rng), started = ...future.startTime, 
[16:12:27.220]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.220]             version = "1.8"), class = "FutureResult")
[16:12:27.220]     }, finally = {
[16:12:27.220]         if (!identical(...future.workdir, getwd())) 
[16:12:27.220]             setwd(...future.workdir)
[16:12:27.220]         {
[16:12:27.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.220]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.220]             }
[16:12:27.220]             base::options(...future.oldOptions)
[16:12:27.220]             if (.Platform$OS.type == "windows") {
[16:12:27.220]                 old_names <- names(...future.oldEnvVars)
[16:12:27.220]                 envs <- base::Sys.getenv()
[16:12:27.220]                 names <- names(envs)
[16:12:27.220]                 common <- intersect(names, old_names)
[16:12:27.220]                 added <- setdiff(names, old_names)
[16:12:27.220]                 removed <- setdiff(old_names, names)
[16:12:27.220]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.220]                   envs[common]]
[16:12:27.220]                 NAMES <- toupper(changed)
[16:12:27.220]                 args <- list()
[16:12:27.220]                 for (kk in seq_along(NAMES)) {
[16:12:27.220]                   name <- changed[[kk]]
[16:12:27.220]                   NAME <- NAMES[[kk]]
[16:12:27.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.220]                     next
[16:12:27.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.220]                 }
[16:12:27.220]                 NAMES <- toupper(added)
[16:12:27.220]                 for (kk in seq_along(NAMES)) {
[16:12:27.220]                   name <- added[[kk]]
[16:12:27.220]                   NAME <- NAMES[[kk]]
[16:12:27.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.220]                     next
[16:12:27.220]                   args[[name]] <- ""
[16:12:27.220]                 }
[16:12:27.220]                 NAMES <- toupper(removed)
[16:12:27.220]                 for (kk in seq_along(NAMES)) {
[16:12:27.220]                   name <- removed[[kk]]
[16:12:27.220]                   NAME <- NAMES[[kk]]
[16:12:27.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.220]                     next
[16:12:27.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.220]                 }
[16:12:27.220]                 if (length(args) > 0) 
[16:12:27.220]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.220]             }
[16:12:27.220]             else {
[16:12:27.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.220]             }
[16:12:27.220]             {
[16:12:27.220]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.220]                   0L) {
[16:12:27.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.220]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.220]                   base::options(opts)
[16:12:27.220]                 }
[16:12:27.220]                 {
[16:12:27.220]                   {
[16:12:27.220]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.220]                     NULL
[16:12:27.220]                   }
[16:12:27.220]                   options(future.plan = NULL)
[16:12:27.220]                   if (is.na(NA_character_)) 
[16:12:27.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.220]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.220]                     envir = parent.frame()) 
[16:12:27.220]                   {
[16:12:27.220]                     default_workers <- missing(workers)
[16:12:27.220]                     if (is.function(workers)) 
[16:12:27.220]                       workers <- workers()
[16:12:27.220]                     workers <- structure(as.integer(workers), 
[16:12:27.220]                       class = class(workers))
[16:12:27.220]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.220]                       1L)
[16:12:27.220]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.220]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.220]                       if (default_workers) 
[16:12:27.220]                         supportsMulticore(warn = TRUE)
[16:12:27.220]                       return(sequential(..., envir = envir))
[16:12:27.220]                     }
[16:12:27.220]                     oopts <- options(mc.cores = workers)
[16:12:27.220]                     on.exit(options(oopts))
[16:12:27.220]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.220]                       envir = envir)
[16:12:27.220]                     if (!future$lazy) 
[16:12:27.220]                       future <- run(future)
[16:12:27.220]                     invisible(future)
[16:12:27.220]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.220]                 }
[16:12:27.220]             }
[16:12:27.220]         }
[16:12:27.220]     })
[16:12:27.220]     if (TRUE) {
[16:12:27.220]         base::sink(type = "output", split = FALSE)
[16:12:27.220]         if (TRUE) {
[16:12:27.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.220]         }
[16:12:27.220]         else {
[16:12:27.220]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.220]         }
[16:12:27.220]         base::close(...future.stdout)
[16:12:27.220]         ...future.stdout <- NULL
[16:12:27.220]     }
[16:12:27.220]     ...future.result$conditions <- ...future.conditions
[16:12:27.220]     ...future.result$finished <- base::Sys.time()
[16:12:27.220]     ...future.result
[16:12:27.220] }
[16:12:27.222] requestCore(): workers = 2
[16:12:27.224] MulticoreFuture started
[16:12:27.225] - Launch lazy future ... done
[16:12:27.225] run() for ‘MulticoreFuture’ ... done
[16:12:27.225] getGlobalsAndPackages() ...
[16:12:27.226] Searching for globals...
[16:12:27.225] plan(): Setting new future strategy stack:
[16:12:27.226] List of future strategies:
[16:12:27.226] 1. sequential:
[16:12:27.226]    - args: function (..., envir = parent.frame())
[16:12:27.226]    - tweaked: FALSE
[16:12:27.226]    - call: NULL
[16:12:27.226] 
[16:12:27.227] Searching for globals ... DONE
[16:12:27.227] plan(): nbrOfWorkers() = 1
[16:12:27.227] - globals: [0] <none>
[16:12:27.227] getGlobalsAndPackages() ... DONE
[16:12:27.227] run() for ‘Future’ ...
[16:12:27.228] - state: ‘created’
[16:12:27.228] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.229] plan(): Setting new future strategy stack:
[16:12:27.229] List of future strategies:
[16:12:27.229] 1. multicore:
[16:12:27.229]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.229]    - tweaked: FALSE
[16:12:27.229]    - call: plan(strategy)
[16:12:27.234] plan(): nbrOfWorkers() = 2
[16:12:27.234] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:27.234]   - Field: ‘label’
[16:12:27.234]   - Field: ‘local’
[16:12:27.235]   - Field: ‘owner’
[16:12:27.235]   - Field: ‘envir’
[16:12:27.235]   - Field: ‘workers’
[16:12:27.235]   - Field: ‘packages’
[16:12:27.235]   - Field: ‘gc’
[16:12:27.235]   - Field: ‘job’
[16:12:27.236]   - Field: ‘conditions’
[16:12:27.236]   - Field: ‘expr’
[16:12:27.236]   - Field: ‘uuid’
[16:12:27.236]   - Field: ‘seed’
[16:12:27.236]   - Field: ‘version’
[16:12:27.236]   - Field: ‘result’
[16:12:27.237]   - Field: ‘asynchronous’
[16:12:27.237]   - Field: ‘calls’
[16:12:27.237]   - Field: ‘globals’
[16:12:27.237]   - Field: ‘stdout’
[16:12:27.237]   - Field: ‘earlySignal’
[16:12:27.237]   - Field: ‘lazy’
[16:12:27.237]   - Field: ‘state’
[16:12:27.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:27.238] - Launch lazy future ...
[16:12:27.238] Packages needed by the future expression (n = 0): <none>
[16:12:27.239] Packages needed by future strategies (n = 0): <none>
[16:12:27.239] {
[16:12:27.239]     {
[16:12:27.239]         {
[16:12:27.239]             ...future.startTime <- base::Sys.time()
[16:12:27.239]             {
[16:12:27.239]                 {
[16:12:27.239]                   {
[16:12:27.239]                     {
[16:12:27.239]                       base::local({
[16:12:27.239]                         has_future <- base::requireNamespace("future", 
[16:12:27.239]                           quietly = TRUE)
[16:12:27.239]                         if (has_future) {
[16:12:27.239]                           ns <- base::getNamespace("future")
[16:12:27.239]                           version <- ns[[".package"]][["version"]]
[16:12:27.239]                           if (is.null(version)) 
[16:12:27.239]                             version <- utils::packageVersion("future")
[16:12:27.239]                         }
[16:12:27.239]                         else {
[16:12:27.239]                           version <- NULL
[16:12:27.239]                         }
[16:12:27.239]                         if (!has_future || version < "1.8.0") {
[16:12:27.239]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.239]                             "", base::R.version$version.string), 
[16:12:27.239]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.239]                               "release", "version")], collapse = " "), 
[16:12:27.239]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.239]                             info)
[16:12:27.239]                           info <- base::paste(info, collapse = "; ")
[16:12:27.239]                           if (!has_future) {
[16:12:27.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.239]                               info)
[16:12:27.239]                           }
[16:12:27.239]                           else {
[16:12:27.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.239]                               info, version)
[16:12:27.239]                           }
[16:12:27.239]                           base::stop(msg)
[16:12:27.239]                         }
[16:12:27.239]                       })
[16:12:27.239]                     }
[16:12:27.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.239]                     base::options(mc.cores = 1L)
[16:12:27.239]                   }
[16:12:27.239]                   options(future.plan = NULL)
[16:12:27.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.239]                 }
[16:12:27.239]                 ...future.workdir <- getwd()
[16:12:27.239]             }
[16:12:27.239]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.239]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.239]         }
[16:12:27.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.239]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.239]             base::names(...future.oldOptions))
[16:12:27.239]     }
[16:12:27.239]     if (FALSE) {
[16:12:27.239]     }
[16:12:27.239]     else {
[16:12:27.239]         if (TRUE) {
[16:12:27.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.239]                 open = "w")
[16:12:27.239]         }
[16:12:27.239]         else {
[16:12:27.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.239]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.239]         }
[16:12:27.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.239]             base::sink(type = "output", split = FALSE)
[16:12:27.239]             base::close(...future.stdout)
[16:12:27.239]         }, add = TRUE)
[16:12:27.239]     }
[16:12:27.239]     ...future.frame <- base::sys.nframe()
[16:12:27.239]     ...future.conditions <- base::list()
[16:12:27.239]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.239]     if (FALSE) {
[16:12:27.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.239]     }
[16:12:27.239]     ...future.result <- base::tryCatch({
[16:12:27.239]         base::withCallingHandlers({
[16:12:27.239]             ...future.value <- base::withVisible(base::local({
[16:12:27.239]                 withCallingHandlers({
[16:12:27.239]                   NULL
[16:12:27.239]                 }, immediateCondition = function(cond) {
[16:12:27.239]                   save_rds <- function (object, pathname, ...) 
[16:12:27.239]                   {
[16:12:27.239]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:27.239]                     if (file_test("-f", pathname_tmp)) {
[16:12:27.239]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.239]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:27.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.239]                         fi_tmp[["mtime"]])
[16:12:27.239]                     }
[16:12:27.239]                     tryCatch({
[16:12:27.239]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:27.239]                     }, error = function(ex) {
[16:12:27.239]                       msg <- conditionMessage(ex)
[16:12:27.239]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.239]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:27.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.239]                         fi_tmp[["mtime"]], msg)
[16:12:27.239]                       ex$message <- msg
[16:12:27.239]                       stop(ex)
[16:12:27.239]                     })
[16:12:27.239]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:27.239]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:27.239]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:27.239]                       fi_tmp <- file.info(pathname_tmp)
[16:12:27.239]                       fi <- file.info(pathname)
[16:12:27.239]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:27.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:27.239]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:27.239]                         fi[["size"]], fi[["mtime"]])
[16:12:27.239]                       stop(msg)
[16:12:27.239]                     }
[16:12:27.239]                     invisible(pathname)
[16:12:27.239]                   }
[16:12:27.239]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:27.239]                     rootPath = tempdir()) 
[16:12:27.239]                   {
[16:12:27.239]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:27.239]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:27.239]                       tmpdir = path, fileext = ".rds")
[16:12:27.239]                     save_rds(obj, file)
[16:12:27.239]                   }
[16:12:27.239]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:27.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.239]                   {
[16:12:27.239]                     inherits <- base::inherits
[16:12:27.239]                     invokeRestart <- base::invokeRestart
[16:12:27.239]                     is.null <- base::is.null
[16:12:27.239]                     muffled <- FALSE
[16:12:27.239]                     if (inherits(cond, "message")) {
[16:12:27.239]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.239]                       if (muffled) 
[16:12:27.239]                         invokeRestart("muffleMessage")
[16:12:27.239]                     }
[16:12:27.239]                     else if (inherits(cond, "warning")) {
[16:12:27.239]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.239]                       if (muffled) 
[16:12:27.239]                         invokeRestart("muffleWarning")
[16:12:27.239]                     }
[16:12:27.239]                     else if (inherits(cond, "condition")) {
[16:12:27.239]                       if (!is.null(pattern)) {
[16:12:27.239]                         computeRestarts <- base::computeRestarts
[16:12:27.239]                         grepl <- base::grepl
[16:12:27.239]                         restarts <- computeRestarts(cond)
[16:12:27.239]                         for (restart in restarts) {
[16:12:27.239]                           name <- restart$name
[16:12:27.239]                           if (is.null(name)) 
[16:12:27.239]                             next
[16:12:27.239]                           if (!grepl(pattern, name)) 
[16:12:27.239]                             next
[16:12:27.239]                           invokeRestart(restart)
[16:12:27.239]                           muffled <- TRUE
[16:12:27.239]                           break
[16:12:27.239]                         }
[16:12:27.239]                       }
[16:12:27.239]                     }
[16:12:27.239]                     invisible(muffled)
[16:12:27.239]                   }
[16:12:27.239]                   muffleCondition(cond)
[16:12:27.239]                 })
[16:12:27.239]             }))
[16:12:27.239]             future::FutureResult(value = ...future.value$value, 
[16:12:27.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.239]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.239]                     ...future.globalenv.names))
[16:12:27.239]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.239]         }, condition = base::local({
[16:12:27.239]             c <- base::c
[16:12:27.239]             inherits <- base::inherits
[16:12:27.239]             invokeRestart <- base::invokeRestart
[16:12:27.239]             length <- base::length
[16:12:27.239]             list <- base::list
[16:12:27.239]             seq.int <- base::seq.int
[16:12:27.239]             signalCondition <- base::signalCondition
[16:12:27.239]             sys.calls <- base::sys.calls
[16:12:27.239]             `[[` <- base::`[[`
[16:12:27.239]             `+` <- base::`+`
[16:12:27.239]             `<<-` <- base::`<<-`
[16:12:27.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.239]                   3L)]
[16:12:27.239]             }
[16:12:27.239]             function(cond) {
[16:12:27.239]                 is_error <- inherits(cond, "error")
[16:12:27.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.239]                   NULL)
[16:12:27.239]                 if (is_error) {
[16:12:27.239]                   sessionInformation <- function() {
[16:12:27.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.239]                       search = base::search(), system = base::Sys.info())
[16:12:27.239]                   }
[16:12:27.239]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.239]                     cond$call), session = sessionInformation(), 
[16:12:27.239]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.239]                   signalCondition(cond)
[16:12:27.239]                 }
[16:12:27.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.239]                 "immediateCondition"))) {
[16:12:27.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.239]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.239]                   if (TRUE && !signal) {
[16:12:27.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.239]                     {
[16:12:27.239]                       inherits <- base::inherits
[16:12:27.239]                       invokeRestart <- base::invokeRestart
[16:12:27.239]                       is.null <- base::is.null
[16:12:27.239]                       muffled <- FALSE
[16:12:27.239]                       if (inherits(cond, "message")) {
[16:12:27.239]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.239]                         if (muffled) 
[16:12:27.239]                           invokeRestart("muffleMessage")
[16:12:27.239]                       }
[16:12:27.239]                       else if (inherits(cond, "warning")) {
[16:12:27.239]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.239]                         if (muffled) 
[16:12:27.239]                           invokeRestart("muffleWarning")
[16:12:27.239]                       }
[16:12:27.239]                       else if (inherits(cond, "condition")) {
[16:12:27.239]                         if (!is.null(pattern)) {
[16:12:27.239]                           computeRestarts <- base::computeRestarts
[16:12:27.239]                           grepl <- base::grepl
[16:12:27.239]                           restarts <- computeRestarts(cond)
[16:12:27.239]                           for (restart in restarts) {
[16:12:27.239]                             name <- restart$name
[16:12:27.239]                             if (is.null(name)) 
[16:12:27.239]                               next
[16:12:27.239]                             if (!grepl(pattern, name)) 
[16:12:27.239]                               next
[16:12:27.239]                             invokeRestart(restart)
[16:12:27.239]                             muffled <- TRUE
[16:12:27.239]                             break
[16:12:27.239]                           }
[16:12:27.239]                         }
[16:12:27.239]                       }
[16:12:27.239]                       invisible(muffled)
[16:12:27.239]                     }
[16:12:27.239]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.239]                   }
[16:12:27.239]                 }
[16:12:27.239]                 else {
[16:12:27.239]                   if (TRUE) {
[16:12:27.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.239]                     {
[16:12:27.239]                       inherits <- base::inherits
[16:12:27.239]                       invokeRestart <- base::invokeRestart
[16:12:27.239]                       is.null <- base::is.null
[16:12:27.239]                       muffled <- FALSE
[16:12:27.239]                       if (inherits(cond, "message")) {
[16:12:27.239]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.239]                         if (muffled) 
[16:12:27.239]                           invokeRestart("muffleMessage")
[16:12:27.239]                       }
[16:12:27.239]                       else if (inherits(cond, "warning")) {
[16:12:27.239]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.239]                         if (muffled) 
[16:12:27.239]                           invokeRestart("muffleWarning")
[16:12:27.239]                       }
[16:12:27.239]                       else if (inherits(cond, "condition")) {
[16:12:27.239]                         if (!is.null(pattern)) {
[16:12:27.239]                           computeRestarts <- base::computeRestarts
[16:12:27.239]                           grepl <- base::grepl
[16:12:27.239]                           restarts <- computeRestarts(cond)
[16:12:27.239]                           for (restart in restarts) {
[16:12:27.239]                             name <- restart$name
[16:12:27.239]                             if (is.null(name)) 
[16:12:27.239]                               next
[16:12:27.239]                             if (!grepl(pattern, name)) 
[16:12:27.239]                               next
[16:12:27.239]                             invokeRestart(restart)
[16:12:27.239]                             muffled <- TRUE
[16:12:27.239]                             break
[16:12:27.239]                           }
[16:12:27.239]                         }
[16:12:27.239]                       }
[16:12:27.239]                       invisible(muffled)
[16:12:27.239]                     }
[16:12:27.239]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.239]                   }
[16:12:27.239]                 }
[16:12:27.239]             }
[16:12:27.239]         }))
[16:12:27.239]     }, error = function(ex) {
[16:12:27.239]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.239]                 ...future.rng), started = ...future.startTime, 
[16:12:27.239]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.239]             version = "1.8"), class = "FutureResult")
[16:12:27.239]     }, finally = {
[16:12:27.239]         if (!identical(...future.workdir, getwd())) 
[16:12:27.239]             setwd(...future.workdir)
[16:12:27.239]         {
[16:12:27.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.239]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.239]             }
[16:12:27.239]             base::options(...future.oldOptions)
[16:12:27.239]             if (.Platform$OS.type == "windows") {
[16:12:27.239]                 old_names <- names(...future.oldEnvVars)
[16:12:27.239]                 envs <- base::Sys.getenv()
[16:12:27.239]                 names <- names(envs)
[16:12:27.239]                 common <- intersect(names, old_names)
[16:12:27.239]                 added <- setdiff(names, old_names)
[16:12:27.239]                 removed <- setdiff(old_names, names)
[16:12:27.239]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.239]                   envs[common]]
[16:12:27.239]                 NAMES <- toupper(changed)
[16:12:27.239]                 args <- list()
[16:12:27.239]                 for (kk in seq_along(NAMES)) {
[16:12:27.239]                   name <- changed[[kk]]
[16:12:27.239]                   NAME <- NAMES[[kk]]
[16:12:27.239]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.239]                     next
[16:12:27.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.239]                 }
[16:12:27.239]                 NAMES <- toupper(added)
[16:12:27.239]                 for (kk in seq_along(NAMES)) {
[16:12:27.239]                   name <- added[[kk]]
[16:12:27.239]                   NAME <- NAMES[[kk]]
[16:12:27.239]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.239]                     next
[16:12:27.239]                   args[[name]] <- ""
[16:12:27.239]                 }
[16:12:27.239]                 NAMES <- toupper(removed)
[16:12:27.239]                 for (kk in seq_along(NAMES)) {
[16:12:27.239]                   name <- removed[[kk]]
[16:12:27.239]                   NAME <- NAMES[[kk]]
[16:12:27.239]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.239]                     next
[16:12:27.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.239]                 }
[16:12:27.239]                 if (length(args) > 0) 
[16:12:27.239]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.239]             }
[16:12:27.239]             else {
[16:12:27.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.239]             }
[16:12:27.239]             {
[16:12:27.239]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.239]                   0L) {
[16:12:27.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.239]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.239]                   base::options(opts)
[16:12:27.239]                 }
[16:12:27.239]                 {
[16:12:27.239]                   {
[16:12:27.239]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.239]                     NULL
[16:12:27.239]                   }
[16:12:27.239]                   options(future.plan = NULL)
[16:12:27.239]                   if (is.na(NA_character_)) 
[16:12:27.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.239]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:27.239]                     envir = parent.frame()) 
[16:12:27.239]                   {
[16:12:27.239]                     default_workers <- missing(workers)
[16:12:27.239]                     if (is.function(workers)) 
[16:12:27.239]                       workers <- workers()
[16:12:27.239]                     workers <- structure(as.integer(workers), 
[16:12:27.239]                       class = class(workers))
[16:12:27.239]                     stop_if_not(is.finite(workers), workers >= 
[16:12:27.239]                       1L)
[16:12:27.239]                     if ((workers == 1L && !inherits(workers, 
[16:12:27.239]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:27.239]                       if (default_workers) 
[16:12:27.239]                         supportsMulticore(warn = TRUE)
[16:12:27.239]                       return(sequential(..., envir = envir))
[16:12:27.239]                     }
[16:12:27.239]                     oopts <- options(mc.cores = workers)
[16:12:27.239]                     on.exit(options(oopts))
[16:12:27.239]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:27.239]                       envir = envir)
[16:12:27.239]                     if (!future$lazy) 
[16:12:27.239]                       future <- run(future)
[16:12:27.239]                     invisible(future)
[16:12:27.239]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.239]                 }
[16:12:27.239]             }
[16:12:27.239]         }
[16:12:27.239]     })
[16:12:27.239]     if (TRUE) {
[16:12:27.239]         base::sink(type = "output", split = FALSE)
[16:12:27.239]         if (TRUE) {
[16:12:27.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.239]         }
[16:12:27.239]         else {
[16:12:27.239]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.239]         }
[16:12:27.239]         base::close(...future.stdout)
[16:12:27.239]         ...future.stdout <- NULL
[16:12:27.239]     }
[16:12:27.239]     ...future.result$conditions <- ...future.conditions
[16:12:27.239]     ...future.result$finished <- base::Sys.time()
[16:12:27.239]     ...future.result
[16:12:27.239] }
[16:12:27.243] requestCore(): workers = 2
[16:12:27.245] MulticoreFuture started
[16:12:27.246] - Launch lazy future ... done
[16:12:27.246] run() for ‘MulticoreFuture’ ... done
List of 6[16:12:27.246] plan(): Setting new future strategy stack:

 $ a:[16:12:27.247] List of future strategies:
[16:12:27.247] 1. sequential:
[16:12:27.247]    - args: function (..., envir = parent.frame())
[16:12:27.247]    - tweaked: FALSE
[16:12:27.247]    - call: NULL
 num 1
 $ b:[16:12:27.248] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bad9d30f8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae4b4b98> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:12:27.250] plan(): Setting new future strategy stack:
List of 6
 $ a:[16:12:27.250] List of future strategies:
[16:12:27.250] 1. multicore:
[16:12:27.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:27.250]    - tweaked: FALSE
[16:12:27.250]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bad9d30f8> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae4b4b98> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ :[16:12:27.255] plan(): nbrOfWorkers() = 2
 chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:27.259] resolve() on list ...
[16:12:27.259]  recursive: 0
[16:12:27.263]  length: 6
[16:12:27.264]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:27.264] signalConditionsASAP(numeric, pos=1) ...
[16:12:27.264] - nx: 6
[16:12:27.264] - relay: TRUE
[16:12:27.265] - stdout: TRUE
[16:12:27.265] - signal: TRUE
[16:12:27.265] - resignal: FALSE
[16:12:27.265] - force: TRUE
[16:12:27.266] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.266] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.266]  - until=2
[16:12:27.266]  - relaying element #2
[16:12:27.267] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.267] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.267] signalConditionsASAP(NULL, pos=1) ... done
[16:12:27.267]  length: 5 (resolved future 1)
[16:12:27.268] Future #2
[16:12:27.269] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:27.269] - nx: 6
[16:12:27.269] - relay: TRUE
[16:12:27.269] - stdout: TRUE
[16:12:27.270] - signal: TRUE
[16:12:27.270] - resignal: FALSE
[16:12:27.270] - force: TRUE
[16:12:27.270] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.270] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:27.270]  - until=2
[16:12:27.270]  - relaying element #2
[16:12:27.271] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.271] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.271] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:27.271]  length: 4 (resolved future 2)
[16:12:27.272] Future #3
[16:12:27.273] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:27.273] - nx: 6
[16:12:27.273] - relay: TRUE
[16:12:27.273] - stdout: TRUE
[16:12:27.273] - signal: TRUE
[16:12:27.274] - resignal: FALSE
[16:12:27.274] - force: TRUE
[16:12:27.274] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.274] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:27.274]  - until=3
[16:12:27.274]  - relaying element #3
[16:12:27.274] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.275] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.275] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:27.275]  length: 3 (resolved future 3)
[16:12:27.275] signalConditionsASAP(NULL, pos=4) ...
[16:12:27.275] - nx: 6
[16:12:27.275] - relay: TRUE
[16:12:27.275] - stdout: TRUE
[16:12:27.275] - signal: TRUE
[16:12:27.275] - resignal: FALSE
[16:12:27.276] - force: TRUE
[16:12:27.276] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.276]  - until=5
[16:12:27.276]  - relaying element #5
[16:12:27.276] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.276] signalConditionsASAP(NULL, pos=4) ... done
[16:12:27.276]  length: 2 (resolved future 4)
[16:12:27.277] signalConditionsASAP(NULL, pos=5) ...
[16:12:27.277] - nx: 6
[16:12:27.277] - relay: TRUE
[16:12:27.277] - stdout: TRUE
[16:12:27.277] - signal: TRUE
[16:12:27.277] - resignal: FALSE
[16:12:27.277] - force: TRUE
[16:12:27.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:27.277] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.277]  - until=6
[16:12:27.278]  - relaying element #6
[16:12:27.278] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.278] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.278] signalConditionsASAP(NULL, pos=5) ... done
[16:12:27.278]  length: 1 (resolved future 5)
[16:12:27.278] signalConditionsASAP(numeric, pos=6) ...
[16:12:27.278] - nx: 6
[16:12:27.278] - relay: TRUE
[16:12:27.278] - stdout: TRUE
[16:12:27.279] - signal: TRUE
[16:12:27.279] - resignal: FALSE
[16:12:27.279] - force: TRUE
[16:12:27.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:27.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.279]  - until=6
[16:12:27.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.279] signalConditionsASAP(numeric, pos=6) ... done
[16:12:27.279]  length: 0 (resolved future 6)
[16:12:27.280] Relaying remaining futures
[16:12:27.280] signalConditionsASAP(NULL, pos=0) ...
[16:12:27.280] - nx: 6
[16:12:27.280] - relay: TRUE
[16:12:27.280] - stdout: TRUE
[16:12:27.280] - signal: TRUE
[16:12:27.280] - resignal: FALSE
[16:12:27.280] - force: TRUE
[16:12:27.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.280] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:27.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:27.281] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:27.281] signalConditionsASAP(NULL, pos=0) ... done
[16:12:27.281] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[16:12:27.285] plan(): Setting new future strategy stack:
[16:12:27.285] List of future strategies:
[16:12:27.285] 1. multisession:
[16:12:27.285]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:27.285]    - tweaked: FALSE
[16:12:27.285]    - call: plan(strategy)
[16:12:27.286] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:27.286] multisession:
[16:12:27.286] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:27.286] - tweaked: FALSE
[16:12:27.286] - call: plan(strategy)
[16:12:27.293] getGlobalsAndPackages() ...
[16:12:27.293] Not searching for globals
[16:12:27.293] - globals: [0] <none>
[16:12:27.293] getGlobalsAndPackages() ... DONE
[16:12:27.294] [local output] makeClusterPSOCK() ...
[16:12:27.337] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:27.343] [local output] Base port: 11516
[16:12:27.343] [local output] Getting setup options for 2 cluster nodes ...
[16:12:27.343] [local output]  - Node 1 of 2 ...
[16:12:27.344] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:27.345] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454a2cdaf13a.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454a2cdaf13a.pid")'’
[16:12:27.566] - Possible to infer worker's PID: TRUE
[16:12:27.567] [local output] Rscript port: 11516

[16:12:27.567] [local output]  - Node 2 of 2 ...
[16:12:27.568] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:27.568] [local output] Rscript port: 11516

[16:12:27.568] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:27.569] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:27.569] [local output] Setting up PSOCK nodes in parallel
[16:12:27.569] List of 36
[16:12:27.569]  $ worker          : chr "localhost"
[16:12:27.569]   ..- attr(*, "localhost")= logi TRUE
[16:12:27.569]  $ master          : chr "localhost"
[16:12:27.569]  $ port            : int 11516
[16:12:27.569]  $ connectTimeout  : num 120
[16:12:27.569]  $ timeout         : num 2592000
[16:12:27.569]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:27.569]  $ homogeneous     : logi TRUE
[16:12:27.569]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:27.569]  $ rscript_envs    : NULL
[16:12:27.569]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:27.569]  $ rscript_startup : NULL
[16:12:27.569]  $ rscript_sh      : chr "sh"
[16:12:27.569]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:27.569]  $ methods         : logi TRUE
[16:12:27.569]  $ socketOptions   : chr "no-delay"
[16:12:27.569]  $ useXDR          : logi FALSE
[16:12:27.569]  $ outfile         : chr "/dev/null"
[16:12:27.569]  $ renice          : int NA
[16:12:27.569]  $ rshcmd          : NULL
[16:12:27.569]  $ user            : chr(0) 
[16:12:27.569]  $ revtunnel       : logi FALSE
[16:12:27.569]  $ rshlogfile      : NULL
[16:12:27.569]  $ rshopts         : chr(0) 
[16:12:27.569]  $ rank            : int 1
[16:12:27.569]  $ manual          : logi FALSE
[16:12:27.569]  $ dryrun          : logi FALSE
[16:12:27.569]  $ quiet           : logi FALSE
[16:12:27.569]  $ setup_strategy  : chr "parallel"
[16:12:27.569]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:27.569]  $ pidfile         : chr "/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454a2cdaf13a.pid"
[16:12:27.569]  $ rshcmd_label    : NULL
[16:12:27.569]  $ rsh_call        : NULL
[16:12:27.569]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:27.569]  $ localMachine    : logi TRUE
[16:12:27.569]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:27.569]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:27.569]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:27.569]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:27.569]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:27.569]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:27.569]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:27.569]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:27.569]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:27.569]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:27.569]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:27.569]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:27.569]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:27.569]  $ arguments       :List of 28
[16:12:27.569]   ..$ worker          : chr "localhost"
[16:12:27.569]   ..$ master          : NULL
[16:12:27.569]   ..$ port            : int 11516
[16:12:27.569]   ..$ connectTimeout  : num 120
[16:12:27.569]   ..$ timeout         : num 2592000
[16:12:27.569]   ..$ rscript         : NULL
[16:12:27.569]   ..$ homogeneous     : NULL
[16:12:27.569]   ..$ rscript_args    : NULL
[16:12:27.569]   ..$ rscript_envs    : NULL
[16:12:27.569]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:27.569]   ..$ rscript_startup : NULL
[16:12:27.569]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:27.569]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:27.569]   ..$ methods         : logi TRUE
[16:12:27.569]   ..$ socketOptions   : chr "no-delay"
[16:12:27.569]   ..$ useXDR          : logi FALSE
[16:12:27.569]   ..$ outfile         : chr "/dev/null"
[16:12:27.569]   ..$ renice          : int NA
[16:12:27.569]   ..$ rshcmd          : NULL
[16:12:27.569]   ..$ user            : NULL
[16:12:27.569]   ..$ revtunnel       : logi NA
[16:12:27.569]   ..$ rshlogfile      : NULL
[16:12:27.569]   ..$ rshopts         : NULL
[16:12:27.569]   ..$ rank            : int 1
[16:12:27.569]   ..$ manual          : logi FALSE
[16:12:27.569]   ..$ dryrun          : logi FALSE
[16:12:27.569]   ..$ quiet           : logi FALSE
[16:12:27.569]   ..$ setup_strategy  : chr "parallel"
[16:12:27.569]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:27.587] [local output] System call to launch all workers:
[16:12:27.587] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454a2cdaf13a.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11516 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:27.587] [local output] Starting PSOCK main server
[16:12:27.589] [local output] Workers launched
[16:12:27.589] [local output] Waiting for workers to connect back
[16:12:27.589]  - [local output] 0 workers out of 2 ready
[16:12:27.831]  - [local output] 0 workers out of 2 ready
[16:12:27.832]  - [local output] 1 workers out of 2 ready
[16:12:27.852]  - [local output] 1 workers out of 2 ready
[16:12:27.852]  - [local output] 2 workers out of 2 ready
[16:12:27.852] [local output] Launching of workers completed
[16:12:27.852] [local output] Collecting session information from workers
[16:12:27.853] [local output]  - Worker #1 of 2
[16:12:27.854] [local output]  - Worker #2 of 2
[16:12:27.854] [local output] makeClusterPSOCK() ... done
[16:12:27.866] Packages needed by the future expression (n = 0): <none>
[16:12:27.866] Packages needed by future strategies (n = 0): <none>
[16:12:27.866] {
[16:12:27.866]     {
[16:12:27.866]         {
[16:12:27.866]             ...future.startTime <- base::Sys.time()
[16:12:27.866]             {
[16:12:27.866]                 {
[16:12:27.866]                   {
[16:12:27.866]                     {
[16:12:27.866]                       base::local({
[16:12:27.866]                         has_future <- base::requireNamespace("future", 
[16:12:27.866]                           quietly = TRUE)
[16:12:27.866]                         if (has_future) {
[16:12:27.866]                           ns <- base::getNamespace("future")
[16:12:27.866]                           version <- ns[[".package"]][["version"]]
[16:12:27.866]                           if (is.null(version)) 
[16:12:27.866]                             version <- utils::packageVersion("future")
[16:12:27.866]                         }
[16:12:27.866]                         else {
[16:12:27.866]                           version <- NULL
[16:12:27.866]                         }
[16:12:27.866]                         if (!has_future || version < "1.8.0") {
[16:12:27.866]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:27.866]                             "", base::R.version$version.string), 
[16:12:27.866]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:27.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:27.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:27.866]                               "release", "version")], collapse = " "), 
[16:12:27.866]                             hostname = base::Sys.info()[["nodename"]])
[16:12:27.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:27.866]                             info)
[16:12:27.866]                           info <- base::paste(info, collapse = "; ")
[16:12:27.866]                           if (!has_future) {
[16:12:27.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:27.866]                               info)
[16:12:27.866]                           }
[16:12:27.866]                           else {
[16:12:27.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:27.866]                               info, version)
[16:12:27.866]                           }
[16:12:27.866]                           base::stop(msg)
[16:12:27.866]                         }
[16:12:27.866]                       })
[16:12:27.866]                     }
[16:12:27.866]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:27.866]                     base::options(mc.cores = 1L)
[16:12:27.866]                   }
[16:12:27.866]                   options(future.plan = NULL)
[16:12:27.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:27.866]                 }
[16:12:27.866]                 ...future.workdir <- getwd()
[16:12:27.866]             }
[16:12:27.866]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:27.866]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:27.866]         }
[16:12:27.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:27.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:27.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:27.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:27.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:27.866]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:27.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:27.866]             base::names(...future.oldOptions))
[16:12:27.866]     }
[16:12:27.866]     if (FALSE) {
[16:12:27.866]     }
[16:12:27.866]     else {
[16:12:27.866]         if (TRUE) {
[16:12:27.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:27.866]                 open = "w")
[16:12:27.866]         }
[16:12:27.866]         else {
[16:12:27.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:27.866]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:27.866]         }
[16:12:27.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:27.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:27.866]             base::sink(type = "output", split = FALSE)
[16:12:27.866]             base::close(...future.stdout)
[16:12:27.866]         }, add = TRUE)
[16:12:27.866]     }
[16:12:27.866]     ...future.frame <- base::sys.nframe()
[16:12:27.866]     ...future.conditions <- base::list()
[16:12:27.866]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:27.866]     if (FALSE) {
[16:12:27.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:27.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:27.866]     }
[16:12:27.866]     ...future.result <- base::tryCatch({
[16:12:27.866]         base::withCallingHandlers({
[16:12:27.866]             ...future.value <- base::withVisible(base::local({
[16:12:27.866]                 ...future.makeSendCondition <- local({
[16:12:27.866]                   sendCondition <- NULL
[16:12:27.866]                   function(frame = 1L) {
[16:12:27.866]                     if (is.function(sendCondition)) 
[16:12:27.866]                       return(sendCondition)
[16:12:27.866]                     ns <- getNamespace("parallel")
[16:12:27.866]                     if (exists("sendData", mode = "function", 
[16:12:27.866]                       envir = ns)) {
[16:12:27.866]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:27.866]                         envir = ns)
[16:12:27.866]                       envir <- sys.frame(frame)
[16:12:27.866]                       master <- NULL
[16:12:27.866]                       while (!identical(envir, .GlobalEnv) && 
[16:12:27.866]                         !identical(envir, emptyenv())) {
[16:12:27.866]                         if (exists("master", mode = "list", envir = envir, 
[16:12:27.866]                           inherits = FALSE)) {
[16:12:27.866]                           master <- get("master", mode = "list", 
[16:12:27.866]                             envir = envir, inherits = FALSE)
[16:12:27.866]                           if (inherits(master, c("SOCKnode", 
[16:12:27.866]                             "SOCK0node"))) {
[16:12:27.866]                             sendCondition <<- function(cond) {
[16:12:27.866]                               data <- list(type = "VALUE", value = cond, 
[16:12:27.866]                                 success = TRUE)
[16:12:27.866]                               parallel_sendData(master, data)
[16:12:27.866]                             }
[16:12:27.866]                             return(sendCondition)
[16:12:27.866]                           }
[16:12:27.866]                         }
[16:12:27.866]                         frame <- frame + 1L
[16:12:27.866]                         envir <- sys.frame(frame)
[16:12:27.866]                       }
[16:12:27.866]                     }
[16:12:27.866]                     sendCondition <<- function(cond) NULL
[16:12:27.866]                   }
[16:12:27.866]                 })
[16:12:27.866]                 withCallingHandlers({
[16:12:27.866]                   NA
[16:12:27.866]                 }, immediateCondition = function(cond) {
[16:12:27.866]                   sendCondition <- ...future.makeSendCondition()
[16:12:27.866]                   sendCondition(cond)
[16:12:27.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.866]                   {
[16:12:27.866]                     inherits <- base::inherits
[16:12:27.866]                     invokeRestart <- base::invokeRestart
[16:12:27.866]                     is.null <- base::is.null
[16:12:27.866]                     muffled <- FALSE
[16:12:27.866]                     if (inherits(cond, "message")) {
[16:12:27.866]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:27.866]                       if (muffled) 
[16:12:27.866]                         invokeRestart("muffleMessage")
[16:12:27.866]                     }
[16:12:27.866]                     else if (inherits(cond, "warning")) {
[16:12:27.866]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:27.866]                       if (muffled) 
[16:12:27.866]                         invokeRestart("muffleWarning")
[16:12:27.866]                     }
[16:12:27.866]                     else if (inherits(cond, "condition")) {
[16:12:27.866]                       if (!is.null(pattern)) {
[16:12:27.866]                         computeRestarts <- base::computeRestarts
[16:12:27.866]                         grepl <- base::grepl
[16:12:27.866]                         restarts <- computeRestarts(cond)
[16:12:27.866]                         for (restart in restarts) {
[16:12:27.866]                           name <- restart$name
[16:12:27.866]                           if (is.null(name)) 
[16:12:27.866]                             next
[16:12:27.866]                           if (!grepl(pattern, name)) 
[16:12:27.866]                             next
[16:12:27.866]                           invokeRestart(restart)
[16:12:27.866]                           muffled <- TRUE
[16:12:27.866]                           break
[16:12:27.866]                         }
[16:12:27.866]                       }
[16:12:27.866]                     }
[16:12:27.866]                     invisible(muffled)
[16:12:27.866]                   }
[16:12:27.866]                   muffleCondition(cond)
[16:12:27.866]                 })
[16:12:27.866]             }))
[16:12:27.866]             future::FutureResult(value = ...future.value$value, 
[16:12:27.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.866]                   ...future.rng), globalenv = if (FALSE) 
[16:12:27.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:27.866]                     ...future.globalenv.names))
[16:12:27.866]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:27.866]         }, condition = base::local({
[16:12:27.866]             c <- base::c
[16:12:27.866]             inherits <- base::inherits
[16:12:27.866]             invokeRestart <- base::invokeRestart
[16:12:27.866]             length <- base::length
[16:12:27.866]             list <- base::list
[16:12:27.866]             seq.int <- base::seq.int
[16:12:27.866]             signalCondition <- base::signalCondition
[16:12:27.866]             sys.calls <- base::sys.calls
[16:12:27.866]             `[[` <- base::`[[`
[16:12:27.866]             `+` <- base::`+`
[16:12:27.866]             `<<-` <- base::`<<-`
[16:12:27.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:27.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:27.866]                   3L)]
[16:12:27.866]             }
[16:12:27.866]             function(cond) {
[16:12:27.866]                 is_error <- inherits(cond, "error")
[16:12:27.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:27.866]                   NULL)
[16:12:27.866]                 if (is_error) {
[16:12:27.866]                   sessionInformation <- function() {
[16:12:27.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:27.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:27.866]                       search = base::search(), system = base::Sys.info())
[16:12:27.866]                   }
[16:12:27.866]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:27.866]                     cond$call), session = sessionInformation(), 
[16:12:27.866]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:27.866]                   signalCondition(cond)
[16:12:27.866]                 }
[16:12:27.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:27.866]                 "immediateCondition"))) {
[16:12:27.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:27.866]                   ...future.conditions[[length(...future.conditions) + 
[16:12:27.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:27.866]                   if (TRUE && !signal) {
[16:12:27.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.866]                     {
[16:12:27.866]                       inherits <- base::inherits
[16:12:27.866]                       invokeRestart <- base::invokeRestart
[16:12:27.866]                       is.null <- base::is.null
[16:12:27.866]                       muffled <- FALSE
[16:12:27.866]                       if (inherits(cond, "message")) {
[16:12:27.866]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.866]                         if (muffled) 
[16:12:27.866]                           invokeRestart("muffleMessage")
[16:12:27.866]                       }
[16:12:27.866]                       else if (inherits(cond, "warning")) {
[16:12:27.866]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.866]                         if (muffled) 
[16:12:27.866]                           invokeRestart("muffleWarning")
[16:12:27.866]                       }
[16:12:27.866]                       else if (inherits(cond, "condition")) {
[16:12:27.866]                         if (!is.null(pattern)) {
[16:12:27.866]                           computeRestarts <- base::computeRestarts
[16:12:27.866]                           grepl <- base::grepl
[16:12:27.866]                           restarts <- computeRestarts(cond)
[16:12:27.866]                           for (restart in restarts) {
[16:12:27.866]                             name <- restart$name
[16:12:27.866]                             if (is.null(name)) 
[16:12:27.866]                               next
[16:12:27.866]                             if (!grepl(pattern, name)) 
[16:12:27.866]                               next
[16:12:27.866]                             invokeRestart(restart)
[16:12:27.866]                             muffled <- TRUE
[16:12:27.866]                             break
[16:12:27.866]                           }
[16:12:27.866]                         }
[16:12:27.866]                       }
[16:12:27.866]                       invisible(muffled)
[16:12:27.866]                     }
[16:12:27.866]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.866]                   }
[16:12:27.866]                 }
[16:12:27.866]                 else {
[16:12:27.866]                   if (TRUE) {
[16:12:27.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:27.866]                     {
[16:12:27.866]                       inherits <- base::inherits
[16:12:27.866]                       invokeRestart <- base::invokeRestart
[16:12:27.866]                       is.null <- base::is.null
[16:12:27.866]                       muffled <- FALSE
[16:12:27.866]                       if (inherits(cond, "message")) {
[16:12:27.866]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:27.866]                         if (muffled) 
[16:12:27.866]                           invokeRestart("muffleMessage")
[16:12:27.866]                       }
[16:12:27.866]                       else if (inherits(cond, "warning")) {
[16:12:27.866]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:27.866]                         if (muffled) 
[16:12:27.866]                           invokeRestart("muffleWarning")
[16:12:27.866]                       }
[16:12:27.866]                       else if (inherits(cond, "condition")) {
[16:12:27.866]                         if (!is.null(pattern)) {
[16:12:27.866]                           computeRestarts <- base::computeRestarts
[16:12:27.866]                           grepl <- base::grepl
[16:12:27.866]                           restarts <- computeRestarts(cond)
[16:12:27.866]                           for (restart in restarts) {
[16:12:27.866]                             name <- restart$name
[16:12:27.866]                             if (is.null(name)) 
[16:12:27.866]                               next
[16:12:27.866]                             if (!grepl(pattern, name)) 
[16:12:27.866]                               next
[16:12:27.866]                             invokeRestart(restart)
[16:12:27.866]                             muffled <- TRUE
[16:12:27.866]                             break
[16:12:27.866]                           }
[16:12:27.866]                         }
[16:12:27.866]                       }
[16:12:27.866]                       invisible(muffled)
[16:12:27.866]                     }
[16:12:27.866]                     muffleCondition(cond, pattern = "^muffle")
[16:12:27.866]                   }
[16:12:27.866]                 }
[16:12:27.866]             }
[16:12:27.866]         }))
[16:12:27.866]     }, error = function(ex) {
[16:12:27.866]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:27.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:27.866]                 ...future.rng), started = ...future.startTime, 
[16:12:27.866]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:27.866]             version = "1.8"), class = "FutureResult")
[16:12:27.866]     }, finally = {
[16:12:27.866]         if (!identical(...future.workdir, getwd())) 
[16:12:27.866]             setwd(...future.workdir)
[16:12:27.866]         {
[16:12:27.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:27.866]                 ...future.oldOptions$nwarnings <- NULL
[16:12:27.866]             }
[16:12:27.866]             base::options(...future.oldOptions)
[16:12:27.866]             if (.Platform$OS.type == "windows") {
[16:12:27.866]                 old_names <- names(...future.oldEnvVars)
[16:12:27.866]                 envs <- base::Sys.getenv()
[16:12:27.866]                 names <- names(envs)
[16:12:27.866]                 common <- intersect(names, old_names)
[16:12:27.866]                 added <- setdiff(names, old_names)
[16:12:27.866]                 removed <- setdiff(old_names, names)
[16:12:27.866]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:27.866]                   envs[common]]
[16:12:27.866]                 NAMES <- toupper(changed)
[16:12:27.866]                 args <- list()
[16:12:27.866]                 for (kk in seq_along(NAMES)) {
[16:12:27.866]                   name <- changed[[kk]]
[16:12:27.866]                   NAME <- NAMES[[kk]]
[16:12:27.866]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.866]                     next
[16:12:27.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.866]                 }
[16:12:27.866]                 NAMES <- toupper(added)
[16:12:27.866]                 for (kk in seq_along(NAMES)) {
[16:12:27.866]                   name <- added[[kk]]
[16:12:27.866]                   NAME <- NAMES[[kk]]
[16:12:27.866]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.866]                     next
[16:12:27.866]                   args[[name]] <- ""
[16:12:27.866]                 }
[16:12:27.866]                 NAMES <- toupper(removed)
[16:12:27.866]                 for (kk in seq_along(NAMES)) {
[16:12:27.866]                   name <- removed[[kk]]
[16:12:27.866]                   NAME <- NAMES[[kk]]
[16:12:27.866]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:27.866]                     next
[16:12:27.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:27.866]                 }
[16:12:27.866]                 if (length(args) > 0) 
[16:12:27.866]                   base::do.call(base::Sys.setenv, args = args)
[16:12:27.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:27.866]             }
[16:12:27.866]             else {
[16:12:27.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:27.866]             }
[16:12:27.866]             {
[16:12:27.866]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:27.866]                   0L) {
[16:12:27.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:27.866]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:27.866]                   base::options(opts)
[16:12:27.866]                 }
[16:12:27.866]                 {
[16:12:27.866]                   {
[16:12:27.866]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:27.866]                     NULL
[16:12:27.866]                   }
[16:12:27.866]                   options(future.plan = NULL)
[16:12:27.866]                   if (is.na(NA_character_)) 
[16:12:27.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:27.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:27.866]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:27.866]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:27.866]                     envir = parent.frame()) 
[16:12:27.866]                   {
[16:12:27.866]                     if (is.function(workers)) 
[16:12:27.866]                       workers <- workers()
[16:12:27.866]                     workers <- structure(as.integer(workers), 
[16:12:27.866]                       class = class(workers))
[16:12:27.866]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:27.866]                       workers >= 1)
[16:12:27.866]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:27.866]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:27.866]                     }
[16:12:27.866]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:27.866]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:27.866]                       envir = envir)
[16:12:27.866]                     if (!future$lazy) 
[16:12:27.866]                       future <- run(future)
[16:12:27.866]                     invisible(future)
[16:12:27.866]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:27.866]                 }
[16:12:27.866]             }
[16:12:27.866]         }
[16:12:27.866]     })
[16:12:27.866]     if (TRUE) {
[16:12:27.866]         base::sink(type = "output", split = FALSE)
[16:12:27.866]         if (TRUE) {
[16:12:27.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:27.866]         }
[16:12:27.866]         else {
[16:12:27.866]             ...future.result["stdout"] <- base::list(NULL)
[16:12:27.866]         }
[16:12:27.866]         base::close(...future.stdout)
[16:12:27.866]         ...future.stdout <- NULL
[16:12:27.866]     }
[16:12:27.866]     ...future.result$conditions <- ...future.conditions
[16:12:27.866]     ...future.result$finished <- base::Sys.time()
[16:12:27.866]     ...future.result
[16:12:27.866] }
[16:12:27.938] MultisessionFuture started
[16:12:27.938] result() for ClusterFuture ...
[16:12:27.939] receiveMessageFromWorker() for ClusterFuture ...
[16:12:27.939] - Validating connection of MultisessionFuture
[16:12:27.974] - received message: FutureResult
[16:12:27.974] - Received FutureResult
[16:12:27.975] - Erased future from FutureRegistry
[16:12:27.975] result() for ClusterFuture ...
[16:12:27.975] - result already collected: FutureResult
[16:12:27.975] result() for ClusterFuture ... done
[16:12:27.975] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:27.975] result() for ClusterFuture ... done
[16:12:27.975] result() for ClusterFuture ...
[16:12:27.975] - result already collected: FutureResult
[16:12:27.976] result() for ClusterFuture ... done
[16:12:27.976] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:27.980] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:12:27.980] getGlobalsAndPackages() ...
[16:12:27.980] Searching for globals...
[16:12:27.980] 
[16:12:27.981] Searching for globals ... DONE
[16:12:27.981] - globals: [0] <none>
[16:12:27.981] getGlobalsAndPackages() ... DONE
[16:12:27.981] run() for ‘Future’ ...
[16:12:27.981] - state: ‘created’
[16:12:27.981] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:27.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:27.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:27.997]   - Field: ‘node’
[16:12:27.997]   - Field: ‘label’
[16:12:27.997]   - Field: ‘local’
[16:12:27.997]   - Field: ‘owner’
[16:12:27.998]   - Field: ‘envir’
[16:12:27.998]   - Field: ‘workers’
[16:12:27.998]   - Field: ‘packages’
[16:12:27.998]   - Field: ‘gc’
[16:12:27.998]   - Field: ‘conditions’
[16:12:27.998]   - Field: ‘persistent’
[16:12:27.998]   - Field: ‘expr’
[16:12:27.998]   - Field: ‘uuid’
[16:12:27.998]   - Field: ‘seed’
[16:12:27.999]   - Field: ‘version’
[16:12:27.999]   - Field: ‘result’
[16:12:27.999]   - Field: ‘asynchronous’
[16:12:27.999]   - Field: ‘calls’
[16:12:27.999]   - Field: ‘globals’
[16:12:27.999]   - Field: ‘stdout’
[16:12:27.999]   - Field: ‘earlySignal’
[16:12:27.999]   - Field: ‘lazy’
[16:12:27.999]   - Field: ‘state’
[16:12:28.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.000] - Launch lazy future ...
[16:12:28.000] Packages needed by the future expression (n = 0): <none>
[16:12:28.000] Packages needed by future strategies (n = 0): <none>
[16:12:28.001] {
[16:12:28.001]     {
[16:12:28.001]         {
[16:12:28.001]             ...future.startTime <- base::Sys.time()
[16:12:28.001]             {
[16:12:28.001]                 {
[16:12:28.001]                   {
[16:12:28.001]                     {
[16:12:28.001]                       base::local({
[16:12:28.001]                         has_future <- base::requireNamespace("future", 
[16:12:28.001]                           quietly = TRUE)
[16:12:28.001]                         if (has_future) {
[16:12:28.001]                           ns <- base::getNamespace("future")
[16:12:28.001]                           version <- ns[[".package"]][["version"]]
[16:12:28.001]                           if (is.null(version)) 
[16:12:28.001]                             version <- utils::packageVersion("future")
[16:12:28.001]                         }
[16:12:28.001]                         else {
[16:12:28.001]                           version <- NULL
[16:12:28.001]                         }
[16:12:28.001]                         if (!has_future || version < "1.8.0") {
[16:12:28.001]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.001]                             "", base::R.version$version.string), 
[16:12:28.001]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.001]                               "release", "version")], collapse = " "), 
[16:12:28.001]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.001]                             info)
[16:12:28.001]                           info <- base::paste(info, collapse = "; ")
[16:12:28.001]                           if (!has_future) {
[16:12:28.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.001]                               info)
[16:12:28.001]                           }
[16:12:28.001]                           else {
[16:12:28.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.001]                               info, version)
[16:12:28.001]                           }
[16:12:28.001]                           base::stop(msg)
[16:12:28.001]                         }
[16:12:28.001]                       })
[16:12:28.001]                     }
[16:12:28.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.001]                     base::options(mc.cores = 1L)
[16:12:28.001]                   }
[16:12:28.001]                   options(future.plan = NULL)
[16:12:28.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.001]                 }
[16:12:28.001]                 ...future.workdir <- getwd()
[16:12:28.001]             }
[16:12:28.001]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.001]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.001]         }
[16:12:28.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.001]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.001]             base::names(...future.oldOptions))
[16:12:28.001]     }
[16:12:28.001]     if (FALSE) {
[16:12:28.001]     }
[16:12:28.001]     else {
[16:12:28.001]         if (TRUE) {
[16:12:28.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.001]                 open = "w")
[16:12:28.001]         }
[16:12:28.001]         else {
[16:12:28.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.001]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.001]         }
[16:12:28.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.001]             base::sink(type = "output", split = FALSE)
[16:12:28.001]             base::close(...future.stdout)
[16:12:28.001]         }, add = TRUE)
[16:12:28.001]     }
[16:12:28.001]     ...future.frame <- base::sys.nframe()
[16:12:28.001]     ...future.conditions <- base::list()
[16:12:28.001]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.001]     if (FALSE) {
[16:12:28.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.001]     }
[16:12:28.001]     ...future.result <- base::tryCatch({
[16:12:28.001]         base::withCallingHandlers({
[16:12:28.001]             ...future.value <- base::withVisible(base::local({
[16:12:28.001]                 ...future.makeSendCondition <- local({
[16:12:28.001]                   sendCondition <- NULL
[16:12:28.001]                   function(frame = 1L) {
[16:12:28.001]                     if (is.function(sendCondition)) 
[16:12:28.001]                       return(sendCondition)
[16:12:28.001]                     ns <- getNamespace("parallel")
[16:12:28.001]                     if (exists("sendData", mode = "function", 
[16:12:28.001]                       envir = ns)) {
[16:12:28.001]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.001]                         envir = ns)
[16:12:28.001]                       envir <- sys.frame(frame)
[16:12:28.001]                       master <- NULL
[16:12:28.001]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.001]                         !identical(envir, emptyenv())) {
[16:12:28.001]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.001]                           inherits = FALSE)) {
[16:12:28.001]                           master <- get("master", mode = "list", 
[16:12:28.001]                             envir = envir, inherits = FALSE)
[16:12:28.001]                           if (inherits(master, c("SOCKnode", 
[16:12:28.001]                             "SOCK0node"))) {
[16:12:28.001]                             sendCondition <<- function(cond) {
[16:12:28.001]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.001]                                 success = TRUE)
[16:12:28.001]                               parallel_sendData(master, data)
[16:12:28.001]                             }
[16:12:28.001]                             return(sendCondition)
[16:12:28.001]                           }
[16:12:28.001]                         }
[16:12:28.001]                         frame <- frame + 1L
[16:12:28.001]                         envir <- sys.frame(frame)
[16:12:28.001]                       }
[16:12:28.001]                     }
[16:12:28.001]                     sendCondition <<- function(cond) NULL
[16:12:28.001]                   }
[16:12:28.001]                 })
[16:12:28.001]                 withCallingHandlers({
[16:12:28.001]                   2
[16:12:28.001]                 }, immediateCondition = function(cond) {
[16:12:28.001]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.001]                   sendCondition(cond)
[16:12:28.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.001]                   {
[16:12:28.001]                     inherits <- base::inherits
[16:12:28.001]                     invokeRestart <- base::invokeRestart
[16:12:28.001]                     is.null <- base::is.null
[16:12:28.001]                     muffled <- FALSE
[16:12:28.001]                     if (inherits(cond, "message")) {
[16:12:28.001]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.001]                       if (muffled) 
[16:12:28.001]                         invokeRestart("muffleMessage")
[16:12:28.001]                     }
[16:12:28.001]                     else if (inherits(cond, "warning")) {
[16:12:28.001]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.001]                       if (muffled) 
[16:12:28.001]                         invokeRestart("muffleWarning")
[16:12:28.001]                     }
[16:12:28.001]                     else if (inherits(cond, "condition")) {
[16:12:28.001]                       if (!is.null(pattern)) {
[16:12:28.001]                         computeRestarts <- base::computeRestarts
[16:12:28.001]                         grepl <- base::grepl
[16:12:28.001]                         restarts <- computeRestarts(cond)
[16:12:28.001]                         for (restart in restarts) {
[16:12:28.001]                           name <- restart$name
[16:12:28.001]                           if (is.null(name)) 
[16:12:28.001]                             next
[16:12:28.001]                           if (!grepl(pattern, name)) 
[16:12:28.001]                             next
[16:12:28.001]                           invokeRestart(restart)
[16:12:28.001]                           muffled <- TRUE
[16:12:28.001]                           break
[16:12:28.001]                         }
[16:12:28.001]                       }
[16:12:28.001]                     }
[16:12:28.001]                     invisible(muffled)
[16:12:28.001]                   }
[16:12:28.001]                   muffleCondition(cond)
[16:12:28.001]                 })
[16:12:28.001]             }))
[16:12:28.001]             future::FutureResult(value = ...future.value$value, 
[16:12:28.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.001]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.001]                     ...future.globalenv.names))
[16:12:28.001]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.001]         }, condition = base::local({
[16:12:28.001]             c <- base::c
[16:12:28.001]             inherits <- base::inherits
[16:12:28.001]             invokeRestart <- base::invokeRestart
[16:12:28.001]             length <- base::length
[16:12:28.001]             list <- base::list
[16:12:28.001]             seq.int <- base::seq.int
[16:12:28.001]             signalCondition <- base::signalCondition
[16:12:28.001]             sys.calls <- base::sys.calls
[16:12:28.001]             `[[` <- base::`[[`
[16:12:28.001]             `+` <- base::`+`
[16:12:28.001]             `<<-` <- base::`<<-`
[16:12:28.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.001]                   3L)]
[16:12:28.001]             }
[16:12:28.001]             function(cond) {
[16:12:28.001]                 is_error <- inherits(cond, "error")
[16:12:28.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.001]                   NULL)
[16:12:28.001]                 if (is_error) {
[16:12:28.001]                   sessionInformation <- function() {
[16:12:28.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.001]                       search = base::search(), system = base::Sys.info())
[16:12:28.001]                   }
[16:12:28.001]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.001]                     cond$call), session = sessionInformation(), 
[16:12:28.001]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.001]                   signalCondition(cond)
[16:12:28.001]                 }
[16:12:28.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.001]                 "immediateCondition"))) {
[16:12:28.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.001]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.001]                   if (TRUE && !signal) {
[16:12:28.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.001]                     {
[16:12:28.001]                       inherits <- base::inherits
[16:12:28.001]                       invokeRestart <- base::invokeRestart
[16:12:28.001]                       is.null <- base::is.null
[16:12:28.001]                       muffled <- FALSE
[16:12:28.001]                       if (inherits(cond, "message")) {
[16:12:28.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.001]                         if (muffled) 
[16:12:28.001]                           invokeRestart("muffleMessage")
[16:12:28.001]                       }
[16:12:28.001]                       else if (inherits(cond, "warning")) {
[16:12:28.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.001]                         if (muffled) 
[16:12:28.001]                           invokeRestart("muffleWarning")
[16:12:28.001]                       }
[16:12:28.001]                       else if (inherits(cond, "condition")) {
[16:12:28.001]                         if (!is.null(pattern)) {
[16:12:28.001]                           computeRestarts <- base::computeRestarts
[16:12:28.001]                           grepl <- base::grepl
[16:12:28.001]                           restarts <- computeRestarts(cond)
[16:12:28.001]                           for (restart in restarts) {
[16:12:28.001]                             name <- restart$name
[16:12:28.001]                             if (is.null(name)) 
[16:12:28.001]                               next
[16:12:28.001]                             if (!grepl(pattern, name)) 
[16:12:28.001]                               next
[16:12:28.001]                             invokeRestart(restart)
[16:12:28.001]                             muffled <- TRUE
[16:12:28.001]                             break
[16:12:28.001]                           }
[16:12:28.001]                         }
[16:12:28.001]                       }
[16:12:28.001]                       invisible(muffled)
[16:12:28.001]                     }
[16:12:28.001]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.001]                   }
[16:12:28.001]                 }
[16:12:28.001]                 else {
[16:12:28.001]                   if (TRUE) {
[16:12:28.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.001]                     {
[16:12:28.001]                       inherits <- base::inherits
[16:12:28.001]                       invokeRestart <- base::invokeRestart
[16:12:28.001]                       is.null <- base::is.null
[16:12:28.001]                       muffled <- FALSE
[16:12:28.001]                       if (inherits(cond, "message")) {
[16:12:28.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.001]                         if (muffled) 
[16:12:28.001]                           invokeRestart("muffleMessage")
[16:12:28.001]                       }
[16:12:28.001]                       else if (inherits(cond, "warning")) {
[16:12:28.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.001]                         if (muffled) 
[16:12:28.001]                           invokeRestart("muffleWarning")
[16:12:28.001]                       }
[16:12:28.001]                       else if (inherits(cond, "condition")) {
[16:12:28.001]                         if (!is.null(pattern)) {
[16:12:28.001]                           computeRestarts <- base::computeRestarts
[16:12:28.001]                           grepl <- base::grepl
[16:12:28.001]                           restarts <- computeRestarts(cond)
[16:12:28.001]                           for (restart in restarts) {
[16:12:28.001]                             name <- restart$name
[16:12:28.001]                             if (is.null(name)) 
[16:12:28.001]                               next
[16:12:28.001]                             if (!grepl(pattern, name)) 
[16:12:28.001]                               next
[16:12:28.001]                             invokeRestart(restart)
[16:12:28.001]                             muffled <- TRUE
[16:12:28.001]                             break
[16:12:28.001]                           }
[16:12:28.001]                         }
[16:12:28.001]                       }
[16:12:28.001]                       invisible(muffled)
[16:12:28.001]                     }
[16:12:28.001]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.001]                   }
[16:12:28.001]                 }
[16:12:28.001]             }
[16:12:28.001]         }))
[16:12:28.001]     }, error = function(ex) {
[16:12:28.001]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.001]                 ...future.rng), started = ...future.startTime, 
[16:12:28.001]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.001]             version = "1.8"), class = "FutureResult")
[16:12:28.001]     }, finally = {
[16:12:28.001]         if (!identical(...future.workdir, getwd())) 
[16:12:28.001]             setwd(...future.workdir)
[16:12:28.001]         {
[16:12:28.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.001]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.001]             }
[16:12:28.001]             base::options(...future.oldOptions)
[16:12:28.001]             if (.Platform$OS.type == "windows") {
[16:12:28.001]                 old_names <- names(...future.oldEnvVars)
[16:12:28.001]                 envs <- base::Sys.getenv()
[16:12:28.001]                 names <- names(envs)
[16:12:28.001]                 common <- intersect(names, old_names)
[16:12:28.001]                 added <- setdiff(names, old_names)
[16:12:28.001]                 removed <- setdiff(old_names, names)
[16:12:28.001]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.001]                   envs[common]]
[16:12:28.001]                 NAMES <- toupper(changed)
[16:12:28.001]                 args <- list()
[16:12:28.001]                 for (kk in seq_along(NAMES)) {
[16:12:28.001]                   name <- changed[[kk]]
[16:12:28.001]                   NAME <- NAMES[[kk]]
[16:12:28.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.001]                     next
[16:12:28.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.001]                 }
[16:12:28.001]                 NAMES <- toupper(added)
[16:12:28.001]                 for (kk in seq_along(NAMES)) {
[16:12:28.001]                   name <- added[[kk]]
[16:12:28.001]                   NAME <- NAMES[[kk]]
[16:12:28.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.001]                     next
[16:12:28.001]                   args[[name]] <- ""
[16:12:28.001]                 }
[16:12:28.001]                 NAMES <- toupper(removed)
[16:12:28.001]                 for (kk in seq_along(NAMES)) {
[16:12:28.001]                   name <- removed[[kk]]
[16:12:28.001]                   NAME <- NAMES[[kk]]
[16:12:28.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.001]                     next
[16:12:28.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.001]                 }
[16:12:28.001]                 if (length(args) > 0) 
[16:12:28.001]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.001]             }
[16:12:28.001]             else {
[16:12:28.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.001]             }
[16:12:28.001]             {
[16:12:28.001]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.001]                   0L) {
[16:12:28.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.001]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.001]                   base::options(opts)
[16:12:28.001]                 }
[16:12:28.001]                 {
[16:12:28.001]                   {
[16:12:28.001]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.001]                     NULL
[16:12:28.001]                   }
[16:12:28.001]                   options(future.plan = NULL)
[16:12:28.001]                   if (is.na(NA_character_)) 
[16:12:28.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.001]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.001]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.001]                     envir = parent.frame()) 
[16:12:28.001]                   {
[16:12:28.001]                     if (is.function(workers)) 
[16:12:28.001]                       workers <- workers()
[16:12:28.001]                     workers <- structure(as.integer(workers), 
[16:12:28.001]                       class = class(workers))
[16:12:28.001]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.001]                       workers >= 1)
[16:12:28.001]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.001]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.001]                     }
[16:12:28.001]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.001]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.001]                       envir = envir)
[16:12:28.001]                     if (!future$lazy) 
[16:12:28.001]                       future <- run(future)
[16:12:28.001]                     invisible(future)
[16:12:28.001]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.001]                 }
[16:12:28.001]             }
[16:12:28.001]         }
[16:12:28.001]     })
[16:12:28.001]     if (TRUE) {
[16:12:28.001]         base::sink(type = "output", split = FALSE)
[16:12:28.001]         if (TRUE) {
[16:12:28.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.001]         }
[16:12:28.001]         else {
[16:12:28.001]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.001]         }
[16:12:28.001]         base::close(...future.stdout)
[16:12:28.001]         ...future.stdout <- NULL
[16:12:28.001]     }
[16:12:28.001]     ...future.result$conditions <- ...future.conditions
[16:12:28.001]     ...future.result$finished <- base::Sys.time()
[16:12:28.001]     ...future.result
[16:12:28.001] }
[16:12:28.004] MultisessionFuture started
[16:12:28.005] - Launch lazy future ... done
[16:12:28.005] run() for ‘MultisessionFuture’ ... done
[16:12:28.005] getGlobalsAndPackages() ...
[16:12:28.005] Searching for globals...
[16:12:28.006] 
[16:12:28.006] Searching for globals ... DONE
[16:12:28.006] - globals: [0] <none>
[16:12:28.006] getGlobalsAndPackages() ... DONE
[16:12:28.006] run() for ‘Future’ ...
[16:12:28.006] - state: ‘created’
[16:12:28.007] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.022]   - Field: ‘node’
[16:12:28.023]   - Field: ‘label’
[16:12:28.023]   - Field: ‘local’
[16:12:28.023]   - Field: ‘owner’
[16:12:28.023]   - Field: ‘envir’
[16:12:28.023]   - Field: ‘workers’
[16:12:28.023]   - Field: ‘packages’
[16:12:28.023]   - Field: ‘gc’
[16:12:28.023]   - Field: ‘conditions’
[16:12:28.023]   - Field: ‘persistent’
[16:12:28.024]   - Field: ‘expr’
[16:12:28.024]   - Field: ‘uuid’
[16:12:28.024]   - Field: ‘seed’
[16:12:28.024]   - Field: ‘version’
[16:12:28.024]   - Field: ‘result’
[16:12:28.024]   - Field: ‘asynchronous’
[16:12:28.024]   - Field: ‘calls’
[16:12:28.024]   - Field: ‘globals’
[16:12:28.024]   - Field: ‘stdout’
[16:12:28.025]   - Field: ‘earlySignal’
[16:12:28.025]   - Field: ‘lazy’
[16:12:28.025]   - Field: ‘state’
[16:12:28.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.025] - Launch lazy future ...
[16:12:28.025] Packages needed by the future expression (n = 0): <none>
[16:12:28.026] Packages needed by future strategies (n = 0): <none>
[16:12:28.026] {
[16:12:28.026]     {
[16:12:28.026]         {
[16:12:28.026]             ...future.startTime <- base::Sys.time()
[16:12:28.026]             {
[16:12:28.026]                 {
[16:12:28.026]                   {
[16:12:28.026]                     {
[16:12:28.026]                       base::local({
[16:12:28.026]                         has_future <- base::requireNamespace("future", 
[16:12:28.026]                           quietly = TRUE)
[16:12:28.026]                         if (has_future) {
[16:12:28.026]                           ns <- base::getNamespace("future")
[16:12:28.026]                           version <- ns[[".package"]][["version"]]
[16:12:28.026]                           if (is.null(version)) 
[16:12:28.026]                             version <- utils::packageVersion("future")
[16:12:28.026]                         }
[16:12:28.026]                         else {
[16:12:28.026]                           version <- NULL
[16:12:28.026]                         }
[16:12:28.026]                         if (!has_future || version < "1.8.0") {
[16:12:28.026]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.026]                             "", base::R.version$version.string), 
[16:12:28.026]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.026]                               "release", "version")], collapse = " "), 
[16:12:28.026]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.026]                             info)
[16:12:28.026]                           info <- base::paste(info, collapse = "; ")
[16:12:28.026]                           if (!has_future) {
[16:12:28.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.026]                               info)
[16:12:28.026]                           }
[16:12:28.026]                           else {
[16:12:28.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.026]                               info, version)
[16:12:28.026]                           }
[16:12:28.026]                           base::stop(msg)
[16:12:28.026]                         }
[16:12:28.026]                       })
[16:12:28.026]                     }
[16:12:28.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.026]                     base::options(mc.cores = 1L)
[16:12:28.026]                   }
[16:12:28.026]                   options(future.plan = NULL)
[16:12:28.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.026]                 }
[16:12:28.026]                 ...future.workdir <- getwd()
[16:12:28.026]             }
[16:12:28.026]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.026]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.026]         }
[16:12:28.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.026]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.026]             base::names(...future.oldOptions))
[16:12:28.026]     }
[16:12:28.026]     if (FALSE) {
[16:12:28.026]     }
[16:12:28.026]     else {
[16:12:28.026]         if (TRUE) {
[16:12:28.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.026]                 open = "w")
[16:12:28.026]         }
[16:12:28.026]         else {
[16:12:28.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.026]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.026]         }
[16:12:28.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.026]             base::sink(type = "output", split = FALSE)
[16:12:28.026]             base::close(...future.stdout)
[16:12:28.026]         }, add = TRUE)
[16:12:28.026]     }
[16:12:28.026]     ...future.frame <- base::sys.nframe()
[16:12:28.026]     ...future.conditions <- base::list()
[16:12:28.026]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.026]     if (FALSE) {
[16:12:28.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.026]     }
[16:12:28.026]     ...future.result <- base::tryCatch({
[16:12:28.026]         base::withCallingHandlers({
[16:12:28.026]             ...future.value <- base::withVisible(base::local({
[16:12:28.026]                 ...future.makeSendCondition <- local({
[16:12:28.026]                   sendCondition <- NULL
[16:12:28.026]                   function(frame = 1L) {
[16:12:28.026]                     if (is.function(sendCondition)) 
[16:12:28.026]                       return(sendCondition)
[16:12:28.026]                     ns <- getNamespace("parallel")
[16:12:28.026]                     if (exists("sendData", mode = "function", 
[16:12:28.026]                       envir = ns)) {
[16:12:28.026]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.026]                         envir = ns)
[16:12:28.026]                       envir <- sys.frame(frame)
[16:12:28.026]                       master <- NULL
[16:12:28.026]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.026]                         !identical(envir, emptyenv())) {
[16:12:28.026]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.026]                           inherits = FALSE)) {
[16:12:28.026]                           master <- get("master", mode = "list", 
[16:12:28.026]                             envir = envir, inherits = FALSE)
[16:12:28.026]                           if (inherits(master, c("SOCKnode", 
[16:12:28.026]                             "SOCK0node"))) {
[16:12:28.026]                             sendCondition <<- function(cond) {
[16:12:28.026]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.026]                                 success = TRUE)
[16:12:28.026]                               parallel_sendData(master, data)
[16:12:28.026]                             }
[16:12:28.026]                             return(sendCondition)
[16:12:28.026]                           }
[16:12:28.026]                         }
[16:12:28.026]                         frame <- frame + 1L
[16:12:28.026]                         envir <- sys.frame(frame)
[16:12:28.026]                       }
[16:12:28.026]                     }
[16:12:28.026]                     sendCondition <<- function(cond) NULL
[16:12:28.026]                   }
[16:12:28.026]                 })
[16:12:28.026]                 withCallingHandlers({
[16:12:28.026]                   NULL
[16:12:28.026]                 }, immediateCondition = function(cond) {
[16:12:28.026]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.026]                   sendCondition(cond)
[16:12:28.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.026]                   {
[16:12:28.026]                     inherits <- base::inherits
[16:12:28.026]                     invokeRestart <- base::invokeRestart
[16:12:28.026]                     is.null <- base::is.null
[16:12:28.026]                     muffled <- FALSE
[16:12:28.026]                     if (inherits(cond, "message")) {
[16:12:28.026]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.026]                       if (muffled) 
[16:12:28.026]                         invokeRestart("muffleMessage")
[16:12:28.026]                     }
[16:12:28.026]                     else if (inherits(cond, "warning")) {
[16:12:28.026]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.026]                       if (muffled) 
[16:12:28.026]                         invokeRestart("muffleWarning")
[16:12:28.026]                     }
[16:12:28.026]                     else if (inherits(cond, "condition")) {
[16:12:28.026]                       if (!is.null(pattern)) {
[16:12:28.026]                         computeRestarts <- base::computeRestarts
[16:12:28.026]                         grepl <- base::grepl
[16:12:28.026]                         restarts <- computeRestarts(cond)
[16:12:28.026]                         for (restart in restarts) {
[16:12:28.026]                           name <- restart$name
[16:12:28.026]                           if (is.null(name)) 
[16:12:28.026]                             next
[16:12:28.026]                           if (!grepl(pattern, name)) 
[16:12:28.026]                             next
[16:12:28.026]                           invokeRestart(restart)
[16:12:28.026]                           muffled <- TRUE
[16:12:28.026]                           break
[16:12:28.026]                         }
[16:12:28.026]                       }
[16:12:28.026]                     }
[16:12:28.026]                     invisible(muffled)
[16:12:28.026]                   }
[16:12:28.026]                   muffleCondition(cond)
[16:12:28.026]                 })
[16:12:28.026]             }))
[16:12:28.026]             future::FutureResult(value = ...future.value$value, 
[16:12:28.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.026]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.026]                     ...future.globalenv.names))
[16:12:28.026]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.026]         }, condition = base::local({
[16:12:28.026]             c <- base::c
[16:12:28.026]             inherits <- base::inherits
[16:12:28.026]             invokeRestart <- base::invokeRestart
[16:12:28.026]             length <- base::length
[16:12:28.026]             list <- base::list
[16:12:28.026]             seq.int <- base::seq.int
[16:12:28.026]             signalCondition <- base::signalCondition
[16:12:28.026]             sys.calls <- base::sys.calls
[16:12:28.026]             `[[` <- base::`[[`
[16:12:28.026]             `+` <- base::`+`
[16:12:28.026]             `<<-` <- base::`<<-`
[16:12:28.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.026]                   3L)]
[16:12:28.026]             }
[16:12:28.026]             function(cond) {
[16:12:28.026]                 is_error <- inherits(cond, "error")
[16:12:28.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.026]                   NULL)
[16:12:28.026]                 if (is_error) {
[16:12:28.026]                   sessionInformation <- function() {
[16:12:28.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.026]                       search = base::search(), system = base::Sys.info())
[16:12:28.026]                   }
[16:12:28.026]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.026]                     cond$call), session = sessionInformation(), 
[16:12:28.026]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.026]                   signalCondition(cond)
[16:12:28.026]                 }
[16:12:28.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.026]                 "immediateCondition"))) {
[16:12:28.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.026]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.026]                   if (TRUE && !signal) {
[16:12:28.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.026]                     {
[16:12:28.026]                       inherits <- base::inherits
[16:12:28.026]                       invokeRestart <- base::invokeRestart
[16:12:28.026]                       is.null <- base::is.null
[16:12:28.026]                       muffled <- FALSE
[16:12:28.026]                       if (inherits(cond, "message")) {
[16:12:28.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.026]                         if (muffled) 
[16:12:28.026]                           invokeRestart("muffleMessage")
[16:12:28.026]                       }
[16:12:28.026]                       else if (inherits(cond, "warning")) {
[16:12:28.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.026]                         if (muffled) 
[16:12:28.026]                           invokeRestart("muffleWarning")
[16:12:28.026]                       }
[16:12:28.026]                       else if (inherits(cond, "condition")) {
[16:12:28.026]                         if (!is.null(pattern)) {
[16:12:28.026]                           computeRestarts <- base::computeRestarts
[16:12:28.026]                           grepl <- base::grepl
[16:12:28.026]                           restarts <- computeRestarts(cond)
[16:12:28.026]                           for (restart in restarts) {
[16:12:28.026]                             name <- restart$name
[16:12:28.026]                             if (is.null(name)) 
[16:12:28.026]                               next
[16:12:28.026]                             if (!grepl(pattern, name)) 
[16:12:28.026]                               next
[16:12:28.026]                             invokeRestart(restart)
[16:12:28.026]                             muffled <- TRUE
[16:12:28.026]                             break
[16:12:28.026]                           }
[16:12:28.026]                         }
[16:12:28.026]                       }
[16:12:28.026]                       invisible(muffled)
[16:12:28.026]                     }
[16:12:28.026]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.026]                   }
[16:12:28.026]                 }
[16:12:28.026]                 else {
[16:12:28.026]                   if (TRUE) {
[16:12:28.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.026]                     {
[16:12:28.026]                       inherits <- base::inherits
[16:12:28.026]                       invokeRestart <- base::invokeRestart
[16:12:28.026]                       is.null <- base::is.null
[16:12:28.026]                       muffled <- FALSE
[16:12:28.026]                       if (inherits(cond, "message")) {
[16:12:28.026]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.026]                         if (muffled) 
[16:12:28.026]                           invokeRestart("muffleMessage")
[16:12:28.026]                       }
[16:12:28.026]                       else if (inherits(cond, "warning")) {
[16:12:28.026]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.026]                         if (muffled) 
[16:12:28.026]                           invokeRestart("muffleWarning")
[16:12:28.026]                       }
[16:12:28.026]                       else if (inherits(cond, "condition")) {
[16:12:28.026]                         if (!is.null(pattern)) {
[16:12:28.026]                           computeRestarts <- base::computeRestarts
[16:12:28.026]                           grepl <- base::grepl
[16:12:28.026]                           restarts <- computeRestarts(cond)
[16:12:28.026]                           for (restart in restarts) {
[16:12:28.026]                             name <- restart$name
[16:12:28.026]                             if (is.null(name)) 
[16:12:28.026]                               next
[16:12:28.026]                             if (!grepl(pattern, name)) 
[16:12:28.026]                               next
[16:12:28.026]                             invokeRestart(restart)
[16:12:28.026]                             muffled <- TRUE
[16:12:28.026]                             break
[16:12:28.026]                           }
[16:12:28.026]                         }
[16:12:28.026]                       }
[16:12:28.026]                       invisible(muffled)
[16:12:28.026]                     }
[16:12:28.026]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.026]                   }
[16:12:28.026]                 }
[16:12:28.026]             }
[16:12:28.026]         }))
[16:12:28.026]     }, error = function(ex) {
[16:12:28.026]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.026]                 ...future.rng), started = ...future.startTime, 
[16:12:28.026]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.026]             version = "1.8"), class = "FutureResult")
[16:12:28.026]     }, finally = {
[16:12:28.026]         if (!identical(...future.workdir, getwd())) 
[16:12:28.026]             setwd(...future.workdir)
[16:12:28.026]         {
[16:12:28.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.026]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.026]             }
[16:12:28.026]             base::options(...future.oldOptions)
[16:12:28.026]             if (.Platform$OS.type == "windows") {
[16:12:28.026]                 old_names <- names(...future.oldEnvVars)
[16:12:28.026]                 envs <- base::Sys.getenv()
[16:12:28.026]                 names <- names(envs)
[16:12:28.026]                 common <- intersect(names, old_names)
[16:12:28.026]                 added <- setdiff(names, old_names)
[16:12:28.026]                 removed <- setdiff(old_names, names)
[16:12:28.026]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.026]                   envs[common]]
[16:12:28.026]                 NAMES <- toupper(changed)
[16:12:28.026]                 args <- list()
[16:12:28.026]                 for (kk in seq_along(NAMES)) {
[16:12:28.026]                   name <- changed[[kk]]
[16:12:28.026]                   NAME <- NAMES[[kk]]
[16:12:28.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.026]                     next
[16:12:28.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.026]                 }
[16:12:28.026]                 NAMES <- toupper(added)
[16:12:28.026]                 for (kk in seq_along(NAMES)) {
[16:12:28.026]                   name <- added[[kk]]
[16:12:28.026]                   NAME <- NAMES[[kk]]
[16:12:28.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.026]                     next
[16:12:28.026]                   args[[name]] <- ""
[16:12:28.026]                 }
[16:12:28.026]                 NAMES <- toupper(removed)
[16:12:28.026]                 for (kk in seq_along(NAMES)) {
[16:12:28.026]                   name <- removed[[kk]]
[16:12:28.026]                   NAME <- NAMES[[kk]]
[16:12:28.026]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.026]                     next
[16:12:28.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.026]                 }
[16:12:28.026]                 if (length(args) > 0) 
[16:12:28.026]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.026]             }
[16:12:28.026]             else {
[16:12:28.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.026]             }
[16:12:28.026]             {
[16:12:28.026]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.026]                   0L) {
[16:12:28.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.026]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.026]                   base::options(opts)
[16:12:28.026]                 }
[16:12:28.026]                 {
[16:12:28.026]                   {
[16:12:28.026]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.026]                     NULL
[16:12:28.026]                   }
[16:12:28.026]                   options(future.plan = NULL)
[16:12:28.026]                   if (is.na(NA_character_)) 
[16:12:28.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.026]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.026]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.026]                     envir = parent.frame()) 
[16:12:28.026]                   {
[16:12:28.026]                     if (is.function(workers)) 
[16:12:28.026]                       workers <- workers()
[16:12:28.026]                     workers <- structure(as.integer(workers), 
[16:12:28.026]                       class = class(workers))
[16:12:28.026]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.026]                       workers >= 1)
[16:12:28.026]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.026]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.026]                     }
[16:12:28.026]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.026]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.026]                       envir = envir)
[16:12:28.026]                     if (!future$lazy) 
[16:12:28.026]                       future <- run(future)
[16:12:28.026]                     invisible(future)
[16:12:28.026]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.026]                 }
[16:12:28.026]             }
[16:12:28.026]         }
[16:12:28.026]     })
[16:12:28.026]     if (TRUE) {
[16:12:28.026]         base::sink(type = "output", split = FALSE)
[16:12:28.026]         if (TRUE) {
[16:12:28.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.026]         }
[16:12:28.026]         else {
[16:12:28.026]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.026]         }
[16:12:28.026]         base::close(...future.stdout)
[16:12:28.026]         ...future.stdout <- NULL
[16:12:28.026]     }
[16:12:28.026]     ...future.result$conditions <- ...future.conditions
[16:12:28.026]     ...future.result$finished <- base::Sys.time()
[16:12:28.026]     ...future.result
[16:12:28.026] }
[16:12:28.100] MultisessionFuture started
[16:12:28.100] - Launch lazy future ... done
[16:12:28.100] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bafc628c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bb00d4718> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bafc628c8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bb00d4718> 
 $  : NULL
 $  : NULL
 $  : num 6
[16:12:28.106] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.106] - Validating connection of MultisessionFuture
[16:12:28.107] - received message: FutureResult
[16:12:28.107] - Received FutureResult
[16:12:28.107] - Erased future from FutureRegistry
[16:12:28.107] result() for ClusterFuture ...
[16:12:28.107] - result already collected: FutureResult
[16:12:28.107] result() for ClusterFuture ... done
[16:12:28.107] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:28.119] resolve() on list ...
[16:12:28.119]  recursive: 0
[16:12:28.120]  length: 6
[16:12:28.120]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:28.120] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.120] - nx: 6
[16:12:28.120] - relay: TRUE
[16:12:28.120] - stdout: TRUE
[16:12:28.120] - signal: TRUE
[16:12:28.120] - resignal: FALSE
[16:12:28.121] - force: TRUE
[16:12:28.121] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.121]  - until=2
[16:12:28.121]  - relaying element #2
[16:12:28.121] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.121] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.121]  length: 5 (resolved future 1)
[16:12:28.122] Future #2
[16:12:28.122] result() for ClusterFuture ...
[16:12:28.122] - result already collected: FutureResult
[16:12:28.122] result() for ClusterFuture ... done
[16:12:28.122] result() for ClusterFuture ...
[16:12:28.122] - result already collected: FutureResult
[16:12:28.122] result() for ClusterFuture ... done
[16:12:28.122] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:28.123] - nx: 6
[16:12:28.123] - relay: TRUE
[16:12:28.123] - stdout: TRUE
[16:12:28.123] - signal: TRUE
[16:12:28.123] - resignal: FALSE
[16:12:28.123] - force: TRUE
[16:12:28.123] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.123] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.123]  - until=2
[16:12:28.124]  - relaying element #2
[16:12:28.124] result() for ClusterFuture ...
[16:12:28.124] - result already collected: FutureResult
[16:12:28.124] result() for ClusterFuture ... done
[16:12:28.124] result() for ClusterFuture ...
[16:12:28.124] - result already collected: FutureResult
[16:12:28.124] result() for ClusterFuture ... done
[16:12:28.124] result() for ClusterFuture ...
[16:12:28.125] - result already collected: FutureResult
[16:12:28.125] result() for ClusterFuture ... done
[16:12:28.125] result() for ClusterFuture ...
[16:12:28.125] - result already collected: FutureResult
[16:12:28.125] result() for ClusterFuture ... done
[16:12:28.125] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.125] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.125] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:28.125]  length: 4 (resolved future 2)
[16:12:28.134] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.134] - Validating connection of MultisessionFuture
[16:12:28.134] - received message: FutureResult
[16:12:28.135] - Received FutureResult
[16:12:28.135] - Erased future from FutureRegistry
[16:12:28.135] result() for ClusterFuture ...
[16:12:28.135] - result already collected: FutureResult
[16:12:28.135] result() for ClusterFuture ... done
[16:12:28.135] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.135] Future #3
[16:12:28.135] result() for ClusterFuture ...
[16:12:28.135] - result already collected: FutureResult
[16:12:28.136] result() for ClusterFuture ... done
[16:12:28.136] result() for ClusterFuture ...
[16:12:28.136] - result already collected: FutureResult
[16:12:28.136] result() for ClusterFuture ... done
[16:12:28.136] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:28.136] - nx: 6
[16:12:28.136] - relay: TRUE
[16:12:28.136] - stdout: TRUE
[16:12:28.137] - signal: TRUE
[16:12:28.137] - resignal: FALSE
[16:12:28.137] - force: TRUE
[16:12:28.137] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.137] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.137]  - until=3
[16:12:28.137]  - relaying element #3
[16:12:28.137] result() for ClusterFuture ...
[16:12:28.137] - result already collected: FutureResult
[16:12:28.138] result() for ClusterFuture ... done
[16:12:28.138] result() for ClusterFuture ...
[16:12:28.138] - result already collected: FutureResult
[16:12:28.138] result() for ClusterFuture ... done
[16:12:28.138] result() for ClusterFuture ...
[16:12:28.138] - result already collected: FutureResult
[16:12:28.138] result() for ClusterFuture ... done
[16:12:28.138] result() for ClusterFuture ...
[16:12:28.139] - result already collected: FutureResult
[16:12:28.139] result() for ClusterFuture ... done
[16:12:28.139] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.139] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.139] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:28.139]  length: 3 (resolved future 3)
[16:12:28.139] signalConditionsASAP(NULL, pos=4) ...
[16:12:28.139] - nx: 6
[16:12:28.139] - relay: TRUE
[16:12:28.140] - stdout: TRUE
[16:12:28.140] - signal: TRUE
[16:12:28.140] - resignal: FALSE
[16:12:28.140] - force: TRUE
[16:12:28.140] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.140] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.140]  - until=5
[16:12:28.140]  - relaying element #5
[16:12:28.140] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:28.141] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.141] signalConditionsASAP(NULL, pos=4) ... done
[16:12:28.141]  length: 2 (resolved future 4)
[16:12:28.141] signalConditionsASAP(NULL, pos=5) ...
[16:12:28.141] - nx: 6
[16:12:28.141] - relay: TRUE
[16:12:28.141] - stdout: TRUE
[16:12:28.141] - signal: TRUE
[16:12:28.141] - resignal: FALSE
[16:12:28.142] - force: TRUE
[16:12:28.142] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:28.142] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.142]  - until=6
[16:12:28.142]  - relaying element #6
[16:12:28.142] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:28.142] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.142] signalConditionsASAP(NULL, pos=5) ... done
[16:12:28.142]  length: 1 (resolved future 5)
[16:12:28.143] signalConditionsASAP(numeric, pos=6) ...
[16:12:28.143] - nx: 6
[16:12:28.143] - relay: TRUE
[16:12:28.143] - stdout: TRUE
[16:12:28.143] - signal: TRUE
[16:12:28.143] - resignal: FALSE
[16:12:28.143] - force: TRUE
[16:12:28.143] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:28.143] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.144]  - until=6
[16:12:28.144] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.144] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.144] signalConditionsASAP(numeric, pos=6) ... done
[16:12:28.144]  length: 0 (resolved future 6)
[16:12:28.144] Relaying remaining futures
[16:12:28.144] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.144] - nx: 6
[16:12:28.144] - relay: TRUE
[16:12:28.145] - stdout: TRUE
[16:12:28.145] - signal: TRUE
[16:12:28.147] - resignal: FALSE
[16:12:28.147] - force: TRUE
[16:12:28.147] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.148] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:28.148] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.148] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.148] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.148] resolve() on list ... DONE
[16:12:28.148] result() for ClusterFuture ...
[16:12:28.148] - result already collected: FutureResult
[16:12:28.148] result() for ClusterFuture ... done
[16:12:28.148] result() for ClusterFuture ...
[16:12:28.149] - result already collected: FutureResult
[16:12:28.149] result() for ClusterFuture ... done
[16:12:28.149] result() for ClusterFuture ...
[16:12:28.149] - result already collected: FutureResult
[16:12:28.149] result() for ClusterFuture ... done
[16:12:28.149] result() for ClusterFuture ...
[16:12:28.149] - result already collected: FutureResult
[16:12:28.149] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[16:12:28.151] getGlobalsAndPackages() ...
[16:12:28.151] Searching for globals...
[16:12:28.152] 
[16:12:28.152] Searching for globals ... DONE
[16:12:28.152] - globals: [0] <none>
[16:12:28.152] getGlobalsAndPackages() ... DONE
[16:12:28.152] run() for ‘Future’ ...
[16:12:28.152] - state: ‘created’
[16:12:28.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.168]   - Field: ‘node’
[16:12:28.168]   - Field: ‘label’
[16:12:28.168]   - Field: ‘local’
[16:12:28.168]   - Field: ‘owner’
[16:12:28.168]   - Field: ‘envir’
[16:12:28.168]   - Field: ‘workers’
[16:12:28.168]   - Field: ‘packages’
[16:12:28.169]   - Field: ‘gc’
[16:12:28.169]   - Field: ‘conditions’
[16:12:28.169]   - Field: ‘persistent’
[16:12:28.169]   - Field: ‘expr’
[16:12:28.169]   - Field: ‘uuid’
[16:12:28.169]   - Field: ‘seed’
[16:12:28.169]   - Field: ‘version’
[16:12:28.169]   - Field: ‘result’
[16:12:28.169]   - Field: ‘asynchronous’
[16:12:28.169]   - Field: ‘calls’
[16:12:28.169]   - Field: ‘globals’
[16:12:28.170]   - Field: ‘stdout’
[16:12:28.170]   - Field: ‘earlySignal’
[16:12:28.170]   - Field: ‘lazy’
[16:12:28.170]   - Field: ‘state’
[16:12:28.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.170] - Launch lazy future ...
[16:12:28.170] Packages needed by the future expression (n = 0): <none>
[16:12:28.170] Packages needed by future strategies (n = 0): <none>
[16:12:28.171] {
[16:12:28.171]     {
[16:12:28.171]         {
[16:12:28.171]             ...future.startTime <- base::Sys.time()
[16:12:28.171]             {
[16:12:28.171]                 {
[16:12:28.171]                   {
[16:12:28.171]                     {
[16:12:28.171]                       base::local({
[16:12:28.171]                         has_future <- base::requireNamespace("future", 
[16:12:28.171]                           quietly = TRUE)
[16:12:28.171]                         if (has_future) {
[16:12:28.171]                           ns <- base::getNamespace("future")
[16:12:28.171]                           version <- ns[[".package"]][["version"]]
[16:12:28.171]                           if (is.null(version)) 
[16:12:28.171]                             version <- utils::packageVersion("future")
[16:12:28.171]                         }
[16:12:28.171]                         else {
[16:12:28.171]                           version <- NULL
[16:12:28.171]                         }
[16:12:28.171]                         if (!has_future || version < "1.8.0") {
[16:12:28.171]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.171]                             "", base::R.version$version.string), 
[16:12:28.171]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.171]                               "release", "version")], collapse = " "), 
[16:12:28.171]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.171]                             info)
[16:12:28.171]                           info <- base::paste(info, collapse = "; ")
[16:12:28.171]                           if (!has_future) {
[16:12:28.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.171]                               info)
[16:12:28.171]                           }
[16:12:28.171]                           else {
[16:12:28.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.171]                               info, version)
[16:12:28.171]                           }
[16:12:28.171]                           base::stop(msg)
[16:12:28.171]                         }
[16:12:28.171]                       })
[16:12:28.171]                     }
[16:12:28.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.171]                     base::options(mc.cores = 1L)
[16:12:28.171]                   }
[16:12:28.171]                   options(future.plan = NULL)
[16:12:28.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.171]                 }
[16:12:28.171]                 ...future.workdir <- getwd()
[16:12:28.171]             }
[16:12:28.171]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.171]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.171]         }
[16:12:28.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.171]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.171]             base::names(...future.oldOptions))
[16:12:28.171]     }
[16:12:28.171]     if (FALSE) {
[16:12:28.171]     }
[16:12:28.171]     else {
[16:12:28.171]         if (TRUE) {
[16:12:28.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.171]                 open = "w")
[16:12:28.171]         }
[16:12:28.171]         else {
[16:12:28.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.171]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.171]         }
[16:12:28.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.171]             base::sink(type = "output", split = FALSE)
[16:12:28.171]             base::close(...future.stdout)
[16:12:28.171]         }, add = TRUE)
[16:12:28.171]     }
[16:12:28.171]     ...future.frame <- base::sys.nframe()
[16:12:28.171]     ...future.conditions <- base::list()
[16:12:28.171]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.171]     if (FALSE) {
[16:12:28.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.171]     }
[16:12:28.171]     ...future.result <- base::tryCatch({
[16:12:28.171]         base::withCallingHandlers({
[16:12:28.171]             ...future.value <- base::withVisible(base::local({
[16:12:28.171]                 ...future.makeSendCondition <- local({
[16:12:28.171]                   sendCondition <- NULL
[16:12:28.171]                   function(frame = 1L) {
[16:12:28.171]                     if (is.function(sendCondition)) 
[16:12:28.171]                       return(sendCondition)
[16:12:28.171]                     ns <- getNamespace("parallel")
[16:12:28.171]                     if (exists("sendData", mode = "function", 
[16:12:28.171]                       envir = ns)) {
[16:12:28.171]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.171]                         envir = ns)
[16:12:28.171]                       envir <- sys.frame(frame)
[16:12:28.171]                       master <- NULL
[16:12:28.171]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.171]                         !identical(envir, emptyenv())) {
[16:12:28.171]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.171]                           inherits = FALSE)) {
[16:12:28.171]                           master <- get("master", mode = "list", 
[16:12:28.171]                             envir = envir, inherits = FALSE)
[16:12:28.171]                           if (inherits(master, c("SOCKnode", 
[16:12:28.171]                             "SOCK0node"))) {
[16:12:28.171]                             sendCondition <<- function(cond) {
[16:12:28.171]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.171]                                 success = TRUE)
[16:12:28.171]                               parallel_sendData(master, data)
[16:12:28.171]                             }
[16:12:28.171]                             return(sendCondition)
[16:12:28.171]                           }
[16:12:28.171]                         }
[16:12:28.171]                         frame <- frame + 1L
[16:12:28.171]                         envir <- sys.frame(frame)
[16:12:28.171]                       }
[16:12:28.171]                     }
[16:12:28.171]                     sendCondition <<- function(cond) NULL
[16:12:28.171]                   }
[16:12:28.171]                 })
[16:12:28.171]                 withCallingHandlers({
[16:12:28.171]                   2
[16:12:28.171]                 }, immediateCondition = function(cond) {
[16:12:28.171]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.171]                   sendCondition(cond)
[16:12:28.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.171]                   {
[16:12:28.171]                     inherits <- base::inherits
[16:12:28.171]                     invokeRestart <- base::invokeRestart
[16:12:28.171]                     is.null <- base::is.null
[16:12:28.171]                     muffled <- FALSE
[16:12:28.171]                     if (inherits(cond, "message")) {
[16:12:28.171]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.171]                       if (muffled) 
[16:12:28.171]                         invokeRestart("muffleMessage")
[16:12:28.171]                     }
[16:12:28.171]                     else if (inherits(cond, "warning")) {
[16:12:28.171]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.171]                       if (muffled) 
[16:12:28.171]                         invokeRestart("muffleWarning")
[16:12:28.171]                     }
[16:12:28.171]                     else if (inherits(cond, "condition")) {
[16:12:28.171]                       if (!is.null(pattern)) {
[16:12:28.171]                         computeRestarts <- base::computeRestarts
[16:12:28.171]                         grepl <- base::grepl
[16:12:28.171]                         restarts <- computeRestarts(cond)
[16:12:28.171]                         for (restart in restarts) {
[16:12:28.171]                           name <- restart$name
[16:12:28.171]                           if (is.null(name)) 
[16:12:28.171]                             next
[16:12:28.171]                           if (!grepl(pattern, name)) 
[16:12:28.171]                             next
[16:12:28.171]                           invokeRestart(restart)
[16:12:28.171]                           muffled <- TRUE
[16:12:28.171]                           break
[16:12:28.171]                         }
[16:12:28.171]                       }
[16:12:28.171]                     }
[16:12:28.171]                     invisible(muffled)
[16:12:28.171]                   }
[16:12:28.171]                   muffleCondition(cond)
[16:12:28.171]                 })
[16:12:28.171]             }))
[16:12:28.171]             future::FutureResult(value = ...future.value$value, 
[16:12:28.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.171]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.171]                     ...future.globalenv.names))
[16:12:28.171]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.171]         }, condition = base::local({
[16:12:28.171]             c <- base::c
[16:12:28.171]             inherits <- base::inherits
[16:12:28.171]             invokeRestart <- base::invokeRestart
[16:12:28.171]             length <- base::length
[16:12:28.171]             list <- base::list
[16:12:28.171]             seq.int <- base::seq.int
[16:12:28.171]             signalCondition <- base::signalCondition
[16:12:28.171]             sys.calls <- base::sys.calls
[16:12:28.171]             `[[` <- base::`[[`
[16:12:28.171]             `+` <- base::`+`
[16:12:28.171]             `<<-` <- base::`<<-`
[16:12:28.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.171]                   3L)]
[16:12:28.171]             }
[16:12:28.171]             function(cond) {
[16:12:28.171]                 is_error <- inherits(cond, "error")
[16:12:28.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.171]                   NULL)
[16:12:28.171]                 if (is_error) {
[16:12:28.171]                   sessionInformation <- function() {
[16:12:28.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.171]                       search = base::search(), system = base::Sys.info())
[16:12:28.171]                   }
[16:12:28.171]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.171]                     cond$call), session = sessionInformation(), 
[16:12:28.171]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.171]                   signalCondition(cond)
[16:12:28.171]                 }
[16:12:28.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.171]                 "immediateCondition"))) {
[16:12:28.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.171]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.171]                   if (TRUE && !signal) {
[16:12:28.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.171]                     {
[16:12:28.171]                       inherits <- base::inherits
[16:12:28.171]                       invokeRestart <- base::invokeRestart
[16:12:28.171]                       is.null <- base::is.null
[16:12:28.171]                       muffled <- FALSE
[16:12:28.171]                       if (inherits(cond, "message")) {
[16:12:28.171]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.171]                         if (muffled) 
[16:12:28.171]                           invokeRestart("muffleMessage")
[16:12:28.171]                       }
[16:12:28.171]                       else if (inherits(cond, "warning")) {
[16:12:28.171]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.171]                         if (muffled) 
[16:12:28.171]                           invokeRestart("muffleWarning")
[16:12:28.171]                       }
[16:12:28.171]                       else if (inherits(cond, "condition")) {
[16:12:28.171]                         if (!is.null(pattern)) {
[16:12:28.171]                           computeRestarts <- base::computeRestarts
[16:12:28.171]                           grepl <- base::grepl
[16:12:28.171]                           restarts <- computeRestarts(cond)
[16:12:28.171]                           for (restart in restarts) {
[16:12:28.171]                             name <- restart$name
[16:12:28.171]                             if (is.null(name)) 
[16:12:28.171]                               next
[16:12:28.171]                             if (!grepl(pattern, name)) 
[16:12:28.171]                               next
[16:12:28.171]                             invokeRestart(restart)
[16:12:28.171]                             muffled <- TRUE
[16:12:28.171]                             break
[16:12:28.171]                           }
[16:12:28.171]                         }
[16:12:28.171]                       }
[16:12:28.171]                       invisible(muffled)
[16:12:28.171]                     }
[16:12:28.171]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.171]                   }
[16:12:28.171]                 }
[16:12:28.171]                 else {
[16:12:28.171]                   if (TRUE) {
[16:12:28.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.171]                     {
[16:12:28.171]                       inherits <- base::inherits
[16:12:28.171]                       invokeRestart <- base::invokeRestart
[16:12:28.171]                       is.null <- base::is.null
[16:12:28.171]                       muffled <- FALSE
[16:12:28.171]                       if (inherits(cond, "message")) {
[16:12:28.171]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.171]                         if (muffled) 
[16:12:28.171]                           invokeRestart("muffleMessage")
[16:12:28.171]                       }
[16:12:28.171]                       else if (inherits(cond, "warning")) {
[16:12:28.171]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.171]                         if (muffled) 
[16:12:28.171]                           invokeRestart("muffleWarning")
[16:12:28.171]                       }
[16:12:28.171]                       else if (inherits(cond, "condition")) {
[16:12:28.171]                         if (!is.null(pattern)) {
[16:12:28.171]                           computeRestarts <- base::computeRestarts
[16:12:28.171]                           grepl <- base::grepl
[16:12:28.171]                           restarts <- computeRestarts(cond)
[16:12:28.171]                           for (restart in restarts) {
[16:12:28.171]                             name <- restart$name
[16:12:28.171]                             if (is.null(name)) 
[16:12:28.171]                               next
[16:12:28.171]                             if (!grepl(pattern, name)) 
[16:12:28.171]                               next
[16:12:28.171]                             invokeRestart(restart)
[16:12:28.171]                             muffled <- TRUE
[16:12:28.171]                             break
[16:12:28.171]                           }
[16:12:28.171]                         }
[16:12:28.171]                       }
[16:12:28.171]                       invisible(muffled)
[16:12:28.171]                     }
[16:12:28.171]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.171]                   }
[16:12:28.171]                 }
[16:12:28.171]             }
[16:12:28.171]         }))
[16:12:28.171]     }, error = function(ex) {
[16:12:28.171]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.171]                 ...future.rng), started = ...future.startTime, 
[16:12:28.171]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.171]             version = "1.8"), class = "FutureResult")
[16:12:28.171]     }, finally = {
[16:12:28.171]         if (!identical(...future.workdir, getwd())) 
[16:12:28.171]             setwd(...future.workdir)
[16:12:28.171]         {
[16:12:28.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.171]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.171]             }
[16:12:28.171]             base::options(...future.oldOptions)
[16:12:28.171]             if (.Platform$OS.type == "windows") {
[16:12:28.171]                 old_names <- names(...future.oldEnvVars)
[16:12:28.171]                 envs <- base::Sys.getenv()
[16:12:28.171]                 names <- names(envs)
[16:12:28.171]                 common <- intersect(names, old_names)
[16:12:28.171]                 added <- setdiff(names, old_names)
[16:12:28.171]                 removed <- setdiff(old_names, names)
[16:12:28.171]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.171]                   envs[common]]
[16:12:28.171]                 NAMES <- toupper(changed)
[16:12:28.171]                 args <- list()
[16:12:28.171]                 for (kk in seq_along(NAMES)) {
[16:12:28.171]                   name <- changed[[kk]]
[16:12:28.171]                   NAME <- NAMES[[kk]]
[16:12:28.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.171]                     next
[16:12:28.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.171]                 }
[16:12:28.171]                 NAMES <- toupper(added)
[16:12:28.171]                 for (kk in seq_along(NAMES)) {
[16:12:28.171]                   name <- added[[kk]]
[16:12:28.171]                   NAME <- NAMES[[kk]]
[16:12:28.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.171]                     next
[16:12:28.171]                   args[[name]] <- ""
[16:12:28.171]                 }
[16:12:28.171]                 NAMES <- toupper(removed)
[16:12:28.171]                 for (kk in seq_along(NAMES)) {
[16:12:28.171]                   name <- removed[[kk]]
[16:12:28.171]                   NAME <- NAMES[[kk]]
[16:12:28.171]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.171]                     next
[16:12:28.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.171]                 }
[16:12:28.171]                 if (length(args) > 0) 
[16:12:28.171]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.171]             }
[16:12:28.171]             else {
[16:12:28.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.171]             }
[16:12:28.171]             {
[16:12:28.171]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.171]                   0L) {
[16:12:28.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.171]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.171]                   base::options(opts)
[16:12:28.171]                 }
[16:12:28.171]                 {
[16:12:28.171]                   {
[16:12:28.171]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.171]                     NULL
[16:12:28.171]                   }
[16:12:28.171]                   options(future.plan = NULL)
[16:12:28.171]                   if (is.na(NA_character_)) 
[16:12:28.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.171]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.171]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.171]                     envir = parent.frame()) 
[16:12:28.171]                   {
[16:12:28.171]                     if (is.function(workers)) 
[16:12:28.171]                       workers <- workers()
[16:12:28.171]                     workers <- structure(as.integer(workers), 
[16:12:28.171]                       class = class(workers))
[16:12:28.171]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.171]                       workers >= 1)
[16:12:28.171]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.171]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.171]                     }
[16:12:28.171]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.171]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.171]                       envir = envir)
[16:12:28.171]                     if (!future$lazy) 
[16:12:28.171]                       future <- run(future)
[16:12:28.171]                     invisible(future)
[16:12:28.171]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.171]                 }
[16:12:28.171]             }
[16:12:28.171]         }
[16:12:28.171]     })
[16:12:28.171]     if (TRUE) {
[16:12:28.171]         base::sink(type = "output", split = FALSE)
[16:12:28.171]         if (TRUE) {
[16:12:28.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.171]         }
[16:12:28.171]         else {
[16:12:28.171]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.171]         }
[16:12:28.171]         base::close(...future.stdout)
[16:12:28.171]         ...future.stdout <- NULL
[16:12:28.171]     }
[16:12:28.171]     ...future.result$conditions <- ...future.conditions
[16:12:28.171]     ...future.result$finished <- base::Sys.time()
[16:12:28.171]     ...future.result
[16:12:28.171] }
[16:12:28.174] MultisessionFuture started
[16:12:28.174] - Launch lazy future ... done
[16:12:28.174] run() for ‘MultisessionFuture’ ... done
[16:12:28.175] getGlobalsAndPackages() ...
[16:12:28.175] Searching for globals...
[16:12:28.175] 
[16:12:28.175] Searching for globals ... DONE
[16:12:28.175] - globals: [0] <none>
[16:12:28.175] getGlobalsAndPackages() ... DONE
[16:12:28.176] run() for ‘Future’ ...
[16:12:28.176] - state: ‘created’
[16:12:28.176] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.191] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.191]   - Field: ‘node’
[16:12:28.191]   - Field: ‘label’
[16:12:28.191]   - Field: ‘local’
[16:12:28.191]   - Field: ‘owner’
[16:12:28.191]   - Field: ‘envir’
[16:12:28.191]   - Field: ‘workers’
[16:12:28.191]   - Field: ‘packages’
[16:12:28.192]   - Field: ‘gc’
[16:12:28.192]   - Field: ‘conditions’
[16:12:28.192]   - Field: ‘persistent’
[16:12:28.192]   - Field: ‘expr’
[16:12:28.192]   - Field: ‘uuid’
[16:12:28.192]   - Field: ‘seed’
[16:12:28.192]   - Field: ‘version’
[16:12:28.192]   - Field: ‘result’
[16:12:28.192]   - Field: ‘asynchronous’
[16:12:28.192]   - Field: ‘calls’
[16:12:28.193]   - Field: ‘globals’
[16:12:28.193]   - Field: ‘stdout’
[16:12:28.193]   - Field: ‘earlySignal’
[16:12:28.193]   - Field: ‘lazy’
[16:12:28.193]   - Field: ‘state’
[16:12:28.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.193] - Launch lazy future ...
[16:12:28.193] Packages needed by the future expression (n = 0): <none>
[16:12:28.194] Packages needed by future strategies (n = 0): <none>
[16:12:28.194] {
[16:12:28.194]     {
[16:12:28.194]         {
[16:12:28.194]             ...future.startTime <- base::Sys.time()
[16:12:28.194]             {
[16:12:28.194]                 {
[16:12:28.194]                   {
[16:12:28.194]                     {
[16:12:28.194]                       base::local({
[16:12:28.194]                         has_future <- base::requireNamespace("future", 
[16:12:28.194]                           quietly = TRUE)
[16:12:28.194]                         if (has_future) {
[16:12:28.194]                           ns <- base::getNamespace("future")
[16:12:28.194]                           version <- ns[[".package"]][["version"]]
[16:12:28.194]                           if (is.null(version)) 
[16:12:28.194]                             version <- utils::packageVersion("future")
[16:12:28.194]                         }
[16:12:28.194]                         else {
[16:12:28.194]                           version <- NULL
[16:12:28.194]                         }
[16:12:28.194]                         if (!has_future || version < "1.8.0") {
[16:12:28.194]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.194]                             "", base::R.version$version.string), 
[16:12:28.194]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.194]                               "release", "version")], collapse = " "), 
[16:12:28.194]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.194]                             info)
[16:12:28.194]                           info <- base::paste(info, collapse = "; ")
[16:12:28.194]                           if (!has_future) {
[16:12:28.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.194]                               info)
[16:12:28.194]                           }
[16:12:28.194]                           else {
[16:12:28.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.194]                               info, version)
[16:12:28.194]                           }
[16:12:28.194]                           base::stop(msg)
[16:12:28.194]                         }
[16:12:28.194]                       })
[16:12:28.194]                     }
[16:12:28.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.194]                     base::options(mc.cores = 1L)
[16:12:28.194]                   }
[16:12:28.194]                   options(future.plan = NULL)
[16:12:28.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.194]                 }
[16:12:28.194]                 ...future.workdir <- getwd()
[16:12:28.194]             }
[16:12:28.194]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.194]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.194]         }
[16:12:28.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.194]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.194]             base::names(...future.oldOptions))
[16:12:28.194]     }
[16:12:28.194]     if (FALSE) {
[16:12:28.194]     }
[16:12:28.194]     else {
[16:12:28.194]         if (TRUE) {
[16:12:28.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.194]                 open = "w")
[16:12:28.194]         }
[16:12:28.194]         else {
[16:12:28.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.194]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.194]         }
[16:12:28.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.194]             base::sink(type = "output", split = FALSE)
[16:12:28.194]             base::close(...future.stdout)
[16:12:28.194]         }, add = TRUE)
[16:12:28.194]     }
[16:12:28.194]     ...future.frame <- base::sys.nframe()
[16:12:28.194]     ...future.conditions <- base::list()
[16:12:28.194]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.194]     if (FALSE) {
[16:12:28.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.194]     }
[16:12:28.194]     ...future.result <- base::tryCatch({
[16:12:28.194]         base::withCallingHandlers({
[16:12:28.194]             ...future.value <- base::withVisible(base::local({
[16:12:28.194]                 ...future.makeSendCondition <- local({
[16:12:28.194]                   sendCondition <- NULL
[16:12:28.194]                   function(frame = 1L) {
[16:12:28.194]                     if (is.function(sendCondition)) 
[16:12:28.194]                       return(sendCondition)
[16:12:28.194]                     ns <- getNamespace("parallel")
[16:12:28.194]                     if (exists("sendData", mode = "function", 
[16:12:28.194]                       envir = ns)) {
[16:12:28.194]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.194]                         envir = ns)
[16:12:28.194]                       envir <- sys.frame(frame)
[16:12:28.194]                       master <- NULL
[16:12:28.194]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.194]                         !identical(envir, emptyenv())) {
[16:12:28.194]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.194]                           inherits = FALSE)) {
[16:12:28.194]                           master <- get("master", mode = "list", 
[16:12:28.194]                             envir = envir, inherits = FALSE)
[16:12:28.194]                           if (inherits(master, c("SOCKnode", 
[16:12:28.194]                             "SOCK0node"))) {
[16:12:28.194]                             sendCondition <<- function(cond) {
[16:12:28.194]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.194]                                 success = TRUE)
[16:12:28.194]                               parallel_sendData(master, data)
[16:12:28.194]                             }
[16:12:28.194]                             return(sendCondition)
[16:12:28.194]                           }
[16:12:28.194]                         }
[16:12:28.194]                         frame <- frame + 1L
[16:12:28.194]                         envir <- sys.frame(frame)
[16:12:28.194]                       }
[16:12:28.194]                     }
[16:12:28.194]                     sendCondition <<- function(cond) NULL
[16:12:28.194]                   }
[16:12:28.194]                 })
[16:12:28.194]                 withCallingHandlers({
[16:12:28.194]                   NULL
[16:12:28.194]                 }, immediateCondition = function(cond) {
[16:12:28.194]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.194]                   sendCondition(cond)
[16:12:28.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.194]                   {
[16:12:28.194]                     inherits <- base::inherits
[16:12:28.194]                     invokeRestart <- base::invokeRestart
[16:12:28.194]                     is.null <- base::is.null
[16:12:28.194]                     muffled <- FALSE
[16:12:28.194]                     if (inherits(cond, "message")) {
[16:12:28.194]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.194]                       if (muffled) 
[16:12:28.194]                         invokeRestart("muffleMessage")
[16:12:28.194]                     }
[16:12:28.194]                     else if (inherits(cond, "warning")) {
[16:12:28.194]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.194]                       if (muffled) 
[16:12:28.194]                         invokeRestart("muffleWarning")
[16:12:28.194]                     }
[16:12:28.194]                     else if (inherits(cond, "condition")) {
[16:12:28.194]                       if (!is.null(pattern)) {
[16:12:28.194]                         computeRestarts <- base::computeRestarts
[16:12:28.194]                         grepl <- base::grepl
[16:12:28.194]                         restarts <- computeRestarts(cond)
[16:12:28.194]                         for (restart in restarts) {
[16:12:28.194]                           name <- restart$name
[16:12:28.194]                           if (is.null(name)) 
[16:12:28.194]                             next
[16:12:28.194]                           if (!grepl(pattern, name)) 
[16:12:28.194]                             next
[16:12:28.194]                           invokeRestart(restart)
[16:12:28.194]                           muffled <- TRUE
[16:12:28.194]                           break
[16:12:28.194]                         }
[16:12:28.194]                       }
[16:12:28.194]                     }
[16:12:28.194]                     invisible(muffled)
[16:12:28.194]                   }
[16:12:28.194]                   muffleCondition(cond)
[16:12:28.194]                 })
[16:12:28.194]             }))
[16:12:28.194]             future::FutureResult(value = ...future.value$value, 
[16:12:28.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.194]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.194]                     ...future.globalenv.names))
[16:12:28.194]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.194]         }, condition = base::local({
[16:12:28.194]             c <- base::c
[16:12:28.194]             inherits <- base::inherits
[16:12:28.194]             invokeRestart <- base::invokeRestart
[16:12:28.194]             length <- base::length
[16:12:28.194]             list <- base::list
[16:12:28.194]             seq.int <- base::seq.int
[16:12:28.194]             signalCondition <- base::signalCondition
[16:12:28.194]             sys.calls <- base::sys.calls
[16:12:28.194]             `[[` <- base::`[[`
[16:12:28.194]             `+` <- base::`+`
[16:12:28.194]             `<<-` <- base::`<<-`
[16:12:28.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.194]                   3L)]
[16:12:28.194]             }
[16:12:28.194]             function(cond) {
[16:12:28.194]                 is_error <- inherits(cond, "error")
[16:12:28.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.194]                   NULL)
[16:12:28.194]                 if (is_error) {
[16:12:28.194]                   sessionInformation <- function() {
[16:12:28.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.194]                       search = base::search(), system = base::Sys.info())
[16:12:28.194]                   }
[16:12:28.194]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.194]                     cond$call), session = sessionInformation(), 
[16:12:28.194]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.194]                   signalCondition(cond)
[16:12:28.194]                 }
[16:12:28.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.194]                 "immediateCondition"))) {
[16:12:28.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.194]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.194]                   if (TRUE && !signal) {
[16:12:28.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.194]                     {
[16:12:28.194]                       inherits <- base::inherits
[16:12:28.194]                       invokeRestart <- base::invokeRestart
[16:12:28.194]                       is.null <- base::is.null
[16:12:28.194]                       muffled <- FALSE
[16:12:28.194]                       if (inherits(cond, "message")) {
[16:12:28.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.194]                         if (muffled) 
[16:12:28.194]                           invokeRestart("muffleMessage")
[16:12:28.194]                       }
[16:12:28.194]                       else if (inherits(cond, "warning")) {
[16:12:28.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.194]                         if (muffled) 
[16:12:28.194]                           invokeRestart("muffleWarning")
[16:12:28.194]                       }
[16:12:28.194]                       else if (inherits(cond, "condition")) {
[16:12:28.194]                         if (!is.null(pattern)) {
[16:12:28.194]                           computeRestarts <- base::computeRestarts
[16:12:28.194]                           grepl <- base::grepl
[16:12:28.194]                           restarts <- computeRestarts(cond)
[16:12:28.194]                           for (restart in restarts) {
[16:12:28.194]                             name <- restart$name
[16:12:28.194]                             if (is.null(name)) 
[16:12:28.194]                               next
[16:12:28.194]                             if (!grepl(pattern, name)) 
[16:12:28.194]                               next
[16:12:28.194]                             invokeRestart(restart)
[16:12:28.194]                             muffled <- TRUE
[16:12:28.194]                             break
[16:12:28.194]                           }
[16:12:28.194]                         }
[16:12:28.194]                       }
[16:12:28.194]                       invisible(muffled)
[16:12:28.194]                     }
[16:12:28.194]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.194]                   }
[16:12:28.194]                 }
[16:12:28.194]                 else {
[16:12:28.194]                   if (TRUE) {
[16:12:28.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.194]                     {
[16:12:28.194]                       inherits <- base::inherits
[16:12:28.194]                       invokeRestart <- base::invokeRestart
[16:12:28.194]                       is.null <- base::is.null
[16:12:28.194]                       muffled <- FALSE
[16:12:28.194]                       if (inherits(cond, "message")) {
[16:12:28.194]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.194]                         if (muffled) 
[16:12:28.194]                           invokeRestart("muffleMessage")
[16:12:28.194]                       }
[16:12:28.194]                       else if (inherits(cond, "warning")) {
[16:12:28.194]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.194]                         if (muffled) 
[16:12:28.194]                           invokeRestart("muffleWarning")
[16:12:28.194]                       }
[16:12:28.194]                       else if (inherits(cond, "condition")) {
[16:12:28.194]                         if (!is.null(pattern)) {
[16:12:28.194]                           computeRestarts <- base::computeRestarts
[16:12:28.194]                           grepl <- base::grepl
[16:12:28.194]                           restarts <- computeRestarts(cond)
[16:12:28.194]                           for (restart in restarts) {
[16:12:28.194]                             name <- restart$name
[16:12:28.194]                             if (is.null(name)) 
[16:12:28.194]                               next
[16:12:28.194]                             if (!grepl(pattern, name)) 
[16:12:28.194]                               next
[16:12:28.194]                             invokeRestart(restart)
[16:12:28.194]                             muffled <- TRUE
[16:12:28.194]                             break
[16:12:28.194]                           }
[16:12:28.194]                         }
[16:12:28.194]                       }
[16:12:28.194]                       invisible(muffled)
[16:12:28.194]                     }
[16:12:28.194]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.194]                   }
[16:12:28.194]                 }
[16:12:28.194]             }
[16:12:28.194]         }))
[16:12:28.194]     }, error = function(ex) {
[16:12:28.194]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.194]                 ...future.rng), started = ...future.startTime, 
[16:12:28.194]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.194]             version = "1.8"), class = "FutureResult")
[16:12:28.194]     }, finally = {
[16:12:28.194]         if (!identical(...future.workdir, getwd())) 
[16:12:28.194]             setwd(...future.workdir)
[16:12:28.194]         {
[16:12:28.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.194]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.194]             }
[16:12:28.194]             base::options(...future.oldOptions)
[16:12:28.194]             if (.Platform$OS.type == "windows") {
[16:12:28.194]                 old_names <- names(...future.oldEnvVars)
[16:12:28.194]                 envs <- base::Sys.getenv()
[16:12:28.194]                 names <- names(envs)
[16:12:28.194]                 common <- intersect(names, old_names)
[16:12:28.194]                 added <- setdiff(names, old_names)
[16:12:28.194]                 removed <- setdiff(old_names, names)
[16:12:28.194]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.194]                   envs[common]]
[16:12:28.194]                 NAMES <- toupper(changed)
[16:12:28.194]                 args <- list()
[16:12:28.194]                 for (kk in seq_along(NAMES)) {
[16:12:28.194]                   name <- changed[[kk]]
[16:12:28.194]                   NAME <- NAMES[[kk]]
[16:12:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.194]                     next
[16:12:28.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.194]                 }
[16:12:28.194]                 NAMES <- toupper(added)
[16:12:28.194]                 for (kk in seq_along(NAMES)) {
[16:12:28.194]                   name <- added[[kk]]
[16:12:28.194]                   NAME <- NAMES[[kk]]
[16:12:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.194]                     next
[16:12:28.194]                   args[[name]] <- ""
[16:12:28.194]                 }
[16:12:28.194]                 NAMES <- toupper(removed)
[16:12:28.194]                 for (kk in seq_along(NAMES)) {
[16:12:28.194]                   name <- removed[[kk]]
[16:12:28.194]                   NAME <- NAMES[[kk]]
[16:12:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.194]                     next
[16:12:28.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.194]                 }
[16:12:28.194]                 if (length(args) > 0) 
[16:12:28.194]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.194]             }
[16:12:28.194]             else {
[16:12:28.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.194]             }
[16:12:28.194]             {
[16:12:28.194]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.194]                   0L) {
[16:12:28.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.194]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.194]                   base::options(opts)
[16:12:28.194]                 }
[16:12:28.194]                 {
[16:12:28.194]                   {
[16:12:28.194]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.194]                     NULL
[16:12:28.194]                   }
[16:12:28.194]                   options(future.plan = NULL)
[16:12:28.194]                   if (is.na(NA_character_)) 
[16:12:28.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.194]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.194]                     envir = parent.frame()) 
[16:12:28.194]                   {
[16:12:28.194]                     if (is.function(workers)) 
[16:12:28.194]                       workers <- workers()
[16:12:28.194]                     workers <- structure(as.integer(workers), 
[16:12:28.194]                       class = class(workers))
[16:12:28.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.194]                       workers >= 1)
[16:12:28.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.194]                     }
[16:12:28.194]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.194]                       envir = envir)
[16:12:28.194]                     if (!future$lazy) 
[16:12:28.194]                       future <- run(future)
[16:12:28.194]                     invisible(future)
[16:12:28.194]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.194]                 }
[16:12:28.194]             }
[16:12:28.194]         }
[16:12:28.194]     })
[16:12:28.194]     if (TRUE) {
[16:12:28.194]         base::sink(type = "output", split = FALSE)
[16:12:28.194]         if (TRUE) {
[16:12:28.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.194]         }
[16:12:28.194]         else {
[16:12:28.194]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.194]         }
[16:12:28.194]         base::close(...future.stdout)
[16:12:28.194]         ...future.stdout <- NULL
[16:12:28.194]     }
[16:12:28.194]     ...future.result$conditions <- ...future.conditions
[16:12:28.194]     ...future.result$finished <- base::Sys.time()
[16:12:28.194]     ...future.result
[16:12:28.194] }
[16:12:28.197] MultisessionFuture started
[16:12:28.197] - Launch lazy future ... done
[16:12:28.197] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baef96ae0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae9ba978> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baef96ae0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bae9ba978> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:28.225] resolve() on list ...
[16:12:28.226]  recursive: 0
[16:12:28.226]  length: 6
[16:12:28.226]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:28.226] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.226] - nx: 6
[16:12:28.226] - relay: TRUE
[16:12:28.226] - stdout: TRUE
[16:12:28.226] - signal: TRUE
[16:12:28.226] - resignal: FALSE
[16:12:28.226] - force: TRUE
[16:12:28.226] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.227] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.227]  - until=2
[16:12:28.227]  - relaying element #2
[16:12:28.227] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.227] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.227] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.227]  length: 5 (resolved future 1)
[16:12:28.228] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.228] - Validating connection of MultisessionFuture
[16:12:28.228] - received message: FutureResult
[16:12:28.228] - Received FutureResult
[16:12:28.228] - Erased future from FutureRegistry
[16:12:28.228] result() for ClusterFuture ...
[16:12:28.228] - result already collected: FutureResult
[16:12:28.228] result() for ClusterFuture ... done
[16:12:28.229] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.229] Future #2
[16:12:28.229] result() for ClusterFuture ...
[16:12:28.229] - result already collected: FutureResult
[16:12:28.229] result() for ClusterFuture ... done
[16:12:28.229] result() for ClusterFuture ...
[16:12:28.229] - result already collected: FutureResult
[16:12:28.229] result() for ClusterFuture ... done
[16:12:28.229] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:28.229] - nx: 6
[16:12:28.229] - relay: TRUE
[16:12:28.230] - stdout: TRUE
[16:12:28.230] - signal: TRUE
[16:12:28.230] - resignal: FALSE
[16:12:28.230] - force: TRUE
[16:12:28.230] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.230] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.230]  - until=2
[16:12:28.230]  - relaying element #2
[16:12:28.230] result() for ClusterFuture ...
[16:12:28.230] - result already collected: FutureResult
[16:12:28.230] result() for ClusterFuture ... done
[16:12:28.231] result() for ClusterFuture ...
[16:12:28.231] - result already collected: FutureResult
[16:12:28.231] result() for ClusterFuture ... done
[16:12:28.231] result() for ClusterFuture ...
[16:12:28.231] - result already collected: FutureResult
[16:12:28.231] result() for ClusterFuture ... done
[16:12:28.231] result() for ClusterFuture ...
[16:12:28.231] - result already collected: FutureResult
[16:12:28.231] result() for ClusterFuture ... done
[16:12:28.231] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.231] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.231] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:28.232]  length: 4 (resolved future 2)
[16:12:28.242] signalConditionsASAP(NULL, pos=4) ...
[16:12:28.242] - nx: 6
[16:12:28.243] - relay: TRUE
[16:12:28.243] - stdout: TRUE
[16:12:28.243] - signal: TRUE
[16:12:28.243] - resignal: FALSE
[16:12:28.243] - force: TRUE
[16:12:28.243] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.243] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.243]  - until=5
[16:12:28.243]  - relaying element #3
[16:12:28.244]  - relaying element #5
[16:12:28.244] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:12:28.244] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.244] signalConditionsASAP(NULL, pos=4) ... done
[16:12:28.244]  length: 3 (resolved future 4)
[16:12:28.244] signalConditionsASAP(NULL, pos=5) ...
[16:12:28.244] - nx: 6
[16:12:28.244] - relay: TRUE
[16:12:28.244] - stdout: TRUE
[16:12:28.244] - signal: TRUE
[16:12:28.245] - resignal: FALSE
[16:12:28.245] - force: TRUE
[16:12:28.245] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:12:28.245] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.245]  - until=6
[16:12:28.245]  - relaying element #3
[16:12:28.245]  - relaying element #6
[16:12:28.245] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:12:28.245] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.245] signalConditionsASAP(NULL, pos=5) ... done
[16:12:28.245]  length: 2 (resolved future 5)
[16:12:28.246] signalConditionsASAP(numeric, pos=6) ...
[16:12:28.246] - nx: 6
[16:12:28.246] - relay: TRUE
[16:12:28.246] - stdout: TRUE
[16:12:28.246] - signal: TRUE
[16:12:28.246] - resignal: FALSE
[16:12:28.246] - force: TRUE
[16:12:28.246] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:12:28.246] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.246]  - until=6
[16:12:28.246]  - relaying element #3
[16:12:28.246] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:12:28.247] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.247] signalConditionsASAP(NULL, pos=6) ... done
[16:12:28.247]  length: 1 (resolved future 6)
[16:12:28.257] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.257] - Validating connection of MultisessionFuture
[16:12:28.258] - received message: FutureResult
[16:12:28.258] - Received FutureResult
[16:12:28.258] - Erased future from FutureRegistry
[16:12:28.258] result() for ClusterFuture ...
[16:12:28.258] - result already collected: FutureResult
[16:12:28.258] result() for ClusterFuture ... done
[16:12:28.258] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.258] Future #3
[16:12:28.258] result() for ClusterFuture ...
[16:12:28.259] - result already collected: FutureResult
[16:12:28.259] result() for ClusterFuture ... done
[16:12:28.259] result() for ClusterFuture ...
[16:12:28.259] - result already collected: FutureResult
[16:12:28.259] result() for ClusterFuture ... done
[16:12:28.259] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:28.259] - nx: 6
[16:12:28.259] - relay: TRUE
[16:12:28.259] - stdout: TRUE
[16:12:28.259] - signal: TRUE
[16:12:28.259] - resignal: FALSE
[16:12:28.259] - force: TRUE
[16:12:28.260] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:12:28.260] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.260]  - until=6
[16:12:28.260]  - relaying element #3
[16:12:28.260] result() for ClusterFuture ...
[16:12:28.260] - result already collected: FutureResult
[16:12:28.260] result() for ClusterFuture ... done
[16:12:28.260] result() for ClusterFuture ...
[16:12:28.260] - result already collected: FutureResult
[16:12:28.260] result() for ClusterFuture ... done
[16:12:28.261] result() for ClusterFuture ...
[16:12:28.261] - result already collected: FutureResult
[16:12:28.261] result() for ClusterFuture ... done
[16:12:28.261] result() for ClusterFuture ...
[16:12:28.261] - result already collected: FutureResult
[16:12:28.261] result() for ClusterFuture ... done
[16:12:28.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.261] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.261] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:28.261]  length: 0 (resolved future 3)
[16:12:28.261] Relaying remaining futures
[16:12:28.262] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.262] - nx: 6
[16:12:28.262] - relay: TRUE
[16:12:28.262] - stdout: TRUE
[16:12:28.262] - signal: TRUE
[16:12:28.262] - resignal: FALSE
[16:12:28.262] - force: TRUE
[16:12:28.262] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:28.262] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.262] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.263] resolve() on list ... DONE
[16:12:28.263] result() for ClusterFuture ...
[16:12:28.263] - result already collected: FutureResult
[16:12:28.263] result() for ClusterFuture ... done
[16:12:28.263] result() for ClusterFuture ...
[16:12:28.263] - result already collected: FutureResult
[16:12:28.263] result() for ClusterFuture ... done
[16:12:28.263] result() for ClusterFuture ...
[16:12:28.263] - result already collected: FutureResult
[16:12:28.263] result() for ClusterFuture ... done
[16:12:28.263] result() for ClusterFuture ...
[16:12:28.264] - result already collected: FutureResult
[16:12:28.264] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:12:28.267] getGlobalsAndPackages() ...
[16:12:28.267] Searching for globals...
[16:12:28.267] 
[16:12:28.267] Searching for globals ... DONE
[16:12:28.268] - globals: [0] <none>
[16:12:28.268] getGlobalsAndPackages() ... DONE
[16:12:28.268] run() for ‘Future’ ...
[16:12:28.268] - state: ‘created’
[16:12:28.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.283]   - Field: ‘node’
[16:12:28.283]   - Field: ‘label’
[16:12:28.283]   - Field: ‘local’
[16:12:28.283]   - Field: ‘owner’
[16:12:28.283]   - Field: ‘envir’
[16:12:28.283]   - Field: ‘workers’
[16:12:28.283]   - Field: ‘packages’
[16:12:28.283]   - Field: ‘gc’
[16:12:28.284]   - Field: ‘conditions’
[16:12:28.284]   - Field: ‘persistent’
[16:12:28.284]   - Field: ‘expr’
[16:12:28.284]   - Field: ‘uuid’
[16:12:28.284]   - Field: ‘seed’
[16:12:28.284]   - Field: ‘version’
[16:12:28.284]   - Field: ‘result’
[16:12:28.284]   - Field: ‘asynchronous’
[16:12:28.284]   - Field: ‘calls’
[16:12:28.284]   - Field: ‘globals’
[16:12:28.284]   - Field: ‘stdout’
[16:12:28.285]   - Field: ‘earlySignal’
[16:12:28.285]   - Field: ‘lazy’
[16:12:28.285]   - Field: ‘state’
[16:12:28.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.285] - Launch lazy future ...
[16:12:28.285] Packages needed by the future expression (n = 0): <none>
[16:12:28.285] Packages needed by future strategies (n = 0): <none>
[16:12:28.286] {
[16:12:28.286]     {
[16:12:28.286]         {
[16:12:28.286]             ...future.startTime <- base::Sys.time()
[16:12:28.286]             {
[16:12:28.286]                 {
[16:12:28.286]                   {
[16:12:28.286]                     {
[16:12:28.286]                       base::local({
[16:12:28.286]                         has_future <- base::requireNamespace("future", 
[16:12:28.286]                           quietly = TRUE)
[16:12:28.286]                         if (has_future) {
[16:12:28.286]                           ns <- base::getNamespace("future")
[16:12:28.286]                           version <- ns[[".package"]][["version"]]
[16:12:28.286]                           if (is.null(version)) 
[16:12:28.286]                             version <- utils::packageVersion("future")
[16:12:28.286]                         }
[16:12:28.286]                         else {
[16:12:28.286]                           version <- NULL
[16:12:28.286]                         }
[16:12:28.286]                         if (!has_future || version < "1.8.0") {
[16:12:28.286]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.286]                             "", base::R.version$version.string), 
[16:12:28.286]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.286]                               "release", "version")], collapse = " "), 
[16:12:28.286]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.286]                             info)
[16:12:28.286]                           info <- base::paste(info, collapse = "; ")
[16:12:28.286]                           if (!has_future) {
[16:12:28.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.286]                               info)
[16:12:28.286]                           }
[16:12:28.286]                           else {
[16:12:28.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.286]                               info, version)
[16:12:28.286]                           }
[16:12:28.286]                           base::stop(msg)
[16:12:28.286]                         }
[16:12:28.286]                       })
[16:12:28.286]                     }
[16:12:28.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.286]                     base::options(mc.cores = 1L)
[16:12:28.286]                   }
[16:12:28.286]                   options(future.plan = NULL)
[16:12:28.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.286]                 }
[16:12:28.286]                 ...future.workdir <- getwd()
[16:12:28.286]             }
[16:12:28.286]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.286]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.286]         }
[16:12:28.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.286]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.286]             base::names(...future.oldOptions))
[16:12:28.286]     }
[16:12:28.286]     if (FALSE) {
[16:12:28.286]     }
[16:12:28.286]     else {
[16:12:28.286]         if (TRUE) {
[16:12:28.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.286]                 open = "w")
[16:12:28.286]         }
[16:12:28.286]         else {
[16:12:28.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.286]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.286]         }
[16:12:28.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.286]             base::sink(type = "output", split = FALSE)
[16:12:28.286]             base::close(...future.stdout)
[16:12:28.286]         }, add = TRUE)
[16:12:28.286]     }
[16:12:28.286]     ...future.frame <- base::sys.nframe()
[16:12:28.286]     ...future.conditions <- base::list()
[16:12:28.286]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.286]     if (FALSE) {
[16:12:28.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.286]     }
[16:12:28.286]     ...future.result <- base::tryCatch({
[16:12:28.286]         base::withCallingHandlers({
[16:12:28.286]             ...future.value <- base::withVisible(base::local({
[16:12:28.286]                 ...future.makeSendCondition <- local({
[16:12:28.286]                   sendCondition <- NULL
[16:12:28.286]                   function(frame = 1L) {
[16:12:28.286]                     if (is.function(sendCondition)) 
[16:12:28.286]                       return(sendCondition)
[16:12:28.286]                     ns <- getNamespace("parallel")
[16:12:28.286]                     if (exists("sendData", mode = "function", 
[16:12:28.286]                       envir = ns)) {
[16:12:28.286]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.286]                         envir = ns)
[16:12:28.286]                       envir <- sys.frame(frame)
[16:12:28.286]                       master <- NULL
[16:12:28.286]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.286]                         !identical(envir, emptyenv())) {
[16:12:28.286]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.286]                           inherits = FALSE)) {
[16:12:28.286]                           master <- get("master", mode = "list", 
[16:12:28.286]                             envir = envir, inherits = FALSE)
[16:12:28.286]                           if (inherits(master, c("SOCKnode", 
[16:12:28.286]                             "SOCK0node"))) {
[16:12:28.286]                             sendCondition <<- function(cond) {
[16:12:28.286]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.286]                                 success = TRUE)
[16:12:28.286]                               parallel_sendData(master, data)
[16:12:28.286]                             }
[16:12:28.286]                             return(sendCondition)
[16:12:28.286]                           }
[16:12:28.286]                         }
[16:12:28.286]                         frame <- frame + 1L
[16:12:28.286]                         envir <- sys.frame(frame)
[16:12:28.286]                       }
[16:12:28.286]                     }
[16:12:28.286]                     sendCondition <<- function(cond) NULL
[16:12:28.286]                   }
[16:12:28.286]                 })
[16:12:28.286]                 withCallingHandlers({
[16:12:28.286]                   2
[16:12:28.286]                 }, immediateCondition = function(cond) {
[16:12:28.286]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.286]                   sendCondition(cond)
[16:12:28.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.286]                   {
[16:12:28.286]                     inherits <- base::inherits
[16:12:28.286]                     invokeRestart <- base::invokeRestart
[16:12:28.286]                     is.null <- base::is.null
[16:12:28.286]                     muffled <- FALSE
[16:12:28.286]                     if (inherits(cond, "message")) {
[16:12:28.286]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.286]                       if (muffled) 
[16:12:28.286]                         invokeRestart("muffleMessage")
[16:12:28.286]                     }
[16:12:28.286]                     else if (inherits(cond, "warning")) {
[16:12:28.286]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.286]                       if (muffled) 
[16:12:28.286]                         invokeRestart("muffleWarning")
[16:12:28.286]                     }
[16:12:28.286]                     else if (inherits(cond, "condition")) {
[16:12:28.286]                       if (!is.null(pattern)) {
[16:12:28.286]                         computeRestarts <- base::computeRestarts
[16:12:28.286]                         grepl <- base::grepl
[16:12:28.286]                         restarts <- computeRestarts(cond)
[16:12:28.286]                         for (restart in restarts) {
[16:12:28.286]                           name <- restart$name
[16:12:28.286]                           if (is.null(name)) 
[16:12:28.286]                             next
[16:12:28.286]                           if (!grepl(pattern, name)) 
[16:12:28.286]                             next
[16:12:28.286]                           invokeRestart(restart)
[16:12:28.286]                           muffled <- TRUE
[16:12:28.286]                           break
[16:12:28.286]                         }
[16:12:28.286]                       }
[16:12:28.286]                     }
[16:12:28.286]                     invisible(muffled)
[16:12:28.286]                   }
[16:12:28.286]                   muffleCondition(cond)
[16:12:28.286]                 })
[16:12:28.286]             }))
[16:12:28.286]             future::FutureResult(value = ...future.value$value, 
[16:12:28.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.286]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.286]                     ...future.globalenv.names))
[16:12:28.286]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.286]         }, condition = base::local({
[16:12:28.286]             c <- base::c
[16:12:28.286]             inherits <- base::inherits
[16:12:28.286]             invokeRestart <- base::invokeRestart
[16:12:28.286]             length <- base::length
[16:12:28.286]             list <- base::list
[16:12:28.286]             seq.int <- base::seq.int
[16:12:28.286]             signalCondition <- base::signalCondition
[16:12:28.286]             sys.calls <- base::sys.calls
[16:12:28.286]             `[[` <- base::`[[`
[16:12:28.286]             `+` <- base::`+`
[16:12:28.286]             `<<-` <- base::`<<-`
[16:12:28.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.286]                   3L)]
[16:12:28.286]             }
[16:12:28.286]             function(cond) {
[16:12:28.286]                 is_error <- inherits(cond, "error")
[16:12:28.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.286]                   NULL)
[16:12:28.286]                 if (is_error) {
[16:12:28.286]                   sessionInformation <- function() {
[16:12:28.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.286]                       search = base::search(), system = base::Sys.info())
[16:12:28.286]                   }
[16:12:28.286]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.286]                     cond$call), session = sessionInformation(), 
[16:12:28.286]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.286]                   signalCondition(cond)
[16:12:28.286]                 }
[16:12:28.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.286]                 "immediateCondition"))) {
[16:12:28.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.286]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.286]                   if (TRUE && !signal) {
[16:12:28.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.286]                     {
[16:12:28.286]                       inherits <- base::inherits
[16:12:28.286]                       invokeRestart <- base::invokeRestart
[16:12:28.286]                       is.null <- base::is.null
[16:12:28.286]                       muffled <- FALSE
[16:12:28.286]                       if (inherits(cond, "message")) {
[16:12:28.286]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.286]                         if (muffled) 
[16:12:28.286]                           invokeRestart("muffleMessage")
[16:12:28.286]                       }
[16:12:28.286]                       else if (inherits(cond, "warning")) {
[16:12:28.286]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.286]                         if (muffled) 
[16:12:28.286]                           invokeRestart("muffleWarning")
[16:12:28.286]                       }
[16:12:28.286]                       else if (inherits(cond, "condition")) {
[16:12:28.286]                         if (!is.null(pattern)) {
[16:12:28.286]                           computeRestarts <- base::computeRestarts
[16:12:28.286]                           grepl <- base::grepl
[16:12:28.286]                           restarts <- computeRestarts(cond)
[16:12:28.286]                           for (restart in restarts) {
[16:12:28.286]                             name <- restart$name
[16:12:28.286]                             if (is.null(name)) 
[16:12:28.286]                               next
[16:12:28.286]                             if (!grepl(pattern, name)) 
[16:12:28.286]                               next
[16:12:28.286]                             invokeRestart(restart)
[16:12:28.286]                             muffled <- TRUE
[16:12:28.286]                             break
[16:12:28.286]                           }
[16:12:28.286]                         }
[16:12:28.286]                       }
[16:12:28.286]                       invisible(muffled)
[16:12:28.286]                     }
[16:12:28.286]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.286]                   }
[16:12:28.286]                 }
[16:12:28.286]                 else {
[16:12:28.286]                   if (TRUE) {
[16:12:28.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.286]                     {
[16:12:28.286]                       inherits <- base::inherits
[16:12:28.286]                       invokeRestart <- base::invokeRestart
[16:12:28.286]                       is.null <- base::is.null
[16:12:28.286]                       muffled <- FALSE
[16:12:28.286]                       if (inherits(cond, "message")) {
[16:12:28.286]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.286]                         if (muffled) 
[16:12:28.286]                           invokeRestart("muffleMessage")
[16:12:28.286]                       }
[16:12:28.286]                       else if (inherits(cond, "warning")) {
[16:12:28.286]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.286]                         if (muffled) 
[16:12:28.286]                           invokeRestart("muffleWarning")
[16:12:28.286]                       }
[16:12:28.286]                       else if (inherits(cond, "condition")) {
[16:12:28.286]                         if (!is.null(pattern)) {
[16:12:28.286]                           computeRestarts <- base::computeRestarts
[16:12:28.286]                           grepl <- base::grepl
[16:12:28.286]                           restarts <- computeRestarts(cond)
[16:12:28.286]                           for (restart in restarts) {
[16:12:28.286]                             name <- restart$name
[16:12:28.286]                             if (is.null(name)) 
[16:12:28.286]                               next
[16:12:28.286]                             if (!grepl(pattern, name)) 
[16:12:28.286]                               next
[16:12:28.286]                             invokeRestart(restart)
[16:12:28.286]                             muffled <- TRUE
[16:12:28.286]                             break
[16:12:28.286]                           }
[16:12:28.286]                         }
[16:12:28.286]                       }
[16:12:28.286]                       invisible(muffled)
[16:12:28.286]                     }
[16:12:28.286]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.286]                   }
[16:12:28.286]                 }
[16:12:28.286]             }
[16:12:28.286]         }))
[16:12:28.286]     }, error = function(ex) {
[16:12:28.286]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.286]                 ...future.rng), started = ...future.startTime, 
[16:12:28.286]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.286]             version = "1.8"), class = "FutureResult")
[16:12:28.286]     }, finally = {
[16:12:28.286]         if (!identical(...future.workdir, getwd())) 
[16:12:28.286]             setwd(...future.workdir)
[16:12:28.286]         {
[16:12:28.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.286]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.286]             }
[16:12:28.286]             base::options(...future.oldOptions)
[16:12:28.286]             if (.Platform$OS.type == "windows") {
[16:12:28.286]                 old_names <- names(...future.oldEnvVars)
[16:12:28.286]                 envs <- base::Sys.getenv()
[16:12:28.286]                 names <- names(envs)
[16:12:28.286]                 common <- intersect(names, old_names)
[16:12:28.286]                 added <- setdiff(names, old_names)
[16:12:28.286]                 removed <- setdiff(old_names, names)
[16:12:28.286]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.286]                   envs[common]]
[16:12:28.286]                 NAMES <- toupper(changed)
[16:12:28.286]                 args <- list()
[16:12:28.286]                 for (kk in seq_along(NAMES)) {
[16:12:28.286]                   name <- changed[[kk]]
[16:12:28.286]                   NAME <- NAMES[[kk]]
[16:12:28.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.286]                     next
[16:12:28.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.286]                 }
[16:12:28.286]                 NAMES <- toupper(added)
[16:12:28.286]                 for (kk in seq_along(NAMES)) {
[16:12:28.286]                   name <- added[[kk]]
[16:12:28.286]                   NAME <- NAMES[[kk]]
[16:12:28.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.286]                     next
[16:12:28.286]                   args[[name]] <- ""
[16:12:28.286]                 }
[16:12:28.286]                 NAMES <- toupper(removed)
[16:12:28.286]                 for (kk in seq_along(NAMES)) {
[16:12:28.286]                   name <- removed[[kk]]
[16:12:28.286]                   NAME <- NAMES[[kk]]
[16:12:28.286]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.286]                     next
[16:12:28.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.286]                 }
[16:12:28.286]                 if (length(args) > 0) 
[16:12:28.286]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.286]             }
[16:12:28.286]             else {
[16:12:28.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.286]             }
[16:12:28.286]             {
[16:12:28.286]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.286]                   0L) {
[16:12:28.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.286]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.286]                   base::options(opts)
[16:12:28.286]                 }
[16:12:28.286]                 {
[16:12:28.286]                   {
[16:12:28.286]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.286]                     NULL
[16:12:28.286]                   }
[16:12:28.286]                   options(future.plan = NULL)
[16:12:28.286]                   if (is.na(NA_character_)) 
[16:12:28.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.286]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.286]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.286]                     envir = parent.frame()) 
[16:12:28.286]                   {
[16:12:28.286]                     if (is.function(workers)) 
[16:12:28.286]                       workers <- workers()
[16:12:28.286]                     workers <- structure(as.integer(workers), 
[16:12:28.286]                       class = class(workers))
[16:12:28.286]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.286]                       workers >= 1)
[16:12:28.286]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.286]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.286]                     }
[16:12:28.286]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.286]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.286]                       envir = envir)
[16:12:28.286]                     if (!future$lazy) 
[16:12:28.286]                       future <- run(future)
[16:12:28.286]                     invisible(future)
[16:12:28.286]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.286]                 }
[16:12:28.286]             }
[16:12:28.286]         }
[16:12:28.286]     })
[16:12:28.286]     if (TRUE) {
[16:12:28.286]         base::sink(type = "output", split = FALSE)
[16:12:28.286]         if (TRUE) {
[16:12:28.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.286]         }
[16:12:28.286]         else {
[16:12:28.286]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.286]         }
[16:12:28.286]         base::close(...future.stdout)
[16:12:28.286]         ...future.stdout <- NULL
[16:12:28.286]     }
[16:12:28.286]     ...future.result$conditions <- ...future.conditions
[16:12:28.286]     ...future.result$finished <- base::Sys.time()
[16:12:28.286]     ...future.result
[16:12:28.286] }
[16:12:28.289] MultisessionFuture started
[16:12:28.289] - Launch lazy future ... done
[16:12:28.289] run() for ‘MultisessionFuture’ ... done
[16:12:28.289] getGlobalsAndPackages() ...
[16:12:28.290] Searching for globals...
[16:12:28.290] 
[16:12:28.290] Searching for globals ... DONE
[16:12:28.290] - globals: [0] <none>
[16:12:28.290] getGlobalsAndPackages() ... DONE
[16:12:28.290] run() for ‘Future’ ...
[16:12:28.290] - state: ‘created’
[16:12:28.291] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.305] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.305]   - Field: ‘node’
[16:12:28.305]   - Field: ‘label’
[16:12:28.305]   - Field: ‘local’
[16:12:28.306]   - Field: ‘owner’
[16:12:28.306]   - Field: ‘envir’
[16:12:28.306]   - Field: ‘workers’
[16:12:28.306]   - Field: ‘packages’
[16:12:28.306]   - Field: ‘gc’
[16:12:28.306]   - Field: ‘conditions’
[16:12:28.306]   - Field: ‘persistent’
[16:12:28.306]   - Field: ‘expr’
[16:12:28.306]   - Field: ‘uuid’
[16:12:28.306]   - Field: ‘seed’
[16:12:28.306]   - Field: ‘version’
[16:12:28.307]   - Field: ‘result’
[16:12:28.307]   - Field: ‘asynchronous’
[16:12:28.307]   - Field: ‘calls’
[16:12:28.307]   - Field: ‘globals’
[16:12:28.307]   - Field: ‘stdout’
[16:12:28.307]   - Field: ‘earlySignal’
[16:12:28.307]   - Field: ‘lazy’
[16:12:28.307]   - Field: ‘state’
[16:12:28.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.307] - Launch lazy future ...
[16:12:28.308] Packages needed by the future expression (n = 0): <none>
[16:12:28.308] Packages needed by future strategies (n = 0): <none>
[16:12:28.308] {
[16:12:28.308]     {
[16:12:28.308]         {
[16:12:28.308]             ...future.startTime <- base::Sys.time()
[16:12:28.308]             {
[16:12:28.308]                 {
[16:12:28.308]                   {
[16:12:28.308]                     {
[16:12:28.308]                       base::local({
[16:12:28.308]                         has_future <- base::requireNamespace("future", 
[16:12:28.308]                           quietly = TRUE)
[16:12:28.308]                         if (has_future) {
[16:12:28.308]                           ns <- base::getNamespace("future")
[16:12:28.308]                           version <- ns[[".package"]][["version"]]
[16:12:28.308]                           if (is.null(version)) 
[16:12:28.308]                             version <- utils::packageVersion("future")
[16:12:28.308]                         }
[16:12:28.308]                         else {
[16:12:28.308]                           version <- NULL
[16:12:28.308]                         }
[16:12:28.308]                         if (!has_future || version < "1.8.0") {
[16:12:28.308]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.308]                             "", base::R.version$version.string), 
[16:12:28.308]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.308]                               "release", "version")], collapse = " "), 
[16:12:28.308]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.308]                             info)
[16:12:28.308]                           info <- base::paste(info, collapse = "; ")
[16:12:28.308]                           if (!has_future) {
[16:12:28.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.308]                               info)
[16:12:28.308]                           }
[16:12:28.308]                           else {
[16:12:28.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.308]                               info, version)
[16:12:28.308]                           }
[16:12:28.308]                           base::stop(msg)
[16:12:28.308]                         }
[16:12:28.308]                       })
[16:12:28.308]                     }
[16:12:28.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.308]                     base::options(mc.cores = 1L)
[16:12:28.308]                   }
[16:12:28.308]                   options(future.plan = NULL)
[16:12:28.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.308]                 }
[16:12:28.308]                 ...future.workdir <- getwd()
[16:12:28.308]             }
[16:12:28.308]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.308]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.308]         }
[16:12:28.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.308]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.308]             base::names(...future.oldOptions))
[16:12:28.308]     }
[16:12:28.308]     if (FALSE) {
[16:12:28.308]     }
[16:12:28.308]     else {
[16:12:28.308]         if (TRUE) {
[16:12:28.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.308]                 open = "w")
[16:12:28.308]         }
[16:12:28.308]         else {
[16:12:28.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.308]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.308]         }
[16:12:28.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.308]             base::sink(type = "output", split = FALSE)
[16:12:28.308]             base::close(...future.stdout)
[16:12:28.308]         }, add = TRUE)
[16:12:28.308]     }
[16:12:28.308]     ...future.frame <- base::sys.nframe()
[16:12:28.308]     ...future.conditions <- base::list()
[16:12:28.308]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.308]     if (FALSE) {
[16:12:28.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.308]     }
[16:12:28.308]     ...future.result <- base::tryCatch({
[16:12:28.308]         base::withCallingHandlers({
[16:12:28.308]             ...future.value <- base::withVisible(base::local({
[16:12:28.308]                 ...future.makeSendCondition <- local({
[16:12:28.308]                   sendCondition <- NULL
[16:12:28.308]                   function(frame = 1L) {
[16:12:28.308]                     if (is.function(sendCondition)) 
[16:12:28.308]                       return(sendCondition)
[16:12:28.308]                     ns <- getNamespace("parallel")
[16:12:28.308]                     if (exists("sendData", mode = "function", 
[16:12:28.308]                       envir = ns)) {
[16:12:28.308]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.308]                         envir = ns)
[16:12:28.308]                       envir <- sys.frame(frame)
[16:12:28.308]                       master <- NULL
[16:12:28.308]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.308]                         !identical(envir, emptyenv())) {
[16:12:28.308]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.308]                           inherits = FALSE)) {
[16:12:28.308]                           master <- get("master", mode = "list", 
[16:12:28.308]                             envir = envir, inherits = FALSE)
[16:12:28.308]                           if (inherits(master, c("SOCKnode", 
[16:12:28.308]                             "SOCK0node"))) {
[16:12:28.308]                             sendCondition <<- function(cond) {
[16:12:28.308]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.308]                                 success = TRUE)
[16:12:28.308]                               parallel_sendData(master, data)
[16:12:28.308]                             }
[16:12:28.308]                             return(sendCondition)
[16:12:28.308]                           }
[16:12:28.308]                         }
[16:12:28.308]                         frame <- frame + 1L
[16:12:28.308]                         envir <- sys.frame(frame)
[16:12:28.308]                       }
[16:12:28.308]                     }
[16:12:28.308]                     sendCondition <<- function(cond) NULL
[16:12:28.308]                   }
[16:12:28.308]                 })
[16:12:28.308]                 withCallingHandlers({
[16:12:28.308]                   NULL
[16:12:28.308]                 }, immediateCondition = function(cond) {
[16:12:28.308]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.308]                   sendCondition(cond)
[16:12:28.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.308]                   {
[16:12:28.308]                     inherits <- base::inherits
[16:12:28.308]                     invokeRestart <- base::invokeRestart
[16:12:28.308]                     is.null <- base::is.null
[16:12:28.308]                     muffled <- FALSE
[16:12:28.308]                     if (inherits(cond, "message")) {
[16:12:28.308]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.308]                       if (muffled) 
[16:12:28.308]                         invokeRestart("muffleMessage")
[16:12:28.308]                     }
[16:12:28.308]                     else if (inherits(cond, "warning")) {
[16:12:28.308]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.308]                       if (muffled) 
[16:12:28.308]                         invokeRestart("muffleWarning")
[16:12:28.308]                     }
[16:12:28.308]                     else if (inherits(cond, "condition")) {
[16:12:28.308]                       if (!is.null(pattern)) {
[16:12:28.308]                         computeRestarts <- base::computeRestarts
[16:12:28.308]                         grepl <- base::grepl
[16:12:28.308]                         restarts <- computeRestarts(cond)
[16:12:28.308]                         for (restart in restarts) {
[16:12:28.308]                           name <- restart$name
[16:12:28.308]                           if (is.null(name)) 
[16:12:28.308]                             next
[16:12:28.308]                           if (!grepl(pattern, name)) 
[16:12:28.308]                             next
[16:12:28.308]                           invokeRestart(restart)
[16:12:28.308]                           muffled <- TRUE
[16:12:28.308]                           break
[16:12:28.308]                         }
[16:12:28.308]                       }
[16:12:28.308]                     }
[16:12:28.308]                     invisible(muffled)
[16:12:28.308]                   }
[16:12:28.308]                   muffleCondition(cond)
[16:12:28.308]                 })
[16:12:28.308]             }))
[16:12:28.308]             future::FutureResult(value = ...future.value$value, 
[16:12:28.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.308]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.308]                     ...future.globalenv.names))
[16:12:28.308]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.308]         }, condition = base::local({
[16:12:28.308]             c <- base::c
[16:12:28.308]             inherits <- base::inherits
[16:12:28.308]             invokeRestart <- base::invokeRestart
[16:12:28.308]             length <- base::length
[16:12:28.308]             list <- base::list
[16:12:28.308]             seq.int <- base::seq.int
[16:12:28.308]             signalCondition <- base::signalCondition
[16:12:28.308]             sys.calls <- base::sys.calls
[16:12:28.308]             `[[` <- base::`[[`
[16:12:28.308]             `+` <- base::`+`
[16:12:28.308]             `<<-` <- base::`<<-`
[16:12:28.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.308]                   3L)]
[16:12:28.308]             }
[16:12:28.308]             function(cond) {
[16:12:28.308]                 is_error <- inherits(cond, "error")
[16:12:28.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.308]                   NULL)
[16:12:28.308]                 if (is_error) {
[16:12:28.308]                   sessionInformation <- function() {
[16:12:28.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.308]                       search = base::search(), system = base::Sys.info())
[16:12:28.308]                   }
[16:12:28.308]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.308]                     cond$call), session = sessionInformation(), 
[16:12:28.308]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.308]                   signalCondition(cond)
[16:12:28.308]                 }
[16:12:28.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.308]                 "immediateCondition"))) {
[16:12:28.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.308]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.308]                   if (TRUE && !signal) {
[16:12:28.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.308]                     {
[16:12:28.308]                       inherits <- base::inherits
[16:12:28.308]                       invokeRestart <- base::invokeRestart
[16:12:28.308]                       is.null <- base::is.null
[16:12:28.308]                       muffled <- FALSE
[16:12:28.308]                       if (inherits(cond, "message")) {
[16:12:28.308]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.308]                         if (muffled) 
[16:12:28.308]                           invokeRestart("muffleMessage")
[16:12:28.308]                       }
[16:12:28.308]                       else if (inherits(cond, "warning")) {
[16:12:28.308]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.308]                         if (muffled) 
[16:12:28.308]                           invokeRestart("muffleWarning")
[16:12:28.308]                       }
[16:12:28.308]                       else if (inherits(cond, "condition")) {
[16:12:28.308]                         if (!is.null(pattern)) {
[16:12:28.308]                           computeRestarts <- base::computeRestarts
[16:12:28.308]                           grepl <- base::grepl
[16:12:28.308]                           restarts <- computeRestarts(cond)
[16:12:28.308]                           for (restart in restarts) {
[16:12:28.308]                             name <- restart$name
[16:12:28.308]                             if (is.null(name)) 
[16:12:28.308]                               next
[16:12:28.308]                             if (!grepl(pattern, name)) 
[16:12:28.308]                               next
[16:12:28.308]                             invokeRestart(restart)
[16:12:28.308]                             muffled <- TRUE
[16:12:28.308]                             break
[16:12:28.308]                           }
[16:12:28.308]                         }
[16:12:28.308]                       }
[16:12:28.308]                       invisible(muffled)
[16:12:28.308]                     }
[16:12:28.308]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.308]                   }
[16:12:28.308]                 }
[16:12:28.308]                 else {
[16:12:28.308]                   if (TRUE) {
[16:12:28.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.308]                     {
[16:12:28.308]                       inherits <- base::inherits
[16:12:28.308]                       invokeRestart <- base::invokeRestart
[16:12:28.308]                       is.null <- base::is.null
[16:12:28.308]                       muffled <- FALSE
[16:12:28.308]                       if (inherits(cond, "message")) {
[16:12:28.308]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.308]                         if (muffled) 
[16:12:28.308]                           invokeRestart("muffleMessage")
[16:12:28.308]                       }
[16:12:28.308]                       else if (inherits(cond, "warning")) {
[16:12:28.308]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.308]                         if (muffled) 
[16:12:28.308]                           invokeRestart("muffleWarning")
[16:12:28.308]                       }
[16:12:28.308]                       else if (inherits(cond, "condition")) {
[16:12:28.308]                         if (!is.null(pattern)) {
[16:12:28.308]                           computeRestarts <- base::computeRestarts
[16:12:28.308]                           grepl <- base::grepl
[16:12:28.308]                           restarts <- computeRestarts(cond)
[16:12:28.308]                           for (restart in restarts) {
[16:12:28.308]                             name <- restart$name
[16:12:28.308]                             if (is.null(name)) 
[16:12:28.308]                               next
[16:12:28.308]                             if (!grepl(pattern, name)) 
[16:12:28.308]                               next
[16:12:28.308]                             invokeRestart(restart)
[16:12:28.308]                             muffled <- TRUE
[16:12:28.308]                             break
[16:12:28.308]                           }
[16:12:28.308]                         }
[16:12:28.308]                       }
[16:12:28.308]                       invisible(muffled)
[16:12:28.308]                     }
[16:12:28.308]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.308]                   }
[16:12:28.308]                 }
[16:12:28.308]             }
[16:12:28.308]         }))
[16:12:28.308]     }, error = function(ex) {
[16:12:28.308]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.308]                 ...future.rng), started = ...future.startTime, 
[16:12:28.308]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.308]             version = "1.8"), class = "FutureResult")
[16:12:28.308]     }, finally = {
[16:12:28.308]         if (!identical(...future.workdir, getwd())) 
[16:12:28.308]             setwd(...future.workdir)
[16:12:28.308]         {
[16:12:28.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.308]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.308]             }
[16:12:28.308]             base::options(...future.oldOptions)
[16:12:28.308]             if (.Platform$OS.type == "windows") {
[16:12:28.308]                 old_names <- names(...future.oldEnvVars)
[16:12:28.308]                 envs <- base::Sys.getenv()
[16:12:28.308]                 names <- names(envs)
[16:12:28.308]                 common <- intersect(names, old_names)
[16:12:28.308]                 added <- setdiff(names, old_names)
[16:12:28.308]                 removed <- setdiff(old_names, names)
[16:12:28.308]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.308]                   envs[common]]
[16:12:28.308]                 NAMES <- toupper(changed)
[16:12:28.308]                 args <- list()
[16:12:28.308]                 for (kk in seq_along(NAMES)) {
[16:12:28.308]                   name <- changed[[kk]]
[16:12:28.308]                   NAME <- NAMES[[kk]]
[16:12:28.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.308]                     next
[16:12:28.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.308]                 }
[16:12:28.308]                 NAMES <- toupper(added)
[16:12:28.308]                 for (kk in seq_along(NAMES)) {
[16:12:28.308]                   name <- added[[kk]]
[16:12:28.308]                   NAME <- NAMES[[kk]]
[16:12:28.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.308]                     next
[16:12:28.308]                   args[[name]] <- ""
[16:12:28.308]                 }
[16:12:28.308]                 NAMES <- toupper(removed)
[16:12:28.308]                 for (kk in seq_along(NAMES)) {
[16:12:28.308]                   name <- removed[[kk]]
[16:12:28.308]                   NAME <- NAMES[[kk]]
[16:12:28.308]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.308]                     next
[16:12:28.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.308]                 }
[16:12:28.308]                 if (length(args) > 0) 
[16:12:28.308]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.308]             }
[16:12:28.308]             else {
[16:12:28.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.308]             }
[16:12:28.308]             {
[16:12:28.308]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.308]                   0L) {
[16:12:28.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.308]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.308]                   base::options(opts)
[16:12:28.308]                 }
[16:12:28.308]                 {
[16:12:28.308]                   {
[16:12:28.308]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.308]                     NULL
[16:12:28.308]                   }
[16:12:28.308]                   options(future.plan = NULL)
[16:12:28.308]                   if (is.na(NA_character_)) 
[16:12:28.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.308]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.308]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.308]                     envir = parent.frame()) 
[16:12:28.308]                   {
[16:12:28.308]                     if (is.function(workers)) 
[16:12:28.308]                       workers <- workers()
[16:12:28.308]                     workers <- structure(as.integer(workers), 
[16:12:28.308]                       class = class(workers))
[16:12:28.308]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.308]                       workers >= 1)
[16:12:28.308]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.308]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.308]                     }
[16:12:28.308]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.308]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.308]                       envir = envir)
[16:12:28.308]                     if (!future$lazy) 
[16:12:28.308]                       future <- run(future)
[16:12:28.308]                     invisible(future)
[16:12:28.308]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.308]                 }
[16:12:28.308]             }
[16:12:28.308]         }
[16:12:28.308]     })
[16:12:28.308]     if (TRUE) {
[16:12:28.308]         base::sink(type = "output", split = FALSE)
[16:12:28.308]         if (TRUE) {
[16:12:28.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.308]         }
[16:12:28.308]         else {
[16:12:28.308]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.308]         }
[16:12:28.308]         base::close(...future.stdout)
[16:12:28.308]         ...future.stdout <- NULL
[16:12:28.308]     }
[16:12:28.308]     ...future.result$conditions <- ...future.conditions
[16:12:28.308]     ...future.result$finished <- base::Sys.time()
[16:12:28.308]     ...future.result
[16:12:28.308] }
[16:12:28.311] MultisessionFuture started
[16:12:28.311] - Launch lazy future ... done
[16:12:28.311] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bb04fe9b0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bb085a030> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bb04fe9b0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bb085a030> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:28.341] resolve() on list ...
[16:12:28.341]  recursive: 0
[16:12:28.342]  length: 6
[16:12:28.342]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:28.342] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.342] - nx: 6
[16:12:28.342] - relay: TRUE
[16:12:28.342] - stdout: TRUE
[16:12:28.342] - signal: TRUE
[16:12:28.342] - resignal: FALSE
[16:12:28.342] - force: TRUE
[16:12:28.342] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.342] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.342]  - until=2
[16:12:28.343]  - relaying element #2
[16:12:28.343] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.343] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.343] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.343]  length: 5 (resolved future 1)
[16:12:28.343] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.344] - Validating connection of MultisessionFuture
[16:12:28.344] - received message: FutureResult
[16:12:28.344] - Received FutureResult
[16:12:28.344] - Erased future from FutureRegistry
[16:12:28.344] result() for ClusterFuture ...
[16:12:28.344] - result already collected: FutureResult
[16:12:28.344] result() for ClusterFuture ... done
[16:12:28.344] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.344] Future #2
[16:12:28.344] result() for ClusterFuture ...
[16:12:28.345] - result already collected: FutureResult
[16:12:28.345] result() for ClusterFuture ... done
[16:12:28.345] result() for ClusterFuture ...
[16:12:28.345] - result already collected: FutureResult
[16:12:28.345] result() for ClusterFuture ... done
[16:12:28.345] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:28.345] - nx: 6
[16:12:28.345] - relay: TRUE
[16:12:28.345] - stdout: TRUE
[16:12:28.345] - signal: TRUE
[16:12:28.345] - resignal: FALSE
[16:12:28.345] - force: TRUE
[16:12:28.346] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.346] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.346]  - until=2
[16:12:28.346]  - relaying element #2
[16:12:28.346] result() for ClusterFuture ...
[16:12:28.346] - result already collected: FutureResult
[16:12:28.346] result() for ClusterFuture ... done
[16:12:28.346] result() for ClusterFuture ...
[16:12:28.346] - result already collected: FutureResult
[16:12:28.346] result() for ClusterFuture ... done
[16:12:28.347] result() for ClusterFuture ...
[16:12:28.347] - result already collected: FutureResult
[16:12:28.347] result() for ClusterFuture ... done
[16:12:28.347] result() for ClusterFuture ...
[16:12:28.347] - result already collected: FutureResult
[16:12:28.347] result() for ClusterFuture ... done
[16:12:28.347] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.347] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.347] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:28.347]  length: 4 (resolved future 2)
[16:12:28.356] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.357] - Validating connection of MultisessionFuture
[16:12:28.357] - received message: FutureResult
[16:12:28.357] - Received FutureResult
[16:12:28.357] - Erased future from FutureRegistry
[16:12:28.357] result() for ClusterFuture ...
[16:12:28.357] - result already collected: FutureResult
[16:12:28.357] result() for ClusterFuture ... done
[16:12:28.357] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.358] Future #3
[16:12:28.358] result() for ClusterFuture ...
[16:12:28.358] - result already collected: FutureResult
[16:12:28.358] result() for ClusterFuture ... done
[16:12:28.358] result() for ClusterFuture ...
[16:12:28.358] - result already collected: FutureResult
[16:12:28.358] result() for ClusterFuture ... done
[16:12:28.358] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:28.358] - nx: 6
[16:12:28.358] - relay: TRUE
[16:12:28.358] - stdout: TRUE
[16:12:28.358] - signal: TRUE
[16:12:28.359] - resignal: FALSE
[16:12:28.359] - force: TRUE
[16:12:28.359] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.359] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.359]  - until=3
[16:12:28.359]  - relaying element #3
[16:12:28.359] result() for ClusterFuture ...
[16:12:28.359] - result already collected: FutureResult
[16:12:28.359] result() for ClusterFuture ... done
[16:12:28.359] result() for ClusterFuture ...
[16:12:28.359] - result already collected: FutureResult
[16:12:28.359] result() for ClusterFuture ... done
[16:12:28.360] result() for ClusterFuture ...
[16:12:28.360] - result already collected: FutureResult
[16:12:28.360] result() for ClusterFuture ... done
[16:12:28.360] result() for ClusterFuture ...
[16:12:28.360] - result already collected: FutureResult
[16:12:28.360] result() for ClusterFuture ... done
[16:12:28.360] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.360] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.360] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:28.360]  length: 3 (resolved future 3)
[16:12:28.361] signalConditionsASAP(NULL, pos=4) ...
[16:12:28.361] - nx: 6
[16:12:28.361] - relay: TRUE
[16:12:28.361] - stdout: TRUE
[16:12:28.361] - signal: TRUE
[16:12:28.361] - resignal: FALSE
[16:12:28.361] - force: TRUE
[16:12:28.361] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.361] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.361]  - until=5
[16:12:28.361]  - relaying element #5
[16:12:28.361] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:28.362] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.362] signalConditionsASAP(NULL, pos=4) ... done
[16:12:28.362]  length: 2 (resolved future 4)
[16:12:28.362] signalConditionsASAP(NULL, pos=5) ...
[16:12:28.362] - nx: 6
[16:12:28.362] - relay: TRUE
[16:12:28.362] - stdout: TRUE
[16:12:28.362] - signal: TRUE
[16:12:28.362] - resignal: FALSE
[16:12:28.362] - force: TRUE
[16:12:28.362] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:28.362] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.363]  - until=6
[16:12:28.363]  - relaying element #6
[16:12:28.363] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:28.363] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.363] signalConditionsASAP(NULL, pos=5) ... done
[16:12:28.363]  length: 1 (resolved future 5)
[16:12:28.363] signalConditionsASAP(numeric, pos=6) ...
[16:12:28.363] - nx: 6
[16:12:28.363] - relay: TRUE
[16:12:28.363] - stdout: TRUE
[16:12:28.363] - signal: TRUE
[16:12:28.363] - resignal: FALSE
[16:12:28.364] - force: TRUE
[16:12:28.364] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:28.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.364]  - until=6
[16:12:28.364] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.364] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.364] signalConditionsASAP(numeric, pos=6) ... done
[16:12:28.364]  length: 0 (resolved future 6)
[16:12:28.364] Relaying remaining futures
[16:12:28.364] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.364] - nx: 6
[16:12:28.365] - relay: TRUE
[16:12:28.365] - stdout: TRUE
[16:12:28.365] - signal: TRUE
[16:12:28.365] - resignal: FALSE
[16:12:28.365] - force: TRUE
[16:12:28.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:28.365] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.365] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.365] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.365] resolve() on list ... DONE
[16:12:28.365] result() for ClusterFuture ...
[16:12:28.366] - result already collected: FutureResult
[16:12:28.366] result() for ClusterFuture ... done
[16:12:28.366] result() for ClusterFuture ...
[16:12:28.366] - result already collected: FutureResult
[16:12:28.366] result() for ClusterFuture ... done
[16:12:28.366] result() for ClusterFuture ...
[16:12:28.366] - result already collected: FutureResult
[16:12:28.366] result() for ClusterFuture ... done
[16:12:28.366] result() for ClusterFuture ...
[16:12:28.366] - result already collected: FutureResult
[16:12:28.366] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:12:28.370] getGlobalsAndPackages() ...
[16:12:28.370] Searching for globals...
[16:12:28.370] 
[16:12:28.370] Searching for globals ... DONE
[16:12:28.370] - globals: [0] <none>
[16:12:28.370] getGlobalsAndPackages() ... DONE
[16:12:28.371] run() for ‘Future’ ...
[16:12:28.371] - state: ‘created’
[16:12:28.371] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.385] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.386]   - Field: ‘node’
[16:12:28.386]   - Field: ‘label’
[16:12:28.386]   - Field: ‘local’
[16:12:28.386]   - Field: ‘owner’
[16:12:28.386]   - Field: ‘envir’
[16:12:28.386]   - Field: ‘workers’
[16:12:28.386]   - Field: ‘packages’
[16:12:28.386]   - Field: ‘gc’
[16:12:28.386]   - Field: ‘conditions’
[16:12:28.386]   - Field: ‘persistent’
[16:12:28.386]   - Field: ‘expr’
[16:12:28.387]   - Field: ‘uuid’
[16:12:28.387]   - Field: ‘seed’
[16:12:28.387]   - Field: ‘version’
[16:12:28.387]   - Field: ‘result’
[16:12:28.387]   - Field: ‘asynchronous’
[16:12:28.387]   - Field: ‘calls’
[16:12:28.387]   - Field: ‘globals’
[16:12:28.387]   - Field: ‘stdout’
[16:12:28.387]   - Field: ‘earlySignal’
[16:12:28.387]   - Field: ‘lazy’
[16:12:28.387]   - Field: ‘state’
[16:12:28.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.388] - Launch lazy future ...
[16:12:28.388] Packages needed by the future expression (n = 0): <none>
[16:12:28.388] Packages needed by future strategies (n = 0): <none>
[16:12:28.389] {
[16:12:28.389]     {
[16:12:28.389]         {
[16:12:28.389]             ...future.startTime <- base::Sys.time()
[16:12:28.389]             {
[16:12:28.389]                 {
[16:12:28.389]                   {
[16:12:28.389]                     {
[16:12:28.389]                       base::local({
[16:12:28.389]                         has_future <- base::requireNamespace("future", 
[16:12:28.389]                           quietly = TRUE)
[16:12:28.389]                         if (has_future) {
[16:12:28.389]                           ns <- base::getNamespace("future")
[16:12:28.389]                           version <- ns[[".package"]][["version"]]
[16:12:28.389]                           if (is.null(version)) 
[16:12:28.389]                             version <- utils::packageVersion("future")
[16:12:28.389]                         }
[16:12:28.389]                         else {
[16:12:28.389]                           version <- NULL
[16:12:28.389]                         }
[16:12:28.389]                         if (!has_future || version < "1.8.0") {
[16:12:28.389]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.389]                             "", base::R.version$version.string), 
[16:12:28.389]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.389]                               "release", "version")], collapse = " "), 
[16:12:28.389]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.389]                             info)
[16:12:28.389]                           info <- base::paste(info, collapse = "; ")
[16:12:28.389]                           if (!has_future) {
[16:12:28.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.389]                               info)
[16:12:28.389]                           }
[16:12:28.389]                           else {
[16:12:28.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.389]                               info, version)
[16:12:28.389]                           }
[16:12:28.389]                           base::stop(msg)
[16:12:28.389]                         }
[16:12:28.389]                       })
[16:12:28.389]                     }
[16:12:28.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.389]                     base::options(mc.cores = 1L)
[16:12:28.389]                   }
[16:12:28.389]                   options(future.plan = NULL)
[16:12:28.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.389]                 }
[16:12:28.389]                 ...future.workdir <- getwd()
[16:12:28.389]             }
[16:12:28.389]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.389]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.389]         }
[16:12:28.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.389]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.389]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.389]             base::names(...future.oldOptions))
[16:12:28.389]     }
[16:12:28.389]     if (FALSE) {
[16:12:28.389]     }
[16:12:28.389]     else {
[16:12:28.389]         if (TRUE) {
[16:12:28.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.389]                 open = "w")
[16:12:28.389]         }
[16:12:28.389]         else {
[16:12:28.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.389]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.389]         }
[16:12:28.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.389]             base::sink(type = "output", split = FALSE)
[16:12:28.389]             base::close(...future.stdout)
[16:12:28.389]         }, add = TRUE)
[16:12:28.389]     }
[16:12:28.389]     ...future.frame <- base::sys.nframe()
[16:12:28.389]     ...future.conditions <- base::list()
[16:12:28.389]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.389]     if (FALSE) {
[16:12:28.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.389]     }
[16:12:28.389]     ...future.result <- base::tryCatch({
[16:12:28.389]         base::withCallingHandlers({
[16:12:28.389]             ...future.value <- base::withVisible(base::local({
[16:12:28.389]                 ...future.makeSendCondition <- local({
[16:12:28.389]                   sendCondition <- NULL
[16:12:28.389]                   function(frame = 1L) {
[16:12:28.389]                     if (is.function(sendCondition)) 
[16:12:28.389]                       return(sendCondition)
[16:12:28.389]                     ns <- getNamespace("parallel")
[16:12:28.389]                     if (exists("sendData", mode = "function", 
[16:12:28.389]                       envir = ns)) {
[16:12:28.389]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.389]                         envir = ns)
[16:12:28.389]                       envir <- sys.frame(frame)
[16:12:28.389]                       master <- NULL
[16:12:28.389]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.389]                         !identical(envir, emptyenv())) {
[16:12:28.389]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.389]                           inherits = FALSE)) {
[16:12:28.389]                           master <- get("master", mode = "list", 
[16:12:28.389]                             envir = envir, inherits = FALSE)
[16:12:28.389]                           if (inherits(master, c("SOCKnode", 
[16:12:28.389]                             "SOCK0node"))) {
[16:12:28.389]                             sendCondition <<- function(cond) {
[16:12:28.389]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.389]                                 success = TRUE)
[16:12:28.389]                               parallel_sendData(master, data)
[16:12:28.389]                             }
[16:12:28.389]                             return(sendCondition)
[16:12:28.389]                           }
[16:12:28.389]                         }
[16:12:28.389]                         frame <- frame + 1L
[16:12:28.389]                         envir <- sys.frame(frame)
[16:12:28.389]                       }
[16:12:28.389]                     }
[16:12:28.389]                     sendCondition <<- function(cond) NULL
[16:12:28.389]                   }
[16:12:28.389]                 })
[16:12:28.389]                 withCallingHandlers({
[16:12:28.389]                   2
[16:12:28.389]                 }, immediateCondition = function(cond) {
[16:12:28.389]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.389]                   sendCondition(cond)
[16:12:28.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.389]                   {
[16:12:28.389]                     inherits <- base::inherits
[16:12:28.389]                     invokeRestart <- base::invokeRestart
[16:12:28.389]                     is.null <- base::is.null
[16:12:28.389]                     muffled <- FALSE
[16:12:28.389]                     if (inherits(cond, "message")) {
[16:12:28.389]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.389]                       if (muffled) 
[16:12:28.389]                         invokeRestart("muffleMessage")
[16:12:28.389]                     }
[16:12:28.389]                     else if (inherits(cond, "warning")) {
[16:12:28.389]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.389]                       if (muffled) 
[16:12:28.389]                         invokeRestart("muffleWarning")
[16:12:28.389]                     }
[16:12:28.389]                     else if (inherits(cond, "condition")) {
[16:12:28.389]                       if (!is.null(pattern)) {
[16:12:28.389]                         computeRestarts <- base::computeRestarts
[16:12:28.389]                         grepl <- base::grepl
[16:12:28.389]                         restarts <- computeRestarts(cond)
[16:12:28.389]                         for (restart in restarts) {
[16:12:28.389]                           name <- restart$name
[16:12:28.389]                           if (is.null(name)) 
[16:12:28.389]                             next
[16:12:28.389]                           if (!grepl(pattern, name)) 
[16:12:28.389]                             next
[16:12:28.389]                           invokeRestart(restart)
[16:12:28.389]                           muffled <- TRUE
[16:12:28.389]                           break
[16:12:28.389]                         }
[16:12:28.389]                       }
[16:12:28.389]                     }
[16:12:28.389]                     invisible(muffled)
[16:12:28.389]                   }
[16:12:28.389]                   muffleCondition(cond)
[16:12:28.389]                 })
[16:12:28.389]             }))
[16:12:28.389]             future::FutureResult(value = ...future.value$value, 
[16:12:28.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.389]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.389]                     ...future.globalenv.names))
[16:12:28.389]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.389]         }, condition = base::local({
[16:12:28.389]             c <- base::c
[16:12:28.389]             inherits <- base::inherits
[16:12:28.389]             invokeRestart <- base::invokeRestart
[16:12:28.389]             length <- base::length
[16:12:28.389]             list <- base::list
[16:12:28.389]             seq.int <- base::seq.int
[16:12:28.389]             signalCondition <- base::signalCondition
[16:12:28.389]             sys.calls <- base::sys.calls
[16:12:28.389]             `[[` <- base::`[[`
[16:12:28.389]             `+` <- base::`+`
[16:12:28.389]             `<<-` <- base::`<<-`
[16:12:28.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.389]                   3L)]
[16:12:28.389]             }
[16:12:28.389]             function(cond) {
[16:12:28.389]                 is_error <- inherits(cond, "error")
[16:12:28.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.389]                   NULL)
[16:12:28.389]                 if (is_error) {
[16:12:28.389]                   sessionInformation <- function() {
[16:12:28.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.389]                       search = base::search(), system = base::Sys.info())
[16:12:28.389]                   }
[16:12:28.389]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.389]                     cond$call), session = sessionInformation(), 
[16:12:28.389]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.389]                   signalCondition(cond)
[16:12:28.389]                 }
[16:12:28.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.389]                 "immediateCondition"))) {
[16:12:28.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.389]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.389]                   if (TRUE && !signal) {
[16:12:28.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.389]                     {
[16:12:28.389]                       inherits <- base::inherits
[16:12:28.389]                       invokeRestart <- base::invokeRestart
[16:12:28.389]                       is.null <- base::is.null
[16:12:28.389]                       muffled <- FALSE
[16:12:28.389]                       if (inherits(cond, "message")) {
[16:12:28.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.389]                         if (muffled) 
[16:12:28.389]                           invokeRestart("muffleMessage")
[16:12:28.389]                       }
[16:12:28.389]                       else if (inherits(cond, "warning")) {
[16:12:28.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.389]                         if (muffled) 
[16:12:28.389]                           invokeRestart("muffleWarning")
[16:12:28.389]                       }
[16:12:28.389]                       else if (inherits(cond, "condition")) {
[16:12:28.389]                         if (!is.null(pattern)) {
[16:12:28.389]                           computeRestarts <- base::computeRestarts
[16:12:28.389]                           grepl <- base::grepl
[16:12:28.389]                           restarts <- computeRestarts(cond)
[16:12:28.389]                           for (restart in restarts) {
[16:12:28.389]                             name <- restart$name
[16:12:28.389]                             if (is.null(name)) 
[16:12:28.389]                               next
[16:12:28.389]                             if (!grepl(pattern, name)) 
[16:12:28.389]                               next
[16:12:28.389]                             invokeRestart(restart)
[16:12:28.389]                             muffled <- TRUE
[16:12:28.389]                             break
[16:12:28.389]                           }
[16:12:28.389]                         }
[16:12:28.389]                       }
[16:12:28.389]                       invisible(muffled)
[16:12:28.389]                     }
[16:12:28.389]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.389]                   }
[16:12:28.389]                 }
[16:12:28.389]                 else {
[16:12:28.389]                   if (TRUE) {
[16:12:28.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.389]                     {
[16:12:28.389]                       inherits <- base::inherits
[16:12:28.389]                       invokeRestart <- base::invokeRestart
[16:12:28.389]                       is.null <- base::is.null
[16:12:28.389]                       muffled <- FALSE
[16:12:28.389]                       if (inherits(cond, "message")) {
[16:12:28.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.389]                         if (muffled) 
[16:12:28.389]                           invokeRestart("muffleMessage")
[16:12:28.389]                       }
[16:12:28.389]                       else if (inherits(cond, "warning")) {
[16:12:28.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.389]                         if (muffled) 
[16:12:28.389]                           invokeRestart("muffleWarning")
[16:12:28.389]                       }
[16:12:28.389]                       else if (inherits(cond, "condition")) {
[16:12:28.389]                         if (!is.null(pattern)) {
[16:12:28.389]                           computeRestarts <- base::computeRestarts
[16:12:28.389]                           grepl <- base::grepl
[16:12:28.389]                           restarts <- computeRestarts(cond)
[16:12:28.389]                           for (restart in restarts) {
[16:12:28.389]                             name <- restart$name
[16:12:28.389]                             if (is.null(name)) 
[16:12:28.389]                               next
[16:12:28.389]                             if (!grepl(pattern, name)) 
[16:12:28.389]                               next
[16:12:28.389]                             invokeRestart(restart)
[16:12:28.389]                             muffled <- TRUE
[16:12:28.389]                             break
[16:12:28.389]                           }
[16:12:28.389]                         }
[16:12:28.389]                       }
[16:12:28.389]                       invisible(muffled)
[16:12:28.389]                     }
[16:12:28.389]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.389]                   }
[16:12:28.389]                 }
[16:12:28.389]             }
[16:12:28.389]         }))
[16:12:28.389]     }, error = function(ex) {
[16:12:28.389]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.389]                 ...future.rng), started = ...future.startTime, 
[16:12:28.389]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.389]             version = "1.8"), class = "FutureResult")
[16:12:28.389]     }, finally = {
[16:12:28.389]         if (!identical(...future.workdir, getwd())) 
[16:12:28.389]             setwd(...future.workdir)
[16:12:28.389]         {
[16:12:28.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.389]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.389]             }
[16:12:28.389]             base::options(...future.oldOptions)
[16:12:28.389]             if (.Platform$OS.type == "windows") {
[16:12:28.389]                 old_names <- names(...future.oldEnvVars)
[16:12:28.389]                 envs <- base::Sys.getenv()
[16:12:28.389]                 names <- names(envs)
[16:12:28.389]                 common <- intersect(names, old_names)
[16:12:28.389]                 added <- setdiff(names, old_names)
[16:12:28.389]                 removed <- setdiff(old_names, names)
[16:12:28.389]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.389]                   envs[common]]
[16:12:28.389]                 NAMES <- toupper(changed)
[16:12:28.389]                 args <- list()
[16:12:28.389]                 for (kk in seq_along(NAMES)) {
[16:12:28.389]                   name <- changed[[kk]]
[16:12:28.389]                   NAME <- NAMES[[kk]]
[16:12:28.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.389]                     next
[16:12:28.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.389]                 }
[16:12:28.389]                 NAMES <- toupper(added)
[16:12:28.389]                 for (kk in seq_along(NAMES)) {
[16:12:28.389]                   name <- added[[kk]]
[16:12:28.389]                   NAME <- NAMES[[kk]]
[16:12:28.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.389]                     next
[16:12:28.389]                   args[[name]] <- ""
[16:12:28.389]                 }
[16:12:28.389]                 NAMES <- toupper(removed)
[16:12:28.389]                 for (kk in seq_along(NAMES)) {
[16:12:28.389]                   name <- removed[[kk]]
[16:12:28.389]                   NAME <- NAMES[[kk]]
[16:12:28.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.389]                     next
[16:12:28.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.389]                 }
[16:12:28.389]                 if (length(args) > 0) 
[16:12:28.389]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.389]             }
[16:12:28.389]             else {
[16:12:28.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.389]             }
[16:12:28.389]             {
[16:12:28.389]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.389]                   0L) {
[16:12:28.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.389]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.389]                   base::options(opts)
[16:12:28.389]                 }
[16:12:28.389]                 {
[16:12:28.389]                   {
[16:12:28.389]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.389]                     NULL
[16:12:28.389]                   }
[16:12:28.389]                   options(future.plan = NULL)
[16:12:28.389]                   if (is.na(NA_character_)) 
[16:12:28.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.389]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.389]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.389]                     envir = parent.frame()) 
[16:12:28.389]                   {
[16:12:28.389]                     if (is.function(workers)) 
[16:12:28.389]                       workers <- workers()
[16:12:28.389]                     workers <- structure(as.integer(workers), 
[16:12:28.389]                       class = class(workers))
[16:12:28.389]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.389]                       workers >= 1)
[16:12:28.389]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.389]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.389]                     }
[16:12:28.389]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.389]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.389]                       envir = envir)
[16:12:28.389]                     if (!future$lazy) 
[16:12:28.389]                       future <- run(future)
[16:12:28.389]                     invisible(future)
[16:12:28.389]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.389]                 }
[16:12:28.389]             }
[16:12:28.389]         }
[16:12:28.389]     })
[16:12:28.389]     if (TRUE) {
[16:12:28.389]         base::sink(type = "output", split = FALSE)
[16:12:28.389]         if (TRUE) {
[16:12:28.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.389]         }
[16:12:28.389]         else {
[16:12:28.389]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.389]         }
[16:12:28.389]         base::close(...future.stdout)
[16:12:28.389]         ...future.stdout <- NULL
[16:12:28.389]     }
[16:12:28.389]     ...future.result$conditions <- ...future.conditions
[16:12:28.389]     ...future.result$finished <- base::Sys.time()
[16:12:28.389]     ...future.result
[16:12:28.389] }
[16:12:28.392] MultisessionFuture started
[16:12:28.392] - Launch lazy future ... done
[16:12:28.392] run() for ‘MultisessionFuture’ ... done
[16:12:28.392] getGlobalsAndPackages() ...
[16:12:28.392] Searching for globals...
[16:12:28.393] 
[16:12:28.393] Searching for globals ... DONE
[16:12:28.393] - globals: [0] <none>
[16:12:28.393] getGlobalsAndPackages() ... DONE
[16:12:28.393] run() for ‘Future’ ...
[16:12:28.393] - state: ‘created’
[16:12:28.393] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.407] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.408]   - Field: ‘node’
[16:12:28.408]   - Field: ‘label’
[16:12:28.408]   - Field: ‘local’
[16:12:28.408]   - Field: ‘owner’
[16:12:28.408]   - Field: ‘envir’
[16:12:28.408]   - Field: ‘workers’
[16:12:28.408]   - Field: ‘packages’
[16:12:28.408]   - Field: ‘gc’
[16:12:28.408]   - Field: ‘conditions’
[16:12:28.409]   - Field: ‘persistent’
[16:12:28.409]   - Field: ‘expr’
[16:12:28.409]   - Field: ‘uuid’
[16:12:28.409]   - Field: ‘seed’
[16:12:28.409]   - Field: ‘version’
[16:12:28.409]   - Field: ‘result’
[16:12:28.409]   - Field: ‘asynchronous’
[16:12:28.409]   - Field: ‘calls’
[16:12:28.409]   - Field: ‘globals’
[16:12:28.409]   - Field: ‘stdout’
[16:12:28.409]   - Field: ‘earlySignal’
[16:12:28.410]   - Field: ‘lazy’
[16:12:28.410]   - Field: ‘state’
[16:12:28.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.410] - Launch lazy future ...
[16:12:28.410] Packages needed by the future expression (n = 0): <none>
[16:12:28.410] Packages needed by future strategies (n = 0): <none>
[16:12:28.411] {
[16:12:28.411]     {
[16:12:28.411]         {
[16:12:28.411]             ...future.startTime <- base::Sys.time()
[16:12:28.411]             {
[16:12:28.411]                 {
[16:12:28.411]                   {
[16:12:28.411]                     {
[16:12:28.411]                       base::local({
[16:12:28.411]                         has_future <- base::requireNamespace("future", 
[16:12:28.411]                           quietly = TRUE)
[16:12:28.411]                         if (has_future) {
[16:12:28.411]                           ns <- base::getNamespace("future")
[16:12:28.411]                           version <- ns[[".package"]][["version"]]
[16:12:28.411]                           if (is.null(version)) 
[16:12:28.411]                             version <- utils::packageVersion("future")
[16:12:28.411]                         }
[16:12:28.411]                         else {
[16:12:28.411]                           version <- NULL
[16:12:28.411]                         }
[16:12:28.411]                         if (!has_future || version < "1.8.0") {
[16:12:28.411]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.411]                             "", base::R.version$version.string), 
[16:12:28.411]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.411]                               "release", "version")], collapse = " "), 
[16:12:28.411]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.411]                             info)
[16:12:28.411]                           info <- base::paste(info, collapse = "; ")
[16:12:28.411]                           if (!has_future) {
[16:12:28.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.411]                               info)
[16:12:28.411]                           }
[16:12:28.411]                           else {
[16:12:28.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.411]                               info, version)
[16:12:28.411]                           }
[16:12:28.411]                           base::stop(msg)
[16:12:28.411]                         }
[16:12:28.411]                       })
[16:12:28.411]                     }
[16:12:28.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.411]                     base::options(mc.cores = 1L)
[16:12:28.411]                   }
[16:12:28.411]                   options(future.plan = NULL)
[16:12:28.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.411]                 }
[16:12:28.411]                 ...future.workdir <- getwd()
[16:12:28.411]             }
[16:12:28.411]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.411]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.411]         }
[16:12:28.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.411]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.411]             base::names(...future.oldOptions))
[16:12:28.411]     }
[16:12:28.411]     if (FALSE) {
[16:12:28.411]     }
[16:12:28.411]     else {
[16:12:28.411]         if (TRUE) {
[16:12:28.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.411]                 open = "w")
[16:12:28.411]         }
[16:12:28.411]         else {
[16:12:28.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.411]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.411]         }
[16:12:28.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.411]             base::sink(type = "output", split = FALSE)
[16:12:28.411]             base::close(...future.stdout)
[16:12:28.411]         }, add = TRUE)
[16:12:28.411]     }
[16:12:28.411]     ...future.frame <- base::sys.nframe()
[16:12:28.411]     ...future.conditions <- base::list()
[16:12:28.411]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.411]     if (FALSE) {
[16:12:28.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.411]     }
[16:12:28.411]     ...future.result <- base::tryCatch({
[16:12:28.411]         base::withCallingHandlers({
[16:12:28.411]             ...future.value <- base::withVisible(base::local({
[16:12:28.411]                 ...future.makeSendCondition <- local({
[16:12:28.411]                   sendCondition <- NULL
[16:12:28.411]                   function(frame = 1L) {
[16:12:28.411]                     if (is.function(sendCondition)) 
[16:12:28.411]                       return(sendCondition)
[16:12:28.411]                     ns <- getNamespace("parallel")
[16:12:28.411]                     if (exists("sendData", mode = "function", 
[16:12:28.411]                       envir = ns)) {
[16:12:28.411]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.411]                         envir = ns)
[16:12:28.411]                       envir <- sys.frame(frame)
[16:12:28.411]                       master <- NULL
[16:12:28.411]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.411]                         !identical(envir, emptyenv())) {
[16:12:28.411]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.411]                           inherits = FALSE)) {
[16:12:28.411]                           master <- get("master", mode = "list", 
[16:12:28.411]                             envir = envir, inherits = FALSE)
[16:12:28.411]                           if (inherits(master, c("SOCKnode", 
[16:12:28.411]                             "SOCK0node"))) {
[16:12:28.411]                             sendCondition <<- function(cond) {
[16:12:28.411]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.411]                                 success = TRUE)
[16:12:28.411]                               parallel_sendData(master, data)
[16:12:28.411]                             }
[16:12:28.411]                             return(sendCondition)
[16:12:28.411]                           }
[16:12:28.411]                         }
[16:12:28.411]                         frame <- frame + 1L
[16:12:28.411]                         envir <- sys.frame(frame)
[16:12:28.411]                       }
[16:12:28.411]                     }
[16:12:28.411]                     sendCondition <<- function(cond) NULL
[16:12:28.411]                   }
[16:12:28.411]                 })
[16:12:28.411]                 withCallingHandlers({
[16:12:28.411]                   NULL
[16:12:28.411]                 }, immediateCondition = function(cond) {
[16:12:28.411]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.411]                   sendCondition(cond)
[16:12:28.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.411]                   {
[16:12:28.411]                     inherits <- base::inherits
[16:12:28.411]                     invokeRestart <- base::invokeRestart
[16:12:28.411]                     is.null <- base::is.null
[16:12:28.411]                     muffled <- FALSE
[16:12:28.411]                     if (inherits(cond, "message")) {
[16:12:28.411]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.411]                       if (muffled) 
[16:12:28.411]                         invokeRestart("muffleMessage")
[16:12:28.411]                     }
[16:12:28.411]                     else if (inherits(cond, "warning")) {
[16:12:28.411]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.411]                       if (muffled) 
[16:12:28.411]                         invokeRestart("muffleWarning")
[16:12:28.411]                     }
[16:12:28.411]                     else if (inherits(cond, "condition")) {
[16:12:28.411]                       if (!is.null(pattern)) {
[16:12:28.411]                         computeRestarts <- base::computeRestarts
[16:12:28.411]                         grepl <- base::grepl
[16:12:28.411]                         restarts <- computeRestarts(cond)
[16:12:28.411]                         for (restart in restarts) {
[16:12:28.411]                           name <- restart$name
[16:12:28.411]                           if (is.null(name)) 
[16:12:28.411]                             next
[16:12:28.411]                           if (!grepl(pattern, name)) 
[16:12:28.411]                             next
[16:12:28.411]                           invokeRestart(restart)
[16:12:28.411]                           muffled <- TRUE
[16:12:28.411]                           break
[16:12:28.411]                         }
[16:12:28.411]                       }
[16:12:28.411]                     }
[16:12:28.411]                     invisible(muffled)
[16:12:28.411]                   }
[16:12:28.411]                   muffleCondition(cond)
[16:12:28.411]                 })
[16:12:28.411]             }))
[16:12:28.411]             future::FutureResult(value = ...future.value$value, 
[16:12:28.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.411]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.411]                     ...future.globalenv.names))
[16:12:28.411]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.411]         }, condition = base::local({
[16:12:28.411]             c <- base::c
[16:12:28.411]             inherits <- base::inherits
[16:12:28.411]             invokeRestart <- base::invokeRestart
[16:12:28.411]             length <- base::length
[16:12:28.411]             list <- base::list
[16:12:28.411]             seq.int <- base::seq.int
[16:12:28.411]             signalCondition <- base::signalCondition
[16:12:28.411]             sys.calls <- base::sys.calls
[16:12:28.411]             `[[` <- base::`[[`
[16:12:28.411]             `+` <- base::`+`
[16:12:28.411]             `<<-` <- base::`<<-`
[16:12:28.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.411]                   3L)]
[16:12:28.411]             }
[16:12:28.411]             function(cond) {
[16:12:28.411]                 is_error <- inherits(cond, "error")
[16:12:28.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.411]                   NULL)
[16:12:28.411]                 if (is_error) {
[16:12:28.411]                   sessionInformation <- function() {
[16:12:28.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.411]                       search = base::search(), system = base::Sys.info())
[16:12:28.411]                   }
[16:12:28.411]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.411]                     cond$call), session = sessionInformation(), 
[16:12:28.411]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.411]                   signalCondition(cond)
[16:12:28.411]                 }
[16:12:28.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.411]                 "immediateCondition"))) {
[16:12:28.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.411]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.411]                   if (TRUE && !signal) {
[16:12:28.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.411]                     {
[16:12:28.411]                       inherits <- base::inherits
[16:12:28.411]                       invokeRestart <- base::invokeRestart
[16:12:28.411]                       is.null <- base::is.null
[16:12:28.411]                       muffled <- FALSE
[16:12:28.411]                       if (inherits(cond, "message")) {
[16:12:28.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.411]                         if (muffled) 
[16:12:28.411]                           invokeRestart("muffleMessage")
[16:12:28.411]                       }
[16:12:28.411]                       else if (inherits(cond, "warning")) {
[16:12:28.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.411]                         if (muffled) 
[16:12:28.411]                           invokeRestart("muffleWarning")
[16:12:28.411]                       }
[16:12:28.411]                       else if (inherits(cond, "condition")) {
[16:12:28.411]                         if (!is.null(pattern)) {
[16:12:28.411]                           computeRestarts <- base::computeRestarts
[16:12:28.411]                           grepl <- base::grepl
[16:12:28.411]                           restarts <- computeRestarts(cond)
[16:12:28.411]                           for (restart in restarts) {
[16:12:28.411]                             name <- restart$name
[16:12:28.411]                             if (is.null(name)) 
[16:12:28.411]                               next
[16:12:28.411]                             if (!grepl(pattern, name)) 
[16:12:28.411]                               next
[16:12:28.411]                             invokeRestart(restart)
[16:12:28.411]                             muffled <- TRUE
[16:12:28.411]                             break
[16:12:28.411]                           }
[16:12:28.411]                         }
[16:12:28.411]                       }
[16:12:28.411]                       invisible(muffled)
[16:12:28.411]                     }
[16:12:28.411]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.411]                   }
[16:12:28.411]                 }
[16:12:28.411]                 else {
[16:12:28.411]                   if (TRUE) {
[16:12:28.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.411]                     {
[16:12:28.411]                       inherits <- base::inherits
[16:12:28.411]                       invokeRestart <- base::invokeRestart
[16:12:28.411]                       is.null <- base::is.null
[16:12:28.411]                       muffled <- FALSE
[16:12:28.411]                       if (inherits(cond, "message")) {
[16:12:28.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.411]                         if (muffled) 
[16:12:28.411]                           invokeRestart("muffleMessage")
[16:12:28.411]                       }
[16:12:28.411]                       else if (inherits(cond, "warning")) {
[16:12:28.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.411]                         if (muffled) 
[16:12:28.411]                           invokeRestart("muffleWarning")
[16:12:28.411]                       }
[16:12:28.411]                       else if (inherits(cond, "condition")) {
[16:12:28.411]                         if (!is.null(pattern)) {
[16:12:28.411]                           computeRestarts <- base::computeRestarts
[16:12:28.411]                           grepl <- base::grepl
[16:12:28.411]                           restarts <- computeRestarts(cond)
[16:12:28.411]                           for (restart in restarts) {
[16:12:28.411]                             name <- restart$name
[16:12:28.411]                             if (is.null(name)) 
[16:12:28.411]                               next
[16:12:28.411]                             if (!grepl(pattern, name)) 
[16:12:28.411]                               next
[16:12:28.411]                             invokeRestart(restart)
[16:12:28.411]                             muffled <- TRUE
[16:12:28.411]                             break
[16:12:28.411]                           }
[16:12:28.411]                         }
[16:12:28.411]                       }
[16:12:28.411]                       invisible(muffled)
[16:12:28.411]                     }
[16:12:28.411]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.411]                   }
[16:12:28.411]                 }
[16:12:28.411]             }
[16:12:28.411]         }))
[16:12:28.411]     }, error = function(ex) {
[16:12:28.411]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.411]                 ...future.rng), started = ...future.startTime, 
[16:12:28.411]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.411]             version = "1.8"), class = "FutureResult")
[16:12:28.411]     }, finally = {
[16:12:28.411]         if (!identical(...future.workdir, getwd())) 
[16:12:28.411]             setwd(...future.workdir)
[16:12:28.411]         {
[16:12:28.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.411]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.411]             }
[16:12:28.411]             base::options(...future.oldOptions)
[16:12:28.411]             if (.Platform$OS.type == "windows") {
[16:12:28.411]                 old_names <- names(...future.oldEnvVars)
[16:12:28.411]                 envs <- base::Sys.getenv()
[16:12:28.411]                 names <- names(envs)
[16:12:28.411]                 common <- intersect(names, old_names)
[16:12:28.411]                 added <- setdiff(names, old_names)
[16:12:28.411]                 removed <- setdiff(old_names, names)
[16:12:28.411]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.411]                   envs[common]]
[16:12:28.411]                 NAMES <- toupper(changed)
[16:12:28.411]                 args <- list()
[16:12:28.411]                 for (kk in seq_along(NAMES)) {
[16:12:28.411]                   name <- changed[[kk]]
[16:12:28.411]                   NAME <- NAMES[[kk]]
[16:12:28.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.411]                     next
[16:12:28.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.411]                 }
[16:12:28.411]                 NAMES <- toupper(added)
[16:12:28.411]                 for (kk in seq_along(NAMES)) {
[16:12:28.411]                   name <- added[[kk]]
[16:12:28.411]                   NAME <- NAMES[[kk]]
[16:12:28.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.411]                     next
[16:12:28.411]                   args[[name]] <- ""
[16:12:28.411]                 }
[16:12:28.411]                 NAMES <- toupper(removed)
[16:12:28.411]                 for (kk in seq_along(NAMES)) {
[16:12:28.411]                   name <- removed[[kk]]
[16:12:28.411]                   NAME <- NAMES[[kk]]
[16:12:28.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.411]                     next
[16:12:28.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.411]                 }
[16:12:28.411]                 if (length(args) > 0) 
[16:12:28.411]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.411]             }
[16:12:28.411]             else {
[16:12:28.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.411]             }
[16:12:28.411]             {
[16:12:28.411]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.411]                   0L) {
[16:12:28.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.411]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.411]                   base::options(opts)
[16:12:28.411]                 }
[16:12:28.411]                 {
[16:12:28.411]                   {
[16:12:28.411]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.411]                     NULL
[16:12:28.411]                   }
[16:12:28.411]                   options(future.plan = NULL)
[16:12:28.411]                   if (is.na(NA_character_)) 
[16:12:28.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.411]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.411]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.411]                     envir = parent.frame()) 
[16:12:28.411]                   {
[16:12:28.411]                     if (is.function(workers)) 
[16:12:28.411]                       workers <- workers()
[16:12:28.411]                     workers <- structure(as.integer(workers), 
[16:12:28.411]                       class = class(workers))
[16:12:28.411]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.411]                       workers >= 1)
[16:12:28.411]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.411]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.411]                     }
[16:12:28.411]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.411]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.411]                       envir = envir)
[16:12:28.411]                     if (!future$lazy) 
[16:12:28.411]                       future <- run(future)
[16:12:28.411]                     invisible(future)
[16:12:28.411]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.411]                 }
[16:12:28.411]             }
[16:12:28.411]         }
[16:12:28.411]     })
[16:12:28.411]     if (TRUE) {
[16:12:28.411]         base::sink(type = "output", split = FALSE)
[16:12:28.411]         if (TRUE) {
[16:12:28.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.411]         }
[16:12:28.411]         else {
[16:12:28.411]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.411]         }
[16:12:28.411]         base::close(...future.stdout)
[16:12:28.411]         ...future.stdout <- NULL
[16:12:28.411]     }
[16:12:28.411]     ...future.result$conditions <- ...future.conditions
[16:12:28.411]     ...future.result$finished <- base::Sys.time()
[16:12:28.411]     ...future.result
[16:12:28.411] }
[16:12:28.414] MultisessionFuture started
[16:12:28.414] - Launch lazy future ... done
[16:12:28.414] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baca808a8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bafb59bc0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baca808a8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560bafb59bc0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:28.442] resolve() on list ...
[16:12:28.442]  recursive: 0
[16:12:28.442]  length: 6
[16:12:28.442]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:28.442] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.443] - nx: 6
[16:12:28.443] - relay: TRUE
[16:12:28.443] - stdout: TRUE
[16:12:28.443] - signal: TRUE
[16:12:28.443] - resignal: FALSE
[16:12:28.443] - force: TRUE
[16:12:28.443] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.443] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.443]  - until=2
[16:12:28.443]  - relaying element #2
[16:12:28.443] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.443] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.444] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.444]  length: 5 (resolved future 1)
[16:12:28.444] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.444] - Validating connection of MultisessionFuture
[16:12:28.444] - received message: FutureResult
[16:12:28.445] - Received FutureResult
[16:12:28.445] - Erased future from FutureRegistry
[16:12:28.445] result() for ClusterFuture ...
[16:12:28.445] - result already collected: FutureResult
[16:12:28.445] result() for ClusterFuture ... done
[16:12:28.445] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.445] Future #2
[16:12:28.445] result() for ClusterFuture ...
[16:12:28.445] - result already collected: FutureResult
[16:12:28.445] result() for ClusterFuture ... done
[16:12:28.445] result() for ClusterFuture ...
[16:12:28.446] - result already collected: FutureResult
[16:12:28.446] result() for ClusterFuture ... done
[16:12:28.446] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:28.446] - nx: 6
[16:12:28.446] - relay: TRUE
[16:12:28.446] - stdout: TRUE
[16:12:28.446] - signal: TRUE
[16:12:28.446] - resignal: FALSE
[16:12:28.446] - force: TRUE
[16:12:28.446] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.446] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.447]  - until=2
[16:12:28.447]  - relaying element #2
[16:12:28.447] result() for ClusterFuture ...
[16:12:28.447] - result already collected: FutureResult
[16:12:28.447] result() for ClusterFuture ... done
[16:12:28.447] result() for ClusterFuture ...
[16:12:28.447] - result already collected: FutureResult
[16:12:28.447] result() for ClusterFuture ... done
[16:12:28.447] result() for ClusterFuture ...
[16:12:28.447] - result already collected: FutureResult
[16:12:28.447] result() for ClusterFuture ... done
[16:12:28.448] result() for ClusterFuture ...
[16:12:28.448] - result already collected: FutureResult
[16:12:28.448] result() for ClusterFuture ... done
[16:12:28.448] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.448] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.448] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:28.448]  length: 4 (resolved future 2)
[16:12:28.459] signalConditionsASAP(NULL, pos=4) ...
[16:12:28.459] - nx: 6
[16:12:28.459] - relay: TRUE
[16:12:28.459] - stdout: TRUE
[16:12:28.459] - signal: TRUE
[16:12:28.459] - resignal: FALSE
[16:12:28.459] - force: TRUE
[16:12:28.459] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.459] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.460]  - until=5
[16:12:28.460]  - relaying element #3
[16:12:28.460]  - relaying element #5
[16:12:28.460] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:12:28.460] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.460] signalConditionsASAP(NULL, pos=4) ... done
[16:12:28.460]  length: 3 (resolved future 4)
[16:12:28.460] signalConditionsASAP(NULL, pos=5) ...
[16:12:28.460] - nx: 6
[16:12:28.460] - relay: TRUE
[16:12:28.460] - stdout: TRUE
[16:12:28.461] - signal: TRUE
[16:12:28.461] - resignal: FALSE
[16:12:28.461] - force: TRUE
[16:12:28.461] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:12:28.461] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.461]  - until=6
[16:12:28.461]  - relaying element #3
[16:12:28.461]  - relaying element #6
[16:12:28.461] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:12:28.461] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.461] signalConditionsASAP(NULL, pos=5) ... done
[16:12:28.462]  length: 2 (resolved future 5)
[16:12:28.462] signalConditionsASAP(numeric, pos=6) ...
[16:12:28.462] - nx: 6
[16:12:28.462] - relay: TRUE
[16:12:28.462] - stdout: TRUE
[16:12:28.462] - signal: TRUE
[16:12:28.462] - resignal: FALSE
[16:12:28.462] - force: TRUE
[16:12:28.462] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:12:28.462] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.462]  - until=6
[16:12:28.462]  - relaying element #3
[16:12:28.462] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:12:28.463] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.463] signalConditionsASAP(NULL, pos=6) ... done
[16:12:28.463]  length: 1 (resolved future 6)
[16:12:28.473] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.473] - Validating connection of MultisessionFuture
[16:12:28.474] - received message: FutureResult
[16:12:28.474] - Received FutureResult
[16:12:28.474] - Erased future from FutureRegistry
[16:12:28.474] result() for ClusterFuture ...
[16:12:28.474] - result already collected: FutureResult
[16:12:28.474] result() for ClusterFuture ... done
[16:12:28.474] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.474] Future #3
[16:12:28.474] result() for ClusterFuture ...
[16:12:28.474] - result already collected: FutureResult
[16:12:28.475] result() for ClusterFuture ... done
[16:12:28.475] result() for ClusterFuture ...
[16:12:28.475] - result already collected: FutureResult
[16:12:28.475] result() for ClusterFuture ... done
[16:12:28.475] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:28.475] - nx: 6
[16:12:28.475] - relay: TRUE
[16:12:28.475] - stdout: TRUE
[16:12:28.475] - signal: TRUE
[16:12:28.475] - resignal: FALSE
[16:12:28.475] - force: TRUE
[16:12:28.475] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:12:28.476] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.476]  - until=6
[16:12:28.476]  - relaying element #3
[16:12:28.476] result() for ClusterFuture ...
[16:12:28.476] - result already collected: FutureResult
[16:12:28.476] result() for ClusterFuture ... done
[16:12:28.476] result() for ClusterFuture ...
[16:12:28.476] - result already collected: FutureResult
[16:12:28.476] result() for ClusterFuture ... done
[16:12:28.476] result() for ClusterFuture ...
[16:12:28.477] - result already collected: FutureResult
[16:12:28.477] result() for ClusterFuture ... done
[16:12:28.477] result() for ClusterFuture ...
[16:12:28.477] - result already collected: FutureResult
[16:12:28.477] result() for ClusterFuture ... done
[16:12:28.477] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.477] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.477] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:28.477]  length: 0 (resolved future 3)
[16:12:28.477] Relaying remaining futures
[16:12:28.477] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.477] - nx: 6
[16:12:28.478] - relay: TRUE
[16:12:28.478] - stdout: TRUE
[16:12:28.478] - signal: TRUE
[16:12:28.478] - resignal: FALSE
[16:12:28.478] - force: TRUE
[16:12:28.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.478] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:28.478] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.478] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.478] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.478] resolve() on list ... DONE
[16:12:28.479] result() for ClusterFuture ...
[16:12:28.479] - result already collected: FutureResult
[16:12:28.479] result() for ClusterFuture ... done
[16:12:28.479] result() for ClusterFuture ...
[16:12:28.479] - result already collected: FutureResult
[16:12:28.479] result() for ClusterFuture ... done
[16:12:28.479] result() for ClusterFuture ...
[16:12:28.479] - result already collected: FutureResult
[16:12:28.479] result() for ClusterFuture ... done
[16:12:28.479] result() for ClusterFuture ...
[16:12:28.479] - result already collected: FutureResult
[16:12:28.479] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:12:28.483] getGlobalsAndPackages() ...
[16:12:28.485] Searching for globals...
[16:12:28.485] 
[16:12:28.485] Searching for globals ... DONE
[16:12:28.486] - globals: [0] <none>
[16:12:28.486] getGlobalsAndPackages() ... DONE
[16:12:28.486] run() for ‘Future’ ...
[16:12:28.486] - state: ‘created’
[16:12:28.486] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.501]   - Field: ‘node’
[16:12:28.501]   - Field: ‘label’
[16:12:28.501]   - Field: ‘local’
[16:12:28.501]   - Field: ‘owner’
[16:12:28.501]   - Field: ‘envir’
[16:12:28.501]   - Field: ‘workers’
[16:12:28.501]   - Field: ‘packages’
[16:12:28.501]   - Field: ‘gc’
[16:12:28.501]   - Field: ‘conditions’
[16:12:28.502]   - Field: ‘persistent’
[16:12:28.502]   - Field: ‘expr’
[16:12:28.502]   - Field: ‘uuid’
[16:12:28.502]   - Field: ‘seed’
[16:12:28.502]   - Field: ‘version’
[16:12:28.502]   - Field: ‘result’
[16:12:28.502]   - Field: ‘asynchronous’
[16:12:28.502]   - Field: ‘calls’
[16:12:28.502]   - Field: ‘globals’
[16:12:28.502]   - Field: ‘stdout’
[16:12:28.502]   - Field: ‘earlySignal’
[16:12:28.503]   - Field: ‘lazy’
[16:12:28.503]   - Field: ‘state’
[16:12:28.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.503] - Launch lazy future ...
[16:12:28.503] Packages needed by the future expression (n = 0): <none>
[16:12:28.503] Packages needed by future strategies (n = 0): <none>
[16:12:28.504] {
[16:12:28.504]     {
[16:12:28.504]         {
[16:12:28.504]             ...future.startTime <- base::Sys.time()
[16:12:28.504]             {
[16:12:28.504]                 {
[16:12:28.504]                   {
[16:12:28.504]                     {
[16:12:28.504]                       base::local({
[16:12:28.504]                         has_future <- base::requireNamespace("future", 
[16:12:28.504]                           quietly = TRUE)
[16:12:28.504]                         if (has_future) {
[16:12:28.504]                           ns <- base::getNamespace("future")
[16:12:28.504]                           version <- ns[[".package"]][["version"]]
[16:12:28.504]                           if (is.null(version)) 
[16:12:28.504]                             version <- utils::packageVersion("future")
[16:12:28.504]                         }
[16:12:28.504]                         else {
[16:12:28.504]                           version <- NULL
[16:12:28.504]                         }
[16:12:28.504]                         if (!has_future || version < "1.8.0") {
[16:12:28.504]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.504]                             "", base::R.version$version.string), 
[16:12:28.504]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.504]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.504]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.504]                               "release", "version")], collapse = " "), 
[16:12:28.504]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.504]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.504]                             info)
[16:12:28.504]                           info <- base::paste(info, collapse = "; ")
[16:12:28.504]                           if (!has_future) {
[16:12:28.504]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.504]                               info)
[16:12:28.504]                           }
[16:12:28.504]                           else {
[16:12:28.504]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.504]                               info, version)
[16:12:28.504]                           }
[16:12:28.504]                           base::stop(msg)
[16:12:28.504]                         }
[16:12:28.504]                       })
[16:12:28.504]                     }
[16:12:28.504]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.504]                     base::options(mc.cores = 1L)
[16:12:28.504]                   }
[16:12:28.504]                   options(future.plan = NULL)
[16:12:28.504]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.504]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.504]                 }
[16:12:28.504]                 ...future.workdir <- getwd()
[16:12:28.504]             }
[16:12:28.504]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.504]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.504]         }
[16:12:28.504]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.504]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.504]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.504]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.504]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.504]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.504]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.504]             base::names(...future.oldOptions))
[16:12:28.504]     }
[16:12:28.504]     if (FALSE) {
[16:12:28.504]     }
[16:12:28.504]     else {
[16:12:28.504]         if (TRUE) {
[16:12:28.504]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.504]                 open = "w")
[16:12:28.504]         }
[16:12:28.504]         else {
[16:12:28.504]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.504]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.504]         }
[16:12:28.504]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.504]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.504]             base::sink(type = "output", split = FALSE)
[16:12:28.504]             base::close(...future.stdout)
[16:12:28.504]         }, add = TRUE)
[16:12:28.504]     }
[16:12:28.504]     ...future.frame <- base::sys.nframe()
[16:12:28.504]     ...future.conditions <- base::list()
[16:12:28.504]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.504]     if (FALSE) {
[16:12:28.504]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.504]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.504]     }
[16:12:28.504]     ...future.result <- base::tryCatch({
[16:12:28.504]         base::withCallingHandlers({
[16:12:28.504]             ...future.value <- base::withVisible(base::local({
[16:12:28.504]                 ...future.makeSendCondition <- local({
[16:12:28.504]                   sendCondition <- NULL
[16:12:28.504]                   function(frame = 1L) {
[16:12:28.504]                     if (is.function(sendCondition)) 
[16:12:28.504]                       return(sendCondition)
[16:12:28.504]                     ns <- getNamespace("parallel")
[16:12:28.504]                     if (exists("sendData", mode = "function", 
[16:12:28.504]                       envir = ns)) {
[16:12:28.504]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.504]                         envir = ns)
[16:12:28.504]                       envir <- sys.frame(frame)
[16:12:28.504]                       master <- NULL
[16:12:28.504]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.504]                         !identical(envir, emptyenv())) {
[16:12:28.504]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.504]                           inherits = FALSE)) {
[16:12:28.504]                           master <- get("master", mode = "list", 
[16:12:28.504]                             envir = envir, inherits = FALSE)
[16:12:28.504]                           if (inherits(master, c("SOCKnode", 
[16:12:28.504]                             "SOCK0node"))) {
[16:12:28.504]                             sendCondition <<- function(cond) {
[16:12:28.504]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.504]                                 success = TRUE)
[16:12:28.504]                               parallel_sendData(master, data)
[16:12:28.504]                             }
[16:12:28.504]                             return(sendCondition)
[16:12:28.504]                           }
[16:12:28.504]                         }
[16:12:28.504]                         frame <- frame + 1L
[16:12:28.504]                         envir <- sys.frame(frame)
[16:12:28.504]                       }
[16:12:28.504]                     }
[16:12:28.504]                     sendCondition <<- function(cond) NULL
[16:12:28.504]                   }
[16:12:28.504]                 })
[16:12:28.504]                 withCallingHandlers({
[16:12:28.504]                   2
[16:12:28.504]                 }, immediateCondition = function(cond) {
[16:12:28.504]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.504]                   sendCondition(cond)
[16:12:28.504]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.504]                   {
[16:12:28.504]                     inherits <- base::inherits
[16:12:28.504]                     invokeRestart <- base::invokeRestart
[16:12:28.504]                     is.null <- base::is.null
[16:12:28.504]                     muffled <- FALSE
[16:12:28.504]                     if (inherits(cond, "message")) {
[16:12:28.504]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.504]                       if (muffled) 
[16:12:28.504]                         invokeRestart("muffleMessage")
[16:12:28.504]                     }
[16:12:28.504]                     else if (inherits(cond, "warning")) {
[16:12:28.504]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.504]                       if (muffled) 
[16:12:28.504]                         invokeRestart("muffleWarning")
[16:12:28.504]                     }
[16:12:28.504]                     else if (inherits(cond, "condition")) {
[16:12:28.504]                       if (!is.null(pattern)) {
[16:12:28.504]                         computeRestarts <- base::computeRestarts
[16:12:28.504]                         grepl <- base::grepl
[16:12:28.504]                         restarts <- computeRestarts(cond)
[16:12:28.504]                         for (restart in restarts) {
[16:12:28.504]                           name <- restart$name
[16:12:28.504]                           if (is.null(name)) 
[16:12:28.504]                             next
[16:12:28.504]                           if (!grepl(pattern, name)) 
[16:12:28.504]                             next
[16:12:28.504]                           invokeRestart(restart)
[16:12:28.504]                           muffled <- TRUE
[16:12:28.504]                           break
[16:12:28.504]                         }
[16:12:28.504]                       }
[16:12:28.504]                     }
[16:12:28.504]                     invisible(muffled)
[16:12:28.504]                   }
[16:12:28.504]                   muffleCondition(cond)
[16:12:28.504]                 })
[16:12:28.504]             }))
[16:12:28.504]             future::FutureResult(value = ...future.value$value, 
[16:12:28.504]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.504]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.504]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.504]                     ...future.globalenv.names))
[16:12:28.504]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.504]         }, condition = base::local({
[16:12:28.504]             c <- base::c
[16:12:28.504]             inherits <- base::inherits
[16:12:28.504]             invokeRestart <- base::invokeRestart
[16:12:28.504]             length <- base::length
[16:12:28.504]             list <- base::list
[16:12:28.504]             seq.int <- base::seq.int
[16:12:28.504]             signalCondition <- base::signalCondition
[16:12:28.504]             sys.calls <- base::sys.calls
[16:12:28.504]             `[[` <- base::`[[`
[16:12:28.504]             `+` <- base::`+`
[16:12:28.504]             `<<-` <- base::`<<-`
[16:12:28.504]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.504]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.504]                   3L)]
[16:12:28.504]             }
[16:12:28.504]             function(cond) {
[16:12:28.504]                 is_error <- inherits(cond, "error")
[16:12:28.504]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.504]                   NULL)
[16:12:28.504]                 if (is_error) {
[16:12:28.504]                   sessionInformation <- function() {
[16:12:28.504]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.504]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.504]                       search = base::search(), system = base::Sys.info())
[16:12:28.504]                   }
[16:12:28.504]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.504]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.504]                     cond$call), session = sessionInformation(), 
[16:12:28.504]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.504]                   signalCondition(cond)
[16:12:28.504]                 }
[16:12:28.504]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.504]                 "immediateCondition"))) {
[16:12:28.504]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.504]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.504]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.504]                   if (TRUE && !signal) {
[16:12:28.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.504]                     {
[16:12:28.504]                       inherits <- base::inherits
[16:12:28.504]                       invokeRestart <- base::invokeRestart
[16:12:28.504]                       is.null <- base::is.null
[16:12:28.504]                       muffled <- FALSE
[16:12:28.504]                       if (inherits(cond, "message")) {
[16:12:28.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.504]                         if (muffled) 
[16:12:28.504]                           invokeRestart("muffleMessage")
[16:12:28.504]                       }
[16:12:28.504]                       else if (inherits(cond, "warning")) {
[16:12:28.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.504]                         if (muffled) 
[16:12:28.504]                           invokeRestart("muffleWarning")
[16:12:28.504]                       }
[16:12:28.504]                       else if (inherits(cond, "condition")) {
[16:12:28.504]                         if (!is.null(pattern)) {
[16:12:28.504]                           computeRestarts <- base::computeRestarts
[16:12:28.504]                           grepl <- base::grepl
[16:12:28.504]                           restarts <- computeRestarts(cond)
[16:12:28.504]                           for (restart in restarts) {
[16:12:28.504]                             name <- restart$name
[16:12:28.504]                             if (is.null(name)) 
[16:12:28.504]                               next
[16:12:28.504]                             if (!grepl(pattern, name)) 
[16:12:28.504]                               next
[16:12:28.504]                             invokeRestart(restart)
[16:12:28.504]                             muffled <- TRUE
[16:12:28.504]                             break
[16:12:28.504]                           }
[16:12:28.504]                         }
[16:12:28.504]                       }
[16:12:28.504]                       invisible(muffled)
[16:12:28.504]                     }
[16:12:28.504]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.504]                   }
[16:12:28.504]                 }
[16:12:28.504]                 else {
[16:12:28.504]                   if (TRUE) {
[16:12:28.504]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.504]                     {
[16:12:28.504]                       inherits <- base::inherits
[16:12:28.504]                       invokeRestart <- base::invokeRestart
[16:12:28.504]                       is.null <- base::is.null
[16:12:28.504]                       muffled <- FALSE
[16:12:28.504]                       if (inherits(cond, "message")) {
[16:12:28.504]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.504]                         if (muffled) 
[16:12:28.504]                           invokeRestart("muffleMessage")
[16:12:28.504]                       }
[16:12:28.504]                       else if (inherits(cond, "warning")) {
[16:12:28.504]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.504]                         if (muffled) 
[16:12:28.504]                           invokeRestart("muffleWarning")
[16:12:28.504]                       }
[16:12:28.504]                       else if (inherits(cond, "condition")) {
[16:12:28.504]                         if (!is.null(pattern)) {
[16:12:28.504]                           computeRestarts <- base::computeRestarts
[16:12:28.504]                           grepl <- base::grepl
[16:12:28.504]                           restarts <- computeRestarts(cond)
[16:12:28.504]                           for (restart in restarts) {
[16:12:28.504]                             name <- restart$name
[16:12:28.504]                             if (is.null(name)) 
[16:12:28.504]                               next
[16:12:28.504]                             if (!grepl(pattern, name)) 
[16:12:28.504]                               next
[16:12:28.504]                             invokeRestart(restart)
[16:12:28.504]                             muffled <- TRUE
[16:12:28.504]                             break
[16:12:28.504]                           }
[16:12:28.504]                         }
[16:12:28.504]                       }
[16:12:28.504]                       invisible(muffled)
[16:12:28.504]                     }
[16:12:28.504]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.504]                   }
[16:12:28.504]                 }
[16:12:28.504]             }
[16:12:28.504]         }))
[16:12:28.504]     }, error = function(ex) {
[16:12:28.504]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.504]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.504]                 ...future.rng), started = ...future.startTime, 
[16:12:28.504]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.504]             version = "1.8"), class = "FutureResult")
[16:12:28.504]     }, finally = {
[16:12:28.504]         if (!identical(...future.workdir, getwd())) 
[16:12:28.504]             setwd(...future.workdir)
[16:12:28.504]         {
[16:12:28.504]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.504]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.504]             }
[16:12:28.504]             base::options(...future.oldOptions)
[16:12:28.504]             if (.Platform$OS.type == "windows") {
[16:12:28.504]                 old_names <- names(...future.oldEnvVars)
[16:12:28.504]                 envs <- base::Sys.getenv()
[16:12:28.504]                 names <- names(envs)
[16:12:28.504]                 common <- intersect(names, old_names)
[16:12:28.504]                 added <- setdiff(names, old_names)
[16:12:28.504]                 removed <- setdiff(old_names, names)
[16:12:28.504]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.504]                   envs[common]]
[16:12:28.504]                 NAMES <- toupper(changed)
[16:12:28.504]                 args <- list()
[16:12:28.504]                 for (kk in seq_along(NAMES)) {
[16:12:28.504]                   name <- changed[[kk]]
[16:12:28.504]                   NAME <- NAMES[[kk]]
[16:12:28.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.504]                     next
[16:12:28.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.504]                 }
[16:12:28.504]                 NAMES <- toupper(added)
[16:12:28.504]                 for (kk in seq_along(NAMES)) {
[16:12:28.504]                   name <- added[[kk]]
[16:12:28.504]                   NAME <- NAMES[[kk]]
[16:12:28.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.504]                     next
[16:12:28.504]                   args[[name]] <- ""
[16:12:28.504]                 }
[16:12:28.504]                 NAMES <- toupper(removed)
[16:12:28.504]                 for (kk in seq_along(NAMES)) {
[16:12:28.504]                   name <- removed[[kk]]
[16:12:28.504]                   NAME <- NAMES[[kk]]
[16:12:28.504]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.504]                     next
[16:12:28.504]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.504]                 }
[16:12:28.504]                 if (length(args) > 0) 
[16:12:28.504]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.504]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.504]             }
[16:12:28.504]             else {
[16:12:28.504]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.504]             }
[16:12:28.504]             {
[16:12:28.504]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.504]                   0L) {
[16:12:28.504]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.504]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.504]                   base::options(opts)
[16:12:28.504]                 }
[16:12:28.504]                 {
[16:12:28.504]                   {
[16:12:28.504]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.504]                     NULL
[16:12:28.504]                   }
[16:12:28.504]                   options(future.plan = NULL)
[16:12:28.504]                   if (is.na(NA_character_)) 
[16:12:28.504]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.504]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.504]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.504]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.504]                     envir = parent.frame()) 
[16:12:28.504]                   {
[16:12:28.504]                     if (is.function(workers)) 
[16:12:28.504]                       workers <- workers()
[16:12:28.504]                     workers <- structure(as.integer(workers), 
[16:12:28.504]                       class = class(workers))
[16:12:28.504]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.504]                       workers >= 1)
[16:12:28.504]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.504]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.504]                     }
[16:12:28.504]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.504]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.504]                       envir = envir)
[16:12:28.504]                     if (!future$lazy) 
[16:12:28.504]                       future <- run(future)
[16:12:28.504]                     invisible(future)
[16:12:28.504]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.504]                 }
[16:12:28.504]             }
[16:12:28.504]         }
[16:12:28.504]     })
[16:12:28.504]     if (TRUE) {
[16:12:28.504]         base::sink(type = "output", split = FALSE)
[16:12:28.504]         if (TRUE) {
[16:12:28.504]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.504]         }
[16:12:28.504]         else {
[16:12:28.504]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.504]         }
[16:12:28.504]         base::close(...future.stdout)
[16:12:28.504]         ...future.stdout <- NULL
[16:12:28.504]     }
[16:12:28.504]     ...future.result$conditions <- ...future.conditions
[16:12:28.504]     ...future.result$finished <- base::Sys.time()
[16:12:28.504]     ...future.result
[16:12:28.504] }
[16:12:28.507] MultisessionFuture started
[16:12:28.507] - Launch lazy future ... done
[16:12:28.507] run() for ‘MultisessionFuture’ ... done
[16:12:28.507] getGlobalsAndPackages() ...
[16:12:28.507] Searching for globals...
[16:12:28.508] 
[16:12:28.508] Searching for globals ... DONE
[16:12:28.508] - globals: [0] <none>
[16:12:28.508] getGlobalsAndPackages() ... DONE
[16:12:28.508] run() for ‘Future’ ...
[16:12:28.508] - state: ‘created’
[16:12:28.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:28.522]   - Field: ‘node’
[16:12:28.523]   - Field: ‘label’
[16:12:28.523]   - Field: ‘local’
[16:12:28.523]   - Field: ‘owner’
[16:12:28.523]   - Field: ‘envir’
[16:12:28.523]   - Field: ‘workers’
[16:12:28.523]   - Field: ‘packages’
[16:12:28.523]   - Field: ‘gc’
[16:12:28.523]   - Field: ‘conditions’
[16:12:28.523]   - Field: ‘persistent’
[16:12:28.523]   - Field: ‘expr’
[16:12:28.523]   - Field: ‘uuid’
[16:12:28.524]   - Field: ‘seed’
[16:12:28.524]   - Field: ‘version’
[16:12:28.524]   - Field: ‘result’
[16:12:28.524]   - Field: ‘asynchronous’
[16:12:28.524]   - Field: ‘calls’
[16:12:28.524]   - Field: ‘globals’
[16:12:28.524]   - Field: ‘stdout’
[16:12:28.524]   - Field: ‘earlySignal’
[16:12:28.524]   - Field: ‘lazy’
[16:12:28.524]   - Field: ‘state’
[16:12:28.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:28.525] - Launch lazy future ...
[16:12:28.525] Packages needed by the future expression (n = 0): <none>
[16:12:28.525] Packages needed by future strategies (n = 0): <none>
[16:12:28.525] {
[16:12:28.525]     {
[16:12:28.525]         {
[16:12:28.525]             ...future.startTime <- base::Sys.time()
[16:12:28.525]             {
[16:12:28.525]                 {
[16:12:28.525]                   {
[16:12:28.525]                     {
[16:12:28.525]                       base::local({
[16:12:28.525]                         has_future <- base::requireNamespace("future", 
[16:12:28.525]                           quietly = TRUE)
[16:12:28.525]                         if (has_future) {
[16:12:28.525]                           ns <- base::getNamespace("future")
[16:12:28.525]                           version <- ns[[".package"]][["version"]]
[16:12:28.525]                           if (is.null(version)) 
[16:12:28.525]                             version <- utils::packageVersion("future")
[16:12:28.525]                         }
[16:12:28.525]                         else {
[16:12:28.525]                           version <- NULL
[16:12:28.525]                         }
[16:12:28.525]                         if (!has_future || version < "1.8.0") {
[16:12:28.525]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.525]                             "", base::R.version$version.string), 
[16:12:28.525]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.525]                               "release", "version")], collapse = " "), 
[16:12:28.525]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.525]                             info)
[16:12:28.525]                           info <- base::paste(info, collapse = "; ")
[16:12:28.525]                           if (!has_future) {
[16:12:28.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.525]                               info)
[16:12:28.525]                           }
[16:12:28.525]                           else {
[16:12:28.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.525]                               info, version)
[16:12:28.525]                           }
[16:12:28.525]                           base::stop(msg)
[16:12:28.525]                         }
[16:12:28.525]                       })
[16:12:28.525]                     }
[16:12:28.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.525]                     base::options(mc.cores = 1L)
[16:12:28.525]                   }
[16:12:28.525]                   options(future.plan = NULL)
[16:12:28.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.525]                 }
[16:12:28.525]                 ...future.workdir <- getwd()
[16:12:28.525]             }
[16:12:28.525]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.525]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.525]         }
[16:12:28.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.525]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.525]             base::names(...future.oldOptions))
[16:12:28.525]     }
[16:12:28.525]     if (FALSE) {
[16:12:28.525]     }
[16:12:28.525]     else {
[16:12:28.525]         if (TRUE) {
[16:12:28.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.525]                 open = "w")
[16:12:28.525]         }
[16:12:28.525]         else {
[16:12:28.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.525]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.525]         }
[16:12:28.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.525]             base::sink(type = "output", split = FALSE)
[16:12:28.525]             base::close(...future.stdout)
[16:12:28.525]         }, add = TRUE)
[16:12:28.525]     }
[16:12:28.525]     ...future.frame <- base::sys.nframe()
[16:12:28.525]     ...future.conditions <- base::list()
[16:12:28.525]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.525]     if (FALSE) {
[16:12:28.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.525]     }
[16:12:28.525]     ...future.result <- base::tryCatch({
[16:12:28.525]         base::withCallingHandlers({
[16:12:28.525]             ...future.value <- base::withVisible(base::local({
[16:12:28.525]                 ...future.makeSendCondition <- local({
[16:12:28.525]                   sendCondition <- NULL
[16:12:28.525]                   function(frame = 1L) {
[16:12:28.525]                     if (is.function(sendCondition)) 
[16:12:28.525]                       return(sendCondition)
[16:12:28.525]                     ns <- getNamespace("parallel")
[16:12:28.525]                     if (exists("sendData", mode = "function", 
[16:12:28.525]                       envir = ns)) {
[16:12:28.525]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:28.525]                         envir = ns)
[16:12:28.525]                       envir <- sys.frame(frame)
[16:12:28.525]                       master <- NULL
[16:12:28.525]                       while (!identical(envir, .GlobalEnv) && 
[16:12:28.525]                         !identical(envir, emptyenv())) {
[16:12:28.525]                         if (exists("master", mode = "list", envir = envir, 
[16:12:28.525]                           inherits = FALSE)) {
[16:12:28.525]                           master <- get("master", mode = "list", 
[16:12:28.525]                             envir = envir, inherits = FALSE)
[16:12:28.525]                           if (inherits(master, c("SOCKnode", 
[16:12:28.525]                             "SOCK0node"))) {
[16:12:28.525]                             sendCondition <<- function(cond) {
[16:12:28.525]                               data <- list(type = "VALUE", value = cond, 
[16:12:28.525]                                 success = TRUE)
[16:12:28.525]                               parallel_sendData(master, data)
[16:12:28.525]                             }
[16:12:28.525]                             return(sendCondition)
[16:12:28.525]                           }
[16:12:28.525]                         }
[16:12:28.525]                         frame <- frame + 1L
[16:12:28.525]                         envir <- sys.frame(frame)
[16:12:28.525]                       }
[16:12:28.525]                     }
[16:12:28.525]                     sendCondition <<- function(cond) NULL
[16:12:28.525]                   }
[16:12:28.525]                 })
[16:12:28.525]                 withCallingHandlers({
[16:12:28.525]                   NULL
[16:12:28.525]                 }, immediateCondition = function(cond) {
[16:12:28.525]                   sendCondition <- ...future.makeSendCondition()
[16:12:28.525]                   sendCondition(cond)
[16:12:28.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.525]                   {
[16:12:28.525]                     inherits <- base::inherits
[16:12:28.525]                     invokeRestart <- base::invokeRestart
[16:12:28.525]                     is.null <- base::is.null
[16:12:28.525]                     muffled <- FALSE
[16:12:28.525]                     if (inherits(cond, "message")) {
[16:12:28.525]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.525]                       if (muffled) 
[16:12:28.525]                         invokeRestart("muffleMessage")
[16:12:28.525]                     }
[16:12:28.525]                     else if (inherits(cond, "warning")) {
[16:12:28.525]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.525]                       if (muffled) 
[16:12:28.525]                         invokeRestart("muffleWarning")
[16:12:28.525]                     }
[16:12:28.525]                     else if (inherits(cond, "condition")) {
[16:12:28.525]                       if (!is.null(pattern)) {
[16:12:28.525]                         computeRestarts <- base::computeRestarts
[16:12:28.525]                         grepl <- base::grepl
[16:12:28.525]                         restarts <- computeRestarts(cond)
[16:12:28.525]                         for (restart in restarts) {
[16:12:28.525]                           name <- restart$name
[16:12:28.525]                           if (is.null(name)) 
[16:12:28.525]                             next
[16:12:28.525]                           if (!grepl(pattern, name)) 
[16:12:28.525]                             next
[16:12:28.525]                           invokeRestart(restart)
[16:12:28.525]                           muffled <- TRUE
[16:12:28.525]                           break
[16:12:28.525]                         }
[16:12:28.525]                       }
[16:12:28.525]                     }
[16:12:28.525]                     invisible(muffled)
[16:12:28.525]                   }
[16:12:28.525]                   muffleCondition(cond)
[16:12:28.525]                 })
[16:12:28.525]             }))
[16:12:28.525]             future::FutureResult(value = ...future.value$value, 
[16:12:28.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.525]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.525]                     ...future.globalenv.names))
[16:12:28.525]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.525]         }, condition = base::local({
[16:12:28.525]             c <- base::c
[16:12:28.525]             inherits <- base::inherits
[16:12:28.525]             invokeRestart <- base::invokeRestart
[16:12:28.525]             length <- base::length
[16:12:28.525]             list <- base::list
[16:12:28.525]             seq.int <- base::seq.int
[16:12:28.525]             signalCondition <- base::signalCondition
[16:12:28.525]             sys.calls <- base::sys.calls
[16:12:28.525]             `[[` <- base::`[[`
[16:12:28.525]             `+` <- base::`+`
[16:12:28.525]             `<<-` <- base::`<<-`
[16:12:28.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.525]                   3L)]
[16:12:28.525]             }
[16:12:28.525]             function(cond) {
[16:12:28.525]                 is_error <- inherits(cond, "error")
[16:12:28.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.525]                   NULL)
[16:12:28.525]                 if (is_error) {
[16:12:28.525]                   sessionInformation <- function() {
[16:12:28.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.525]                       search = base::search(), system = base::Sys.info())
[16:12:28.525]                   }
[16:12:28.525]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.525]                     cond$call), session = sessionInformation(), 
[16:12:28.525]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.525]                   signalCondition(cond)
[16:12:28.525]                 }
[16:12:28.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.525]                 "immediateCondition"))) {
[16:12:28.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.525]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.525]                   if (TRUE && !signal) {
[16:12:28.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.525]                     {
[16:12:28.525]                       inherits <- base::inherits
[16:12:28.525]                       invokeRestart <- base::invokeRestart
[16:12:28.525]                       is.null <- base::is.null
[16:12:28.525]                       muffled <- FALSE
[16:12:28.525]                       if (inherits(cond, "message")) {
[16:12:28.525]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.525]                         if (muffled) 
[16:12:28.525]                           invokeRestart("muffleMessage")
[16:12:28.525]                       }
[16:12:28.525]                       else if (inherits(cond, "warning")) {
[16:12:28.525]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.525]                         if (muffled) 
[16:12:28.525]                           invokeRestart("muffleWarning")
[16:12:28.525]                       }
[16:12:28.525]                       else if (inherits(cond, "condition")) {
[16:12:28.525]                         if (!is.null(pattern)) {
[16:12:28.525]                           computeRestarts <- base::computeRestarts
[16:12:28.525]                           grepl <- base::grepl
[16:12:28.525]                           restarts <- computeRestarts(cond)
[16:12:28.525]                           for (restart in restarts) {
[16:12:28.525]                             name <- restart$name
[16:12:28.525]                             if (is.null(name)) 
[16:12:28.525]                               next
[16:12:28.525]                             if (!grepl(pattern, name)) 
[16:12:28.525]                               next
[16:12:28.525]                             invokeRestart(restart)
[16:12:28.525]                             muffled <- TRUE
[16:12:28.525]                             break
[16:12:28.525]                           }
[16:12:28.525]                         }
[16:12:28.525]                       }
[16:12:28.525]                       invisible(muffled)
[16:12:28.525]                     }
[16:12:28.525]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.525]                   }
[16:12:28.525]                 }
[16:12:28.525]                 else {
[16:12:28.525]                   if (TRUE) {
[16:12:28.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.525]                     {
[16:12:28.525]                       inherits <- base::inherits
[16:12:28.525]                       invokeRestart <- base::invokeRestart
[16:12:28.525]                       is.null <- base::is.null
[16:12:28.525]                       muffled <- FALSE
[16:12:28.525]                       if (inherits(cond, "message")) {
[16:12:28.525]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.525]                         if (muffled) 
[16:12:28.525]                           invokeRestart("muffleMessage")
[16:12:28.525]                       }
[16:12:28.525]                       else if (inherits(cond, "warning")) {
[16:12:28.525]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.525]                         if (muffled) 
[16:12:28.525]                           invokeRestart("muffleWarning")
[16:12:28.525]                       }
[16:12:28.525]                       else if (inherits(cond, "condition")) {
[16:12:28.525]                         if (!is.null(pattern)) {
[16:12:28.525]                           computeRestarts <- base::computeRestarts
[16:12:28.525]                           grepl <- base::grepl
[16:12:28.525]                           restarts <- computeRestarts(cond)
[16:12:28.525]                           for (restart in restarts) {
[16:12:28.525]                             name <- restart$name
[16:12:28.525]                             if (is.null(name)) 
[16:12:28.525]                               next
[16:12:28.525]                             if (!grepl(pattern, name)) 
[16:12:28.525]                               next
[16:12:28.525]                             invokeRestart(restart)
[16:12:28.525]                             muffled <- TRUE
[16:12:28.525]                             break
[16:12:28.525]                           }
[16:12:28.525]                         }
[16:12:28.525]                       }
[16:12:28.525]                       invisible(muffled)
[16:12:28.525]                     }
[16:12:28.525]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.525]                   }
[16:12:28.525]                 }
[16:12:28.525]             }
[16:12:28.525]         }))
[16:12:28.525]     }, error = function(ex) {
[16:12:28.525]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.525]                 ...future.rng), started = ...future.startTime, 
[16:12:28.525]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.525]             version = "1.8"), class = "FutureResult")
[16:12:28.525]     }, finally = {
[16:12:28.525]         if (!identical(...future.workdir, getwd())) 
[16:12:28.525]             setwd(...future.workdir)
[16:12:28.525]         {
[16:12:28.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.525]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.525]             }
[16:12:28.525]             base::options(...future.oldOptions)
[16:12:28.525]             if (.Platform$OS.type == "windows") {
[16:12:28.525]                 old_names <- names(...future.oldEnvVars)
[16:12:28.525]                 envs <- base::Sys.getenv()
[16:12:28.525]                 names <- names(envs)
[16:12:28.525]                 common <- intersect(names, old_names)
[16:12:28.525]                 added <- setdiff(names, old_names)
[16:12:28.525]                 removed <- setdiff(old_names, names)
[16:12:28.525]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.525]                   envs[common]]
[16:12:28.525]                 NAMES <- toupper(changed)
[16:12:28.525]                 args <- list()
[16:12:28.525]                 for (kk in seq_along(NAMES)) {
[16:12:28.525]                   name <- changed[[kk]]
[16:12:28.525]                   NAME <- NAMES[[kk]]
[16:12:28.525]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.525]                     next
[16:12:28.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.525]                 }
[16:12:28.525]                 NAMES <- toupper(added)
[16:12:28.525]                 for (kk in seq_along(NAMES)) {
[16:12:28.525]                   name <- added[[kk]]
[16:12:28.525]                   NAME <- NAMES[[kk]]
[16:12:28.525]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.525]                     next
[16:12:28.525]                   args[[name]] <- ""
[16:12:28.525]                 }
[16:12:28.525]                 NAMES <- toupper(removed)
[16:12:28.525]                 for (kk in seq_along(NAMES)) {
[16:12:28.525]                   name <- removed[[kk]]
[16:12:28.525]                   NAME <- NAMES[[kk]]
[16:12:28.525]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.525]                     next
[16:12:28.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.525]                 }
[16:12:28.525]                 if (length(args) > 0) 
[16:12:28.525]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.525]             }
[16:12:28.525]             else {
[16:12:28.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.525]             }
[16:12:28.525]             {
[16:12:28.525]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.525]                   0L) {
[16:12:28.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.525]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.525]                   base::options(opts)
[16:12:28.525]                 }
[16:12:28.525]                 {
[16:12:28.525]                   {
[16:12:28.525]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.525]                     NULL
[16:12:28.525]                   }
[16:12:28.525]                   options(future.plan = NULL)
[16:12:28.525]                   if (is.na(NA_character_)) 
[16:12:28.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.525]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:28.525]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:28.525]                     envir = parent.frame()) 
[16:12:28.525]                   {
[16:12:28.525]                     if (is.function(workers)) 
[16:12:28.525]                       workers <- workers()
[16:12:28.525]                     workers <- structure(as.integer(workers), 
[16:12:28.525]                       class = class(workers))
[16:12:28.525]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:28.525]                       workers >= 1)
[16:12:28.525]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:28.525]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:28.525]                     }
[16:12:28.525]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:28.525]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:28.525]                       envir = envir)
[16:12:28.525]                     if (!future$lazy) 
[16:12:28.525]                       future <- run(future)
[16:12:28.525]                     invisible(future)
[16:12:28.525]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.525]                 }
[16:12:28.525]             }
[16:12:28.525]         }
[16:12:28.525]     })
[16:12:28.525]     if (TRUE) {
[16:12:28.525]         base::sink(type = "output", split = FALSE)
[16:12:28.525]         if (TRUE) {
[16:12:28.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.525]         }
[16:12:28.525]         else {
[16:12:28.525]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.525]         }
[16:12:28.525]         base::close(...future.stdout)
[16:12:28.525]         ...future.stdout <- NULL
[16:12:28.525]     }
[16:12:28.525]     ...future.result$conditions <- ...future.conditions
[16:12:28.525]     ...future.result$finished <- base::Sys.time()
[16:12:28.525]     ...future.result
[16:12:28.525] }
[16:12:28.528] MultisessionFuture started
[16:12:28.528] - Launch lazy future ... done
[16:12:28.528] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baf47b798> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baec99df8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baf47b798> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x560baec99df8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[16:12:28.557] resolve() on list ...
[16:12:28.557]  recursive: 0
[16:12:28.557]  length: 6
[16:12:28.557]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[16:12:28.557] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.557] - nx: 6
[16:12:28.557] - relay: TRUE
[16:12:28.557] - stdout: TRUE
[16:12:28.558] - signal: TRUE
[16:12:28.558] - resignal: FALSE
[16:12:28.558] - force: TRUE
[16:12:28.558] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.558] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.558]  - until=2
[16:12:28.558]  - relaying element #2
[16:12:28.558] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.558] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.558] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.558]  length: 5 (resolved future 1)
[16:12:28.559] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.559] - Validating connection of MultisessionFuture
[16:12:28.559] - received message: FutureResult
[16:12:28.559] - Received FutureResult
[16:12:28.559] - Erased future from FutureRegistry
[16:12:28.559] result() for ClusterFuture ...
[16:12:28.560] - result already collected: FutureResult
[16:12:28.560] result() for ClusterFuture ... done
[16:12:28.560] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.560] Future #2
[16:12:28.560] result() for ClusterFuture ...
[16:12:28.560] - result already collected: FutureResult
[16:12:28.560] result() for ClusterFuture ... done
[16:12:28.560] result() for ClusterFuture ...
[16:12:28.560] - result already collected: FutureResult
[16:12:28.560] result() for ClusterFuture ... done
[16:12:28.561] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:28.561] - nx: 6
[16:12:28.561] - relay: TRUE
[16:12:28.561] - stdout: TRUE
[16:12:28.561] - signal: TRUE
[16:12:28.561] - resignal: FALSE
[16:12:28.561] - force: TRUE
[16:12:28.561] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.561] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:28.561]  - until=2
[16:12:28.561]  - relaying element #2
[16:12:28.561] result() for ClusterFuture ...
[16:12:28.562] - result already collected: FutureResult
[16:12:28.562] result() for ClusterFuture ... done
[16:12:28.562] result() for ClusterFuture ...
[16:12:28.562] - result already collected: FutureResult
[16:12:28.562] result() for ClusterFuture ... done
[16:12:28.562] result() for ClusterFuture ...
[16:12:28.562] - result already collected: FutureResult
[16:12:28.562] result() for ClusterFuture ... done
[16:12:28.562] result() for ClusterFuture ...
[16:12:28.562] - result already collected: FutureResult
[16:12:28.562] result() for ClusterFuture ... done
[16:12:28.563] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.563] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.563] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:28.563]  length: 4 (resolved future 2)
[16:12:28.573] signalConditionsASAP(NULL, pos=4) ...
[16:12:28.573] - nx: 6
[16:12:28.574] - relay: TRUE
[16:12:28.574] - stdout: TRUE
[16:12:28.574] - signal: TRUE
[16:12:28.574] - resignal: FALSE
[16:12:28.574] - force: TRUE
[16:12:28.574] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.574] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.574]  - until=5
[16:12:28.574]  - relaying element #3
[16:12:28.575]  - relaying element #5
[16:12:28.575] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:12:28.575] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.575] signalConditionsASAP(NULL, pos=4) ... done
[16:12:28.575]  length: 3 (resolved future 4)
[16:12:28.575] signalConditionsASAP(NULL, pos=5) ...
[16:12:28.575] - nx: 6
[16:12:28.575] - relay: TRUE
[16:12:28.575] - stdout: TRUE
[16:12:28.575] - signal: TRUE
[16:12:28.575] - resignal: FALSE
[16:12:28.575] - force: TRUE
[16:12:28.576] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, FALSE, FALSE
[16:12:28.576] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.576]  - until=6
[16:12:28.576]  - relaying element #3
[16:12:28.576]  - relaying element #6
[16:12:28.576] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:12:28.576] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.576] signalConditionsASAP(NULL, pos=5) ... done
[16:12:28.576]  length: 2 (resolved future 5)
[16:12:28.576] signalConditionsASAP(numeric, pos=6) ...
[16:12:28.577] - nx: 6
[16:12:28.577] - relay: TRUE
[16:12:28.577] - stdout: TRUE
[16:12:28.577] - signal: TRUE
[16:12:28.577] - resignal: FALSE
[16:12:28.577] - force: TRUE
[16:12:28.577] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, FALSE
[16:12:28.577] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.577]  - until=6
[16:12:28.577]  - relaying element #3
[16:12:28.577] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:12:28.577] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.578] signalConditionsASAP(NULL, pos=6) ... done
[16:12:28.578]  length: 1 (resolved future 6)
[16:12:28.588] receiveMessageFromWorker() for ClusterFuture ...
[16:12:28.588] - Validating connection of MultisessionFuture
[16:12:28.588] - received message: FutureResult
[16:12:28.589] - Received FutureResult
[16:12:28.589] - Erased future from FutureRegistry
[16:12:28.589] result() for ClusterFuture ...
[16:12:28.589] - result already collected: FutureResult
[16:12:28.589] result() for ClusterFuture ... done
[16:12:28.589] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:28.589] Future #3
[16:12:28.589] result() for ClusterFuture ...
[16:12:28.589] - result already collected: FutureResult
[16:12:28.589] result() for ClusterFuture ... done
[16:12:28.589] result() for ClusterFuture ...
[16:12:28.590] - result already collected: FutureResult
[16:12:28.590] result() for ClusterFuture ... done
[16:12:28.590] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:28.590] - nx: 6
[16:12:28.590] - relay: TRUE
[16:12:28.590] - stdout: TRUE
[16:12:28.590] - signal: TRUE
[16:12:28.590] - resignal: FALSE
[16:12:28.590] - force: TRUE
[16:12:28.590] - relayed: [n=6] TRUE, TRUE, FALSE, TRUE, TRUE, TRUE
[16:12:28.590] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:28.590]  - until=6
[16:12:28.591]  - relaying element #3
[16:12:28.591] result() for ClusterFuture ...
[16:12:28.591] - result already collected: FutureResult
[16:12:28.591] result() for ClusterFuture ... done
[16:12:28.591] result() for ClusterFuture ...
[16:12:28.591] - result already collected: FutureResult
[16:12:28.591] result() for ClusterFuture ... done
[16:12:28.591] result() for ClusterFuture ...
[16:12:28.591] - result already collected: FutureResult
[16:12:28.591] result() for ClusterFuture ... done
[16:12:28.591] result() for ClusterFuture ...
[16:12:28.592] - result already collected: FutureResult
[16:12:28.592] result() for ClusterFuture ... done
[16:12:28.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.592] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:28.592]  length: 0 (resolved future 3)
[16:12:28.592] Relaying remaining futures
[16:12:28.592] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.592] - nx: 6
[16:12:28.592] - relay: TRUE
[16:12:28.592] - stdout: TRUE
[16:12:28.592] - signal: TRUE
[16:12:28.593] - resignal: FALSE
[16:12:28.593] - force: TRUE
[16:12:28.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[16:12:28.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:28.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:28.593] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.593] resolve() on list ... DONE
[16:12:28.593] result() for ClusterFuture ...
[16:12:28.593] - result already collected: FutureResult
[16:12:28.593] result() for ClusterFuture ... done
[16:12:28.594] result() for ClusterFuture ...
[16:12:28.594] - result already collected: FutureResult
[16:12:28.594] result() for ClusterFuture ... done
[16:12:28.594] result() for ClusterFuture ...
[16:12:28.594] - result already collected: FutureResult
[16:12:28.594] result() for ClusterFuture ... done
[16:12:28.594] result() for ClusterFuture ...
[16:12:28.594] - result already collected: FutureResult
[16:12:28.594] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[16:12:28.598] plan(): Setting new future strategy stack:
[16:12:28.598] List of future strategies:
[16:12:28.598] 1. multicore:
[16:12:28.598]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.598]    - tweaked: FALSE
[16:12:28.598]    - call: plan(strategy)
[16:12:28.603] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:12:28.603] getGlobalsAndPackages() ...
[16:12:28.603] Searching for globals...
[16:12:28.604] 
[16:12:28.604] Searching for globals ... DONE
[16:12:28.604] - globals: [0] <none>
[16:12:28.604] getGlobalsAndPackages() ... DONE
[16:12:28.605] run() for ‘Future’ ...
[16:12:28.605] - state: ‘created’
[16:12:28.605] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.609] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.610]   - Field: ‘label’
[16:12:28.610]   - Field: ‘local’
[16:12:28.610]   - Field: ‘owner’
[16:12:28.610]   - Field: ‘envir’
[16:12:28.610]   - Field: ‘workers’
[16:12:28.610]   - Field: ‘packages’
[16:12:28.610]   - Field: ‘gc’
[16:12:28.610]   - Field: ‘job’
[16:12:28.610]   - Field: ‘conditions’
[16:12:28.610]   - Field: ‘expr’
[16:12:28.611]   - Field: ‘uuid’
[16:12:28.611]   - Field: ‘seed’
[16:12:28.611]   - Field: ‘version’
[16:12:28.611]   - Field: ‘result’
[16:12:28.611]   - Field: ‘asynchronous’
[16:12:28.611]   - Field: ‘calls’
[16:12:28.611]   - Field: ‘globals’
[16:12:28.611]   - Field: ‘stdout’
[16:12:28.611]   - Field: ‘earlySignal’
[16:12:28.611]   - Field: ‘lazy’
[16:12:28.611]   - Field: ‘state’
[16:12:28.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.612] - Launch lazy future ...
[16:12:28.612] Packages needed by the future expression (n = 0): <none>
[16:12:28.612] Packages needed by future strategies (n = 0): <none>
[16:12:28.612] {
[16:12:28.612]     {
[16:12:28.612]         {
[16:12:28.612]             ...future.startTime <- base::Sys.time()
[16:12:28.612]             {
[16:12:28.612]                 {
[16:12:28.612]                   {
[16:12:28.612]                     {
[16:12:28.612]                       base::local({
[16:12:28.612]                         has_future <- base::requireNamespace("future", 
[16:12:28.612]                           quietly = TRUE)
[16:12:28.612]                         if (has_future) {
[16:12:28.612]                           ns <- base::getNamespace("future")
[16:12:28.612]                           version <- ns[[".package"]][["version"]]
[16:12:28.612]                           if (is.null(version)) 
[16:12:28.612]                             version <- utils::packageVersion("future")
[16:12:28.612]                         }
[16:12:28.612]                         else {
[16:12:28.612]                           version <- NULL
[16:12:28.612]                         }
[16:12:28.612]                         if (!has_future || version < "1.8.0") {
[16:12:28.612]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.612]                             "", base::R.version$version.string), 
[16:12:28.612]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.612]                               "release", "version")], collapse = " "), 
[16:12:28.612]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.612]                             info)
[16:12:28.612]                           info <- base::paste(info, collapse = "; ")
[16:12:28.612]                           if (!has_future) {
[16:12:28.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.612]                               info)
[16:12:28.612]                           }
[16:12:28.612]                           else {
[16:12:28.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.612]                               info, version)
[16:12:28.612]                           }
[16:12:28.612]                           base::stop(msg)
[16:12:28.612]                         }
[16:12:28.612]                       })
[16:12:28.612]                     }
[16:12:28.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.612]                     base::options(mc.cores = 1L)
[16:12:28.612]                   }
[16:12:28.612]                   options(future.plan = NULL)
[16:12:28.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.612]                 }
[16:12:28.612]                 ...future.workdir <- getwd()
[16:12:28.612]             }
[16:12:28.612]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.612]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.612]         }
[16:12:28.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.612]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.612]             base::names(...future.oldOptions))
[16:12:28.612]     }
[16:12:28.612]     if (FALSE) {
[16:12:28.612]     }
[16:12:28.612]     else {
[16:12:28.612]         if (TRUE) {
[16:12:28.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.612]                 open = "w")
[16:12:28.612]         }
[16:12:28.612]         else {
[16:12:28.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.612]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.612]         }
[16:12:28.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.612]             base::sink(type = "output", split = FALSE)
[16:12:28.612]             base::close(...future.stdout)
[16:12:28.612]         }, add = TRUE)
[16:12:28.612]     }
[16:12:28.612]     ...future.frame <- base::sys.nframe()
[16:12:28.612]     ...future.conditions <- base::list()
[16:12:28.612]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.612]     if (FALSE) {
[16:12:28.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.612]     }
[16:12:28.612]     ...future.result <- base::tryCatch({
[16:12:28.612]         base::withCallingHandlers({
[16:12:28.612]             ...future.value <- base::withVisible(base::local({
[16:12:28.612]                 withCallingHandlers({
[16:12:28.612]                   2
[16:12:28.612]                 }, immediateCondition = function(cond) {
[16:12:28.612]                   save_rds <- function (object, pathname, ...) 
[16:12:28.612]                   {
[16:12:28.612]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.612]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.612]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.612]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.612]                         fi_tmp[["mtime"]])
[16:12:28.612]                     }
[16:12:28.612]                     tryCatch({
[16:12:28.612]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.612]                     }, error = function(ex) {
[16:12:28.612]                       msg <- conditionMessage(ex)
[16:12:28.612]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.612]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.612]                         fi_tmp[["mtime"]], msg)
[16:12:28.612]                       ex$message <- msg
[16:12:28.612]                       stop(ex)
[16:12:28.612]                     })
[16:12:28.612]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.612]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.612]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.612]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.612]                       fi <- file.info(pathname)
[16:12:28.612]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.612]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.612]                         fi[["size"]], fi[["mtime"]])
[16:12:28.612]                       stop(msg)
[16:12:28.612]                     }
[16:12:28.612]                     invisible(pathname)
[16:12:28.612]                   }
[16:12:28.612]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.612]                     rootPath = tempdir()) 
[16:12:28.612]                   {
[16:12:28.612]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.612]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.612]                       tmpdir = path, fileext = ".rds")
[16:12:28.612]                     save_rds(obj, file)
[16:12:28.612]                   }
[16:12:28.612]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.612]                   {
[16:12:28.612]                     inherits <- base::inherits
[16:12:28.612]                     invokeRestart <- base::invokeRestart
[16:12:28.612]                     is.null <- base::is.null
[16:12:28.612]                     muffled <- FALSE
[16:12:28.612]                     if (inherits(cond, "message")) {
[16:12:28.612]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.612]                       if (muffled) 
[16:12:28.612]                         invokeRestart("muffleMessage")
[16:12:28.612]                     }
[16:12:28.612]                     else if (inherits(cond, "warning")) {
[16:12:28.612]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.612]                       if (muffled) 
[16:12:28.612]                         invokeRestart("muffleWarning")
[16:12:28.612]                     }
[16:12:28.612]                     else if (inherits(cond, "condition")) {
[16:12:28.612]                       if (!is.null(pattern)) {
[16:12:28.612]                         computeRestarts <- base::computeRestarts
[16:12:28.612]                         grepl <- base::grepl
[16:12:28.612]                         restarts <- computeRestarts(cond)
[16:12:28.612]                         for (restart in restarts) {
[16:12:28.612]                           name <- restart$name
[16:12:28.612]                           if (is.null(name)) 
[16:12:28.612]                             next
[16:12:28.612]                           if (!grepl(pattern, name)) 
[16:12:28.612]                             next
[16:12:28.612]                           invokeRestart(restart)
[16:12:28.612]                           muffled <- TRUE
[16:12:28.612]                           break
[16:12:28.612]                         }
[16:12:28.612]                       }
[16:12:28.612]                     }
[16:12:28.612]                     invisible(muffled)
[16:12:28.612]                   }
[16:12:28.612]                   muffleCondition(cond)
[16:12:28.612]                 })
[16:12:28.612]             }))
[16:12:28.612]             future::FutureResult(value = ...future.value$value, 
[16:12:28.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.612]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.612]                     ...future.globalenv.names))
[16:12:28.612]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.612]         }, condition = base::local({
[16:12:28.612]             c <- base::c
[16:12:28.612]             inherits <- base::inherits
[16:12:28.612]             invokeRestart <- base::invokeRestart
[16:12:28.612]             length <- base::length
[16:12:28.612]             list <- base::list
[16:12:28.612]             seq.int <- base::seq.int
[16:12:28.612]             signalCondition <- base::signalCondition
[16:12:28.612]             sys.calls <- base::sys.calls
[16:12:28.612]             `[[` <- base::`[[`
[16:12:28.612]             `+` <- base::`+`
[16:12:28.612]             `<<-` <- base::`<<-`
[16:12:28.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.612]                   3L)]
[16:12:28.612]             }
[16:12:28.612]             function(cond) {
[16:12:28.612]                 is_error <- inherits(cond, "error")
[16:12:28.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.612]                   NULL)
[16:12:28.612]                 if (is_error) {
[16:12:28.612]                   sessionInformation <- function() {
[16:12:28.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.612]                       search = base::search(), system = base::Sys.info())
[16:12:28.612]                   }
[16:12:28.612]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.612]                     cond$call), session = sessionInformation(), 
[16:12:28.612]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.612]                   signalCondition(cond)
[16:12:28.612]                 }
[16:12:28.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.612]                 "immediateCondition"))) {
[16:12:28.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.612]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.612]                   if (TRUE && !signal) {
[16:12:28.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.612]                     {
[16:12:28.612]                       inherits <- base::inherits
[16:12:28.612]                       invokeRestart <- base::invokeRestart
[16:12:28.612]                       is.null <- base::is.null
[16:12:28.612]                       muffled <- FALSE
[16:12:28.612]                       if (inherits(cond, "message")) {
[16:12:28.612]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.612]                         if (muffled) 
[16:12:28.612]                           invokeRestart("muffleMessage")
[16:12:28.612]                       }
[16:12:28.612]                       else if (inherits(cond, "warning")) {
[16:12:28.612]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.612]                         if (muffled) 
[16:12:28.612]                           invokeRestart("muffleWarning")
[16:12:28.612]                       }
[16:12:28.612]                       else if (inherits(cond, "condition")) {
[16:12:28.612]                         if (!is.null(pattern)) {
[16:12:28.612]                           computeRestarts <- base::computeRestarts
[16:12:28.612]                           grepl <- base::grepl
[16:12:28.612]                           restarts <- computeRestarts(cond)
[16:12:28.612]                           for (restart in restarts) {
[16:12:28.612]                             name <- restart$name
[16:12:28.612]                             if (is.null(name)) 
[16:12:28.612]                               next
[16:12:28.612]                             if (!grepl(pattern, name)) 
[16:12:28.612]                               next
[16:12:28.612]                             invokeRestart(restart)
[16:12:28.612]                             muffled <- TRUE
[16:12:28.612]                             break
[16:12:28.612]                           }
[16:12:28.612]                         }
[16:12:28.612]                       }
[16:12:28.612]                       invisible(muffled)
[16:12:28.612]                     }
[16:12:28.612]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.612]                   }
[16:12:28.612]                 }
[16:12:28.612]                 else {
[16:12:28.612]                   if (TRUE) {
[16:12:28.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.612]                     {
[16:12:28.612]                       inherits <- base::inherits
[16:12:28.612]                       invokeRestart <- base::invokeRestart
[16:12:28.612]                       is.null <- base::is.null
[16:12:28.612]                       muffled <- FALSE
[16:12:28.612]                       if (inherits(cond, "message")) {
[16:12:28.612]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.612]                         if (muffled) 
[16:12:28.612]                           invokeRestart("muffleMessage")
[16:12:28.612]                       }
[16:12:28.612]                       else if (inherits(cond, "warning")) {
[16:12:28.612]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.612]                         if (muffled) 
[16:12:28.612]                           invokeRestart("muffleWarning")
[16:12:28.612]                       }
[16:12:28.612]                       else if (inherits(cond, "condition")) {
[16:12:28.612]                         if (!is.null(pattern)) {
[16:12:28.612]                           computeRestarts <- base::computeRestarts
[16:12:28.612]                           grepl <- base::grepl
[16:12:28.612]                           restarts <- computeRestarts(cond)
[16:12:28.612]                           for (restart in restarts) {
[16:12:28.612]                             name <- restart$name
[16:12:28.612]                             if (is.null(name)) 
[16:12:28.612]                               next
[16:12:28.612]                             if (!grepl(pattern, name)) 
[16:12:28.612]                               next
[16:12:28.612]                             invokeRestart(restart)
[16:12:28.612]                             muffled <- TRUE
[16:12:28.612]                             break
[16:12:28.612]                           }
[16:12:28.612]                         }
[16:12:28.612]                       }
[16:12:28.612]                       invisible(muffled)
[16:12:28.612]                     }
[16:12:28.612]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.612]                   }
[16:12:28.612]                 }
[16:12:28.612]             }
[16:12:28.612]         }))
[16:12:28.612]     }, error = function(ex) {
[16:12:28.612]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.612]                 ...future.rng), started = ...future.startTime, 
[16:12:28.612]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.612]             version = "1.8"), class = "FutureResult")
[16:12:28.612]     }, finally = {
[16:12:28.612]         if (!identical(...future.workdir, getwd())) 
[16:12:28.612]             setwd(...future.workdir)
[16:12:28.612]         {
[16:12:28.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.612]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.612]             }
[16:12:28.612]             base::options(...future.oldOptions)
[16:12:28.612]             if (.Platform$OS.type == "windows") {
[16:12:28.612]                 old_names <- names(...future.oldEnvVars)
[16:12:28.612]                 envs <- base::Sys.getenv()
[16:12:28.612]                 names <- names(envs)
[16:12:28.612]                 common <- intersect(names, old_names)
[16:12:28.612]                 added <- setdiff(names, old_names)
[16:12:28.612]                 removed <- setdiff(old_names, names)
[16:12:28.612]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.612]                   envs[common]]
[16:12:28.612]                 NAMES <- toupper(changed)
[16:12:28.612]                 args <- list()
[16:12:28.612]                 for (kk in seq_along(NAMES)) {
[16:12:28.612]                   name <- changed[[kk]]
[16:12:28.612]                   NAME <- NAMES[[kk]]
[16:12:28.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.612]                     next
[16:12:28.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.612]                 }
[16:12:28.612]                 NAMES <- toupper(added)
[16:12:28.612]                 for (kk in seq_along(NAMES)) {
[16:12:28.612]                   name <- added[[kk]]
[16:12:28.612]                   NAME <- NAMES[[kk]]
[16:12:28.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.612]                     next
[16:12:28.612]                   args[[name]] <- ""
[16:12:28.612]                 }
[16:12:28.612]                 NAMES <- toupper(removed)
[16:12:28.612]                 for (kk in seq_along(NAMES)) {
[16:12:28.612]                   name <- removed[[kk]]
[16:12:28.612]                   NAME <- NAMES[[kk]]
[16:12:28.612]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.612]                     next
[16:12:28.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.612]                 }
[16:12:28.612]                 if (length(args) > 0) 
[16:12:28.612]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.612]             }
[16:12:28.612]             else {
[16:12:28.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.612]             }
[16:12:28.612]             {
[16:12:28.612]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.612]                   0L) {
[16:12:28.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.612]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.612]                   base::options(opts)
[16:12:28.612]                 }
[16:12:28.612]                 {
[16:12:28.612]                   {
[16:12:28.612]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.612]                     NULL
[16:12:28.612]                   }
[16:12:28.612]                   options(future.plan = NULL)
[16:12:28.612]                   if (is.na(NA_character_)) 
[16:12:28.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.612]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.612]                     envir = parent.frame()) 
[16:12:28.612]                   {
[16:12:28.612]                     default_workers <- missing(workers)
[16:12:28.612]                     if (is.function(workers)) 
[16:12:28.612]                       workers <- workers()
[16:12:28.612]                     workers <- structure(as.integer(workers), 
[16:12:28.612]                       class = class(workers))
[16:12:28.612]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.612]                       1L)
[16:12:28.612]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.612]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.612]                       if (default_workers) 
[16:12:28.612]                         supportsMulticore(warn = TRUE)
[16:12:28.612]                       return(sequential(..., envir = envir))
[16:12:28.612]                     }
[16:12:28.612]                     oopts <- options(mc.cores = workers)
[16:12:28.612]                     on.exit(options(oopts))
[16:12:28.612]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.612]                       envir = envir)
[16:12:28.612]                     if (!future$lazy) 
[16:12:28.612]                       future <- run(future)
[16:12:28.612]                     invisible(future)
[16:12:28.612]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.612]                 }
[16:12:28.612]             }
[16:12:28.612]         }
[16:12:28.612]     })
[16:12:28.612]     if (TRUE) {
[16:12:28.612]         base::sink(type = "output", split = FALSE)
[16:12:28.612]         if (TRUE) {
[16:12:28.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.612]         }
[16:12:28.612]         else {
[16:12:28.612]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.612]         }
[16:12:28.612]         base::close(...future.stdout)
[16:12:28.612]         ...future.stdout <- NULL
[16:12:28.612]     }
[16:12:28.612]     ...future.result$conditions <- ...future.conditions
[16:12:28.612]     ...future.result$finished <- base::Sys.time()
[16:12:28.612]     ...future.result
[16:12:28.612] }
[16:12:28.615] requestCore(): workers = 2
[16:12:28.617] MulticoreFuture started
[16:12:28.617] - Launch lazy future ... done
[16:12:28.618] run() for ‘MulticoreFuture’ ... done
[16:12:28.618] getGlobalsAndPackages() ...
[16:12:28.618] Searching for globals...
[16:12:28.618] plan(): Setting new future strategy stack:
[16:12:28.619] 
[16:12:28.618] List of future strategies:
[16:12:28.618] 1. sequential:
[16:12:28.618]    - args: function (..., envir = parent.frame())
[16:12:28.618]    - tweaked: FALSE
[16:12:28.618]    - call: NULL
[16:12:28.619] Searching for globals ... DONE
[16:12:28.619] - globals: [0] <none>
[16:12:28.619] plan(): nbrOfWorkers() = 1
[16:12:28.619] getGlobalsAndPackages() ... DONE
[16:12:28.620] run() for ‘Future’ ...
[16:12:28.620] - state: ‘created’
[16:12:28.620] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.621] plan(): Setting new future strategy stack:
[16:12:28.621] List of future strategies:
[16:12:28.621] 1. multicore:
[16:12:28.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.621]    - tweaked: FALSE
[16:12:28.621]    - call: plan(strategy)
[16:12:28.625] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.626] plan(): nbrOfWorkers() = 2
[16:12:28.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.626]   - Field: ‘label’
[16:12:28.626]   - Field: ‘local’
[16:12:28.626]   - Field: ‘owner’
[16:12:28.626]   - Field: ‘envir’
[16:12:28.626]   - Field: ‘workers’
[16:12:28.627]   - Field: ‘packages’
[16:12:28.627]   - Field: ‘gc’
[16:12:28.627]   - Field: ‘job’
[16:12:28.627]   - Field: ‘conditions’
[16:12:28.627]   - Field: ‘expr’
[16:12:28.627]   - Field: ‘uuid’
[16:12:28.627]   - Field: ‘seed’
[16:12:28.627]   - Field: ‘version’
[16:12:28.628]   - Field: ‘result’
[16:12:28.628]   - Field: ‘asynchronous’
[16:12:28.628]   - Field: ‘calls’
[16:12:28.628]   - Field: ‘globals’
[16:12:28.628]   - Field: ‘stdout’
[16:12:28.628]   - Field: ‘earlySignal’
[16:12:28.628]   - Field: ‘lazy’
[16:12:28.629]   - Field: ‘state’
[16:12:28.629] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.629] - Launch lazy future ...
[16:12:28.629] Packages needed by the future expression (n = 0): <none>
[16:12:28.629] Packages needed by future strategies (n = 0): <none>
[16:12:28.630] {
[16:12:28.630]     {
[16:12:28.630]         {
[16:12:28.630]             ...future.startTime <- base::Sys.time()
[16:12:28.630]             {
[16:12:28.630]                 {
[16:12:28.630]                   {
[16:12:28.630]                     {
[16:12:28.630]                       base::local({
[16:12:28.630]                         has_future <- base::requireNamespace("future", 
[16:12:28.630]                           quietly = TRUE)
[16:12:28.630]                         if (has_future) {
[16:12:28.630]                           ns <- base::getNamespace("future")
[16:12:28.630]                           version <- ns[[".package"]][["version"]]
[16:12:28.630]                           if (is.null(version)) 
[16:12:28.630]                             version <- utils::packageVersion("future")
[16:12:28.630]                         }
[16:12:28.630]                         else {
[16:12:28.630]                           version <- NULL
[16:12:28.630]                         }
[16:12:28.630]                         if (!has_future || version < "1.8.0") {
[16:12:28.630]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.630]                             "", base::R.version$version.string), 
[16:12:28.630]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.630]                               "release", "version")], collapse = " "), 
[16:12:28.630]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.630]                             info)
[16:12:28.630]                           info <- base::paste(info, collapse = "; ")
[16:12:28.630]                           if (!has_future) {
[16:12:28.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.630]                               info)
[16:12:28.630]                           }
[16:12:28.630]                           else {
[16:12:28.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.630]                               info, version)
[16:12:28.630]                           }
[16:12:28.630]                           base::stop(msg)
[16:12:28.630]                         }
[16:12:28.630]                       })
[16:12:28.630]                     }
[16:12:28.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.630]                     base::options(mc.cores = 1L)
[16:12:28.630]                   }
[16:12:28.630]                   options(future.plan = NULL)
[16:12:28.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.630]                 }
[16:12:28.630]                 ...future.workdir <- getwd()
[16:12:28.630]             }
[16:12:28.630]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.630]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.630]         }
[16:12:28.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.630]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.630]             base::names(...future.oldOptions))
[16:12:28.630]     }
[16:12:28.630]     if (FALSE) {
[16:12:28.630]     }
[16:12:28.630]     else {
[16:12:28.630]         if (TRUE) {
[16:12:28.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.630]                 open = "w")
[16:12:28.630]         }
[16:12:28.630]         else {
[16:12:28.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.630]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.630]         }
[16:12:28.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.630]             base::sink(type = "output", split = FALSE)
[16:12:28.630]             base::close(...future.stdout)
[16:12:28.630]         }, add = TRUE)
[16:12:28.630]     }
[16:12:28.630]     ...future.frame <- base::sys.nframe()
[16:12:28.630]     ...future.conditions <- base::list()
[16:12:28.630]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.630]     if (FALSE) {
[16:12:28.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.630]     }
[16:12:28.630]     ...future.result <- base::tryCatch({
[16:12:28.630]         base::withCallingHandlers({
[16:12:28.630]             ...future.value <- base::withVisible(base::local({
[16:12:28.630]                 withCallingHandlers({
[16:12:28.630]                   NULL
[16:12:28.630]                 }, immediateCondition = function(cond) {
[16:12:28.630]                   save_rds <- function (object, pathname, ...) 
[16:12:28.630]                   {
[16:12:28.630]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.630]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.630]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.630]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.630]                         fi_tmp[["mtime"]])
[16:12:28.630]                     }
[16:12:28.630]                     tryCatch({
[16:12:28.630]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.630]                     }, error = function(ex) {
[16:12:28.630]                       msg <- conditionMessage(ex)
[16:12:28.630]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.630]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.630]                         fi_tmp[["mtime"]], msg)
[16:12:28.630]                       ex$message <- msg
[16:12:28.630]                       stop(ex)
[16:12:28.630]                     })
[16:12:28.630]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.630]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.630]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.630]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.630]                       fi <- file.info(pathname)
[16:12:28.630]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.630]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.630]                         fi[["size"]], fi[["mtime"]])
[16:12:28.630]                       stop(msg)
[16:12:28.630]                     }
[16:12:28.630]                     invisible(pathname)
[16:12:28.630]                   }
[16:12:28.630]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.630]                     rootPath = tempdir()) 
[16:12:28.630]                   {
[16:12:28.630]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.630]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.630]                       tmpdir = path, fileext = ".rds")
[16:12:28.630]                     save_rds(obj, file)
[16:12:28.630]                   }
[16:12:28.630]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.630]                   {
[16:12:28.630]                     inherits <- base::inherits
[16:12:28.630]                     invokeRestart <- base::invokeRestart
[16:12:28.630]                     is.null <- base::is.null
[16:12:28.630]                     muffled <- FALSE
[16:12:28.630]                     if (inherits(cond, "message")) {
[16:12:28.630]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.630]                       if (muffled) 
[16:12:28.630]                         invokeRestart("muffleMessage")
[16:12:28.630]                     }
[16:12:28.630]                     else if (inherits(cond, "warning")) {
[16:12:28.630]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.630]                       if (muffled) 
[16:12:28.630]                         invokeRestart("muffleWarning")
[16:12:28.630]                     }
[16:12:28.630]                     else if (inherits(cond, "condition")) {
[16:12:28.630]                       if (!is.null(pattern)) {
[16:12:28.630]                         computeRestarts <- base::computeRestarts
[16:12:28.630]                         grepl <- base::grepl
[16:12:28.630]                         restarts <- computeRestarts(cond)
[16:12:28.630]                         for (restart in restarts) {
[16:12:28.630]                           name <- restart$name
[16:12:28.630]                           if (is.null(name)) 
[16:12:28.630]                             next
[16:12:28.630]                           if (!grepl(pattern, name)) 
[16:12:28.630]                             next
[16:12:28.630]                           invokeRestart(restart)
[16:12:28.630]                           muffled <- TRUE
[16:12:28.630]                           break
[16:12:28.630]                         }
[16:12:28.630]                       }
[16:12:28.630]                     }
[16:12:28.630]                     invisible(muffled)
[16:12:28.630]                   }
[16:12:28.630]                   muffleCondition(cond)
[16:12:28.630]                 })
[16:12:28.630]             }))
[16:12:28.630]             future::FutureResult(value = ...future.value$value, 
[16:12:28.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.630]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.630]                     ...future.globalenv.names))
[16:12:28.630]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.630]         }, condition = base::local({
[16:12:28.630]             c <- base::c
[16:12:28.630]             inherits <- base::inherits
[16:12:28.630]             invokeRestart <- base::invokeRestart
[16:12:28.630]             length <- base::length
[16:12:28.630]             list <- base::list
[16:12:28.630]             seq.int <- base::seq.int
[16:12:28.630]             signalCondition <- base::signalCondition
[16:12:28.630]             sys.calls <- base::sys.calls
[16:12:28.630]             `[[` <- base::`[[`
[16:12:28.630]             `+` <- base::`+`
[16:12:28.630]             `<<-` <- base::`<<-`
[16:12:28.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.630]                   3L)]
[16:12:28.630]             }
[16:12:28.630]             function(cond) {
[16:12:28.630]                 is_error <- inherits(cond, "error")
[16:12:28.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.630]                   NULL)
[16:12:28.630]                 if (is_error) {
[16:12:28.630]                   sessionInformation <- function() {
[16:12:28.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.630]                       search = base::search(), system = base::Sys.info())
[16:12:28.630]                   }
[16:12:28.630]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.630]                     cond$call), session = sessionInformation(), 
[16:12:28.630]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.630]                   signalCondition(cond)
[16:12:28.630]                 }
[16:12:28.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.630]                 "immediateCondition"))) {
[16:12:28.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.630]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.630]                   if (TRUE && !signal) {
[16:12:28.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.630]                     {
[16:12:28.630]                       inherits <- base::inherits
[16:12:28.630]                       invokeRestart <- base::invokeRestart
[16:12:28.630]                       is.null <- base::is.null
[16:12:28.630]                       muffled <- FALSE
[16:12:28.630]                       if (inherits(cond, "message")) {
[16:12:28.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.630]                         if (muffled) 
[16:12:28.630]                           invokeRestart("muffleMessage")
[16:12:28.630]                       }
[16:12:28.630]                       else if (inherits(cond, "warning")) {
[16:12:28.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.630]                         if (muffled) 
[16:12:28.630]                           invokeRestart("muffleWarning")
[16:12:28.630]                       }
[16:12:28.630]                       else if (inherits(cond, "condition")) {
[16:12:28.630]                         if (!is.null(pattern)) {
[16:12:28.630]                           computeRestarts <- base::computeRestarts
[16:12:28.630]                           grepl <- base::grepl
[16:12:28.630]                           restarts <- computeRestarts(cond)
[16:12:28.630]                           for (restart in restarts) {
[16:12:28.630]                             name <- restart$name
[16:12:28.630]                             if (is.null(name)) 
[16:12:28.630]                               next
[16:12:28.630]                             if (!grepl(pattern, name)) 
[16:12:28.630]                               next
[16:12:28.630]                             invokeRestart(restart)
[16:12:28.630]                             muffled <- TRUE
[16:12:28.630]                             break
[16:12:28.630]                           }
[16:12:28.630]                         }
[16:12:28.630]                       }
[16:12:28.630]                       invisible(muffled)
[16:12:28.630]                     }
[16:12:28.630]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.630]                   }
[16:12:28.630]                 }
[16:12:28.630]                 else {
[16:12:28.630]                   if (TRUE) {
[16:12:28.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.630]                     {
[16:12:28.630]                       inherits <- base::inherits
[16:12:28.630]                       invokeRestart <- base::invokeRestart
[16:12:28.630]                       is.null <- base::is.null
[16:12:28.630]                       muffled <- FALSE
[16:12:28.630]                       if (inherits(cond, "message")) {
[16:12:28.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.630]                         if (muffled) 
[16:12:28.630]                           invokeRestart("muffleMessage")
[16:12:28.630]                       }
[16:12:28.630]                       else if (inherits(cond, "warning")) {
[16:12:28.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.630]                         if (muffled) 
[16:12:28.630]                           invokeRestart("muffleWarning")
[16:12:28.630]                       }
[16:12:28.630]                       else if (inherits(cond, "condition")) {
[16:12:28.630]                         if (!is.null(pattern)) {
[16:12:28.630]                           computeRestarts <- base::computeRestarts
[16:12:28.630]                           grepl <- base::grepl
[16:12:28.630]                           restarts <- computeRestarts(cond)
[16:12:28.630]                           for (restart in restarts) {
[16:12:28.630]                             name <- restart$name
[16:12:28.630]                             if (is.null(name)) 
[16:12:28.630]                               next
[16:12:28.630]                             if (!grepl(pattern, name)) 
[16:12:28.630]                               next
[16:12:28.630]                             invokeRestart(restart)
[16:12:28.630]                             muffled <- TRUE
[16:12:28.630]                             break
[16:12:28.630]                           }
[16:12:28.630]                         }
[16:12:28.630]                       }
[16:12:28.630]                       invisible(muffled)
[16:12:28.630]                     }
[16:12:28.630]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.630]                   }
[16:12:28.630]                 }
[16:12:28.630]             }
[16:12:28.630]         }))
[16:12:28.630]     }, error = function(ex) {
[16:12:28.630]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.630]                 ...future.rng), started = ...future.startTime, 
[16:12:28.630]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.630]             version = "1.8"), class = "FutureResult")
[16:12:28.630]     }, finally = {
[16:12:28.630]         if (!identical(...future.workdir, getwd())) 
[16:12:28.630]             setwd(...future.workdir)
[16:12:28.630]         {
[16:12:28.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.630]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.630]             }
[16:12:28.630]             base::options(...future.oldOptions)
[16:12:28.630]             if (.Platform$OS.type == "windows") {
[16:12:28.630]                 old_names <- names(...future.oldEnvVars)
[16:12:28.630]                 envs <- base::Sys.getenv()
[16:12:28.630]                 names <- names(envs)
[16:12:28.630]                 common <- intersect(names, old_names)
[16:12:28.630]                 added <- setdiff(names, old_names)
[16:12:28.630]                 removed <- setdiff(old_names, names)
[16:12:28.630]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.630]                   envs[common]]
[16:12:28.630]                 NAMES <- toupper(changed)
[16:12:28.630]                 args <- list()
[16:12:28.630]                 for (kk in seq_along(NAMES)) {
[16:12:28.630]                   name <- changed[[kk]]
[16:12:28.630]                   NAME <- NAMES[[kk]]
[16:12:28.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.630]                     next
[16:12:28.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.630]                 }
[16:12:28.630]                 NAMES <- toupper(added)
[16:12:28.630]                 for (kk in seq_along(NAMES)) {
[16:12:28.630]                   name <- added[[kk]]
[16:12:28.630]                   NAME <- NAMES[[kk]]
[16:12:28.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.630]                     next
[16:12:28.630]                   args[[name]] <- ""
[16:12:28.630]                 }
[16:12:28.630]                 NAMES <- toupper(removed)
[16:12:28.630]                 for (kk in seq_along(NAMES)) {
[16:12:28.630]                   name <- removed[[kk]]
[16:12:28.630]                   NAME <- NAMES[[kk]]
[16:12:28.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.630]                     next
[16:12:28.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.630]                 }
[16:12:28.630]                 if (length(args) > 0) 
[16:12:28.630]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.630]             }
[16:12:28.630]             else {
[16:12:28.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.630]             }
[16:12:28.630]             {
[16:12:28.630]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.630]                   0L) {
[16:12:28.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.630]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.630]                   base::options(opts)
[16:12:28.630]                 }
[16:12:28.630]                 {
[16:12:28.630]                   {
[16:12:28.630]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.630]                     NULL
[16:12:28.630]                   }
[16:12:28.630]                   options(future.plan = NULL)
[16:12:28.630]                   if (is.na(NA_character_)) 
[16:12:28.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.630]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.630]                     envir = parent.frame()) 
[16:12:28.630]                   {
[16:12:28.630]                     default_workers <- missing(workers)
[16:12:28.630]                     if (is.function(workers)) 
[16:12:28.630]                       workers <- workers()
[16:12:28.630]                     workers <- structure(as.integer(workers), 
[16:12:28.630]                       class = class(workers))
[16:12:28.630]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.630]                       1L)
[16:12:28.630]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.630]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.630]                       if (default_workers) 
[16:12:28.630]                         supportsMulticore(warn = TRUE)
[16:12:28.630]                       return(sequential(..., envir = envir))
[16:12:28.630]                     }
[16:12:28.630]                     oopts <- options(mc.cores = workers)
[16:12:28.630]                     on.exit(options(oopts))
[16:12:28.630]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.630]                       envir = envir)
[16:12:28.630]                     if (!future$lazy) 
[16:12:28.630]                       future <- run(future)
[16:12:28.630]                     invisible(future)
[16:12:28.630]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.630]                 }
[16:12:28.630]             }
[16:12:28.630]         }
[16:12:28.630]     })
[16:12:28.630]     if (TRUE) {
[16:12:28.630]         base::sink(type = "output", split = FALSE)
[16:12:28.630]         if (TRUE) {
[16:12:28.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.630]         }
[16:12:28.630]         else {
[16:12:28.630]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.630]         }
[16:12:28.630]         base::close(...future.stdout)
[16:12:28.630]         ...future.stdout <- NULL
[16:12:28.630]     }
[16:12:28.630]     ...future.result$conditions <- ...future.conditions
[16:12:28.630]     ...future.result$finished <- base::Sys.time()
[16:12:28.630]     ...future.result
[16:12:28.630] }
[16:12:28.633] requestCore(): workers = 2
[16:12:28.636] MulticoreFuture started
[16:12:28.636] - Launch lazy future ... done
[16:12:28.636] run() for ‘MulticoreFuture’ ... done
[16:12:28.637] plan(): Setting new future strategy stack:
[16:12:28.637] getGlobalsAndPackages() ...
[16:12:28.637] Searching for globals...
[16:12:28.637] List of future strategies:
[16:12:28.637] 1. sequential:
[16:12:28.637]    - args: function (..., envir = parent.frame())
[16:12:28.637]    - tweaked: FALSE
[16:12:28.637]    - call: NULL
[16:12:28.638] plan(): nbrOfWorkers() = 1
[16:12:28.639] - globals found: [1] ‘{’
[16:12:28.639] Searching for globals ... DONE
[16:12:28.639] Resolving globals: FALSE
[16:12:28.639] 
[16:12:28.640] 
[16:12:28.640] getGlobalsAndPackages() ... DONE
[16:12:28.640] plan(): Setting new future strategy stack:
[16:12:28.640] run() for ‘Future’ ...
[16:12:28.640] - state: ‘created’
[16:12:28.640] List of future strategies:
[16:12:28.640] 1. multicore:
[16:12:28.640]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.640]    - tweaked: FALSE
[16:12:28.640]    - call: plan(strategy)
[16:12:28.641] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.645] plan(): nbrOfWorkers() = 2
[16:12:28.646] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.646]   - Field: ‘label’
[16:12:28.646]   - Field: ‘local’
[16:12:28.647]   - Field: ‘owner’
[16:12:28.647]   - Field: ‘envir’
[16:12:28.647]   - Field: ‘workers’
[16:12:28.647]   - Field: ‘packages’
[16:12:28.647]   - Field: ‘gc’
[16:12:28.647]   - Field: ‘job’
[16:12:28.647]   - Field: ‘conditions’
[16:12:28.647]   - Field: ‘expr’
[16:12:28.648]   - Field: ‘uuid’
[16:12:28.648]   - Field: ‘seed’
[16:12:28.648]   - Field: ‘version’
[16:12:28.648]   - Field: ‘result’
[16:12:28.648]   - Field: ‘asynchronous’
[16:12:28.648]   - Field: ‘calls’
[16:12:28.648]   - Field: ‘globals’
[16:12:28.649]   - Field: ‘stdout’
[16:12:28.649]   - Field: ‘earlySignal’
[16:12:28.649]   - Field: ‘lazy’
[16:12:28.649]   - Field: ‘state’
[16:12:28.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.649] - Launch lazy future ...
[16:12:28.650] Packages needed by the future expression (n = 0): <none>
[16:12:28.650] Packages needed by future strategies (n = 0): <none>
[16:12:28.650] {
[16:12:28.650]     {
[16:12:28.650]         {
[16:12:28.650]             ...future.startTime <- base::Sys.time()
[16:12:28.650]             {
[16:12:28.650]                 {
[16:12:28.650]                   {
[16:12:28.650]                     {
[16:12:28.650]                       base::local({
[16:12:28.650]                         has_future <- base::requireNamespace("future", 
[16:12:28.650]                           quietly = TRUE)
[16:12:28.650]                         if (has_future) {
[16:12:28.650]                           ns <- base::getNamespace("future")
[16:12:28.650]                           version <- ns[[".package"]][["version"]]
[16:12:28.650]                           if (is.null(version)) 
[16:12:28.650]                             version <- utils::packageVersion("future")
[16:12:28.650]                         }
[16:12:28.650]                         else {
[16:12:28.650]                           version <- NULL
[16:12:28.650]                         }
[16:12:28.650]                         if (!has_future || version < "1.8.0") {
[16:12:28.650]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.650]                             "", base::R.version$version.string), 
[16:12:28.650]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.650]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.650]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.650]                               "release", "version")], collapse = " "), 
[16:12:28.650]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.650]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.650]                             info)
[16:12:28.650]                           info <- base::paste(info, collapse = "; ")
[16:12:28.650]                           if (!has_future) {
[16:12:28.650]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.650]                               info)
[16:12:28.650]                           }
[16:12:28.650]                           else {
[16:12:28.650]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.650]                               info, version)
[16:12:28.650]                           }
[16:12:28.650]                           base::stop(msg)
[16:12:28.650]                         }
[16:12:28.650]                       })
[16:12:28.650]                     }
[16:12:28.650]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.650]                     base::options(mc.cores = 1L)
[16:12:28.650]                   }
[16:12:28.650]                   options(future.plan = NULL)
[16:12:28.650]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.650]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.650]                 }
[16:12:28.650]                 ...future.workdir <- getwd()
[16:12:28.650]             }
[16:12:28.650]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.650]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.650]         }
[16:12:28.650]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.650]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.650]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.650]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.650]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.650]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.650]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.650]             base::names(...future.oldOptions))
[16:12:28.650]     }
[16:12:28.650]     if (FALSE) {
[16:12:28.650]     }
[16:12:28.650]     else {
[16:12:28.650]         if (TRUE) {
[16:12:28.650]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.650]                 open = "w")
[16:12:28.650]         }
[16:12:28.650]         else {
[16:12:28.650]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.650]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.650]         }
[16:12:28.650]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.650]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.650]             base::sink(type = "output", split = FALSE)
[16:12:28.650]             base::close(...future.stdout)
[16:12:28.650]         }, add = TRUE)
[16:12:28.650]     }
[16:12:28.650]     ...future.frame <- base::sys.nframe()
[16:12:28.650]     ...future.conditions <- base::list()
[16:12:28.650]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.650]     if (FALSE) {
[16:12:28.650]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.650]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.650]     }
[16:12:28.650]     ...future.result <- base::tryCatch({
[16:12:28.650]         base::withCallingHandlers({
[16:12:28.650]             ...future.value <- base::withVisible(base::local({
[16:12:28.650]                 withCallingHandlers({
[16:12:28.650]                   {
[16:12:28.650]                     4
[16:12:28.650]                   }
[16:12:28.650]                 }, immediateCondition = function(cond) {
[16:12:28.650]                   save_rds <- function (object, pathname, ...) 
[16:12:28.650]                   {
[16:12:28.650]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.650]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.650]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.650]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.650]                         fi_tmp[["mtime"]])
[16:12:28.650]                     }
[16:12:28.650]                     tryCatch({
[16:12:28.650]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.650]                     }, error = function(ex) {
[16:12:28.650]                       msg <- conditionMessage(ex)
[16:12:28.650]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.650]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.650]                         fi_tmp[["mtime"]], msg)
[16:12:28.650]                       ex$message <- msg
[16:12:28.650]                       stop(ex)
[16:12:28.650]                     })
[16:12:28.650]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.650]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.650]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.650]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.650]                       fi <- file.info(pathname)
[16:12:28.650]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.650]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.650]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.650]                         fi[["size"]], fi[["mtime"]])
[16:12:28.650]                       stop(msg)
[16:12:28.650]                     }
[16:12:28.650]                     invisible(pathname)
[16:12:28.650]                   }
[16:12:28.650]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.650]                     rootPath = tempdir()) 
[16:12:28.650]                   {
[16:12:28.650]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.650]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.650]                       tmpdir = path, fileext = ".rds")
[16:12:28.650]                     save_rds(obj, file)
[16:12:28.650]                   }
[16:12:28.650]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.650]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.650]                   {
[16:12:28.650]                     inherits <- base::inherits
[16:12:28.650]                     invokeRestart <- base::invokeRestart
[16:12:28.650]                     is.null <- base::is.null
[16:12:28.650]                     muffled <- FALSE
[16:12:28.650]                     if (inherits(cond, "message")) {
[16:12:28.650]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.650]                       if (muffled) 
[16:12:28.650]                         invokeRestart("muffleMessage")
[16:12:28.650]                     }
[16:12:28.650]                     else if (inherits(cond, "warning")) {
[16:12:28.650]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.650]                       if (muffled) 
[16:12:28.650]                         invokeRestart("muffleWarning")
[16:12:28.650]                     }
[16:12:28.650]                     else if (inherits(cond, "condition")) {
[16:12:28.650]                       if (!is.null(pattern)) {
[16:12:28.650]                         computeRestarts <- base::computeRestarts
[16:12:28.650]                         grepl <- base::grepl
[16:12:28.650]                         restarts <- computeRestarts(cond)
[16:12:28.650]                         for (restart in restarts) {
[16:12:28.650]                           name <- restart$name
[16:12:28.650]                           if (is.null(name)) 
[16:12:28.650]                             next
[16:12:28.650]                           if (!grepl(pattern, name)) 
[16:12:28.650]                             next
[16:12:28.650]                           invokeRestart(restart)
[16:12:28.650]                           muffled <- TRUE
[16:12:28.650]                           break
[16:12:28.650]                         }
[16:12:28.650]                       }
[16:12:28.650]                     }
[16:12:28.650]                     invisible(muffled)
[16:12:28.650]                   }
[16:12:28.650]                   muffleCondition(cond)
[16:12:28.650]                 })
[16:12:28.650]             }))
[16:12:28.650]             future::FutureResult(value = ...future.value$value, 
[16:12:28.650]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.650]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.650]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.650]                     ...future.globalenv.names))
[16:12:28.650]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.650]         }, condition = base::local({
[16:12:28.650]             c <- base::c
[16:12:28.650]             inherits <- base::inherits
[16:12:28.650]             invokeRestart <- base::invokeRestart
[16:12:28.650]             length <- base::length
[16:12:28.650]             list <- base::list
[16:12:28.650]             seq.int <- base::seq.int
[16:12:28.650]             signalCondition <- base::signalCondition
[16:12:28.650]             sys.calls <- base::sys.calls
[16:12:28.650]             `[[` <- base::`[[`
[16:12:28.650]             `+` <- base::`+`
[16:12:28.650]             `<<-` <- base::`<<-`
[16:12:28.650]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.650]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.650]                   3L)]
[16:12:28.650]             }
[16:12:28.650]             function(cond) {
[16:12:28.650]                 is_error <- inherits(cond, "error")
[16:12:28.650]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.650]                   NULL)
[16:12:28.650]                 if (is_error) {
[16:12:28.650]                   sessionInformation <- function() {
[16:12:28.650]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.650]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.650]                       search = base::search(), system = base::Sys.info())
[16:12:28.650]                   }
[16:12:28.650]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.650]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.650]                     cond$call), session = sessionInformation(), 
[16:12:28.650]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.650]                   signalCondition(cond)
[16:12:28.650]                 }
[16:12:28.650]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.650]                 "immediateCondition"))) {
[16:12:28.650]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.650]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.650]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.650]                   if (TRUE && !signal) {
[16:12:28.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.650]                     {
[16:12:28.650]                       inherits <- base::inherits
[16:12:28.650]                       invokeRestart <- base::invokeRestart
[16:12:28.650]                       is.null <- base::is.null
[16:12:28.650]                       muffled <- FALSE
[16:12:28.650]                       if (inherits(cond, "message")) {
[16:12:28.650]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.650]                         if (muffled) 
[16:12:28.650]                           invokeRestart("muffleMessage")
[16:12:28.650]                       }
[16:12:28.650]                       else if (inherits(cond, "warning")) {
[16:12:28.650]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.650]                         if (muffled) 
[16:12:28.650]                           invokeRestart("muffleWarning")
[16:12:28.650]                       }
[16:12:28.650]                       else if (inherits(cond, "condition")) {
[16:12:28.650]                         if (!is.null(pattern)) {
[16:12:28.650]                           computeRestarts <- base::computeRestarts
[16:12:28.650]                           grepl <- base::grepl
[16:12:28.650]                           restarts <- computeRestarts(cond)
[16:12:28.650]                           for (restart in restarts) {
[16:12:28.650]                             name <- restart$name
[16:12:28.650]                             if (is.null(name)) 
[16:12:28.650]                               next
[16:12:28.650]                             if (!grepl(pattern, name)) 
[16:12:28.650]                               next
[16:12:28.650]                             invokeRestart(restart)
[16:12:28.650]                             muffled <- TRUE
[16:12:28.650]                             break
[16:12:28.650]                           }
[16:12:28.650]                         }
[16:12:28.650]                       }
[16:12:28.650]                       invisible(muffled)
[16:12:28.650]                     }
[16:12:28.650]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.650]                   }
[16:12:28.650]                 }
[16:12:28.650]                 else {
[16:12:28.650]                   if (TRUE) {
[16:12:28.650]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.650]                     {
[16:12:28.650]                       inherits <- base::inherits
[16:12:28.650]                       invokeRestart <- base::invokeRestart
[16:12:28.650]                       is.null <- base::is.null
[16:12:28.650]                       muffled <- FALSE
[16:12:28.650]                       if (inherits(cond, "message")) {
[16:12:28.650]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.650]                         if (muffled) 
[16:12:28.650]                           invokeRestart("muffleMessage")
[16:12:28.650]                       }
[16:12:28.650]                       else if (inherits(cond, "warning")) {
[16:12:28.650]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.650]                         if (muffled) 
[16:12:28.650]                           invokeRestart("muffleWarning")
[16:12:28.650]                       }
[16:12:28.650]                       else if (inherits(cond, "condition")) {
[16:12:28.650]                         if (!is.null(pattern)) {
[16:12:28.650]                           computeRestarts <- base::computeRestarts
[16:12:28.650]                           grepl <- base::grepl
[16:12:28.650]                           restarts <- computeRestarts(cond)
[16:12:28.650]                           for (restart in restarts) {
[16:12:28.650]                             name <- restart$name
[16:12:28.650]                             if (is.null(name)) 
[16:12:28.650]                               next
[16:12:28.650]                             if (!grepl(pattern, name)) 
[16:12:28.650]                               next
[16:12:28.650]                             invokeRestart(restart)
[16:12:28.650]                             muffled <- TRUE
[16:12:28.650]                             break
[16:12:28.650]                           }
[16:12:28.650]                         }
[16:12:28.650]                       }
[16:12:28.650]                       invisible(muffled)
[16:12:28.650]                     }
[16:12:28.650]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.650]                   }
[16:12:28.650]                 }
[16:12:28.650]             }
[16:12:28.650]         }))
[16:12:28.650]     }, error = function(ex) {
[16:12:28.650]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.650]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.650]                 ...future.rng), started = ...future.startTime, 
[16:12:28.650]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.650]             version = "1.8"), class = "FutureResult")
[16:12:28.650]     }, finally = {
[16:12:28.650]         if (!identical(...future.workdir, getwd())) 
[16:12:28.650]             setwd(...future.workdir)
[16:12:28.650]         {
[16:12:28.650]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.650]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.650]             }
[16:12:28.650]             base::options(...future.oldOptions)
[16:12:28.650]             if (.Platform$OS.type == "windows") {
[16:12:28.650]                 old_names <- names(...future.oldEnvVars)
[16:12:28.650]                 envs <- base::Sys.getenv()
[16:12:28.650]                 names <- names(envs)
[16:12:28.650]                 common <- intersect(names, old_names)
[16:12:28.650]                 added <- setdiff(names, old_names)
[16:12:28.650]                 removed <- setdiff(old_names, names)
[16:12:28.650]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.650]                   envs[common]]
[16:12:28.650]                 NAMES <- toupper(changed)
[16:12:28.650]                 args <- list()
[16:12:28.650]                 for (kk in seq_along(NAMES)) {
[16:12:28.650]                   name <- changed[[kk]]
[16:12:28.650]                   NAME <- NAMES[[kk]]
[16:12:28.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.650]                     next
[16:12:28.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.650]                 }
[16:12:28.650]                 NAMES <- toupper(added)
[16:12:28.650]                 for (kk in seq_along(NAMES)) {
[16:12:28.650]                   name <- added[[kk]]
[16:12:28.650]                   NAME <- NAMES[[kk]]
[16:12:28.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.650]                     next
[16:12:28.650]                   args[[name]] <- ""
[16:12:28.650]                 }
[16:12:28.650]                 NAMES <- toupper(removed)
[16:12:28.650]                 for (kk in seq_along(NAMES)) {
[16:12:28.650]                   name <- removed[[kk]]
[16:12:28.650]                   NAME <- NAMES[[kk]]
[16:12:28.650]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.650]                     next
[16:12:28.650]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.650]                 }
[16:12:28.650]                 if (length(args) > 0) 
[16:12:28.650]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.650]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.650]             }
[16:12:28.650]             else {
[16:12:28.650]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.650]             }
[16:12:28.650]             {
[16:12:28.650]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.650]                   0L) {
[16:12:28.650]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.650]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.650]                   base::options(opts)
[16:12:28.650]                 }
[16:12:28.650]                 {
[16:12:28.650]                   {
[16:12:28.650]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.650]                     NULL
[16:12:28.650]                   }
[16:12:28.650]                   options(future.plan = NULL)
[16:12:28.650]                   if (is.na(NA_character_)) 
[16:12:28.650]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.650]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.650]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.650]                     envir = parent.frame()) 
[16:12:28.650]                   {
[16:12:28.650]                     default_workers <- missing(workers)
[16:12:28.650]                     if (is.function(workers)) 
[16:12:28.650]                       workers <- workers()
[16:12:28.650]                     workers <- structure(as.integer(workers), 
[16:12:28.650]                       class = class(workers))
[16:12:28.650]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.650]                       1L)
[16:12:28.650]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.650]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.650]                       if (default_workers) 
[16:12:28.650]                         supportsMulticore(warn = TRUE)
[16:12:28.650]                       return(sequential(..., envir = envir))
[16:12:28.650]                     }
[16:12:28.650]                     oopts <- options(mc.cores = workers)
[16:12:28.650]                     on.exit(options(oopts))
[16:12:28.650]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.650]                       envir = envir)
[16:12:28.650]                     if (!future$lazy) 
[16:12:28.650]                       future <- run(future)
[16:12:28.650]                     invisible(future)
[16:12:28.650]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.650]                 }
[16:12:28.650]             }
[16:12:28.650]         }
[16:12:28.650]     })
[16:12:28.650]     if (TRUE) {
[16:12:28.650]         base::sink(type = "output", split = FALSE)
[16:12:28.650]         if (TRUE) {
[16:12:28.650]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.650]         }
[16:12:28.650]         else {
[16:12:28.650]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.650]         }
[16:12:28.650]         base::close(...future.stdout)
[16:12:28.650]         ...future.stdout <- NULL
[16:12:28.650]     }
[16:12:28.650]     ...future.result$conditions <- ...future.conditions
[16:12:28.650]     ...future.result$finished <- base::Sys.time()
[16:12:28.650]     ...future.result
[16:12:28.650] }
[16:12:28.654] requestCore(): workers = 2
[16:12:28.654] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:28.673] MulticoreFuture started
[16:12:28.673] - Launch lazy future ... done
[16:12:28.674] run() for ‘MulticoreFuture’ ... done
[16:12:28.674] plan(): Setting new future strategy stack:
<environment: 0x560bb03a9828> 
[16:12:28.674] List of future strategies:
[16:12:28.674] 1. sequential:
[16:12:28.674]    - args: function (..., envir = parent.frame())
[16:12:28.674]    - tweaked: FALSE
[16:12:28.674]    - call: NULL
[16:12:28.675] plan(): nbrOfWorkers() = 1
<environment: 0x560baf3cd980> 
[16:12:28.677] plan(): Setting new future strategy stack:
[16:12:28.677] List of future strategies:
[16:12:28.677] 1. multicore:
[16:12:28.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.677]    - tweaked: FALSE
[16:12:28.677]    - call: plan(strategy)
[16:12:28.682] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:28.685] resolve() on environment ...
[16:12:28.685]  recursive: 0
[16:12:28.686]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:28.686] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.686] - nx: 4
[16:12:28.686] - relay: TRUE
[16:12:28.686] - stdout: TRUE
[16:12:28.687] - signal: TRUE
[16:12:28.687] - resignal: FALSE
[16:12:28.687] - force: TRUE
[16:12:28.687] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.687] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.687]  - until=2
[16:12:28.687]  - relaying element #2
[16:12:28.687] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.688] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.688] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.688]  length: 3 (resolved future 1)
[16:12:28.688] Future #2
[16:12:28.688] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:28.689] - nx: 4
[16:12:28.689] - relay: TRUE
[16:12:28.689] - stdout: TRUE
[16:12:28.689] - signal: TRUE
[16:12:28.689] - resignal: FALSE
[16:12:28.689] - force: TRUE
[16:12:28.689] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.689] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.690]  - until=2
[16:12:28.690]  - relaying element #2
[16:12:28.690] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.690] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.690] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:28.690]  length: 2 (resolved future 2)
[16:12:28.691] Future #3
[16:12:28.692] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:28.692] - nx: 4
[16:12:28.692] - relay: TRUE
[16:12:28.692] - stdout: TRUE
[16:12:28.693] - signal: TRUE
[16:12:28.693] - resignal: FALSE
[16:12:28.693] - force: TRUE
[16:12:28.693] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.693] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.693]  - until=3
[16:12:28.694]  - relaying element #3
[16:12:28.694] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.694] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.694] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:28.695]  length: 1 (resolved future 3)
[16:12:28.695] Future #4
[16:12:28.696] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:28.696] - nx: 4
[16:12:28.696] - relay: TRUE
[16:12:28.697] - stdout: TRUE
[16:12:28.697] - signal: TRUE
[16:12:28.697] - resignal: FALSE
[16:12:28.697] - force: TRUE
[16:12:28.697] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.697] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.697]  - until=4
[16:12:28.697]  - relaying element #4
[16:12:28.698] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.698] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:28.698] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:28.698]  length: 0 (resolved future 4)
[16:12:28.698] Relaying remaining futures
[16:12:28.698] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.698] - nx: 4
[16:12:28.698] - relay: TRUE
[16:12:28.698] - stdout: TRUE
[16:12:28.699] - signal: TRUE
[16:12:28.699] - resignal: FALSE
[16:12:28.699] - force: TRUE
[16:12:28.699] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.699] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:28.699] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.699] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:28.699] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.699] resolve() on environment ... DONE
<environment: 0x560baf206ef8> 
Dimensions: c(1, 6)
[16:12:28.700] getGlobalsAndPackages() ...
[16:12:28.700] Searching for globals...
[16:12:28.701] 
[16:12:28.701] Searching for globals ... DONE
[16:12:28.701] - globals: [0] <none>
[16:12:28.701] getGlobalsAndPackages() ... DONE
[16:12:28.701] run() for ‘Future’ ...
[16:12:28.701] - state: ‘created’
[16:12:28.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.706] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.706] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.706]   - Field: ‘label’
[16:12:28.706]   - Field: ‘local’
[16:12:28.706]   - Field: ‘owner’
[16:12:28.707]   - Field: ‘envir’
[16:12:28.707]   - Field: ‘workers’
[16:12:28.707]   - Field: ‘packages’
[16:12:28.707]   - Field: ‘gc’
[16:12:28.707]   - Field: ‘job’
[16:12:28.707]   - Field: ‘conditions’
[16:12:28.707]   - Field: ‘expr’
[16:12:28.707]   - Field: ‘uuid’
[16:12:28.707]   - Field: ‘seed’
[16:12:28.708]   - Field: ‘version’
[16:12:28.708]   - Field: ‘result’
[16:12:28.708]   - Field: ‘asynchronous’
[16:12:28.708]   - Field: ‘calls’
[16:12:28.708]   - Field: ‘globals’
[16:12:28.708]   - Field: ‘stdout’
[16:12:28.708]   - Field: ‘earlySignal’
[16:12:28.708]   - Field: ‘lazy’
[16:12:28.708]   - Field: ‘state’
[16:12:28.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.709] - Launch lazy future ...
[16:12:28.709] Packages needed by the future expression (n = 0): <none>
[16:12:28.709] Packages needed by future strategies (n = 0): <none>
[16:12:28.710] {
[16:12:28.710]     {
[16:12:28.710]         {
[16:12:28.710]             ...future.startTime <- base::Sys.time()
[16:12:28.710]             {
[16:12:28.710]                 {
[16:12:28.710]                   {
[16:12:28.710]                     {
[16:12:28.710]                       base::local({
[16:12:28.710]                         has_future <- base::requireNamespace("future", 
[16:12:28.710]                           quietly = TRUE)
[16:12:28.710]                         if (has_future) {
[16:12:28.710]                           ns <- base::getNamespace("future")
[16:12:28.710]                           version <- ns[[".package"]][["version"]]
[16:12:28.710]                           if (is.null(version)) 
[16:12:28.710]                             version <- utils::packageVersion("future")
[16:12:28.710]                         }
[16:12:28.710]                         else {
[16:12:28.710]                           version <- NULL
[16:12:28.710]                         }
[16:12:28.710]                         if (!has_future || version < "1.8.0") {
[16:12:28.710]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.710]                             "", base::R.version$version.string), 
[16:12:28.710]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.710]                               "release", "version")], collapse = " "), 
[16:12:28.710]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.710]                             info)
[16:12:28.710]                           info <- base::paste(info, collapse = "; ")
[16:12:28.710]                           if (!has_future) {
[16:12:28.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.710]                               info)
[16:12:28.710]                           }
[16:12:28.710]                           else {
[16:12:28.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.710]                               info, version)
[16:12:28.710]                           }
[16:12:28.710]                           base::stop(msg)
[16:12:28.710]                         }
[16:12:28.710]                       })
[16:12:28.710]                     }
[16:12:28.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.710]                     base::options(mc.cores = 1L)
[16:12:28.710]                   }
[16:12:28.710]                   options(future.plan = NULL)
[16:12:28.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.710]                 }
[16:12:28.710]                 ...future.workdir <- getwd()
[16:12:28.710]             }
[16:12:28.710]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.710]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.710]         }
[16:12:28.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.710]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.710]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.710]             base::names(...future.oldOptions))
[16:12:28.710]     }
[16:12:28.710]     if (FALSE) {
[16:12:28.710]     }
[16:12:28.710]     else {
[16:12:28.710]         if (TRUE) {
[16:12:28.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.710]                 open = "w")
[16:12:28.710]         }
[16:12:28.710]         else {
[16:12:28.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.710]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.710]         }
[16:12:28.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.710]             base::sink(type = "output", split = FALSE)
[16:12:28.710]             base::close(...future.stdout)
[16:12:28.710]         }, add = TRUE)
[16:12:28.710]     }
[16:12:28.710]     ...future.frame <- base::sys.nframe()
[16:12:28.710]     ...future.conditions <- base::list()
[16:12:28.710]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.710]     if (FALSE) {
[16:12:28.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.710]     }
[16:12:28.710]     ...future.result <- base::tryCatch({
[16:12:28.710]         base::withCallingHandlers({
[16:12:28.710]             ...future.value <- base::withVisible(base::local({
[16:12:28.710]                 withCallingHandlers({
[16:12:28.710]                   2
[16:12:28.710]                 }, immediateCondition = function(cond) {
[16:12:28.710]                   save_rds <- function (object, pathname, ...) 
[16:12:28.710]                   {
[16:12:28.710]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.710]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.710]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.710]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.710]                         fi_tmp[["mtime"]])
[16:12:28.710]                     }
[16:12:28.710]                     tryCatch({
[16:12:28.710]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.710]                     }, error = function(ex) {
[16:12:28.710]                       msg <- conditionMessage(ex)
[16:12:28.710]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.710]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.710]                         fi_tmp[["mtime"]], msg)
[16:12:28.710]                       ex$message <- msg
[16:12:28.710]                       stop(ex)
[16:12:28.710]                     })
[16:12:28.710]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.710]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.710]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.710]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.710]                       fi <- file.info(pathname)
[16:12:28.710]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.710]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.710]                         fi[["size"]], fi[["mtime"]])
[16:12:28.710]                       stop(msg)
[16:12:28.710]                     }
[16:12:28.710]                     invisible(pathname)
[16:12:28.710]                   }
[16:12:28.710]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.710]                     rootPath = tempdir()) 
[16:12:28.710]                   {
[16:12:28.710]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.710]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.710]                       tmpdir = path, fileext = ".rds")
[16:12:28.710]                     save_rds(obj, file)
[16:12:28.710]                   }
[16:12:28.710]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.710]                   {
[16:12:28.710]                     inherits <- base::inherits
[16:12:28.710]                     invokeRestart <- base::invokeRestart
[16:12:28.710]                     is.null <- base::is.null
[16:12:28.710]                     muffled <- FALSE
[16:12:28.710]                     if (inherits(cond, "message")) {
[16:12:28.710]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.710]                       if (muffled) 
[16:12:28.710]                         invokeRestart("muffleMessage")
[16:12:28.710]                     }
[16:12:28.710]                     else if (inherits(cond, "warning")) {
[16:12:28.710]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.710]                       if (muffled) 
[16:12:28.710]                         invokeRestart("muffleWarning")
[16:12:28.710]                     }
[16:12:28.710]                     else if (inherits(cond, "condition")) {
[16:12:28.710]                       if (!is.null(pattern)) {
[16:12:28.710]                         computeRestarts <- base::computeRestarts
[16:12:28.710]                         grepl <- base::grepl
[16:12:28.710]                         restarts <- computeRestarts(cond)
[16:12:28.710]                         for (restart in restarts) {
[16:12:28.710]                           name <- restart$name
[16:12:28.710]                           if (is.null(name)) 
[16:12:28.710]                             next
[16:12:28.710]                           if (!grepl(pattern, name)) 
[16:12:28.710]                             next
[16:12:28.710]                           invokeRestart(restart)
[16:12:28.710]                           muffled <- TRUE
[16:12:28.710]                           break
[16:12:28.710]                         }
[16:12:28.710]                       }
[16:12:28.710]                     }
[16:12:28.710]                     invisible(muffled)
[16:12:28.710]                   }
[16:12:28.710]                   muffleCondition(cond)
[16:12:28.710]                 })
[16:12:28.710]             }))
[16:12:28.710]             future::FutureResult(value = ...future.value$value, 
[16:12:28.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.710]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.710]                     ...future.globalenv.names))
[16:12:28.710]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.710]         }, condition = base::local({
[16:12:28.710]             c <- base::c
[16:12:28.710]             inherits <- base::inherits
[16:12:28.710]             invokeRestart <- base::invokeRestart
[16:12:28.710]             length <- base::length
[16:12:28.710]             list <- base::list
[16:12:28.710]             seq.int <- base::seq.int
[16:12:28.710]             signalCondition <- base::signalCondition
[16:12:28.710]             sys.calls <- base::sys.calls
[16:12:28.710]             `[[` <- base::`[[`
[16:12:28.710]             `+` <- base::`+`
[16:12:28.710]             `<<-` <- base::`<<-`
[16:12:28.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.710]                   3L)]
[16:12:28.710]             }
[16:12:28.710]             function(cond) {
[16:12:28.710]                 is_error <- inherits(cond, "error")
[16:12:28.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.710]                   NULL)
[16:12:28.710]                 if (is_error) {
[16:12:28.710]                   sessionInformation <- function() {
[16:12:28.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.710]                       search = base::search(), system = base::Sys.info())
[16:12:28.710]                   }
[16:12:28.710]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.710]                     cond$call), session = sessionInformation(), 
[16:12:28.710]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.710]                   signalCondition(cond)
[16:12:28.710]                 }
[16:12:28.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.710]                 "immediateCondition"))) {
[16:12:28.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.710]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.710]                   if (TRUE && !signal) {
[16:12:28.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.710]                     {
[16:12:28.710]                       inherits <- base::inherits
[16:12:28.710]                       invokeRestart <- base::invokeRestart
[16:12:28.710]                       is.null <- base::is.null
[16:12:28.710]                       muffled <- FALSE
[16:12:28.710]                       if (inherits(cond, "message")) {
[16:12:28.710]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.710]                         if (muffled) 
[16:12:28.710]                           invokeRestart("muffleMessage")
[16:12:28.710]                       }
[16:12:28.710]                       else if (inherits(cond, "warning")) {
[16:12:28.710]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.710]                         if (muffled) 
[16:12:28.710]                           invokeRestart("muffleWarning")
[16:12:28.710]                       }
[16:12:28.710]                       else if (inherits(cond, "condition")) {
[16:12:28.710]                         if (!is.null(pattern)) {
[16:12:28.710]                           computeRestarts <- base::computeRestarts
[16:12:28.710]                           grepl <- base::grepl
[16:12:28.710]                           restarts <- computeRestarts(cond)
[16:12:28.710]                           for (restart in restarts) {
[16:12:28.710]                             name <- restart$name
[16:12:28.710]                             if (is.null(name)) 
[16:12:28.710]                               next
[16:12:28.710]                             if (!grepl(pattern, name)) 
[16:12:28.710]                               next
[16:12:28.710]                             invokeRestart(restart)
[16:12:28.710]                             muffled <- TRUE
[16:12:28.710]                             break
[16:12:28.710]                           }
[16:12:28.710]                         }
[16:12:28.710]                       }
[16:12:28.710]                       invisible(muffled)
[16:12:28.710]                     }
[16:12:28.710]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.710]                   }
[16:12:28.710]                 }
[16:12:28.710]                 else {
[16:12:28.710]                   if (TRUE) {
[16:12:28.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.710]                     {
[16:12:28.710]                       inherits <- base::inherits
[16:12:28.710]                       invokeRestart <- base::invokeRestart
[16:12:28.710]                       is.null <- base::is.null
[16:12:28.710]                       muffled <- FALSE
[16:12:28.710]                       if (inherits(cond, "message")) {
[16:12:28.710]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.710]                         if (muffled) 
[16:12:28.710]                           invokeRestart("muffleMessage")
[16:12:28.710]                       }
[16:12:28.710]                       else if (inherits(cond, "warning")) {
[16:12:28.710]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.710]                         if (muffled) 
[16:12:28.710]                           invokeRestart("muffleWarning")
[16:12:28.710]                       }
[16:12:28.710]                       else if (inherits(cond, "condition")) {
[16:12:28.710]                         if (!is.null(pattern)) {
[16:12:28.710]                           computeRestarts <- base::computeRestarts
[16:12:28.710]                           grepl <- base::grepl
[16:12:28.710]                           restarts <- computeRestarts(cond)
[16:12:28.710]                           for (restart in restarts) {
[16:12:28.710]                             name <- restart$name
[16:12:28.710]                             if (is.null(name)) 
[16:12:28.710]                               next
[16:12:28.710]                             if (!grepl(pattern, name)) 
[16:12:28.710]                               next
[16:12:28.710]                             invokeRestart(restart)
[16:12:28.710]                             muffled <- TRUE
[16:12:28.710]                             break
[16:12:28.710]                           }
[16:12:28.710]                         }
[16:12:28.710]                       }
[16:12:28.710]                       invisible(muffled)
[16:12:28.710]                     }
[16:12:28.710]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.710]                   }
[16:12:28.710]                 }
[16:12:28.710]             }
[16:12:28.710]         }))
[16:12:28.710]     }, error = function(ex) {
[16:12:28.710]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.710]                 ...future.rng), started = ...future.startTime, 
[16:12:28.710]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.710]             version = "1.8"), class = "FutureResult")
[16:12:28.710]     }, finally = {
[16:12:28.710]         if (!identical(...future.workdir, getwd())) 
[16:12:28.710]             setwd(...future.workdir)
[16:12:28.710]         {
[16:12:28.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.710]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.710]             }
[16:12:28.710]             base::options(...future.oldOptions)
[16:12:28.710]             if (.Platform$OS.type == "windows") {
[16:12:28.710]                 old_names <- names(...future.oldEnvVars)
[16:12:28.710]                 envs <- base::Sys.getenv()
[16:12:28.710]                 names <- names(envs)
[16:12:28.710]                 common <- intersect(names, old_names)
[16:12:28.710]                 added <- setdiff(names, old_names)
[16:12:28.710]                 removed <- setdiff(old_names, names)
[16:12:28.710]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.710]                   envs[common]]
[16:12:28.710]                 NAMES <- toupper(changed)
[16:12:28.710]                 args <- list()
[16:12:28.710]                 for (kk in seq_along(NAMES)) {
[16:12:28.710]                   name <- changed[[kk]]
[16:12:28.710]                   NAME <- NAMES[[kk]]
[16:12:28.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.710]                     next
[16:12:28.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.710]                 }
[16:12:28.710]                 NAMES <- toupper(added)
[16:12:28.710]                 for (kk in seq_along(NAMES)) {
[16:12:28.710]                   name <- added[[kk]]
[16:12:28.710]                   NAME <- NAMES[[kk]]
[16:12:28.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.710]                     next
[16:12:28.710]                   args[[name]] <- ""
[16:12:28.710]                 }
[16:12:28.710]                 NAMES <- toupper(removed)
[16:12:28.710]                 for (kk in seq_along(NAMES)) {
[16:12:28.710]                   name <- removed[[kk]]
[16:12:28.710]                   NAME <- NAMES[[kk]]
[16:12:28.710]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.710]                     next
[16:12:28.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.710]                 }
[16:12:28.710]                 if (length(args) > 0) 
[16:12:28.710]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.710]             }
[16:12:28.710]             else {
[16:12:28.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.710]             }
[16:12:28.710]             {
[16:12:28.710]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.710]                   0L) {
[16:12:28.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.710]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.710]                   base::options(opts)
[16:12:28.710]                 }
[16:12:28.710]                 {
[16:12:28.710]                   {
[16:12:28.710]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.710]                     NULL
[16:12:28.710]                   }
[16:12:28.710]                   options(future.plan = NULL)
[16:12:28.710]                   if (is.na(NA_character_)) 
[16:12:28.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.710]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.710]                     envir = parent.frame()) 
[16:12:28.710]                   {
[16:12:28.710]                     default_workers <- missing(workers)
[16:12:28.710]                     if (is.function(workers)) 
[16:12:28.710]                       workers <- workers()
[16:12:28.710]                     workers <- structure(as.integer(workers), 
[16:12:28.710]                       class = class(workers))
[16:12:28.710]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.710]                       1L)
[16:12:28.710]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.710]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.710]                       if (default_workers) 
[16:12:28.710]                         supportsMulticore(warn = TRUE)
[16:12:28.710]                       return(sequential(..., envir = envir))
[16:12:28.710]                     }
[16:12:28.710]                     oopts <- options(mc.cores = workers)
[16:12:28.710]                     on.exit(options(oopts))
[16:12:28.710]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.710]                       envir = envir)
[16:12:28.710]                     if (!future$lazy) 
[16:12:28.710]                       future <- run(future)
[16:12:28.710]                     invisible(future)
[16:12:28.710]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.710]                 }
[16:12:28.710]             }
[16:12:28.710]         }
[16:12:28.710]     })
[16:12:28.710]     if (TRUE) {
[16:12:28.710]         base::sink(type = "output", split = FALSE)
[16:12:28.710]         if (TRUE) {
[16:12:28.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.710]         }
[16:12:28.710]         else {
[16:12:28.710]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.710]         }
[16:12:28.710]         base::close(...future.stdout)
[16:12:28.710]         ...future.stdout <- NULL
[16:12:28.710]     }
[16:12:28.710]     ...future.result$conditions <- ...future.conditions
[16:12:28.710]     ...future.result$finished <- base::Sys.time()
[16:12:28.710]     ...future.result
[16:12:28.710] }
[16:12:28.713] requestCore(): workers = 2
[16:12:28.715] MulticoreFuture started
[16:12:28.715] - Launch lazy future ... done
[16:12:28.715] run() for ‘MulticoreFuture’ ... done
[16:12:28.716] getGlobalsAndPackages() ...
[16:12:28.716] Searching for globals...
[16:12:28.716] plan(): Setting new future strategy stack:
[16:12:28.717] 
[16:12:28.716] List of future strategies:
[16:12:28.716] 1. sequential:
[16:12:28.716]    - args: function (..., envir = parent.frame())
[16:12:28.716]    - tweaked: FALSE
[16:12:28.716]    - call: NULL
[16:12:28.717] Searching for globals ... DONE
[16:12:28.717] plan(): nbrOfWorkers() = 1
[16:12:28.717] - globals: [0] <none>
[16:12:28.717] getGlobalsAndPackages() ... DONE
[16:12:28.718] run() for ‘Future’ ...
[16:12:28.718] - state: ‘created’
[16:12:28.719] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.719] plan(): Setting new future strategy stack:
[16:12:28.719] List of future strategies:
[16:12:28.719] 1. multicore:
[16:12:28.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.719]    - tweaked: FALSE
[16:12:28.719]    - call: plan(strategy)
[16:12:28.724] plan(): nbrOfWorkers() = 2
[16:12:28.724] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.724] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.725]   - Field: ‘label’
[16:12:28.725]   - Field: ‘local’
[16:12:28.725]   - Field: ‘owner’
[16:12:28.725]   - Field: ‘envir’
[16:12:28.725]   - Field: ‘workers’
[16:12:28.726]   - Field: ‘packages’
[16:12:28.726]   - Field: ‘gc’
[16:12:28.726]   - Field: ‘job’
[16:12:28.726]   - Field: ‘conditions’
[16:12:28.726]   - Field: ‘expr’
[16:12:28.726]   - Field: ‘uuid’
[16:12:28.727]   - Field: ‘seed’
[16:12:28.727]   - Field: ‘version’
[16:12:28.727]   - Field: ‘result’
[16:12:28.727]   - Field: ‘asynchronous’
[16:12:28.727]   - Field: ‘calls’
[16:12:28.727]   - Field: ‘globals’
[16:12:28.728]   - Field: ‘stdout’
[16:12:28.728]   - Field: ‘earlySignal’
[16:12:28.728]   - Field: ‘lazy’
[16:12:28.728]   - Field: ‘state’
[16:12:28.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.729] - Launch lazy future ...
[16:12:28.729] Packages needed by the future expression (n = 0): <none>
[16:12:28.729] Packages needed by future strategies (n = 0): <none>
[16:12:28.730] {
[16:12:28.730]     {
[16:12:28.730]         {
[16:12:28.730]             ...future.startTime <- base::Sys.time()
[16:12:28.730]             {
[16:12:28.730]                 {
[16:12:28.730]                   {
[16:12:28.730]                     {
[16:12:28.730]                       base::local({
[16:12:28.730]                         has_future <- base::requireNamespace("future", 
[16:12:28.730]                           quietly = TRUE)
[16:12:28.730]                         if (has_future) {
[16:12:28.730]                           ns <- base::getNamespace("future")
[16:12:28.730]                           version <- ns[[".package"]][["version"]]
[16:12:28.730]                           if (is.null(version)) 
[16:12:28.730]                             version <- utils::packageVersion("future")
[16:12:28.730]                         }
[16:12:28.730]                         else {
[16:12:28.730]                           version <- NULL
[16:12:28.730]                         }
[16:12:28.730]                         if (!has_future || version < "1.8.0") {
[16:12:28.730]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.730]                             "", base::R.version$version.string), 
[16:12:28.730]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.730]                               "release", "version")], collapse = " "), 
[16:12:28.730]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.730]                             info)
[16:12:28.730]                           info <- base::paste(info, collapse = "; ")
[16:12:28.730]                           if (!has_future) {
[16:12:28.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.730]                               info)
[16:12:28.730]                           }
[16:12:28.730]                           else {
[16:12:28.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.730]                               info, version)
[16:12:28.730]                           }
[16:12:28.730]                           base::stop(msg)
[16:12:28.730]                         }
[16:12:28.730]                       })
[16:12:28.730]                     }
[16:12:28.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.730]                     base::options(mc.cores = 1L)
[16:12:28.730]                   }
[16:12:28.730]                   options(future.plan = NULL)
[16:12:28.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.730]                 }
[16:12:28.730]                 ...future.workdir <- getwd()
[16:12:28.730]             }
[16:12:28.730]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.730]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.730]         }
[16:12:28.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.730]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.730]             base::names(...future.oldOptions))
[16:12:28.730]     }
[16:12:28.730]     if (FALSE) {
[16:12:28.730]     }
[16:12:28.730]     else {
[16:12:28.730]         if (TRUE) {
[16:12:28.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.730]                 open = "w")
[16:12:28.730]         }
[16:12:28.730]         else {
[16:12:28.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.730]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.730]         }
[16:12:28.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.730]             base::sink(type = "output", split = FALSE)
[16:12:28.730]             base::close(...future.stdout)
[16:12:28.730]         }, add = TRUE)
[16:12:28.730]     }
[16:12:28.730]     ...future.frame <- base::sys.nframe()
[16:12:28.730]     ...future.conditions <- base::list()
[16:12:28.730]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.730]     if (FALSE) {
[16:12:28.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.730]     }
[16:12:28.730]     ...future.result <- base::tryCatch({
[16:12:28.730]         base::withCallingHandlers({
[16:12:28.730]             ...future.value <- base::withVisible(base::local({
[16:12:28.730]                 withCallingHandlers({
[16:12:28.730]                   NULL
[16:12:28.730]                 }, immediateCondition = function(cond) {
[16:12:28.730]                   save_rds <- function (object, pathname, ...) 
[16:12:28.730]                   {
[16:12:28.730]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.730]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.730]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.730]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.730]                         fi_tmp[["mtime"]])
[16:12:28.730]                     }
[16:12:28.730]                     tryCatch({
[16:12:28.730]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.730]                     }, error = function(ex) {
[16:12:28.730]                       msg <- conditionMessage(ex)
[16:12:28.730]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.730]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.730]                         fi_tmp[["mtime"]], msg)
[16:12:28.730]                       ex$message <- msg
[16:12:28.730]                       stop(ex)
[16:12:28.730]                     })
[16:12:28.730]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.730]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.730]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.730]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.730]                       fi <- file.info(pathname)
[16:12:28.730]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.730]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.730]                         fi[["size"]], fi[["mtime"]])
[16:12:28.730]                       stop(msg)
[16:12:28.730]                     }
[16:12:28.730]                     invisible(pathname)
[16:12:28.730]                   }
[16:12:28.730]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.730]                     rootPath = tempdir()) 
[16:12:28.730]                   {
[16:12:28.730]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.730]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.730]                       tmpdir = path, fileext = ".rds")
[16:12:28.730]                     save_rds(obj, file)
[16:12:28.730]                   }
[16:12:28.730]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.730]                   {
[16:12:28.730]                     inherits <- base::inherits
[16:12:28.730]                     invokeRestart <- base::invokeRestart
[16:12:28.730]                     is.null <- base::is.null
[16:12:28.730]                     muffled <- FALSE
[16:12:28.730]                     if (inherits(cond, "message")) {
[16:12:28.730]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.730]                       if (muffled) 
[16:12:28.730]                         invokeRestart("muffleMessage")
[16:12:28.730]                     }
[16:12:28.730]                     else if (inherits(cond, "warning")) {
[16:12:28.730]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.730]                       if (muffled) 
[16:12:28.730]                         invokeRestart("muffleWarning")
[16:12:28.730]                     }
[16:12:28.730]                     else if (inherits(cond, "condition")) {
[16:12:28.730]                       if (!is.null(pattern)) {
[16:12:28.730]                         computeRestarts <- base::computeRestarts
[16:12:28.730]                         grepl <- base::grepl
[16:12:28.730]                         restarts <- computeRestarts(cond)
[16:12:28.730]                         for (restart in restarts) {
[16:12:28.730]                           name <- restart$name
[16:12:28.730]                           if (is.null(name)) 
[16:12:28.730]                             next
[16:12:28.730]                           if (!grepl(pattern, name)) 
[16:12:28.730]                             next
[16:12:28.730]                           invokeRestart(restart)
[16:12:28.730]                           muffled <- TRUE
[16:12:28.730]                           break
[16:12:28.730]                         }
[16:12:28.730]                       }
[16:12:28.730]                     }
[16:12:28.730]                     invisible(muffled)
[16:12:28.730]                   }
[16:12:28.730]                   muffleCondition(cond)
[16:12:28.730]                 })
[16:12:28.730]             }))
[16:12:28.730]             future::FutureResult(value = ...future.value$value, 
[16:12:28.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.730]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.730]                     ...future.globalenv.names))
[16:12:28.730]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.730]         }, condition = base::local({
[16:12:28.730]             c <- base::c
[16:12:28.730]             inherits <- base::inherits
[16:12:28.730]             invokeRestart <- base::invokeRestart
[16:12:28.730]             length <- base::length
[16:12:28.730]             list <- base::list
[16:12:28.730]             seq.int <- base::seq.int
[16:12:28.730]             signalCondition <- base::signalCondition
[16:12:28.730]             sys.calls <- base::sys.calls
[16:12:28.730]             `[[` <- base::`[[`
[16:12:28.730]             `+` <- base::`+`
[16:12:28.730]             `<<-` <- base::`<<-`
[16:12:28.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.730]                   3L)]
[16:12:28.730]             }
[16:12:28.730]             function(cond) {
[16:12:28.730]                 is_error <- inherits(cond, "error")
[16:12:28.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.730]                   NULL)
[16:12:28.730]                 if (is_error) {
[16:12:28.730]                   sessionInformation <- function() {
[16:12:28.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.730]                       search = base::search(), system = base::Sys.info())
[16:12:28.730]                   }
[16:12:28.730]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.730]                     cond$call), session = sessionInformation(), 
[16:12:28.730]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.730]                   signalCondition(cond)
[16:12:28.730]                 }
[16:12:28.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.730]                 "immediateCondition"))) {
[16:12:28.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.730]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.730]                   if (TRUE && !signal) {
[16:12:28.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.730]                     {
[16:12:28.730]                       inherits <- base::inherits
[16:12:28.730]                       invokeRestart <- base::invokeRestart
[16:12:28.730]                       is.null <- base::is.null
[16:12:28.730]                       muffled <- FALSE
[16:12:28.730]                       if (inherits(cond, "message")) {
[16:12:28.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.730]                         if (muffled) 
[16:12:28.730]                           invokeRestart("muffleMessage")
[16:12:28.730]                       }
[16:12:28.730]                       else if (inherits(cond, "warning")) {
[16:12:28.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.730]                         if (muffled) 
[16:12:28.730]                           invokeRestart("muffleWarning")
[16:12:28.730]                       }
[16:12:28.730]                       else if (inherits(cond, "condition")) {
[16:12:28.730]                         if (!is.null(pattern)) {
[16:12:28.730]                           computeRestarts <- base::computeRestarts
[16:12:28.730]                           grepl <- base::grepl
[16:12:28.730]                           restarts <- computeRestarts(cond)
[16:12:28.730]                           for (restart in restarts) {
[16:12:28.730]                             name <- restart$name
[16:12:28.730]                             if (is.null(name)) 
[16:12:28.730]                               next
[16:12:28.730]                             if (!grepl(pattern, name)) 
[16:12:28.730]                               next
[16:12:28.730]                             invokeRestart(restart)
[16:12:28.730]                             muffled <- TRUE
[16:12:28.730]                             break
[16:12:28.730]                           }
[16:12:28.730]                         }
[16:12:28.730]                       }
[16:12:28.730]                       invisible(muffled)
[16:12:28.730]                     }
[16:12:28.730]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.730]                   }
[16:12:28.730]                 }
[16:12:28.730]                 else {
[16:12:28.730]                   if (TRUE) {
[16:12:28.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.730]                     {
[16:12:28.730]                       inherits <- base::inherits
[16:12:28.730]                       invokeRestart <- base::invokeRestart
[16:12:28.730]                       is.null <- base::is.null
[16:12:28.730]                       muffled <- FALSE
[16:12:28.730]                       if (inherits(cond, "message")) {
[16:12:28.730]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.730]                         if (muffled) 
[16:12:28.730]                           invokeRestart("muffleMessage")
[16:12:28.730]                       }
[16:12:28.730]                       else if (inherits(cond, "warning")) {
[16:12:28.730]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.730]                         if (muffled) 
[16:12:28.730]                           invokeRestart("muffleWarning")
[16:12:28.730]                       }
[16:12:28.730]                       else if (inherits(cond, "condition")) {
[16:12:28.730]                         if (!is.null(pattern)) {
[16:12:28.730]                           computeRestarts <- base::computeRestarts
[16:12:28.730]                           grepl <- base::grepl
[16:12:28.730]                           restarts <- computeRestarts(cond)
[16:12:28.730]                           for (restart in restarts) {
[16:12:28.730]                             name <- restart$name
[16:12:28.730]                             if (is.null(name)) 
[16:12:28.730]                               next
[16:12:28.730]                             if (!grepl(pattern, name)) 
[16:12:28.730]                               next
[16:12:28.730]                             invokeRestart(restart)
[16:12:28.730]                             muffled <- TRUE
[16:12:28.730]                             break
[16:12:28.730]                           }
[16:12:28.730]                         }
[16:12:28.730]                       }
[16:12:28.730]                       invisible(muffled)
[16:12:28.730]                     }
[16:12:28.730]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.730]                   }
[16:12:28.730]                 }
[16:12:28.730]             }
[16:12:28.730]         }))
[16:12:28.730]     }, error = function(ex) {
[16:12:28.730]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.730]                 ...future.rng), started = ...future.startTime, 
[16:12:28.730]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.730]             version = "1.8"), class = "FutureResult")
[16:12:28.730]     }, finally = {
[16:12:28.730]         if (!identical(...future.workdir, getwd())) 
[16:12:28.730]             setwd(...future.workdir)
[16:12:28.730]         {
[16:12:28.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.730]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.730]             }
[16:12:28.730]             base::options(...future.oldOptions)
[16:12:28.730]             if (.Platform$OS.type == "windows") {
[16:12:28.730]                 old_names <- names(...future.oldEnvVars)
[16:12:28.730]                 envs <- base::Sys.getenv()
[16:12:28.730]                 names <- names(envs)
[16:12:28.730]                 common <- intersect(names, old_names)
[16:12:28.730]                 added <- setdiff(names, old_names)
[16:12:28.730]                 removed <- setdiff(old_names, names)
[16:12:28.730]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.730]                   envs[common]]
[16:12:28.730]                 NAMES <- toupper(changed)
[16:12:28.730]                 args <- list()
[16:12:28.730]                 for (kk in seq_along(NAMES)) {
[16:12:28.730]                   name <- changed[[kk]]
[16:12:28.730]                   NAME <- NAMES[[kk]]
[16:12:28.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.730]                     next
[16:12:28.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.730]                 }
[16:12:28.730]                 NAMES <- toupper(added)
[16:12:28.730]                 for (kk in seq_along(NAMES)) {
[16:12:28.730]                   name <- added[[kk]]
[16:12:28.730]                   NAME <- NAMES[[kk]]
[16:12:28.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.730]                     next
[16:12:28.730]                   args[[name]] <- ""
[16:12:28.730]                 }
[16:12:28.730]                 NAMES <- toupper(removed)
[16:12:28.730]                 for (kk in seq_along(NAMES)) {
[16:12:28.730]                   name <- removed[[kk]]
[16:12:28.730]                   NAME <- NAMES[[kk]]
[16:12:28.730]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.730]                     next
[16:12:28.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.730]                 }
[16:12:28.730]                 if (length(args) > 0) 
[16:12:28.730]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.730]             }
[16:12:28.730]             else {
[16:12:28.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.730]             }
[16:12:28.730]             {
[16:12:28.730]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.730]                   0L) {
[16:12:28.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.730]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.730]                   base::options(opts)
[16:12:28.730]                 }
[16:12:28.730]                 {
[16:12:28.730]                   {
[16:12:28.730]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.730]                     NULL
[16:12:28.730]                   }
[16:12:28.730]                   options(future.plan = NULL)
[16:12:28.730]                   if (is.na(NA_character_)) 
[16:12:28.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.730]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.730]                     envir = parent.frame()) 
[16:12:28.730]                   {
[16:12:28.730]                     default_workers <- missing(workers)
[16:12:28.730]                     if (is.function(workers)) 
[16:12:28.730]                       workers <- workers()
[16:12:28.730]                     workers <- structure(as.integer(workers), 
[16:12:28.730]                       class = class(workers))
[16:12:28.730]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.730]                       1L)
[16:12:28.730]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.730]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.730]                       if (default_workers) 
[16:12:28.730]                         supportsMulticore(warn = TRUE)
[16:12:28.730]                       return(sequential(..., envir = envir))
[16:12:28.730]                     }
[16:12:28.730]                     oopts <- options(mc.cores = workers)
[16:12:28.730]                     on.exit(options(oopts))
[16:12:28.730]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.730]                       envir = envir)
[16:12:28.730]                     if (!future$lazy) 
[16:12:28.730]                       future <- run(future)
[16:12:28.730]                     invisible(future)
[16:12:28.730]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.730]                 }
[16:12:28.730]             }
[16:12:28.730]         }
[16:12:28.730]     })
[16:12:28.730]     if (TRUE) {
[16:12:28.730]         base::sink(type = "output", split = FALSE)
[16:12:28.730]         if (TRUE) {
[16:12:28.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.730]         }
[16:12:28.730]         else {
[16:12:28.730]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.730]         }
[16:12:28.730]         base::close(...future.stdout)
[16:12:28.730]         ...future.stdout <- NULL
[16:12:28.730]     }
[16:12:28.730]     ...future.result$conditions <- ...future.conditions
[16:12:28.730]     ...future.result$finished <- base::Sys.time()
[16:12:28.730]     ...future.result
[16:12:28.730] }
[16:12:28.734] requestCore(): workers = 2
[16:12:28.736] MulticoreFuture started
[16:12:28.737] - Launch lazy future ... done
[16:12:28.737] run() for ‘MulticoreFuture’ ... done
[16:12:28.738] plan(): Setting new future strategy stack:
[16:12:28.738] getGlobalsAndPackages() ...
[16:12:28.738] Searching for globals...
[16:12:28.738] List of future strategies:
[16:12:28.738] 1. sequential:
[16:12:28.738]    - args: function (..., envir = parent.frame())
[16:12:28.738]    - tweaked: FALSE
[16:12:28.738]    - call: NULL
[16:12:28.739] plan(): nbrOfWorkers() = 1
[16:12:28.739] - globals found: [1] ‘{’
[16:12:28.740] Searching for globals ... DONE
[16:12:28.740] Resolving globals: FALSE
[16:12:28.740] 
[16:12:28.740] 
[16:12:28.741] getGlobalsAndPackages() ... DONE
[16:12:28.741] plan(): Setting new future strategy stack:
[16:12:28.741] run() for ‘Future’ ...
[16:12:28.741] - state: ‘created’
[16:12:28.741] List of future strategies:
[16:12:28.741] 1. multicore:
[16:12:28.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.741]    - tweaked: FALSE
[16:12:28.741]    - call: plan(strategy)
[16:12:28.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.746] plan(): nbrOfWorkers() = 2
[16:12:28.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.747]   - Field: ‘label’
[16:12:28.747]   - Field: ‘local’
[16:12:28.747]   - Field: ‘owner’
[16:12:28.747]   - Field: ‘envir’
[16:12:28.747]   - Field: ‘workers’
[16:12:28.747]   - Field: ‘packages’
[16:12:28.748]   - Field: ‘gc’
[16:12:28.748]   - Field: ‘job’
[16:12:28.748]   - Field: ‘conditions’
[16:12:28.748]   - Field: ‘expr’
[16:12:28.748]   - Field: ‘uuid’
[16:12:28.748]   - Field: ‘seed’
[16:12:28.749]   - Field: ‘version’
[16:12:28.749]   - Field: ‘result’
[16:12:28.749]   - Field: ‘asynchronous’
[16:12:28.749]   - Field: ‘calls’
[16:12:28.749]   - Field: ‘globals’
[16:12:28.749]   - Field: ‘stdout’
[16:12:28.749]   - Field: ‘earlySignal’
[16:12:28.749]   - Field: ‘lazy’
[16:12:28.750]   - Field: ‘state’
[16:12:28.750] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.750] - Launch lazy future ...
[16:12:28.750] Packages needed by the future expression (n = 0): <none>
[16:12:28.751] Packages needed by future strategies (n = 0): <none>
[16:12:28.751] {
[16:12:28.751]     {
[16:12:28.751]         {
[16:12:28.751]             ...future.startTime <- base::Sys.time()
[16:12:28.751]             {
[16:12:28.751]                 {
[16:12:28.751]                   {
[16:12:28.751]                     {
[16:12:28.751]                       base::local({
[16:12:28.751]                         has_future <- base::requireNamespace("future", 
[16:12:28.751]                           quietly = TRUE)
[16:12:28.751]                         if (has_future) {
[16:12:28.751]                           ns <- base::getNamespace("future")
[16:12:28.751]                           version <- ns[[".package"]][["version"]]
[16:12:28.751]                           if (is.null(version)) 
[16:12:28.751]                             version <- utils::packageVersion("future")
[16:12:28.751]                         }
[16:12:28.751]                         else {
[16:12:28.751]                           version <- NULL
[16:12:28.751]                         }
[16:12:28.751]                         if (!has_future || version < "1.8.0") {
[16:12:28.751]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.751]                             "", base::R.version$version.string), 
[16:12:28.751]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.751]                               "release", "version")], collapse = " "), 
[16:12:28.751]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.751]                             info)
[16:12:28.751]                           info <- base::paste(info, collapse = "; ")
[16:12:28.751]                           if (!has_future) {
[16:12:28.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.751]                               info)
[16:12:28.751]                           }
[16:12:28.751]                           else {
[16:12:28.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.751]                               info, version)
[16:12:28.751]                           }
[16:12:28.751]                           base::stop(msg)
[16:12:28.751]                         }
[16:12:28.751]                       })
[16:12:28.751]                     }
[16:12:28.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.751]                     base::options(mc.cores = 1L)
[16:12:28.751]                   }
[16:12:28.751]                   options(future.plan = NULL)
[16:12:28.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.751]                 }
[16:12:28.751]                 ...future.workdir <- getwd()
[16:12:28.751]             }
[16:12:28.751]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.751]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.751]         }
[16:12:28.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.751]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.751]             base::names(...future.oldOptions))
[16:12:28.751]     }
[16:12:28.751]     if (FALSE) {
[16:12:28.751]     }
[16:12:28.751]     else {
[16:12:28.751]         if (TRUE) {
[16:12:28.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.751]                 open = "w")
[16:12:28.751]         }
[16:12:28.751]         else {
[16:12:28.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.751]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.751]         }
[16:12:28.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.751]             base::sink(type = "output", split = FALSE)
[16:12:28.751]             base::close(...future.stdout)
[16:12:28.751]         }, add = TRUE)
[16:12:28.751]     }
[16:12:28.751]     ...future.frame <- base::sys.nframe()
[16:12:28.751]     ...future.conditions <- base::list()
[16:12:28.751]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.751]     if (FALSE) {
[16:12:28.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.751]     }
[16:12:28.751]     ...future.result <- base::tryCatch({
[16:12:28.751]         base::withCallingHandlers({
[16:12:28.751]             ...future.value <- base::withVisible(base::local({
[16:12:28.751]                 withCallingHandlers({
[16:12:28.751]                   {
[16:12:28.751]                     4
[16:12:28.751]                   }
[16:12:28.751]                 }, immediateCondition = function(cond) {
[16:12:28.751]                   save_rds <- function (object, pathname, ...) 
[16:12:28.751]                   {
[16:12:28.751]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.751]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.751]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.751]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.751]                         fi_tmp[["mtime"]])
[16:12:28.751]                     }
[16:12:28.751]                     tryCatch({
[16:12:28.751]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.751]                     }, error = function(ex) {
[16:12:28.751]                       msg <- conditionMessage(ex)
[16:12:28.751]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.751]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.751]                         fi_tmp[["mtime"]], msg)
[16:12:28.751]                       ex$message <- msg
[16:12:28.751]                       stop(ex)
[16:12:28.751]                     })
[16:12:28.751]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.751]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.751]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.751]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.751]                       fi <- file.info(pathname)
[16:12:28.751]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.751]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.751]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.751]                         fi[["size"]], fi[["mtime"]])
[16:12:28.751]                       stop(msg)
[16:12:28.751]                     }
[16:12:28.751]                     invisible(pathname)
[16:12:28.751]                   }
[16:12:28.751]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.751]                     rootPath = tempdir()) 
[16:12:28.751]                   {
[16:12:28.751]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.751]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.751]                       tmpdir = path, fileext = ".rds")
[16:12:28.751]                     save_rds(obj, file)
[16:12:28.751]                   }
[16:12:28.751]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.751]                   {
[16:12:28.751]                     inherits <- base::inherits
[16:12:28.751]                     invokeRestart <- base::invokeRestart
[16:12:28.751]                     is.null <- base::is.null
[16:12:28.751]                     muffled <- FALSE
[16:12:28.751]                     if (inherits(cond, "message")) {
[16:12:28.751]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.751]                       if (muffled) 
[16:12:28.751]                         invokeRestart("muffleMessage")
[16:12:28.751]                     }
[16:12:28.751]                     else if (inherits(cond, "warning")) {
[16:12:28.751]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.751]                       if (muffled) 
[16:12:28.751]                         invokeRestart("muffleWarning")
[16:12:28.751]                     }
[16:12:28.751]                     else if (inherits(cond, "condition")) {
[16:12:28.751]                       if (!is.null(pattern)) {
[16:12:28.751]                         computeRestarts <- base::computeRestarts
[16:12:28.751]                         grepl <- base::grepl
[16:12:28.751]                         restarts <- computeRestarts(cond)
[16:12:28.751]                         for (restart in restarts) {
[16:12:28.751]                           name <- restart$name
[16:12:28.751]                           if (is.null(name)) 
[16:12:28.751]                             next
[16:12:28.751]                           if (!grepl(pattern, name)) 
[16:12:28.751]                             next
[16:12:28.751]                           invokeRestart(restart)
[16:12:28.751]                           muffled <- TRUE
[16:12:28.751]                           break
[16:12:28.751]                         }
[16:12:28.751]                       }
[16:12:28.751]                     }
[16:12:28.751]                     invisible(muffled)
[16:12:28.751]                   }
[16:12:28.751]                   muffleCondition(cond)
[16:12:28.751]                 })
[16:12:28.751]             }))
[16:12:28.751]             future::FutureResult(value = ...future.value$value, 
[16:12:28.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.751]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.751]                     ...future.globalenv.names))
[16:12:28.751]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.751]         }, condition = base::local({
[16:12:28.751]             c <- base::c
[16:12:28.751]             inherits <- base::inherits
[16:12:28.751]             invokeRestart <- base::invokeRestart
[16:12:28.751]             length <- base::length
[16:12:28.751]             list <- base::list
[16:12:28.751]             seq.int <- base::seq.int
[16:12:28.751]             signalCondition <- base::signalCondition
[16:12:28.751]             sys.calls <- base::sys.calls
[16:12:28.751]             `[[` <- base::`[[`
[16:12:28.751]             `+` <- base::`+`
[16:12:28.751]             `<<-` <- base::`<<-`
[16:12:28.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.751]                   3L)]
[16:12:28.751]             }
[16:12:28.751]             function(cond) {
[16:12:28.751]                 is_error <- inherits(cond, "error")
[16:12:28.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.751]                   NULL)
[16:12:28.751]                 if (is_error) {
[16:12:28.751]                   sessionInformation <- function() {
[16:12:28.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.751]                       search = base::search(), system = base::Sys.info())
[16:12:28.751]                   }
[16:12:28.751]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.751]                     cond$call), session = sessionInformation(), 
[16:12:28.751]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.751]                   signalCondition(cond)
[16:12:28.751]                 }
[16:12:28.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.751]                 "immediateCondition"))) {
[16:12:28.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.751]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.751]                   if (TRUE && !signal) {
[16:12:28.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.751]                     {
[16:12:28.751]                       inherits <- base::inherits
[16:12:28.751]                       invokeRestart <- base::invokeRestart
[16:12:28.751]                       is.null <- base::is.null
[16:12:28.751]                       muffled <- FALSE
[16:12:28.751]                       if (inherits(cond, "message")) {
[16:12:28.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.751]                         if (muffled) 
[16:12:28.751]                           invokeRestart("muffleMessage")
[16:12:28.751]                       }
[16:12:28.751]                       else if (inherits(cond, "warning")) {
[16:12:28.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.751]                         if (muffled) 
[16:12:28.751]                           invokeRestart("muffleWarning")
[16:12:28.751]                       }
[16:12:28.751]                       else if (inherits(cond, "condition")) {
[16:12:28.751]                         if (!is.null(pattern)) {
[16:12:28.751]                           computeRestarts <- base::computeRestarts
[16:12:28.751]                           grepl <- base::grepl
[16:12:28.751]                           restarts <- computeRestarts(cond)
[16:12:28.751]                           for (restart in restarts) {
[16:12:28.751]                             name <- restart$name
[16:12:28.751]                             if (is.null(name)) 
[16:12:28.751]                               next
[16:12:28.751]                             if (!grepl(pattern, name)) 
[16:12:28.751]                               next
[16:12:28.751]                             invokeRestart(restart)
[16:12:28.751]                             muffled <- TRUE
[16:12:28.751]                             break
[16:12:28.751]                           }
[16:12:28.751]                         }
[16:12:28.751]                       }
[16:12:28.751]                       invisible(muffled)
[16:12:28.751]                     }
[16:12:28.751]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.751]                   }
[16:12:28.751]                 }
[16:12:28.751]                 else {
[16:12:28.751]                   if (TRUE) {
[16:12:28.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.751]                     {
[16:12:28.751]                       inherits <- base::inherits
[16:12:28.751]                       invokeRestart <- base::invokeRestart
[16:12:28.751]                       is.null <- base::is.null
[16:12:28.751]                       muffled <- FALSE
[16:12:28.751]                       if (inherits(cond, "message")) {
[16:12:28.751]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.751]                         if (muffled) 
[16:12:28.751]                           invokeRestart("muffleMessage")
[16:12:28.751]                       }
[16:12:28.751]                       else if (inherits(cond, "warning")) {
[16:12:28.751]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.751]                         if (muffled) 
[16:12:28.751]                           invokeRestart("muffleWarning")
[16:12:28.751]                       }
[16:12:28.751]                       else if (inherits(cond, "condition")) {
[16:12:28.751]                         if (!is.null(pattern)) {
[16:12:28.751]                           computeRestarts <- base::computeRestarts
[16:12:28.751]                           grepl <- base::grepl
[16:12:28.751]                           restarts <- computeRestarts(cond)
[16:12:28.751]                           for (restart in restarts) {
[16:12:28.751]                             name <- restart$name
[16:12:28.751]                             if (is.null(name)) 
[16:12:28.751]                               next
[16:12:28.751]                             if (!grepl(pattern, name)) 
[16:12:28.751]                               next
[16:12:28.751]                             invokeRestart(restart)
[16:12:28.751]                             muffled <- TRUE
[16:12:28.751]                             break
[16:12:28.751]                           }
[16:12:28.751]                         }
[16:12:28.751]                       }
[16:12:28.751]                       invisible(muffled)
[16:12:28.751]                     }
[16:12:28.751]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.751]                   }
[16:12:28.751]                 }
[16:12:28.751]             }
[16:12:28.751]         }))
[16:12:28.751]     }, error = function(ex) {
[16:12:28.751]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.751]                 ...future.rng), started = ...future.startTime, 
[16:12:28.751]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.751]             version = "1.8"), class = "FutureResult")
[16:12:28.751]     }, finally = {
[16:12:28.751]         if (!identical(...future.workdir, getwd())) 
[16:12:28.751]             setwd(...future.workdir)
[16:12:28.751]         {
[16:12:28.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.751]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.751]             }
[16:12:28.751]             base::options(...future.oldOptions)
[16:12:28.751]             if (.Platform$OS.type == "windows") {
[16:12:28.751]                 old_names <- names(...future.oldEnvVars)
[16:12:28.751]                 envs <- base::Sys.getenv()
[16:12:28.751]                 names <- names(envs)
[16:12:28.751]                 common <- intersect(names, old_names)
[16:12:28.751]                 added <- setdiff(names, old_names)
[16:12:28.751]                 removed <- setdiff(old_names, names)
[16:12:28.751]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.751]                   envs[common]]
[16:12:28.751]                 NAMES <- toupper(changed)
[16:12:28.751]                 args <- list()
[16:12:28.751]                 for (kk in seq_along(NAMES)) {
[16:12:28.751]                   name <- changed[[kk]]
[16:12:28.751]                   NAME <- NAMES[[kk]]
[16:12:28.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.751]                     next
[16:12:28.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.751]                 }
[16:12:28.751]                 NAMES <- toupper(added)
[16:12:28.751]                 for (kk in seq_along(NAMES)) {
[16:12:28.751]                   name <- added[[kk]]
[16:12:28.751]                   NAME <- NAMES[[kk]]
[16:12:28.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.751]                     next
[16:12:28.751]                   args[[name]] <- ""
[16:12:28.751]                 }
[16:12:28.751]                 NAMES <- toupper(removed)
[16:12:28.751]                 for (kk in seq_along(NAMES)) {
[16:12:28.751]                   name <- removed[[kk]]
[16:12:28.751]                   NAME <- NAMES[[kk]]
[16:12:28.751]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.751]                     next
[16:12:28.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.751]                 }
[16:12:28.751]                 if (length(args) > 0) 
[16:12:28.751]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.751]             }
[16:12:28.751]             else {
[16:12:28.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.751]             }
[16:12:28.751]             {
[16:12:28.751]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.751]                   0L) {
[16:12:28.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.751]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.751]                   base::options(opts)
[16:12:28.751]                 }
[16:12:28.751]                 {
[16:12:28.751]                   {
[16:12:28.751]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.751]                     NULL
[16:12:28.751]                   }
[16:12:28.751]                   options(future.plan = NULL)
[16:12:28.751]                   if (is.na(NA_character_)) 
[16:12:28.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.751]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.751]                     envir = parent.frame()) 
[16:12:28.751]                   {
[16:12:28.751]                     default_workers <- missing(workers)
[16:12:28.751]                     if (is.function(workers)) 
[16:12:28.751]                       workers <- workers()
[16:12:28.751]                     workers <- structure(as.integer(workers), 
[16:12:28.751]                       class = class(workers))
[16:12:28.751]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.751]                       1L)
[16:12:28.751]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.751]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.751]                       if (default_workers) 
[16:12:28.751]                         supportsMulticore(warn = TRUE)
[16:12:28.751]                       return(sequential(..., envir = envir))
[16:12:28.751]                     }
[16:12:28.751]                     oopts <- options(mc.cores = workers)
[16:12:28.751]                     on.exit(options(oopts))
[16:12:28.751]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.751]                       envir = envir)
[16:12:28.751]                     if (!future$lazy) 
[16:12:28.751]                       future <- run(future)
[16:12:28.751]                     invisible(future)
[16:12:28.751]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.751]                 }
[16:12:28.751]             }
[16:12:28.751]         }
[16:12:28.751]     })
[16:12:28.751]     if (TRUE) {
[16:12:28.751]         base::sink(type = "output", split = FALSE)
[16:12:28.751]         if (TRUE) {
[16:12:28.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.751]         }
[16:12:28.751]         else {
[16:12:28.751]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.751]         }
[16:12:28.751]         base::close(...future.stdout)
[16:12:28.751]         ...future.stdout <- NULL
[16:12:28.751]     }
[16:12:28.751]     ...future.result$conditions <- ...future.conditions
[16:12:28.751]     ...future.result$finished <- base::Sys.time()
[16:12:28.751]     ...future.result
[16:12:28.751] }
[16:12:28.755] requestCore(): workers = 2
[16:12:28.755] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:28.781] MulticoreFuture started
[16:12:28.782] - Launch lazy future ... done
[16:12:28.782] run() for ‘MulticoreFuture’ ... done
[16:12:28.783] plan(): Setting new future strategy stack:
<environment: 0x560bae9bebe0> 
[16:12:28.783] List of future strategies:
[16:12:28.783] 1. sequential:
[16:12:28.783]    - args: function (..., envir = parent.frame())
[16:12:28.783]    - tweaked: FALSE
[16:12:28.783]    - call: NULL
[16:12:28.784] plan(): nbrOfWorkers() = 1
<environment: 0x560bb01dfd48> 
[16:12:28.786] plan(): Setting new future strategy stack:
[16:12:28.787] List of future strategies:
[16:12:28.787] 1. multicore:
[16:12:28.787]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.787]    - tweaked: FALSE
[16:12:28.787]    - call: plan(strategy)
[16:12:28.792] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:28.794] resolve() on environment ...
[16:12:28.794]  recursive: 0
[16:12:28.795]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:28.795] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.795] - nx: 4
[16:12:28.795] - relay: TRUE
[16:12:28.795] - stdout: TRUE
[16:12:28.796] - signal: TRUE
[16:12:28.796] - resignal: FALSE
[16:12:28.796] - force: TRUE
[16:12:28.796] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.796] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.796]  - until=2
[16:12:28.796]  - relaying element #2
[16:12:28.796] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.797] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.797] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.797]  length: 3 (resolved future 1)
[16:12:28.797] Future #2
[16:12:28.797] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:28.797] - nx: 4
[16:12:28.798] - relay: TRUE
[16:12:28.798] - stdout: TRUE
[16:12:28.798] - signal: TRUE
[16:12:28.798] - resignal: FALSE
[16:12:28.798] - force: TRUE
[16:12:28.798] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.798] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.798]  - until=2
[16:12:28.799]  - relaying element #2
[16:12:28.799] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.799] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.799] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:28.799]  length: 2 (resolved future 2)
[16:12:28.800] Future #3
[16:12:28.801] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:28.801] - nx: 4
[16:12:28.801] - relay: TRUE
[16:12:28.801] - stdout: TRUE
[16:12:28.801] - signal: TRUE
[16:12:28.801] - resignal: FALSE
[16:12:28.801] - force: TRUE
[16:12:28.801] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.802] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.802]  - until=3
[16:12:28.802]  - relaying element #3
[16:12:28.802] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.802] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.802] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:28.803]  length: 1 (resolved future 3)
[16:12:28.803] Future #4
[16:12:28.804] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:28.804] - nx: 4
[16:12:28.804] - relay: TRUE
[16:12:28.804] - stdout: TRUE
[16:12:28.804] - signal: TRUE
[16:12:28.805] - resignal: FALSE
[16:12:28.805] - force: TRUE
[16:12:28.805] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.805] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.805]  - until=4
[16:12:28.805]  - relaying element #4
[16:12:28.806] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.806] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:28.806] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:28.806]  length: 0 (resolved future 4)
[16:12:28.806] Relaying remaining futures
[16:12:28.806] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.807] - nx: 4
[16:12:28.807] - relay: TRUE
[16:12:28.807] - stdout: TRUE
[16:12:28.807] - signal: TRUE
[16:12:28.807] - resignal: FALSE
[16:12:28.807] - force: TRUE
[16:12:28.807] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.807] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:28.808] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.808] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:28.808] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.808] resolve() on environment ... DONE
<environment: 0x560bb02b3f48> 
Dimensions: c(2, 3)
[16:12:28.809] getGlobalsAndPackages() ...
[16:12:28.809] Searching for globals...
[16:12:28.809] 
[16:12:28.809] Searching for globals ... DONE
[16:12:28.809] - globals: [0] <none>
[16:12:28.809] getGlobalsAndPackages() ... DONE
[16:12:28.810] run() for ‘Future’ ...
[16:12:28.810] - state: ‘created’
[16:12:28.810] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.814] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.814]   - Field: ‘label’
[16:12:28.814]   - Field: ‘local’
[16:12:28.814]   - Field: ‘owner’
[16:12:28.815]   - Field: ‘envir’
[16:12:28.815]   - Field: ‘workers’
[16:12:28.815]   - Field: ‘packages’
[16:12:28.815]   - Field: ‘gc’
[16:12:28.815]   - Field: ‘job’
[16:12:28.815]   - Field: ‘conditions’
[16:12:28.815]   - Field: ‘expr’
[16:12:28.815]   - Field: ‘uuid’
[16:12:28.815]   - Field: ‘seed’
[16:12:28.816]   - Field: ‘version’
[16:12:28.816]   - Field: ‘result’
[16:12:28.816]   - Field: ‘asynchronous’
[16:12:28.816]   - Field: ‘calls’
[16:12:28.816]   - Field: ‘globals’
[16:12:28.816]   - Field: ‘stdout’
[16:12:28.816]   - Field: ‘earlySignal’
[16:12:28.816]   - Field: ‘lazy’
[16:12:28.816]   - Field: ‘state’
[16:12:28.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.817] - Launch lazy future ...
[16:12:28.817] Packages needed by the future expression (n = 0): <none>
[16:12:28.817] Packages needed by future strategies (n = 0): <none>
[16:12:28.818] {
[16:12:28.818]     {
[16:12:28.818]         {
[16:12:28.818]             ...future.startTime <- base::Sys.time()
[16:12:28.818]             {
[16:12:28.818]                 {
[16:12:28.818]                   {
[16:12:28.818]                     {
[16:12:28.818]                       base::local({
[16:12:28.818]                         has_future <- base::requireNamespace("future", 
[16:12:28.818]                           quietly = TRUE)
[16:12:28.818]                         if (has_future) {
[16:12:28.818]                           ns <- base::getNamespace("future")
[16:12:28.818]                           version <- ns[[".package"]][["version"]]
[16:12:28.818]                           if (is.null(version)) 
[16:12:28.818]                             version <- utils::packageVersion("future")
[16:12:28.818]                         }
[16:12:28.818]                         else {
[16:12:28.818]                           version <- NULL
[16:12:28.818]                         }
[16:12:28.818]                         if (!has_future || version < "1.8.0") {
[16:12:28.818]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.818]                             "", base::R.version$version.string), 
[16:12:28.818]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.818]                               "release", "version")], collapse = " "), 
[16:12:28.818]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.818]                             info)
[16:12:28.818]                           info <- base::paste(info, collapse = "; ")
[16:12:28.818]                           if (!has_future) {
[16:12:28.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.818]                               info)
[16:12:28.818]                           }
[16:12:28.818]                           else {
[16:12:28.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.818]                               info, version)
[16:12:28.818]                           }
[16:12:28.818]                           base::stop(msg)
[16:12:28.818]                         }
[16:12:28.818]                       })
[16:12:28.818]                     }
[16:12:28.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.818]                     base::options(mc.cores = 1L)
[16:12:28.818]                   }
[16:12:28.818]                   options(future.plan = NULL)
[16:12:28.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.818]                 }
[16:12:28.818]                 ...future.workdir <- getwd()
[16:12:28.818]             }
[16:12:28.818]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.818]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.818]         }
[16:12:28.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.818]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.818]             base::names(...future.oldOptions))
[16:12:28.818]     }
[16:12:28.818]     if (FALSE) {
[16:12:28.818]     }
[16:12:28.818]     else {
[16:12:28.818]         if (TRUE) {
[16:12:28.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.818]                 open = "w")
[16:12:28.818]         }
[16:12:28.818]         else {
[16:12:28.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.818]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.818]         }
[16:12:28.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.818]             base::sink(type = "output", split = FALSE)
[16:12:28.818]             base::close(...future.stdout)
[16:12:28.818]         }, add = TRUE)
[16:12:28.818]     }
[16:12:28.818]     ...future.frame <- base::sys.nframe()
[16:12:28.818]     ...future.conditions <- base::list()
[16:12:28.818]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.818]     if (FALSE) {
[16:12:28.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.818]     }
[16:12:28.818]     ...future.result <- base::tryCatch({
[16:12:28.818]         base::withCallingHandlers({
[16:12:28.818]             ...future.value <- base::withVisible(base::local({
[16:12:28.818]                 withCallingHandlers({
[16:12:28.818]                   2
[16:12:28.818]                 }, immediateCondition = function(cond) {
[16:12:28.818]                   save_rds <- function (object, pathname, ...) 
[16:12:28.818]                   {
[16:12:28.818]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.818]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.818]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.818]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.818]                         fi_tmp[["mtime"]])
[16:12:28.818]                     }
[16:12:28.818]                     tryCatch({
[16:12:28.818]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.818]                     }, error = function(ex) {
[16:12:28.818]                       msg <- conditionMessage(ex)
[16:12:28.818]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.818]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.818]                         fi_tmp[["mtime"]], msg)
[16:12:28.818]                       ex$message <- msg
[16:12:28.818]                       stop(ex)
[16:12:28.818]                     })
[16:12:28.818]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.818]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.818]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.818]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.818]                       fi <- file.info(pathname)
[16:12:28.818]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.818]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.818]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.818]                         fi[["size"]], fi[["mtime"]])
[16:12:28.818]                       stop(msg)
[16:12:28.818]                     }
[16:12:28.818]                     invisible(pathname)
[16:12:28.818]                   }
[16:12:28.818]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.818]                     rootPath = tempdir()) 
[16:12:28.818]                   {
[16:12:28.818]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.818]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.818]                       tmpdir = path, fileext = ".rds")
[16:12:28.818]                     save_rds(obj, file)
[16:12:28.818]                   }
[16:12:28.818]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.818]                   {
[16:12:28.818]                     inherits <- base::inherits
[16:12:28.818]                     invokeRestart <- base::invokeRestart
[16:12:28.818]                     is.null <- base::is.null
[16:12:28.818]                     muffled <- FALSE
[16:12:28.818]                     if (inherits(cond, "message")) {
[16:12:28.818]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.818]                       if (muffled) 
[16:12:28.818]                         invokeRestart("muffleMessage")
[16:12:28.818]                     }
[16:12:28.818]                     else if (inherits(cond, "warning")) {
[16:12:28.818]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.818]                       if (muffled) 
[16:12:28.818]                         invokeRestart("muffleWarning")
[16:12:28.818]                     }
[16:12:28.818]                     else if (inherits(cond, "condition")) {
[16:12:28.818]                       if (!is.null(pattern)) {
[16:12:28.818]                         computeRestarts <- base::computeRestarts
[16:12:28.818]                         grepl <- base::grepl
[16:12:28.818]                         restarts <- computeRestarts(cond)
[16:12:28.818]                         for (restart in restarts) {
[16:12:28.818]                           name <- restart$name
[16:12:28.818]                           if (is.null(name)) 
[16:12:28.818]                             next
[16:12:28.818]                           if (!grepl(pattern, name)) 
[16:12:28.818]                             next
[16:12:28.818]                           invokeRestart(restart)
[16:12:28.818]                           muffled <- TRUE
[16:12:28.818]                           break
[16:12:28.818]                         }
[16:12:28.818]                       }
[16:12:28.818]                     }
[16:12:28.818]                     invisible(muffled)
[16:12:28.818]                   }
[16:12:28.818]                   muffleCondition(cond)
[16:12:28.818]                 })
[16:12:28.818]             }))
[16:12:28.818]             future::FutureResult(value = ...future.value$value, 
[16:12:28.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.818]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.818]                     ...future.globalenv.names))
[16:12:28.818]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.818]         }, condition = base::local({
[16:12:28.818]             c <- base::c
[16:12:28.818]             inherits <- base::inherits
[16:12:28.818]             invokeRestart <- base::invokeRestart
[16:12:28.818]             length <- base::length
[16:12:28.818]             list <- base::list
[16:12:28.818]             seq.int <- base::seq.int
[16:12:28.818]             signalCondition <- base::signalCondition
[16:12:28.818]             sys.calls <- base::sys.calls
[16:12:28.818]             `[[` <- base::`[[`
[16:12:28.818]             `+` <- base::`+`
[16:12:28.818]             `<<-` <- base::`<<-`
[16:12:28.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.818]                   3L)]
[16:12:28.818]             }
[16:12:28.818]             function(cond) {
[16:12:28.818]                 is_error <- inherits(cond, "error")
[16:12:28.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.818]                   NULL)
[16:12:28.818]                 if (is_error) {
[16:12:28.818]                   sessionInformation <- function() {
[16:12:28.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.818]                       search = base::search(), system = base::Sys.info())
[16:12:28.818]                   }
[16:12:28.818]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.818]                     cond$call), session = sessionInformation(), 
[16:12:28.818]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.818]                   signalCondition(cond)
[16:12:28.818]                 }
[16:12:28.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.818]                 "immediateCondition"))) {
[16:12:28.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.818]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.818]                   if (TRUE && !signal) {
[16:12:28.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.818]                     {
[16:12:28.818]                       inherits <- base::inherits
[16:12:28.818]                       invokeRestart <- base::invokeRestart
[16:12:28.818]                       is.null <- base::is.null
[16:12:28.818]                       muffled <- FALSE
[16:12:28.818]                       if (inherits(cond, "message")) {
[16:12:28.818]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.818]                         if (muffled) 
[16:12:28.818]                           invokeRestart("muffleMessage")
[16:12:28.818]                       }
[16:12:28.818]                       else if (inherits(cond, "warning")) {
[16:12:28.818]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.818]                         if (muffled) 
[16:12:28.818]                           invokeRestart("muffleWarning")
[16:12:28.818]                       }
[16:12:28.818]                       else if (inherits(cond, "condition")) {
[16:12:28.818]                         if (!is.null(pattern)) {
[16:12:28.818]                           computeRestarts <- base::computeRestarts
[16:12:28.818]                           grepl <- base::grepl
[16:12:28.818]                           restarts <- computeRestarts(cond)
[16:12:28.818]                           for (restart in restarts) {
[16:12:28.818]                             name <- restart$name
[16:12:28.818]                             if (is.null(name)) 
[16:12:28.818]                               next
[16:12:28.818]                             if (!grepl(pattern, name)) 
[16:12:28.818]                               next
[16:12:28.818]                             invokeRestart(restart)
[16:12:28.818]                             muffled <- TRUE
[16:12:28.818]                             break
[16:12:28.818]                           }
[16:12:28.818]                         }
[16:12:28.818]                       }
[16:12:28.818]                       invisible(muffled)
[16:12:28.818]                     }
[16:12:28.818]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.818]                   }
[16:12:28.818]                 }
[16:12:28.818]                 else {
[16:12:28.818]                   if (TRUE) {
[16:12:28.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.818]                     {
[16:12:28.818]                       inherits <- base::inherits
[16:12:28.818]                       invokeRestart <- base::invokeRestart
[16:12:28.818]                       is.null <- base::is.null
[16:12:28.818]                       muffled <- FALSE
[16:12:28.818]                       if (inherits(cond, "message")) {
[16:12:28.818]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.818]                         if (muffled) 
[16:12:28.818]                           invokeRestart("muffleMessage")
[16:12:28.818]                       }
[16:12:28.818]                       else if (inherits(cond, "warning")) {
[16:12:28.818]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.818]                         if (muffled) 
[16:12:28.818]                           invokeRestart("muffleWarning")
[16:12:28.818]                       }
[16:12:28.818]                       else if (inherits(cond, "condition")) {
[16:12:28.818]                         if (!is.null(pattern)) {
[16:12:28.818]                           computeRestarts <- base::computeRestarts
[16:12:28.818]                           grepl <- base::grepl
[16:12:28.818]                           restarts <- computeRestarts(cond)
[16:12:28.818]                           for (restart in restarts) {
[16:12:28.818]                             name <- restart$name
[16:12:28.818]                             if (is.null(name)) 
[16:12:28.818]                               next
[16:12:28.818]                             if (!grepl(pattern, name)) 
[16:12:28.818]                               next
[16:12:28.818]                             invokeRestart(restart)
[16:12:28.818]                             muffled <- TRUE
[16:12:28.818]                             break
[16:12:28.818]                           }
[16:12:28.818]                         }
[16:12:28.818]                       }
[16:12:28.818]                       invisible(muffled)
[16:12:28.818]                     }
[16:12:28.818]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.818]                   }
[16:12:28.818]                 }
[16:12:28.818]             }
[16:12:28.818]         }))
[16:12:28.818]     }, error = function(ex) {
[16:12:28.818]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.818]                 ...future.rng), started = ...future.startTime, 
[16:12:28.818]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.818]             version = "1.8"), class = "FutureResult")
[16:12:28.818]     }, finally = {
[16:12:28.818]         if (!identical(...future.workdir, getwd())) 
[16:12:28.818]             setwd(...future.workdir)
[16:12:28.818]         {
[16:12:28.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.818]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.818]             }
[16:12:28.818]             base::options(...future.oldOptions)
[16:12:28.818]             if (.Platform$OS.type == "windows") {
[16:12:28.818]                 old_names <- names(...future.oldEnvVars)
[16:12:28.818]                 envs <- base::Sys.getenv()
[16:12:28.818]                 names <- names(envs)
[16:12:28.818]                 common <- intersect(names, old_names)
[16:12:28.818]                 added <- setdiff(names, old_names)
[16:12:28.818]                 removed <- setdiff(old_names, names)
[16:12:28.818]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.818]                   envs[common]]
[16:12:28.818]                 NAMES <- toupper(changed)
[16:12:28.818]                 args <- list()
[16:12:28.818]                 for (kk in seq_along(NAMES)) {
[16:12:28.818]                   name <- changed[[kk]]
[16:12:28.818]                   NAME <- NAMES[[kk]]
[16:12:28.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.818]                     next
[16:12:28.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.818]                 }
[16:12:28.818]                 NAMES <- toupper(added)
[16:12:28.818]                 for (kk in seq_along(NAMES)) {
[16:12:28.818]                   name <- added[[kk]]
[16:12:28.818]                   NAME <- NAMES[[kk]]
[16:12:28.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.818]                     next
[16:12:28.818]                   args[[name]] <- ""
[16:12:28.818]                 }
[16:12:28.818]                 NAMES <- toupper(removed)
[16:12:28.818]                 for (kk in seq_along(NAMES)) {
[16:12:28.818]                   name <- removed[[kk]]
[16:12:28.818]                   NAME <- NAMES[[kk]]
[16:12:28.818]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.818]                     next
[16:12:28.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.818]                 }
[16:12:28.818]                 if (length(args) > 0) 
[16:12:28.818]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.818]             }
[16:12:28.818]             else {
[16:12:28.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.818]             }
[16:12:28.818]             {
[16:12:28.818]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.818]                   0L) {
[16:12:28.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.818]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.818]                   base::options(opts)
[16:12:28.818]                 }
[16:12:28.818]                 {
[16:12:28.818]                   {
[16:12:28.818]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.818]                     NULL
[16:12:28.818]                   }
[16:12:28.818]                   options(future.plan = NULL)
[16:12:28.818]                   if (is.na(NA_character_)) 
[16:12:28.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.818]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.818]                     envir = parent.frame()) 
[16:12:28.818]                   {
[16:12:28.818]                     default_workers <- missing(workers)
[16:12:28.818]                     if (is.function(workers)) 
[16:12:28.818]                       workers <- workers()
[16:12:28.818]                     workers <- structure(as.integer(workers), 
[16:12:28.818]                       class = class(workers))
[16:12:28.818]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.818]                       1L)
[16:12:28.818]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.818]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.818]                       if (default_workers) 
[16:12:28.818]                         supportsMulticore(warn = TRUE)
[16:12:28.818]                       return(sequential(..., envir = envir))
[16:12:28.818]                     }
[16:12:28.818]                     oopts <- options(mc.cores = workers)
[16:12:28.818]                     on.exit(options(oopts))
[16:12:28.818]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.818]                       envir = envir)
[16:12:28.818]                     if (!future$lazy) 
[16:12:28.818]                       future <- run(future)
[16:12:28.818]                     invisible(future)
[16:12:28.818]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.818]                 }
[16:12:28.818]             }
[16:12:28.818]         }
[16:12:28.818]     })
[16:12:28.818]     if (TRUE) {
[16:12:28.818]         base::sink(type = "output", split = FALSE)
[16:12:28.818]         if (TRUE) {
[16:12:28.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.818]         }
[16:12:28.818]         else {
[16:12:28.818]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.818]         }
[16:12:28.818]         base::close(...future.stdout)
[16:12:28.818]         ...future.stdout <- NULL
[16:12:28.818]     }
[16:12:28.818]     ...future.result$conditions <- ...future.conditions
[16:12:28.818]     ...future.result$finished <- base::Sys.time()
[16:12:28.818]     ...future.result
[16:12:28.818] }
[16:12:28.820] requestCore(): workers = 2
[16:12:28.822] MulticoreFuture started
[16:12:28.823] - Launch lazy future ... done
[16:12:28.823] run() for ‘MulticoreFuture’ ... done
[16:12:28.823] getGlobalsAndPackages() ...
[16:12:28.823] Searching for globals...
[16:12:28.823] plan(): Setting new future strategy stack:
[16:12:28.824] 
[16:12:28.824] Searching for globals ... DONE
[16:12:28.824] List of future strategies:
[16:12:28.824] 1. sequential:
[16:12:28.824]    - args: function (..., envir = parent.frame())
[16:12:28.824]    - tweaked: FALSE
[16:12:28.824]    - call: NULL
[16:12:28.824] - globals: [0] <none>
[16:12:28.824] getGlobalsAndPackages() ... DONE
[16:12:28.824] plan(): nbrOfWorkers() = 1
[16:12:28.825] run() for ‘Future’ ...
[16:12:28.825] - state: ‘created’
[16:12:28.825] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.826] plan(): Setting new future strategy stack:
[16:12:28.826] List of future strategies:
[16:12:28.826] 1. multicore:
[16:12:28.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.826]    - tweaked: FALSE
[16:12:28.826]    - call: plan(strategy)
[16:12:28.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.830] plan(): nbrOfWorkers() = 2
[16:12:28.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.831]   - Field: ‘label’
[16:12:28.831]   - Field: ‘local’
[16:12:28.831]   - Field: ‘owner’
[16:12:28.831]   - Field: ‘envir’
[16:12:28.831]   - Field: ‘workers’
[16:12:28.831]   - Field: ‘packages’
[16:12:28.832]   - Field: ‘gc’
[16:12:28.832]   - Field: ‘job’
[16:12:28.832]   - Field: ‘conditions’
[16:12:28.832]   - Field: ‘expr’
[16:12:28.832]   - Field: ‘uuid’
[16:12:28.832]   - Field: ‘seed’
[16:12:28.832]   - Field: ‘version’
[16:12:28.833]   - Field: ‘result’
[16:12:28.833]   - Field: ‘asynchronous’
[16:12:28.833]   - Field: ‘calls’
[16:12:28.833]   - Field: ‘globals’
[16:12:28.833]   - Field: ‘stdout’
[16:12:28.833]   - Field: ‘earlySignal’
[16:12:28.833]   - Field: ‘lazy’
[16:12:28.833]   - Field: ‘state’
[16:12:28.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.834] - Launch lazy future ...
[16:12:28.834] Packages needed by the future expression (n = 0): <none>
[16:12:28.834] Packages needed by future strategies (n = 0): <none>
[16:12:28.841] {
[16:12:28.841]     {
[16:12:28.841]         {
[16:12:28.841]             ...future.startTime <- base::Sys.time()
[16:12:28.841]             {
[16:12:28.841]                 {
[16:12:28.841]                   {
[16:12:28.841]                     {
[16:12:28.841]                       base::local({
[16:12:28.841]                         has_future <- base::requireNamespace("future", 
[16:12:28.841]                           quietly = TRUE)
[16:12:28.841]                         if (has_future) {
[16:12:28.841]                           ns <- base::getNamespace("future")
[16:12:28.841]                           version <- ns[[".package"]][["version"]]
[16:12:28.841]                           if (is.null(version)) 
[16:12:28.841]                             version <- utils::packageVersion("future")
[16:12:28.841]                         }
[16:12:28.841]                         else {
[16:12:28.841]                           version <- NULL
[16:12:28.841]                         }
[16:12:28.841]                         if (!has_future || version < "1.8.0") {
[16:12:28.841]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.841]                             "", base::R.version$version.string), 
[16:12:28.841]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.841]                               "release", "version")], collapse = " "), 
[16:12:28.841]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.841]                             info)
[16:12:28.841]                           info <- base::paste(info, collapse = "; ")
[16:12:28.841]                           if (!has_future) {
[16:12:28.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.841]                               info)
[16:12:28.841]                           }
[16:12:28.841]                           else {
[16:12:28.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.841]                               info, version)
[16:12:28.841]                           }
[16:12:28.841]                           base::stop(msg)
[16:12:28.841]                         }
[16:12:28.841]                       })
[16:12:28.841]                     }
[16:12:28.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.841]                     base::options(mc.cores = 1L)
[16:12:28.841]                   }
[16:12:28.841]                   options(future.plan = NULL)
[16:12:28.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.841]                 }
[16:12:28.841]                 ...future.workdir <- getwd()
[16:12:28.841]             }
[16:12:28.841]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.841]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.841]         }
[16:12:28.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.841]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.841]             base::names(...future.oldOptions))
[16:12:28.841]     }
[16:12:28.841]     if (FALSE) {
[16:12:28.841]     }
[16:12:28.841]     else {
[16:12:28.841]         if (TRUE) {
[16:12:28.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.841]                 open = "w")
[16:12:28.841]         }
[16:12:28.841]         else {
[16:12:28.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.841]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.841]         }
[16:12:28.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.841]             base::sink(type = "output", split = FALSE)
[16:12:28.841]             base::close(...future.stdout)
[16:12:28.841]         }, add = TRUE)
[16:12:28.841]     }
[16:12:28.841]     ...future.frame <- base::sys.nframe()
[16:12:28.841]     ...future.conditions <- base::list()
[16:12:28.841]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.841]     if (FALSE) {
[16:12:28.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.841]     }
[16:12:28.841]     ...future.result <- base::tryCatch({
[16:12:28.841]         base::withCallingHandlers({
[16:12:28.841]             ...future.value <- base::withVisible(base::local({
[16:12:28.841]                 withCallingHandlers({
[16:12:28.841]                   NULL
[16:12:28.841]                 }, immediateCondition = function(cond) {
[16:12:28.841]                   save_rds <- function (object, pathname, ...) 
[16:12:28.841]                   {
[16:12:28.841]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.841]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.841]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.841]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.841]                         fi_tmp[["mtime"]])
[16:12:28.841]                     }
[16:12:28.841]                     tryCatch({
[16:12:28.841]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.841]                     }, error = function(ex) {
[16:12:28.841]                       msg <- conditionMessage(ex)
[16:12:28.841]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.841]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.841]                         fi_tmp[["mtime"]], msg)
[16:12:28.841]                       ex$message <- msg
[16:12:28.841]                       stop(ex)
[16:12:28.841]                     })
[16:12:28.841]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.841]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.841]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.841]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.841]                       fi <- file.info(pathname)
[16:12:28.841]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.841]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.841]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.841]                         fi[["size"]], fi[["mtime"]])
[16:12:28.841]                       stop(msg)
[16:12:28.841]                     }
[16:12:28.841]                     invisible(pathname)
[16:12:28.841]                   }
[16:12:28.841]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.841]                     rootPath = tempdir()) 
[16:12:28.841]                   {
[16:12:28.841]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.841]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.841]                       tmpdir = path, fileext = ".rds")
[16:12:28.841]                     save_rds(obj, file)
[16:12:28.841]                   }
[16:12:28.841]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.841]                   {
[16:12:28.841]                     inherits <- base::inherits
[16:12:28.841]                     invokeRestart <- base::invokeRestart
[16:12:28.841]                     is.null <- base::is.null
[16:12:28.841]                     muffled <- FALSE
[16:12:28.841]                     if (inherits(cond, "message")) {
[16:12:28.841]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.841]                       if (muffled) 
[16:12:28.841]                         invokeRestart("muffleMessage")
[16:12:28.841]                     }
[16:12:28.841]                     else if (inherits(cond, "warning")) {
[16:12:28.841]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.841]                       if (muffled) 
[16:12:28.841]                         invokeRestart("muffleWarning")
[16:12:28.841]                     }
[16:12:28.841]                     else if (inherits(cond, "condition")) {
[16:12:28.841]                       if (!is.null(pattern)) {
[16:12:28.841]                         computeRestarts <- base::computeRestarts
[16:12:28.841]                         grepl <- base::grepl
[16:12:28.841]                         restarts <- computeRestarts(cond)
[16:12:28.841]                         for (restart in restarts) {
[16:12:28.841]                           name <- restart$name
[16:12:28.841]                           if (is.null(name)) 
[16:12:28.841]                             next
[16:12:28.841]                           if (!grepl(pattern, name)) 
[16:12:28.841]                             next
[16:12:28.841]                           invokeRestart(restart)
[16:12:28.841]                           muffled <- TRUE
[16:12:28.841]                           break
[16:12:28.841]                         }
[16:12:28.841]                       }
[16:12:28.841]                     }
[16:12:28.841]                     invisible(muffled)
[16:12:28.841]                   }
[16:12:28.841]                   muffleCondition(cond)
[16:12:28.841]                 })
[16:12:28.841]             }))
[16:12:28.841]             future::FutureResult(value = ...future.value$value, 
[16:12:28.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.841]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.841]                     ...future.globalenv.names))
[16:12:28.841]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.841]         }, condition = base::local({
[16:12:28.841]             c <- base::c
[16:12:28.841]             inherits <- base::inherits
[16:12:28.841]             invokeRestart <- base::invokeRestart
[16:12:28.841]             length <- base::length
[16:12:28.841]             list <- base::list
[16:12:28.841]             seq.int <- base::seq.int
[16:12:28.841]             signalCondition <- base::signalCondition
[16:12:28.841]             sys.calls <- base::sys.calls
[16:12:28.841]             `[[` <- base::`[[`
[16:12:28.841]             `+` <- base::`+`
[16:12:28.841]             `<<-` <- base::`<<-`
[16:12:28.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.841]                   3L)]
[16:12:28.841]             }
[16:12:28.841]             function(cond) {
[16:12:28.841]                 is_error <- inherits(cond, "error")
[16:12:28.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.841]                   NULL)
[16:12:28.841]                 if (is_error) {
[16:12:28.841]                   sessionInformation <- function() {
[16:12:28.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.841]                       search = base::search(), system = base::Sys.info())
[16:12:28.841]                   }
[16:12:28.841]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.841]                     cond$call), session = sessionInformation(), 
[16:12:28.841]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.841]                   signalCondition(cond)
[16:12:28.841]                 }
[16:12:28.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.841]                 "immediateCondition"))) {
[16:12:28.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.841]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.841]                   if (TRUE && !signal) {
[16:12:28.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.841]                     {
[16:12:28.841]                       inherits <- base::inherits
[16:12:28.841]                       invokeRestart <- base::invokeRestart
[16:12:28.841]                       is.null <- base::is.null
[16:12:28.841]                       muffled <- FALSE
[16:12:28.841]                       if (inherits(cond, "message")) {
[16:12:28.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.841]                         if (muffled) 
[16:12:28.841]                           invokeRestart("muffleMessage")
[16:12:28.841]                       }
[16:12:28.841]                       else if (inherits(cond, "warning")) {
[16:12:28.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.841]                         if (muffled) 
[16:12:28.841]                           invokeRestart("muffleWarning")
[16:12:28.841]                       }
[16:12:28.841]                       else if (inherits(cond, "condition")) {
[16:12:28.841]                         if (!is.null(pattern)) {
[16:12:28.841]                           computeRestarts <- base::computeRestarts
[16:12:28.841]                           grepl <- base::grepl
[16:12:28.841]                           restarts <- computeRestarts(cond)
[16:12:28.841]                           for (restart in restarts) {
[16:12:28.841]                             name <- restart$name
[16:12:28.841]                             if (is.null(name)) 
[16:12:28.841]                               next
[16:12:28.841]                             if (!grepl(pattern, name)) 
[16:12:28.841]                               next
[16:12:28.841]                             invokeRestart(restart)
[16:12:28.841]                             muffled <- TRUE
[16:12:28.841]                             break
[16:12:28.841]                           }
[16:12:28.841]                         }
[16:12:28.841]                       }
[16:12:28.841]                       invisible(muffled)
[16:12:28.841]                     }
[16:12:28.841]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.841]                   }
[16:12:28.841]                 }
[16:12:28.841]                 else {
[16:12:28.841]                   if (TRUE) {
[16:12:28.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.841]                     {
[16:12:28.841]                       inherits <- base::inherits
[16:12:28.841]                       invokeRestart <- base::invokeRestart
[16:12:28.841]                       is.null <- base::is.null
[16:12:28.841]                       muffled <- FALSE
[16:12:28.841]                       if (inherits(cond, "message")) {
[16:12:28.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.841]                         if (muffled) 
[16:12:28.841]                           invokeRestart("muffleMessage")
[16:12:28.841]                       }
[16:12:28.841]                       else if (inherits(cond, "warning")) {
[16:12:28.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.841]                         if (muffled) 
[16:12:28.841]                           invokeRestart("muffleWarning")
[16:12:28.841]                       }
[16:12:28.841]                       else if (inherits(cond, "condition")) {
[16:12:28.841]                         if (!is.null(pattern)) {
[16:12:28.841]                           computeRestarts <- base::computeRestarts
[16:12:28.841]                           grepl <- base::grepl
[16:12:28.841]                           restarts <- computeRestarts(cond)
[16:12:28.841]                           for (restart in restarts) {
[16:12:28.841]                             name <- restart$name
[16:12:28.841]                             if (is.null(name)) 
[16:12:28.841]                               next
[16:12:28.841]                             if (!grepl(pattern, name)) 
[16:12:28.841]                               next
[16:12:28.841]                             invokeRestart(restart)
[16:12:28.841]                             muffled <- TRUE
[16:12:28.841]                             break
[16:12:28.841]                           }
[16:12:28.841]                         }
[16:12:28.841]                       }
[16:12:28.841]                       invisible(muffled)
[16:12:28.841]                     }
[16:12:28.841]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.841]                   }
[16:12:28.841]                 }
[16:12:28.841]             }
[16:12:28.841]         }))
[16:12:28.841]     }, error = function(ex) {
[16:12:28.841]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.841]                 ...future.rng), started = ...future.startTime, 
[16:12:28.841]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.841]             version = "1.8"), class = "FutureResult")
[16:12:28.841]     }, finally = {
[16:12:28.841]         if (!identical(...future.workdir, getwd())) 
[16:12:28.841]             setwd(...future.workdir)
[16:12:28.841]         {
[16:12:28.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.841]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.841]             }
[16:12:28.841]             base::options(...future.oldOptions)
[16:12:28.841]             if (.Platform$OS.type == "windows") {
[16:12:28.841]                 old_names <- names(...future.oldEnvVars)
[16:12:28.841]                 envs <- base::Sys.getenv()
[16:12:28.841]                 names <- names(envs)
[16:12:28.841]                 common <- intersect(names, old_names)
[16:12:28.841]                 added <- setdiff(names, old_names)
[16:12:28.841]                 removed <- setdiff(old_names, names)
[16:12:28.841]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.841]                   envs[common]]
[16:12:28.841]                 NAMES <- toupper(changed)
[16:12:28.841]                 args <- list()
[16:12:28.841]                 for (kk in seq_along(NAMES)) {
[16:12:28.841]                   name <- changed[[kk]]
[16:12:28.841]                   NAME <- NAMES[[kk]]
[16:12:28.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.841]                     next
[16:12:28.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.841]                 }
[16:12:28.841]                 NAMES <- toupper(added)
[16:12:28.841]                 for (kk in seq_along(NAMES)) {
[16:12:28.841]                   name <- added[[kk]]
[16:12:28.841]                   NAME <- NAMES[[kk]]
[16:12:28.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.841]                     next
[16:12:28.841]                   args[[name]] <- ""
[16:12:28.841]                 }
[16:12:28.841]                 NAMES <- toupper(removed)
[16:12:28.841]                 for (kk in seq_along(NAMES)) {
[16:12:28.841]                   name <- removed[[kk]]
[16:12:28.841]                   NAME <- NAMES[[kk]]
[16:12:28.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.841]                     next
[16:12:28.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.841]                 }
[16:12:28.841]                 if (length(args) > 0) 
[16:12:28.841]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.841]             }
[16:12:28.841]             else {
[16:12:28.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.841]             }
[16:12:28.841]             {
[16:12:28.841]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.841]                   0L) {
[16:12:28.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.841]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.841]                   base::options(opts)
[16:12:28.841]                 }
[16:12:28.841]                 {
[16:12:28.841]                   {
[16:12:28.841]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.841]                     NULL
[16:12:28.841]                   }
[16:12:28.841]                   options(future.plan = NULL)
[16:12:28.841]                   if (is.na(NA_character_)) 
[16:12:28.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.841]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.841]                     envir = parent.frame()) 
[16:12:28.841]                   {
[16:12:28.841]                     default_workers <- missing(workers)
[16:12:28.841]                     if (is.function(workers)) 
[16:12:28.841]                       workers <- workers()
[16:12:28.841]                     workers <- structure(as.integer(workers), 
[16:12:28.841]                       class = class(workers))
[16:12:28.841]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.841]                       1L)
[16:12:28.841]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.841]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.841]                       if (default_workers) 
[16:12:28.841]                         supportsMulticore(warn = TRUE)
[16:12:28.841]                       return(sequential(..., envir = envir))
[16:12:28.841]                     }
[16:12:28.841]                     oopts <- options(mc.cores = workers)
[16:12:28.841]                     on.exit(options(oopts))
[16:12:28.841]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.841]                       envir = envir)
[16:12:28.841]                     if (!future$lazy) 
[16:12:28.841]                       future <- run(future)
[16:12:28.841]                     invisible(future)
[16:12:28.841]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.841]                 }
[16:12:28.841]             }
[16:12:28.841]         }
[16:12:28.841]     })
[16:12:28.841]     if (TRUE) {
[16:12:28.841]         base::sink(type = "output", split = FALSE)
[16:12:28.841]         if (TRUE) {
[16:12:28.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.841]         }
[16:12:28.841]         else {
[16:12:28.841]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.841]         }
[16:12:28.841]         base::close(...future.stdout)
[16:12:28.841]         ...future.stdout <- NULL
[16:12:28.841]     }
[16:12:28.841]     ...future.result$conditions <- ...future.conditions
[16:12:28.841]     ...future.result$finished <- base::Sys.time()
[16:12:28.841]     ...future.result
[16:12:28.841] }
[16:12:28.844] requestCore(): workers = 2
[16:12:28.846] MulticoreFuture started
[16:12:28.846] - Launch lazy future ... done
[16:12:28.847] run() for ‘MulticoreFuture’ ... done
[16:12:28.847] plan(): Setting new future strategy stack:
[16:12:28.847] getGlobalsAndPackages() ...
[16:12:28.848] Searching for globals...
[16:12:28.848] List of future strategies:
[16:12:28.848] 1. sequential:
[16:12:28.848]    - args: function (..., envir = parent.frame())
[16:12:28.848]    - tweaked: FALSE
[16:12:28.848]    - call: NULL
[16:12:28.848] plan(): nbrOfWorkers() = 1
[16:12:28.849] - globals found: [1] ‘{’
[16:12:28.849] Searching for globals ... DONE
[16:12:28.849] Resolving globals: FALSE
[16:12:28.850] 
[16:12:28.850] 
[16:12:28.850] getGlobalsAndPackages() ... DONE
[16:12:28.850] plan(): Setting new future strategy stack:
[16:12:28.851] run() for ‘Future’ ...
[16:12:28.851] - state: ‘created’
[16:12:28.851] List of future strategies:
[16:12:28.851] 1. multicore:
[16:12:28.851]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.851]    - tweaked: FALSE
[16:12:28.851]    - call: plan(strategy)
[16:12:28.851] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.855] plan(): nbrOfWorkers() = 2
[16:12:28.856] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.856] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.856]   - Field: ‘label’
[16:12:28.856]   - Field: ‘local’
[16:12:28.856]   - Field: ‘owner’
[16:12:28.857]   - Field: ‘envir’
[16:12:28.857]   - Field: ‘workers’
[16:12:28.857]   - Field: ‘packages’
[16:12:28.857]   - Field: ‘gc’
[16:12:28.857]   - Field: ‘job’
[16:12:28.857]   - Field: ‘conditions’
[16:12:28.858]   - Field: ‘expr’
[16:12:28.858]   - Field: ‘uuid’
[16:12:28.858]   - Field: ‘seed’
[16:12:28.858]   - Field: ‘version’
[16:12:28.858]   - Field: ‘result’
[16:12:28.858]   - Field: ‘asynchronous’
[16:12:28.858]   - Field: ‘calls’
[16:12:28.859]   - Field: ‘globals’
[16:12:28.859]   - Field: ‘stdout’
[16:12:28.859]   - Field: ‘earlySignal’
[16:12:28.859]   - Field: ‘lazy’
[16:12:28.859]   - Field: ‘state’
[16:12:28.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.859] - Launch lazy future ...
[16:12:28.860] Packages needed by the future expression (n = 0): <none>
[16:12:28.860] Packages needed by future strategies (n = 0): <none>
[16:12:28.861] {
[16:12:28.861]     {
[16:12:28.861]         {
[16:12:28.861]             ...future.startTime <- base::Sys.time()
[16:12:28.861]             {
[16:12:28.861]                 {
[16:12:28.861]                   {
[16:12:28.861]                     {
[16:12:28.861]                       base::local({
[16:12:28.861]                         has_future <- base::requireNamespace("future", 
[16:12:28.861]                           quietly = TRUE)
[16:12:28.861]                         if (has_future) {
[16:12:28.861]                           ns <- base::getNamespace("future")
[16:12:28.861]                           version <- ns[[".package"]][["version"]]
[16:12:28.861]                           if (is.null(version)) 
[16:12:28.861]                             version <- utils::packageVersion("future")
[16:12:28.861]                         }
[16:12:28.861]                         else {
[16:12:28.861]                           version <- NULL
[16:12:28.861]                         }
[16:12:28.861]                         if (!has_future || version < "1.8.0") {
[16:12:28.861]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.861]                             "", base::R.version$version.string), 
[16:12:28.861]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.861]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.861]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.861]                               "release", "version")], collapse = " "), 
[16:12:28.861]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.861]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.861]                             info)
[16:12:28.861]                           info <- base::paste(info, collapse = "; ")
[16:12:28.861]                           if (!has_future) {
[16:12:28.861]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.861]                               info)
[16:12:28.861]                           }
[16:12:28.861]                           else {
[16:12:28.861]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.861]                               info, version)
[16:12:28.861]                           }
[16:12:28.861]                           base::stop(msg)
[16:12:28.861]                         }
[16:12:28.861]                       })
[16:12:28.861]                     }
[16:12:28.861]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.861]                     base::options(mc.cores = 1L)
[16:12:28.861]                   }
[16:12:28.861]                   options(future.plan = NULL)
[16:12:28.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.861]                 }
[16:12:28.861]                 ...future.workdir <- getwd()
[16:12:28.861]             }
[16:12:28.861]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.861]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.861]         }
[16:12:28.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.861]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.861]             base::names(...future.oldOptions))
[16:12:28.861]     }
[16:12:28.861]     if (FALSE) {
[16:12:28.861]     }
[16:12:28.861]     else {
[16:12:28.861]         if (TRUE) {
[16:12:28.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.861]                 open = "w")
[16:12:28.861]         }
[16:12:28.861]         else {
[16:12:28.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.861]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.861]         }
[16:12:28.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.861]             base::sink(type = "output", split = FALSE)
[16:12:28.861]             base::close(...future.stdout)
[16:12:28.861]         }, add = TRUE)
[16:12:28.861]     }
[16:12:28.861]     ...future.frame <- base::sys.nframe()
[16:12:28.861]     ...future.conditions <- base::list()
[16:12:28.861]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.861]     if (FALSE) {
[16:12:28.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.861]     }
[16:12:28.861]     ...future.result <- base::tryCatch({
[16:12:28.861]         base::withCallingHandlers({
[16:12:28.861]             ...future.value <- base::withVisible(base::local({
[16:12:28.861]                 withCallingHandlers({
[16:12:28.861]                   {
[16:12:28.861]                     4
[16:12:28.861]                   }
[16:12:28.861]                 }, immediateCondition = function(cond) {
[16:12:28.861]                   save_rds <- function (object, pathname, ...) 
[16:12:28.861]                   {
[16:12:28.861]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.861]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.861]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.861]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.861]                         fi_tmp[["mtime"]])
[16:12:28.861]                     }
[16:12:28.861]                     tryCatch({
[16:12:28.861]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.861]                     }, error = function(ex) {
[16:12:28.861]                       msg <- conditionMessage(ex)
[16:12:28.861]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.861]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.861]                         fi_tmp[["mtime"]], msg)
[16:12:28.861]                       ex$message <- msg
[16:12:28.861]                       stop(ex)
[16:12:28.861]                     })
[16:12:28.861]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.861]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.861]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.861]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.861]                       fi <- file.info(pathname)
[16:12:28.861]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.861]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.861]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.861]                         fi[["size"]], fi[["mtime"]])
[16:12:28.861]                       stop(msg)
[16:12:28.861]                     }
[16:12:28.861]                     invisible(pathname)
[16:12:28.861]                   }
[16:12:28.861]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.861]                     rootPath = tempdir()) 
[16:12:28.861]                   {
[16:12:28.861]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.861]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.861]                       tmpdir = path, fileext = ".rds")
[16:12:28.861]                     save_rds(obj, file)
[16:12:28.861]                   }
[16:12:28.861]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.861]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.861]                   {
[16:12:28.861]                     inherits <- base::inherits
[16:12:28.861]                     invokeRestart <- base::invokeRestart
[16:12:28.861]                     is.null <- base::is.null
[16:12:28.861]                     muffled <- FALSE
[16:12:28.861]                     if (inherits(cond, "message")) {
[16:12:28.861]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.861]                       if (muffled) 
[16:12:28.861]                         invokeRestart("muffleMessage")
[16:12:28.861]                     }
[16:12:28.861]                     else if (inherits(cond, "warning")) {
[16:12:28.861]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.861]                       if (muffled) 
[16:12:28.861]                         invokeRestart("muffleWarning")
[16:12:28.861]                     }
[16:12:28.861]                     else if (inherits(cond, "condition")) {
[16:12:28.861]                       if (!is.null(pattern)) {
[16:12:28.861]                         computeRestarts <- base::computeRestarts
[16:12:28.861]                         grepl <- base::grepl
[16:12:28.861]                         restarts <- computeRestarts(cond)
[16:12:28.861]                         for (restart in restarts) {
[16:12:28.861]                           name <- restart$name
[16:12:28.861]                           if (is.null(name)) 
[16:12:28.861]                             next
[16:12:28.861]                           if (!grepl(pattern, name)) 
[16:12:28.861]                             next
[16:12:28.861]                           invokeRestart(restart)
[16:12:28.861]                           muffled <- TRUE
[16:12:28.861]                           break
[16:12:28.861]                         }
[16:12:28.861]                       }
[16:12:28.861]                     }
[16:12:28.861]                     invisible(muffled)
[16:12:28.861]                   }
[16:12:28.861]                   muffleCondition(cond)
[16:12:28.861]                 })
[16:12:28.861]             }))
[16:12:28.861]             future::FutureResult(value = ...future.value$value, 
[16:12:28.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.861]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.861]                     ...future.globalenv.names))
[16:12:28.861]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.861]         }, condition = base::local({
[16:12:28.861]             c <- base::c
[16:12:28.861]             inherits <- base::inherits
[16:12:28.861]             invokeRestart <- base::invokeRestart
[16:12:28.861]             length <- base::length
[16:12:28.861]             list <- base::list
[16:12:28.861]             seq.int <- base::seq.int
[16:12:28.861]             signalCondition <- base::signalCondition
[16:12:28.861]             sys.calls <- base::sys.calls
[16:12:28.861]             `[[` <- base::`[[`
[16:12:28.861]             `+` <- base::`+`
[16:12:28.861]             `<<-` <- base::`<<-`
[16:12:28.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.861]                   3L)]
[16:12:28.861]             }
[16:12:28.861]             function(cond) {
[16:12:28.861]                 is_error <- inherits(cond, "error")
[16:12:28.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.861]                   NULL)
[16:12:28.861]                 if (is_error) {
[16:12:28.861]                   sessionInformation <- function() {
[16:12:28.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.861]                       search = base::search(), system = base::Sys.info())
[16:12:28.861]                   }
[16:12:28.861]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.861]                     cond$call), session = sessionInformation(), 
[16:12:28.861]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.861]                   signalCondition(cond)
[16:12:28.861]                 }
[16:12:28.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.861]                 "immediateCondition"))) {
[16:12:28.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.861]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.861]                   if (TRUE && !signal) {
[16:12:28.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.861]                     {
[16:12:28.861]                       inherits <- base::inherits
[16:12:28.861]                       invokeRestart <- base::invokeRestart
[16:12:28.861]                       is.null <- base::is.null
[16:12:28.861]                       muffled <- FALSE
[16:12:28.861]                       if (inherits(cond, "message")) {
[16:12:28.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.861]                         if (muffled) 
[16:12:28.861]                           invokeRestart("muffleMessage")
[16:12:28.861]                       }
[16:12:28.861]                       else if (inherits(cond, "warning")) {
[16:12:28.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.861]                         if (muffled) 
[16:12:28.861]                           invokeRestart("muffleWarning")
[16:12:28.861]                       }
[16:12:28.861]                       else if (inherits(cond, "condition")) {
[16:12:28.861]                         if (!is.null(pattern)) {
[16:12:28.861]                           computeRestarts <- base::computeRestarts
[16:12:28.861]                           grepl <- base::grepl
[16:12:28.861]                           restarts <- computeRestarts(cond)
[16:12:28.861]                           for (restart in restarts) {
[16:12:28.861]                             name <- restart$name
[16:12:28.861]                             if (is.null(name)) 
[16:12:28.861]                               next
[16:12:28.861]                             if (!grepl(pattern, name)) 
[16:12:28.861]                               next
[16:12:28.861]                             invokeRestart(restart)
[16:12:28.861]                             muffled <- TRUE
[16:12:28.861]                             break
[16:12:28.861]                           }
[16:12:28.861]                         }
[16:12:28.861]                       }
[16:12:28.861]                       invisible(muffled)
[16:12:28.861]                     }
[16:12:28.861]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.861]                   }
[16:12:28.861]                 }
[16:12:28.861]                 else {
[16:12:28.861]                   if (TRUE) {
[16:12:28.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.861]                     {
[16:12:28.861]                       inherits <- base::inherits
[16:12:28.861]                       invokeRestart <- base::invokeRestart
[16:12:28.861]                       is.null <- base::is.null
[16:12:28.861]                       muffled <- FALSE
[16:12:28.861]                       if (inherits(cond, "message")) {
[16:12:28.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.861]                         if (muffled) 
[16:12:28.861]                           invokeRestart("muffleMessage")
[16:12:28.861]                       }
[16:12:28.861]                       else if (inherits(cond, "warning")) {
[16:12:28.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.861]                         if (muffled) 
[16:12:28.861]                           invokeRestart("muffleWarning")
[16:12:28.861]                       }
[16:12:28.861]                       else if (inherits(cond, "condition")) {
[16:12:28.861]                         if (!is.null(pattern)) {
[16:12:28.861]                           computeRestarts <- base::computeRestarts
[16:12:28.861]                           grepl <- base::grepl
[16:12:28.861]                           restarts <- computeRestarts(cond)
[16:12:28.861]                           for (restart in restarts) {
[16:12:28.861]                             name <- restart$name
[16:12:28.861]                             if (is.null(name)) 
[16:12:28.861]                               next
[16:12:28.861]                             if (!grepl(pattern, name)) 
[16:12:28.861]                               next
[16:12:28.861]                             invokeRestart(restart)
[16:12:28.861]                             muffled <- TRUE
[16:12:28.861]                             break
[16:12:28.861]                           }
[16:12:28.861]                         }
[16:12:28.861]                       }
[16:12:28.861]                       invisible(muffled)
[16:12:28.861]                     }
[16:12:28.861]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.861]                   }
[16:12:28.861]                 }
[16:12:28.861]             }
[16:12:28.861]         }))
[16:12:28.861]     }, error = function(ex) {
[16:12:28.861]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.861]                 ...future.rng), started = ...future.startTime, 
[16:12:28.861]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.861]             version = "1.8"), class = "FutureResult")
[16:12:28.861]     }, finally = {
[16:12:28.861]         if (!identical(...future.workdir, getwd())) 
[16:12:28.861]             setwd(...future.workdir)
[16:12:28.861]         {
[16:12:28.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.861]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.861]             }
[16:12:28.861]             base::options(...future.oldOptions)
[16:12:28.861]             if (.Platform$OS.type == "windows") {
[16:12:28.861]                 old_names <- names(...future.oldEnvVars)
[16:12:28.861]                 envs <- base::Sys.getenv()
[16:12:28.861]                 names <- names(envs)
[16:12:28.861]                 common <- intersect(names, old_names)
[16:12:28.861]                 added <- setdiff(names, old_names)
[16:12:28.861]                 removed <- setdiff(old_names, names)
[16:12:28.861]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.861]                   envs[common]]
[16:12:28.861]                 NAMES <- toupper(changed)
[16:12:28.861]                 args <- list()
[16:12:28.861]                 for (kk in seq_along(NAMES)) {
[16:12:28.861]                   name <- changed[[kk]]
[16:12:28.861]                   NAME <- NAMES[[kk]]
[16:12:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.861]                     next
[16:12:28.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.861]                 }
[16:12:28.861]                 NAMES <- toupper(added)
[16:12:28.861]                 for (kk in seq_along(NAMES)) {
[16:12:28.861]                   name <- added[[kk]]
[16:12:28.861]                   NAME <- NAMES[[kk]]
[16:12:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.861]                     next
[16:12:28.861]                   args[[name]] <- ""
[16:12:28.861]                 }
[16:12:28.861]                 NAMES <- toupper(removed)
[16:12:28.861]                 for (kk in seq_along(NAMES)) {
[16:12:28.861]                   name <- removed[[kk]]
[16:12:28.861]                   NAME <- NAMES[[kk]]
[16:12:28.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.861]                     next
[16:12:28.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.861]                 }
[16:12:28.861]                 if (length(args) > 0) 
[16:12:28.861]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.861]             }
[16:12:28.861]             else {
[16:12:28.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.861]             }
[16:12:28.861]             {
[16:12:28.861]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.861]                   0L) {
[16:12:28.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.861]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.861]                   base::options(opts)
[16:12:28.861]                 }
[16:12:28.861]                 {
[16:12:28.861]                   {
[16:12:28.861]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.861]                     NULL
[16:12:28.861]                   }
[16:12:28.861]                   options(future.plan = NULL)
[16:12:28.861]                   if (is.na(NA_character_)) 
[16:12:28.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.861]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.861]                     envir = parent.frame()) 
[16:12:28.861]                   {
[16:12:28.861]                     default_workers <- missing(workers)
[16:12:28.861]                     if (is.function(workers)) 
[16:12:28.861]                       workers <- workers()
[16:12:28.861]                     workers <- structure(as.integer(workers), 
[16:12:28.861]                       class = class(workers))
[16:12:28.861]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.861]                       1L)
[16:12:28.861]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.861]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.861]                       if (default_workers) 
[16:12:28.861]                         supportsMulticore(warn = TRUE)
[16:12:28.861]                       return(sequential(..., envir = envir))
[16:12:28.861]                     }
[16:12:28.861]                     oopts <- options(mc.cores = workers)
[16:12:28.861]                     on.exit(options(oopts))
[16:12:28.861]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.861]                       envir = envir)
[16:12:28.861]                     if (!future$lazy) 
[16:12:28.861]                       future <- run(future)
[16:12:28.861]                     invisible(future)
[16:12:28.861]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.861]                 }
[16:12:28.861]             }
[16:12:28.861]         }
[16:12:28.861]     })
[16:12:28.861]     if (TRUE) {
[16:12:28.861]         base::sink(type = "output", split = FALSE)
[16:12:28.861]         if (TRUE) {
[16:12:28.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.861]         }
[16:12:28.861]         else {
[16:12:28.861]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.861]         }
[16:12:28.861]         base::close(...future.stdout)
[16:12:28.861]         ...future.stdout <- NULL
[16:12:28.861]     }
[16:12:28.861]     ...future.result$conditions <- ...future.conditions
[16:12:28.861]     ...future.result$finished <- base::Sys.time()
[16:12:28.861]     ...future.result
[16:12:28.861] }
[16:12:28.864] requestCore(): workers = 2
[16:12:28.865] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:28.879] MulticoreFuture started
[16:12:28.879] - Launch lazy future ... done
[16:12:28.880] run() for ‘MulticoreFuture’ ... done
[16:12:28.880] plan(): Setting new future strategy stack:
<environment: 0x560bb07f31d8> 
[16:12:28.881] List of future strategies:
[16:12:28.881] 1. sequential:
[16:12:28.881]    - args: function (..., envir = parent.frame())
[16:12:28.881]    - tweaked: FALSE
[16:12:28.881]    - call: NULL
[16:12:28.882] plan(): nbrOfWorkers() = 1
<environment: 0x560baebf3c38> 
[16:12:28.885] plan(): Setting new future strategy stack:
[16:12:28.885] List of future strategies:
[16:12:28.885] 1. multicore:
[16:12:28.885]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.885]    - tweaked: FALSE
[16:12:28.885]    - call: plan(strategy)
[16:12:28.890] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:28.893] resolve() on environment ...
[16:12:28.893]  recursive: 0
[16:12:28.894]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:28.894] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.894] - nx: 4
[16:12:28.894] - relay: TRUE
[16:12:28.894] - stdout: TRUE
[16:12:28.894] - signal: TRUE
[16:12:28.895] - resignal: FALSE
[16:12:28.895] - force: TRUE
[16:12:28.895] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.895] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.895]  - until=2
[16:12:28.895]  - relaying element #2
[16:12:28.895] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.896] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.896] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.896]  length: 3 (resolved future 1)
[16:12:28.896] Future #2
[16:12:28.896] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:28.897] - nx: 4
[16:12:28.897] - relay: TRUE
[16:12:28.897] - stdout: TRUE
[16:12:28.897] - signal: TRUE
[16:12:28.897] - resignal: FALSE
[16:12:28.897] - force: TRUE
[16:12:28.897] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.898] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.898]  - until=2
[16:12:28.898]  - relaying element #2
[16:12:28.898] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.898] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.898] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:28.899]  length: 2 (resolved future 2)
[16:12:28.899] Future #3
[16:12:28.900] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:28.900] - nx: 4
[16:12:28.900] - relay: TRUE
[16:12:28.900] - stdout: TRUE
[16:12:28.901] - signal: TRUE
[16:12:28.901] - resignal: FALSE
[16:12:28.901] - force: TRUE
[16:12:28.901] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.901] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.901]  - until=3
[16:12:28.902]  - relaying element #3
[16:12:28.902] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.902] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.902] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:28.902]  length: 1 (resolved future 3)
[16:12:28.903] Future #4
[16:12:28.904] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:28.904] - nx: 4
[16:12:28.904] - relay: TRUE
[16:12:28.904] - stdout: TRUE
[16:12:28.904] - signal: TRUE
[16:12:28.904] - resignal: FALSE
[16:12:28.905] - force: TRUE
[16:12:28.905] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.905] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.905]  - until=4
[16:12:28.905]  - relaying element #4
[16:12:28.906] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.906] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:28.906] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:28.906]  length: 0 (resolved future 4)
[16:12:28.906] Relaying remaining futures
[16:12:28.906] signalConditionsASAP(NULL, pos=0) ...
[16:12:28.907] - nx: 4
[16:12:28.907] - relay: TRUE
[16:12:28.907] - stdout: TRUE
[16:12:28.907] - signal: TRUE
[16:12:28.907] - resignal: FALSE
[16:12:28.907] - force: TRUE
[16:12:28.907] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.908] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:28.908] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:28.908] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:28.908] signalConditionsASAP(NULL, pos=0) ... done
[16:12:28.908] resolve() on environment ... DONE
<environment: 0x560baeaa32d0> 
Dimensions: c(2, 3, 1)
[16:12:28.909] getGlobalsAndPackages() ...
[16:12:28.909] Searching for globals...
[16:12:28.909] 
[16:12:28.910] Searching for globals ... DONE
[16:12:28.910] - globals: [0] <none>
[16:12:28.910] getGlobalsAndPackages() ... DONE
[16:12:28.910] run() for ‘Future’ ...
[16:12:28.910] - state: ‘created’
[16:12:28.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.915]   - Field: ‘label’
[16:12:28.915]   - Field: ‘local’
[16:12:28.915]   - Field: ‘owner’
[16:12:28.916]   - Field: ‘envir’
[16:12:28.916]   - Field: ‘workers’
[16:12:28.916]   - Field: ‘packages’
[16:12:28.916]   - Field: ‘gc’
[16:12:28.916]   - Field: ‘job’
[16:12:28.916]   - Field: ‘conditions’
[16:12:28.916]   - Field: ‘expr’
[16:12:28.916]   - Field: ‘uuid’
[16:12:28.917]   - Field: ‘seed’
[16:12:28.917]   - Field: ‘version’
[16:12:28.917]   - Field: ‘result’
[16:12:28.917]   - Field: ‘asynchronous’
[16:12:28.917]   - Field: ‘calls’
[16:12:28.917]   - Field: ‘globals’
[16:12:28.917]   - Field: ‘stdout’
[16:12:28.917]   - Field: ‘earlySignal’
[16:12:28.917]   - Field: ‘lazy’
[16:12:28.918]   - Field: ‘state’
[16:12:28.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.918] - Launch lazy future ...
[16:12:28.918] Packages needed by the future expression (n = 0): <none>
[16:12:28.918] Packages needed by future strategies (n = 0): <none>
[16:12:28.919] {
[16:12:28.919]     {
[16:12:28.919]         {
[16:12:28.919]             ...future.startTime <- base::Sys.time()
[16:12:28.919]             {
[16:12:28.919]                 {
[16:12:28.919]                   {
[16:12:28.919]                     {
[16:12:28.919]                       base::local({
[16:12:28.919]                         has_future <- base::requireNamespace("future", 
[16:12:28.919]                           quietly = TRUE)
[16:12:28.919]                         if (has_future) {
[16:12:28.919]                           ns <- base::getNamespace("future")
[16:12:28.919]                           version <- ns[[".package"]][["version"]]
[16:12:28.919]                           if (is.null(version)) 
[16:12:28.919]                             version <- utils::packageVersion("future")
[16:12:28.919]                         }
[16:12:28.919]                         else {
[16:12:28.919]                           version <- NULL
[16:12:28.919]                         }
[16:12:28.919]                         if (!has_future || version < "1.8.0") {
[16:12:28.919]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.919]                             "", base::R.version$version.string), 
[16:12:28.919]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.919]                               "release", "version")], collapse = " "), 
[16:12:28.919]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.919]                             info)
[16:12:28.919]                           info <- base::paste(info, collapse = "; ")
[16:12:28.919]                           if (!has_future) {
[16:12:28.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.919]                               info)
[16:12:28.919]                           }
[16:12:28.919]                           else {
[16:12:28.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.919]                               info, version)
[16:12:28.919]                           }
[16:12:28.919]                           base::stop(msg)
[16:12:28.919]                         }
[16:12:28.919]                       })
[16:12:28.919]                     }
[16:12:28.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.919]                     base::options(mc.cores = 1L)
[16:12:28.919]                   }
[16:12:28.919]                   options(future.plan = NULL)
[16:12:28.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.919]                 }
[16:12:28.919]                 ...future.workdir <- getwd()
[16:12:28.919]             }
[16:12:28.919]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.919]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.919]         }
[16:12:28.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.919]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.919]             base::names(...future.oldOptions))
[16:12:28.919]     }
[16:12:28.919]     if (FALSE) {
[16:12:28.919]     }
[16:12:28.919]     else {
[16:12:28.919]         if (TRUE) {
[16:12:28.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.919]                 open = "w")
[16:12:28.919]         }
[16:12:28.919]         else {
[16:12:28.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.919]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.919]         }
[16:12:28.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.919]             base::sink(type = "output", split = FALSE)
[16:12:28.919]             base::close(...future.stdout)
[16:12:28.919]         }, add = TRUE)
[16:12:28.919]     }
[16:12:28.919]     ...future.frame <- base::sys.nframe()
[16:12:28.919]     ...future.conditions <- base::list()
[16:12:28.919]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.919]     if (FALSE) {
[16:12:28.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.919]     }
[16:12:28.919]     ...future.result <- base::tryCatch({
[16:12:28.919]         base::withCallingHandlers({
[16:12:28.919]             ...future.value <- base::withVisible(base::local({
[16:12:28.919]                 withCallingHandlers({
[16:12:28.919]                   2
[16:12:28.919]                 }, immediateCondition = function(cond) {
[16:12:28.919]                   save_rds <- function (object, pathname, ...) 
[16:12:28.919]                   {
[16:12:28.919]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.919]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.919]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.919]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.919]                         fi_tmp[["mtime"]])
[16:12:28.919]                     }
[16:12:28.919]                     tryCatch({
[16:12:28.919]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.919]                     }, error = function(ex) {
[16:12:28.919]                       msg <- conditionMessage(ex)
[16:12:28.919]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.919]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.919]                         fi_tmp[["mtime"]], msg)
[16:12:28.919]                       ex$message <- msg
[16:12:28.919]                       stop(ex)
[16:12:28.919]                     })
[16:12:28.919]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.919]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.919]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.919]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.919]                       fi <- file.info(pathname)
[16:12:28.919]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.919]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.919]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.919]                         fi[["size"]], fi[["mtime"]])
[16:12:28.919]                       stop(msg)
[16:12:28.919]                     }
[16:12:28.919]                     invisible(pathname)
[16:12:28.919]                   }
[16:12:28.919]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.919]                     rootPath = tempdir()) 
[16:12:28.919]                   {
[16:12:28.919]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.919]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.919]                       tmpdir = path, fileext = ".rds")
[16:12:28.919]                     save_rds(obj, file)
[16:12:28.919]                   }
[16:12:28.919]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.919]                   {
[16:12:28.919]                     inherits <- base::inherits
[16:12:28.919]                     invokeRestart <- base::invokeRestart
[16:12:28.919]                     is.null <- base::is.null
[16:12:28.919]                     muffled <- FALSE
[16:12:28.919]                     if (inherits(cond, "message")) {
[16:12:28.919]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.919]                       if (muffled) 
[16:12:28.919]                         invokeRestart("muffleMessage")
[16:12:28.919]                     }
[16:12:28.919]                     else if (inherits(cond, "warning")) {
[16:12:28.919]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.919]                       if (muffled) 
[16:12:28.919]                         invokeRestart("muffleWarning")
[16:12:28.919]                     }
[16:12:28.919]                     else if (inherits(cond, "condition")) {
[16:12:28.919]                       if (!is.null(pattern)) {
[16:12:28.919]                         computeRestarts <- base::computeRestarts
[16:12:28.919]                         grepl <- base::grepl
[16:12:28.919]                         restarts <- computeRestarts(cond)
[16:12:28.919]                         for (restart in restarts) {
[16:12:28.919]                           name <- restart$name
[16:12:28.919]                           if (is.null(name)) 
[16:12:28.919]                             next
[16:12:28.919]                           if (!grepl(pattern, name)) 
[16:12:28.919]                             next
[16:12:28.919]                           invokeRestart(restart)
[16:12:28.919]                           muffled <- TRUE
[16:12:28.919]                           break
[16:12:28.919]                         }
[16:12:28.919]                       }
[16:12:28.919]                     }
[16:12:28.919]                     invisible(muffled)
[16:12:28.919]                   }
[16:12:28.919]                   muffleCondition(cond)
[16:12:28.919]                 })
[16:12:28.919]             }))
[16:12:28.919]             future::FutureResult(value = ...future.value$value, 
[16:12:28.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.919]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.919]                     ...future.globalenv.names))
[16:12:28.919]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.919]         }, condition = base::local({
[16:12:28.919]             c <- base::c
[16:12:28.919]             inherits <- base::inherits
[16:12:28.919]             invokeRestart <- base::invokeRestart
[16:12:28.919]             length <- base::length
[16:12:28.919]             list <- base::list
[16:12:28.919]             seq.int <- base::seq.int
[16:12:28.919]             signalCondition <- base::signalCondition
[16:12:28.919]             sys.calls <- base::sys.calls
[16:12:28.919]             `[[` <- base::`[[`
[16:12:28.919]             `+` <- base::`+`
[16:12:28.919]             `<<-` <- base::`<<-`
[16:12:28.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.919]                   3L)]
[16:12:28.919]             }
[16:12:28.919]             function(cond) {
[16:12:28.919]                 is_error <- inherits(cond, "error")
[16:12:28.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.919]                   NULL)
[16:12:28.919]                 if (is_error) {
[16:12:28.919]                   sessionInformation <- function() {
[16:12:28.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.919]                       search = base::search(), system = base::Sys.info())
[16:12:28.919]                   }
[16:12:28.919]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.919]                     cond$call), session = sessionInformation(), 
[16:12:28.919]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.919]                   signalCondition(cond)
[16:12:28.919]                 }
[16:12:28.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.919]                 "immediateCondition"))) {
[16:12:28.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.919]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.919]                   if (TRUE && !signal) {
[16:12:28.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.919]                     {
[16:12:28.919]                       inherits <- base::inherits
[16:12:28.919]                       invokeRestart <- base::invokeRestart
[16:12:28.919]                       is.null <- base::is.null
[16:12:28.919]                       muffled <- FALSE
[16:12:28.919]                       if (inherits(cond, "message")) {
[16:12:28.919]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.919]                         if (muffled) 
[16:12:28.919]                           invokeRestart("muffleMessage")
[16:12:28.919]                       }
[16:12:28.919]                       else if (inherits(cond, "warning")) {
[16:12:28.919]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.919]                         if (muffled) 
[16:12:28.919]                           invokeRestart("muffleWarning")
[16:12:28.919]                       }
[16:12:28.919]                       else if (inherits(cond, "condition")) {
[16:12:28.919]                         if (!is.null(pattern)) {
[16:12:28.919]                           computeRestarts <- base::computeRestarts
[16:12:28.919]                           grepl <- base::grepl
[16:12:28.919]                           restarts <- computeRestarts(cond)
[16:12:28.919]                           for (restart in restarts) {
[16:12:28.919]                             name <- restart$name
[16:12:28.919]                             if (is.null(name)) 
[16:12:28.919]                               next
[16:12:28.919]                             if (!grepl(pattern, name)) 
[16:12:28.919]                               next
[16:12:28.919]                             invokeRestart(restart)
[16:12:28.919]                             muffled <- TRUE
[16:12:28.919]                             break
[16:12:28.919]                           }
[16:12:28.919]                         }
[16:12:28.919]                       }
[16:12:28.919]                       invisible(muffled)
[16:12:28.919]                     }
[16:12:28.919]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.919]                   }
[16:12:28.919]                 }
[16:12:28.919]                 else {
[16:12:28.919]                   if (TRUE) {
[16:12:28.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.919]                     {
[16:12:28.919]                       inherits <- base::inherits
[16:12:28.919]                       invokeRestart <- base::invokeRestart
[16:12:28.919]                       is.null <- base::is.null
[16:12:28.919]                       muffled <- FALSE
[16:12:28.919]                       if (inherits(cond, "message")) {
[16:12:28.919]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.919]                         if (muffled) 
[16:12:28.919]                           invokeRestart("muffleMessage")
[16:12:28.919]                       }
[16:12:28.919]                       else if (inherits(cond, "warning")) {
[16:12:28.919]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.919]                         if (muffled) 
[16:12:28.919]                           invokeRestart("muffleWarning")
[16:12:28.919]                       }
[16:12:28.919]                       else if (inherits(cond, "condition")) {
[16:12:28.919]                         if (!is.null(pattern)) {
[16:12:28.919]                           computeRestarts <- base::computeRestarts
[16:12:28.919]                           grepl <- base::grepl
[16:12:28.919]                           restarts <- computeRestarts(cond)
[16:12:28.919]                           for (restart in restarts) {
[16:12:28.919]                             name <- restart$name
[16:12:28.919]                             if (is.null(name)) 
[16:12:28.919]                               next
[16:12:28.919]                             if (!grepl(pattern, name)) 
[16:12:28.919]                               next
[16:12:28.919]                             invokeRestart(restart)
[16:12:28.919]                             muffled <- TRUE
[16:12:28.919]                             break
[16:12:28.919]                           }
[16:12:28.919]                         }
[16:12:28.919]                       }
[16:12:28.919]                       invisible(muffled)
[16:12:28.919]                     }
[16:12:28.919]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.919]                   }
[16:12:28.919]                 }
[16:12:28.919]             }
[16:12:28.919]         }))
[16:12:28.919]     }, error = function(ex) {
[16:12:28.919]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.919]                 ...future.rng), started = ...future.startTime, 
[16:12:28.919]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.919]             version = "1.8"), class = "FutureResult")
[16:12:28.919]     }, finally = {
[16:12:28.919]         if (!identical(...future.workdir, getwd())) 
[16:12:28.919]             setwd(...future.workdir)
[16:12:28.919]         {
[16:12:28.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.919]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.919]             }
[16:12:28.919]             base::options(...future.oldOptions)
[16:12:28.919]             if (.Platform$OS.type == "windows") {
[16:12:28.919]                 old_names <- names(...future.oldEnvVars)
[16:12:28.919]                 envs <- base::Sys.getenv()
[16:12:28.919]                 names <- names(envs)
[16:12:28.919]                 common <- intersect(names, old_names)
[16:12:28.919]                 added <- setdiff(names, old_names)
[16:12:28.919]                 removed <- setdiff(old_names, names)
[16:12:28.919]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.919]                   envs[common]]
[16:12:28.919]                 NAMES <- toupper(changed)
[16:12:28.919]                 args <- list()
[16:12:28.919]                 for (kk in seq_along(NAMES)) {
[16:12:28.919]                   name <- changed[[kk]]
[16:12:28.919]                   NAME <- NAMES[[kk]]
[16:12:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.919]                     next
[16:12:28.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.919]                 }
[16:12:28.919]                 NAMES <- toupper(added)
[16:12:28.919]                 for (kk in seq_along(NAMES)) {
[16:12:28.919]                   name <- added[[kk]]
[16:12:28.919]                   NAME <- NAMES[[kk]]
[16:12:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.919]                     next
[16:12:28.919]                   args[[name]] <- ""
[16:12:28.919]                 }
[16:12:28.919]                 NAMES <- toupper(removed)
[16:12:28.919]                 for (kk in seq_along(NAMES)) {
[16:12:28.919]                   name <- removed[[kk]]
[16:12:28.919]                   NAME <- NAMES[[kk]]
[16:12:28.919]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.919]                     next
[16:12:28.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.919]                 }
[16:12:28.919]                 if (length(args) > 0) 
[16:12:28.919]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.919]             }
[16:12:28.919]             else {
[16:12:28.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.919]             }
[16:12:28.919]             {
[16:12:28.919]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.919]                   0L) {
[16:12:28.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.919]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.919]                   base::options(opts)
[16:12:28.919]                 }
[16:12:28.919]                 {
[16:12:28.919]                   {
[16:12:28.919]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.919]                     NULL
[16:12:28.919]                   }
[16:12:28.919]                   options(future.plan = NULL)
[16:12:28.919]                   if (is.na(NA_character_)) 
[16:12:28.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.919]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.919]                     envir = parent.frame()) 
[16:12:28.919]                   {
[16:12:28.919]                     default_workers <- missing(workers)
[16:12:28.919]                     if (is.function(workers)) 
[16:12:28.919]                       workers <- workers()
[16:12:28.919]                     workers <- structure(as.integer(workers), 
[16:12:28.919]                       class = class(workers))
[16:12:28.919]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.919]                       1L)
[16:12:28.919]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.919]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.919]                       if (default_workers) 
[16:12:28.919]                         supportsMulticore(warn = TRUE)
[16:12:28.919]                       return(sequential(..., envir = envir))
[16:12:28.919]                     }
[16:12:28.919]                     oopts <- options(mc.cores = workers)
[16:12:28.919]                     on.exit(options(oopts))
[16:12:28.919]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.919]                       envir = envir)
[16:12:28.919]                     if (!future$lazy) 
[16:12:28.919]                       future <- run(future)
[16:12:28.919]                     invisible(future)
[16:12:28.919]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.919]                 }
[16:12:28.919]             }
[16:12:28.919]         }
[16:12:28.919]     })
[16:12:28.919]     if (TRUE) {
[16:12:28.919]         base::sink(type = "output", split = FALSE)
[16:12:28.919]         if (TRUE) {
[16:12:28.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.919]         }
[16:12:28.919]         else {
[16:12:28.919]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.919]         }
[16:12:28.919]         base::close(...future.stdout)
[16:12:28.919]         ...future.stdout <- NULL
[16:12:28.919]     }
[16:12:28.919]     ...future.result$conditions <- ...future.conditions
[16:12:28.919]     ...future.result$finished <- base::Sys.time()
[16:12:28.919]     ...future.result
[16:12:28.919] }
[16:12:28.922] requestCore(): workers = 2
[16:12:28.924] MulticoreFuture started
[16:12:28.924] - Launch lazy future ... done
[16:12:28.924] run() for ‘MulticoreFuture’ ... done
[16:12:28.925] getGlobalsAndPackages() ...
[16:12:28.925] Searching for globals...
[16:12:28.925] plan(): Setting new future strategy stack:
[16:12:28.926] 
[16:12:28.925] List of future strategies:
[16:12:28.925] 1. sequential:
[16:12:28.925]    - args: function (..., envir = parent.frame())
[16:12:28.925]    - tweaked: FALSE
[16:12:28.925]    - call: NULL
[16:12:28.926] Searching for globals ... DONE
[16:12:28.926] - globals: [0] <none>
[16:12:28.926] plan(): nbrOfWorkers() = 1
[16:12:28.926] getGlobalsAndPackages() ... DONE
[16:12:28.927] run() for ‘Future’ ...
[16:12:28.927] - state: ‘created’
[16:12:28.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.928] plan(): Setting new future strategy stack:
[16:12:28.928] List of future strategies:
[16:12:28.928] 1. multicore:
[16:12:28.928]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.928]    - tweaked: FALSE
[16:12:28.928]    - call: plan(strategy)
[16:12:28.932] plan(): nbrOfWorkers() = 2
[16:12:28.932] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.933]   - Field: ‘label’
[16:12:28.933]   - Field: ‘local’
[16:12:28.933]   - Field: ‘owner’
[16:12:28.933]   - Field: ‘envir’
[16:12:28.933]   - Field: ‘workers’
[16:12:28.933]   - Field: ‘packages’
[16:12:28.934]   - Field: ‘gc’
[16:12:28.934]   - Field: ‘job’
[16:12:28.934]   - Field: ‘conditions’
[16:12:28.934]   - Field: ‘expr’
[16:12:28.934]   - Field: ‘uuid’
[16:12:28.934]   - Field: ‘seed’
[16:12:28.934]   - Field: ‘version’
[16:12:28.935]   - Field: ‘result’
[16:12:28.935]   - Field: ‘asynchronous’
[16:12:28.935]   - Field: ‘calls’
[16:12:28.935]   - Field: ‘globals’
[16:12:28.935]   - Field: ‘stdout’
[16:12:28.935]   - Field: ‘earlySignal’
[16:12:28.935]   - Field: ‘lazy’
[16:12:28.936]   - Field: ‘state’
[16:12:28.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.936] - Launch lazy future ...
[16:12:28.936] Packages needed by the future expression (n = 0): <none>
[16:12:28.937] Packages needed by future strategies (n = 0): <none>
[16:12:28.937] {
[16:12:28.937]     {
[16:12:28.937]         {
[16:12:28.937]             ...future.startTime <- base::Sys.time()
[16:12:28.937]             {
[16:12:28.937]                 {
[16:12:28.937]                   {
[16:12:28.937]                     {
[16:12:28.937]                       base::local({
[16:12:28.937]                         has_future <- base::requireNamespace("future", 
[16:12:28.937]                           quietly = TRUE)
[16:12:28.937]                         if (has_future) {
[16:12:28.937]                           ns <- base::getNamespace("future")
[16:12:28.937]                           version <- ns[[".package"]][["version"]]
[16:12:28.937]                           if (is.null(version)) 
[16:12:28.937]                             version <- utils::packageVersion("future")
[16:12:28.937]                         }
[16:12:28.937]                         else {
[16:12:28.937]                           version <- NULL
[16:12:28.937]                         }
[16:12:28.937]                         if (!has_future || version < "1.8.0") {
[16:12:28.937]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.937]                             "", base::R.version$version.string), 
[16:12:28.937]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.937]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.937]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.937]                               "release", "version")], collapse = " "), 
[16:12:28.937]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.937]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.937]                             info)
[16:12:28.937]                           info <- base::paste(info, collapse = "; ")
[16:12:28.937]                           if (!has_future) {
[16:12:28.937]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.937]                               info)
[16:12:28.937]                           }
[16:12:28.937]                           else {
[16:12:28.937]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.937]                               info, version)
[16:12:28.937]                           }
[16:12:28.937]                           base::stop(msg)
[16:12:28.937]                         }
[16:12:28.937]                       })
[16:12:28.937]                     }
[16:12:28.937]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.937]                     base::options(mc.cores = 1L)
[16:12:28.937]                   }
[16:12:28.937]                   options(future.plan = NULL)
[16:12:28.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.937]                 }
[16:12:28.937]                 ...future.workdir <- getwd()
[16:12:28.937]             }
[16:12:28.937]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.937]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.937]         }
[16:12:28.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.937]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.937]             base::names(...future.oldOptions))
[16:12:28.937]     }
[16:12:28.937]     if (FALSE) {
[16:12:28.937]     }
[16:12:28.937]     else {
[16:12:28.937]         if (TRUE) {
[16:12:28.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.937]                 open = "w")
[16:12:28.937]         }
[16:12:28.937]         else {
[16:12:28.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.937]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.937]         }
[16:12:28.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.937]             base::sink(type = "output", split = FALSE)
[16:12:28.937]             base::close(...future.stdout)
[16:12:28.937]         }, add = TRUE)
[16:12:28.937]     }
[16:12:28.937]     ...future.frame <- base::sys.nframe()
[16:12:28.937]     ...future.conditions <- base::list()
[16:12:28.937]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.937]     if (FALSE) {
[16:12:28.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.937]     }
[16:12:28.937]     ...future.result <- base::tryCatch({
[16:12:28.937]         base::withCallingHandlers({
[16:12:28.937]             ...future.value <- base::withVisible(base::local({
[16:12:28.937]                 withCallingHandlers({
[16:12:28.937]                   NULL
[16:12:28.937]                 }, immediateCondition = function(cond) {
[16:12:28.937]                   save_rds <- function (object, pathname, ...) 
[16:12:28.937]                   {
[16:12:28.937]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.937]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.937]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.937]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.937]                         fi_tmp[["mtime"]])
[16:12:28.937]                     }
[16:12:28.937]                     tryCatch({
[16:12:28.937]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.937]                     }, error = function(ex) {
[16:12:28.937]                       msg <- conditionMessage(ex)
[16:12:28.937]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.937]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.937]                         fi_tmp[["mtime"]], msg)
[16:12:28.937]                       ex$message <- msg
[16:12:28.937]                       stop(ex)
[16:12:28.937]                     })
[16:12:28.937]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.937]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.937]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.937]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.937]                       fi <- file.info(pathname)
[16:12:28.937]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.937]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.937]                         fi[["size"]], fi[["mtime"]])
[16:12:28.937]                       stop(msg)
[16:12:28.937]                     }
[16:12:28.937]                     invisible(pathname)
[16:12:28.937]                   }
[16:12:28.937]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.937]                     rootPath = tempdir()) 
[16:12:28.937]                   {
[16:12:28.937]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.937]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.937]                       tmpdir = path, fileext = ".rds")
[16:12:28.937]                     save_rds(obj, file)
[16:12:28.937]                   }
[16:12:28.937]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.937]                   {
[16:12:28.937]                     inherits <- base::inherits
[16:12:28.937]                     invokeRestart <- base::invokeRestart
[16:12:28.937]                     is.null <- base::is.null
[16:12:28.937]                     muffled <- FALSE
[16:12:28.937]                     if (inherits(cond, "message")) {
[16:12:28.937]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.937]                       if (muffled) 
[16:12:28.937]                         invokeRestart("muffleMessage")
[16:12:28.937]                     }
[16:12:28.937]                     else if (inherits(cond, "warning")) {
[16:12:28.937]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.937]                       if (muffled) 
[16:12:28.937]                         invokeRestart("muffleWarning")
[16:12:28.937]                     }
[16:12:28.937]                     else if (inherits(cond, "condition")) {
[16:12:28.937]                       if (!is.null(pattern)) {
[16:12:28.937]                         computeRestarts <- base::computeRestarts
[16:12:28.937]                         grepl <- base::grepl
[16:12:28.937]                         restarts <- computeRestarts(cond)
[16:12:28.937]                         for (restart in restarts) {
[16:12:28.937]                           name <- restart$name
[16:12:28.937]                           if (is.null(name)) 
[16:12:28.937]                             next
[16:12:28.937]                           if (!grepl(pattern, name)) 
[16:12:28.937]                             next
[16:12:28.937]                           invokeRestart(restart)
[16:12:28.937]                           muffled <- TRUE
[16:12:28.937]                           break
[16:12:28.937]                         }
[16:12:28.937]                       }
[16:12:28.937]                     }
[16:12:28.937]                     invisible(muffled)
[16:12:28.937]                   }
[16:12:28.937]                   muffleCondition(cond)
[16:12:28.937]                 })
[16:12:28.937]             }))
[16:12:28.937]             future::FutureResult(value = ...future.value$value, 
[16:12:28.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.937]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.937]                     ...future.globalenv.names))
[16:12:28.937]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.937]         }, condition = base::local({
[16:12:28.937]             c <- base::c
[16:12:28.937]             inherits <- base::inherits
[16:12:28.937]             invokeRestart <- base::invokeRestart
[16:12:28.937]             length <- base::length
[16:12:28.937]             list <- base::list
[16:12:28.937]             seq.int <- base::seq.int
[16:12:28.937]             signalCondition <- base::signalCondition
[16:12:28.937]             sys.calls <- base::sys.calls
[16:12:28.937]             `[[` <- base::`[[`
[16:12:28.937]             `+` <- base::`+`
[16:12:28.937]             `<<-` <- base::`<<-`
[16:12:28.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.937]                   3L)]
[16:12:28.937]             }
[16:12:28.937]             function(cond) {
[16:12:28.937]                 is_error <- inherits(cond, "error")
[16:12:28.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.937]                   NULL)
[16:12:28.937]                 if (is_error) {
[16:12:28.937]                   sessionInformation <- function() {
[16:12:28.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.937]                       search = base::search(), system = base::Sys.info())
[16:12:28.937]                   }
[16:12:28.937]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.937]                     cond$call), session = sessionInformation(), 
[16:12:28.937]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.937]                   signalCondition(cond)
[16:12:28.937]                 }
[16:12:28.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.937]                 "immediateCondition"))) {
[16:12:28.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.937]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.937]                   if (TRUE && !signal) {
[16:12:28.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.937]                     {
[16:12:28.937]                       inherits <- base::inherits
[16:12:28.937]                       invokeRestart <- base::invokeRestart
[16:12:28.937]                       is.null <- base::is.null
[16:12:28.937]                       muffled <- FALSE
[16:12:28.937]                       if (inherits(cond, "message")) {
[16:12:28.937]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.937]                         if (muffled) 
[16:12:28.937]                           invokeRestart("muffleMessage")
[16:12:28.937]                       }
[16:12:28.937]                       else if (inherits(cond, "warning")) {
[16:12:28.937]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.937]                         if (muffled) 
[16:12:28.937]                           invokeRestart("muffleWarning")
[16:12:28.937]                       }
[16:12:28.937]                       else if (inherits(cond, "condition")) {
[16:12:28.937]                         if (!is.null(pattern)) {
[16:12:28.937]                           computeRestarts <- base::computeRestarts
[16:12:28.937]                           grepl <- base::grepl
[16:12:28.937]                           restarts <- computeRestarts(cond)
[16:12:28.937]                           for (restart in restarts) {
[16:12:28.937]                             name <- restart$name
[16:12:28.937]                             if (is.null(name)) 
[16:12:28.937]                               next
[16:12:28.937]                             if (!grepl(pattern, name)) 
[16:12:28.937]                               next
[16:12:28.937]                             invokeRestart(restart)
[16:12:28.937]                             muffled <- TRUE
[16:12:28.937]                             break
[16:12:28.937]                           }
[16:12:28.937]                         }
[16:12:28.937]                       }
[16:12:28.937]                       invisible(muffled)
[16:12:28.937]                     }
[16:12:28.937]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.937]                   }
[16:12:28.937]                 }
[16:12:28.937]                 else {
[16:12:28.937]                   if (TRUE) {
[16:12:28.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.937]                     {
[16:12:28.937]                       inherits <- base::inherits
[16:12:28.937]                       invokeRestart <- base::invokeRestart
[16:12:28.937]                       is.null <- base::is.null
[16:12:28.937]                       muffled <- FALSE
[16:12:28.937]                       if (inherits(cond, "message")) {
[16:12:28.937]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.937]                         if (muffled) 
[16:12:28.937]                           invokeRestart("muffleMessage")
[16:12:28.937]                       }
[16:12:28.937]                       else if (inherits(cond, "warning")) {
[16:12:28.937]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.937]                         if (muffled) 
[16:12:28.937]                           invokeRestart("muffleWarning")
[16:12:28.937]                       }
[16:12:28.937]                       else if (inherits(cond, "condition")) {
[16:12:28.937]                         if (!is.null(pattern)) {
[16:12:28.937]                           computeRestarts <- base::computeRestarts
[16:12:28.937]                           grepl <- base::grepl
[16:12:28.937]                           restarts <- computeRestarts(cond)
[16:12:28.937]                           for (restart in restarts) {
[16:12:28.937]                             name <- restart$name
[16:12:28.937]                             if (is.null(name)) 
[16:12:28.937]                               next
[16:12:28.937]                             if (!grepl(pattern, name)) 
[16:12:28.937]                               next
[16:12:28.937]                             invokeRestart(restart)
[16:12:28.937]                             muffled <- TRUE
[16:12:28.937]                             break
[16:12:28.937]                           }
[16:12:28.937]                         }
[16:12:28.937]                       }
[16:12:28.937]                       invisible(muffled)
[16:12:28.937]                     }
[16:12:28.937]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.937]                   }
[16:12:28.937]                 }
[16:12:28.937]             }
[16:12:28.937]         }))
[16:12:28.937]     }, error = function(ex) {
[16:12:28.937]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.937]                 ...future.rng), started = ...future.startTime, 
[16:12:28.937]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.937]             version = "1.8"), class = "FutureResult")
[16:12:28.937]     }, finally = {
[16:12:28.937]         if (!identical(...future.workdir, getwd())) 
[16:12:28.937]             setwd(...future.workdir)
[16:12:28.937]         {
[16:12:28.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.937]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.937]             }
[16:12:28.937]             base::options(...future.oldOptions)
[16:12:28.937]             if (.Platform$OS.type == "windows") {
[16:12:28.937]                 old_names <- names(...future.oldEnvVars)
[16:12:28.937]                 envs <- base::Sys.getenv()
[16:12:28.937]                 names <- names(envs)
[16:12:28.937]                 common <- intersect(names, old_names)
[16:12:28.937]                 added <- setdiff(names, old_names)
[16:12:28.937]                 removed <- setdiff(old_names, names)
[16:12:28.937]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.937]                   envs[common]]
[16:12:28.937]                 NAMES <- toupper(changed)
[16:12:28.937]                 args <- list()
[16:12:28.937]                 for (kk in seq_along(NAMES)) {
[16:12:28.937]                   name <- changed[[kk]]
[16:12:28.937]                   NAME <- NAMES[[kk]]
[16:12:28.937]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.937]                     next
[16:12:28.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.937]                 }
[16:12:28.937]                 NAMES <- toupper(added)
[16:12:28.937]                 for (kk in seq_along(NAMES)) {
[16:12:28.937]                   name <- added[[kk]]
[16:12:28.937]                   NAME <- NAMES[[kk]]
[16:12:28.937]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.937]                     next
[16:12:28.937]                   args[[name]] <- ""
[16:12:28.937]                 }
[16:12:28.937]                 NAMES <- toupper(removed)
[16:12:28.937]                 for (kk in seq_along(NAMES)) {
[16:12:28.937]                   name <- removed[[kk]]
[16:12:28.937]                   NAME <- NAMES[[kk]]
[16:12:28.937]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.937]                     next
[16:12:28.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.937]                 }
[16:12:28.937]                 if (length(args) > 0) 
[16:12:28.937]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.937]             }
[16:12:28.937]             else {
[16:12:28.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.937]             }
[16:12:28.937]             {
[16:12:28.937]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.937]                   0L) {
[16:12:28.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.937]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.937]                   base::options(opts)
[16:12:28.937]                 }
[16:12:28.937]                 {
[16:12:28.937]                   {
[16:12:28.937]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.937]                     NULL
[16:12:28.937]                   }
[16:12:28.937]                   options(future.plan = NULL)
[16:12:28.937]                   if (is.na(NA_character_)) 
[16:12:28.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.937]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.937]                     envir = parent.frame()) 
[16:12:28.937]                   {
[16:12:28.937]                     default_workers <- missing(workers)
[16:12:28.937]                     if (is.function(workers)) 
[16:12:28.937]                       workers <- workers()
[16:12:28.937]                     workers <- structure(as.integer(workers), 
[16:12:28.937]                       class = class(workers))
[16:12:28.937]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.937]                       1L)
[16:12:28.937]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.937]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.937]                       if (default_workers) 
[16:12:28.937]                         supportsMulticore(warn = TRUE)
[16:12:28.937]                       return(sequential(..., envir = envir))
[16:12:28.937]                     }
[16:12:28.937]                     oopts <- options(mc.cores = workers)
[16:12:28.937]                     on.exit(options(oopts))
[16:12:28.937]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.937]                       envir = envir)
[16:12:28.937]                     if (!future$lazy) 
[16:12:28.937]                       future <- run(future)
[16:12:28.937]                     invisible(future)
[16:12:28.937]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.937]                 }
[16:12:28.937]             }
[16:12:28.937]         }
[16:12:28.937]     })
[16:12:28.937]     if (TRUE) {
[16:12:28.937]         base::sink(type = "output", split = FALSE)
[16:12:28.937]         if (TRUE) {
[16:12:28.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.937]         }
[16:12:28.937]         else {
[16:12:28.937]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.937]         }
[16:12:28.937]         base::close(...future.stdout)
[16:12:28.937]         ...future.stdout <- NULL
[16:12:28.937]     }
[16:12:28.937]     ...future.result$conditions <- ...future.conditions
[16:12:28.937]     ...future.result$finished <- base::Sys.time()
[16:12:28.937]     ...future.result
[16:12:28.937] }
[16:12:28.941] requestCore(): workers = 2
[16:12:28.943] MulticoreFuture started
[16:12:28.943] - Launch lazy future ... done
[16:12:28.944] run() for ‘MulticoreFuture’ ... done
[16:12:28.944] plan(): Setting new future strategy stack:
[16:12:28.945] getGlobalsAndPackages() ...
[16:12:28.945] Searching for globals...
[16:12:28.945] List of future strategies:
[16:12:28.945] 1. sequential:
[16:12:28.945]    - args: function (..., envir = parent.frame())
[16:12:28.945]    - tweaked: FALSE
[16:12:28.945]    - call: NULL
[16:12:28.946] plan(): nbrOfWorkers() = 1
[16:12:28.946] - globals found: [1] ‘{’
[16:12:28.946] Searching for globals ... DONE
[16:12:28.946] Resolving globals: FALSE
[16:12:28.947] 
[16:12:28.947] 
[16:12:28.947] getGlobalsAndPackages() ... DONE
[16:12:28.947] plan(): Setting new future strategy stack:
[16:12:28.948] run() for ‘Future’ ...
[16:12:28.948] - state: ‘created’
[16:12:28.948] List of future strategies:
[16:12:28.948] 1. multicore:
[16:12:28.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.948]    - tweaked: FALSE
[16:12:28.948]    - call: plan(strategy)
[16:12:28.948] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:28.953] plan(): nbrOfWorkers() = 2
[16:12:28.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:28.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:28.954]   - Field: ‘label’
[16:12:28.954]   - Field: ‘local’
[16:12:28.954]   - Field: ‘owner’
[16:12:28.954]   - Field: ‘envir’
[16:12:28.955]   - Field: ‘workers’
[16:12:28.955]   - Field: ‘packages’
[16:12:28.955]   - Field: ‘gc’
[16:12:28.955]   - Field: ‘job’
[16:12:28.955]   - Field: ‘conditions’
[16:12:28.955]   - Field: ‘expr’
[16:12:28.956]   - Field: ‘uuid’
[16:12:28.956]   - Field: ‘seed’
[16:12:28.956]   - Field: ‘version’
[16:12:28.956]   - Field: ‘result’
[16:12:28.956]   - Field: ‘asynchronous’
[16:12:28.956]   - Field: ‘calls’
[16:12:28.957]   - Field: ‘globals’
[16:12:28.957]   - Field: ‘stdout’
[16:12:28.957]   - Field: ‘earlySignal’
[16:12:28.957]   - Field: ‘lazy’
[16:12:28.957]   - Field: ‘state’
[16:12:28.957] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:28.957] - Launch lazy future ...
[16:12:28.958] Packages needed by the future expression (n = 0): <none>
[16:12:28.958] Packages needed by future strategies (n = 0): <none>
[16:12:28.959] {
[16:12:28.959]     {
[16:12:28.959]         {
[16:12:28.959]             ...future.startTime <- base::Sys.time()
[16:12:28.959]             {
[16:12:28.959]                 {
[16:12:28.959]                   {
[16:12:28.959]                     {
[16:12:28.959]                       base::local({
[16:12:28.959]                         has_future <- base::requireNamespace("future", 
[16:12:28.959]                           quietly = TRUE)
[16:12:28.959]                         if (has_future) {
[16:12:28.959]                           ns <- base::getNamespace("future")
[16:12:28.959]                           version <- ns[[".package"]][["version"]]
[16:12:28.959]                           if (is.null(version)) 
[16:12:28.959]                             version <- utils::packageVersion("future")
[16:12:28.959]                         }
[16:12:28.959]                         else {
[16:12:28.959]                           version <- NULL
[16:12:28.959]                         }
[16:12:28.959]                         if (!has_future || version < "1.8.0") {
[16:12:28.959]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:28.959]                             "", base::R.version$version.string), 
[16:12:28.959]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:28.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:28.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:28.959]                               "release", "version")], collapse = " "), 
[16:12:28.959]                             hostname = base::Sys.info()[["nodename"]])
[16:12:28.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:28.959]                             info)
[16:12:28.959]                           info <- base::paste(info, collapse = "; ")
[16:12:28.959]                           if (!has_future) {
[16:12:28.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:28.959]                               info)
[16:12:28.959]                           }
[16:12:28.959]                           else {
[16:12:28.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:28.959]                               info, version)
[16:12:28.959]                           }
[16:12:28.959]                           base::stop(msg)
[16:12:28.959]                         }
[16:12:28.959]                       })
[16:12:28.959]                     }
[16:12:28.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:28.959]                     base::options(mc.cores = 1L)
[16:12:28.959]                   }
[16:12:28.959]                   options(future.plan = NULL)
[16:12:28.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:28.959]                 }
[16:12:28.959]                 ...future.workdir <- getwd()
[16:12:28.959]             }
[16:12:28.959]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:28.959]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:28.959]         }
[16:12:28.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:28.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:28.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:28.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:28.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:28.959]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:28.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:28.959]             base::names(...future.oldOptions))
[16:12:28.959]     }
[16:12:28.959]     if (FALSE) {
[16:12:28.959]     }
[16:12:28.959]     else {
[16:12:28.959]         if (TRUE) {
[16:12:28.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:28.959]                 open = "w")
[16:12:28.959]         }
[16:12:28.959]         else {
[16:12:28.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:28.959]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:28.959]         }
[16:12:28.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:28.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:28.959]             base::sink(type = "output", split = FALSE)
[16:12:28.959]             base::close(...future.stdout)
[16:12:28.959]         }, add = TRUE)
[16:12:28.959]     }
[16:12:28.959]     ...future.frame <- base::sys.nframe()
[16:12:28.959]     ...future.conditions <- base::list()
[16:12:28.959]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:28.959]     if (FALSE) {
[16:12:28.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:28.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:28.959]     }
[16:12:28.959]     ...future.result <- base::tryCatch({
[16:12:28.959]         base::withCallingHandlers({
[16:12:28.959]             ...future.value <- base::withVisible(base::local({
[16:12:28.959]                 withCallingHandlers({
[16:12:28.959]                   {
[16:12:28.959]                     4
[16:12:28.959]                   }
[16:12:28.959]                 }, immediateCondition = function(cond) {
[16:12:28.959]                   save_rds <- function (object, pathname, ...) 
[16:12:28.959]                   {
[16:12:28.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:28.959]                     if (file_test("-f", pathname_tmp)) {
[16:12:28.959]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:28.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.959]                         fi_tmp[["mtime"]])
[16:12:28.959]                     }
[16:12:28.959]                     tryCatch({
[16:12:28.959]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:28.959]                     }, error = function(ex) {
[16:12:28.959]                       msg <- conditionMessage(ex)
[16:12:28.959]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:28.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.959]                         fi_tmp[["mtime"]], msg)
[16:12:28.959]                       ex$message <- msg
[16:12:28.959]                       stop(ex)
[16:12:28.959]                     })
[16:12:28.959]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:28.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:28.959]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:28.959]                       fi_tmp <- file.info(pathname_tmp)
[16:12:28.959]                       fi <- file.info(pathname)
[16:12:28.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:28.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:28.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:28.959]                         fi[["size"]], fi[["mtime"]])
[16:12:28.959]                       stop(msg)
[16:12:28.959]                     }
[16:12:28.959]                     invisible(pathname)
[16:12:28.959]                   }
[16:12:28.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:28.959]                     rootPath = tempdir()) 
[16:12:28.959]                   {
[16:12:28.959]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:28.959]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:28.959]                       tmpdir = path, fileext = ".rds")
[16:12:28.959]                     save_rds(obj, file)
[16:12:28.959]                   }
[16:12:28.959]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:28.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.959]                   {
[16:12:28.959]                     inherits <- base::inherits
[16:12:28.959]                     invokeRestart <- base::invokeRestart
[16:12:28.959]                     is.null <- base::is.null
[16:12:28.959]                     muffled <- FALSE
[16:12:28.959]                     if (inherits(cond, "message")) {
[16:12:28.959]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:28.959]                       if (muffled) 
[16:12:28.959]                         invokeRestart("muffleMessage")
[16:12:28.959]                     }
[16:12:28.959]                     else if (inherits(cond, "warning")) {
[16:12:28.959]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:28.959]                       if (muffled) 
[16:12:28.959]                         invokeRestart("muffleWarning")
[16:12:28.959]                     }
[16:12:28.959]                     else if (inherits(cond, "condition")) {
[16:12:28.959]                       if (!is.null(pattern)) {
[16:12:28.959]                         computeRestarts <- base::computeRestarts
[16:12:28.959]                         grepl <- base::grepl
[16:12:28.959]                         restarts <- computeRestarts(cond)
[16:12:28.959]                         for (restart in restarts) {
[16:12:28.959]                           name <- restart$name
[16:12:28.959]                           if (is.null(name)) 
[16:12:28.959]                             next
[16:12:28.959]                           if (!grepl(pattern, name)) 
[16:12:28.959]                             next
[16:12:28.959]                           invokeRestart(restart)
[16:12:28.959]                           muffled <- TRUE
[16:12:28.959]                           break
[16:12:28.959]                         }
[16:12:28.959]                       }
[16:12:28.959]                     }
[16:12:28.959]                     invisible(muffled)
[16:12:28.959]                   }
[16:12:28.959]                   muffleCondition(cond)
[16:12:28.959]                 })
[16:12:28.959]             }))
[16:12:28.959]             future::FutureResult(value = ...future.value$value, 
[16:12:28.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.959]                   ...future.rng), globalenv = if (FALSE) 
[16:12:28.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:28.959]                     ...future.globalenv.names))
[16:12:28.959]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:28.959]         }, condition = base::local({
[16:12:28.959]             c <- base::c
[16:12:28.959]             inherits <- base::inherits
[16:12:28.959]             invokeRestart <- base::invokeRestart
[16:12:28.959]             length <- base::length
[16:12:28.959]             list <- base::list
[16:12:28.959]             seq.int <- base::seq.int
[16:12:28.959]             signalCondition <- base::signalCondition
[16:12:28.959]             sys.calls <- base::sys.calls
[16:12:28.959]             `[[` <- base::`[[`
[16:12:28.959]             `+` <- base::`+`
[16:12:28.959]             `<<-` <- base::`<<-`
[16:12:28.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:28.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:28.959]                   3L)]
[16:12:28.959]             }
[16:12:28.959]             function(cond) {
[16:12:28.959]                 is_error <- inherits(cond, "error")
[16:12:28.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:28.959]                   NULL)
[16:12:28.959]                 if (is_error) {
[16:12:28.959]                   sessionInformation <- function() {
[16:12:28.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:28.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:28.959]                       search = base::search(), system = base::Sys.info())
[16:12:28.959]                   }
[16:12:28.959]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:28.959]                     cond$call), session = sessionInformation(), 
[16:12:28.959]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:28.959]                   signalCondition(cond)
[16:12:28.959]                 }
[16:12:28.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:28.959]                 "immediateCondition"))) {
[16:12:28.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:28.959]                   ...future.conditions[[length(...future.conditions) + 
[16:12:28.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:28.959]                   if (TRUE && !signal) {
[16:12:28.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.959]                     {
[16:12:28.959]                       inherits <- base::inherits
[16:12:28.959]                       invokeRestart <- base::invokeRestart
[16:12:28.959]                       is.null <- base::is.null
[16:12:28.959]                       muffled <- FALSE
[16:12:28.959]                       if (inherits(cond, "message")) {
[16:12:28.959]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.959]                         if (muffled) 
[16:12:28.959]                           invokeRestart("muffleMessage")
[16:12:28.959]                       }
[16:12:28.959]                       else if (inherits(cond, "warning")) {
[16:12:28.959]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.959]                         if (muffled) 
[16:12:28.959]                           invokeRestart("muffleWarning")
[16:12:28.959]                       }
[16:12:28.959]                       else if (inherits(cond, "condition")) {
[16:12:28.959]                         if (!is.null(pattern)) {
[16:12:28.959]                           computeRestarts <- base::computeRestarts
[16:12:28.959]                           grepl <- base::grepl
[16:12:28.959]                           restarts <- computeRestarts(cond)
[16:12:28.959]                           for (restart in restarts) {
[16:12:28.959]                             name <- restart$name
[16:12:28.959]                             if (is.null(name)) 
[16:12:28.959]                               next
[16:12:28.959]                             if (!grepl(pattern, name)) 
[16:12:28.959]                               next
[16:12:28.959]                             invokeRestart(restart)
[16:12:28.959]                             muffled <- TRUE
[16:12:28.959]                             break
[16:12:28.959]                           }
[16:12:28.959]                         }
[16:12:28.959]                       }
[16:12:28.959]                       invisible(muffled)
[16:12:28.959]                     }
[16:12:28.959]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.959]                   }
[16:12:28.959]                 }
[16:12:28.959]                 else {
[16:12:28.959]                   if (TRUE) {
[16:12:28.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:28.959]                     {
[16:12:28.959]                       inherits <- base::inherits
[16:12:28.959]                       invokeRestart <- base::invokeRestart
[16:12:28.959]                       is.null <- base::is.null
[16:12:28.959]                       muffled <- FALSE
[16:12:28.959]                       if (inherits(cond, "message")) {
[16:12:28.959]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:28.959]                         if (muffled) 
[16:12:28.959]                           invokeRestart("muffleMessage")
[16:12:28.959]                       }
[16:12:28.959]                       else if (inherits(cond, "warning")) {
[16:12:28.959]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:28.959]                         if (muffled) 
[16:12:28.959]                           invokeRestart("muffleWarning")
[16:12:28.959]                       }
[16:12:28.959]                       else if (inherits(cond, "condition")) {
[16:12:28.959]                         if (!is.null(pattern)) {
[16:12:28.959]                           computeRestarts <- base::computeRestarts
[16:12:28.959]                           grepl <- base::grepl
[16:12:28.959]                           restarts <- computeRestarts(cond)
[16:12:28.959]                           for (restart in restarts) {
[16:12:28.959]                             name <- restart$name
[16:12:28.959]                             if (is.null(name)) 
[16:12:28.959]                               next
[16:12:28.959]                             if (!grepl(pattern, name)) 
[16:12:28.959]                               next
[16:12:28.959]                             invokeRestart(restart)
[16:12:28.959]                             muffled <- TRUE
[16:12:28.959]                             break
[16:12:28.959]                           }
[16:12:28.959]                         }
[16:12:28.959]                       }
[16:12:28.959]                       invisible(muffled)
[16:12:28.959]                     }
[16:12:28.959]                     muffleCondition(cond, pattern = "^muffle")
[16:12:28.959]                   }
[16:12:28.959]                 }
[16:12:28.959]             }
[16:12:28.959]         }))
[16:12:28.959]     }, error = function(ex) {
[16:12:28.959]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:28.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:28.959]                 ...future.rng), started = ...future.startTime, 
[16:12:28.959]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:28.959]             version = "1.8"), class = "FutureResult")
[16:12:28.959]     }, finally = {
[16:12:28.959]         if (!identical(...future.workdir, getwd())) 
[16:12:28.959]             setwd(...future.workdir)
[16:12:28.959]         {
[16:12:28.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:28.959]                 ...future.oldOptions$nwarnings <- NULL
[16:12:28.959]             }
[16:12:28.959]             base::options(...future.oldOptions)
[16:12:28.959]             if (.Platform$OS.type == "windows") {
[16:12:28.959]                 old_names <- names(...future.oldEnvVars)
[16:12:28.959]                 envs <- base::Sys.getenv()
[16:12:28.959]                 names <- names(envs)
[16:12:28.959]                 common <- intersect(names, old_names)
[16:12:28.959]                 added <- setdiff(names, old_names)
[16:12:28.959]                 removed <- setdiff(old_names, names)
[16:12:28.959]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:28.959]                   envs[common]]
[16:12:28.959]                 NAMES <- toupper(changed)
[16:12:28.959]                 args <- list()
[16:12:28.959]                 for (kk in seq_along(NAMES)) {
[16:12:28.959]                   name <- changed[[kk]]
[16:12:28.959]                   NAME <- NAMES[[kk]]
[16:12:28.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.959]                     next
[16:12:28.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.959]                 }
[16:12:28.959]                 NAMES <- toupper(added)
[16:12:28.959]                 for (kk in seq_along(NAMES)) {
[16:12:28.959]                   name <- added[[kk]]
[16:12:28.959]                   NAME <- NAMES[[kk]]
[16:12:28.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.959]                     next
[16:12:28.959]                   args[[name]] <- ""
[16:12:28.959]                 }
[16:12:28.959]                 NAMES <- toupper(removed)
[16:12:28.959]                 for (kk in seq_along(NAMES)) {
[16:12:28.959]                   name <- removed[[kk]]
[16:12:28.959]                   NAME <- NAMES[[kk]]
[16:12:28.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:28.959]                     next
[16:12:28.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:28.959]                 }
[16:12:28.959]                 if (length(args) > 0) 
[16:12:28.959]                   base::do.call(base::Sys.setenv, args = args)
[16:12:28.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:28.959]             }
[16:12:28.959]             else {
[16:12:28.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:28.959]             }
[16:12:28.959]             {
[16:12:28.959]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:28.959]                   0L) {
[16:12:28.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:28.959]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:28.959]                   base::options(opts)
[16:12:28.959]                 }
[16:12:28.959]                 {
[16:12:28.959]                   {
[16:12:28.959]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:28.959]                     NULL
[16:12:28.959]                   }
[16:12:28.959]                   options(future.plan = NULL)
[16:12:28.959]                   if (is.na(NA_character_)) 
[16:12:28.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:28.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:28.959]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:28.959]                     envir = parent.frame()) 
[16:12:28.959]                   {
[16:12:28.959]                     default_workers <- missing(workers)
[16:12:28.959]                     if (is.function(workers)) 
[16:12:28.959]                       workers <- workers()
[16:12:28.959]                     workers <- structure(as.integer(workers), 
[16:12:28.959]                       class = class(workers))
[16:12:28.959]                     stop_if_not(is.finite(workers), workers >= 
[16:12:28.959]                       1L)
[16:12:28.959]                     if ((workers == 1L && !inherits(workers, 
[16:12:28.959]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:28.959]                       if (default_workers) 
[16:12:28.959]                         supportsMulticore(warn = TRUE)
[16:12:28.959]                       return(sequential(..., envir = envir))
[16:12:28.959]                     }
[16:12:28.959]                     oopts <- options(mc.cores = workers)
[16:12:28.959]                     on.exit(options(oopts))
[16:12:28.959]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:28.959]                       envir = envir)
[16:12:28.959]                     if (!future$lazy) 
[16:12:28.959]                       future <- run(future)
[16:12:28.959]                     invisible(future)
[16:12:28.959]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:28.959]                 }
[16:12:28.959]             }
[16:12:28.959]         }
[16:12:28.959]     })
[16:12:28.959]     if (TRUE) {
[16:12:28.959]         base::sink(type = "output", split = FALSE)
[16:12:28.959]         if (TRUE) {
[16:12:28.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:28.959]         }
[16:12:28.959]         else {
[16:12:28.959]             ...future.result["stdout"] <- base::list(NULL)
[16:12:28.959]         }
[16:12:28.959]         base::close(...future.stdout)
[16:12:28.959]         ...future.stdout <- NULL
[16:12:28.959]     }
[16:12:28.959]     ...future.result$conditions <- ...future.conditions
[16:12:28.959]     ...future.result$finished <- base::Sys.time()
[16:12:28.959]     ...future.result
[16:12:28.959] }
[16:12:28.962] requestCore(): workers = 2
[16:12:28.962] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:28.976] MulticoreFuture started
[16:12:28.977] - Launch lazy future ... done
[16:12:28.977] run() for ‘MulticoreFuture’ ... done
[16:12:28.978] plan(): Setting new future strategy stack:
<environment: 0x560bad842f20> 
[16:12:28.978] List of future strategies:
[16:12:28.978] 1. sequential:
[16:12:28.978]    - args: function (..., envir = parent.frame())
[16:12:28.978]    - tweaked: FALSE
[16:12:28.978]    - call: NULL
[16:12:28.979] plan(): nbrOfWorkers() = 1
<environment: 0x560bb00f3020> 
[16:12:28.982] plan(): Setting new future strategy stack:
[16:12:28.982] List of future strategies:
[16:12:28.982] 1. multicore:
[16:12:28.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:28.982]    - tweaked: FALSE
[16:12:28.982]    - call: plan(strategy)
[16:12:28.987] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:28.989] resolve() on environment ...
[16:12:28.989]  recursive: 0
[16:12:28.990]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:28.990] signalConditionsASAP(numeric, pos=1) ...
[16:12:28.990] - nx: 4
[16:12:28.990] - relay: TRUE
[16:12:28.990] - stdout: TRUE
[16:12:28.991] - signal: TRUE
[16:12:28.991] - resignal: FALSE
[16:12:28.991] - force: TRUE
[16:12:28.991] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.991] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.991]  - until=2
[16:12:28.991]  - relaying element #2
[16:12:28.992] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.992] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.992] signalConditionsASAP(NULL, pos=1) ... done
[16:12:28.992]  length: 3 (resolved future 1)
[16:12:28.992] Future #2
[16:12:28.992] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:28.993] - nx: 4
[16:12:28.993] - relay: TRUE
[16:12:28.993] - stdout: TRUE
[16:12:28.993] - signal: TRUE
[16:12:28.993] - resignal: FALSE
[16:12:28.993] - force: TRUE
[16:12:28.993] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:28.993] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:28.993]  - until=2
[16:12:28.994]  - relaying element #2
[16:12:28.994] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.994] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.994] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:28.994]  length: 2 (resolved future 2)
[16:12:28.995] Future #3
[16:12:28.996] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:28.996] - nx: 4
[16:12:28.996] - relay: TRUE
[16:12:28.996] - stdout: TRUE
[16:12:28.996] - signal: TRUE
[16:12:28.996] - resignal: FALSE
[16:12:28.996] - force: TRUE
[16:12:28.996] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:28.997] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:28.997]  - until=3
[16:12:28.997]  - relaying element #3
[16:12:28.997] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:28.997] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:28.997] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:28.997]  length: 1 (resolved future 3)
[16:12:28.998] Future #4
[16:12:28.999] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:28.999] - nx: 4
[16:12:28.999] - relay: TRUE
[16:12:28.999] - stdout: TRUE
[16:12:28.999] - signal: TRUE
[16:12:28.999] - resignal: FALSE
[16:12:29.000] - force: TRUE
[16:12:29.000] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.000] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.000]  - until=4
[16:12:29.000]  - relaying element #4
[16:12:29.001] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.001] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.001] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:29.001]  length: 0 (resolved future 4)
[16:12:29.001] Relaying remaining futures
[16:12:29.001] signalConditionsASAP(NULL, pos=0) ...
[16:12:29.002] - nx: 4
[16:12:29.002] - relay: TRUE
[16:12:29.002] - stdout: TRUE
[16:12:29.002] - signal: TRUE
[16:12:29.002] - resignal: FALSE
[16:12:29.002] - force: TRUE
[16:12:29.002] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.002] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:29.002] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.003] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.003] signalConditionsASAP(NULL, pos=0) ... done
[16:12:29.003] resolve() on environment ... DONE
<environment: 0x560bb01ae640> 
Dimensions: c(2, 1, 3, 1)
[16:12:29.003] getGlobalsAndPackages() ...
[16:12:29.003] Searching for globals...
[16:12:29.004] 
[16:12:29.004] Searching for globals ... DONE
[16:12:29.004] - globals: [0] <none>
[16:12:29.004] getGlobalsAndPackages() ... DONE
[16:12:29.005] run() for ‘Future’ ...
[16:12:29.005] - state: ‘created’
[16:12:29.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.009] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.009] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:29.009]   - Field: ‘label’
[16:12:29.009]   - Field: ‘local’
[16:12:29.009]   - Field: ‘owner’
[16:12:29.009]   - Field: ‘envir’
[16:12:29.010]   - Field: ‘workers’
[16:12:29.010]   - Field: ‘packages’
[16:12:29.010]   - Field: ‘gc’
[16:12:29.010]   - Field: ‘job’
[16:12:29.010]   - Field: ‘conditions’
[16:12:29.010]   - Field: ‘expr’
[16:12:29.010]   - Field: ‘uuid’
[16:12:29.010]   - Field: ‘seed’
[16:12:29.010]   - Field: ‘version’
[16:12:29.011]   - Field: ‘result’
[16:12:29.011]   - Field: ‘asynchronous’
[16:12:29.011]   - Field: ‘calls’
[16:12:29.011]   - Field: ‘globals’
[16:12:29.011]   - Field: ‘stdout’
[16:12:29.011]   - Field: ‘earlySignal’
[16:12:29.011]   - Field: ‘lazy’
[16:12:29.011]   - Field: ‘state’
[16:12:29.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:29.012] - Launch lazy future ...
[16:12:29.012] Packages needed by the future expression (n = 0): <none>
[16:12:29.012] Packages needed by future strategies (n = 0): <none>
[16:12:29.013] {
[16:12:29.013]     {
[16:12:29.013]         {
[16:12:29.013]             ...future.startTime <- base::Sys.time()
[16:12:29.013]             {
[16:12:29.013]                 {
[16:12:29.013]                   {
[16:12:29.013]                     {
[16:12:29.013]                       base::local({
[16:12:29.013]                         has_future <- base::requireNamespace("future", 
[16:12:29.013]                           quietly = TRUE)
[16:12:29.013]                         if (has_future) {
[16:12:29.013]                           ns <- base::getNamespace("future")
[16:12:29.013]                           version <- ns[[".package"]][["version"]]
[16:12:29.013]                           if (is.null(version)) 
[16:12:29.013]                             version <- utils::packageVersion("future")
[16:12:29.013]                         }
[16:12:29.013]                         else {
[16:12:29.013]                           version <- NULL
[16:12:29.013]                         }
[16:12:29.013]                         if (!has_future || version < "1.8.0") {
[16:12:29.013]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.013]                             "", base::R.version$version.string), 
[16:12:29.013]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.013]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.013]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.013]                               "release", "version")], collapse = " "), 
[16:12:29.013]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.013]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.013]                             info)
[16:12:29.013]                           info <- base::paste(info, collapse = "; ")
[16:12:29.013]                           if (!has_future) {
[16:12:29.013]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.013]                               info)
[16:12:29.013]                           }
[16:12:29.013]                           else {
[16:12:29.013]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.013]                               info, version)
[16:12:29.013]                           }
[16:12:29.013]                           base::stop(msg)
[16:12:29.013]                         }
[16:12:29.013]                       })
[16:12:29.013]                     }
[16:12:29.013]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.013]                     base::options(mc.cores = 1L)
[16:12:29.013]                   }
[16:12:29.013]                   options(future.plan = NULL)
[16:12:29.013]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.013]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.013]                 }
[16:12:29.013]                 ...future.workdir <- getwd()
[16:12:29.013]             }
[16:12:29.013]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.013]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.013]         }
[16:12:29.013]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.013]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.013]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.013]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.013]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.013]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.013]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.013]             base::names(...future.oldOptions))
[16:12:29.013]     }
[16:12:29.013]     if (FALSE) {
[16:12:29.013]     }
[16:12:29.013]     else {
[16:12:29.013]         if (TRUE) {
[16:12:29.013]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.013]                 open = "w")
[16:12:29.013]         }
[16:12:29.013]         else {
[16:12:29.013]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.013]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.013]         }
[16:12:29.013]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.013]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.013]             base::sink(type = "output", split = FALSE)
[16:12:29.013]             base::close(...future.stdout)
[16:12:29.013]         }, add = TRUE)
[16:12:29.013]     }
[16:12:29.013]     ...future.frame <- base::sys.nframe()
[16:12:29.013]     ...future.conditions <- base::list()
[16:12:29.013]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.013]     if (FALSE) {
[16:12:29.013]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.013]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.013]     }
[16:12:29.013]     ...future.result <- base::tryCatch({
[16:12:29.013]         base::withCallingHandlers({
[16:12:29.013]             ...future.value <- base::withVisible(base::local({
[16:12:29.013]                 withCallingHandlers({
[16:12:29.013]                   2
[16:12:29.013]                 }, immediateCondition = function(cond) {
[16:12:29.013]                   save_rds <- function (object, pathname, ...) 
[16:12:29.013]                   {
[16:12:29.013]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:29.013]                     if (file_test("-f", pathname_tmp)) {
[16:12:29.013]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.013]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:29.013]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.013]                         fi_tmp[["mtime"]])
[16:12:29.013]                     }
[16:12:29.013]                     tryCatch({
[16:12:29.013]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:29.013]                     }, error = function(ex) {
[16:12:29.013]                       msg <- conditionMessage(ex)
[16:12:29.013]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.013]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:29.013]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.013]                         fi_tmp[["mtime"]], msg)
[16:12:29.013]                       ex$message <- msg
[16:12:29.013]                       stop(ex)
[16:12:29.013]                     })
[16:12:29.013]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:29.013]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:29.013]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:29.013]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.013]                       fi <- file.info(pathname)
[16:12:29.013]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:29.013]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.013]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:29.013]                         fi[["size"]], fi[["mtime"]])
[16:12:29.013]                       stop(msg)
[16:12:29.013]                     }
[16:12:29.013]                     invisible(pathname)
[16:12:29.013]                   }
[16:12:29.013]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:29.013]                     rootPath = tempdir()) 
[16:12:29.013]                   {
[16:12:29.013]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:29.013]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:29.013]                       tmpdir = path, fileext = ".rds")
[16:12:29.013]                     save_rds(obj, file)
[16:12:29.013]                   }
[16:12:29.013]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:29.013]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.013]                   {
[16:12:29.013]                     inherits <- base::inherits
[16:12:29.013]                     invokeRestart <- base::invokeRestart
[16:12:29.013]                     is.null <- base::is.null
[16:12:29.013]                     muffled <- FALSE
[16:12:29.013]                     if (inherits(cond, "message")) {
[16:12:29.013]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.013]                       if (muffled) 
[16:12:29.013]                         invokeRestart("muffleMessage")
[16:12:29.013]                     }
[16:12:29.013]                     else if (inherits(cond, "warning")) {
[16:12:29.013]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.013]                       if (muffled) 
[16:12:29.013]                         invokeRestart("muffleWarning")
[16:12:29.013]                     }
[16:12:29.013]                     else if (inherits(cond, "condition")) {
[16:12:29.013]                       if (!is.null(pattern)) {
[16:12:29.013]                         computeRestarts <- base::computeRestarts
[16:12:29.013]                         grepl <- base::grepl
[16:12:29.013]                         restarts <- computeRestarts(cond)
[16:12:29.013]                         for (restart in restarts) {
[16:12:29.013]                           name <- restart$name
[16:12:29.013]                           if (is.null(name)) 
[16:12:29.013]                             next
[16:12:29.013]                           if (!grepl(pattern, name)) 
[16:12:29.013]                             next
[16:12:29.013]                           invokeRestart(restart)
[16:12:29.013]                           muffled <- TRUE
[16:12:29.013]                           break
[16:12:29.013]                         }
[16:12:29.013]                       }
[16:12:29.013]                     }
[16:12:29.013]                     invisible(muffled)
[16:12:29.013]                   }
[16:12:29.013]                   muffleCondition(cond)
[16:12:29.013]                 })
[16:12:29.013]             }))
[16:12:29.013]             future::FutureResult(value = ...future.value$value, 
[16:12:29.013]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.013]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.013]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.013]                     ...future.globalenv.names))
[16:12:29.013]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.013]         }, condition = base::local({
[16:12:29.013]             c <- base::c
[16:12:29.013]             inherits <- base::inherits
[16:12:29.013]             invokeRestart <- base::invokeRestart
[16:12:29.013]             length <- base::length
[16:12:29.013]             list <- base::list
[16:12:29.013]             seq.int <- base::seq.int
[16:12:29.013]             signalCondition <- base::signalCondition
[16:12:29.013]             sys.calls <- base::sys.calls
[16:12:29.013]             `[[` <- base::`[[`
[16:12:29.013]             `+` <- base::`+`
[16:12:29.013]             `<<-` <- base::`<<-`
[16:12:29.013]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.013]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.013]                   3L)]
[16:12:29.013]             }
[16:12:29.013]             function(cond) {
[16:12:29.013]                 is_error <- inherits(cond, "error")
[16:12:29.013]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.013]                   NULL)
[16:12:29.013]                 if (is_error) {
[16:12:29.013]                   sessionInformation <- function() {
[16:12:29.013]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.013]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.013]                       search = base::search(), system = base::Sys.info())
[16:12:29.013]                   }
[16:12:29.013]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.013]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.013]                     cond$call), session = sessionInformation(), 
[16:12:29.013]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.013]                   signalCondition(cond)
[16:12:29.013]                 }
[16:12:29.013]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.013]                 "immediateCondition"))) {
[16:12:29.013]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.013]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.013]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.013]                   if (TRUE && !signal) {
[16:12:29.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.013]                     {
[16:12:29.013]                       inherits <- base::inherits
[16:12:29.013]                       invokeRestart <- base::invokeRestart
[16:12:29.013]                       is.null <- base::is.null
[16:12:29.013]                       muffled <- FALSE
[16:12:29.013]                       if (inherits(cond, "message")) {
[16:12:29.013]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.013]                         if (muffled) 
[16:12:29.013]                           invokeRestart("muffleMessage")
[16:12:29.013]                       }
[16:12:29.013]                       else if (inherits(cond, "warning")) {
[16:12:29.013]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.013]                         if (muffled) 
[16:12:29.013]                           invokeRestart("muffleWarning")
[16:12:29.013]                       }
[16:12:29.013]                       else if (inherits(cond, "condition")) {
[16:12:29.013]                         if (!is.null(pattern)) {
[16:12:29.013]                           computeRestarts <- base::computeRestarts
[16:12:29.013]                           grepl <- base::grepl
[16:12:29.013]                           restarts <- computeRestarts(cond)
[16:12:29.013]                           for (restart in restarts) {
[16:12:29.013]                             name <- restart$name
[16:12:29.013]                             if (is.null(name)) 
[16:12:29.013]                               next
[16:12:29.013]                             if (!grepl(pattern, name)) 
[16:12:29.013]                               next
[16:12:29.013]                             invokeRestart(restart)
[16:12:29.013]                             muffled <- TRUE
[16:12:29.013]                             break
[16:12:29.013]                           }
[16:12:29.013]                         }
[16:12:29.013]                       }
[16:12:29.013]                       invisible(muffled)
[16:12:29.013]                     }
[16:12:29.013]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.013]                   }
[16:12:29.013]                 }
[16:12:29.013]                 else {
[16:12:29.013]                   if (TRUE) {
[16:12:29.013]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.013]                     {
[16:12:29.013]                       inherits <- base::inherits
[16:12:29.013]                       invokeRestart <- base::invokeRestart
[16:12:29.013]                       is.null <- base::is.null
[16:12:29.013]                       muffled <- FALSE
[16:12:29.013]                       if (inherits(cond, "message")) {
[16:12:29.013]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.013]                         if (muffled) 
[16:12:29.013]                           invokeRestart("muffleMessage")
[16:12:29.013]                       }
[16:12:29.013]                       else if (inherits(cond, "warning")) {
[16:12:29.013]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.013]                         if (muffled) 
[16:12:29.013]                           invokeRestart("muffleWarning")
[16:12:29.013]                       }
[16:12:29.013]                       else if (inherits(cond, "condition")) {
[16:12:29.013]                         if (!is.null(pattern)) {
[16:12:29.013]                           computeRestarts <- base::computeRestarts
[16:12:29.013]                           grepl <- base::grepl
[16:12:29.013]                           restarts <- computeRestarts(cond)
[16:12:29.013]                           for (restart in restarts) {
[16:12:29.013]                             name <- restart$name
[16:12:29.013]                             if (is.null(name)) 
[16:12:29.013]                               next
[16:12:29.013]                             if (!grepl(pattern, name)) 
[16:12:29.013]                               next
[16:12:29.013]                             invokeRestart(restart)
[16:12:29.013]                             muffled <- TRUE
[16:12:29.013]                             break
[16:12:29.013]                           }
[16:12:29.013]                         }
[16:12:29.013]                       }
[16:12:29.013]                       invisible(muffled)
[16:12:29.013]                     }
[16:12:29.013]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.013]                   }
[16:12:29.013]                 }
[16:12:29.013]             }
[16:12:29.013]         }))
[16:12:29.013]     }, error = function(ex) {
[16:12:29.013]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.013]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.013]                 ...future.rng), started = ...future.startTime, 
[16:12:29.013]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.013]             version = "1.8"), class = "FutureResult")
[16:12:29.013]     }, finally = {
[16:12:29.013]         if (!identical(...future.workdir, getwd())) 
[16:12:29.013]             setwd(...future.workdir)
[16:12:29.013]         {
[16:12:29.013]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.013]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.013]             }
[16:12:29.013]             base::options(...future.oldOptions)
[16:12:29.013]             if (.Platform$OS.type == "windows") {
[16:12:29.013]                 old_names <- names(...future.oldEnvVars)
[16:12:29.013]                 envs <- base::Sys.getenv()
[16:12:29.013]                 names <- names(envs)
[16:12:29.013]                 common <- intersect(names, old_names)
[16:12:29.013]                 added <- setdiff(names, old_names)
[16:12:29.013]                 removed <- setdiff(old_names, names)
[16:12:29.013]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.013]                   envs[common]]
[16:12:29.013]                 NAMES <- toupper(changed)
[16:12:29.013]                 args <- list()
[16:12:29.013]                 for (kk in seq_along(NAMES)) {
[16:12:29.013]                   name <- changed[[kk]]
[16:12:29.013]                   NAME <- NAMES[[kk]]
[16:12:29.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.013]                     next
[16:12:29.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.013]                 }
[16:12:29.013]                 NAMES <- toupper(added)
[16:12:29.013]                 for (kk in seq_along(NAMES)) {
[16:12:29.013]                   name <- added[[kk]]
[16:12:29.013]                   NAME <- NAMES[[kk]]
[16:12:29.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.013]                     next
[16:12:29.013]                   args[[name]] <- ""
[16:12:29.013]                 }
[16:12:29.013]                 NAMES <- toupper(removed)
[16:12:29.013]                 for (kk in seq_along(NAMES)) {
[16:12:29.013]                   name <- removed[[kk]]
[16:12:29.013]                   NAME <- NAMES[[kk]]
[16:12:29.013]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.013]                     next
[16:12:29.013]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.013]                 }
[16:12:29.013]                 if (length(args) > 0) 
[16:12:29.013]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.013]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.013]             }
[16:12:29.013]             else {
[16:12:29.013]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.013]             }
[16:12:29.013]             {
[16:12:29.013]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.013]                   0L) {
[16:12:29.013]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.013]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.013]                   base::options(opts)
[16:12:29.013]                 }
[16:12:29.013]                 {
[16:12:29.013]                   {
[16:12:29.013]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.013]                     NULL
[16:12:29.013]                   }
[16:12:29.013]                   options(future.plan = NULL)
[16:12:29.013]                   if (is.na(NA_character_)) 
[16:12:29.013]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.013]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.013]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:29.013]                     envir = parent.frame()) 
[16:12:29.013]                   {
[16:12:29.013]                     default_workers <- missing(workers)
[16:12:29.013]                     if (is.function(workers)) 
[16:12:29.013]                       workers <- workers()
[16:12:29.013]                     workers <- structure(as.integer(workers), 
[16:12:29.013]                       class = class(workers))
[16:12:29.013]                     stop_if_not(is.finite(workers), workers >= 
[16:12:29.013]                       1L)
[16:12:29.013]                     if ((workers == 1L && !inherits(workers, 
[16:12:29.013]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:29.013]                       if (default_workers) 
[16:12:29.013]                         supportsMulticore(warn = TRUE)
[16:12:29.013]                       return(sequential(..., envir = envir))
[16:12:29.013]                     }
[16:12:29.013]                     oopts <- options(mc.cores = workers)
[16:12:29.013]                     on.exit(options(oopts))
[16:12:29.013]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:29.013]                       envir = envir)
[16:12:29.013]                     if (!future$lazy) 
[16:12:29.013]                       future <- run(future)
[16:12:29.013]                     invisible(future)
[16:12:29.013]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.013]                 }
[16:12:29.013]             }
[16:12:29.013]         }
[16:12:29.013]     })
[16:12:29.013]     if (TRUE) {
[16:12:29.013]         base::sink(type = "output", split = FALSE)
[16:12:29.013]         if (TRUE) {
[16:12:29.013]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.013]         }
[16:12:29.013]         else {
[16:12:29.013]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.013]         }
[16:12:29.013]         base::close(...future.stdout)
[16:12:29.013]         ...future.stdout <- NULL
[16:12:29.013]     }
[16:12:29.013]     ...future.result$conditions <- ...future.conditions
[16:12:29.013]     ...future.result$finished <- base::Sys.time()
[16:12:29.013]     ...future.result
[16:12:29.013] }
[16:12:29.015] requestCore(): workers = 2
[16:12:29.017] MulticoreFuture started
[16:12:29.018] - Launch lazy future ... done
[16:12:29.018] run() for ‘MulticoreFuture’ ... done
[16:12:29.018] getGlobalsAndPackages() ...
[16:12:29.018] Searching for globals...
[16:12:29.018] plan(): Setting new future strategy stack:
[16:12:29.018] List of future strategies:
[16:12:29.018] 1. sequential:
[16:12:29.018]    - args: function (..., envir = parent.frame())
[16:12:29.018]    - tweaked: FALSE
[16:12:29.018]    - call: NULL
[16:12:29.019] 
[16:12:29.019] Searching for globals ... DONE
[16:12:29.019] - globals: [0] <none>
[16:12:29.019] plan(): nbrOfWorkers() = 1
[16:12:29.019] getGlobalsAndPackages() ... DONE
[16:12:29.020] run() for ‘Future’ ...
[16:12:29.020] - state: ‘created’
[16:12:29.020] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.021] plan(): Setting new future strategy stack:
[16:12:29.021] List of future strategies:
[16:12:29.021] 1. multicore:
[16:12:29.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:29.021]    - tweaked: FALSE
[16:12:29.021]    - call: plan(strategy)
[16:12:29.025] plan(): nbrOfWorkers() = 2
[16:12:29.025] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:29.026]   - Field: ‘label’
[16:12:29.026]   - Field: ‘local’
[16:12:29.026]   - Field: ‘owner’
[16:12:29.026]   - Field: ‘envir’
[16:12:29.026]   - Field: ‘workers’
[16:12:29.026]   - Field: ‘packages’
[16:12:29.026]   - Field: ‘gc’
[16:12:29.027]   - Field: ‘job’
[16:12:29.027]   - Field: ‘conditions’
[16:12:29.027]   - Field: ‘expr’
[16:12:29.027]   - Field: ‘uuid’
[16:12:29.027]   - Field: ‘seed’
[16:12:29.027]   - Field: ‘version’
[16:12:29.027]   - Field: ‘result’
[16:12:29.028]   - Field: ‘asynchronous’
[16:12:29.028]   - Field: ‘calls’
[16:12:29.028]   - Field: ‘globals’
[16:12:29.028]   - Field: ‘stdout’
[16:12:29.028]   - Field: ‘earlySignal’
[16:12:29.028]   - Field: ‘lazy’
[16:12:29.028]   - Field: ‘state’
[16:12:29.029] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:29.029] - Launch lazy future ...
[16:12:29.029] Packages needed by the future expression (n = 0): <none>
[16:12:29.029] Packages needed by future strategies (n = 0): <none>
[16:12:29.030] {
[16:12:29.030]     {
[16:12:29.030]         {
[16:12:29.030]             ...future.startTime <- base::Sys.time()
[16:12:29.030]             {
[16:12:29.030]                 {
[16:12:29.030]                   {
[16:12:29.030]                     {
[16:12:29.030]                       base::local({
[16:12:29.030]                         has_future <- base::requireNamespace("future", 
[16:12:29.030]                           quietly = TRUE)
[16:12:29.030]                         if (has_future) {
[16:12:29.030]                           ns <- base::getNamespace("future")
[16:12:29.030]                           version <- ns[[".package"]][["version"]]
[16:12:29.030]                           if (is.null(version)) 
[16:12:29.030]                             version <- utils::packageVersion("future")
[16:12:29.030]                         }
[16:12:29.030]                         else {
[16:12:29.030]                           version <- NULL
[16:12:29.030]                         }
[16:12:29.030]                         if (!has_future || version < "1.8.0") {
[16:12:29.030]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.030]                             "", base::R.version$version.string), 
[16:12:29.030]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.030]                               "release", "version")], collapse = " "), 
[16:12:29.030]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.030]                             info)
[16:12:29.030]                           info <- base::paste(info, collapse = "; ")
[16:12:29.030]                           if (!has_future) {
[16:12:29.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.030]                               info)
[16:12:29.030]                           }
[16:12:29.030]                           else {
[16:12:29.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.030]                               info, version)
[16:12:29.030]                           }
[16:12:29.030]                           base::stop(msg)
[16:12:29.030]                         }
[16:12:29.030]                       })
[16:12:29.030]                     }
[16:12:29.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.030]                     base::options(mc.cores = 1L)
[16:12:29.030]                   }
[16:12:29.030]                   options(future.plan = NULL)
[16:12:29.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.030]                 }
[16:12:29.030]                 ...future.workdir <- getwd()
[16:12:29.030]             }
[16:12:29.030]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.030]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.030]         }
[16:12:29.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.030]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.030]             base::names(...future.oldOptions))
[16:12:29.030]     }
[16:12:29.030]     if (FALSE) {
[16:12:29.030]     }
[16:12:29.030]     else {
[16:12:29.030]         if (TRUE) {
[16:12:29.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.030]                 open = "w")
[16:12:29.030]         }
[16:12:29.030]         else {
[16:12:29.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.030]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.030]         }
[16:12:29.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.030]             base::sink(type = "output", split = FALSE)
[16:12:29.030]             base::close(...future.stdout)
[16:12:29.030]         }, add = TRUE)
[16:12:29.030]     }
[16:12:29.030]     ...future.frame <- base::sys.nframe()
[16:12:29.030]     ...future.conditions <- base::list()
[16:12:29.030]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.030]     if (FALSE) {
[16:12:29.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.030]     }
[16:12:29.030]     ...future.result <- base::tryCatch({
[16:12:29.030]         base::withCallingHandlers({
[16:12:29.030]             ...future.value <- base::withVisible(base::local({
[16:12:29.030]                 withCallingHandlers({
[16:12:29.030]                   NULL
[16:12:29.030]                 }, immediateCondition = function(cond) {
[16:12:29.030]                   save_rds <- function (object, pathname, ...) 
[16:12:29.030]                   {
[16:12:29.030]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:29.030]                     if (file_test("-f", pathname_tmp)) {
[16:12:29.030]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.030]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:29.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.030]                         fi_tmp[["mtime"]])
[16:12:29.030]                     }
[16:12:29.030]                     tryCatch({
[16:12:29.030]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:29.030]                     }, error = function(ex) {
[16:12:29.030]                       msg <- conditionMessage(ex)
[16:12:29.030]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.030]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:29.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.030]                         fi_tmp[["mtime"]], msg)
[16:12:29.030]                       ex$message <- msg
[16:12:29.030]                       stop(ex)
[16:12:29.030]                     })
[16:12:29.030]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:29.030]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:29.030]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:29.030]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.030]                       fi <- file.info(pathname)
[16:12:29.030]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:29.030]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.030]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:29.030]                         fi[["size"]], fi[["mtime"]])
[16:12:29.030]                       stop(msg)
[16:12:29.030]                     }
[16:12:29.030]                     invisible(pathname)
[16:12:29.030]                   }
[16:12:29.030]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:29.030]                     rootPath = tempdir()) 
[16:12:29.030]                   {
[16:12:29.030]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:29.030]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:29.030]                       tmpdir = path, fileext = ".rds")
[16:12:29.030]                     save_rds(obj, file)
[16:12:29.030]                   }
[16:12:29.030]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:29.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.030]                   {
[16:12:29.030]                     inherits <- base::inherits
[16:12:29.030]                     invokeRestart <- base::invokeRestart
[16:12:29.030]                     is.null <- base::is.null
[16:12:29.030]                     muffled <- FALSE
[16:12:29.030]                     if (inherits(cond, "message")) {
[16:12:29.030]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.030]                       if (muffled) 
[16:12:29.030]                         invokeRestart("muffleMessage")
[16:12:29.030]                     }
[16:12:29.030]                     else if (inherits(cond, "warning")) {
[16:12:29.030]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.030]                       if (muffled) 
[16:12:29.030]                         invokeRestart("muffleWarning")
[16:12:29.030]                     }
[16:12:29.030]                     else if (inherits(cond, "condition")) {
[16:12:29.030]                       if (!is.null(pattern)) {
[16:12:29.030]                         computeRestarts <- base::computeRestarts
[16:12:29.030]                         grepl <- base::grepl
[16:12:29.030]                         restarts <- computeRestarts(cond)
[16:12:29.030]                         for (restart in restarts) {
[16:12:29.030]                           name <- restart$name
[16:12:29.030]                           if (is.null(name)) 
[16:12:29.030]                             next
[16:12:29.030]                           if (!grepl(pattern, name)) 
[16:12:29.030]                             next
[16:12:29.030]                           invokeRestart(restart)
[16:12:29.030]                           muffled <- TRUE
[16:12:29.030]                           break
[16:12:29.030]                         }
[16:12:29.030]                       }
[16:12:29.030]                     }
[16:12:29.030]                     invisible(muffled)
[16:12:29.030]                   }
[16:12:29.030]                   muffleCondition(cond)
[16:12:29.030]                 })
[16:12:29.030]             }))
[16:12:29.030]             future::FutureResult(value = ...future.value$value, 
[16:12:29.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.030]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.030]                     ...future.globalenv.names))
[16:12:29.030]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.030]         }, condition = base::local({
[16:12:29.030]             c <- base::c
[16:12:29.030]             inherits <- base::inherits
[16:12:29.030]             invokeRestart <- base::invokeRestart
[16:12:29.030]             length <- base::length
[16:12:29.030]             list <- base::list
[16:12:29.030]             seq.int <- base::seq.int
[16:12:29.030]             signalCondition <- base::signalCondition
[16:12:29.030]             sys.calls <- base::sys.calls
[16:12:29.030]             `[[` <- base::`[[`
[16:12:29.030]             `+` <- base::`+`
[16:12:29.030]             `<<-` <- base::`<<-`
[16:12:29.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.030]                   3L)]
[16:12:29.030]             }
[16:12:29.030]             function(cond) {
[16:12:29.030]                 is_error <- inherits(cond, "error")
[16:12:29.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.030]                   NULL)
[16:12:29.030]                 if (is_error) {
[16:12:29.030]                   sessionInformation <- function() {
[16:12:29.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.030]                       search = base::search(), system = base::Sys.info())
[16:12:29.030]                   }
[16:12:29.030]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.030]                     cond$call), session = sessionInformation(), 
[16:12:29.030]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.030]                   signalCondition(cond)
[16:12:29.030]                 }
[16:12:29.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.030]                 "immediateCondition"))) {
[16:12:29.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.030]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.030]                   if (TRUE && !signal) {
[16:12:29.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.030]                     {
[16:12:29.030]                       inherits <- base::inherits
[16:12:29.030]                       invokeRestart <- base::invokeRestart
[16:12:29.030]                       is.null <- base::is.null
[16:12:29.030]                       muffled <- FALSE
[16:12:29.030]                       if (inherits(cond, "message")) {
[16:12:29.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.030]                         if (muffled) 
[16:12:29.030]                           invokeRestart("muffleMessage")
[16:12:29.030]                       }
[16:12:29.030]                       else if (inherits(cond, "warning")) {
[16:12:29.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.030]                         if (muffled) 
[16:12:29.030]                           invokeRestart("muffleWarning")
[16:12:29.030]                       }
[16:12:29.030]                       else if (inherits(cond, "condition")) {
[16:12:29.030]                         if (!is.null(pattern)) {
[16:12:29.030]                           computeRestarts <- base::computeRestarts
[16:12:29.030]                           grepl <- base::grepl
[16:12:29.030]                           restarts <- computeRestarts(cond)
[16:12:29.030]                           for (restart in restarts) {
[16:12:29.030]                             name <- restart$name
[16:12:29.030]                             if (is.null(name)) 
[16:12:29.030]                               next
[16:12:29.030]                             if (!grepl(pattern, name)) 
[16:12:29.030]                               next
[16:12:29.030]                             invokeRestart(restart)
[16:12:29.030]                             muffled <- TRUE
[16:12:29.030]                             break
[16:12:29.030]                           }
[16:12:29.030]                         }
[16:12:29.030]                       }
[16:12:29.030]                       invisible(muffled)
[16:12:29.030]                     }
[16:12:29.030]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.030]                   }
[16:12:29.030]                 }
[16:12:29.030]                 else {
[16:12:29.030]                   if (TRUE) {
[16:12:29.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.030]                     {
[16:12:29.030]                       inherits <- base::inherits
[16:12:29.030]                       invokeRestart <- base::invokeRestart
[16:12:29.030]                       is.null <- base::is.null
[16:12:29.030]                       muffled <- FALSE
[16:12:29.030]                       if (inherits(cond, "message")) {
[16:12:29.030]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.030]                         if (muffled) 
[16:12:29.030]                           invokeRestart("muffleMessage")
[16:12:29.030]                       }
[16:12:29.030]                       else if (inherits(cond, "warning")) {
[16:12:29.030]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.030]                         if (muffled) 
[16:12:29.030]                           invokeRestart("muffleWarning")
[16:12:29.030]                       }
[16:12:29.030]                       else if (inherits(cond, "condition")) {
[16:12:29.030]                         if (!is.null(pattern)) {
[16:12:29.030]                           computeRestarts <- base::computeRestarts
[16:12:29.030]                           grepl <- base::grepl
[16:12:29.030]                           restarts <- computeRestarts(cond)
[16:12:29.030]                           for (restart in restarts) {
[16:12:29.030]                             name <- restart$name
[16:12:29.030]                             if (is.null(name)) 
[16:12:29.030]                               next
[16:12:29.030]                             if (!grepl(pattern, name)) 
[16:12:29.030]                               next
[16:12:29.030]                             invokeRestart(restart)
[16:12:29.030]                             muffled <- TRUE
[16:12:29.030]                             break
[16:12:29.030]                           }
[16:12:29.030]                         }
[16:12:29.030]                       }
[16:12:29.030]                       invisible(muffled)
[16:12:29.030]                     }
[16:12:29.030]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.030]                   }
[16:12:29.030]                 }
[16:12:29.030]             }
[16:12:29.030]         }))
[16:12:29.030]     }, error = function(ex) {
[16:12:29.030]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.030]                 ...future.rng), started = ...future.startTime, 
[16:12:29.030]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.030]             version = "1.8"), class = "FutureResult")
[16:12:29.030]     }, finally = {
[16:12:29.030]         if (!identical(...future.workdir, getwd())) 
[16:12:29.030]             setwd(...future.workdir)
[16:12:29.030]         {
[16:12:29.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.030]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.030]             }
[16:12:29.030]             base::options(...future.oldOptions)
[16:12:29.030]             if (.Platform$OS.type == "windows") {
[16:12:29.030]                 old_names <- names(...future.oldEnvVars)
[16:12:29.030]                 envs <- base::Sys.getenv()
[16:12:29.030]                 names <- names(envs)
[16:12:29.030]                 common <- intersect(names, old_names)
[16:12:29.030]                 added <- setdiff(names, old_names)
[16:12:29.030]                 removed <- setdiff(old_names, names)
[16:12:29.030]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.030]                   envs[common]]
[16:12:29.030]                 NAMES <- toupper(changed)
[16:12:29.030]                 args <- list()
[16:12:29.030]                 for (kk in seq_along(NAMES)) {
[16:12:29.030]                   name <- changed[[kk]]
[16:12:29.030]                   NAME <- NAMES[[kk]]
[16:12:29.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.030]                     next
[16:12:29.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.030]                 }
[16:12:29.030]                 NAMES <- toupper(added)
[16:12:29.030]                 for (kk in seq_along(NAMES)) {
[16:12:29.030]                   name <- added[[kk]]
[16:12:29.030]                   NAME <- NAMES[[kk]]
[16:12:29.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.030]                     next
[16:12:29.030]                   args[[name]] <- ""
[16:12:29.030]                 }
[16:12:29.030]                 NAMES <- toupper(removed)
[16:12:29.030]                 for (kk in seq_along(NAMES)) {
[16:12:29.030]                   name <- removed[[kk]]
[16:12:29.030]                   NAME <- NAMES[[kk]]
[16:12:29.030]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.030]                     next
[16:12:29.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.030]                 }
[16:12:29.030]                 if (length(args) > 0) 
[16:12:29.030]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.030]             }
[16:12:29.030]             else {
[16:12:29.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.030]             }
[16:12:29.030]             {
[16:12:29.030]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.030]                   0L) {
[16:12:29.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.030]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.030]                   base::options(opts)
[16:12:29.030]                 }
[16:12:29.030]                 {
[16:12:29.030]                   {
[16:12:29.030]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.030]                     NULL
[16:12:29.030]                   }
[16:12:29.030]                   options(future.plan = NULL)
[16:12:29.030]                   if (is.na(NA_character_)) 
[16:12:29.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.030]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:29.030]                     envir = parent.frame()) 
[16:12:29.030]                   {
[16:12:29.030]                     default_workers <- missing(workers)
[16:12:29.030]                     if (is.function(workers)) 
[16:12:29.030]                       workers <- workers()
[16:12:29.030]                     workers <- structure(as.integer(workers), 
[16:12:29.030]                       class = class(workers))
[16:12:29.030]                     stop_if_not(is.finite(workers), workers >= 
[16:12:29.030]                       1L)
[16:12:29.030]                     if ((workers == 1L && !inherits(workers, 
[16:12:29.030]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:29.030]                       if (default_workers) 
[16:12:29.030]                         supportsMulticore(warn = TRUE)
[16:12:29.030]                       return(sequential(..., envir = envir))
[16:12:29.030]                     }
[16:12:29.030]                     oopts <- options(mc.cores = workers)
[16:12:29.030]                     on.exit(options(oopts))
[16:12:29.030]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:29.030]                       envir = envir)
[16:12:29.030]                     if (!future$lazy) 
[16:12:29.030]                       future <- run(future)
[16:12:29.030]                     invisible(future)
[16:12:29.030]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.030]                 }
[16:12:29.030]             }
[16:12:29.030]         }
[16:12:29.030]     })
[16:12:29.030]     if (TRUE) {
[16:12:29.030]         base::sink(type = "output", split = FALSE)
[16:12:29.030]         if (TRUE) {
[16:12:29.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.030]         }
[16:12:29.030]         else {
[16:12:29.030]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.030]         }
[16:12:29.030]         base::close(...future.stdout)
[16:12:29.030]         ...future.stdout <- NULL
[16:12:29.030]     }
[16:12:29.030]     ...future.result$conditions <- ...future.conditions
[16:12:29.030]     ...future.result$finished <- base::Sys.time()
[16:12:29.030]     ...future.result
[16:12:29.030] }
[16:12:29.033] requestCore(): workers = 2
[16:12:29.035] MulticoreFuture started
[16:12:29.036] - Launch lazy future ... done
[16:12:29.049] plan(): Setting new future strategy stack:
[16:12:29.050] run() for ‘MulticoreFuture’ ... done
[16:12:29.050] List of future strategies:
[16:12:29.050] 1. sequential:
[16:12:29.050]    - args: function (..., envir = parent.frame())
[16:12:29.050]    - tweaked: FALSE
[16:12:29.050]    - call: NULL
[16:12:29.050] getGlobalsAndPackages() ...
[16:12:29.051] Searching for globals...
[16:12:29.051] plan(): nbrOfWorkers() = 1
[16:12:29.052] - globals found: [1] ‘{’
[16:12:29.052] Searching for globals ... DONE
[16:12:29.052] Resolving globals: FALSE
[16:12:29.052] plan(): Setting new future strategy stack:
[16:12:29.053] 
[16:12:29.052] List of future strategies:
[16:12:29.052] 1. multicore:
[16:12:29.052]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:29.052]    - tweaked: FALSE
[16:12:29.052]    - call: plan(strategy)
[16:12:29.053] 
[16:12:29.053] getGlobalsAndPackages() ... DONE
[16:12:29.053] run() for ‘Future’ ...
[16:12:29.053] - state: ‘created’
[16:12:29.054] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.057] plan(): nbrOfWorkers() = 2
[16:12:29.058] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:29.058]   - Field: ‘label’
[16:12:29.058]   - Field: ‘local’
[16:12:29.058]   - Field: ‘owner’
[16:12:29.058]   - Field: ‘envir’
[16:12:29.059]   - Field: ‘workers’
[16:12:29.059]   - Field: ‘packages’
[16:12:29.059]   - Field: ‘gc’
[16:12:29.059]   - Field: ‘job’
[16:12:29.059]   - Field: ‘conditions’
[16:12:29.059]   - Field: ‘expr’
[16:12:29.059]   - Field: ‘uuid’
[16:12:29.059]   - Field: ‘seed’
[16:12:29.060]   - Field: ‘version’
[16:12:29.060]   - Field: ‘result’
[16:12:29.060]   - Field: ‘asynchronous’
[16:12:29.060]   - Field: ‘calls’
[16:12:29.060]   - Field: ‘globals’
[16:12:29.060]   - Field: ‘stdout’
[16:12:29.060]   - Field: ‘earlySignal’
[16:12:29.061]   - Field: ‘lazy’
[16:12:29.061]   - Field: ‘state’
[16:12:29.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:29.061] - Launch lazy future ...
[16:12:29.061] Packages needed by the future expression (n = 0): <none>
[16:12:29.062] Packages needed by future strategies (n = 0): <none>
[16:12:29.062] {
[16:12:29.062]     {
[16:12:29.062]         {
[16:12:29.062]             ...future.startTime <- base::Sys.time()
[16:12:29.062]             {
[16:12:29.062]                 {
[16:12:29.062]                   {
[16:12:29.062]                     {
[16:12:29.062]                       base::local({
[16:12:29.062]                         has_future <- base::requireNamespace("future", 
[16:12:29.062]                           quietly = TRUE)
[16:12:29.062]                         if (has_future) {
[16:12:29.062]                           ns <- base::getNamespace("future")
[16:12:29.062]                           version <- ns[[".package"]][["version"]]
[16:12:29.062]                           if (is.null(version)) 
[16:12:29.062]                             version <- utils::packageVersion("future")
[16:12:29.062]                         }
[16:12:29.062]                         else {
[16:12:29.062]                           version <- NULL
[16:12:29.062]                         }
[16:12:29.062]                         if (!has_future || version < "1.8.0") {
[16:12:29.062]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.062]                             "", base::R.version$version.string), 
[16:12:29.062]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.062]                               "release", "version")], collapse = " "), 
[16:12:29.062]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.062]                             info)
[16:12:29.062]                           info <- base::paste(info, collapse = "; ")
[16:12:29.062]                           if (!has_future) {
[16:12:29.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.062]                               info)
[16:12:29.062]                           }
[16:12:29.062]                           else {
[16:12:29.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.062]                               info, version)
[16:12:29.062]                           }
[16:12:29.062]                           base::stop(msg)
[16:12:29.062]                         }
[16:12:29.062]                       })
[16:12:29.062]                     }
[16:12:29.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.062]                     base::options(mc.cores = 1L)
[16:12:29.062]                   }
[16:12:29.062]                   options(future.plan = NULL)
[16:12:29.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.062]                 }
[16:12:29.062]                 ...future.workdir <- getwd()
[16:12:29.062]             }
[16:12:29.062]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.062]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.062]         }
[16:12:29.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.062]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.062]             base::names(...future.oldOptions))
[16:12:29.062]     }
[16:12:29.062]     if (FALSE) {
[16:12:29.062]     }
[16:12:29.062]     else {
[16:12:29.062]         if (TRUE) {
[16:12:29.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.062]                 open = "w")
[16:12:29.062]         }
[16:12:29.062]         else {
[16:12:29.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.062]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.062]         }
[16:12:29.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.062]             base::sink(type = "output", split = FALSE)
[16:12:29.062]             base::close(...future.stdout)
[16:12:29.062]         }, add = TRUE)
[16:12:29.062]     }
[16:12:29.062]     ...future.frame <- base::sys.nframe()
[16:12:29.062]     ...future.conditions <- base::list()
[16:12:29.062]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.062]     if (FALSE) {
[16:12:29.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.062]     }
[16:12:29.062]     ...future.result <- base::tryCatch({
[16:12:29.062]         base::withCallingHandlers({
[16:12:29.062]             ...future.value <- base::withVisible(base::local({
[16:12:29.062]                 withCallingHandlers({
[16:12:29.062]                   {
[16:12:29.062]                     4
[16:12:29.062]                   }
[16:12:29.062]                 }, immediateCondition = function(cond) {
[16:12:29.062]                   save_rds <- function (object, pathname, ...) 
[16:12:29.062]                   {
[16:12:29.062]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:29.062]                     if (file_test("-f", pathname_tmp)) {
[16:12:29.062]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.062]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:29.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.062]                         fi_tmp[["mtime"]])
[16:12:29.062]                     }
[16:12:29.062]                     tryCatch({
[16:12:29.062]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:29.062]                     }, error = function(ex) {
[16:12:29.062]                       msg <- conditionMessage(ex)
[16:12:29.062]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.062]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:29.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.062]                         fi_tmp[["mtime"]], msg)
[16:12:29.062]                       ex$message <- msg
[16:12:29.062]                       stop(ex)
[16:12:29.062]                     })
[16:12:29.062]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:29.062]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:29.062]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:29.062]                       fi_tmp <- file.info(pathname_tmp)
[16:12:29.062]                       fi <- file.info(pathname)
[16:12:29.062]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:29.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:29.062]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:29.062]                         fi[["size"]], fi[["mtime"]])
[16:12:29.062]                       stop(msg)
[16:12:29.062]                     }
[16:12:29.062]                     invisible(pathname)
[16:12:29.062]                   }
[16:12:29.062]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:29.062]                     rootPath = tempdir()) 
[16:12:29.062]                   {
[16:12:29.062]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:29.062]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:29.062]                       tmpdir = path, fileext = ".rds")
[16:12:29.062]                     save_rds(obj, file)
[16:12:29.062]                   }
[16:12:29.062]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:29.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.062]                   {
[16:12:29.062]                     inherits <- base::inherits
[16:12:29.062]                     invokeRestart <- base::invokeRestart
[16:12:29.062]                     is.null <- base::is.null
[16:12:29.062]                     muffled <- FALSE
[16:12:29.062]                     if (inherits(cond, "message")) {
[16:12:29.062]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.062]                       if (muffled) 
[16:12:29.062]                         invokeRestart("muffleMessage")
[16:12:29.062]                     }
[16:12:29.062]                     else if (inherits(cond, "warning")) {
[16:12:29.062]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.062]                       if (muffled) 
[16:12:29.062]                         invokeRestart("muffleWarning")
[16:12:29.062]                     }
[16:12:29.062]                     else if (inherits(cond, "condition")) {
[16:12:29.062]                       if (!is.null(pattern)) {
[16:12:29.062]                         computeRestarts <- base::computeRestarts
[16:12:29.062]                         grepl <- base::grepl
[16:12:29.062]                         restarts <- computeRestarts(cond)
[16:12:29.062]                         for (restart in restarts) {
[16:12:29.062]                           name <- restart$name
[16:12:29.062]                           if (is.null(name)) 
[16:12:29.062]                             next
[16:12:29.062]                           if (!grepl(pattern, name)) 
[16:12:29.062]                             next
[16:12:29.062]                           invokeRestart(restart)
[16:12:29.062]                           muffled <- TRUE
[16:12:29.062]                           break
[16:12:29.062]                         }
[16:12:29.062]                       }
[16:12:29.062]                     }
[16:12:29.062]                     invisible(muffled)
[16:12:29.062]                   }
[16:12:29.062]                   muffleCondition(cond)
[16:12:29.062]                 })
[16:12:29.062]             }))
[16:12:29.062]             future::FutureResult(value = ...future.value$value, 
[16:12:29.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.062]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.062]                     ...future.globalenv.names))
[16:12:29.062]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.062]         }, condition = base::local({
[16:12:29.062]             c <- base::c
[16:12:29.062]             inherits <- base::inherits
[16:12:29.062]             invokeRestart <- base::invokeRestart
[16:12:29.062]             length <- base::length
[16:12:29.062]             list <- base::list
[16:12:29.062]             seq.int <- base::seq.int
[16:12:29.062]             signalCondition <- base::signalCondition
[16:12:29.062]             sys.calls <- base::sys.calls
[16:12:29.062]             `[[` <- base::`[[`
[16:12:29.062]             `+` <- base::`+`
[16:12:29.062]             `<<-` <- base::`<<-`
[16:12:29.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.062]                   3L)]
[16:12:29.062]             }
[16:12:29.062]             function(cond) {
[16:12:29.062]                 is_error <- inherits(cond, "error")
[16:12:29.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.062]                   NULL)
[16:12:29.062]                 if (is_error) {
[16:12:29.062]                   sessionInformation <- function() {
[16:12:29.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.062]                       search = base::search(), system = base::Sys.info())
[16:12:29.062]                   }
[16:12:29.062]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.062]                     cond$call), session = sessionInformation(), 
[16:12:29.062]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.062]                   signalCondition(cond)
[16:12:29.062]                 }
[16:12:29.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.062]                 "immediateCondition"))) {
[16:12:29.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.062]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.062]                   if (TRUE && !signal) {
[16:12:29.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.062]                     {
[16:12:29.062]                       inherits <- base::inherits
[16:12:29.062]                       invokeRestart <- base::invokeRestart
[16:12:29.062]                       is.null <- base::is.null
[16:12:29.062]                       muffled <- FALSE
[16:12:29.062]                       if (inherits(cond, "message")) {
[16:12:29.062]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.062]                         if (muffled) 
[16:12:29.062]                           invokeRestart("muffleMessage")
[16:12:29.062]                       }
[16:12:29.062]                       else if (inherits(cond, "warning")) {
[16:12:29.062]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.062]                         if (muffled) 
[16:12:29.062]                           invokeRestart("muffleWarning")
[16:12:29.062]                       }
[16:12:29.062]                       else if (inherits(cond, "condition")) {
[16:12:29.062]                         if (!is.null(pattern)) {
[16:12:29.062]                           computeRestarts <- base::computeRestarts
[16:12:29.062]                           grepl <- base::grepl
[16:12:29.062]                           restarts <- computeRestarts(cond)
[16:12:29.062]                           for (restart in restarts) {
[16:12:29.062]                             name <- restart$name
[16:12:29.062]                             if (is.null(name)) 
[16:12:29.062]                               next
[16:12:29.062]                             if (!grepl(pattern, name)) 
[16:12:29.062]                               next
[16:12:29.062]                             invokeRestart(restart)
[16:12:29.062]                             muffled <- TRUE
[16:12:29.062]                             break
[16:12:29.062]                           }
[16:12:29.062]                         }
[16:12:29.062]                       }
[16:12:29.062]                       invisible(muffled)
[16:12:29.062]                     }
[16:12:29.062]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.062]                   }
[16:12:29.062]                 }
[16:12:29.062]                 else {
[16:12:29.062]                   if (TRUE) {
[16:12:29.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.062]                     {
[16:12:29.062]                       inherits <- base::inherits
[16:12:29.062]                       invokeRestart <- base::invokeRestart
[16:12:29.062]                       is.null <- base::is.null
[16:12:29.062]                       muffled <- FALSE
[16:12:29.062]                       if (inherits(cond, "message")) {
[16:12:29.062]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.062]                         if (muffled) 
[16:12:29.062]                           invokeRestart("muffleMessage")
[16:12:29.062]                       }
[16:12:29.062]                       else if (inherits(cond, "warning")) {
[16:12:29.062]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.062]                         if (muffled) 
[16:12:29.062]                           invokeRestart("muffleWarning")
[16:12:29.062]                       }
[16:12:29.062]                       else if (inherits(cond, "condition")) {
[16:12:29.062]                         if (!is.null(pattern)) {
[16:12:29.062]                           computeRestarts <- base::computeRestarts
[16:12:29.062]                           grepl <- base::grepl
[16:12:29.062]                           restarts <- computeRestarts(cond)
[16:12:29.062]                           for (restart in restarts) {
[16:12:29.062]                             name <- restart$name
[16:12:29.062]                             if (is.null(name)) 
[16:12:29.062]                               next
[16:12:29.062]                             if (!grepl(pattern, name)) 
[16:12:29.062]                               next
[16:12:29.062]                             invokeRestart(restart)
[16:12:29.062]                             muffled <- TRUE
[16:12:29.062]                             break
[16:12:29.062]                           }
[16:12:29.062]                         }
[16:12:29.062]                       }
[16:12:29.062]                       invisible(muffled)
[16:12:29.062]                     }
[16:12:29.062]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.062]                   }
[16:12:29.062]                 }
[16:12:29.062]             }
[16:12:29.062]         }))
[16:12:29.062]     }, error = function(ex) {
[16:12:29.062]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.062]                 ...future.rng), started = ...future.startTime, 
[16:12:29.062]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.062]             version = "1.8"), class = "FutureResult")
[16:12:29.062]     }, finally = {
[16:12:29.062]         if (!identical(...future.workdir, getwd())) 
[16:12:29.062]             setwd(...future.workdir)
[16:12:29.062]         {
[16:12:29.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.062]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.062]             }
[16:12:29.062]             base::options(...future.oldOptions)
[16:12:29.062]             if (.Platform$OS.type == "windows") {
[16:12:29.062]                 old_names <- names(...future.oldEnvVars)
[16:12:29.062]                 envs <- base::Sys.getenv()
[16:12:29.062]                 names <- names(envs)
[16:12:29.062]                 common <- intersect(names, old_names)
[16:12:29.062]                 added <- setdiff(names, old_names)
[16:12:29.062]                 removed <- setdiff(old_names, names)
[16:12:29.062]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.062]                   envs[common]]
[16:12:29.062]                 NAMES <- toupper(changed)
[16:12:29.062]                 args <- list()
[16:12:29.062]                 for (kk in seq_along(NAMES)) {
[16:12:29.062]                   name <- changed[[kk]]
[16:12:29.062]                   NAME <- NAMES[[kk]]
[16:12:29.062]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.062]                     next
[16:12:29.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.062]                 }
[16:12:29.062]                 NAMES <- toupper(added)
[16:12:29.062]                 for (kk in seq_along(NAMES)) {
[16:12:29.062]                   name <- added[[kk]]
[16:12:29.062]                   NAME <- NAMES[[kk]]
[16:12:29.062]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.062]                     next
[16:12:29.062]                   args[[name]] <- ""
[16:12:29.062]                 }
[16:12:29.062]                 NAMES <- toupper(removed)
[16:12:29.062]                 for (kk in seq_along(NAMES)) {
[16:12:29.062]                   name <- removed[[kk]]
[16:12:29.062]                   NAME <- NAMES[[kk]]
[16:12:29.062]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.062]                     next
[16:12:29.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.062]                 }
[16:12:29.062]                 if (length(args) > 0) 
[16:12:29.062]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.062]             }
[16:12:29.062]             else {
[16:12:29.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.062]             }
[16:12:29.062]             {
[16:12:29.062]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.062]                   0L) {
[16:12:29.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.062]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.062]                   base::options(opts)
[16:12:29.062]                 }
[16:12:29.062]                 {
[16:12:29.062]                   {
[16:12:29.062]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.062]                     NULL
[16:12:29.062]                   }
[16:12:29.062]                   options(future.plan = NULL)
[16:12:29.062]                   if (is.na(NA_character_)) 
[16:12:29.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.062]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:29.062]                     envir = parent.frame()) 
[16:12:29.062]                   {
[16:12:29.062]                     default_workers <- missing(workers)
[16:12:29.062]                     if (is.function(workers)) 
[16:12:29.062]                       workers <- workers()
[16:12:29.062]                     workers <- structure(as.integer(workers), 
[16:12:29.062]                       class = class(workers))
[16:12:29.062]                     stop_if_not(is.finite(workers), workers >= 
[16:12:29.062]                       1L)
[16:12:29.062]                     if ((workers == 1L && !inherits(workers, 
[16:12:29.062]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:29.062]                       if (default_workers) 
[16:12:29.062]                         supportsMulticore(warn = TRUE)
[16:12:29.062]                       return(sequential(..., envir = envir))
[16:12:29.062]                     }
[16:12:29.062]                     oopts <- options(mc.cores = workers)
[16:12:29.062]                     on.exit(options(oopts))
[16:12:29.062]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:29.062]                       envir = envir)
[16:12:29.062]                     if (!future$lazy) 
[16:12:29.062]                       future <- run(future)
[16:12:29.062]                     invisible(future)
[16:12:29.062]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.062]                 }
[16:12:29.062]             }
[16:12:29.062]         }
[16:12:29.062]     })
[16:12:29.062]     if (TRUE) {
[16:12:29.062]         base::sink(type = "output", split = FALSE)
[16:12:29.062]         if (TRUE) {
[16:12:29.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.062]         }
[16:12:29.062]         else {
[16:12:29.062]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.062]         }
[16:12:29.062]         base::close(...future.stdout)
[16:12:29.062]         ...future.stdout <- NULL
[16:12:29.062]     }
[16:12:29.062]     ...future.result$conditions <- ...future.conditions
[16:12:29.062]     ...future.result$finished <- base::Sys.time()
[16:12:29.062]     ...future.result
[16:12:29.062] }
[16:12:29.065] requestCore(): workers = 2
[16:12:29.065] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:29.079] MulticoreFuture started
[16:12:29.080] - Launch lazy future ... done
[16:12:29.080] run() for ‘MulticoreFuture’ ... done
[16:12:29.081] plan(): Setting new future strategy stack:
<environment: 0x560bb0721d80> 
[16:12:29.081] List of future strategies:
[16:12:29.081] 1. sequential:
[16:12:29.081]    - args: function (..., envir = parent.frame())
[16:12:29.081]    - tweaked: FALSE
[16:12:29.081]    - call: NULL
[16:12:29.082] plan(): nbrOfWorkers() = 1
<environment: 0x560baed5dde0> 
[16:12:29.085] plan(): Setting new future strategy stack:
[16:12:29.085] List of future strategies:
[16:12:29.085] 1. multicore:
[16:12:29.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:29.085]    - tweaked: FALSE
[16:12:29.085]    - call: plan(strategy)
[16:12:29.090] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:29.093] resolve() on environment ...
[16:12:29.093]  recursive: 0
[16:12:29.094]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:29.094] signalConditionsASAP(numeric, pos=1) ...
[16:12:29.094] - nx: 4
[16:12:29.094] - relay: TRUE
[16:12:29.094] - stdout: TRUE
[16:12:29.095] - signal: TRUE
[16:12:29.095] - resignal: FALSE
[16:12:29.095] - force: TRUE
[16:12:29.095] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.095] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.095]  - until=2
[16:12:29.095]  - relaying element #2
[16:12:29.095] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.096] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.096] signalConditionsASAP(NULL, pos=1) ... done
[16:12:29.096]  length: 3 (resolved future 1)
[16:12:29.096] Future #2
[16:12:29.096] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:29.096] - nx: 4
[16:12:29.097] - relay: TRUE
[16:12:29.097] - stdout: TRUE
[16:12:29.097] - signal: TRUE
[16:12:29.097] - resignal: FALSE
[16:12:29.097] - force: TRUE
[16:12:29.097] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.097] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.098]  - until=2
[16:12:29.098]  - relaying element #2
[16:12:29.098] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.098] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.098] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:29.098]  length: 2 (resolved future 2)
[16:12:29.099] Future #3
[16:12:29.100] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:29.100] - nx: 4
[16:12:29.100] - relay: TRUE
[16:12:29.100] - stdout: TRUE
[16:12:29.100] - signal: TRUE
[16:12:29.100] - resignal: FALSE
[16:12:29.100] - force: TRUE
[16:12:29.101] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.101] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.101]  - until=3
[16:12:29.101]  - relaying element #3
[16:12:29.101] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.101] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.101] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:29.102]  length: 1 (resolved future 3)
[16:12:29.102] Future #4
[16:12:29.103] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:29.103] - nx: 4
[16:12:29.103] - relay: TRUE
[16:12:29.103] - stdout: TRUE
[16:12:29.104] - signal: TRUE
[16:12:29.104] - resignal: FALSE
[16:12:29.104] - force: TRUE
[16:12:29.104] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.104] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.104]  - until=4
[16:12:29.104]  - relaying element #4
[16:12:29.105] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.105] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.105] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:29.105]  length: 0 (resolved future 4)
[16:12:29.105] Relaying remaining futures
[16:12:29.106] signalConditionsASAP(NULL, pos=0) ...
[16:12:29.106] - nx: 4
[16:12:29.106] - relay: TRUE
[16:12:29.106] - stdout: TRUE
[16:12:29.106] - signal: TRUE
[16:12:29.106] - resignal: FALSE
[16:12:29.106] - force: TRUE
[16:12:29.106] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.107] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:29.107] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.107] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.107] signalConditionsASAP(NULL, pos=0) ... done
[16:12:29.107] resolve() on environment ... DONE
<environment: 0x560baebdd5c8> 
Type of future: multisession
[16:12:29.108] plan(): Setting new future strategy stack:
[16:12:29.108] List of future strategies:
[16:12:29.108] 1. multisession:
[16:12:29.108]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:29.108]    - tweaked: FALSE
[16:12:29.108]    - call: plan(strategy)
[16:12:29.109] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:29.109] multisession:
[16:12:29.109] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:29.109] - tweaked: FALSE
[16:12:29.109] - call: plan(strategy)
[16:12:29.113] getGlobalsAndPackages() ...
[16:12:29.113] Not searching for globals
[16:12:29.113] - globals: [0] <none>
[16:12:29.113] getGlobalsAndPackages() ... DONE
[16:12:29.114] [local output] makeClusterPSOCK() ...
[16:12:29.114] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:29.115] [local output] Base port: 11384
[16:12:29.115] [local output] Getting setup options for 2 cluster nodes ...
[16:12:29.115] [local output]  - Node 1 of 2 ...
[16:12:29.115] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:29.116] [local output] Rscript port: 11384

[16:12:29.117] [local output]  - Node 2 of 2 ...
[16:12:29.117] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:29.118] [local output] Rscript port: 11384

[16:12:29.118] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:29.118] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:29.118] [local output] Setting up PSOCK nodes in parallel
[16:12:29.118] List of 36
[16:12:29.118]  $ worker          : chr "localhost"
[16:12:29.118]   ..- attr(*, "localhost")= logi TRUE
[16:12:29.118]  $ master          : chr "localhost"
[16:12:29.118]  $ port            : int 11384
[16:12:29.118]  $ connectTimeout  : num 120
[16:12:29.118]  $ timeout         : num 2592000
[16:12:29.118]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:29.118]  $ homogeneous     : logi TRUE
[16:12:29.118]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:29.118]  $ rscript_envs    : NULL
[16:12:29.118]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:29.118]  $ rscript_startup : NULL
[16:12:29.118]  $ rscript_sh      : chr "sh"
[16:12:29.118]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:29.118]  $ methods         : logi TRUE
[16:12:29.118]  $ socketOptions   : chr "no-delay"
[16:12:29.118]  $ useXDR          : logi FALSE
[16:12:29.118]  $ outfile         : chr "/dev/null"
[16:12:29.118]  $ renice          : int NA
[16:12:29.118]  $ rshcmd          : NULL
[16:12:29.118]  $ user            : chr(0) 
[16:12:29.118]  $ revtunnel       : logi FALSE
[16:12:29.118]  $ rshlogfile      : NULL
[16:12:29.118]  $ rshopts         : chr(0) 
[16:12:29.118]  $ rank            : int 1
[16:12:29.118]  $ manual          : logi FALSE
[16:12:29.118]  $ dryrun          : logi FALSE
[16:12:29.118]  $ quiet           : logi FALSE
[16:12:29.118]  $ setup_strategy  : chr "parallel"
[16:12:29.118]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:29.118]  $ pidfile         : chr "/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454af0af1cc.pid"
[16:12:29.118]  $ rshcmd_label    : NULL
[16:12:29.118]  $ rsh_call        : NULL
[16:12:29.118]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:29.118]  $ localMachine    : logi TRUE
[16:12:29.118]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:29.118]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:29.118]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:29.118]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:29.118]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:29.118]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:29.118]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:29.118]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:29.118]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:29.118]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:29.118]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:29.118]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:29.118]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:29.118]  $ arguments       :List of 28
[16:12:29.118]   ..$ worker          : chr "localhost"
[16:12:29.118]   ..$ master          : NULL
[16:12:29.118]   ..$ port            : int 11384
[16:12:29.118]   ..$ connectTimeout  : num 120
[16:12:29.118]   ..$ timeout         : num 2592000
[16:12:29.118]   ..$ rscript         : NULL
[16:12:29.118]   ..$ homogeneous     : NULL
[16:12:29.118]   ..$ rscript_args    : NULL
[16:12:29.118]   ..$ rscript_envs    : NULL
[16:12:29.118]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:29.118]   ..$ rscript_startup : NULL
[16:12:29.118]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:29.118]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:29.118]   ..$ methods         : logi TRUE
[16:12:29.118]   ..$ socketOptions   : chr "no-delay"
[16:12:29.118]   ..$ useXDR          : logi FALSE
[16:12:29.118]   ..$ outfile         : chr "/dev/null"
[16:12:29.118]   ..$ renice          : int NA
[16:12:29.118]   ..$ rshcmd          : NULL
[16:12:29.118]   ..$ user            : NULL
[16:12:29.118]   ..$ revtunnel       : logi NA
[16:12:29.118]   ..$ rshlogfile      : NULL
[16:12:29.118]   ..$ rshopts         : NULL
[16:12:29.118]   ..$ rank            : int 1
[16:12:29.118]   ..$ manual          : logi FALSE
[16:12:29.118]   ..$ dryrun          : logi FALSE
[16:12:29.118]   ..$ quiet           : logi FALSE
[16:12:29.118]   ..$ setup_strategy  : chr "parallel"
[16:12:29.118]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:29.139] [local output] System call to launch all workers:
[16:12:29.139] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454af0af1cc.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11384 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:29.139] [local output] Starting PSOCK main server
[16:12:29.140] [local output] Workers launched
[16:12:29.141] [local output] Waiting for workers to connect back
[16:12:29.141]  - [local output] 0 workers out of 2 ready
[16:12:29.385]  - [local output] 0 workers out of 2 ready
[16:12:29.386]  - [local output] 1 workers out of 2 ready
[16:12:29.387]  - [local output] 1 workers out of 2 ready
[16:12:29.387]  - [local output] 2 workers out of 2 ready
[16:12:29.387] [local output] Launching of workers completed
[16:12:29.387] [local output] Collecting session information from workers
[16:12:29.388] [local output]  - Worker #1 of 2
[16:12:29.388] [local output]  - Worker #2 of 2
[16:12:29.389] [local output] makeClusterPSOCK() ... done
[16:12:29.400] Packages needed by the future expression (n = 0): <none>
[16:12:29.400] Packages needed by future strategies (n = 0): <none>
[16:12:29.401] {
[16:12:29.401]     {
[16:12:29.401]         {
[16:12:29.401]             ...future.startTime <- base::Sys.time()
[16:12:29.401]             {
[16:12:29.401]                 {
[16:12:29.401]                   {
[16:12:29.401]                     {
[16:12:29.401]                       base::local({
[16:12:29.401]                         has_future <- base::requireNamespace("future", 
[16:12:29.401]                           quietly = TRUE)
[16:12:29.401]                         if (has_future) {
[16:12:29.401]                           ns <- base::getNamespace("future")
[16:12:29.401]                           version <- ns[[".package"]][["version"]]
[16:12:29.401]                           if (is.null(version)) 
[16:12:29.401]                             version <- utils::packageVersion("future")
[16:12:29.401]                         }
[16:12:29.401]                         else {
[16:12:29.401]                           version <- NULL
[16:12:29.401]                         }
[16:12:29.401]                         if (!has_future || version < "1.8.0") {
[16:12:29.401]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.401]                             "", base::R.version$version.string), 
[16:12:29.401]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.401]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.401]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.401]                               "release", "version")], collapse = " "), 
[16:12:29.401]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.401]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.401]                             info)
[16:12:29.401]                           info <- base::paste(info, collapse = "; ")
[16:12:29.401]                           if (!has_future) {
[16:12:29.401]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.401]                               info)
[16:12:29.401]                           }
[16:12:29.401]                           else {
[16:12:29.401]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.401]                               info, version)
[16:12:29.401]                           }
[16:12:29.401]                           base::stop(msg)
[16:12:29.401]                         }
[16:12:29.401]                       })
[16:12:29.401]                     }
[16:12:29.401]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.401]                     base::options(mc.cores = 1L)
[16:12:29.401]                   }
[16:12:29.401]                   options(future.plan = NULL)
[16:12:29.401]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.401]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.401]                 }
[16:12:29.401]                 ...future.workdir <- getwd()
[16:12:29.401]             }
[16:12:29.401]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.401]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.401]         }
[16:12:29.401]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.401]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.401]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.401]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.401]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.401]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.401]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.401]             base::names(...future.oldOptions))
[16:12:29.401]     }
[16:12:29.401]     if (FALSE) {
[16:12:29.401]     }
[16:12:29.401]     else {
[16:12:29.401]         if (TRUE) {
[16:12:29.401]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.401]                 open = "w")
[16:12:29.401]         }
[16:12:29.401]         else {
[16:12:29.401]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.401]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.401]         }
[16:12:29.401]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.401]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.401]             base::sink(type = "output", split = FALSE)
[16:12:29.401]             base::close(...future.stdout)
[16:12:29.401]         }, add = TRUE)
[16:12:29.401]     }
[16:12:29.401]     ...future.frame <- base::sys.nframe()
[16:12:29.401]     ...future.conditions <- base::list()
[16:12:29.401]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.401]     if (FALSE) {
[16:12:29.401]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.401]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.401]     }
[16:12:29.401]     ...future.result <- base::tryCatch({
[16:12:29.401]         base::withCallingHandlers({
[16:12:29.401]             ...future.value <- base::withVisible(base::local({
[16:12:29.401]                 ...future.makeSendCondition <- local({
[16:12:29.401]                   sendCondition <- NULL
[16:12:29.401]                   function(frame = 1L) {
[16:12:29.401]                     if (is.function(sendCondition)) 
[16:12:29.401]                       return(sendCondition)
[16:12:29.401]                     ns <- getNamespace("parallel")
[16:12:29.401]                     if (exists("sendData", mode = "function", 
[16:12:29.401]                       envir = ns)) {
[16:12:29.401]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.401]                         envir = ns)
[16:12:29.401]                       envir <- sys.frame(frame)
[16:12:29.401]                       master <- NULL
[16:12:29.401]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.401]                         !identical(envir, emptyenv())) {
[16:12:29.401]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.401]                           inherits = FALSE)) {
[16:12:29.401]                           master <- get("master", mode = "list", 
[16:12:29.401]                             envir = envir, inherits = FALSE)
[16:12:29.401]                           if (inherits(master, c("SOCKnode", 
[16:12:29.401]                             "SOCK0node"))) {
[16:12:29.401]                             sendCondition <<- function(cond) {
[16:12:29.401]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.401]                                 success = TRUE)
[16:12:29.401]                               parallel_sendData(master, data)
[16:12:29.401]                             }
[16:12:29.401]                             return(sendCondition)
[16:12:29.401]                           }
[16:12:29.401]                         }
[16:12:29.401]                         frame <- frame + 1L
[16:12:29.401]                         envir <- sys.frame(frame)
[16:12:29.401]                       }
[16:12:29.401]                     }
[16:12:29.401]                     sendCondition <<- function(cond) NULL
[16:12:29.401]                   }
[16:12:29.401]                 })
[16:12:29.401]                 withCallingHandlers({
[16:12:29.401]                   NA
[16:12:29.401]                 }, immediateCondition = function(cond) {
[16:12:29.401]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.401]                   sendCondition(cond)
[16:12:29.401]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.401]                   {
[16:12:29.401]                     inherits <- base::inherits
[16:12:29.401]                     invokeRestart <- base::invokeRestart
[16:12:29.401]                     is.null <- base::is.null
[16:12:29.401]                     muffled <- FALSE
[16:12:29.401]                     if (inherits(cond, "message")) {
[16:12:29.401]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.401]                       if (muffled) 
[16:12:29.401]                         invokeRestart("muffleMessage")
[16:12:29.401]                     }
[16:12:29.401]                     else if (inherits(cond, "warning")) {
[16:12:29.401]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.401]                       if (muffled) 
[16:12:29.401]                         invokeRestart("muffleWarning")
[16:12:29.401]                     }
[16:12:29.401]                     else if (inherits(cond, "condition")) {
[16:12:29.401]                       if (!is.null(pattern)) {
[16:12:29.401]                         computeRestarts <- base::computeRestarts
[16:12:29.401]                         grepl <- base::grepl
[16:12:29.401]                         restarts <- computeRestarts(cond)
[16:12:29.401]                         for (restart in restarts) {
[16:12:29.401]                           name <- restart$name
[16:12:29.401]                           if (is.null(name)) 
[16:12:29.401]                             next
[16:12:29.401]                           if (!grepl(pattern, name)) 
[16:12:29.401]                             next
[16:12:29.401]                           invokeRestart(restart)
[16:12:29.401]                           muffled <- TRUE
[16:12:29.401]                           break
[16:12:29.401]                         }
[16:12:29.401]                       }
[16:12:29.401]                     }
[16:12:29.401]                     invisible(muffled)
[16:12:29.401]                   }
[16:12:29.401]                   muffleCondition(cond)
[16:12:29.401]                 })
[16:12:29.401]             }))
[16:12:29.401]             future::FutureResult(value = ...future.value$value, 
[16:12:29.401]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.401]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.401]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.401]                     ...future.globalenv.names))
[16:12:29.401]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.401]         }, condition = base::local({
[16:12:29.401]             c <- base::c
[16:12:29.401]             inherits <- base::inherits
[16:12:29.401]             invokeRestart <- base::invokeRestart
[16:12:29.401]             length <- base::length
[16:12:29.401]             list <- base::list
[16:12:29.401]             seq.int <- base::seq.int
[16:12:29.401]             signalCondition <- base::signalCondition
[16:12:29.401]             sys.calls <- base::sys.calls
[16:12:29.401]             `[[` <- base::`[[`
[16:12:29.401]             `+` <- base::`+`
[16:12:29.401]             `<<-` <- base::`<<-`
[16:12:29.401]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.401]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.401]                   3L)]
[16:12:29.401]             }
[16:12:29.401]             function(cond) {
[16:12:29.401]                 is_error <- inherits(cond, "error")
[16:12:29.401]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.401]                   NULL)
[16:12:29.401]                 if (is_error) {
[16:12:29.401]                   sessionInformation <- function() {
[16:12:29.401]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.401]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.401]                       search = base::search(), system = base::Sys.info())
[16:12:29.401]                   }
[16:12:29.401]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.401]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.401]                     cond$call), session = sessionInformation(), 
[16:12:29.401]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.401]                   signalCondition(cond)
[16:12:29.401]                 }
[16:12:29.401]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.401]                 "immediateCondition"))) {
[16:12:29.401]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.401]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.401]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.401]                   if (TRUE && !signal) {
[16:12:29.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.401]                     {
[16:12:29.401]                       inherits <- base::inherits
[16:12:29.401]                       invokeRestart <- base::invokeRestart
[16:12:29.401]                       is.null <- base::is.null
[16:12:29.401]                       muffled <- FALSE
[16:12:29.401]                       if (inherits(cond, "message")) {
[16:12:29.401]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.401]                         if (muffled) 
[16:12:29.401]                           invokeRestart("muffleMessage")
[16:12:29.401]                       }
[16:12:29.401]                       else if (inherits(cond, "warning")) {
[16:12:29.401]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.401]                         if (muffled) 
[16:12:29.401]                           invokeRestart("muffleWarning")
[16:12:29.401]                       }
[16:12:29.401]                       else if (inherits(cond, "condition")) {
[16:12:29.401]                         if (!is.null(pattern)) {
[16:12:29.401]                           computeRestarts <- base::computeRestarts
[16:12:29.401]                           grepl <- base::grepl
[16:12:29.401]                           restarts <- computeRestarts(cond)
[16:12:29.401]                           for (restart in restarts) {
[16:12:29.401]                             name <- restart$name
[16:12:29.401]                             if (is.null(name)) 
[16:12:29.401]                               next
[16:12:29.401]                             if (!grepl(pattern, name)) 
[16:12:29.401]                               next
[16:12:29.401]                             invokeRestart(restart)
[16:12:29.401]                             muffled <- TRUE
[16:12:29.401]                             break
[16:12:29.401]                           }
[16:12:29.401]                         }
[16:12:29.401]                       }
[16:12:29.401]                       invisible(muffled)
[16:12:29.401]                     }
[16:12:29.401]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.401]                   }
[16:12:29.401]                 }
[16:12:29.401]                 else {
[16:12:29.401]                   if (TRUE) {
[16:12:29.401]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.401]                     {
[16:12:29.401]                       inherits <- base::inherits
[16:12:29.401]                       invokeRestart <- base::invokeRestart
[16:12:29.401]                       is.null <- base::is.null
[16:12:29.401]                       muffled <- FALSE
[16:12:29.401]                       if (inherits(cond, "message")) {
[16:12:29.401]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.401]                         if (muffled) 
[16:12:29.401]                           invokeRestart("muffleMessage")
[16:12:29.401]                       }
[16:12:29.401]                       else if (inherits(cond, "warning")) {
[16:12:29.401]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.401]                         if (muffled) 
[16:12:29.401]                           invokeRestart("muffleWarning")
[16:12:29.401]                       }
[16:12:29.401]                       else if (inherits(cond, "condition")) {
[16:12:29.401]                         if (!is.null(pattern)) {
[16:12:29.401]                           computeRestarts <- base::computeRestarts
[16:12:29.401]                           grepl <- base::grepl
[16:12:29.401]                           restarts <- computeRestarts(cond)
[16:12:29.401]                           for (restart in restarts) {
[16:12:29.401]                             name <- restart$name
[16:12:29.401]                             if (is.null(name)) 
[16:12:29.401]                               next
[16:12:29.401]                             if (!grepl(pattern, name)) 
[16:12:29.401]                               next
[16:12:29.401]                             invokeRestart(restart)
[16:12:29.401]                             muffled <- TRUE
[16:12:29.401]                             break
[16:12:29.401]                           }
[16:12:29.401]                         }
[16:12:29.401]                       }
[16:12:29.401]                       invisible(muffled)
[16:12:29.401]                     }
[16:12:29.401]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.401]                   }
[16:12:29.401]                 }
[16:12:29.401]             }
[16:12:29.401]         }))
[16:12:29.401]     }, error = function(ex) {
[16:12:29.401]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.401]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.401]                 ...future.rng), started = ...future.startTime, 
[16:12:29.401]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.401]             version = "1.8"), class = "FutureResult")
[16:12:29.401]     }, finally = {
[16:12:29.401]         if (!identical(...future.workdir, getwd())) 
[16:12:29.401]             setwd(...future.workdir)
[16:12:29.401]         {
[16:12:29.401]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.401]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.401]             }
[16:12:29.401]             base::options(...future.oldOptions)
[16:12:29.401]             if (.Platform$OS.type == "windows") {
[16:12:29.401]                 old_names <- names(...future.oldEnvVars)
[16:12:29.401]                 envs <- base::Sys.getenv()
[16:12:29.401]                 names <- names(envs)
[16:12:29.401]                 common <- intersect(names, old_names)
[16:12:29.401]                 added <- setdiff(names, old_names)
[16:12:29.401]                 removed <- setdiff(old_names, names)
[16:12:29.401]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.401]                   envs[common]]
[16:12:29.401]                 NAMES <- toupper(changed)
[16:12:29.401]                 args <- list()
[16:12:29.401]                 for (kk in seq_along(NAMES)) {
[16:12:29.401]                   name <- changed[[kk]]
[16:12:29.401]                   NAME <- NAMES[[kk]]
[16:12:29.401]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.401]                     next
[16:12:29.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.401]                 }
[16:12:29.401]                 NAMES <- toupper(added)
[16:12:29.401]                 for (kk in seq_along(NAMES)) {
[16:12:29.401]                   name <- added[[kk]]
[16:12:29.401]                   NAME <- NAMES[[kk]]
[16:12:29.401]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.401]                     next
[16:12:29.401]                   args[[name]] <- ""
[16:12:29.401]                 }
[16:12:29.401]                 NAMES <- toupper(removed)
[16:12:29.401]                 for (kk in seq_along(NAMES)) {
[16:12:29.401]                   name <- removed[[kk]]
[16:12:29.401]                   NAME <- NAMES[[kk]]
[16:12:29.401]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.401]                     next
[16:12:29.401]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.401]                 }
[16:12:29.401]                 if (length(args) > 0) 
[16:12:29.401]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.401]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.401]             }
[16:12:29.401]             else {
[16:12:29.401]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.401]             }
[16:12:29.401]             {
[16:12:29.401]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.401]                   0L) {
[16:12:29.401]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.401]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.401]                   base::options(opts)
[16:12:29.401]                 }
[16:12:29.401]                 {
[16:12:29.401]                   {
[16:12:29.401]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.401]                     NULL
[16:12:29.401]                   }
[16:12:29.401]                   options(future.plan = NULL)
[16:12:29.401]                   if (is.na(NA_character_)) 
[16:12:29.401]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.401]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.401]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.401]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.401]                     envir = parent.frame()) 
[16:12:29.401]                   {
[16:12:29.401]                     if (is.function(workers)) 
[16:12:29.401]                       workers <- workers()
[16:12:29.401]                     workers <- structure(as.integer(workers), 
[16:12:29.401]                       class = class(workers))
[16:12:29.401]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.401]                       workers >= 1)
[16:12:29.401]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.401]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.401]                     }
[16:12:29.401]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.401]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.401]                       envir = envir)
[16:12:29.401]                     if (!future$lazy) 
[16:12:29.401]                       future <- run(future)
[16:12:29.401]                     invisible(future)
[16:12:29.401]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.401]                 }
[16:12:29.401]             }
[16:12:29.401]         }
[16:12:29.401]     })
[16:12:29.401]     if (TRUE) {
[16:12:29.401]         base::sink(type = "output", split = FALSE)
[16:12:29.401]         if (TRUE) {
[16:12:29.401]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.401]         }
[16:12:29.401]         else {
[16:12:29.401]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.401]         }
[16:12:29.401]         base::close(...future.stdout)
[16:12:29.401]         ...future.stdout <- NULL
[16:12:29.401]     }
[16:12:29.401]     ...future.result$conditions <- ...future.conditions
[16:12:29.401]     ...future.result$finished <- base::Sys.time()
[16:12:29.401]     ...future.result
[16:12:29.401] }
[16:12:29.471] MultisessionFuture started
[16:12:29.472] result() for ClusterFuture ...
[16:12:29.472] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.472] - Validating connection of MultisessionFuture
[16:12:29.504] - received message: FutureResult
[16:12:29.504] - Received FutureResult
[16:12:29.505] - Erased future from FutureRegistry
[16:12:29.505] result() for ClusterFuture ...
[16:12:29.505] - result already collected: FutureResult
[16:12:29.505] result() for ClusterFuture ... done
[16:12:29.505] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:29.505] result() for ClusterFuture ... done
[16:12:29.505] result() for ClusterFuture ...
[16:12:29.505] - result already collected: FutureResult
[16:12:29.505] result() for ClusterFuture ... done
[16:12:29.506] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:29.509] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:12:29.509] getGlobalsAndPackages() ...
[16:12:29.510] Searching for globals...
[16:12:29.510] 
[16:12:29.510] Searching for globals ... DONE
[16:12:29.510] - globals: [0] <none>
[16:12:29.510] getGlobalsAndPackages() ... DONE
[16:12:29.511] run() for ‘Future’ ...
[16:12:29.511] - state: ‘created’
[16:12:29.511] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.526]   - Field: ‘node’
[16:12:29.526]   - Field: ‘label’
[16:12:29.526]   - Field: ‘local’
[16:12:29.527]   - Field: ‘owner’
[16:12:29.527]   - Field: ‘envir’
[16:12:29.527]   - Field: ‘workers’
[16:12:29.527]   - Field: ‘packages’
[16:12:29.527]   - Field: ‘gc’
[16:12:29.527]   - Field: ‘conditions’
[16:12:29.527]   - Field: ‘persistent’
[16:12:29.527]   - Field: ‘expr’
[16:12:29.528]   - Field: ‘uuid’
[16:12:29.528]   - Field: ‘seed’
[16:12:29.528]   - Field: ‘version’
[16:12:29.528]   - Field: ‘result’
[16:12:29.528]   - Field: ‘asynchronous’
[16:12:29.528]   - Field: ‘calls’
[16:12:29.528]   - Field: ‘globals’
[16:12:29.528]   - Field: ‘stdout’
[16:12:29.528]   - Field: ‘earlySignal’
[16:12:29.529]   - Field: ‘lazy’
[16:12:29.529]   - Field: ‘state’
[16:12:29.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.529] - Launch lazy future ...
[16:12:29.529] Packages needed by the future expression (n = 0): <none>
[16:12:29.529] Packages needed by future strategies (n = 0): <none>
[16:12:29.530] {
[16:12:29.530]     {
[16:12:29.530]         {
[16:12:29.530]             ...future.startTime <- base::Sys.time()
[16:12:29.530]             {
[16:12:29.530]                 {
[16:12:29.530]                   {
[16:12:29.530]                     {
[16:12:29.530]                       base::local({
[16:12:29.530]                         has_future <- base::requireNamespace("future", 
[16:12:29.530]                           quietly = TRUE)
[16:12:29.530]                         if (has_future) {
[16:12:29.530]                           ns <- base::getNamespace("future")
[16:12:29.530]                           version <- ns[[".package"]][["version"]]
[16:12:29.530]                           if (is.null(version)) 
[16:12:29.530]                             version <- utils::packageVersion("future")
[16:12:29.530]                         }
[16:12:29.530]                         else {
[16:12:29.530]                           version <- NULL
[16:12:29.530]                         }
[16:12:29.530]                         if (!has_future || version < "1.8.0") {
[16:12:29.530]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.530]                             "", base::R.version$version.string), 
[16:12:29.530]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.530]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.530]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.530]                               "release", "version")], collapse = " "), 
[16:12:29.530]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.530]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.530]                             info)
[16:12:29.530]                           info <- base::paste(info, collapse = "; ")
[16:12:29.530]                           if (!has_future) {
[16:12:29.530]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.530]                               info)
[16:12:29.530]                           }
[16:12:29.530]                           else {
[16:12:29.530]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.530]                               info, version)
[16:12:29.530]                           }
[16:12:29.530]                           base::stop(msg)
[16:12:29.530]                         }
[16:12:29.530]                       })
[16:12:29.530]                     }
[16:12:29.530]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.530]                     base::options(mc.cores = 1L)
[16:12:29.530]                   }
[16:12:29.530]                   options(future.plan = NULL)
[16:12:29.530]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.530]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.530]                 }
[16:12:29.530]                 ...future.workdir <- getwd()
[16:12:29.530]             }
[16:12:29.530]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.530]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.530]         }
[16:12:29.530]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.530]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.530]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.530]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.530]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.530]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.530]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.530]             base::names(...future.oldOptions))
[16:12:29.530]     }
[16:12:29.530]     if (FALSE) {
[16:12:29.530]     }
[16:12:29.530]     else {
[16:12:29.530]         if (TRUE) {
[16:12:29.530]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.530]                 open = "w")
[16:12:29.530]         }
[16:12:29.530]         else {
[16:12:29.530]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.530]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.530]         }
[16:12:29.530]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.530]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.530]             base::sink(type = "output", split = FALSE)
[16:12:29.530]             base::close(...future.stdout)
[16:12:29.530]         }, add = TRUE)
[16:12:29.530]     }
[16:12:29.530]     ...future.frame <- base::sys.nframe()
[16:12:29.530]     ...future.conditions <- base::list()
[16:12:29.530]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.530]     if (FALSE) {
[16:12:29.530]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.530]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.530]     }
[16:12:29.530]     ...future.result <- base::tryCatch({
[16:12:29.530]         base::withCallingHandlers({
[16:12:29.530]             ...future.value <- base::withVisible(base::local({
[16:12:29.530]                 ...future.makeSendCondition <- local({
[16:12:29.530]                   sendCondition <- NULL
[16:12:29.530]                   function(frame = 1L) {
[16:12:29.530]                     if (is.function(sendCondition)) 
[16:12:29.530]                       return(sendCondition)
[16:12:29.530]                     ns <- getNamespace("parallel")
[16:12:29.530]                     if (exists("sendData", mode = "function", 
[16:12:29.530]                       envir = ns)) {
[16:12:29.530]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.530]                         envir = ns)
[16:12:29.530]                       envir <- sys.frame(frame)
[16:12:29.530]                       master <- NULL
[16:12:29.530]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.530]                         !identical(envir, emptyenv())) {
[16:12:29.530]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.530]                           inherits = FALSE)) {
[16:12:29.530]                           master <- get("master", mode = "list", 
[16:12:29.530]                             envir = envir, inherits = FALSE)
[16:12:29.530]                           if (inherits(master, c("SOCKnode", 
[16:12:29.530]                             "SOCK0node"))) {
[16:12:29.530]                             sendCondition <<- function(cond) {
[16:12:29.530]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.530]                                 success = TRUE)
[16:12:29.530]                               parallel_sendData(master, data)
[16:12:29.530]                             }
[16:12:29.530]                             return(sendCondition)
[16:12:29.530]                           }
[16:12:29.530]                         }
[16:12:29.530]                         frame <- frame + 1L
[16:12:29.530]                         envir <- sys.frame(frame)
[16:12:29.530]                       }
[16:12:29.530]                     }
[16:12:29.530]                     sendCondition <<- function(cond) NULL
[16:12:29.530]                   }
[16:12:29.530]                 })
[16:12:29.530]                 withCallingHandlers({
[16:12:29.530]                   2
[16:12:29.530]                 }, immediateCondition = function(cond) {
[16:12:29.530]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.530]                   sendCondition(cond)
[16:12:29.530]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.530]                   {
[16:12:29.530]                     inherits <- base::inherits
[16:12:29.530]                     invokeRestart <- base::invokeRestart
[16:12:29.530]                     is.null <- base::is.null
[16:12:29.530]                     muffled <- FALSE
[16:12:29.530]                     if (inherits(cond, "message")) {
[16:12:29.530]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.530]                       if (muffled) 
[16:12:29.530]                         invokeRestart("muffleMessage")
[16:12:29.530]                     }
[16:12:29.530]                     else if (inherits(cond, "warning")) {
[16:12:29.530]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.530]                       if (muffled) 
[16:12:29.530]                         invokeRestart("muffleWarning")
[16:12:29.530]                     }
[16:12:29.530]                     else if (inherits(cond, "condition")) {
[16:12:29.530]                       if (!is.null(pattern)) {
[16:12:29.530]                         computeRestarts <- base::computeRestarts
[16:12:29.530]                         grepl <- base::grepl
[16:12:29.530]                         restarts <- computeRestarts(cond)
[16:12:29.530]                         for (restart in restarts) {
[16:12:29.530]                           name <- restart$name
[16:12:29.530]                           if (is.null(name)) 
[16:12:29.530]                             next
[16:12:29.530]                           if (!grepl(pattern, name)) 
[16:12:29.530]                             next
[16:12:29.530]                           invokeRestart(restart)
[16:12:29.530]                           muffled <- TRUE
[16:12:29.530]                           break
[16:12:29.530]                         }
[16:12:29.530]                       }
[16:12:29.530]                     }
[16:12:29.530]                     invisible(muffled)
[16:12:29.530]                   }
[16:12:29.530]                   muffleCondition(cond)
[16:12:29.530]                 })
[16:12:29.530]             }))
[16:12:29.530]             future::FutureResult(value = ...future.value$value, 
[16:12:29.530]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.530]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.530]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.530]                     ...future.globalenv.names))
[16:12:29.530]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.530]         }, condition = base::local({
[16:12:29.530]             c <- base::c
[16:12:29.530]             inherits <- base::inherits
[16:12:29.530]             invokeRestart <- base::invokeRestart
[16:12:29.530]             length <- base::length
[16:12:29.530]             list <- base::list
[16:12:29.530]             seq.int <- base::seq.int
[16:12:29.530]             signalCondition <- base::signalCondition
[16:12:29.530]             sys.calls <- base::sys.calls
[16:12:29.530]             `[[` <- base::`[[`
[16:12:29.530]             `+` <- base::`+`
[16:12:29.530]             `<<-` <- base::`<<-`
[16:12:29.530]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.530]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.530]                   3L)]
[16:12:29.530]             }
[16:12:29.530]             function(cond) {
[16:12:29.530]                 is_error <- inherits(cond, "error")
[16:12:29.530]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.530]                   NULL)
[16:12:29.530]                 if (is_error) {
[16:12:29.530]                   sessionInformation <- function() {
[16:12:29.530]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.530]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.530]                       search = base::search(), system = base::Sys.info())
[16:12:29.530]                   }
[16:12:29.530]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.530]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.530]                     cond$call), session = sessionInformation(), 
[16:12:29.530]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.530]                   signalCondition(cond)
[16:12:29.530]                 }
[16:12:29.530]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.530]                 "immediateCondition"))) {
[16:12:29.530]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.530]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.530]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.530]                   if (TRUE && !signal) {
[16:12:29.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.530]                     {
[16:12:29.530]                       inherits <- base::inherits
[16:12:29.530]                       invokeRestart <- base::invokeRestart
[16:12:29.530]                       is.null <- base::is.null
[16:12:29.530]                       muffled <- FALSE
[16:12:29.530]                       if (inherits(cond, "message")) {
[16:12:29.530]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.530]                         if (muffled) 
[16:12:29.530]                           invokeRestart("muffleMessage")
[16:12:29.530]                       }
[16:12:29.530]                       else if (inherits(cond, "warning")) {
[16:12:29.530]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.530]                         if (muffled) 
[16:12:29.530]                           invokeRestart("muffleWarning")
[16:12:29.530]                       }
[16:12:29.530]                       else if (inherits(cond, "condition")) {
[16:12:29.530]                         if (!is.null(pattern)) {
[16:12:29.530]                           computeRestarts <- base::computeRestarts
[16:12:29.530]                           grepl <- base::grepl
[16:12:29.530]                           restarts <- computeRestarts(cond)
[16:12:29.530]                           for (restart in restarts) {
[16:12:29.530]                             name <- restart$name
[16:12:29.530]                             if (is.null(name)) 
[16:12:29.530]                               next
[16:12:29.530]                             if (!grepl(pattern, name)) 
[16:12:29.530]                               next
[16:12:29.530]                             invokeRestart(restart)
[16:12:29.530]                             muffled <- TRUE
[16:12:29.530]                             break
[16:12:29.530]                           }
[16:12:29.530]                         }
[16:12:29.530]                       }
[16:12:29.530]                       invisible(muffled)
[16:12:29.530]                     }
[16:12:29.530]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.530]                   }
[16:12:29.530]                 }
[16:12:29.530]                 else {
[16:12:29.530]                   if (TRUE) {
[16:12:29.530]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.530]                     {
[16:12:29.530]                       inherits <- base::inherits
[16:12:29.530]                       invokeRestart <- base::invokeRestart
[16:12:29.530]                       is.null <- base::is.null
[16:12:29.530]                       muffled <- FALSE
[16:12:29.530]                       if (inherits(cond, "message")) {
[16:12:29.530]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.530]                         if (muffled) 
[16:12:29.530]                           invokeRestart("muffleMessage")
[16:12:29.530]                       }
[16:12:29.530]                       else if (inherits(cond, "warning")) {
[16:12:29.530]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.530]                         if (muffled) 
[16:12:29.530]                           invokeRestart("muffleWarning")
[16:12:29.530]                       }
[16:12:29.530]                       else if (inherits(cond, "condition")) {
[16:12:29.530]                         if (!is.null(pattern)) {
[16:12:29.530]                           computeRestarts <- base::computeRestarts
[16:12:29.530]                           grepl <- base::grepl
[16:12:29.530]                           restarts <- computeRestarts(cond)
[16:12:29.530]                           for (restart in restarts) {
[16:12:29.530]                             name <- restart$name
[16:12:29.530]                             if (is.null(name)) 
[16:12:29.530]                               next
[16:12:29.530]                             if (!grepl(pattern, name)) 
[16:12:29.530]                               next
[16:12:29.530]                             invokeRestart(restart)
[16:12:29.530]                             muffled <- TRUE
[16:12:29.530]                             break
[16:12:29.530]                           }
[16:12:29.530]                         }
[16:12:29.530]                       }
[16:12:29.530]                       invisible(muffled)
[16:12:29.530]                     }
[16:12:29.530]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.530]                   }
[16:12:29.530]                 }
[16:12:29.530]             }
[16:12:29.530]         }))
[16:12:29.530]     }, error = function(ex) {
[16:12:29.530]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.530]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.530]                 ...future.rng), started = ...future.startTime, 
[16:12:29.530]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.530]             version = "1.8"), class = "FutureResult")
[16:12:29.530]     }, finally = {
[16:12:29.530]         if (!identical(...future.workdir, getwd())) 
[16:12:29.530]             setwd(...future.workdir)
[16:12:29.530]         {
[16:12:29.530]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.530]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.530]             }
[16:12:29.530]             base::options(...future.oldOptions)
[16:12:29.530]             if (.Platform$OS.type == "windows") {
[16:12:29.530]                 old_names <- names(...future.oldEnvVars)
[16:12:29.530]                 envs <- base::Sys.getenv()
[16:12:29.530]                 names <- names(envs)
[16:12:29.530]                 common <- intersect(names, old_names)
[16:12:29.530]                 added <- setdiff(names, old_names)
[16:12:29.530]                 removed <- setdiff(old_names, names)
[16:12:29.530]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.530]                   envs[common]]
[16:12:29.530]                 NAMES <- toupper(changed)
[16:12:29.530]                 args <- list()
[16:12:29.530]                 for (kk in seq_along(NAMES)) {
[16:12:29.530]                   name <- changed[[kk]]
[16:12:29.530]                   NAME <- NAMES[[kk]]
[16:12:29.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.530]                     next
[16:12:29.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.530]                 }
[16:12:29.530]                 NAMES <- toupper(added)
[16:12:29.530]                 for (kk in seq_along(NAMES)) {
[16:12:29.530]                   name <- added[[kk]]
[16:12:29.530]                   NAME <- NAMES[[kk]]
[16:12:29.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.530]                     next
[16:12:29.530]                   args[[name]] <- ""
[16:12:29.530]                 }
[16:12:29.530]                 NAMES <- toupper(removed)
[16:12:29.530]                 for (kk in seq_along(NAMES)) {
[16:12:29.530]                   name <- removed[[kk]]
[16:12:29.530]                   NAME <- NAMES[[kk]]
[16:12:29.530]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.530]                     next
[16:12:29.530]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.530]                 }
[16:12:29.530]                 if (length(args) > 0) 
[16:12:29.530]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.530]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.530]             }
[16:12:29.530]             else {
[16:12:29.530]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.530]             }
[16:12:29.530]             {
[16:12:29.530]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.530]                   0L) {
[16:12:29.530]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.530]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.530]                   base::options(opts)
[16:12:29.530]                 }
[16:12:29.530]                 {
[16:12:29.530]                   {
[16:12:29.530]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.530]                     NULL
[16:12:29.530]                   }
[16:12:29.530]                   options(future.plan = NULL)
[16:12:29.530]                   if (is.na(NA_character_)) 
[16:12:29.530]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.530]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.530]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.530]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.530]                     envir = parent.frame()) 
[16:12:29.530]                   {
[16:12:29.530]                     if (is.function(workers)) 
[16:12:29.530]                       workers <- workers()
[16:12:29.530]                     workers <- structure(as.integer(workers), 
[16:12:29.530]                       class = class(workers))
[16:12:29.530]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.530]                       workers >= 1)
[16:12:29.530]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.530]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.530]                     }
[16:12:29.530]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.530]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.530]                       envir = envir)
[16:12:29.530]                     if (!future$lazy) 
[16:12:29.530]                       future <- run(future)
[16:12:29.530]                     invisible(future)
[16:12:29.530]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.530]                 }
[16:12:29.530]             }
[16:12:29.530]         }
[16:12:29.530]     })
[16:12:29.530]     if (TRUE) {
[16:12:29.530]         base::sink(type = "output", split = FALSE)
[16:12:29.530]         if (TRUE) {
[16:12:29.530]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.530]         }
[16:12:29.530]         else {
[16:12:29.530]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.530]         }
[16:12:29.530]         base::close(...future.stdout)
[16:12:29.530]         ...future.stdout <- NULL
[16:12:29.530]     }
[16:12:29.530]     ...future.result$conditions <- ...future.conditions
[16:12:29.530]     ...future.result$finished <- base::Sys.time()
[16:12:29.530]     ...future.result
[16:12:29.530] }
[16:12:29.533] MultisessionFuture started
[16:12:29.533] - Launch lazy future ... done
[16:12:29.534] run() for ‘MultisessionFuture’ ... done
[16:12:29.534] getGlobalsAndPackages() ...
[16:12:29.534] Searching for globals...
[16:12:29.534] 
[16:12:29.534] Searching for globals ... DONE
[16:12:29.535] - globals: [0] <none>
[16:12:29.535] getGlobalsAndPackages() ... DONE
[16:12:29.535] run() for ‘Future’ ...
[16:12:29.535] - state: ‘created’
[16:12:29.535] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.550] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.550]   - Field: ‘node’
[16:12:29.550]   - Field: ‘label’
[16:12:29.550]   - Field: ‘local’
[16:12:29.551]   - Field: ‘owner’
[16:12:29.551]   - Field: ‘envir’
[16:12:29.551]   - Field: ‘workers’
[16:12:29.551]   - Field: ‘packages’
[16:12:29.551]   - Field: ‘gc’
[16:12:29.551]   - Field: ‘conditions’
[16:12:29.551]   - Field: ‘persistent’
[16:12:29.551]   - Field: ‘expr’
[16:12:29.551]   - Field: ‘uuid’
[16:12:29.552]   - Field: ‘seed’
[16:12:29.552]   - Field: ‘version’
[16:12:29.552]   - Field: ‘result’
[16:12:29.552]   - Field: ‘asynchronous’
[16:12:29.552]   - Field: ‘calls’
[16:12:29.552]   - Field: ‘globals’
[16:12:29.552]   - Field: ‘stdout’
[16:12:29.552]   - Field: ‘earlySignal’
[16:12:29.552]   - Field: ‘lazy’
[16:12:29.553]   - Field: ‘state’
[16:12:29.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.553] - Launch lazy future ...
[16:12:29.553] Packages needed by the future expression (n = 0): <none>
[16:12:29.553] Packages needed by future strategies (n = 0): <none>
[16:12:29.556] {
[16:12:29.556]     {
[16:12:29.556]         {
[16:12:29.556]             ...future.startTime <- base::Sys.time()
[16:12:29.556]             {
[16:12:29.556]                 {
[16:12:29.556]                   {
[16:12:29.556]                     {
[16:12:29.556]                       base::local({
[16:12:29.556]                         has_future <- base::requireNamespace("future", 
[16:12:29.556]                           quietly = TRUE)
[16:12:29.556]                         if (has_future) {
[16:12:29.556]                           ns <- base::getNamespace("future")
[16:12:29.556]                           version <- ns[[".package"]][["version"]]
[16:12:29.556]                           if (is.null(version)) 
[16:12:29.556]                             version <- utils::packageVersion("future")
[16:12:29.556]                         }
[16:12:29.556]                         else {
[16:12:29.556]                           version <- NULL
[16:12:29.556]                         }
[16:12:29.556]                         if (!has_future || version < "1.8.0") {
[16:12:29.556]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.556]                             "", base::R.version$version.string), 
[16:12:29.556]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.556]                               "release", "version")], collapse = " "), 
[16:12:29.556]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.556]                             info)
[16:12:29.556]                           info <- base::paste(info, collapse = "; ")
[16:12:29.556]                           if (!has_future) {
[16:12:29.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.556]                               info)
[16:12:29.556]                           }
[16:12:29.556]                           else {
[16:12:29.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.556]                               info, version)
[16:12:29.556]                           }
[16:12:29.556]                           base::stop(msg)
[16:12:29.556]                         }
[16:12:29.556]                       })
[16:12:29.556]                     }
[16:12:29.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.556]                     base::options(mc.cores = 1L)
[16:12:29.556]                   }
[16:12:29.556]                   options(future.plan = NULL)
[16:12:29.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.556]                 }
[16:12:29.556]                 ...future.workdir <- getwd()
[16:12:29.556]             }
[16:12:29.556]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.556]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.556]         }
[16:12:29.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.556]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.556]             base::names(...future.oldOptions))
[16:12:29.556]     }
[16:12:29.556]     if (FALSE) {
[16:12:29.556]     }
[16:12:29.556]     else {
[16:12:29.556]         if (TRUE) {
[16:12:29.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.556]                 open = "w")
[16:12:29.556]         }
[16:12:29.556]         else {
[16:12:29.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.556]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.556]         }
[16:12:29.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.556]             base::sink(type = "output", split = FALSE)
[16:12:29.556]             base::close(...future.stdout)
[16:12:29.556]         }, add = TRUE)
[16:12:29.556]     }
[16:12:29.556]     ...future.frame <- base::sys.nframe()
[16:12:29.556]     ...future.conditions <- base::list()
[16:12:29.556]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.556]     if (FALSE) {
[16:12:29.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.556]     }
[16:12:29.556]     ...future.result <- base::tryCatch({
[16:12:29.556]         base::withCallingHandlers({
[16:12:29.556]             ...future.value <- base::withVisible(base::local({
[16:12:29.556]                 ...future.makeSendCondition <- local({
[16:12:29.556]                   sendCondition <- NULL
[16:12:29.556]                   function(frame = 1L) {
[16:12:29.556]                     if (is.function(sendCondition)) 
[16:12:29.556]                       return(sendCondition)
[16:12:29.556]                     ns <- getNamespace("parallel")
[16:12:29.556]                     if (exists("sendData", mode = "function", 
[16:12:29.556]                       envir = ns)) {
[16:12:29.556]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.556]                         envir = ns)
[16:12:29.556]                       envir <- sys.frame(frame)
[16:12:29.556]                       master <- NULL
[16:12:29.556]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.556]                         !identical(envir, emptyenv())) {
[16:12:29.556]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.556]                           inherits = FALSE)) {
[16:12:29.556]                           master <- get("master", mode = "list", 
[16:12:29.556]                             envir = envir, inherits = FALSE)
[16:12:29.556]                           if (inherits(master, c("SOCKnode", 
[16:12:29.556]                             "SOCK0node"))) {
[16:12:29.556]                             sendCondition <<- function(cond) {
[16:12:29.556]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.556]                                 success = TRUE)
[16:12:29.556]                               parallel_sendData(master, data)
[16:12:29.556]                             }
[16:12:29.556]                             return(sendCondition)
[16:12:29.556]                           }
[16:12:29.556]                         }
[16:12:29.556]                         frame <- frame + 1L
[16:12:29.556]                         envir <- sys.frame(frame)
[16:12:29.556]                       }
[16:12:29.556]                     }
[16:12:29.556]                     sendCondition <<- function(cond) NULL
[16:12:29.556]                   }
[16:12:29.556]                 })
[16:12:29.556]                 withCallingHandlers({
[16:12:29.556]                   NULL
[16:12:29.556]                 }, immediateCondition = function(cond) {
[16:12:29.556]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.556]                   sendCondition(cond)
[16:12:29.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.556]                   {
[16:12:29.556]                     inherits <- base::inherits
[16:12:29.556]                     invokeRestart <- base::invokeRestart
[16:12:29.556]                     is.null <- base::is.null
[16:12:29.556]                     muffled <- FALSE
[16:12:29.556]                     if (inherits(cond, "message")) {
[16:12:29.556]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.556]                       if (muffled) 
[16:12:29.556]                         invokeRestart("muffleMessage")
[16:12:29.556]                     }
[16:12:29.556]                     else if (inherits(cond, "warning")) {
[16:12:29.556]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.556]                       if (muffled) 
[16:12:29.556]                         invokeRestart("muffleWarning")
[16:12:29.556]                     }
[16:12:29.556]                     else if (inherits(cond, "condition")) {
[16:12:29.556]                       if (!is.null(pattern)) {
[16:12:29.556]                         computeRestarts <- base::computeRestarts
[16:12:29.556]                         grepl <- base::grepl
[16:12:29.556]                         restarts <- computeRestarts(cond)
[16:12:29.556]                         for (restart in restarts) {
[16:12:29.556]                           name <- restart$name
[16:12:29.556]                           if (is.null(name)) 
[16:12:29.556]                             next
[16:12:29.556]                           if (!grepl(pattern, name)) 
[16:12:29.556]                             next
[16:12:29.556]                           invokeRestart(restart)
[16:12:29.556]                           muffled <- TRUE
[16:12:29.556]                           break
[16:12:29.556]                         }
[16:12:29.556]                       }
[16:12:29.556]                     }
[16:12:29.556]                     invisible(muffled)
[16:12:29.556]                   }
[16:12:29.556]                   muffleCondition(cond)
[16:12:29.556]                 })
[16:12:29.556]             }))
[16:12:29.556]             future::FutureResult(value = ...future.value$value, 
[16:12:29.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.556]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.556]                     ...future.globalenv.names))
[16:12:29.556]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.556]         }, condition = base::local({
[16:12:29.556]             c <- base::c
[16:12:29.556]             inherits <- base::inherits
[16:12:29.556]             invokeRestart <- base::invokeRestart
[16:12:29.556]             length <- base::length
[16:12:29.556]             list <- base::list
[16:12:29.556]             seq.int <- base::seq.int
[16:12:29.556]             signalCondition <- base::signalCondition
[16:12:29.556]             sys.calls <- base::sys.calls
[16:12:29.556]             `[[` <- base::`[[`
[16:12:29.556]             `+` <- base::`+`
[16:12:29.556]             `<<-` <- base::`<<-`
[16:12:29.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.556]                   3L)]
[16:12:29.556]             }
[16:12:29.556]             function(cond) {
[16:12:29.556]                 is_error <- inherits(cond, "error")
[16:12:29.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.556]                   NULL)
[16:12:29.556]                 if (is_error) {
[16:12:29.556]                   sessionInformation <- function() {
[16:12:29.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.556]                       search = base::search(), system = base::Sys.info())
[16:12:29.556]                   }
[16:12:29.556]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.556]                     cond$call), session = sessionInformation(), 
[16:12:29.556]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.556]                   signalCondition(cond)
[16:12:29.556]                 }
[16:12:29.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.556]                 "immediateCondition"))) {
[16:12:29.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.556]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.556]                   if (TRUE && !signal) {
[16:12:29.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.556]                     {
[16:12:29.556]                       inherits <- base::inherits
[16:12:29.556]                       invokeRestart <- base::invokeRestart
[16:12:29.556]                       is.null <- base::is.null
[16:12:29.556]                       muffled <- FALSE
[16:12:29.556]                       if (inherits(cond, "message")) {
[16:12:29.556]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.556]                         if (muffled) 
[16:12:29.556]                           invokeRestart("muffleMessage")
[16:12:29.556]                       }
[16:12:29.556]                       else if (inherits(cond, "warning")) {
[16:12:29.556]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.556]                         if (muffled) 
[16:12:29.556]                           invokeRestart("muffleWarning")
[16:12:29.556]                       }
[16:12:29.556]                       else if (inherits(cond, "condition")) {
[16:12:29.556]                         if (!is.null(pattern)) {
[16:12:29.556]                           computeRestarts <- base::computeRestarts
[16:12:29.556]                           grepl <- base::grepl
[16:12:29.556]                           restarts <- computeRestarts(cond)
[16:12:29.556]                           for (restart in restarts) {
[16:12:29.556]                             name <- restart$name
[16:12:29.556]                             if (is.null(name)) 
[16:12:29.556]                               next
[16:12:29.556]                             if (!grepl(pattern, name)) 
[16:12:29.556]                               next
[16:12:29.556]                             invokeRestart(restart)
[16:12:29.556]                             muffled <- TRUE
[16:12:29.556]                             break
[16:12:29.556]                           }
[16:12:29.556]                         }
[16:12:29.556]                       }
[16:12:29.556]                       invisible(muffled)
[16:12:29.556]                     }
[16:12:29.556]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.556]                   }
[16:12:29.556]                 }
[16:12:29.556]                 else {
[16:12:29.556]                   if (TRUE) {
[16:12:29.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.556]                     {
[16:12:29.556]                       inherits <- base::inherits
[16:12:29.556]                       invokeRestart <- base::invokeRestart
[16:12:29.556]                       is.null <- base::is.null
[16:12:29.556]                       muffled <- FALSE
[16:12:29.556]                       if (inherits(cond, "message")) {
[16:12:29.556]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.556]                         if (muffled) 
[16:12:29.556]                           invokeRestart("muffleMessage")
[16:12:29.556]                       }
[16:12:29.556]                       else if (inherits(cond, "warning")) {
[16:12:29.556]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.556]                         if (muffled) 
[16:12:29.556]                           invokeRestart("muffleWarning")
[16:12:29.556]                       }
[16:12:29.556]                       else if (inherits(cond, "condition")) {
[16:12:29.556]                         if (!is.null(pattern)) {
[16:12:29.556]                           computeRestarts <- base::computeRestarts
[16:12:29.556]                           grepl <- base::grepl
[16:12:29.556]                           restarts <- computeRestarts(cond)
[16:12:29.556]                           for (restart in restarts) {
[16:12:29.556]                             name <- restart$name
[16:12:29.556]                             if (is.null(name)) 
[16:12:29.556]                               next
[16:12:29.556]                             if (!grepl(pattern, name)) 
[16:12:29.556]                               next
[16:12:29.556]                             invokeRestart(restart)
[16:12:29.556]                             muffled <- TRUE
[16:12:29.556]                             break
[16:12:29.556]                           }
[16:12:29.556]                         }
[16:12:29.556]                       }
[16:12:29.556]                       invisible(muffled)
[16:12:29.556]                     }
[16:12:29.556]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.556]                   }
[16:12:29.556]                 }
[16:12:29.556]             }
[16:12:29.556]         }))
[16:12:29.556]     }, error = function(ex) {
[16:12:29.556]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.556]                 ...future.rng), started = ...future.startTime, 
[16:12:29.556]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.556]             version = "1.8"), class = "FutureResult")
[16:12:29.556]     }, finally = {
[16:12:29.556]         if (!identical(...future.workdir, getwd())) 
[16:12:29.556]             setwd(...future.workdir)
[16:12:29.556]         {
[16:12:29.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.556]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.556]             }
[16:12:29.556]             base::options(...future.oldOptions)
[16:12:29.556]             if (.Platform$OS.type == "windows") {
[16:12:29.556]                 old_names <- names(...future.oldEnvVars)
[16:12:29.556]                 envs <- base::Sys.getenv()
[16:12:29.556]                 names <- names(envs)
[16:12:29.556]                 common <- intersect(names, old_names)
[16:12:29.556]                 added <- setdiff(names, old_names)
[16:12:29.556]                 removed <- setdiff(old_names, names)
[16:12:29.556]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.556]                   envs[common]]
[16:12:29.556]                 NAMES <- toupper(changed)
[16:12:29.556]                 args <- list()
[16:12:29.556]                 for (kk in seq_along(NAMES)) {
[16:12:29.556]                   name <- changed[[kk]]
[16:12:29.556]                   NAME <- NAMES[[kk]]
[16:12:29.556]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.556]                     next
[16:12:29.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.556]                 }
[16:12:29.556]                 NAMES <- toupper(added)
[16:12:29.556]                 for (kk in seq_along(NAMES)) {
[16:12:29.556]                   name <- added[[kk]]
[16:12:29.556]                   NAME <- NAMES[[kk]]
[16:12:29.556]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.556]                     next
[16:12:29.556]                   args[[name]] <- ""
[16:12:29.556]                 }
[16:12:29.556]                 NAMES <- toupper(removed)
[16:12:29.556]                 for (kk in seq_along(NAMES)) {
[16:12:29.556]                   name <- removed[[kk]]
[16:12:29.556]                   NAME <- NAMES[[kk]]
[16:12:29.556]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.556]                     next
[16:12:29.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.556]                 }
[16:12:29.556]                 if (length(args) > 0) 
[16:12:29.556]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.556]             }
[16:12:29.556]             else {
[16:12:29.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.556]             }
[16:12:29.556]             {
[16:12:29.556]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.556]                   0L) {
[16:12:29.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.556]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.556]                   base::options(opts)
[16:12:29.556]                 }
[16:12:29.556]                 {
[16:12:29.556]                   {
[16:12:29.556]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.556]                     NULL
[16:12:29.556]                   }
[16:12:29.556]                   options(future.plan = NULL)
[16:12:29.556]                   if (is.na(NA_character_)) 
[16:12:29.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.556]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.556]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.556]                     envir = parent.frame()) 
[16:12:29.556]                   {
[16:12:29.556]                     if (is.function(workers)) 
[16:12:29.556]                       workers <- workers()
[16:12:29.556]                     workers <- structure(as.integer(workers), 
[16:12:29.556]                       class = class(workers))
[16:12:29.556]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.556]                       workers >= 1)
[16:12:29.556]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.556]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.556]                     }
[16:12:29.556]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.556]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.556]                       envir = envir)
[16:12:29.556]                     if (!future$lazy) 
[16:12:29.556]                       future <- run(future)
[16:12:29.556]                     invisible(future)
[16:12:29.556]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.556]                 }
[16:12:29.556]             }
[16:12:29.556]         }
[16:12:29.556]     })
[16:12:29.556]     if (TRUE) {
[16:12:29.556]         base::sink(type = "output", split = FALSE)
[16:12:29.556]         if (TRUE) {
[16:12:29.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.556]         }
[16:12:29.556]         else {
[16:12:29.556]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.556]         }
[16:12:29.556]         base::close(...future.stdout)
[16:12:29.556]         ...future.stdout <- NULL
[16:12:29.556]     }
[16:12:29.556]     ...future.result$conditions <- ...future.conditions
[16:12:29.556]     ...future.result$finished <- base::Sys.time()
[16:12:29.556]     ...future.result
[16:12:29.556] }
[16:12:29.630] MultisessionFuture started
[16:12:29.631] - Launch lazy future ... done
[16:12:29.631] run() for ‘MultisessionFuture’ ... done
[16:12:29.631] getGlobalsAndPackages() ...
[16:12:29.631] Searching for globals...
[16:12:29.632] - globals found: [1] ‘{’
[16:12:29.632] Searching for globals ... DONE
[16:12:29.632] Resolving globals: FALSE
[16:12:29.633] 
[16:12:29.633] 
[16:12:29.633] getGlobalsAndPackages() ... DONE
[16:12:29.633] run() for ‘Future’ ...
[16:12:29.633] - state: ‘created’
[16:12:29.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.648] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.649] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.649]   - Field: ‘node’
[16:12:29.649]   - Field: ‘label’
[16:12:29.649]   - Field: ‘local’
[16:12:29.649]   - Field: ‘owner’
[16:12:29.649]   - Field: ‘envir’
[16:12:29.649]   - Field: ‘workers’
[16:12:29.649]   - Field: ‘packages’
[16:12:29.650]   - Field: ‘gc’
[16:12:29.650]   - Field: ‘conditions’
[16:12:29.650]   - Field: ‘persistent’
[16:12:29.650]   - Field: ‘expr’
[16:12:29.650]   - Field: ‘uuid’
[16:12:29.650]   - Field: ‘seed’
[16:12:29.650]   - Field: ‘version’
[16:12:29.650]   - Field: ‘result’
[16:12:29.650]   - Field: ‘asynchronous’
[16:12:29.650]   - Field: ‘calls’
[16:12:29.651]   - Field: ‘globals’
[16:12:29.651]   - Field: ‘stdout’
[16:12:29.651]   - Field: ‘earlySignal’
[16:12:29.651]   - Field: ‘lazy’
[16:12:29.651]   - Field: ‘state’
[16:12:29.651] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.651] - Launch lazy future ...
[16:12:29.651] Packages needed by the future expression (n = 0): <none>
[16:12:29.652] Packages needed by future strategies (n = 0): <none>
[16:12:29.652] {
[16:12:29.652]     {
[16:12:29.652]         {
[16:12:29.652]             ...future.startTime <- base::Sys.time()
[16:12:29.652]             {
[16:12:29.652]                 {
[16:12:29.652]                   {
[16:12:29.652]                     {
[16:12:29.652]                       base::local({
[16:12:29.652]                         has_future <- base::requireNamespace("future", 
[16:12:29.652]                           quietly = TRUE)
[16:12:29.652]                         if (has_future) {
[16:12:29.652]                           ns <- base::getNamespace("future")
[16:12:29.652]                           version <- ns[[".package"]][["version"]]
[16:12:29.652]                           if (is.null(version)) 
[16:12:29.652]                             version <- utils::packageVersion("future")
[16:12:29.652]                         }
[16:12:29.652]                         else {
[16:12:29.652]                           version <- NULL
[16:12:29.652]                         }
[16:12:29.652]                         if (!has_future || version < "1.8.0") {
[16:12:29.652]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.652]                             "", base::R.version$version.string), 
[16:12:29.652]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.652]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.652]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.652]                               "release", "version")], collapse = " "), 
[16:12:29.652]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.652]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.652]                             info)
[16:12:29.652]                           info <- base::paste(info, collapse = "; ")
[16:12:29.652]                           if (!has_future) {
[16:12:29.652]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.652]                               info)
[16:12:29.652]                           }
[16:12:29.652]                           else {
[16:12:29.652]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.652]                               info, version)
[16:12:29.652]                           }
[16:12:29.652]                           base::stop(msg)
[16:12:29.652]                         }
[16:12:29.652]                       })
[16:12:29.652]                     }
[16:12:29.652]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.652]                     base::options(mc.cores = 1L)
[16:12:29.652]                   }
[16:12:29.652]                   options(future.plan = NULL)
[16:12:29.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.652]                 }
[16:12:29.652]                 ...future.workdir <- getwd()
[16:12:29.652]             }
[16:12:29.652]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.652]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.652]         }
[16:12:29.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.652]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.652]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.652]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.652]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.652]             base::names(...future.oldOptions))
[16:12:29.652]     }
[16:12:29.652]     if (FALSE) {
[16:12:29.652]     }
[16:12:29.652]     else {
[16:12:29.652]         if (TRUE) {
[16:12:29.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.652]                 open = "w")
[16:12:29.652]         }
[16:12:29.652]         else {
[16:12:29.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.652]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.652]         }
[16:12:29.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.652]             base::sink(type = "output", split = FALSE)
[16:12:29.652]             base::close(...future.stdout)
[16:12:29.652]         }, add = TRUE)
[16:12:29.652]     }
[16:12:29.652]     ...future.frame <- base::sys.nframe()
[16:12:29.652]     ...future.conditions <- base::list()
[16:12:29.652]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.652]     if (FALSE) {
[16:12:29.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.652]     }
[16:12:29.652]     ...future.result <- base::tryCatch({
[16:12:29.652]         base::withCallingHandlers({
[16:12:29.652]             ...future.value <- base::withVisible(base::local({
[16:12:29.652]                 ...future.makeSendCondition <- local({
[16:12:29.652]                   sendCondition <- NULL
[16:12:29.652]                   function(frame = 1L) {
[16:12:29.652]                     if (is.function(sendCondition)) 
[16:12:29.652]                       return(sendCondition)
[16:12:29.652]                     ns <- getNamespace("parallel")
[16:12:29.652]                     if (exists("sendData", mode = "function", 
[16:12:29.652]                       envir = ns)) {
[16:12:29.652]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.652]                         envir = ns)
[16:12:29.652]                       envir <- sys.frame(frame)
[16:12:29.652]                       master <- NULL
[16:12:29.652]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.652]                         !identical(envir, emptyenv())) {
[16:12:29.652]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.652]                           inherits = FALSE)) {
[16:12:29.652]                           master <- get("master", mode = "list", 
[16:12:29.652]                             envir = envir, inherits = FALSE)
[16:12:29.652]                           if (inherits(master, c("SOCKnode", 
[16:12:29.652]                             "SOCK0node"))) {
[16:12:29.652]                             sendCondition <<- function(cond) {
[16:12:29.652]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.652]                                 success = TRUE)
[16:12:29.652]                               parallel_sendData(master, data)
[16:12:29.652]                             }
[16:12:29.652]                             return(sendCondition)
[16:12:29.652]                           }
[16:12:29.652]                         }
[16:12:29.652]                         frame <- frame + 1L
[16:12:29.652]                         envir <- sys.frame(frame)
[16:12:29.652]                       }
[16:12:29.652]                     }
[16:12:29.652]                     sendCondition <<- function(cond) NULL
[16:12:29.652]                   }
[16:12:29.652]                 })
[16:12:29.652]                 withCallingHandlers({
[16:12:29.652]                   {
[16:12:29.652]                     4
[16:12:29.652]                   }
[16:12:29.652]                 }, immediateCondition = function(cond) {
[16:12:29.652]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.652]                   sendCondition(cond)
[16:12:29.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.652]                   {
[16:12:29.652]                     inherits <- base::inherits
[16:12:29.652]                     invokeRestart <- base::invokeRestart
[16:12:29.652]                     is.null <- base::is.null
[16:12:29.652]                     muffled <- FALSE
[16:12:29.652]                     if (inherits(cond, "message")) {
[16:12:29.652]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.652]                       if (muffled) 
[16:12:29.652]                         invokeRestart("muffleMessage")
[16:12:29.652]                     }
[16:12:29.652]                     else if (inherits(cond, "warning")) {
[16:12:29.652]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.652]                       if (muffled) 
[16:12:29.652]                         invokeRestart("muffleWarning")
[16:12:29.652]                     }
[16:12:29.652]                     else if (inherits(cond, "condition")) {
[16:12:29.652]                       if (!is.null(pattern)) {
[16:12:29.652]                         computeRestarts <- base::computeRestarts
[16:12:29.652]                         grepl <- base::grepl
[16:12:29.652]                         restarts <- computeRestarts(cond)
[16:12:29.652]                         for (restart in restarts) {
[16:12:29.652]                           name <- restart$name
[16:12:29.652]                           if (is.null(name)) 
[16:12:29.652]                             next
[16:12:29.652]                           if (!grepl(pattern, name)) 
[16:12:29.652]                             next
[16:12:29.652]                           invokeRestart(restart)
[16:12:29.652]                           muffled <- TRUE
[16:12:29.652]                           break
[16:12:29.652]                         }
[16:12:29.652]                       }
[16:12:29.652]                     }
[16:12:29.652]                     invisible(muffled)
[16:12:29.652]                   }
[16:12:29.652]                   muffleCondition(cond)
[16:12:29.652]                 })
[16:12:29.652]             }))
[16:12:29.652]             future::FutureResult(value = ...future.value$value, 
[16:12:29.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.652]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.652]                     ...future.globalenv.names))
[16:12:29.652]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.652]         }, condition = base::local({
[16:12:29.652]             c <- base::c
[16:12:29.652]             inherits <- base::inherits
[16:12:29.652]             invokeRestart <- base::invokeRestart
[16:12:29.652]             length <- base::length
[16:12:29.652]             list <- base::list
[16:12:29.652]             seq.int <- base::seq.int
[16:12:29.652]             signalCondition <- base::signalCondition
[16:12:29.652]             sys.calls <- base::sys.calls
[16:12:29.652]             `[[` <- base::`[[`
[16:12:29.652]             `+` <- base::`+`
[16:12:29.652]             `<<-` <- base::`<<-`
[16:12:29.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.652]                   3L)]
[16:12:29.652]             }
[16:12:29.652]             function(cond) {
[16:12:29.652]                 is_error <- inherits(cond, "error")
[16:12:29.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.652]                   NULL)
[16:12:29.652]                 if (is_error) {
[16:12:29.652]                   sessionInformation <- function() {
[16:12:29.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.652]                       search = base::search(), system = base::Sys.info())
[16:12:29.652]                   }
[16:12:29.652]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.652]                     cond$call), session = sessionInformation(), 
[16:12:29.652]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.652]                   signalCondition(cond)
[16:12:29.652]                 }
[16:12:29.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.652]                 "immediateCondition"))) {
[16:12:29.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.652]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.652]                   if (TRUE && !signal) {
[16:12:29.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.652]                     {
[16:12:29.652]                       inherits <- base::inherits
[16:12:29.652]                       invokeRestart <- base::invokeRestart
[16:12:29.652]                       is.null <- base::is.null
[16:12:29.652]                       muffled <- FALSE
[16:12:29.652]                       if (inherits(cond, "message")) {
[16:12:29.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.652]                         if (muffled) 
[16:12:29.652]                           invokeRestart("muffleMessage")
[16:12:29.652]                       }
[16:12:29.652]                       else if (inherits(cond, "warning")) {
[16:12:29.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.652]                         if (muffled) 
[16:12:29.652]                           invokeRestart("muffleWarning")
[16:12:29.652]                       }
[16:12:29.652]                       else if (inherits(cond, "condition")) {
[16:12:29.652]                         if (!is.null(pattern)) {
[16:12:29.652]                           computeRestarts <- base::computeRestarts
[16:12:29.652]                           grepl <- base::grepl
[16:12:29.652]                           restarts <- computeRestarts(cond)
[16:12:29.652]                           for (restart in restarts) {
[16:12:29.652]                             name <- restart$name
[16:12:29.652]                             if (is.null(name)) 
[16:12:29.652]                               next
[16:12:29.652]                             if (!grepl(pattern, name)) 
[16:12:29.652]                               next
[16:12:29.652]                             invokeRestart(restart)
[16:12:29.652]                             muffled <- TRUE
[16:12:29.652]                             break
[16:12:29.652]                           }
[16:12:29.652]                         }
[16:12:29.652]                       }
[16:12:29.652]                       invisible(muffled)
[16:12:29.652]                     }
[16:12:29.652]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.652]                   }
[16:12:29.652]                 }
[16:12:29.652]                 else {
[16:12:29.652]                   if (TRUE) {
[16:12:29.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.652]                     {
[16:12:29.652]                       inherits <- base::inherits
[16:12:29.652]                       invokeRestart <- base::invokeRestart
[16:12:29.652]                       is.null <- base::is.null
[16:12:29.652]                       muffled <- FALSE
[16:12:29.652]                       if (inherits(cond, "message")) {
[16:12:29.652]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.652]                         if (muffled) 
[16:12:29.652]                           invokeRestart("muffleMessage")
[16:12:29.652]                       }
[16:12:29.652]                       else if (inherits(cond, "warning")) {
[16:12:29.652]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.652]                         if (muffled) 
[16:12:29.652]                           invokeRestart("muffleWarning")
[16:12:29.652]                       }
[16:12:29.652]                       else if (inherits(cond, "condition")) {
[16:12:29.652]                         if (!is.null(pattern)) {
[16:12:29.652]                           computeRestarts <- base::computeRestarts
[16:12:29.652]                           grepl <- base::grepl
[16:12:29.652]                           restarts <- computeRestarts(cond)
[16:12:29.652]                           for (restart in restarts) {
[16:12:29.652]                             name <- restart$name
[16:12:29.652]                             if (is.null(name)) 
[16:12:29.652]                               next
[16:12:29.652]                             if (!grepl(pattern, name)) 
[16:12:29.652]                               next
[16:12:29.652]                             invokeRestart(restart)
[16:12:29.652]                             muffled <- TRUE
[16:12:29.652]                             break
[16:12:29.652]                           }
[16:12:29.652]                         }
[16:12:29.652]                       }
[16:12:29.652]                       invisible(muffled)
[16:12:29.652]                     }
[16:12:29.652]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.652]                   }
[16:12:29.652]                 }
[16:12:29.652]             }
[16:12:29.652]         }))
[16:12:29.652]     }, error = function(ex) {
[16:12:29.652]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.652]                 ...future.rng), started = ...future.startTime, 
[16:12:29.652]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.652]             version = "1.8"), class = "FutureResult")
[16:12:29.652]     }, finally = {
[16:12:29.652]         if (!identical(...future.workdir, getwd())) 
[16:12:29.652]             setwd(...future.workdir)
[16:12:29.652]         {
[16:12:29.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.652]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.652]             }
[16:12:29.652]             base::options(...future.oldOptions)
[16:12:29.652]             if (.Platform$OS.type == "windows") {
[16:12:29.652]                 old_names <- names(...future.oldEnvVars)
[16:12:29.652]                 envs <- base::Sys.getenv()
[16:12:29.652]                 names <- names(envs)
[16:12:29.652]                 common <- intersect(names, old_names)
[16:12:29.652]                 added <- setdiff(names, old_names)
[16:12:29.652]                 removed <- setdiff(old_names, names)
[16:12:29.652]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.652]                   envs[common]]
[16:12:29.652]                 NAMES <- toupper(changed)
[16:12:29.652]                 args <- list()
[16:12:29.652]                 for (kk in seq_along(NAMES)) {
[16:12:29.652]                   name <- changed[[kk]]
[16:12:29.652]                   NAME <- NAMES[[kk]]
[16:12:29.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.652]                     next
[16:12:29.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.652]                 }
[16:12:29.652]                 NAMES <- toupper(added)
[16:12:29.652]                 for (kk in seq_along(NAMES)) {
[16:12:29.652]                   name <- added[[kk]]
[16:12:29.652]                   NAME <- NAMES[[kk]]
[16:12:29.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.652]                     next
[16:12:29.652]                   args[[name]] <- ""
[16:12:29.652]                 }
[16:12:29.652]                 NAMES <- toupper(removed)
[16:12:29.652]                 for (kk in seq_along(NAMES)) {
[16:12:29.652]                   name <- removed[[kk]]
[16:12:29.652]                   NAME <- NAMES[[kk]]
[16:12:29.652]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.652]                     next
[16:12:29.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.652]                 }
[16:12:29.652]                 if (length(args) > 0) 
[16:12:29.652]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.652]             }
[16:12:29.652]             else {
[16:12:29.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.652]             }
[16:12:29.652]             {
[16:12:29.652]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.652]                   0L) {
[16:12:29.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.652]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.652]                   base::options(opts)
[16:12:29.652]                 }
[16:12:29.652]                 {
[16:12:29.652]                   {
[16:12:29.652]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.652]                     NULL
[16:12:29.652]                   }
[16:12:29.652]                   options(future.plan = NULL)
[16:12:29.652]                   if (is.na(NA_character_)) 
[16:12:29.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.652]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.652]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.652]                     envir = parent.frame()) 
[16:12:29.652]                   {
[16:12:29.652]                     if (is.function(workers)) 
[16:12:29.652]                       workers <- workers()
[16:12:29.652]                     workers <- structure(as.integer(workers), 
[16:12:29.652]                       class = class(workers))
[16:12:29.652]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.652]                       workers >= 1)
[16:12:29.652]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.652]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.652]                     }
[16:12:29.652]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.652]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.652]                       envir = envir)
[16:12:29.652]                     if (!future$lazy) 
[16:12:29.652]                       future <- run(future)
[16:12:29.652]                     invisible(future)
[16:12:29.652]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.652]                 }
[16:12:29.652]             }
[16:12:29.652]         }
[16:12:29.652]     })
[16:12:29.652]     if (TRUE) {
[16:12:29.652]         base::sink(type = "output", split = FALSE)
[16:12:29.652]         if (TRUE) {
[16:12:29.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.652]         }
[16:12:29.652]         else {
[16:12:29.652]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.652]         }
[16:12:29.652]         base::close(...future.stdout)
[16:12:29.652]         ...future.stdout <- NULL
[16:12:29.652]     }
[16:12:29.652]     ...future.result$conditions <- ...future.conditions
[16:12:29.652]     ...future.result$finished <- base::Sys.time()
[16:12:29.652]     ...future.result
[16:12:29.652] }
[16:12:29.654] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:29.665] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.665] - Validating connection of MultisessionFuture
[16:12:29.666] - received message: FutureResult
[16:12:29.666] - Received FutureResult
[16:12:29.666] - Erased future from FutureRegistry
[16:12:29.666] result() for ClusterFuture ...
[16:12:29.666] - result already collected: FutureResult
[16:12:29.666] result() for ClusterFuture ... done
[16:12:29.666] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:29.666] result() for ClusterFuture ...
[16:12:29.666] - result already collected: FutureResult
[16:12:29.666] result() for ClusterFuture ... done
[16:12:29.667] result() for ClusterFuture ...
[16:12:29.667] - result already collected: FutureResult
[16:12:29.667] result() for ClusterFuture ... done
[16:12:29.668] MultisessionFuture started
[16:12:29.668] - Launch lazy future ... done
[16:12:29.668] run() for ‘MultisessionFuture’ ... done
<environment: 0x560bb069e020> 
<environment: 0x560baea47858> 
[16:12:29.670] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.670] - Validating connection of MultisessionFuture
[16:12:29.670] - received message: FutureResult
[16:12:29.670] - Received FutureResult
[16:12:29.670] - Erased future from FutureRegistry
[16:12:29.671] result() for ClusterFuture ...
[16:12:29.671] - result already collected: FutureResult
[16:12:29.671] result() for ClusterFuture ... done
[16:12:29.671] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:29.683] resolve() on environment ...
[16:12:29.683]  recursive: 0
[16:12:29.683]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:29.683] signalConditionsASAP(numeric, pos=1) ...
[16:12:29.683] - nx: 4
[16:12:29.683] - relay: TRUE
[16:12:29.684] - stdout: TRUE
[16:12:29.684] - signal: TRUE
[16:12:29.684] - resignal: FALSE
[16:12:29.684] - force: TRUE
[16:12:29.684] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.684] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.684]  - until=2
[16:12:29.684]  - relaying element #2
[16:12:29.684] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.684] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.684] signalConditionsASAP(NULL, pos=1) ... done
[16:12:29.685]  length: 3 (resolved future 1)
[16:12:29.685] Future #2
[16:12:29.685] result() for ClusterFuture ...
[16:12:29.685] - result already collected: FutureResult
[16:12:29.685] result() for ClusterFuture ... done
[16:12:29.685] result() for ClusterFuture ...
[16:12:29.685] - result already collected: FutureResult
[16:12:29.685] result() for ClusterFuture ... done
[16:12:29.685] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:29.685] - nx: 4
[16:12:29.686] - relay: TRUE
[16:12:29.686] - stdout: TRUE
[16:12:29.686] - signal: TRUE
[16:12:29.686] - resignal: FALSE
[16:12:29.686] - force: TRUE
[16:12:29.686] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.686] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.686]  - until=2
[16:12:29.686]  - relaying element #2
[16:12:29.686] result() for ClusterFuture ...
[16:12:29.686] - result already collected: FutureResult
[16:12:29.686] result() for ClusterFuture ... done
[16:12:29.687] result() for ClusterFuture ...
[16:12:29.687] - result already collected: FutureResult
[16:12:29.687] result() for ClusterFuture ... done
[16:12:29.687] result() for ClusterFuture ...
[16:12:29.687] - result already collected: FutureResult
[16:12:29.687] result() for ClusterFuture ... done
[16:12:29.687] result() for ClusterFuture ...
[16:12:29.687] - result already collected: FutureResult
[16:12:29.687] result() for ClusterFuture ... done
[16:12:29.687] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.687] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.688] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:29.688]  length: 2 (resolved future 2)
[16:12:29.688] Future #3
[16:12:29.688] result() for ClusterFuture ...
[16:12:29.688] - result already collected: FutureResult
[16:12:29.688] result() for ClusterFuture ... done
[16:12:29.688] result() for ClusterFuture ...
[16:12:29.688] - result already collected: FutureResult
[16:12:29.688] result() for ClusterFuture ... done
[16:12:29.688] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:29.689] - nx: 4
[16:12:29.689] - relay: TRUE
[16:12:29.689] - stdout: TRUE
[16:12:29.689] - signal: TRUE
[16:12:29.689] - resignal: FALSE
[16:12:29.689] - force: TRUE
[16:12:29.689] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.689] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.689]  - until=3
[16:12:29.689]  - relaying element #3
[16:12:29.689] result() for ClusterFuture ...
[16:12:29.690] - result already collected: FutureResult
[16:12:29.690] result() for ClusterFuture ... done
[16:12:29.690] result() for ClusterFuture ...
[16:12:29.690] - result already collected: FutureResult
[16:12:29.690] result() for ClusterFuture ... done
[16:12:29.690] result() for ClusterFuture ...
[16:12:29.690] - result already collected: FutureResult
[16:12:29.690] result() for ClusterFuture ... done
[16:12:29.690] result() for ClusterFuture ...
[16:12:29.690] - result already collected: FutureResult
[16:12:29.690] result() for ClusterFuture ... done
[16:12:29.690] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.691] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.691] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:29.691]  length: 1 (resolved future 3)
[16:12:29.716] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.717] - Validating connection of MultisessionFuture
[16:12:29.717] - received message: FutureResult
[16:12:29.717] - Received FutureResult
[16:12:29.717] - Erased future from FutureRegistry
[16:12:29.717] result() for ClusterFuture ...
[16:12:29.717] - result already collected: FutureResult
[16:12:29.717] result() for ClusterFuture ... done
[16:12:29.718] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:29.718] Future #4
[16:12:29.718] result() for ClusterFuture ...
[16:12:29.718] - result already collected: FutureResult
[16:12:29.718] result() for ClusterFuture ... done
[16:12:29.718] result() for ClusterFuture ...
[16:12:29.718] - result already collected: FutureResult
[16:12:29.718] result() for ClusterFuture ... done
[16:12:29.718] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:29.718] - nx: 4
[16:12:29.719] - relay: TRUE
[16:12:29.719] - stdout: TRUE
[16:12:29.719] - signal: TRUE
[16:12:29.719] - resignal: FALSE
[16:12:29.719] - force: TRUE
[16:12:29.719] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.719] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.719]  - until=4
[16:12:29.719]  - relaying element #4
[16:12:29.719] result() for ClusterFuture ...
[16:12:29.719] - result already collected: FutureResult
[16:12:29.720] result() for ClusterFuture ... done
[16:12:29.720] result() for ClusterFuture ...
[16:12:29.720] - result already collected: FutureResult
[16:12:29.720] result() for ClusterFuture ... done
[16:12:29.720] result() for ClusterFuture ...
[16:12:29.720] - result already collected: FutureResult
[16:12:29.720] result() for ClusterFuture ... done
[16:12:29.720] result() for ClusterFuture ...
[16:12:29.720] - result already collected: FutureResult
[16:12:29.720] result() for ClusterFuture ... done
[16:12:29.720] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.721] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.721] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:29.721]  length: 0 (resolved future 4)
[16:12:29.721] Relaying remaining futures
[16:12:29.721] signalConditionsASAP(NULL, pos=0) ...
[16:12:29.721] - nx: 4
[16:12:29.721] - relay: TRUE
[16:12:29.721] - stdout: TRUE
[16:12:29.721] - signal: TRUE
[16:12:29.721] - resignal: FALSE
[16:12:29.721] - force: TRUE
[16:12:29.722] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.722] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:29.722] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.722] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.722] signalConditionsASAP(NULL, pos=0) ... done
[16:12:29.722] resolve() on environment ... DONE
[16:12:29.722] result() for ClusterFuture ...
[16:12:29.722] - result already collected: FutureResult
[16:12:29.722] result() for ClusterFuture ... done
[16:12:29.722] result() for ClusterFuture ...
[16:12:29.722] - result already collected: FutureResult
[16:12:29.723] result() for ClusterFuture ... done
[16:12:29.723] result() for ClusterFuture ...
[16:12:29.723] - result already collected: FutureResult
[16:12:29.723] result() for ClusterFuture ... done
[16:12:29.723] result() for ClusterFuture ...
[16:12:29.723] - result already collected: FutureResult
[16:12:29.723] result() for ClusterFuture ... done
[16:12:29.723] result() for ClusterFuture ...
[16:12:29.723] - result already collected: FutureResult
[16:12:29.723] result() for ClusterFuture ... done
[16:12:29.723] result() for ClusterFuture ...
[16:12:29.724] - result already collected: FutureResult
[16:12:29.724] result() for ClusterFuture ... done
<environment: 0x560bae656ae8> 
Dimensions: c(1, 6)
[16:12:29.724] getGlobalsAndPackages() ...
[16:12:29.724] Searching for globals...
[16:12:29.725] 
[16:12:29.725] Searching for globals ... DONE
[16:12:29.725] - globals: [0] <none>
[16:12:29.725] getGlobalsAndPackages() ... DONE
[16:12:29.725] run() for ‘Future’ ...
[16:12:29.725] - state: ‘created’
[16:12:29.725] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.740] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.740]   - Field: ‘node’
[16:12:29.740]   - Field: ‘label’
[16:12:29.740]   - Field: ‘local’
[16:12:29.740]   - Field: ‘owner’
[16:12:29.741]   - Field: ‘envir’
[16:12:29.741]   - Field: ‘workers’
[16:12:29.741]   - Field: ‘packages’
[16:12:29.741]   - Field: ‘gc’
[16:12:29.741]   - Field: ‘conditions’
[16:12:29.741]   - Field: ‘persistent’
[16:12:29.741]   - Field: ‘expr’
[16:12:29.741]   - Field: ‘uuid’
[16:12:29.741]   - Field: ‘seed’
[16:12:29.741]   - Field: ‘version’
[16:12:29.741]   - Field: ‘result’
[16:12:29.742]   - Field: ‘asynchronous’
[16:12:29.742]   - Field: ‘calls’
[16:12:29.742]   - Field: ‘globals’
[16:12:29.742]   - Field: ‘stdout’
[16:12:29.742]   - Field: ‘earlySignal’
[16:12:29.742]   - Field: ‘lazy’
[16:12:29.742]   - Field: ‘state’
[16:12:29.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.742] - Launch lazy future ...
[16:12:29.743] Packages needed by the future expression (n = 0): <none>
[16:12:29.743] Packages needed by future strategies (n = 0): <none>
[16:12:29.743] {
[16:12:29.743]     {
[16:12:29.743]         {
[16:12:29.743]             ...future.startTime <- base::Sys.time()
[16:12:29.743]             {
[16:12:29.743]                 {
[16:12:29.743]                   {
[16:12:29.743]                     {
[16:12:29.743]                       base::local({
[16:12:29.743]                         has_future <- base::requireNamespace("future", 
[16:12:29.743]                           quietly = TRUE)
[16:12:29.743]                         if (has_future) {
[16:12:29.743]                           ns <- base::getNamespace("future")
[16:12:29.743]                           version <- ns[[".package"]][["version"]]
[16:12:29.743]                           if (is.null(version)) 
[16:12:29.743]                             version <- utils::packageVersion("future")
[16:12:29.743]                         }
[16:12:29.743]                         else {
[16:12:29.743]                           version <- NULL
[16:12:29.743]                         }
[16:12:29.743]                         if (!has_future || version < "1.8.0") {
[16:12:29.743]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.743]                             "", base::R.version$version.string), 
[16:12:29.743]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.743]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.743]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.743]                               "release", "version")], collapse = " "), 
[16:12:29.743]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.743]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.743]                             info)
[16:12:29.743]                           info <- base::paste(info, collapse = "; ")
[16:12:29.743]                           if (!has_future) {
[16:12:29.743]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.743]                               info)
[16:12:29.743]                           }
[16:12:29.743]                           else {
[16:12:29.743]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.743]                               info, version)
[16:12:29.743]                           }
[16:12:29.743]                           base::stop(msg)
[16:12:29.743]                         }
[16:12:29.743]                       })
[16:12:29.743]                     }
[16:12:29.743]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.743]                     base::options(mc.cores = 1L)
[16:12:29.743]                   }
[16:12:29.743]                   options(future.plan = NULL)
[16:12:29.743]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.743]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.743]                 }
[16:12:29.743]                 ...future.workdir <- getwd()
[16:12:29.743]             }
[16:12:29.743]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.743]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.743]         }
[16:12:29.743]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.743]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.743]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.743]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.743]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.743]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.743]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.743]             base::names(...future.oldOptions))
[16:12:29.743]     }
[16:12:29.743]     if (FALSE) {
[16:12:29.743]     }
[16:12:29.743]     else {
[16:12:29.743]         if (TRUE) {
[16:12:29.743]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.743]                 open = "w")
[16:12:29.743]         }
[16:12:29.743]         else {
[16:12:29.743]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.743]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.743]         }
[16:12:29.743]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.743]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.743]             base::sink(type = "output", split = FALSE)
[16:12:29.743]             base::close(...future.stdout)
[16:12:29.743]         }, add = TRUE)
[16:12:29.743]     }
[16:12:29.743]     ...future.frame <- base::sys.nframe()
[16:12:29.743]     ...future.conditions <- base::list()
[16:12:29.743]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.743]     if (FALSE) {
[16:12:29.743]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.743]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.743]     }
[16:12:29.743]     ...future.result <- base::tryCatch({
[16:12:29.743]         base::withCallingHandlers({
[16:12:29.743]             ...future.value <- base::withVisible(base::local({
[16:12:29.743]                 ...future.makeSendCondition <- local({
[16:12:29.743]                   sendCondition <- NULL
[16:12:29.743]                   function(frame = 1L) {
[16:12:29.743]                     if (is.function(sendCondition)) 
[16:12:29.743]                       return(sendCondition)
[16:12:29.743]                     ns <- getNamespace("parallel")
[16:12:29.743]                     if (exists("sendData", mode = "function", 
[16:12:29.743]                       envir = ns)) {
[16:12:29.743]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.743]                         envir = ns)
[16:12:29.743]                       envir <- sys.frame(frame)
[16:12:29.743]                       master <- NULL
[16:12:29.743]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.743]                         !identical(envir, emptyenv())) {
[16:12:29.743]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.743]                           inherits = FALSE)) {
[16:12:29.743]                           master <- get("master", mode = "list", 
[16:12:29.743]                             envir = envir, inherits = FALSE)
[16:12:29.743]                           if (inherits(master, c("SOCKnode", 
[16:12:29.743]                             "SOCK0node"))) {
[16:12:29.743]                             sendCondition <<- function(cond) {
[16:12:29.743]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.743]                                 success = TRUE)
[16:12:29.743]                               parallel_sendData(master, data)
[16:12:29.743]                             }
[16:12:29.743]                             return(sendCondition)
[16:12:29.743]                           }
[16:12:29.743]                         }
[16:12:29.743]                         frame <- frame + 1L
[16:12:29.743]                         envir <- sys.frame(frame)
[16:12:29.743]                       }
[16:12:29.743]                     }
[16:12:29.743]                     sendCondition <<- function(cond) NULL
[16:12:29.743]                   }
[16:12:29.743]                 })
[16:12:29.743]                 withCallingHandlers({
[16:12:29.743]                   2
[16:12:29.743]                 }, immediateCondition = function(cond) {
[16:12:29.743]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.743]                   sendCondition(cond)
[16:12:29.743]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.743]                   {
[16:12:29.743]                     inherits <- base::inherits
[16:12:29.743]                     invokeRestart <- base::invokeRestart
[16:12:29.743]                     is.null <- base::is.null
[16:12:29.743]                     muffled <- FALSE
[16:12:29.743]                     if (inherits(cond, "message")) {
[16:12:29.743]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.743]                       if (muffled) 
[16:12:29.743]                         invokeRestart("muffleMessage")
[16:12:29.743]                     }
[16:12:29.743]                     else if (inherits(cond, "warning")) {
[16:12:29.743]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.743]                       if (muffled) 
[16:12:29.743]                         invokeRestart("muffleWarning")
[16:12:29.743]                     }
[16:12:29.743]                     else if (inherits(cond, "condition")) {
[16:12:29.743]                       if (!is.null(pattern)) {
[16:12:29.743]                         computeRestarts <- base::computeRestarts
[16:12:29.743]                         grepl <- base::grepl
[16:12:29.743]                         restarts <- computeRestarts(cond)
[16:12:29.743]                         for (restart in restarts) {
[16:12:29.743]                           name <- restart$name
[16:12:29.743]                           if (is.null(name)) 
[16:12:29.743]                             next
[16:12:29.743]                           if (!grepl(pattern, name)) 
[16:12:29.743]                             next
[16:12:29.743]                           invokeRestart(restart)
[16:12:29.743]                           muffled <- TRUE
[16:12:29.743]                           break
[16:12:29.743]                         }
[16:12:29.743]                       }
[16:12:29.743]                     }
[16:12:29.743]                     invisible(muffled)
[16:12:29.743]                   }
[16:12:29.743]                   muffleCondition(cond)
[16:12:29.743]                 })
[16:12:29.743]             }))
[16:12:29.743]             future::FutureResult(value = ...future.value$value, 
[16:12:29.743]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.743]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.743]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.743]                     ...future.globalenv.names))
[16:12:29.743]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.743]         }, condition = base::local({
[16:12:29.743]             c <- base::c
[16:12:29.743]             inherits <- base::inherits
[16:12:29.743]             invokeRestart <- base::invokeRestart
[16:12:29.743]             length <- base::length
[16:12:29.743]             list <- base::list
[16:12:29.743]             seq.int <- base::seq.int
[16:12:29.743]             signalCondition <- base::signalCondition
[16:12:29.743]             sys.calls <- base::sys.calls
[16:12:29.743]             `[[` <- base::`[[`
[16:12:29.743]             `+` <- base::`+`
[16:12:29.743]             `<<-` <- base::`<<-`
[16:12:29.743]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.743]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.743]                   3L)]
[16:12:29.743]             }
[16:12:29.743]             function(cond) {
[16:12:29.743]                 is_error <- inherits(cond, "error")
[16:12:29.743]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.743]                   NULL)
[16:12:29.743]                 if (is_error) {
[16:12:29.743]                   sessionInformation <- function() {
[16:12:29.743]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.743]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.743]                       search = base::search(), system = base::Sys.info())
[16:12:29.743]                   }
[16:12:29.743]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.743]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.743]                     cond$call), session = sessionInformation(), 
[16:12:29.743]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.743]                   signalCondition(cond)
[16:12:29.743]                 }
[16:12:29.743]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.743]                 "immediateCondition"))) {
[16:12:29.743]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.743]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.743]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.743]                   if (TRUE && !signal) {
[16:12:29.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.743]                     {
[16:12:29.743]                       inherits <- base::inherits
[16:12:29.743]                       invokeRestart <- base::invokeRestart
[16:12:29.743]                       is.null <- base::is.null
[16:12:29.743]                       muffled <- FALSE
[16:12:29.743]                       if (inherits(cond, "message")) {
[16:12:29.743]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.743]                         if (muffled) 
[16:12:29.743]                           invokeRestart("muffleMessage")
[16:12:29.743]                       }
[16:12:29.743]                       else if (inherits(cond, "warning")) {
[16:12:29.743]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.743]                         if (muffled) 
[16:12:29.743]                           invokeRestart("muffleWarning")
[16:12:29.743]                       }
[16:12:29.743]                       else if (inherits(cond, "condition")) {
[16:12:29.743]                         if (!is.null(pattern)) {
[16:12:29.743]                           computeRestarts <- base::computeRestarts
[16:12:29.743]                           grepl <- base::grepl
[16:12:29.743]                           restarts <- computeRestarts(cond)
[16:12:29.743]                           for (restart in restarts) {
[16:12:29.743]                             name <- restart$name
[16:12:29.743]                             if (is.null(name)) 
[16:12:29.743]                               next
[16:12:29.743]                             if (!grepl(pattern, name)) 
[16:12:29.743]                               next
[16:12:29.743]                             invokeRestart(restart)
[16:12:29.743]                             muffled <- TRUE
[16:12:29.743]                             break
[16:12:29.743]                           }
[16:12:29.743]                         }
[16:12:29.743]                       }
[16:12:29.743]                       invisible(muffled)
[16:12:29.743]                     }
[16:12:29.743]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.743]                   }
[16:12:29.743]                 }
[16:12:29.743]                 else {
[16:12:29.743]                   if (TRUE) {
[16:12:29.743]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.743]                     {
[16:12:29.743]                       inherits <- base::inherits
[16:12:29.743]                       invokeRestart <- base::invokeRestart
[16:12:29.743]                       is.null <- base::is.null
[16:12:29.743]                       muffled <- FALSE
[16:12:29.743]                       if (inherits(cond, "message")) {
[16:12:29.743]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.743]                         if (muffled) 
[16:12:29.743]                           invokeRestart("muffleMessage")
[16:12:29.743]                       }
[16:12:29.743]                       else if (inherits(cond, "warning")) {
[16:12:29.743]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.743]                         if (muffled) 
[16:12:29.743]                           invokeRestart("muffleWarning")
[16:12:29.743]                       }
[16:12:29.743]                       else if (inherits(cond, "condition")) {
[16:12:29.743]                         if (!is.null(pattern)) {
[16:12:29.743]                           computeRestarts <- base::computeRestarts
[16:12:29.743]                           grepl <- base::grepl
[16:12:29.743]                           restarts <- computeRestarts(cond)
[16:12:29.743]                           for (restart in restarts) {
[16:12:29.743]                             name <- restart$name
[16:12:29.743]                             if (is.null(name)) 
[16:12:29.743]                               next
[16:12:29.743]                             if (!grepl(pattern, name)) 
[16:12:29.743]                               next
[16:12:29.743]                             invokeRestart(restart)
[16:12:29.743]                             muffled <- TRUE
[16:12:29.743]                             break
[16:12:29.743]                           }
[16:12:29.743]                         }
[16:12:29.743]                       }
[16:12:29.743]                       invisible(muffled)
[16:12:29.743]                     }
[16:12:29.743]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.743]                   }
[16:12:29.743]                 }
[16:12:29.743]             }
[16:12:29.743]         }))
[16:12:29.743]     }, error = function(ex) {
[16:12:29.743]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.743]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.743]                 ...future.rng), started = ...future.startTime, 
[16:12:29.743]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.743]             version = "1.8"), class = "FutureResult")
[16:12:29.743]     }, finally = {
[16:12:29.743]         if (!identical(...future.workdir, getwd())) 
[16:12:29.743]             setwd(...future.workdir)
[16:12:29.743]         {
[16:12:29.743]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.743]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.743]             }
[16:12:29.743]             base::options(...future.oldOptions)
[16:12:29.743]             if (.Platform$OS.type == "windows") {
[16:12:29.743]                 old_names <- names(...future.oldEnvVars)
[16:12:29.743]                 envs <- base::Sys.getenv()
[16:12:29.743]                 names <- names(envs)
[16:12:29.743]                 common <- intersect(names, old_names)
[16:12:29.743]                 added <- setdiff(names, old_names)
[16:12:29.743]                 removed <- setdiff(old_names, names)
[16:12:29.743]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.743]                   envs[common]]
[16:12:29.743]                 NAMES <- toupper(changed)
[16:12:29.743]                 args <- list()
[16:12:29.743]                 for (kk in seq_along(NAMES)) {
[16:12:29.743]                   name <- changed[[kk]]
[16:12:29.743]                   NAME <- NAMES[[kk]]
[16:12:29.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.743]                     next
[16:12:29.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.743]                 }
[16:12:29.743]                 NAMES <- toupper(added)
[16:12:29.743]                 for (kk in seq_along(NAMES)) {
[16:12:29.743]                   name <- added[[kk]]
[16:12:29.743]                   NAME <- NAMES[[kk]]
[16:12:29.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.743]                     next
[16:12:29.743]                   args[[name]] <- ""
[16:12:29.743]                 }
[16:12:29.743]                 NAMES <- toupper(removed)
[16:12:29.743]                 for (kk in seq_along(NAMES)) {
[16:12:29.743]                   name <- removed[[kk]]
[16:12:29.743]                   NAME <- NAMES[[kk]]
[16:12:29.743]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.743]                     next
[16:12:29.743]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.743]                 }
[16:12:29.743]                 if (length(args) > 0) 
[16:12:29.743]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.743]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.743]             }
[16:12:29.743]             else {
[16:12:29.743]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.743]             }
[16:12:29.743]             {
[16:12:29.743]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.743]                   0L) {
[16:12:29.743]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.743]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.743]                   base::options(opts)
[16:12:29.743]                 }
[16:12:29.743]                 {
[16:12:29.743]                   {
[16:12:29.743]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.743]                     NULL
[16:12:29.743]                   }
[16:12:29.743]                   options(future.plan = NULL)
[16:12:29.743]                   if (is.na(NA_character_)) 
[16:12:29.743]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.743]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.743]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.743]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.743]                     envir = parent.frame()) 
[16:12:29.743]                   {
[16:12:29.743]                     if (is.function(workers)) 
[16:12:29.743]                       workers <- workers()
[16:12:29.743]                     workers <- structure(as.integer(workers), 
[16:12:29.743]                       class = class(workers))
[16:12:29.743]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.743]                       workers >= 1)
[16:12:29.743]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.743]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.743]                     }
[16:12:29.743]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.743]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.743]                       envir = envir)
[16:12:29.743]                     if (!future$lazy) 
[16:12:29.743]                       future <- run(future)
[16:12:29.743]                     invisible(future)
[16:12:29.743]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.743]                 }
[16:12:29.743]             }
[16:12:29.743]         }
[16:12:29.743]     })
[16:12:29.743]     if (TRUE) {
[16:12:29.743]         base::sink(type = "output", split = FALSE)
[16:12:29.743]         if (TRUE) {
[16:12:29.743]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.743]         }
[16:12:29.743]         else {
[16:12:29.743]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.743]         }
[16:12:29.743]         base::close(...future.stdout)
[16:12:29.743]         ...future.stdout <- NULL
[16:12:29.743]     }
[16:12:29.743]     ...future.result$conditions <- ...future.conditions
[16:12:29.743]     ...future.result$finished <- base::Sys.time()
[16:12:29.743]     ...future.result
[16:12:29.743] }
[16:12:29.746] MultisessionFuture started
[16:12:29.747] - Launch lazy future ... done
[16:12:29.747] run() for ‘MultisessionFuture’ ... done
[16:12:29.747] getGlobalsAndPackages() ...
[16:12:29.747] Searching for globals...
[16:12:29.747] 
[16:12:29.747] Searching for globals ... DONE
[16:12:29.747] - globals: [0] <none>
[16:12:29.747] getGlobalsAndPackages() ... DONE
[16:12:29.748] run() for ‘Future’ ...
[16:12:29.748] - state: ‘created’
[16:12:29.748] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.762] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.763]   - Field: ‘node’
[16:12:29.763]   - Field: ‘label’
[16:12:29.763]   - Field: ‘local’
[16:12:29.763]   - Field: ‘owner’
[16:12:29.763]   - Field: ‘envir’
[16:12:29.763]   - Field: ‘workers’
[16:12:29.763]   - Field: ‘packages’
[16:12:29.763]   - Field: ‘gc’
[16:12:29.764]   - Field: ‘conditions’
[16:12:29.764]   - Field: ‘persistent’
[16:12:29.764]   - Field: ‘expr’
[16:12:29.764]   - Field: ‘uuid’
[16:12:29.764]   - Field: ‘seed’
[16:12:29.764]   - Field: ‘version’
[16:12:29.764]   - Field: ‘result’
[16:12:29.764]   - Field: ‘asynchronous’
[16:12:29.764]   - Field: ‘calls’
[16:12:29.764]   - Field: ‘globals’
[16:12:29.764]   - Field: ‘stdout’
[16:12:29.765]   - Field: ‘earlySignal’
[16:12:29.765]   - Field: ‘lazy’
[16:12:29.765]   - Field: ‘state’
[16:12:29.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.765] - Launch lazy future ...
[16:12:29.765] Packages needed by the future expression (n = 0): <none>
[16:12:29.765] Packages needed by future strategies (n = 0): <none>
[16:12:29.766] {
[16:12:29.766]     {
[16:12:29.766]         {
[16:12:29.766]             ...future.startTime <- base::Sys.time()
[16:12:29.766]             {
[16:12:29.766]                 {
[16:12:29.766]                   {
[16:12:29.766]                     {
[16:12:29.766]                       base::local({
[16:12:29.766]                         has_future <- base::requireNamespace("future", 
[16:12:29.766]                           quietly = TRUE)
[16:12:29.766]                         if (has_future) {
[16:12:29.766]                           ns <- base::getNamespace("future")
[16:12:29.766]                           version <- ns[[".package"]][["version"]]
[16:12:29.766]                           if (is.null(version)) 
[16:12:29.766]                             version <- utils::packageVersion("future")
[16:12:29.766]                         }
[16:12:29.766]                         else {
[16:12:29.766]                           version <- NULL
[16:12:29.766]                         }
[16:12:29.766]                         if (!has_future || version < "1.8.0") {
[16:12:29.766]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.766]                             "", base::R.version$version.string), 
[16:12:29.766]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.766]                               "release", "version")], collapse = " "), 
[16:12:29.766]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.766]                             info)
[16:12:29.766]                           info <- base::paste(info, collapse = "; ")
[16:12:29.766]                           if (!has_future) {
[16:12:29.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.766]                               info)
[16:12:29.766]                           }
[16:12:29.766]                           else {
[16:12:29.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.766]                               info, version)
[16:12:29.766]                           }
[16:12:29.766]                           base::stop(msg)
[16:12:29.766]                         }
[16:12:29.766]                       })
[16:12:29.766]                     }
[16:12:29.766]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.766]                     base::options(mc.cores = 1L)
[16:12:29.766]                   }
[16:12:29.766]                   options(future.plan = NULL)
[16:12:29.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.766]                 }
[16:12:29.766]                 ...future.workdir <- getwd()
[16:12:29.766]             }
[16:12:29.766]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.766]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.766]         }
[16:12:29.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.766]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.766]             base::names(...future.oldOptions))
[16:12:29.766]     }
[16:12:29.766]     if (FALSE) {
[16:12:29.766]     }
[16:12:29.766]     else {
[16:12:29.766]         if (TRUE) {
[16:12:29.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.766]                 open = "w")
[16:12:29.766]         }
[16:12:29.766]         else {
[16:12:29.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.766]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.766]         }
[16:12:29.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.766]             base::sink(type = "output", split = FALSE)
[16:12:29.766]             base::close(...future.stdout)
[16:12:29.766]         }, add = TRUE)
[16:12:29.766]     }
[16:12:29.766]     ...future.frame <- base::sys.nframe()
[16:12:29.766]     ...future.conditions <- base::list()
[16:12:29.766]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.766]     if (FALSE) {
[16:12:29.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.766]     }
[16:12:29.766]     ...future.result <- base::tryCatch({
[16:12:29.766]         base::withCallingHandlers({
[16:12:29.766]             ...future.value <- base::withVisible(base::local({
[16:12:29.766]                 ...future.makeSendCondition <- local({
[16:12:29.766]                   sendCondition <- NULL
[16:12:29.766]                   function(frame = 1L) {
[16:12:29.766]                     if (is.function(sendCondition)) 
[16:12:29.766]                       return(sendCondition)
[16:12:29.766]                     ns <- getNamespace("parallel")
[16:12:29.766]                     if (exists("sendData", mode = "function", 
[16:12:29.766]                       envir = ns)) {
[16:12:29.766]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.766]                         envir = ns)
[16:12:29.766]                       envir <- sys.frame(frame)
[16:12:29.766]                       master <- NULL
[16:12:29.766]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.766]                         !identical(envir, emptyenv())) {
[16:12:29.766]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.766]                           inherits = FALSE)) {
[16:12:29.766]                           master <- get("master", mode = "list", 
[16:12:29.766]                             envir = envir, inherits = FALSE)
[16:12:29.766]                           if (inherits(master, c("SOCKnode", 
[16:12:29.766]                             "SOCK0node"))) {
[16:12:29.766]                             sendCondition <<- function(cond) {
[16:12:29.766]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.766]                                 success = TRUE)
[16:12:29.766]                               parallel_sendData(master, data)
[16:12:29.766]                             }
[16:12:29.766]                             return(sendCondition)
[16:12:29.766]                           }
[16:12:29.766]                         }
[16:12:29.766]                         frame <- frame + 1L
[16:12:29.766]                         envir <- sys.frame(frame)
[16:12:29.766]                       }
[16:12:29.766]                     }
[16:12:29.766]                     sendCondition <<- function(cond) NULL
[16:12:29.766]                   }
[16:12:29.766]                 })
[16:12:29.766]                 withCallingHandlers({
[16:12:29.766]                   NULL
[16:12:29.766]                 }, immediateCondition = function(cond) {
[16:12:29.766]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.766]                   sendCondition(cond)
[16:12:29.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.766]                   {
[16:12:29.766]                     inherits <- base::inherits
[16:12:29.766]                     invokeRestart <- base::invokeRestart
[16:12:29.766]                     is.null <- base::is.null
[16:12:29.766]                     muffled <- FALSE
[16:12:29.766]                     if (inherits(cond, "message")) {
[16:12:29.766]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.766]                       if (muffled) 
[16:12:29.766]                         invokeRestart("muffleMessage")
[16:12:29.766]                     }
[16:12:29.766]                     else if (inherits(cond, "warning")) {
[16:12:29.766]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.766]                       if (muffled) 
[16:12:29.766]                         invokeRestart("muffleWarning")
[16:12:29.766]                     }
[16:12:29.766]                     else if (inherits(cond, "condition")) {
[16:12:29.766]                       if (!is.null(pattern)) {
[16:12:29.766]                         computeRestarts <- base::computeRestarts
[16:12:29.766]                         grepl <- base::grepl
[16:12:29.766]                         restarts <- computeRestarts(cond)
[16:12:29.766]                         for (restart in restarts) {
[16:12:29.766]                           name <- restart$name
[16:12:29.766]                           if (is.null(name)) 
[16:12:29.766]                             next
[16:12:29.766]                           if (!grepl(pattern, name)) 
[16:12:29.766]                             next
[16:12:29.766]                           invokeRestart(restart)
[16:12:29.766]                           muffled <- TRUE
[16:12:29.766]                           break
[16:12:29.766]                         }
[16:12:29.766]                       }
[16:12:29.766]                     }
[16:12:29.766]                     invisible(muffled)
[16:12:29.766]                   }
[16:12:29.766]                   muffleCondition(cond)
[16:12:29.766]                 })
[16:12:29.766]             }))
[16:12:29.766]             future::FutureResult(value = ...future.value$value, 
[16:12:29.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.766]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.766]                     ...future.globalenv.names))
[16:12:29.766]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.766]         }, condition = base::local({
[16:12:29.766]             c <- base::c
[16:12:29.766]             inherits <- base::inherits
[16:12:29.766]             invokeRestart <- base::invokeRestart
[16:12:29.766]             length <- base::length
[16:12:29.766]             list <- base::list
[16:12:29.766]             seq.int <- base::seq.int
[16:12:29.766]             signalCondition <- base::signalCondition
[16:12:29.766]             sys.calls <- base::sys.calls
[16:12:29.766]             `[[` <- base::`[[`
[16:12:29.766]             `+` <- base::`+`
[16:12:29.766]             `<<-` <- base::`<<-`
[16:12:29.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.766]                   3L)]
[16:12:29.766]             }
[16:12:29.766]             function(cond) {
[16:12:29.766]                 is_error <- inherits(cond, "error")
[16:12:29.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.766]                   NULL)
[16:12:29.766]                 if (is_error) {
[16:12:29.766]                   sessionInformation <- function() {
[16:12:29.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.766]                       search = base::search(), system = base::Sys.info())
[16:12:29.766]                   }
[16:12:29.766]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.766]                     cond$call), session = sessionInformation(), 
[16:12:29.766]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.766]                   signalCondition(cond)
[16:12:29.766]                 }
[16:12:29.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.766]                 "immediateCondition"))) {
[16:12:29.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.766]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.766]                   if (TRUE && !signal) {
[16:12:29.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.766]                     {
[16:12:29.766]                       inherits <- base::inherits
[16:12:29.766]                       invokeRestart <- base::invokeRestart
[16:12:29.766]                       is.null <- base::is.null
[16:12:29.766]                       muffled <- FALSE
[16:12:29.766]                       if (inherits(cond, "message")) {
[16:12:29.766]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.766]                         if (muffled) 
[16:12:29.766]                           invokeRestart("muffleMessage")
[16:12:29.766]                       }
[16:12:29.766]                       else if (inherits(cond, "warning")) {
[16:12:29.766]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.766]                         if (muffled) 
[16:12:29.766]                           invokeRestart("muffleWarning")
[16:12:29.766]                       }
[16:12:29.766]                       else if (inherits(cond, "condition")) {
[16:12:29.766]                         if (!is.null(pattern)) {
[16:12:29.766]                           computeRestarts <- base::computeRestarts
[16:12:29.766]                           grepl <- base::grepl
[16:12:29.766]                           restarts <- computeRestarts(cond)
[16:12:29.766]                           for (restart in restarts) {
[16:12:29.766]                             name <- restart$name
[16:12:29.766]                             if (is.null(name)) 
[16:12:29.766]                               next
[16:12:29.766]                             if (!grepl(pattern, name)) 
[16:12:29.766]                               next
[16:12:29.766]                             invokeRestart(restart)
[16:12:29.766]                             muffled <- TRUE
[16:12:29.766]                             break
[16:12:29.766]                           }
[16:12:29.766]                         }
[16:12:29.766]                       }
[16:12:29.766]                       invisible(muffled)
[16:12:29.766]                     }
[16:12:29.766]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.766]                   }
[16:12:29.766]                 }
[16:12:29.766]                 else {
[16:12:29.766]                   if (TRUE) {
[16:12:29.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.766]                     {
[16:12:29.766]                       inherits <- base::inherits
[16:12:29.766]                       invokeRestart <- base::invokeRestart
[16:12:29.766]                       is.null <- base::is.null
[16:12:29.766]                       muffled <- FALSE
[16:12:29.766]                       if (inherits(cond, "message")) {
[16:12:29.766]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.766]                         if (muffled) 
[16:12:29.766]                           invokeRestart("muffleMessage")
[16:12:29.766]                       }
[16:12:29.766]                       else if (inherits(cond, "warning")) {
[16:12:29.766]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.766]                         if (muffled) 
[16:12:29.766]                           invokeRestart("muffleWarning")
[16:12:29.766]                       }
[16:12:29.766]                       else if (inherits(cond, "condition")) {
[16:12:29.766]                         if (!is.null(pattern)) {
[16:12:29.766]                           computeRestarts <- base::computeRestarts
[16:12:29.766]                           grepl <- base::grepl
[16:12:29.766]                           restarts <- computeRestarts(cond)
[16:12:29.766]                           for (restart in restarts) {
[16:12:29.766]                             name <- restart$name
[16:12:29.766]                             if (is.null(name)) 
[16:12:29.766]                               next
[16:12:29.766]                             if (!grepl(pattern, name)) 
[16:12:29.766]                               next
[16:12:29.766]                             invokeRestart(restart)
[16:12:29.766]                             muffled <- TRUE
[16:12:29.766]                             break
[16:12:29.766]                           }
[16:12:29.766]                         }
[16:12:29.766]                       }
[16:12:29.766]                       invisible(muffled)
[16:12:29.766]                     }
[16:12:29.766]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.766]                   }
[16:12:29.766]                 }
[16:12:29.766]             }
[16:12:29.766]         }))
[16:12:29.766]     }, error = function(ex) {
[16:12:29.766]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.766]                 ...future.rng), started = ...future.startTime, 
[16:12:29.766]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.766]             version = "1.8"), class = "FutureResult")
[16:12:29.766]     }, finally = {
[16:12:29.766]         if (!identical(...future.workdir, getwd())) 
[16:12:29.766]             setwd(...future.workdir)
[16:12:29.766]         {
[16:12:29.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.766]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.766]             }
[16:12:29.766]             base::options(...future.oldOptions)
[16:12:29.766]             if (.Platform$OS.type == "windows") {
[16:12:29.766]                 old_names <- names(...future.oldEnvVars)
[16:12:29.766]                 envs <- base::Sys.getenv()
[16:12:29.766]                 names <- names(envs)
[16:12:29.766]                 common <- intersect(names, old_names)
[16:12:29.766]                 added <- setdiff(names, old_names)
[16:12:29.766]                 removed <- setdiff(old_names, names)
[16:12:29.766]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.766]                   envs[common]]
[16:12:29.766]                 NAMES <- toupper(changed)
[16:12:29.766]                 args <- list()
[16:12:29.766]                 for (kk in seq_along(NAMES)) {
[16:12:29.766]                   name <- changed[[kk]]
[16:12:29.766]                   NAME <- NAMES[[kk]]
[16:12:29.766]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.766]                     next
[16:12:29.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.766]                 }
[16:12:29.766]                 NAMES <- toupper(added)
[16:12:29.766]                 for (kk in seq_along(NAMES)) {
[16:12:29.766]                   name <- added[[kk]]
[16:12:29.766]                   NAME <- NAMES[[kk]]
[16:12:29.766]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.766]                     next
[16:12:29.766]                   args[[name]] <- ""
[16:12:29.766]                 }
[16:12:29.766]                 NAMES <- toupper(removed)
[16:12:29.766]                 for (kk in seq_along(NAMES)) {
[16:12:29.766]                   name <- removed[[kk]]
[16:12:29.766]                   NAME <- NAMES[[kk]]
[16:12:29.766]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.766]                     next
[16:12:29.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.766]                 }
[16:12:29.766]                 if (length(args) > 0) 
[16:12:29.766]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.766]             }
[16:12:29.766]             else {
[16:12:29.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.766]             }
[16:12:29.766]             {
[16:12:29.766]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.766]                   0L) {
[16:12:29.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.766]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.766]                   base::options(opts)
[16:12:29.766]                 }
[16:12:29.766]                 {
[16:12:29.766]                   {
[16:12:29.766]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.766]                     NULL
[16:12:29.766]                   }
[16:12:29.766]                   options(future.plan = NULL)
[16:12:29.766]                   if (is.na(NA_character_)) 
[16:12:29.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.766]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.766]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.766]                     envir = parent.frame()) 
[16:12:29.766]                   {
[16:12:29.766]                     if (is.function(workers)) 
[16:12:29.766]                       workers <- workers()
[16:12:29.766]                     workers <- structure(as.integer(workers), 
[16:12:29.766]                       class = class(workers))
[16:12:29.766]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.766]                       workers >= 1)
[16:12:29.766]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.766]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.766]                     }
[16:12:29.766]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.766]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.766]                       envir = envir)
[16:12:29.766]                     if (!future$lazy) 
[16:12:29.766]                       future <- run(future)
[16:12:29.766]                     invisible(future)
[16:12:29.766]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.766]                 }
[16:12:29.766]             }
[16:12:29.766]         }
[16:12:29.766]     })
[16:12:29.766]     if (TRUE) {
[16:12:29.766]         base::sink(type = "output", split = FALSE)
[16:12:29.766]         if (TRUE) {
[16:12:29.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.766]         }
[16:12:29.766]         else {
[16:12:29.766]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.766]         }
[16:12:29.766]         base::close(...future.stdout)
[16:12:29.766]         ...future.stdout <- NULL
[16:12:29.766]     }
[16:12:29.766]     ...future.result$conditions <- ...future.conditions
[16:12:29.766]     ...future.result$finished <- base::Sys.time()
[16:12:29.766]     ...future.result
[16:12:29.766] }
[16:12:29.769] MultisessionFuture started
[16:12:29.769] - Launch lazy future ... done
[16:12:29.770] run() for ‘MultisessionFuture’ ... done
[16:12:29.770] getGlobalsAndPackages() ...
[16:12:29.770] Searching for globals...
[16:12:29.771] - globals found: [1] ‘{’
[16:12:29.771] Searching for globals ... DONE
[16:12:29.771] Resolving globals: FALSE
[16:12:29.771] 
[16:12:29.771] 
[16:12:29.772] getGlobalsAndPackages() ... DONE
[16:12:29.772] run() for ‘Future’ ...
[16:12:29.772] - state: ‘created’
[16:12:29.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.787] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.787]   - Field: ‘node’
[16:12:29.787]   - Field: ‘label’
[16:12:29.787]   - Field: ‘local’
[16:12:29.787]   - Field: ‘owner’
[16:12:29.787]   - Field: ‘envir’
[16:12:29.788]   - Field: ‘workers’
[16:12:29.788]   - Field: ‘packages’
[16:12:29.788]   - Field: ‘gc’
[16:12:29.788]   - Field: ‘conditions’
[16:12:29.788]   - Field: ‘persistent’
[16:12:29.788]   - Field: ‘expr’
[16:12:29.788]   - Field: ‘uuid’
[16:12:29.788]   - Field: ‘seed’
[16:12:29.788]   - Field: ‘version’
[16:12:29.788]   - Field: ‘result’
[16:12:29.789]   - Field: ‘asynchronous’
[16:12:29.789]   - Field: ‘calls’
[16:12:29.789]   - Field: ‘globals’
[16:12:29.789]   - Field: ‘stdout’
[16:12:29.789]   - Field: ‘earlySignal’
[16:12:29.789]   - Field: ‘lazy’
[16:12:29.789]   - Field: ‘state’
[16:12:29.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.789] - Launch lazy future ...
[16:12:29.790] Packages needed by the future expression (n = 0): <none>
[16:12:29.790] Packages needed by future strategies (n = 0): <none>
[16:12:29.790] {
[16:12:29.790]     {
[16:12:29.790]         {
[16:12:29.790]             ...future.startTime <- base::Sys.time()
[16:12:29.790]             {
[16:12:29.790]                 {
[16:12:29.790]                   {
[16:12:29.790]                     {
[16:12:29.790]                       base::local({
[16:12:29.790]                         has_future <- base::requireNamespace("future", 
[16:12:29.790]                           quietly = TRUE)
[16:12:29.790]                         if (has_future) {
[16:12:29.790]                           ns <- base::getNamespace("future")
[16:12:29.790]                           version <- ns[[".package"]][["version"]]
[16:12:29.790]                           if (is.null(version)) 
[16:12:29.790]                             version <- utils::packageVersion("future")
[16:12:29.790]                         }
[16:12:29.790]                         else {
[16:12:29.790]                           version <- NULL
[16:12:29.790]                         }
[16:12:29.790]                         if (!has_future || version < "1.8.0") {
[16:12:29.790]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.790]                             "", base::R.version$version.string), 
[16:12:29.790]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.790]                               "release", "version")], collapse = " "), 
[16:12:29.790]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.790]                             info)
[16:12:29.790]                           info <- base::paste(info, collapse = "; ")
[16:12:29.790]                           if (!has_future) {
[16:12:29.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.790]                               info)
[16:12:29.790]                           }
[16:12:29.790]                           else {
[16:12:29.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.790]                               info, version)
[16:12:29.790]                           }
[16:12:29.790]                           base::stop(msg)
[16:12:29.790]                         }
[16:12:29.790]                       })
[16:12:29.790]                     }
[16:12:29.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.790]                     base::options(mc.cores = 1L)
[16:12:29.790]                   }
[16:12:29.790]                   options(future.plan = NULL)
[16:12:29.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.790]                 }
[16:12:29.790]                 ...future.workdir <- getwd()
[16:12:29.790]             }
[16:12:29.790]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.790]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.790]         }
[16:12:29.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.790]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.790]             base::names(...future.oldOptions))
[16:12:29.790]     }
[16:12:29.790]     if (FALSE) {
[16:12:29.790]     }
[16:12:29.790]     else {
[16:12:29.790]         if (TRUE) {
[16:12:29.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.790]                 open = "w")
[16:12:29.790]         }
[16:12:29.790]         else {
[16:12:29.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.790]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.790]         }
[16:12:29.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.790]             base::sink(type = "output", split = FALSE)
[16:12:29.790]             base::close(...future.stdout)
[16:12:29.790]         }, add = TRUE)
[16:12:29.790]     }
[16:12:29.790]     ...future.frame <- base::sys.nframe()
[16:12:29.790]     ...future.conditions <- base::list()
[16:12:29.790]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.790]     if (FALSE) {
[16:12:29.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.790]     }
[16:12:29.790]     ...future.result <- base::tryCatch({
[16:12:29.790]         base::withCallingHandlers({
[16:12:29.790]             ...future.value <- base::withVisible(base::local({
[16:12:29.790]                 ...future.makeSendCondition <- local({
[16:12:29.790]                   sendCondition <- NULL
[16:12:29.790]                   function(frame = 1L) {
[16:12:29.790]                     if (is.function(sendCondition)) 
[16:12:29.790]                       return(sendCondition)
[16:12:29.790]                     ns <- getNamespace("parallel")
[16:12:29.790]                     if (exists("sendData", mode = "function", 
[16:12:29.790]                       envir = ns)) {
[16:12:29.790]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.790]                         envir = ns)
[16:12:29.790]                       envir <- sys.frame(frame)
[16:12:29.790]                       master <- NULL
[16:12:29.790]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.790]                         !identical(envir, emptyenv())) {
[16:12:29.790]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.790]                           inherits = FALSE)) {
[16:12:29.790]                           master <- get("master", mode = "list", 
[16:12:29.790]                             envir = envir, inherits = FALSE)
[16:12:29.790]                           if (inherits(master, c("SOCKnode", 
[16:12:29.790]                             "SOCK0node"))) {
[16:12:29.790]                             sendCondition <<- function(cond) {
[16:12:29.790]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.790]                                 success = TRUE)
[16:12:29.790]                               parallel_sendData(master, data)
[16:12:29.790]                             }
[16:12:29.790]                             return(sendCondition)
[16:12:29.790]                           }
[16:12:29.790]                         }
[16:12:29.790]                         frame <- frame + 1L
[16:12:29.790]                         envir <- sys.frame(frame)
[16:12:29.790]                       }
[16:12:29.790]                     }
[16:12:29.790]                     sendCondition <<- function(cond) NULL
[16:12:29.790]                   }
[16:12:29.790]                 })
[16:12:29.790]                 withCallingHandlers({
[16:12:29.790]                   {
[16:12:29.790]                     4
[16:12:29.790]                   }
[16:12:29.790]                 }, immediateCondition = function(cond) {
[16:12:29.790]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.790]                   sendCondition(cond)
[16:12:29.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.790]                   {
[16:12:29.790]                     inherits <- base::inherits
[16:12:29.790]                     invokeRestart <- base::invokeRestart
[16:12:29.790]                     is.null <- base::is.null
[16:12:29.790]                     muffled <- FALSE
[16:12:29.790]                     if (inherits(cond, "message")) {
[16:12:29.790]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.790]                       if (muffled) 
[16:12:29.790]                         invokeRestart("muffleMessage")
[16:12:29.790]                     }
[16:12:29.790]                     else if (inherits(cond, "warning")) {
[16:12:29.790]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.790]                       if (muffled) 
[16:12:29.790]                         invokeRestart("muffleWarning")
[16:12:29.790]                     }
[16:12:29.790]                     else if (inherits(cond, "condition")) {
[16:12:29.790]                       if (!is.null(pattern)) {
[16:12:29.790]                         computeRestarts <- base::computeRestarts
[16:12:29.790]                         grepl <- base::grepl
[16:12:29.790]                         restarts <- computeRestarts(cond)
[16:12:29.790]                         for (restart in restarts) {
[16:12:29.790]                           name <- restart$name
[16:12:29.790]                           if (is.null(name)) 
[16:12:29.790]                             next
[16:12:29.790]                           if (!grepl(pattern, name)) 
[16:12:29.790]                             next
[16:12:29.790]                           invokeRestart(restart)
[16:12:29.790]                           muffled <- TRUE
[16:12:29.790]                           break
[16:12:29.790]                         }
[16:12:29.790]                       }
[16:12:29.790]                     }
[16:12:29.790]                     invisible(muffled)
[16:12:29.790]                   }
[16:12:29.790]                   muffleCondition(cond)
[16:12:29.790]                 })
[16:12:29.790]             }))
[16:12:29.790]             future::FutureResult(value = ...future.value$value, 
[16:12:29.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.790]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.790]                     ...future.globalenv.names))
[16:12:29.790]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.790]         }, condition = base::local({
[16:12:29.790]             c <- base::c
[16:12:29.790]             inherits <- base::inherits
[16:12:29.790]             invokeRestart <- base::invokeRestart
[16:12:29.790]             length <- base::length
[16:12:29.790]             list <- base::list
[16:12:29.790]             seq.int <- base::seq.int
[16:12:29.790]             signalCondition <- base::signalCondition
[16:12:29.790]             sys.calls <- base::sys.calls
[16:12:29.790]             `[[` <- base::`[[`
[16:12:29.790]             `+` <- base::`+`
[16:12:29.790]             `<<-` <- base::`<<-`
[16:12:29.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.790]                   3L)]
[16:12:29.790]             }
[16:12:29.790]             function(cond) {
[16:12:29.790]                 is_error <- inherits(cond, "error")
[16:12:29.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.790]                   NULL)
[16:12:29.790]                 if (is_error) {
[16:12:29.790]                   sessionInformation <- function() {
[16:12:29.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.790]                       search = base::search(), system = base::Sys.info())
[16:12:29.790]                   }
[16:12:29.790]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.790]                     cond$call), session = sessionInformation(), 
[16:12:29.790]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.790]                   signalCondition(cond)
[16:12:29.790]                 }
[16:12:29.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.790]                 "immediateCondition"))) {
[16:12:29.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.790]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.790]                   if (TRUE && !signal) {
[16:12:29.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.790]                     {
[16:12:29.790]                       inherits <- base::inherits
[16:12:29.790]                       invokeRestart <- base::invokeRestart
[16:12:29.790]                       is.null <- base::is.null
[16:12:29.790]                       muffled <- FALSE
[16:12:29.790]                       if (inherits(cond, "message")) {
[16:12:29.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.790]                         if (muffled) 
[16:12:29.790]                           invokeRestart("muffleMessage")
[16:12:29.790]                       }
[16:12:29.790]                       else if (inherits(cond, "warning")) {
[16:12:29.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.790]                         if (muffled) 
[16:12:29.790]                           invokeRestart("muffleWarning")
[16:12:29.790]                       }
[16:12:29.790]                       else if (inherits(cond, "condition")) {
[16:12:29.790]                         if (!is.null(pattern)) {
[16:12:29.790]                           computeRestarts <- base::computeRestarts
[16:12:29.790]                           grepl <- base::grepl
[16:12:29.790]                           restarts <- computeRestarts(cond)
[16:12:29.790]                           for (restart in restarts) {
[16:12:29.790]                             name <- restart$name
[16:12:29.790]                             if (is.null(name)) 
[16:12:29.790]                               next
[16:12:29.790]                             if (!grepl(pattern, name)) 
[16:12:29.790]                               next
[16:12:29.790]                             invokeRestart(restart)
[16:12:29.790]                             muffled <- TRUE
[16:12:29.790]                             break
[16:12:29.790]                           }
[16:12:29.790]                         }
[16:12:29.790]                       }
[16:12:29.790]                       invisible(muffled)
[16:12:29.790]                     }
[16:12:29.790]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.790]                   }
[16:12:29.790]                 }
[16:12:29.790]                 else {
[16:12:29.790]                   if (TRUE) {
[16:12:29.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.790]                     {
[16:12:29.790]                       inherits <- base::inherits
[16:12:29.790]                       invokeRestart <- base::invokeRestart
[16:12:29.790]                       is.null <- base::is.null
[16:12:29.790]                       muffled <- FALSE
[16:12:29.790]                       if (inherits(cond, "message")) {
[16:12:29.790]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.790]                         if (muffled) 
[16:12:29.790]                           invokeRestart("muffleMessage")
[16:12:29.790]                       }
[16:12:29.790]                       else if (inherits(cond, "warning")) {
[16:12:29.790]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.790]                         if (muffled) 
[16:12:29.790]                           invokeRestart("muffleWarning")
[16:12:29.790]                       }
[16:12:29.790]                       else if (inherits(cond, "condition")) {
[16:12:29.790]                         if (!is.null(pattern)) {
[16:12:29.790]                           computeRestarts <- base::computeRestarts
[16:12:29.790]                           grepl <- base::grepl
[16:12:29.790]                           restarts <- computeRestarts(cond)
[16:12:29.790]                           for (restart in restarts) {
[16:12:29.790]                             name <- restart$name
[16:12:29.790]                             if (is.null(name)) 
[16:12:29.790]                               next
[16:12:29.790]                             if (!grepl(pattern, name)) 
[16:12:29.790]                               next
[16:12:29.790]                             invokeRestart(restart)
[16:12:29.790]                             muffled <- TRUE
[16:12:29.790]                             break
[16:12:29.790]                           }
[16:12:29.790]                         }
[16:12:29.790]                       }
[16:12:29.790]                       invisible(muffled)
[16:12:29.790]                     }
[16:12:29.790]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.790]                   }
[16:12:29.790]                 }
[16:12:29.790]             }
[16:12:29.790]         }))
[16:12:29.790]     }, error = function(ex) {
[16:12:29.790]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.790]                 ...future.rng), started = ...future.startTime, 
[16:12:29.790]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.790]             version = "1.8"), class = "FutureResult")
[16:12:29.790]     }, finally = {
[16:12:29.790]         if (!identical(...future.workdir, getwd())) 
[16:12:29.790]             setwd(...future.workdir)
[16:12:29.790]         {
[16:12:29.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.790]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.790]             }
[16:12:29.790]             base::options(...future.oldOptions)
[16:12:29.790]             if (.Platform$OS.type == "windows") {
[16:12:29.790]                 old_names <- names(...future.oldEnvVars)
[16:12:29.790]                 envs <- base::Sys.getenv()
[16:12:29.790]                 names <- names(envs)
[16:12:29.790]                 common <- intersect(names, old_names)
[16:12:29.790]                 added <- setdiff(names, old_names)
[16:12:29.790]                 removed <- setdiff(old_names, names)
[16:12:29.790]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.790]                   envs[common]]
[16:12:29.790]                 NAMES <- toupper(changed)
[16:12:29.790]                 args <- list()
[16:12:29.790]                 for (kk in seq_along(NAMES)) {
[16:12:29.790]                   name <- changed[[kk]]
[16:12:29.790]                   NAME <- NAMES[[kk]]
[16:12:29.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.790]                     next
[16:12:29.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.790]                 }
[16:12:29.790]                 NAMES <- toupper(added)
[16:12:29.790]                 for (kk in seq_along(NAMES)) {
[16:12:29.790]                   name <- added[[kk]]
[16:12:29.790]                   NAME <- NAMES[[kk]]
[16:12:29.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.790]                     next
[16:12:29.790]                   args[[name]] <- ""
[16:12:29.790]                 }
[16:12:29.790]                 NAMES <- toupper(removed)
[16:12:29.790]                 for (kk in seq_along(NAMES)) {
[16:12:29.790]                   name <- removed[[kk]]
[16:12:29.790]                   NAME <- NAMES[[kk]]
[16:12:29.790]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.790]                     next
[16:12:29.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.790]                 }
[16:12:29.790]                 if (length(args) > 0) 
[16:12:29.790]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.790]             }
[16:12:29.790]             else {
[16:12:29.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.790]             }
[16:12:29.790]             {
[16:12:29.790]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.790]                   0L) {
[16:12:29.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.790]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.790]                   base::options(opts)
[16:12:29.790]                 }
[16:12:29.790]                 {
[16:12:29.790]                   {
[16:12:29.790]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.790]                     NULL
[16:12:29.790]                   }
[16:12:29.790]                   options(future.plan = NULL)
[16:12:29.790]                   if (is.na(NA_character_)) 
[16:12:29.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.790]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.790]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.790]                     envir = parent.frame()) 
[16:12:29.790]                   {
[16:12:29.790]                     if (is.function(workers)) 
[16:12:29.790]                       workers <- workers()
[16:12:29.790]                     workers <- structure(as.integer(workers), 
[16:12:29.790]                       class = class(workers))
[16:12:29.790]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.790]                       workers >= 1)
[16:12:29.790]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.790]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.790]                     }
[16:12:29.790]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.790]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.790]                       envir = envir)
[16:12:29.790]                     if (!future$lazy) 
[16:12:29.790]                       future <- run(future)
[16:12:29.790]                     invisible(future)
[16:12:29.790]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.790]                 }
[16:12:29.790]             }
[16:12:29.790]         }
[16:12:29.790]     })
[16:12:29.790]     if (TRUE) {
[16:12:29.790]         base::sink(type = "output", split = FALSE)
[16:12:29.790]         if (TRUE) {
[16:12:29.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.790]         }
[16:12:29.790]         else {
[16:12:29.790]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.790]         }
[16:12:29.790]         base::close(...future.stdout)
[16:12:29.790]         ...future.stdout <- NULL
[16:12:29.790]     }
[16:12:29.790]     ...future.result$conditions <- ...future.conditions
[16:12:29.790]     ...future.result$finished <- base::Sys.time()
[16:12:29.790]     ...future.result
[16:12:29.790] }
[16:12:29.794] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:29.804] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.804] - Validating connection of MultisessionFuture
[16:12:29.805] - received message: FutureResult
[16:12:29.805] - Received FutureResult
[16:12:29.805] - Erased future from FutureRegistry
[16:12:29.805] result() for ClusterFuture ...
[16:12:29.805] - result already collected: FutureResult
[16:12:29.805] result() for ClusterFuture ... done
[16:12:29.805] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:29.805] result() for ClusterFuture ...
[16:12:29.805] - result already collected: FutureResult
[16:12:29.806] result() for ClusterFuture ... done
[16:12:29.806] result() for ClusterFuture ...
[16:12:29.806] - result already collected: FutureResult
[16:12:29.806] result() for ClusterFuture ... done
[16:12:29.807] MultisessionFuture started
[16:12:29.807] - Launch lazy future ... done
[16:12:29.807] run() for ‘MultisessionFuture’ ... done
<environment: 0x560bafb62180> 
<environment: 0x560bb094dfb8> 
[16:12:29.816] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.817] - Validating connection of MultisessionFuture
[16:12:29.817] - received message: FutureResult
[16:12:29.817] - Received FutureResult
[16:12:29.817] - Erased future from FutureRegistry
[16:12:29.817] result() for ClusterFuture ...
[16:12:29.817] - result already collected: FutureResult
[16:12:29.818] result() for ClusterFuture ... done
[16:12:29.818] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:29.829] resolve() on environment ...
[16:12:29.830]  recursive: 0
[16:12:29.830]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:29.830] signalConditionsASAP(numeric, pos=1) ...
[16:12:29.830] - nx: 4
[16:12:29.830] - relay: TRUE
[16:12:29.830] - stdout: TRUE
[16:12:29.831] - signal: TRUE
[16:12:29.831] - resignal: FALSE
[16:12:29.831] - force: TRUE
[16:12:29.831] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.831] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.831]  - until=2
[16:12:29.831]  - relaying element #2
[16:12:29.831] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.831] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.831] signalConditionsASAP(NULL, pos=1) ... done
[16:12:29.831]  length: 3 (resolved future 1)
[16:12:29.832] Future #2
[16:12:29.832] result() for ClusterFuture ...
[16:12:29.832] - result already collected: FutureResult
[16:12:29.832] result() for ClusterFuture ... done
[16:12:29.832] result() for ClusterFuture ...
[16:12:29.832] - result already collected: FutureResult
[16:12:29.832] result() for ClusterFuture ... done
[16:12:29.832] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:29.832] - nx: 4
[16:12:29.833] - relay: TRUE
[16:12:29.833] - stdout: TRUE
[16:12:29.833] - signal: TRUE
[16:12:29.833] - resignal: FALSE
[16:12:29.833] - force: TRUE
[16:12:29.833] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.833] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.836]  - until=2
[16:12:29.836]  - relaying element #2
[16:12:29.836] result() for ClusterFuture ...
[16:12:29.836] - result already collected: FutureResult
[16:12:29.836] result() for ClusterFuture ... done
[16:12:29.836] result() for ClusterFuture ...
[16:12:29.837] - result already collected: FutureResult
[16:12:29.837] result() for ClusterFuture ... done
[16:12:29.837] result() for ClusterFuture ...
[16:12:29.837] - result already collected: FutureResult
[16:12:29.837] result() for ClusterFuture ... done
[16:12:29.837] result() for ClusterFuture ...
[16:12:29.837] - result already collected: FutureResult
[16:12:29.837] result() for ClusterFuture ... done
[16:12:29.837] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.837] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.837] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:29.838]  length: 2 (resolved future 2)
[16:12:29.838] Future #3
[16:12:29.838] result() for ClusterFuture ...
[16:12:29.838] - result already collected: FutureResult
[16:12:29.838] result() for ClusterFuture ... done
[16:12:29.838] result() for ClusterFuture ...
[16:12:29.838] - result already collected: FutureResult
[16:12:29.838] result() for ClusterFuture ... done
[16:12:29.838] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:29.838] - nx: 4
[16:12:29.838] - relay: TRUE
[16:12:29.839] - stdout: TRUE
[16:12:29.839] - signal: TRUE
[16:12:29.839] - resignal: FALSE
[16:12:29.839] - force: TRUE
[16:12:29.839] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.839] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.839]  - until=3
[16:12:29.839]  - relaying element #3
[16:12:29.839] result() for ClusterFuture ...
[16:12:29.839] - result already collected: FutureResult
[16:12:29.839] result() for ClusterFuture ... done
[16:12:29.840] result() for ClusterFuture ...
[16:12:29.840] - result already collected: FutureResult
[16:12:29.840] result() for ClusterFuture ... done
[16:12:29.840] result() for ClusterFuture ...
[16:12:29.840] - result already collected: FutureResult
[16:12:29.840] result() for ClusterFuture ... done
[16:12:29.840] result() for ClusterFuture ...
[16:12:29.840] - result already collected: FutureResult
[16:12:29.840] result() for ClusterFuture ... done
[16:12:29.840] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.840] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.841] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:29.841]  length: 1 (resolved future 3)
[16:12:29.862] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.862] - Validating connection of MultisessionFuture
[16:12:29.862] - received message: FutureResult
[16:12:29.862] - Received FutureResult
[16:12:29.862] - Erased future from FutureRegistry
[16:12:29.863] result() for ClusterFuture ...
[16:12:29.863] - result already collected: FutureResult
[16:12:29.863] result() for ClusterFuture ... done
[16:12:29.863] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:29.863] Future #4
[16:12:29.863] result() for ClusterFuture ...
[16:12:29.863] - result already collected: FutureResult
[16:12:29.863] result() for ClusterFuture ... done
[16:12:29.863] result() for ClusterFuture ...
[16:12:29.863] - result already collected: FutureResult
[16:12:29.863] result() for ClusterFuture ... done
[16:12:29.864] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:29.864] - nx: 4
[16:12:29.864] - relay: TRUE
[16:12:29.864] - stdout: TRUE
[16:12:29.864] - signal: TRUE
[16:12:29.864] - resignal: FALSE
[16:12:29.864] - force: TRUE
[16:12:29.864] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.864] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.864]  - until=4
[16:12:29.864]  - relaying element #4
[16:12:29.865] result() for ClusterFuture ...
[16:12:29.865] - result already collected: FutureResult
[16:12:29.865] result() for ClusterFuture ... done
[16:12:29.865] result() for ClusterFuture ...
[16:12:29.865] - result already collected: FutureResult
[16:12:29.865] result() for ClusterFuture ... done
[16:12:29.865] result() for ClusterFuture ...
[16:12:29.865] - result already collected: FutureResult
[16:12:29.865] result() for ClusterFuture ... done
[16:12:29.865] result() for ClusterFuture ...
[16:12:29.865] - result already collected: FutureResult
[16:12:29.866] result() for ClusterFuture ... done
[16:12:29.866] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.866] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.866] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:29.866]  length: 0 (resolved future 4)
[16:12:29.866] Relaying remaining futures
[16:12:29.866] signalConditionsASAP(NULL, pos=0) ...
[16:12:29.866] - nx: 4
[16:12:29.866] - relay: TRUE
[16:12:29.866] - stdout: TRUE
[16:12:29.866] - signal: TRUE
[16:12:29.866] - resignal: FALSE
[16:12:29.867] - force: TRUE
[16:12:29.867] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.867] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:29.867] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:29.867] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:29.867] signalConditionsASAP(NULL, pos=0) ... done
[16:12:29.867] resolve() on environment ... DONE
[16:12:29.867] result() for ClusterFuture ...
[16:12:29.867] - result already collected: FutureResult
[16:12:29.867] result() for ClusterFuture ... done
[16:12:29.868] result() for ClusterFuture ...
[16:12:29.868] - result already collected: FutureResult
[16:12:29.868] result() for ClusterFuture ... done
[16:12:29.868] result() for ClusterFuture ...
[16:12:29.868] - result already collected: FutureResult
[16:12:29.868] result() for ClusterFuture ... done
[16:12:29.868] result() for ClusterFuture ...
[16:12:29.868] - result already collected: FutureResult
[16:12:29.868] result() for ClusterFuture ... done
[16:12:29.868] result() for ClusterFuture ...
[16:12:29.868] - result already collected: FutureResult
[16:12:29.869] result() for ClusterFuture ... done
[16:12:29.869] result() for ClusterFuture ...
[16:12:29.869] - result already collected: FutureResult
[16:12:29.869] result() for ClusterFuture ... done
<environment: 0x560bb0a988f0> 
Dimensions: c(2, 3)
[16:12:29.869] getGlobalsAndPackages() ...
[16:12:29.869] Searching for globals...
[16:12:29.870] 
[16:12:29.870] Searching for globals ... DONE
[16:12:29.870] - globals: [0] <none>
[16:12:29.870] getGlobalsAndPackages() ... DONE
[16:12:29.870] run() for ‘Future’ ...
[16:12:29.870] - state: ‘created’
[16:12:29.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.885]   - Field: ‘node’
[16:12:29.885]   - Field: ‘label’
[16:12:29.885]   - Field: ‘local’
[16:12:29.885]   - Field: ‘owner’
[16:12:29.886]   - Field: ‘envir’
[16:12:29.886]   - Field: ‘workers’
[16:12:29.886]   - Field: ‘packages’
[16:12:29.886]   - Field: ‘gc’
[16:12:29.886]   - Field: ‘conditions’
[16:12:29.886]   - Field: ‘persistent’
[16:12:29.886]   - Field: ‘expr’
[16:12:29.886]   - Field: ‘uuid’
[16:12:29.886]   - Field: ‘seed’
[16:12:29.886]   - Field: ‘version’
[16:12:29.887]   - Field: ‘result’
[16:12:29.887]   - Field: ‘asynchronous’
[16:12:29.887]   - Field: ‘calls’
[16:12:29.887]   - Field: ‘globals’
[16:12:29.887]   - Field: ‘stdout’
[16:12:29.887]   - Field: ‘earlySignal’
[16:12:29.887]   - Field: ‘lazy’
[16:12:29.887]   - Field: ‘state’
[16:12:29.887] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.887] - Launch lazy future ...
[16:12:29.888] Packages needed by the future expression (n = 0): <none>
[16:12:29.888] Packages needed by future strategies (n = 0): <none>
[16:12:29.888] {
[16:12:29.888]     {
[16:12:29.888]         {
[16:12:29.888]             ...future.startTime <- base::Sys.time()
[16:12:29.888]             {
[16:12:29.888]                 {
[16:12:29.888]                   {
[16:12:29.888]                     {
[16:12:29.888]                       base::local({
[16:12:29.888]                         has_future <- base::requireNamespace("future", 
[16:12:29.888]                           quietly = TRUE)
[16:12:29.888]                         if (has_future) {
[16:12:29.888]                           ns <- base::getNamespace("future")
[16:12:29.888]                           version <- ns[[".package"]][["version"]]
[16:12:29.888]                           if (is.null(version)) 
[16:12:29.888]                             version <- utils::packageVersion("future")
[16:12:29.888]                         }
[16:12:29.888]                         else {
[16:12:29.888]                           version <- NULL
[16:12:29.888]                         }
[16:12:29.888]                         if (!has_future || version < "1.8.0") {
[16:12:29.888]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.888]                             "", base::R.version$version.string), 
[16:12:29.888]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.888]                               "release", "version")], collapse = " "), 
[16:12:29.888]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.888]                             info)
[16:12:29.888]                           info <- base::paste(info, collapse = "; ")
[16:12:29.888]                           if (!has_future) {
[16:12:29.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.888]                               info)
[16:12:29.888]                           }
[16:12:29.888]                           else {
[16:12:29.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.888]                               info, version)
[16:12:29.888]                           }
[16:12:29.888]                           base::stop(msg)
[16:12:29.888]                         }
[16:12:29.888]                       })
[16:12:29.888]                     }
[16:12:29.888]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.888]                     base::options(mc.cores = 1L)
[16:12:29.888]                   }
[16:12:29.888]                   options(future.plan = NULL)
[16:12:29.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.888]                 }
[16:12:29.888]                 ...future.workdir <- getwd()
[16:12:29.888]             }
[16:12:29.888]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.888]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.888]         }
[16:12:29.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.888]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.888]             base::names(...future.oldOptions))
[16:12:29.888]     }
[16:12:29.888]     if (FALSE) {
[16:12:29.888]     }
[16:12:29.888]     else {
[16:12:29.888]         if (TRUE) {
[16:12:29.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.888]                 open = "w")
[16:12:29.888]         }
[16:12:29.888]         else {
[16:12:29.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.888]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.888]         }
[16:12:29.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.888]             base::sink(type = "output", split = FALSE)
[16:12:29.888]             base::close(...future.stdout)
[16:12:29.888]         }, add = TRUE)
[16:12:29.888]     }
[16:12:29.888]     ...future.frame <- base::sys.nframe()
[16:12:29.888]     ...future.conditions <- base::list()
[16:12:29.888]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.888]     if (FALSE) {
[16:12:29.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.888]     }
[16:12:29.888]     ...future.result <- base::tryCatch({
[16:12:29.888]         base::withCallingHandlers({
[16:12:29.888]             ...future.value <- base::withVisible(base::local({
[16:12:29.888]                 ...future.makeSendCondition <- local({
[16:12:29.888]                   sendCondition <- NULL
[16:12:29.888]                   function(frame = 1L) {
[16:12:29.888]                     if (is.function(sendCondition)) 
[16:12:29.888]                       return(sendCondition)
[16:12:29.888]                     ns <- getNamespace("parallel")
[16:12:29.888]                     if (exists("sendData", mode = "function", 
[16:12:29.888]                       envir = ns)) {
[16:12:29.888]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.888]                         envir = ns)
[16:12:29.888]                       envir <- sys.frame(frame)
[16:12:29.888]                       master <- NULL
[16:12:29.888]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.888]                         !identical(envir, emptyenv())) {
[16:12:29.888]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.888]                           inherits = FALSE)) {
[16:12:29.888]                           master <- get("master", mode = "list", 
[16:12:29.888]                             envir = envir, inherits = FALSE)
[16:12:29.888]                           if (inherits(master, c("SOCKnode", 
[16:12:29.888]                             "SOCK0node"))) {
[16:12:29.888]                             sendCondition <<- function(cond) {
[16:12:29.888]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.888]                                 success = TRUE)
[16:12:29.888]                               parallel_sendData(master, data)
[16:12:29.888]                             }
[16:12:29.888]                             return(sendCondition)
[16:12:29.888]                           }
[16:12:29.888]                         }
[16:12:29.888]                         frame <- frame + 1L
[16:12:29.888]                         envir <- sys.frame(frame)
[16:12:29.888]                       }
[16:12:29.888]                     }
[16:12:29.888]                     sendCondition <<- function(cond) NULL
[16:12:29.888]                   }
[16:12:29.888]                 })
[16:12:29.888]                 withCallingHandlers({
[16:12:29.888]                   2
[16:12:29.888]                 }, immediateCondition = function(cond) {
[16:12:29.888]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.888]                   sendCondition(cond)
[16:12:29.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.888]                   {
[16:12:29.888]                     inherits <- base::inherits
[16:12:29.888]                     invokeRestart <- base::invokeRestart
[16:12:29.888]                     is.null <- base::is.null
[16:12:29.888]                     muffled <- FALSE
[16:12:29.888]                     if (inherits(cond, "message")) {
[16:12:29.888]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.888]                       if (muffled) 
[16:12:29.888]                         invokeRestart("muffleMessage")
[16:12:29.888]                     }
[16:12:29.888]                     else if (inherits(cond, "warning")) {
[16:12:29.888]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.888]                       if (muffled) 
[16:12:29.888]                         invokeRestart("muffleWarning")
[16:12:29.888]                     }
[16:12:29.888]                     else if (inherits(cond, "condition")) {
[16:12:29.888]                       if (!is.null(pattern)) {
[16:12:29.888]                         computeRestarts <- base::computeRestarts
[16:12:29.888]                         grepl <- base::grepl
[16:12:29.888]                         restarts <- computeRestarts(cond)
[16:12:29.888]                         for (restart in restarts) {
[16:12:29.888]                           name <- restart$name
[16:12:29.888]                           if (is.null(name)) 
[16:12:29.888]                             next
[16:12:29.888]                           if (!grepl(pattern, name)) 
[16:12:29.888]                             next
[16:12:29.888]                           invokeRestart(restart)
[16:12:29.888]                           muffled <- TRUE
[16:12:29.888]                           break
[16:12:29.888]                         }
[16:12:29.888]                       }
[16:12:29.888]                     }
[16:12:29.888]                     invisible(muffled)
[16:12:29.888]                   }
[16:12:29.888]                   muffleCondition(cond)
[16:12:29.888]                 })
[16:12:29.888]             }))
[16:12:29.888]             future::FutureResult(value = ...future.value$value, 
[16:12:29.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.888]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.888]                     ...future.globalenv.names))
[16:12:29.888]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.888]         }, condition = base::local({
[16:12:29.888]             c <- base::c
[16:12:29.888]             inherits <- base::inherits
[16:12:29.888]             invokeRestart <- base::invokeRestart
[16:12:29.888]             length <- base::length
[16:12:29.888]             list <- base::list
[16:12:29.888]             seq.int <- base::seq.int
[16:12:29.888]             signalCondition <- base::signalCondition
[16:12:29.888]             sys.calls <- base::sys.calls
[16:12:29.888]             `[[` <- base::`[[`
[16:12:29.888]             `+` <- base::`+`
[16:12:29.888]             `<<-` <- base::`<<-`
[16:12:29.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.888]                   3L)]
[16:12:29.888]             }
[16:12:29.888]             function(cond) {
[16:12:29.888]                 is_error <- inherits(cond, "error")
[16:12:29.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.888]                   NULL)
[16:12:29.888]                 if (is_error) {
[16:12:29.888]                   sessionInformation <- function() {
[16:12:29.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.888]                       search = base::search(), system = base::Sys.info())
[16:12:29.888]                   }
[16:12:29.888]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.888]                     cond$call), session = sessionInformation(), 
[16:12:29.888]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.888]                   signalCondition(cond)
[16:12:29.888]                 }
[16:12:29.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.888]                 "immediateCondition"))) {
[16:12:29.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.888]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.888]                   if (TRUE && !signal) {
[16:12:29.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.888]                     {
[16:12:29.888]                       inherits <- base::inherits
[16:12:29.888]                       invokeRestart <- base::invokeRestart
[16:12:29.888]                       is.null <- base::is.null
[16:12:29.888]                       muffled <- FALSE
[16:12:29.888]                       if (inherits(cond, "message")) {
[16:12:29.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.888]                         if (muffled) 
[16:12:29.888]                           invokeRestart("muffleMessage")
[16:12:29.888]                       }
[16:12:29.888]                       else if (inherits(cond, "warning")) {
[16:12:29.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.888]                         if (muffled) 
[16:12:29.888]                           invokeRestart("muffleWarning")
[16:12:29.888]                       }
[16:12:29.888]                       else if (inherits(cond, "condition")) {
[16:12:29.888]                         if (!is.null(pattern)) {
[16:12:29.888]                           computeRestarts <- base::computeRestarts
[16:12:29.888]                           grepl <- base::grepl
[16:12:29.888]                           restarts <- computeRestarts(cond)
[16:12:29.888]                           for (restart in restarts) {
[16:12:29.888]                             name <- restart$name
[16:12:29.888]                             if (is.null(name)) 
[16:12:29.888]                               next
[16:12:29.888]                             if (!grepl(pattern, name)) 
[16:12:29.888]                               next
[16:12:29.888]                             invokeRestart(restart)
[16:12:29.888]                             muffled <- TRUE
[16:12:29.888]                             break
[16:12:29.888]                           }
[16:12:29.888]                         }
[16:12:29.888]                       }
[16:12:29.888]                       invisible(muffled)
[16:12:29.888]                     }
[16:12:29.888]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.888]                   }
[16:12:29.888]                 }
[16:12:29.888]                 else {
[16:12:29.888]                   if (TRUE) {
[16:12:29.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.888]                     {
[16:12:29.888]                       inherits <- base::inherits
[16:12:29.888]                       invokeRestart <- base::invokeRestart
[16:12:29.888]                       is.null <- base::is.null
[16:12:29.888]                       muffled <- FALSE
[16:12:29.888]                       if (inherits(cond, "message")) {
[16:12:29.888]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.888]                         if (muffled) 
[16:12:29.888]                           invokeRestart("muffleMessage")
[16:12:29.888]                       }
[16:12:29.888]                       else if (inherits(cond, "warning")) {
[16:12:29.888]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.888]                         if (muffled) 
[16:12:29.888]                           invokeRestart("muffleWarning")
[16:12:29.888]                       }
[16:12:29.888]                       else if (inherits(cond, "condition")) {
[16:12:29.888]                         if (!is.null(pattern)) {
[16:12:29.888]                           computeRestarts <- base::computeRestarts
[16:12:29.888]                           grepl <- base::grepl
[16:12:29.888]                           restarts <- computeRestarts(cond)
[16:12:29.888]                           for (restart in restarts) {
[16:12:29.888]                             name <- restart$name
[16:12:29.888]                             if (is.null(name)) 
[16:12:29.888]                               next
[16:12:29.888]                             if (!grepl(pattern, name)) 
[16:12:29.888]                               next
[16:12:29.888]                             invokeRestart(restart)
[16:12:29.888]                             muffled <- TRUE
[16:12:29.888]                             break
[16:12:29.888]                           }
[16:12:29.888]                         }
[16:12:29.888]                       }
[16:12:29.888]                       invisible(muffled)
[16:12:29.888]                     }
[16:12:29.888]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.888]                   }
[16:12:29.888]                 }
[16:12:29.888]             }
[16:12:29.888]         }))
[16:12:29.888]     }, error = function(ex) {
[16:12:29.888]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.888]                 ...future.rng), started = ...future.startTime, 
[16:12:29.888]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.888]             version = "1.8"), class = "FutureResult")
[16:12:29.888]     }, finally = {
[16:12:29.888]         if (!identical(...future.workdir, getwd())) 
[16:12:29.888]             setwd(...future.workdir)
[16:12:29.888]         {
[16:12:29.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.888]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.888]             }
[16:12:29.888]             base::options(...future.oldOptions)
[16:12:29.888]             if (.Platform$OS.type == "windows") {
[16:12:29.888]                 old_names <- names(...future.oldEnvVars)
[16:12:29.888]                 envs <- base::Sys.getenv()
[16:12:29.888]                 names <- names(envs)
[16:12:29.888]                 common <- intersect(names, old_names)
[16:12:29.888]                 added <- setdiff(names, old_names)
[16:12:29.888]                 removed <- setdiff(old_names, names)
[16:12:29.888]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.888]                   envs[common]]
[16:12:29.888]                 NAMES <- toupper(changed)
[16:12:29.888]                 args <- list()
[16:12:29.888]                 for (kk in seq_along(NAMES)) {
[16:12:29.888]                   name <- changed[[kk]]
[16:12:29.888]                   NAME <- NAMES[[kk]]
[16:12:29.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.888]                     next
[16:12:29.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.888]                 }
[16:12:29.888]                 NAMES <- toupper(added)
[16:12:29.888]                 for (kk in seq_along(NAMES)) {
[16:12:29.888]                   name <- added[[kk]]
[16:12:29.888]                   NAME <- NAMES[[kk]]
[16:12:29.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.888]                     next
[16:12:29.888]                   args[[name]] <- ""
[16:12:29.888]                 }
[16:12:29.888]                 NAMES <- toupper(removed)
[16:12:29.888]                 for (kk in seq_along(NAMES)) {
[16:12:29.888]                   name <- removed[[kk]]
[16:12:29.888]                   NAME <- NAMES[[kk]]
[16:12:29.888]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.888]                     next
[16:12:29.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.888]                 }
[16:12:29.888]                 if (length(args) > 0) 
[16:12:29.888]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.888]             }
[16:12:29.888]             else {
[16:12:29.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.888]             }
[16:12:29.888]             {
[16:12:29.888]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.888]                   0L) {
[16:12:29.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.888]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.888]                   base::options(opts)
[16:12:29.888]                 }
[16:12:29.888]                 {
[16:12:29.888]                   {
[16:12:29.888]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.888]                     NULL
[16:12:29.888]                   }
[16:12:29.888]                   options(future.plan = NULL)
[16:12:29.888]                   if (is.na(NA_character_)) 
[16:12:29.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.888]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.888]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.888]                     envir = parent.frame()) 
[16:12:29.888]                   {
[16:12:29.888]                     if (is.function(workers)) 
[16:12:29.888]                       workers <- workers()
[16:12:29.888]                     workers <- structure(as.integer(workers), 
[16:12:29.888]                       class = class(workers))
[16:12:29.888]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.888]                       workers >= 1)
[16:12:29.888]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.888]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.888]                     }
[16:12:29.888]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.888]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.888]                       envir = envir)
[16:12:29.888]                     if (!future$lazy) 
[16:12:29.888]                       future <- run(future)
[16:12:29.888]                     invisible(future)
[16:12:29.888]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.888]                 }
[16:12:29.888]             }
[16:12:29.888]         }
[16:12:29.888]     })
[16:12:29.888]     if (TRUE) {
[16:12:29.888]         base::sink(type = "output", split = FALSE)
[16:12:29.888]         if (TRUE) {
[16:12:29.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.888]         }
[16:12:29.888]         else {
[16:12:29.888]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.888]         }
[16:12:29.888]         base::close(...future.stdout)
[16:12:29.888]         ...future.stdout <- NULL
[16:12:29.888]     }
[16:12:29.888]     ...future.result$conditions <- ...future.conditions
[16:12:29.888]     ...future.result$finished <- base::Sys.time()
[16:12:29.888]     ...future.result
[16:12:29.888] }
[16:12:29.891] MultisessionFuture started
[16:12:29.891] - Launch lazy future ... done
[16:12:29.892] run() for ‘MultisessionFuture’ ... done
[16:12:29.892] getGlobalsAndPackages() ...
[16:12:29.892] Searching for globals...
[16:12:29.892] 
[16:12:29.892] Searching for globals ... DONE
[16:12:29.892] - globals: [0] <none>
[16:12:29.893] getGlobalsAndPackages() ... DONE
[16:12:29.893] run() for ‘Future’ ...
[16:12:29.893] - state: ‘created’
[16:12:29.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.908] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.908] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.908]   - Field: ‘node’
[16:12:29.908]   - Field: ‘label’
[16:12:29.908]   - Field: ‘local’
[16:12:29.909]   - Field: ‘owner’
[16:12:29.909]   - Field: ‘envir’
[16:12:29.909]   - Field: ‘workers’
[16:12:29.909]   - Field: ‘packages’
[16:12:29.909]   - Field: ‘gc’
[16:12:29.909]   - Field: ‘conditions’
[16:12:29.909]   - Field: ‘persistent’
[16:12:29.909]   - Field: ‘expr’
[16:12:29.909]   - Field: ‘uuid’
[16:12:29.909]   - Field: ‘seed’
[16:12:29.909]   - Field: ‘version’
[16:12:29.910]   - Field: ‘result’
[16:12:29.910]   - Field: ‘asynchronous’
[16:12:29.910]   - Field: ‘calls’
[16:12:29.910]   - Field: ‘globals’
[16:12:29.910]   - Field: ‘stdout’
[16:12:29.910]   - Field: ‘earlySignal’
[16:12:29.910]   - Field: ‘lazy’
[16:12:29.910]   - Field: ‘state’
[16:12:29.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.910] - Launch lazy future ...
[16:12:29.911] Packages needed by the future expression (n = 0): <none>
[16:12:29.911] Packages needed by future strategies (n = 0): <none>
[16:12:29.911] {
[16:12:29.911]     {
[16:12:29.911]         {
[16:12:29.911]             ...future.startTime <- base::Sys.time()
[16:12:29.911]             {
[16:12:29.911]                 {
[16:12:29.911]                   {
[16:12:29.911]                     {
[16:12:29.911]                       base::local({
[16:12:29.911]                         has_future <- base::requireNamespace("future", 
[16:12:29.911]                           quietly = TRUE)
[16:12:29.911]                         if (has_future) {
[16:12:29.911]                           ns <- base::getNamespace("future")
[16:12:29.911]                           version <- ns[[".package"]][["version"]]
[16:12:29.911]                           if (is.null(version)) 
[16:12:29.911]                             version <- utils::packageVersion("future")
[16:12:29.911]                         }
[16:12:29.911]                         else {
[16:12:29.911]                           version <- NULL
[16:12:29.911]                         }
[16:12:29.911]                         if (!has_future || version < "1.8.0") {
[16:12:29.911]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.911]                             "", base::R.version$version.string), 
[16:12:29.911]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.911]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.911]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.911]                               "release", "version")], collapse = " "), 
[16:12:29.911]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.911]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.911]                             info)
[16:12:29.911]                           info <- base::paste(info, collapse = "; ")
[16:12:29.911]                           if (!has_future) {
[16:12:29.911]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.911]                               info)
[16:12:29.911]                           }
[16:12:29.911]                           else {
[16:12:29.911]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.911]                               info, version)
[16:12:29.911]                           }
[16:12:29.911]                           base::stop(msg)
[16:12:29.911]                         }
[16:12:29.911]                       })
[16:12:29.911]                     }
[16:12:29.911]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.911]                     base::options(mc.cores = 1L)
[16:12:29.911]                   }
[16:12:29.911]                   options(future.plan = NULL)
[16:12:29.911]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.911]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.911]                 }
[16:12:29.911]                 ...future.workdir <- getwd()
[16:12:29.911]             }
[16:12:29.911]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.911]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.911]         }
[16:12:29.911]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.911]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.911]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.911]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.911]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.911]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.911]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.911]             base::names(...future.oldOptions))
[16:12:29.911]     }
[16:12:29.911]     if (FALSE) {
[16:12:29.911]     }
[16:12:29.911]     else {
[16:12:29.911]         if (TRUE) {
[16:12:29.911]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.911]                 open = "w")
[16:12:29.911]         }
[16:12:29.911]         else {
[16:12:29.911]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.911]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.911]         }
[16:12:29.911]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.911]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.911]             base::sink(type = "output", split = FALSE)
[16:12:29.911]             base::close(...future.stdout)
[16:12:29.911]         }, add = TRUE)
[16:12:29.911]     }
[16:12:29.911]     ...future.frame <- base::sys.nframe()
[16:12:29.911]     ...future.conditions <- base::list()
[16:12:29.911]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.911]     if (FALSE) {
[16:12:29.911]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.911]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.911]     }
[16:12:29.911]     ...future.result <- base::tryCatch({
[16:12:29.911]         base::withCallingHandlers({
[16:12:29.911]             ...future.value <- base::withVisible(base::local({
[16:12:29.911]                 ...future.makeSendCondition <- local({
[16:12:29.911]                   sendCondition <- NULL
[16:12:29.911]                   function(frame = 1L) {
[16:12:29.911]                     if (is.function(sendCondition)) 
[16:12:29.911]                       return(sendCondition)
[16:12:29.911]                     ns <- getNamespace("parallel")
[16:12:29.911]                     if (exists("sendData", mode = "function", 
[16:12:29.911]                       envir = ns)) {
[16:12:29.911]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.911]                         envir = ns)
[16:12:29.911]                       envir <- sys.frame(frame)
[16:12:29.911]                       master <- NULL
[16:12:29.911]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.911]                         !identical(envir, emptyenv())) {
[16:12:29.911]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.911]                           inherits = FALSE)) {
[16:12:29.911]                           master <- get("master", mode = "list", 
[16:12:29.911]                             envir = envir, inherits = FALSE)
[16:12:29.911]                           if (inherits(master, c("SOCKnode", 
[16:12:29.911]                             "SOCK0node"))) {
[16:12:29.911]                             sendCondition <<- function(cond) {
[16:12:29.911]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.911]                                 success = TRUE)
[16:12:29.911]                               parallel_sendData(master, data)
[16:12:29.911]                             }
[16:12:29.911]                             return(sendCondition)
[16:12:29.911]                           }
[16:12:29.911]                         }
[16:12:29.911]                         frame <- frame + 1L
[16:12:29.911]                         envir <- sys.frame(frame)
[16:12:29.911]                       }
[16:12:29.911]                     }
[16:12:29.911]                     sendCondition <<- function(cond) NULL
[16:12:29.911]                   }
[16:12:29.911]                 })
[16:12:29.911]                 withCallingHandlers({
[16:12:29.911]                   NULL
[16:12:29.911]                 }, immediateCondition = function(cond) {
[16:12:29.911]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.911]                   sendCondition(cond)
[16:12:29.911]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.911]                   {
[16:12:29.911]                     inherits <- base::inherits
[16:12:29.911]                     invokeRestart <- base::invokeRestart
[16:12:29.911]                     is.null <- base::is.null
[16:12:29.911]                     muffled <- FALSE
[16:12:29.911]                     if (inherits(cond, "message")) {
[16:12:29.911]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.911]                       if (muffled) 
[16:12:29.911]                         invokeRestart("muffleMessage")
[16:12:29.911]                     }
[16:12:29.911]                     else if (inherits(cond, "warning")) {
[16:12:29.911]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.911]                       if (muffled) 
[16:12:29.911]                         invokeRestart("muffleWarning")
[16:12:29.911]                     }
[16:12:29.911]                     else if (inherits(cond, "condition")) {
[16:12:29.911]                       if (!is.null(pattern)) {
[16:12:29.911]                         computeRestarts <- base::computeRestarts
[16:12:29.911]                         grepl <- base::grepl
[16:12:29.911]                         restarts <- computeRestarts(cond)
[16:12:29.911]                         for (restart in restarts) {
[16:12:29.911]                           name <- restart$name
[16:12:29.911]                           if (is.null(name)) 
[16:12:29.911]                             next
[16:12:29.911]                           if (!grepl(pattern, name)) 
[16:12:29.911]                             next
[16:12:29.911]                           invokeRestart(restart)
[16:12:29.911]                           muffled <- TRUE
[16:12:29.911]                           break
[16:12:29.911]                         }
[16:12:29.911]                       }
[16:12:29.911]                     }
[16:12:29.911]                     invisible(muffled)
[16:12:29.911]                   }
[16:12:29.911]                   muffleCondition(cond)
[16:12:29.911]                 })
[16:12:29.911]             }))
[16:12:29.911]             future::FutureResult(value = ...future.value$value, 
[16:12:29.911]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.911]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.911]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.911]                     ...future.globalenv.names))
[16:12:29.911]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.911]         }, condition = base::local({
[16:12:29.911]             c <- base::c
[16:12:29.911]             inherits <- base::inherits
[16:12:29.911]             invokeRestart <- base::invokeRestart
[16:12:29.911]             length <- base::length
[16:12:29.911]             list <- base::list
[16:12:29.911]             seq.int <- base::seq.int
[16:12:29.911]             signalCondition <- base::signalCondition
[16:12:29.911]             sys.calls <- base::sys.calls
[16:12:29.911]             `[[` <- base::`[[`
[16:12:29.911]             `+` <- base::`+`
[16:12:29.911]             `<<-` <- base::`<<-`
[16:12:29.911]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.911]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.911]                   3L)]
[16:12:29.911]             }
[16:12:29.911]             function(cond) {
[16:12:29.911]                 is_error <- inherits(cond, "error")
[16:12:29.911]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.911]                   NULL)
[16:12:29.911]                 if (is_error) {
[16:12:29.911]                   sessionInformation <- function() {
[16:12:29.911]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.911]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.911]                       search = base::search(), system = base::Sys.info())
[16:12:29.911]                   }
[16:12:29.911]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.911]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.911]                     cond$call), session = sessionInformation(), 
[16:12:29.911]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.911]                   signalCondition(cond)
[16:12:29.911]                 }
[16:12:29.911]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.911]                 "immediateCondition"))) {
[16:12:29.911]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.911]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.911]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.911]                   if (TRUE && !signal) {
[16:12:29.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.911]                     {
[16:12:29.911]                       inherits <- base::inherits
[16:12:29.911]                       invokeRestart <- base::invokeRestart
[16:12:29.911]                       is.null <- base::is.null
[16:12:29.911]                       muffled <- FALSE
[16:12:29.911]                       if (inherits(cond, "message")) {
[16:12:29.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.911]                         if (muffled) 
[16:12:29.911]                           invokeRestart("muffleMessage")
[16:12:29.911]                       }
[16:12:29.911]                       else if (inherits(cond, "warning")) {
[16:12:29.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.911]                         if (muffled) 
[16:12:29.911]                           invokeRestart("muffleWarning")
[16:12:29.911]                       }
[16:12:29.911]                       else if (inherits(cond, "condition")) {
[16:12:29.911]                         if (!is.null(pattern)) {
[16:12:29.911]                           computeRestarts <- base::computeRestarts
[16:12:29.911]                           grepl <- base::grepl
[16:12:29.911]                           restarts <- computeRestarts(cond)
[16:12:29.911]                           for (restart in restarts) {
[16:12:29.911]                             name <- restart$name
[16:12:29.911]                             if (is.null(name)) 
[16:12:29.911]                               next
[16:12:29.911]                             if (!grepl(pattern, name)) 
[16:12:29.911]                               next
[16:12:29.911]                             invokeRestart(restart)
[16:12:29.911]                             muffled <- TRUE
[16:12:29.911]                             break
[16:12:29.911]                           }
[16:12:29.911]                         }
[16:12:29.911]                       }
[16:12:29.911]                       invisible(muffled)
[16:12:29.911]                     }
[16:12:29.911]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.911]                   }
[16:12:29.911]                 }
[16:12:29.911]                 else {
[16:12:29.911]                   if (TRUE) {
[16:12:29.911]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.911]                     {
[16:12:29.911]                       inherits <- base::inherits
[16:12:29.911]                       invokeRestart <- base::invokeRestart
[16:12:29.911]                       is.null <- base::is.null
[16:12:29.911]                       muffled <- FALSE
[16:12:29.911]                       if (inherits(cond, "message")) {
[16:12:29.911]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.911]                         if (muffled) 
[16:12:29.911]                           invokeRestart("muffleMessage")
[16:12:29.911]                       }
[16:12:29.911]                       else if (inherits(cond, "warning")) {
[16:12:29.911]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.911]                         if (muffled) 
[16:12:29.911]                           invokeRestart("muffleWarning")
[16:12:29.911]                       }
[16:12:29.911]                       else if (inherits(cond, "condition")) {
[16:12:29.911]                         if (!is.null(pattern)) {
[16:12:29.911]                           computeRestarts <- base::computeRestarts
[16:12:29.911]                           grepl <- base::grepl
[16:12:29.911]                           restarts <- computeRestarts(cond)
[16:12:29.911]                           for (restart in restarts) {
[16:12:29.911]                             name <- restart$name
[16:12:29.911]                             if (is.null(name)) 
[16:12:29.911]                               next
[16:12:29.911]                             if (!grepl(pattern, name)) 
[16:12:29.911]                               next
[16:12:29.911]                             invokeRestart(restart)
[16:12:29.911]                             muffled <- TRUE
[16:12:29.911]                             break
[16:12:29.911]                           }
[16:12:29.911]                         }
[16:12:29.911]                       }
[16:12:29.911]                       invisible(muffled)
[16:12:29.911]                     }
[16:12:29.911]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.911]                   }
[16:12:29.911]                 }
[16:12:29.911]             }
[16:12:29.911]         }))
[16:12:29.911]     }, error = function(ex) {
[16:12:29.911]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.911]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.911]                 ...future.rng), started = ...future.startTime, 
[16:12:29.911]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.911]             version = "1.8"), class = "FutureResult")
[16:12:29.911]     }, finally = {
[16:12:29.911]         if (!identical(...future.workdir, getwd())) 
[16:12:29.911]             setwd(...future.workdir)
[16:12:29.911]         {
[16:12:29.911]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.911]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.911]             }
[16:12:29.911]             base::options(...future.oldOptions)
[16:12:29.911]             if (.Platform$OS.type == "windows") {
[16:12:29.911]                 old_names <- names(...future.oldEnvVars)
[16:12:29.911]                 envs <- base::Sys.getenv()
[16:12:29.911]                 names <- names(envs)
[16:12:29.911]                 common <- intersect(names, old_names)
[16:12:29.911]                 added <- setdiff(names, old_names)
[16:12:29.911]                 removed <- setdiff(old_names, names)
[16:12:29.911]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.911]                   envs[common]]
[16:12:29.911]                 NAMES <- toupper(changed)
[16:12:29.911]                 args <- list()
[16:12:29.911]                 for (kk in seq_along(NAMES)) {
[16:12:29.911]                   name <- changed[[kk]]
[16:12:29.911]                   NAME <- NAMES[[kk]]
[16:12:29.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.911]                     next
[16:12:29.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.911]                 }
[16:12:29.911]                 NAMES <- toupper(added)
[16:12:29.911]                 for (kk in seq_along(NAMES)) {
[16:12:29.911]                   name <- added[[kk]]
[16:12:29.911]                   NAME <- NAMES[[kk]]
[16:12:29.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.911]                     next
[16:12:29.911]                   args[[name]] <- ""
[16:12:29.911]                 }
[16:12:29.911]                 NAMES <- toupper(removed)
[16:12:29.911]                 for (kk in seq_along(NAMES)) {
[16:12:29.911]                   name <- removed[[kk]]
[16:12:29.911]                   NAME <- NAMES[[kk]]
[16:12:29.911]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.911]                     next
[16:12:29.911]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.911]                 }
[16:12:29.911]                 if (length(args) > 0) 
[16:12:29.911]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.911]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.911]             }
[16:12:29.911]             else {
[16:12:29.911]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.911]             }
[16:12:29.911]             {
[16:12:29.911]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.911]                   0L) {
[16:12:29.911]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.911]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.911]                   base::options(opts)
[16:12:29.911]                 }
[16:12:29.911]                 {
[16:12:29.911]                   {
[16:12:29.911]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.911]                     NULL
[16:12:29.911]                   }
[16:12:29.911]                   options(future.plan = NULL)
[16:12:29.911]                   if (is.na(NA_character_)) 
[16:12:29.911]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.911]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.911]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.911]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.911]                     envir = parent.frame()) 
[16:12:29.911]                   {
[16:12:29.911]                     if (is.function(workers)) 
[16:12:29.911]                       workers <- workers()
[16:12:29.911]                     workers <- structure(as.integer(workers), 
[16:12:29.911]                       class = class(workers))
[16:12:29.911]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.911]                       workers >= 1)
[16:12:29.911]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.911]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.911]                     }
[16:12:29.911]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.911]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.911]                       envir = envir)
[16:12:29.911]                     if (!future$lazy) 
[16:12:29.911]                       future <- run(future)
[16:12:29.911]                     invisible(future)
[16:12:29.911]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.911]                 }
[16:12:29.911]             }
[16:12:29.911]         }
[16:12:29.911]     })
[16:12:29.911]     if (TRUE) {
[16:12:29.911]         base::sink(type = "output", split = FALSE)
[16:12:29.911]         if (TRUE) {
[16:12:29.911]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.911]         }
[16:12:29.911]         else {
[16:12:29.911]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.911]         }
[16:12:29.911]         base::close(...future.stdout)
[16:12:29.911]         ...future.stdout <- NULL
[16:12:29.911]     }
[16:12:29.911]     ...future.result$conditions <- ...future.conditions
[16:12:29.911]     ...future.result$finished <- base::Sys.time()
[16:12:29.911]     ...future.result
[16:12:29.911] }
[16:12:29.914] MultisessionFuture started
[16:12:29.915] - Launch lazy future ... done
[16:12:29.915] run() for ‘MultisessionFuture’ ... done
[16:12:29.915] getGlobalsAndPackages() ...
[16:12:29.915] Searching for globals...
[16:12:29.916] - globals found: [1] ‘{’
[16:12:29.916] Searching for globals ... DONE
[16:12:29.916] Resolving globals: FALSE
[16:12:29.916] 
[16:12:29.916] 
[16:12:29.916] getGlobalsAndPackages() ... DONE
[16:12:29.917] run() for ‘Future’ ...
[16:12:29.917] - state: ‘created’
[16:12:29.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:29.932] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:29.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:29.932]   - Field: ‘node’
[16:12:29.932]   - Field: ‘label’
[16:12:29.932]   - Field: ‘local’
[16:12:29.932]   - Field: ‘owner’
[16:12:29.932]   - Field: ‘envir’
[16:12:29.932]   - Field: ‘workers’
[16:12:29.932]   - Field: ‘packages’
[16:12:29.932]   - Field: ‘gc’
[16:12:29.933]   - Field: ‘conditions’
[16:12:29.933]   - Field: ‘persistent’
[16:12:29.933]   - Field: ‘expr’
[16:12:29.933]   - Field: ‘uuid’
[16:12:29.933]   - Field: ‘seed’
[16:12:29.933]   - Field: ‘version’
[16:12:29.933]   - Field: ‘result’
[16:12:29.933]   - Field: ‘asynchronous’
[16:12:29.933]   - Field: ‘calls’
[16:12:29.933]   - Field: ‘globals’
[16:12:29.933]   - Field: ‘stdout’
[16:12:29.934]   - Field: ‘earlySignal’
[16:12:29.934]   - Field: ‘lazy’
[16:12:29.934]   - Field: ‘state’
[16:12:29.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:29.934] - Launch lazy future ...
[16:12:29.934] Packages needed by the future expression (n = 0): <none>
[16:12:29.934] Packages needed by future strategies (n = 0): <none>
[16:12:29.935] {
[16:12:29.935]     {
[16:12:29.935]         {
[16:12:29.935]             ...future.startTime <- base::Sys.time()
[16:12:29.935]             {
[16:12:29.935]                 {
[16:12:29.935]                   {
[16:12:29.935]                     {
[16:12:29.935]                       base::local({
[16:12:29.935]                         has_future <- base::requireNamespace("future", 
[16:12:29.935]                           quietly = TRUE)
[16:12:29.935]                         if (has_future) {
[16:12:29.935]                           ns <- base::getNamespace("future")
[16:12:29.935]                           version <- ns[[".package"]][["version"]]
[16:12:29.935]                           if (is.null(version)) 
[16:12:29.935]                             version <- utils::packageVersion("future")
[16:12:29.935]                         }
[16:12:29.935]                         else {
[16:12:29.935]                           version <- NULL
[16:12:29.935]                         }
[16:12:29.935]                         if (!has_future || version < "1.8.0") {
[16:12:29.935]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:29.935]                             "", base::R.version$version.string), 
[16:12:29.935]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:29.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:29.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:29.935]                               "release", "version")], collapse = " "), 
[16:12:29.935]                             hostname = base::Sys.info()[["nodename"]])
[16:12:29.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:29.935]                             info)
[16:12:29.935]                           info <- base::paste(info, collapse = "; ")
[16:12:29.935]                           if (!has_future) {
[16:12:29.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:29.935]                               info)
[16:12:29.935]                           }
[16:12:29.935]                           else {
[16:12:29.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:29.935]                               info, version)
[16:12:29.935]                           }
[16:12:29.935]                           base::stop(msg)
[16:12:29.935]                         }
[16:12:29.935]                       })
[16:12:29.935]                     }
[16:12:29.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:29.935]                     base::options(mc.cores = 1L)
[16:12:29.935]                   }
[16:12:29.935]                   options(future.plan = NULL)
[16:12:29.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:29.935]                 }
[16:12:29.935]                 ...future.workdir <- getwd()
[16:12:29.935]             }
[16:12:29.935]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:29.935]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:29.935]         }
[16:12:29.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:29.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:29.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:29.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:29.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:29.935]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:29.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:29.935]             base::names(...future.oldOptions))
[16:12:29.935]     }
[16:12:29.935]     if (FALSE) {
[16:12:29.935]     }
[16:12:29.935]     else {
[16:12:29.935]         if (TRUE) {
[16:12:29.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:29.935]                 open = "w")
[16:12:29.935]         }
[16:12:29.935]         else {
[16:12:29.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:29.935]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:29.935]         }
[16:12:29.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:29.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:29.935]             base::sink(type = "output", split = FALSE)
[16:12:29.935]             base::close(...future.stdout)
[16:12:29.935]         }, add = TRUE)
[16:12:29.935]     }
[16:12:29.935]     ...future.frame <- base::sys.nframe()
[16:12:29.935]     ...future.conditions <- base::list()
[16:12:29.935]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:29.935]     if (FALSE) {
[16:12:29.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:29.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:29.935]     }
[16:12:29.935]     ...future.result <- base::tryCatch({
[16:12:29.935]         base::withCallingHandlers({
[16:12:29.935]             ...future.value <- base::withVisible(base::local({
[16:12:29.935]                 ...future.makeSendCondition <- local({
[16:12:29.935]                   sendCondition <- NULL
[16:12:29.935]                   function(frame = 1L) {
[16:12:29.935]                     if (is.function(sendCondition)) 
[16:12:29.935]                       return(sendCondition)
[16:12:29.935]                     ns <- getNamespace("parallel")
[16:12:29.935]                     if (exists("sendData", mode = "function", 
[16:12:29.935]                       envir = ns)) {
[16:12:29.935]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:29.935]                         envir = ns)
[16:12:29.935]                       envir <- sys.frame(frame)
[16:12:29.935]                       master <- NULL
[16:12:29.935]                       while (!identical(envir, .GlobalEnv) && 
[16:12:29.935]                         !identical(envir, emptyenv())) {
[16:12:29.935]                         if (exists("master", mode = "list", envir = envir, 
[16:12:29.935]                           inherits = FALSE)) {
[16:12:29.935]                           master <- get("master", mode = "list", 
[16:12:29.935]                             envir = envir, inherits = FALSE)
[16:12:29.935]                           if (inherits(master, c("SOCKnode", 
[16:12:29.935]                             "SOCK0node"))) {
[16:12:29.935]                             sendCondition <<- function(cond) {
[16:12:29.935]                               data <- list(type = "VALUE", value = cond, 
[16:12:29.935]                                 success = TRUE)
[16:12:29.935]                               parallel_sendData(master, data)
[16:12:29.935]                             }
[16:12:29.935]                             return(sendCondition)
[16:12:29.935]                           }
[16:12:29.935]                         }
[16:12:29.935]                         frame <- frame + 1L
[16:12:29.935]                         envir <- sys.frame(frame)
[16:12:29.935]                       }
[16:12:29.935]                     }
[16:12:29.935]                     sendCondition <<- function(cond) NULL
[16:12:29.935]                   }
[16:12:29.935]                 })
[16:12:29.935]                 withCallingHandlers({
[16:12:29.935]                   {
[16:12:29.935]                     4
[16:12:29.935]                   }
[16:12:29.935]                 }, immediateCondition = function(cond) {
[16:12:29.935]                   sendCondition <- ...future.makeSendCondition()
[16:12:29.935]                   sendCondition(cond)
[16:12:29.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.935]                   {
[16:12:29.935]                     inherits <- base::inherits
[16:12:29.935]                     invokeRestart <- base::invokeRestart
[16:12:29.935]                     is.null <- base::is.null
[16:12:29.935]                     muffled <- FALSE
[16:12:29.935]                     if (inherits(cond, "message")) {
[16:12:29.935]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:29.935]                       if (muffled) 
[16:12:29.935]                         invokeRestart("muffleMessage")
[16:12:29.935]                     }
[16:12:29.935]                     else if (inherits(cond, "warning")) {
[16:12:29.935]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:29.935]                       if (muffled) 
[16:12:29.935]                         invokeRestart("muffleWarning")
[16:12:29.935]                     }
[16:12:29.935]                     else if (inherits(cond, "condition")) {
[16:12:29.935]                       if (!is.null(pattern)) {
[16:12:29.935]                         computeRestarts <- base::computeRestarts
[16:12:29.935]                         grepl <- base::grepl
[16:12:29.935]                         restarts <- computeRestarts(cond)
[16:12:29.935]                         for (restart in restarts) {
[16:12:29.935]                           name <- restart$name
[16:12:29.935]                           if (is.null(name)) 
[16:12:29.935]                             next
[16:12:29.935]                           if (!grepl(pattern, name)) 
[16:12:29.935]                             next
[16:12:29.935]                           invokeRestart(restart)
[16:12:29.935]                           muffled <- TRUE
[16:12:29.935]                           break
[16:12:29.935]                         }
[16:12:29.935]                       }
[16:12:29.935]                     }
[16:12:29.935]                     invisible(muffled)
[16:12:29.935]                   }
[16:12:29.935]                   muffleCondition(cond)
[16:12:29.935]                 })
[16:12:29.935]             }))
[16:12:29.935]             future::FutureResult(value = ...future.value$value, 
[16:12:29.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.935]                   ...future.rng), globalenv = if (FALSE) 
[16:12:29.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:29.935]                     ...future.globalenv.names))
[16:12:29.935]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:29.935]         }, condition = base::local({
[16:12:29.935]             c <- base::c
[16:12:29.935]             inherits <- base::inherits
[16:12:29.935]             invokeRestart <- base::invokeRestart
[16:12:29.935]             length <- base::length
[16:12:29.935]             list <- base::list
[16:12:29.935]             seq.int <- base::seq.int
[16:12:29.935]             signalCondition <- base::signalCondition
[16:12:29.935]             sys.calls <- base::sys.calls
[16:12:29.935]             `[[` <- base::`[[`
[16:12:29.935]             `+` <- base::`+`
[16:12:29.935]             `<<-` <- base::`<<-`
[16:12:29.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:29.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:29.935]                   3L)]
[16:12:29.935]             }
[16:12:29.935]             function(cond) {
[16:12:29.935]                 is_error <- inherits(cond, "error")
[16:12:29.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:29.935]                   NULL)
[16:12:29.935]                 if (is_error) {
[16:12:29.935]                   sessionInformation <- function() {
[16:12:29.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:29.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:29.935]                       search = base::search(), system = base::Sys.info())
[16:12:29.935]                   }
[16:12:29.935]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:29.935]                     cond$call), session = sessionInformation(), 
[16:12:29.935]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:29.935]                   signalCondition(cond)
[16:12:29.935]                 }
[16:12:29.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:29.935]                 "immediateCondition"))) {
[16:12:29.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:29.935]                   ...future.conditions[[length(...future.conditions) + 
[16:12:29.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:29.935]                   if (TRUE && !signal) {
[16:12:29.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.935]                     {
[16:12:29.935]                       inherits <- base::inherits
[16:12:29.935]                       invokeRestart <- base::invokeRestart
[16:12:29.935]                       is.null <- base::is.null
[16:12:29.935]                       muffled <- FALSE
[16:12:29.935]                       if (inherits(cond, "message")) {
[16:12:29.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.935]                         if (muffled) 
[16:12:29.935]                           invokeRestart("muffleMessage")
[16:12:29.935]                       }
[16:12:29.935]                       else if (inherits(cond, "warning")) {
[16:12:29.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.935]                         if (muffled) 
[16:12:29.935]                           invokeRestart("muffleWarning")
[16:12:29.935]                       }
[16:12:29.935]                       else if (inherits(cond, "condition")) {
[16:12:29.935]                         if (!is.null(pattern)) {
[16:12:29.935]                           computeRestarts <- base::computeRestarts
[16:12:29.935]                           grepl <- base::grepl
[16:12:29.935]                           restarts <- computeRestarts(cond)
[16:12:29.935]                           for (restart in restarts) {
[16:12:29.935]                             name <- restart$name
[16:12:29.935]                             if (is.null(name)) 
[16:12:29.935]                               next
[16:12:29.935]                             if (!grepl(pattern, name)) 
[16:12:29.935]                               next
[16:12:29.935]                             invokeRestart(restart)
[16:12:29.935]                             muffled <- TRUE
[16:12:29.935]                             break
[16:12:29.935]                           }
[16:12:29.935]                         }
[16:12:29.935]                       }
[16:12:29.935]                       invisible(muffled)
[16:12:29.935]                     }
[16:12:29.935]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.935]                   }
[16:12:29.935]                 }
[16:12:29.935]                 else {
[16:12:29.935]                   if (TRUE) {
[16:12:29.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:29.935]                     {
[16:12:29.935]                       inherits <- base::inherits
[16:12:29.935]                       invokeRestart <- base::invokeRestart
[16:12:29.935]                       is.null <- base::is.null
[16:12:29.935]                       muffled <- FALSE
[16:12:29.935]                       if (inherits(cond, "message")) {
[16:12:29.935]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:29.935]                         if (muffled) 
[16:12:29.935]                           invokeRestart("muffleMessage")
[16:12:29.935]                       }
[16:12:29.935]                       else if (inherits(cond, "warning")) {
[16:12:29.935]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:29.935]                         if (muffled) 
[16:12:29.935]                           invokeRestart("muffleWarning")
[16:12:29.935]                       }
[16:12:29.935]                       else if (inherits(cond, "condition")) {
[16:12:29.935]                         if (!is.null(pattern)) {
[16:12:29.935]                           computeRestarts <- base::computeRestarts
[16:12:29.935]                           grepl <- base::grepl
[16:12:29.935]                           restarts <- computeRestarts(cond)
[16:12:29.935]                           for (restart in restarts) {
[16:12:29.935]                             name <- restart$name
[16:12:29.935]                             if (is.null(name)) 
[16:12:29.935]                               next
[16:12:29.935]                             if (!grepl(pattern, name)) 
[16:12:29.935]                               next
[16:12:29.935]                             invokeRestart(restart)
[16:12:29.935]                             muffled <- TRUE
[16:12:29.935]                             break
[16:12:29.935]                           }
[16:12:29.935]                         }
[16:12:29.935]                       }
[16:12:29.935]                       invisible(muffled)
[16:12:29.935]                     }
[16:12:29.935]                     muffleCondition(cond, pattern = "^muffle")
[16:12:29.935]                   }
[16:12:29.935]                 }
[16:12:29.935]             }
[16:12:29.935]         }))
[16:12:29.935]     }, error = function(ex) {
[16:12:29.935]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:29.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:29.935]                 ...future.rng), started = ...future.startTime, 
[16:12:29.935]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:29.935]             version = "1.8"), class = "FutureResult")
[16:12:29.935]     }, finally = {
[16:12:29.935]         if (!identical(...future.workdir, getwd())) 
[16:12:29.935]             setwd(...future.workdir)
[16:12:29.935]         {
[16:12:29.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:29.935]                 ...future.oldOptions$nwarnings <- NULL
[16:12:29.935]             }
[16:12:29.935]             base::options(...future.oldOptions)
[16:12:29.935]             if (.Platform$OS.type == "windows") {
[16:12:29.935]                 old_names <- names(...future.oldEnvVars)
[16:12:29.935]                 envs <- base::Sys.getenv()
[16:12:29.935]                 names <- names(envs)
[16:12:29.935]                 common <- intersect(names, old_names)
[16:12:29.935]                 added <- setdiff(names, old_names)
[16:12:29.935]                 removed <- setdiff(old_names, names)
[16:12:29.935]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:29.935]                   envs[common]]
[16:12:29.935]                 NAMES <- toupper(changed)
[16:12:29.935]                 args <- list()
[16:12:29.935]                 for (kk in seq_along(NAMES)) {
[16:12:29.935]                   name <- changed[[kk]]
[16:12:29.935]                   NAME <- NAMES[[kk]]
[16:12:29.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.935]                     next
[16:12:29.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.935]                 }
[16:12:29.935]                 NAMES <- toupper(added)
[16:12:29.935]                 for (kk in seq_along(NAMES)) {
[16:12:29.935]                   name <- added[[kk]]
[16:12:29.935]                   NAME <- NAMES[[kk]]
[16:12:29.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.935]                     next
[16:12:29.935]                   args[[name]] <- ""
[16:12:29.935]                 }
[16:12:29.935]                 NAMES <- toupper(removed)
[16:12:29.935]                 for (kk in seq_along(NAMES)) {
[16:12:29.935]                   name <- removed[[kk]]
[16:12:29.935]                   NAME <- NAMES[[kk]]
[16:12:29.935]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:29.935]                     next
[16:12:29.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:29.935]                 }
[16:12:29.935]                 if (length(args) > 0) 
[16:12:29.935]                   base::do.call(base::Sys.setenv, args = args)
[16:12:29.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:29.935]             }
[16:12:29.935]             else {
[16:12:29.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:29.935]             }
[16:12:29.935]             {
[16:12:29.935]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:29.935]                   0L) {
[16:12:29.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:29.935]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:29.935]                   base::options(opts)
[16:12:29.935]                 }
[16:12:29.935]                 {
[16:12:29.935]                   {
[16:12:29.935]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:29.935]                     NULL
[16:12:29.935]                   }
[16:12:29.935]                   options(future.plan = NULL)
[16:12:29.935]                   if (is.na(NA_character_)) 
[16:12:29.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:29.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:29.935]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:29.935]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:29.935]                     envir = parent.frame()) 
[16:12:29.935]                   {
[16:12:29.935]                     if (is.function(workers)) 
[16:12:29.935]                       workers <- workers()
[16:12:29.935]                     workers <- structure(as.integer(workers), 
[16:12:29.935]                       class = class(workers))
[16:12:29.935]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:29.935]                       workers >= 1)
[16:12:29.935]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:29.935]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:29.935]                     }
[16:12:29.935]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:29.935]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:29.935]                       envir = envir)
[16:12:29.935]                     if (!future$lazy) 
[16:12:29.935]                       future <- run(future)
[16:12:29.935]                     invisible(future)
[16:12:29.935]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:29.935]                 }
[16:12:29.935]             }
[16:12:29.935]         }
[16:12:29.935]     })
[16:12:29.935]     if (TRUE) {
[16:12:29.935]         base::sink(type = "output", split = FALSE)
[16:12:29.935]         if (TRUE) {
[16:12:29.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:29.935]         }
[16:12:29.935]         else {
[16:12:29.935]             ...future.result["stdout"] <- base::list(NULL)
[16:12:29.935]         }
[16:12:29.935]         base::close(...future.stdout)
[16:12:29.935]         ...future.stdout <- NULL
[16:12:29.935]     }
[16:12:29.935]     ...future.result$conditions <- ...future.conditions
[16:12:29.935]     ...future.result$finished <- base::Sys.time()
[16:12:29.935]     ...future.result
[16:12:29.935] }
[16:12:29.937] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:29.948] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.948] - Validating connection of MultisessionFuture
[16:12:29.948] - received message: FutureResult
[16:12:29.948] - Received FutureResult
[16:12:29.949] - Erased future from FutureRegistry
[16:12:29.949] result() for ClusterFuture ...
[16:12:29.949] - result already collected: FutureResult
[16:12:29.949] result() for ClusterFuture ... done
[16:12:29.949] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:29.949] result() for ClusterFuture ...
[16:12:29.949] - result already collected: FutureResult
[16:12:29.949] result() for ClusterFuture ... done
[16:12:29.950] result() for ClusterFuture ...
[16:12:29.950] - result already collected: FutureResult
[16:12:29.950] result() for ClusterFuture ... done
[16:12:29.951] MultisessionFuture started
[16:12:29.951] - Launch lazy future ... done
[16:12:29.951] run() for ‘MultisessionFuture’ ... done
<environment: 0x560bae9a1fd8> 
<environment: 0x560baff17688> 
[16:12:29.962] receiveMessageFromWorker() for ClusterFuture ...
[16:12:29.962] - Validating connection of MultisessionFuture
[16:12:29.962] - received message: FutureResult
[16:12:29.963] - Received FutureResult
[16:12:29.963] - Erased future from FutureRegistry
[16:12:29.963] result() for ClusterFuture ...
[16:12:29.963] - result already collected: FutureResult
[16:12:29.963] result() for ClusterFuture ... done
[16:12:29.963] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:29.975] resolve() on environment ...
[16:12:29.976]  recursive: 0
[16:12:29.976]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:29.976] signalConditionsASAP(numeric, pos=1) ...
[16:12:29.976] - nx: 4
[16:12:29.977] - relay: TRUE
[16:12:29.977] - stdout: TRUE
[16:12:29.977] - signal: TRUE
[16:12:29.977] - resignal: FALSE
[16:12:29.977] - force: TRUE
[16:12:29.977] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.977] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.977]  - until=2
[16:12:29.977]  - relaying element #2
[16:12:29.978] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.978] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.978] signalConditionsASAP(NULL, pos=1) ... done
[16:12:29.978]  length: 3 (resolved future 1)
[16:12:29.978] Future #2
[16:12:29.978] result() for ClusterFuture ...
[16:12:29.978] - result already collected: FutureResult
[16:12:29.978] result() for ClusterFuture ... done
[16:12:29.979] result() for ClusterFuture ...
[16:12:29.979] - result already collected: FutureResult
[16:12:29.979] result() for ClusterFuture ... done
[16:12:29.979] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:29.979] - nx: 4
[16:12:29.979] - relay: TRUE
[16:12:29.979] - stdout: TRUE
[16:12:29.979] - signal: TRUE
[16:12:29.979] - resignal: FALSE
[16:12:29.979] - force: TRUE
[16:12:29.980] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:29.980] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:29.980]  - until=2
[16:12:29.980]  - relaying element #2
[16:12:29.980] result() for ClusterFuture ...
[16:12:29.980] - result already collected: FutureResult
[16:12:29.980] result() for ClusterFuture ... done
[16:12:29.980] result() for ClusterFuture ...
[16:12:29.981] - result already collected: FutureResult
[16:12:29.981] result() for ClusterFuture ... done
[16:12:29.981] result() for ClusterFuture ...
[16:12:29.981] - result already collected: FutureResult
[16:12:29.981] result() for ClusterFuture ... done
[16:12:29.981] result() for ClusterFuture ...
[16:12:29.981] - result already collected: FutureResult
[16:12:29.981] result() for ClusterFuture ... done
[16:12:29.982] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.982] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.982] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:29.982]  length: 2 (resolved future 2)
[16:12:29.982] Future #3
[16:12:29.982] result() for ClusterFuture ...
[16:12:29.982] - result already collected: FutureResult
[16:12:29.982] result() for ClusterFuture ... done
[16:12:29.982] result() for ClusterFuture ...
[16:12:29.983] - result already collected: FutureResult
[16:12:29.983] result() for ClusterFuture ... done
[16:12:29.983] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:29.983] - nx: 4
[16:12:29.983] - relay: TRUE
[16:12:29.983] - stdout: TRUE
[16:12:29.983] - signal: TRUE
[16:12:29.983] - resignal: FALSE
[16:12:29.983] - force: TRUE
[16:12:29.984] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:29.984] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:29.984]  - until=3
[16:12:29.984]  - relaying element #3
[16:12:29.984] result() for ClusterFuture ...
[16:12:29.984] - result already collected: FutureResult
[16:12:29.984] result() for ClusterFuture ... done
[16:12:29.984] result() for ClusterFuture ...
[16:12:29.985] - result already collected: FutureResult
[16:12:29.985] result() for ClusterFuture ... done
[16:12:29.985] result() for ClusterFuture ...
[16:12:29.985] - result already collected: FutureResult
[16:12:29.985] result() for ClusterFuture ... done
[16:12:29.985] result() for ClusterFuture ...
[16:12:29.985] - result already collected: FutureResult
[16:12:29.985] result() for ClusterFuture ... done
[16:12:29.986] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:29.986] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:29.986] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:29.986]  length: 1 (resolved future 3)
[16:12:30.007] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.007] - Validating connection of MultisessionFuture
[16:12:30.007] - received message: FutureResult
[16:12:30.007] - Received FutureResult
[16:12:30.007] - Erased future from FutureRegistry
[16:12:30.007] result() for ClusterFuture ...
[16:12:30.008] - result already collected: FutureResult
[16:12:30.008] result() for ClusterFuture ... done
[16:12:30.008] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:30.008] Future #4
[16:12:30.008] result() for ClusterFuture ...
[16:12:30.008] - result already collected: FutureResult
[16:12:30.008] result() for ClusterFuture ... done
[16:12:30.008] result() for ClusterFuture ...
[16:12:30.008] - result already collected: FutureResult
[16:12:30.008] result() for ClusterFuture ... done
[16:12:30.009] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:30.009] - nx: 4
[16:12:30.009] - relay: TRUE
[16:12:30.009] - stdout: TRUE
[16:12:30.009] - signal: TRUE
[16:12:30.009] - resignal: FALSE
[16:12:30.009] - force: TRUE
[16:12:30.009] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:30.009] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:30.009]  - until=4
[16:12:30.009]  - relaying element #4
[16:12:30.009] result() for ClusterFuture ...
[16:12:30.010] - result already collected: FutureResult
[16:12:30.010] result() for ClusterFuture ... done
[16:12:30.010] result() for ClusterFuture ...
[16:12:30.010] - result already collected: FutureResult
[16:12:30.010] result() for ClusterFuture ... done
[16:12:30.010] result() for ClusterFuture ...
[16:12:30.010] - result already collected: FutureResult
[16:12:30.010] result() for ClusterFuture ... done
[16:12:30.010] result() for ClusterFuture ...
[16:12:30.010] - result already collected: FutureResult
[16:12:30.010] result() for ClusterFuture ... done
[16:12:30.011] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.011] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:30.011] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:30.011]  length: 0 (resolved future 4)
[16:12:30.011] Relaying remaining futures
[16:12:30.011] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.011] - nx: 4
[16:12:30.011] - relay: TRUE
[16:12:30.011] - stdout: TRUE
[16:12:30.011] - signal: TRUE
[16:12:30.011] - resignal: FALSE
[16:12:30.011] - force: TRUE
[16:12:30.012] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.012] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:30.012] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.012] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:30.012] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.012] resolve() on environment ... DONE
[16:12:30.012] result() for ClusterFuture ...
[16:12:30.012] - result already collected: FutureResult
[16:12:30.012] result() for ClusterFuture ... done
[16:12:30.012] result() for ClusterFuture ...
[16:12:30.013] - result already collected: FutureResult
[16:12:30.013] result() for ClusterFuture ... done
[16:12:30.013] result() for ClusterFuture ...
[16:12:30.013] - result already collected: FutureResult
[16:12:30.013] result() for ClusterFuture ... done
[16:12:30.013] result() for ClusterFuture ...
[16:12:30.013] - result already collected: FutureResult
[16:12:30.013] result() for ClusterFuture ... done
[16:12:30.013] result() for ClusterFuture ...
[16:12:30.013] - result already collected: FutureResult
[16:12:30.013] result() for ClusterFuture ... done
[16:12:30.014] result() for ClusterFuture ...
[16:12:30.014] - result already collected: FutureResult
[16:12:30.014] result() for ClusterFuture ... done
<environment: 0x560bb010f7b0> 
Dimensions: c(2, 3, 1)
[16:12:30.014] getGlobalsAndPackages() ...
[16:12:30.014] Searching for globals...
[16:12:30.015] 
[16:12:30.015] Searching for globals ... DONE
[16:12:30.015] - globals: [0] <none>
[16:12:30.015] getGlobalsAndPackages() ... DONE
[16:12:30.015] run() for ‘Future’ ...
[16:12:30.015] - state: ‘created’
[16:12:30.015] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.030] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:30.031]   - Field: ‘node’
[16:12:30.031]   - Field: ‘label’
[16:12:30.031]   - Field: ‘local’
[16:12:30.031]   - Field: ‘owner’
[16:12:30.031]   - Field: ‘envir’
[16:12:30.031]   - Field: ‘workers’
[16:12:30.031]   - Field: ‘packages’
[16:12:30.031]   - Field: ‘gc’
[16:12:30.032]   - Field: ‘conditions’
[16:12:30.032]   - Field: ‘persistent’
[16:12:30.032]   - Field: ‘expr’
[16:12:30.032]   - Field: ‘uuid’
[16:12:30.032]   - Field: ‘seed’
[16:12:30.032]   - Field: ‘version’
[16:12:30.032]   - Field: ‘result’
[16:12:30.032]   - Field: ‘asynchronous’
[16:12:30.032]   - Field: ‘calls’
[16:12:30.032]   - Field: ‘globals’
[16:12:30.033]   - Field: ‘stdout’
[16:12:30.033]   - Field: ‘earlySignal’
[16:12:30.033]   - Field: ‘lazy’
[16:12:30.035]   - Field: ‘state’
[16:12:30.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:30.036] - Launch lazy future ...
[16:12:30.036] Packages needed by the future expression (n = 0): <none>
[16:12:30.036] Packages needed by future strategies (n = 0): <none>
[16:12:30.037] {
[16:12:30.037]     {
[16:12:30.037]         {
[16:12:30.037]             ...future.startTime <- base::Sys.time()
[16:12:30.037]             {
[16:12:30.037]                 {
[16:12:30.037]                   {
[16:12:30.037]                     {
[16:12:30.037]                       base::local({
[16:12:30.037]                         has_future <- base::requireNamespace("future", 
[16:12:30.037]                           quietly = TRUE)
[16:12:30.037]                         if (has_future) {
[16:12:30.037]                           ns <- base::getNamespace("future")
[16:12:30.037]                           version <- ns[[".package"]][["version"]]
[16:12:30.037]                           if (is.null(version)) 
[16:12:30.037]                             version <- utils::packageVersion("future")
[16:12:30.037]                         }
[16:12:30.037]                         else {
[16:12:30.037]                           version <- NULL
[16:12:30.037]                         }
[16:12:30.037]                         if (!has_future || version < "1.8.0") {
[16:12:30.037]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.037]                             "", base::R.version$version.string), 
[16:12:30.037]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.037]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.037]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.037]                               "release", "version")], collapse = " "), 
[16:12:30.037]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.037]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.037]                             info)
[16:12:30.037]                           info <- base::paste(info, collapse = "; ")
[16:12:30.037]                           if (!has_future) {
[16:12:30.037]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.037]                               info)
[16:12:30.037]                           }
[16:12:30.037]                           else {
[16:12:30.037]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.037]                               info, version)
[16:12:30.037]                           }
[16:12:30.037]                           base::stop(msg)
[16:12:30.037]                         }
[16:12:30.037]                       })
[16:12:30.037]                     }
[16:12:30.037]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.037]                     base::options(mc.cores = 1L)
[16:12:30.037]                   }
[16:12:30.037]                   options(future.plan = NULL)
[16:12:30.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.037]                 }
[16:12:30.037]                 ...future.workdir <- getwd()
[16:12:30.037]             }
[16:12:30.037]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.037]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.037]         }
[16:12:30.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.037]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.037]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.037]             base::names(...future.oldOptions))
[16:12:30.037]     }
[16:12:30.037]     if (FALSE) {
[16:12:30.037]     }
[16:12:30.037]     else {
[16:12:30.037]         if (TRUE) {
[16:12:30.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.037]                 open = "w")
[16:12:30.037]         }
[16:12:30.037]         else {
[16:12:30.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.037]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.037]         }
[16:12:30.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.037]             base::sink(type = "output", split = FALSE)
[16:12:30.037]             base::close(...future.stdout)
[16:12:30.037]         }, add = TRUE)
[16:12:30.037]     }
[16:12:30.037]     ...future.frame <- base::sys.nframe()
[16:12:30.037]     ...future.conditions <- base::list()
[16:12:30.037]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.037]     if (FALSE) {
[16:12:30.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.037]     }
[16:12:30.037]     ...future.result <- base::tryCatch({
[16:12:30.037]         base::withCallingHandlers({
[16:12:30.037]             ...future.value <- base::withVisible(base::local({
[16:12:30.037]                 ...future.makeSendCondition <- local({
[16:12:30.037]                   sendCondition <- NULL
[16:12:30.037]                   function(frame = 1L) {
[16:12:30.037]                     if (is.function(sendCondition)) 
[16:12:30.037]                       return(sendCondition)
[16:12:30.037]                     ns <- getNamespace("parallel")
[16:12:30.037]                     if (exists("sendData", mode = "function", 
[16:12:30.037]                       envir = ns)) {
[16:12:30.037]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:30.037]                         envir = ns)
[16:12:30.037]                       envir <- sys.frame(frame)
[16:12:30.037]                       master <- NULL
[16:12:30.037]                       while (!identical(envir, .GlobalEnv) && 
[16:12:30.037]                         !identical(envir, emptyenv())) {
[16:12:30.037]                         if (exists("master", mode = "list", envir = envir, 
[16:12:30.037]                           inherits = FALSE)) {
[16:12:30.037]                           master <- get("master", mode = "list", 
[16:12:30.037]                             envir = envir, inherits = FALSE)
[16:12:30.037]                           if (inherits(master, c("SOCKnode", 
[16:12:30.037]                             "SOCK0node"))) {
[16:12:30.037]                             sendCondition <<- function(cond) {
[16:12:30.037]                               data <- list(type = "VALUE", value = cond, 
[16:12:30.037]                                 success = TRUE)
[16:12:30.037]                               parallel_sendData(master, data)
[16:12:30.037]                             }
[16:12:30.037]                             return(sendCondition)
[16:12:30.037]                           }
[16:12:30.037]                         }
[16:12:30.037]                         frame <- frame + 1L
[16:12:30.037]                         envir <- sys.frame(frame)
[16:12:30.037]                       }
[16:12:30.037]                     }
[16:12:30.037]                     sendCondition <<- function(cond) NULL
[16:12:30.037]                   }
[16:12:30.037]                 })
[16:12:30.037]                 withCallingHandlers({
[16:12:30.037]                   2
[16:12:30.037]                 }, immediateCondition = function(cond) {
[16:12:30.037]                   sendCondition <- ...future.makeSendCondition()
[16:12:30.037]                   sendCondition(cond)
[16:12:30.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.037]                   {
[16:12:30.037]                     inherits <- base::inherits
[16:12:30.037]                     invokeRestart <- base::invokeRestart
[16:12:30.037]                     is.null <- base::is.null
[16:12:30.037]                     muffled <- FALSE
[16:12:30.037]                     if (inherits(cond, "message")) {
[16:12:30.037]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.037]                       if (muffled) 
[16:12:30.037]                         invokeRestart("muffleMessage")
[16:12:30.037]                     }
[16:12:30.037]                     else if (inherits(cond, "warning")) {
[16:12:30.037]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.037]                       if (muffled) 
[16:12:30.037]                         invokeRestart("muffleWarning")
[16:12:30.037]                     }
[16:12:30.037]                     else if (inherits(cond, "condition")) {
[16:12:30.037]                       if (!is.null(pattern)) {
[16:12:30.037]                         computeRestarts <- base::computeRestarts
[16:12:30.037]                         grepl <- base::grepl
[16:12:30.037]                         restarts <- computeRestarts(cond)
[16:12:30.037]                         for (restart in restarts) {
[16:12:30.037]                           name <- restart$name
[16:12:30.037]                           if (is.null(name)) 
[16:12:30.037]                             next
[16:12:30.037]                           if (!grepl(pattern, name)) 
[16:12:30.037]                             next
[16:12:30.037]                           invokeRestart(restart)
[16:12:30.037]                           muffled <- TRUE
[16:12:30.037]                           break
[16:12:30.037]                         }
[16:12:30.037]                       }
[16:12:30.037]                     }
[16:12:30.037]                     invisible(muffled)
[16:12:30.037]                   }
[16:12:30.037]                   muffleCondition(cond)
[16:12:30.037]                 })
[16:12:30.037]             }))
[16:12:30.037]             future::FutureResult(value = ...future.value$value, 
[16:12:30.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.037]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.037]                     ...future.globalenv.names))
[16:12:30.037]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.037]         }, condition = base::local({
[16:12:30.037]             c <- base::c
[16:12:30.037]             inherits <- base::inherits
[16:12:30.037]             invokeRestart <- base::invokeRestart
[16:12:30.037]             length <- base::length
[16:12:30.037]             list <- base::list
[16:12:30.037]             seq.int <- base::seq.int
[16:12:30.037]             signalCondition <- base::signalCondition
[16:12:30.037]             sys.calls <- base::sys.calls
[16:12:30.037]             `[[` <- base::`[[`
[16:12:30.037]             `+` <- base::`+`
[16:12:30.037]             `<<-` <- base::`<<-`
[16:12:30.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.037]                   3L)]
[16:12:30.037]             }
[16:12:30.037]             function(cond) {
[16:12:30.037]                 is_error <- inherits(cond, "error")
[16:12:30.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.037]                   NULL)
[16:12:30.037]                 if (is_error) {
[16:12:30.037]                   sessionInformation <- function() {
[16:12:30.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.037]                       search = base::search(), system = base::Sys.info())
[16:12:30.037]                   }
[16:12:30.037]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.037]                     cond$call), session = sessionInformation(), 
[16:12:30.037]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.037]                   signalCondition(cond)
[16:12:30.037]                 }
[16:12:30.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.037]                 "immediateCondition"))) {
[16:12:30.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.037]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.037]                   if (TRUE && !signal) {
[16:12:30.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.037]                     {
[16:12:30.037]                       inherits <- base::inherits
[16:12:30.037]                       invokeRestart <- base::invokeRestart
[16:12:30.037]                       is.null <- base::is.null
[16:12:30.037]                       muffled <- FALSE
[16:12:30.037]                       if (inherits(cond, "message")) {
[16:12:30.037]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.037]                         if (muffled) 
[16:12:30.037]                           invokeRestart("muffleMessage")
[16:12:30.037]                       }
[16:12:30.037]                       else if (inherits(cond, "warning")) {
[16:12:30.037]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.037]                         if (muffled) 
[16:12:30.037]                           invokeRestart("muffleWarning")
[16:12:30.037]                       }
[16:12:30.037]                       else if (inherits(cond, "condition")) {
[16:12:30.037]                         if (!is.null(pattern)) {
[16:12:30.037]                           computeRestarts <- base::computeRestarts
[16:12:30.037]                           grepl <- base::grepl
[16:12:30.037]                           restarts <- computeRestarts(cond)
[16:12:30.037]                           for (restart in restarts) {
[16:12:30.037]                             name <- restart$name
[16:12:30.037]                             if (is.null(name)) 
[16:12:30.037]                               next
[16:12:30.037]                             if (!grepl(pattern, name)) 
[16:12:30.037]                               next
[16:12:30.037]                             invokeRestart(restart)
[16:12:30.037]                             muffled <- TRUE
[16:12:30.037]                             break
[16:12:30.037]                           }
[16:12:30.037]                         }
[16:12:30.037]                       }
[16:12:30.037]                       invisible(muffled)
[16:12:30.037]                     }
[16:12:30.037]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.037]                   }
[16:12:30.037]                 }
[16:12:30.037]                 else {
[16:12:30.037]                   if (TRUE) {
[16:12:30.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.037]                     {
[16:12:30.037]                       inherits <- base::inherits
[16:12:30.037]                       invokeRestart <- base::invokeRestart
[16:12:30.037]                       is.null <- base::is.null
[16:12:30.037]                       muffled <- FALSE
[16:12:30.037]                       if (inherits(cond, "message")) {
[16:12:30.037]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.037]                         if (muffled) 
[16:12:30.037]                           invokeRestart("muffleMessage")
[16:12:30.037]                       }
[16:12:30.037]                       else if (inherits(cond, "warning")) {
[16:12:30.037]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.037]                         if (muffled) 
[16:12:30.037]                           invokeRestart("muffleWarning")
[16:12:30.037]                       }
[16:12:30.037]                       else if (inherits(cond, "condition")) {
[16:12:30.037]                         if (!is.null(pattern)) {
[16:12:30.037]                           computeRestarts <- base::computeRestarts
[16:12:30.037]                           grepl <- base::grepl
[16:12:30.037]                           restarts <- computeRestarts(cond)
[16:12:30.037]                           for (restart in restarts) {
[16:12:30.037]                             name <- restart$name
[16:12:30.037]                             if (is.null(name)) 
[16:12:30.037]                               next
[16:12:30.037]                             if (!grepl(pattern, name)) 
[16:12:30.037]                               next
[16:12:30.037]                             invokeRestart(restart)
[16:12:30.037]                             muffled <- TRUE
[16:12:30.037]                             break
[16:12:30.037]                           }
[16:12:30.037]                         }
[16:12:30.037]                       }
[16:12:30.037]                       invisible(muffled)
[16:12:30.037]                     }
[16:12:30.037]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.037]                   }
[16:12:30.037]                 }
[16:12:30.037]             }
[16:12:30.037]         }))
[16:12:30.037]     }, error = function(ex) {
[16:12:30.037]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.037]                 ...future.rng), started = ...future.startTime, 
[16:12:30.037]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.037]             version = "1.8"), class = "FutureResult")
[16:12:30.037]     }, finally = {
[16:12:30.037]         if (!identical(...future.workdir, getwd())) 
[16:12:30.037]             setwd(...future.workdir)
[16:12:30.037]         {
[16:12:30.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.037]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.037]             }
[16:12:30.037]             base::options(...future.oldOptions)
[16:12:30.037]             if (.Platform$OS.type == "windows") {
[16:12:30.037]                 old_names <- names(...future.oldEnvVars)
[16:12:30.037]                 envs <- base::Sys.getenv()
[16:12:30.037]                 names <- names(envs)
[16:12:30.037]                 common <- intersect(names, old_names)
[16:12:30.037]                 added <- setdiff(names, old_names)
[16:12:30.037]                 removed <- setdiff(old_names, names)
[16:12:30.037]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.037]                   envs[common]]
[16:12:30.037]                 NAMES <- toupper(changed)
[16:12:30.037]                 args <- list()
[16:12:30.037]                 for (kk in seq_along(NAMES)) {
[16:12:30.037]                   name <- changed[[kk]]
[16:12:30.037]                   NAME <- NAMES[[kk]]
[16:12:30.037]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.037]                     next
[16:12:30.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.037]                 }
[16:12:30.037]                 NAMES <- toupper(added)
[16:12:30.037]                 for (kk in seq_along(NAMES)) {
[16:12:30.037]                   name <- added[[kk]]
[16:12:30.037]                   NAME <- NAMES[[kk]]
[16:12:30.037]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.037]                     next
[16:12:30.037]                   args[[name]] <- ""
[16:12:30.037]                 }
[16:12:30.037]                 NAMES <- toupper(removed)
[16:12:30.037]                 for (kk in seq_along(NAMES)) {
[16:12:30.037]                   name <- removed[[kk]]
[16:12:30.037]                   NAME <- NAMES[[kk]]
[16:12:30.037]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.037]                     next
[16:12:30.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.037]                 }
[16:12:30.037]                 if (length(args) > 0) 
[16:12:30.037]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.037]             }
[16:12:30.037]             else {
[16:12:30.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.037]             }
[16:12:30.037]             {
[16:12:30.037]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.037]                   0L) {
[16:12:30.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.037]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.037]                   base::options(opts)
[16:12:30.037]                 }
[16:12:30.037]                 {
[16:12:30.037]                   {
[16:12:30.037]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.037]                     NULL
[16:12:30.037]                   }
[16:12:30.037]                   options(future.plan = NULL)
[16:12:30.037]                   if (is.na(NA_character_)) 
[16:12:30.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.037]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:30.037]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:30.037]                     envir = parent.frame()) 
[16:12:30.037]                   {
[16:12:30.037]                     if (is.function(workers)) 
[16:12:30.037]                       workers <- workers()
[16:12:30.037]                     workers <- structure(as.integer(workers), 
[16:12:30.037]                       class = class(workers))
[16:12:30.037]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:30.037]                       workers >= 1)
[16:12:30.037]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:30.037]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:30.037]                     }
[16:12:30.037]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:30.037]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:30.037]                       envir = envir)
[16:12:30.037]                     if (!future$lazy) 
[16:12:30.037]                       future <- run(future)
[16:12:30.037]                     invisible(future)
[16:12:30.037]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.037]                 }
[16:12:30.037]             }
[16:12:30.037]         }
[16:12:30.037]     })
[16:12:30.037]     if (TRUE) {
[16:12:30.037]         base::sink(type = "output", split = FALSE)
[16:12:30.037]         if (TRUE) {
[16:12:30.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.037]         }
[16:12:30.037]         else {
[16:12:30.037]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.037]         }
[16:12:30.037]         base::close(...future.stdout)
[16:12:30.037]         ...future.stdout <- NULL
[16:12:30.037]     }
[16:12:30.037]     ...future.result$conditions <- ...future.conditions
[16:12:30.037]     ...future.result$finished <- base::Sys.time()
[16:12:30.037]     ...future.result
[16:12:30.037] }
[16:12:30.040] MultisessionFuture started
[16:12:30.040] - Launch lazy future ... done
[16:12:30.040] run() for ‘MultisessionFuture’ ... done
[16:12:30.040] getGlobalsAndPackages() ...
[16:12:30.040] Searching for globals...
[16:12:30.041] 
[16:12:30.041] Searching for globals ... DONE
[16:12:30.041] - globals: [0] <none>
[16:12:30.041] getGlobalsAndPackages() ... DONE
[16:12:30.041] run() for ‘Future’ ...
[16:12:30.041] - state: ‘created’
[16:12:30.041] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:30.056]   - Field: ‘node’
[16:12:30.056]   - Field: ‘label’
[16:12:30.056]   - Field: ‘local’
[16:12:30.056]   - Field: ‘owner’
[16:12:30.056]   - Field: ‘envir’
[16:12:30.056]   - Field: ‘workers’
[16:12:30.056]   - Field: ‘packages’
[16:12:30.056]   - Field: ‘gc’
[16:12:30.057]   - Field: ‘conditions’
[16:12:30.057]   - Field: ‘persistent’
[16:12:30.057]   - Field: ‘expr’
[16:12:30.057]   - Field: ‘uuid’
[16:12:30.057]   - Field: ‘seed’
[16:12:30.057]   - Field: ‘version’
[16:12:30.057]   - Field: ‘result’
[16:12:30.057]   - Field: ‘asynchronous’
[16:12:30.057]   - Field: ‘calls’
[16:12:30.057]   - Field: ‘globals’
[16:12:30.057]   - Field: ‘stdout’
[16:12:30.058]   - Field: ‘earlySignal’
[16:12:30.058]   - Field: ‘lazy’
[16:12:30.058]   - Field: ‘state’
[16:12:30.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:30.058] - Launch lazy future ...
[16:12:30.058] Packages needed by the future expression (n = 0): <none>
[16:12:30.058] Packages needed by future strategies (n = 0): <none>
[16:12:30.059] {
[16:12:30.059]     {
[16:12:30.059]         {
[16:12:30.059]             ...future.startTime <- base::Sys.time()
[16:12:30.059]             {
[16:12:30.059]                 {
[16:12:30.059]                   {
[16:12:30.059]                     {
[16:12:30.059]                       base::local({
[16:12:30.059]                         has_future <- base::requireNamespace("future", 
[16:12:30.059]                           quietly = TRUE)
[16:12:30.059]                         if (has_future) {
[16:12:30.059]                           ns <- base::getNamespace("future")
[16:12:30.059]                           version <- ns[[".package"]][["version"]]
[16:12:30.059]                           if (is.null(version)) 
[16:12:30.059]                             version <- utils::packageVersion("future")
[16:12:30.059]                         }
[16:12:30.059]                         else {
[16:12:30.059]                           version <- NULL
[16:12:30.059]                         }
[16:12:30.059]                         if (!has_future || version < "1.8.0") {
[16:12:30.059]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.059]                             "", base::R.version$version.string), 
[16:12:30.059]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.059]                               "release", "version")], collapse = " "), 
[16:12:30.059]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.059]                             info)
[16:12:30.059]                           info <- base::paste(info, collapse = "; ")
[16:12:30.059]                           if (!has_future) {
[16:12:30.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.059]                               info)
[16:12:30.059]                           }
[16:12:30.059]                           else {
[16:12:30.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.059]                               info, version)
[16:12:30.059]                           }
[16:12:30.059]                           base::stop(msg)
[16:12:30.059]                         }
[16:12:30.059]                       })
[16:12:30.059]                     }
[16:12:30.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.059]                     base::options(mc.cores = 1L)
[16:12:30.059]                   }
[16:12:30.059]                   options(future.plan = NULL)
[16:12:30.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.059]                 }
[16:12:30.059]                 ...future.workdir <- getwd()
[16:12:30.059]             }
[16:12:30.059]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.059]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.059]         }
[16:12:30.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.059]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.059]             base::names(...future.oldOptions))
[16:12:30.059]     }
[16:12:30.059]     if (FALSE) {
[16:12:30.059]     }
[16:12:30.059]     else {
[16:12:30.059]         if (TRUE) {
[16:12:30.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.059]                 open = "w")
[16:12:30.059]         }
[16:12:30.059]         else {
[16:12:30.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.059]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.059]         }
[16:12:30.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.059]             base::sink(type = "output", split = FALSE)
[16:12:30.059]             base::close(...future.stdout)
[16:12:30.059]         }, add = TRUE)
[16:12:30.059]     }
[16:12:30.059]     ...future.frame <- base::sys.nframe()
[16:12:30.059]     ...future.conditions <- base::list()
[16:12:30.059]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.059]     if (FALSE) {
[16:12:30.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.059]     }
[16:12:30.059]     ...future.result <- base::tryCatch({
[16:12:30.059]         base::withCallingHandlers({
[16:12:30.059]             ...future.value <- base::withVisible(base::local({
[16:12:30.059]                 ...future.makeSendCondition <- local({
[16:12:30.059]                   sendCondition <- NULL
[16:12:30.059]                   function(frame = 1L) {
[16:12:30.059]                     if (is.function(sendCondition)) 
[16:12:30.059]                       return(sendCondition)
[16:12:30.059]                     ns <- getNamespace("parallel")
[16:12:30.059]                     if (exists("sendData", mode = "function", 
[16:12:30.059]                       envir = ns)) {
[16:12:30.059]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:30.059]                         envir = ns)
[16:12:30.059]                       envir <- sys.frame(frame)
[16:12:30.059]                       master <- NULL
[16:12:30.059]                       while (!identical(envir, .GlobalEnv) && 
[16:12:30.059]                         !identical(envir, emptyenv())) {
[16:12:30.059]                         if (exists("master", mode = "list", envir = envir, 
[16:12:30.059]                           inherits = FALSE)) {
[16:12:30.059]                           master <- get("master", mode = "list", 
[16:12:30.059]                             envir = envir, inherits = FALSE)
[16:12:30.059]                           if (inherits(master, c("SOCKnode", 
[16:12:30.059]                             "SOCK0node"))) {
[16:12:30.059]                             sendCondition <<- function(cond) {
[16:12:30.059]                               data <- list(type = "VALUE", value = cond, 
[16:12:30.059]                                 success = TRUE)
[16:12:30.059]                               parallel_sendData(master, data)
[16:12:30.059]                             }
[16:12:30.059]                             return(sendCondition)
[16:12:30.059]                           }
[16:12:30.059]                         }
[16:12:30.059]                         frame <- frame + 1L
[16:12:30.059]                         envir <- sys.frame(frame)
[16:12:30.059]                       }
[16:12:30.059]                     }
[16:12:30.059]                     sendCondition <<- function(cond) NULL
[16:12:30.059]                   }
[16:12:30.059]                 })
[16:12:30.059]                 withCallingHandlers({
[16:12:30.059]                   NULL
[16:12:30.059]                 }, immediateCondition = function(cond) {
[16:12:30.059]                   sendCondition <- ...future.makeSendCondition()
[16:12:30.059]                   sendCondition(cond)
[16:12:30.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.059]                   {
[16:12:30.059]                     inherits <- base::inherits
[16:12:30.059]                     invokeRestart <- base::invokeRestart
[16:12:30.059]                     is.null <- base::is.null
[16:12:30.059]                     muffled <- FALSE
[16:12:30.059]                     if (inherits(cond, "message")) {
[16:12:30.059]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.059]                       if (muffled) 
[16:12:30.059]                         invokeRestart("muffleMessage")
[16:12:30.059]                     }
[16:12:30.059]                     else if (inherits(cond, "warning")) {
[16:12:30.059]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.059]                       if (muffled) 
[16:12:30.059]                         invokeRestart("muffleWarning")
[16:12:30.059]                     }
[16:12:30.059]                     else if (inherits(cond, "condition")) {
[16:12:30.059]                       if (!is.null(pattern)) {
[16:12:30.059]                         computeRestarts <- base::computeRestarts
[16:12:30.059]                         grepl <- base::grepl
[16:12:30.059]                         restarts <- computeRestarts(cond)
[16:12:30.059]                         for (restart in restarts) {
[16:12:30.059]                           name <- restart$name
[16:12:30.059]                           if (is.null(name)) 
[16:12:30.059]                             next
[16:12:30.059]                           if (!grepl(pattern, name)) 
[16:12:30.059]                             next
[16:12:30.059]                           invokeRestart(restart)
[16:12:30.059]                           muffled <- TRUE
[16:12:30.059]                           break
[16:12:30.059]                         }
[16:12:30.059]                       }
[16:12:30.059]                     }
[16:12:30.059]                     invisible(muffled)
[16:12:30.059]                   }
[16:12:30.059]                   muffleCondition(cond)
[16:12:30.059]                 })
[16:12:30.059]             }))
[16:12:30.059]             future::FutureResult(value = ...future.value$value, 
[16:12:30.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.059]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.059]                     ...future.globalenv.names))
[16:12:30.059]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.059]         }, condition = base::local({
[16:12:30.059]             c <- base::c
[16:12:30.059]             inherits <- base::inherits
[16:12:30.059]             invokeRestart <- base::invokeRestart
[16:12:30.059]             length <- base::length
[16:12:30.059]             list <- base::list
[16:12:30.059]             seq.int <- base::seq.int
[16:12:30.059]             signalCondition <- base::signalCondition
[16:12:30.059]             sys.calls <- base::sys.calls
[16:12:30.059]             `[[` <- base::`[[`
[16:12:30.059]             `+` <- base::`+`
[16:12:30.059]             `<<-` <- base::`<<-`
[16:12:30.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.059]                   3L)]
[16:12:30.059]             }
[16:12:30.059]             function(cond) {
[16:12:30.059]                 is_error <- inherits(cond, "error")
[16:12:30.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.059]                   NULL)
[16:12:30.059]                 if (is_error) {
[16:12:30.059]                   sessionInformation <- function() {
[16:12:30.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.059]                       search = base::search(), system = base::Sys.info())
[16:12:30.059]                   }
[16:12:30.059]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.059]                     cond$call), session = sessionInformation(), 
[16:12:30.059]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.059]                   signalCondition(cond)
[16:12:30.059]                 }
[16:12:30.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.059]                 "immediateCondition"))) {
[16:12:30.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.059]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.059]                   if (TRUE && !signal) {
[16:12:30.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.059]                     {
[16:12:30.059]                       inherits <- base::inherits
[16:12:30.059]                       invokeRestart <- base::invokeRestart
[16:12:30.059]                       is.null <- base::is.null
[16:12:30.059]                       muffled <- FALSE
[16:12:30.059]                       if (inherits(cond, "message")) {
[16:12:30.059]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.059]                         if (muffled) 
[16:12:30.059]                           invokeRestart("muffleMessage")
[16:12:30.059]                       }
[16:12:30.059]                       else if (inherits(cond, "warning")) {
[16:12:30.059]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.059]                         if (muffled) 
[16:12:30.059]                           invokeRestart("muffleWarning")
[16:12:30.059]                       }
[16:12:30.059]                       else if (inherits(cond, "condition")) {
[16:12:30.059]                         if (!is.null(pattern)) {
[16:12:30.059]                           computeRestarts <- base::computeRestarts
[16:12:30.059]                           grepl <- base::grepl
[16:12:30.059]                           restarts <- computeRestarts(cond)
[16:12:30.059]                           for (restart in restarts) {
[16:12:30.059]                             name <- restart$name
[16:12:30.059]                             if (is.null(name)) 
[16:12:30.059]                               next
[16:12:30.059]                             if (!grepl(pattern, name)) 
[16:12:30.059]                               next
[16:12:30.059]                             invokeRestart(restart)
[16:12:30.059]                             muffled <- TRUE
[16:12:30.059]                             break
[16:12:30.059]                           }
[16:12:30.059]                         }
[16:12:30.059]                       }
[16:12:30.059]                       invisible(muffled)
[16:12:30.059]                     }
[16:12:30.059]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.059]                   }
[16:12:30.059]                 }
[16:12:30.059]                 else {
[16:12:30.059]                   if (TRUE) {
[16:12:30.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.059]                     {
[16:12:30.059]                       inherits <- base::inherits
[16:12:30.059]                       invokeRestart <- base::invokeRestart
[16:12:30.059]                       is.null <- base::is.null
[16:12:30.059]                       muffled <- FALSE
[16:12:30.059]                       if (inherits(cond, "message")) {
[16:12:30.059]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.059]                         if (muffled) 
[16:12:30.059]                           invokeRestart("muffleMessage")
[16:12:30.059]                       }
[16:12:30.059]                       else if (inherits(cond, "warning")) {
[16:12:30.059]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.059]                         if (muffled) 
[16:12:30.059]                           invokeRestart("muffleWarning")
[16:12:30.059]                       }
[16:12:30.059]                       else if (inherits(cond, "condition")) {
[16:12:30.059]                         if (!is.null(pattern)) {
[16:12:30.059]                           computeRestarts <- base::computeRestarts
[16:12:30.059]                           grepl <- base::grepl
[16:12:30.059]                           restarts <- computeRestarts(cond)
[16:12:30.059]                           for (restart in restarts) {
[16:12:30.059]                             name <- restart$name
[16:12:30.059]                             if (is.null(name)) 
[16:12:30.059]                               next
[16:12:30.059]                             if (!grepl(pattern, name)) 
[16:12:30.059]                               next
[16:12:30.059]                             invokeRestart(restart)
[16:12:30.059]                             muffled <- TRUE
[16:12:30.059]                             break
[16:12:30.059]                           }
[16:12:30.059]                         }
[16:12:30.059]                       }
[16:12:30.059]                       invisible(muffled)
[16:12:30.059]                     }
[16:12:30.059]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.059]                   }
[16:12:30.059]                 }
[16:12:30.059]             }
[16:12:30.059]         }))
[16:12:30.059]     }, error = function(ex) {
[16:12:30.059]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.059]                 ...future.rng), started = ...future.startTime, 
[16:12:30.059]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.059]             version = "1.8"), class = "FutureResult")
[16:12:30.059]     }, finally = {
[16:12:30.059]         if (!identical(...future.workdir, getwd())) 
[16:12:30.059]             setwd(...future.workdir)
[16:12:30.059]         {
[16:12:30.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.059]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.059]             }
[16:12:30.059]             base::options(...future.oldOptions)
[16:12:30.059]             if (.Platform$OS.type == "windows") {
[16:12:30.059]                 old_names <- names(...future.oldEnvVars)
[16:12:30.059]                 envs <- base::Sys.getenv()
[16:12:30.059]                 names <- names(envs)
[16:12:30.059]                 common <- intersect(names, old_names)
[16:12:30.059]                 added <- setdiff(names, old_names)
[16:12:30.059]                 removed <- setdiff(old_names, names)
[16:12:30.059]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.059]                   envs[common]]
[16:12:30.059]                 NAMES <- toupper(changed)
[16:12:30.059]                 args <- list()
[16:12:30.059]                 for (kk in seq_along(NAMES)) {
[16:12:30.059]                   name <- changed[[kk]]
[16:12:30.059]                   NAME <- NAMES[[kk]]
[16:12:30.059]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.059]                     next
[16:12:30.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.059]                 }
[16:12:30.059]                 NAMES <- toupper(added)
[16:12:30.059]                 for (kk in seq_along(NAMES)) {
[16:12:30.059]                   name <- added[[kk]]
[16:12:30.059]                   NAME <- NAMES[[kk]]
[16:12:30.059]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.059]                     next
[16:12:30.059]                   args[[name]] <- ""
[16:12:30.059]                 }
[16:12:30.059]                 NAMES <- toupper(removed)
[16:12:30.059]                 for (kk in seq_along(NAMES)) {
[16:12:30.059]                   name <- removed[[kk]]
[16:12:30.059]                   NAME <- NAMES[[kk]]
[16:12:30.059]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.059]                     next
[16:12:30.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.059]                 }
[16:12:30.059]                 if (length(args) > 0) 
[16:12:30.059]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.059]             }
[16:12:30.059]             else {
[16:12:30.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.059]             }
[16:12:30.059]             {
[16:12:30.059]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.059]                   0L) {
[16:12:30.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.059]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.059]                   base::options(opts)
[16:12:30.059]                 }
[16:12:30.059]                 {
[16:12:30.059]                   {
[16:12:30.059]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.059]                     NULL
[16:12:30.059]                   }
[16:12:30.059]                   options(future.plan = NULL)
[16:12:30.059]                   if (is.na(NA_character_)) 
[16:12:30.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.059]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:30.059]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:30.059]                     envir = parent.frame()) 
[16:12:30.059]                   {
[16:12:30.059]                     if (is.function(workers)) 
[16:12:30.059]                       workers <- workers()
[16:12:30.059]                     workers <- structure(as.integer(workers), 
[16:12:30.059]                       class = class(workers))
[16:12:30.059]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:30.059]                       workers >= 1)
[16:12:30.059]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:30.059]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:30.059]                     }
[16:12:30.059]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:30.059]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:30.059]                       envir = envir)
[16:12:30.059]                     if (!future$lazy) 
[16:12:30.059]                       future <- run(future)
[16:12:30.059]                     invisible(future)
[16:12:30.059]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.059]                 }
[16:12:30.059]             }
[16:12:30.059]         }
[16:12:30.059]     })
[16:12:30.059]     if (TRUE) {
[16:12:30.059]         base::sink(type = "output", split = FALSE)
[16:12:30.059]         if (TRUE) {
[16:12:30.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.059]         }
[16:12:30.059]         else {
[16:12:30.059]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.059]         }
[16:12:30.059]         base::close(...future.stdout)
[16:12:30.059]         ...future.stdout <- NULL
[16:12:30.059]     }
[16:12:30.059]     ...future.result$conditions <- ...future.conditions
[16:12:30.059]     ...future.result$finished <- base::Sys.time()
[16:12:30.059]     ...future.result
[16:12:30.059] }
[16:12:30.062] MultisessionFuture started
[16:12:30.062] - Launch lazy future ... done
[16:12:30.062] run() for ‘MultisessionFuture’ ... done
[16:12:30.063] getGlobalsAndPackages() ...
[16:12:30.063] Searching for globals...
[16:12:30.063] - globals found: [1] ‘{’
[16:12:30.063] Searching for globals ... DONE
[16:12:30.064] Resolving globals: FALSE
[16:12:30.064] 
[16:12:30.064] 
[16:12:30.064] getGlobalsAndPackages() ... DONE
[16:12:30.064] run() for ‘Future’ ...
[16:12:30.064] - state: ‘created’
[16:12:30.064] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.079] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.079] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:30.079]   - Field: ‘node’
[16:12:30.079]   - Field: ‘label’
[16:12:30.079]   - Field: ‘local’
[16:12:30.079]   - Field: ‘owner’
[16:12:30.080]   - Field: ‘envir’
[16:12:30.080]   - Field: ‘workers’
[16:12:30.080]   - Field: ‘packages’
[16:12:30.080]   - Field: ‘gc’
[16:12:30.080]   - Field: ‘conditions’
[16:12:30.080]   - Field: ‘persistent’
[16:12:30.080]   - Field: ‘expr’
[16:12:30.080]   - Field: ‘uuid’
[16:12:30.080]   - Field: ‘seed’
[16:12:30.080]   - Field: ‘version’
[16:12:30.081]   - Field: ‘result’
[16:12:30.081]   - Field: ‘asynchronous’
[16:12:30.081]   - Field: ‘calls’
[16:12:30.081]   - Field: ‘globals’
[16:12:30.081]   - Field: ‘stdout’
[16:12:30.081]   - Field: ‘earlySignal’
[16:12:30.081]   - Field: ‘lazy’
[16:12:30.081]   - Field: ‘state’
[16:12:30.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:30.081] - Launch lazy future ...
[16:12:30.082] Packages needed by the future expression (n = 0): <none>
[16:12:30.082] Packages needed by future strategies (n = 0): <none>
[16:12:30.082] {
[16:12:30.082]     {
[16:12:30.082]         {
[16:12:30.082]             ...future.startTime <- base::Sys.time()
[16:12:30.082]             {
[16:12:30.082]                 {
[16:12:30.082]                   {
[16:12:30.082]                     {
[16:12:30.082]                       base::local({
[16:12:30.082]                         has_future <- base::requireNamespace("future", 
[16:12:30.082]                           quietly = TRUE)
[16:12:30.082]                         if (has_future) {
[16:12:30.082]                           ns <- base::getNamespace("future")
[16:12:30.082]                           version <- ns[[".package"]][["version"]]
[16:12:30.082]                           if (is.null(version)) 
[16:12:30.082]                             version <- utils::packageVersion("future")
[16:12:30.082]                         }
[16:12:30.082]                         else {
[16:12:30.082]                           version <- NULL
[16:12:30.082]                         }
[16:12:30.082]                         if (!has_future || version < "1.8.0") {
[16:12:30.082]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.082]                             "", base::R.version$version.string), 
[16:12:30.082]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.082]                               "release", "version")], collapse = " "), 
[16:12:30.082]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.082]                             info)
[16:12:30.082]                           info <- base::paste(info, collapse = "; ")
[16:12:30.082]                           if (!has_future) {
[16:12:30.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.082]                               info)
[16:12:30.082]                           }
[16:12:30.082]                           else {
[16:12:30.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.082]                               info, version)
[16:12:30.082]                           }
[16:12:30.082]                           base::stop(msg)
[16:12:30.082]                         }
[16:12:30.082]                       })
[16:12:30.082]                     }
[16:12:30.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.082]                     base::options(mc.cores = 1L)
[16:12:30.082]                   }
[16:12:30.082]                   options(future.plan = NULL)
[16:12:30.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.082]                 }
[16:12:30.082]                 ...future.workdir <- getwd()
[16:12:30.082]             }
[16:12:30.082]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.082]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.082]         }
[16:12:30.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.082]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.082]             base::names(...future.oldOptions))
[16:12:30.082]     }
[16:12:30.082]     if (FALSE) {
[16:12:30.082]     }
[16:12:30.082]     else {
[16:12:30.082]         if (TRUE) {
[16:12:30.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.082]                 open = "w")
[16:12:30.082]         }
[16:12:30.082]         else {
[16:12:30.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.082]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.082]         }
[16:12:30.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.082]             base::sink(type = "output", split = FALSE)
[16:12:30.082]             base::close(...future.stdout)
[16:12:30.082]         }, add = TRUE)
[16:12:30.082]     }
[16:12:30.082]     ...future.frame <- base::sys.nframe()
[16:12:30.082]     ...future.conditions <- base::list()
[16:12:30.082]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.082]     if (FALSE) {
[16:12:30.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.082]     }
[16:12:30.082]     ...future.result <- base::tryCatch({
[16:12:30.082]         base::withCallingHandlers({
[16:12:30.082]             ...future.value <- base::withVisible(base::local({
[16:12:30.082]                 ...future.makeSendCondition <- local({
[16:12:30.082]                   sendCondition <- NULL
[16:12:30.082]                   function(frame = 1L) {
[16:12:30.082]                     if (is.function(sendCondition)) 
[16:12:30.082]                       return(sendCondition)
[16:12:30.082]                     ns <- getNamespace("parallel")
[16:12:30.082]                     if (exists("sendData", mode = "function", 
[16:12:30.082]                       envir = ns)) {
[16:12:30.082]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:30.082]                         envir = ns)
[16:12:30.082]                       envir <- sys.frame(frame)
[16:12:30.082]                       master <- NULL
[16:12:30.082]                       while (!identical(envir, .GlobalEnv) && 
[16:12:30.082]                         !identical(envir, emptyenv())) {
[16:12:30.082]                         if (exists("master", mode = "list", envir = envir, 
[16:12:30.082]                           inherits = FALSE)) {
[16:12:30.082]                           master <- get("master", mode = "list", 
[16:12:30.082]                             envir = envir, inherits = FALSE)
[16:12:30.082]                           if (inherits(master, c("SOCKnode", 
[16:12:30.082]                             "SOCK0node"))) {
[16:12:30.082]                             sendCondition <<- function(cond) {
[16:12:30.082]                               data <- list(type = "VALUE", value = cond, 
[16:12:30.082]                                 success = TRUE)
[16:12:30.082]                               parallel_sendData(master, data)
[16:12:30.082]                             }
[16:12:30.082]                             return(sendCondition)
[16:12:30.082]                           }
[16:12:30.082]                         }
[16:12:30.082]                         frame <- frame + 1L
[16:12:30.082]                         envir <- sys.frame(frame)
[16:12:30.082]                       }
[16:12:30.082]                     }
[16:12:30.082]                     sendCondition <<- function(cond) NULL
[16:12:30.082]                   }
[16:12:30.082]                 })
[16:12:30.082]                 withCallingHandlers({
[16:12:30.082]                   {
[16:12:30.082]                     4
[16:12:30.082]                   }
[16:12:30.082]                 }, immediateCondition = function(cond) {
[16:12:30.082]                   sendCondition <- ...future.makeSendCondition()
[16:12:30.082]                   sendCondition(cond)
[16:12:30.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.082]                   {
[16:12:30.082]                     inherits <- base::inherits
[16:12:30.082]                     invokeRestart <- base::invokeRestart
[16:12:30.082]                     is.null <- base::is.null
[16:12:30.082]                     muffled <- FALSE
[16:12:30.082]                     if (inherits(cond, "message")) {
[16:12:30.082]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.082]                       if (muffled) 
[16:12:30.082]                         invokeRestart("muffleMessage")
[16:12:30.082]                     }
[16:12:30.082]                     else if (inherits(cond, "warning")) {
[16:12:30.082]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.082]                       if (muffled) 
[16:12:30.082]                         invokeRestart("muffleWarning")
[16:12:30.082]                     }
[16:12:30.082]                     else if (inherits(cond, "condition")) {
[16:12:30.082]                       if (!is.null(pattern)) {
[16:12:30.082]                         computeRestarts <- base::computeRestarts
[16:12:30.082]                         grepl <- base::grepl
[16:12:30.082]                         restarts <- computeRestarts(cond)
[16:12:30.082]                         for (restart in restarts) {
[16:12:30.082]                           name <- restart$name
[16:12:30.082]                           if (is.null(name)) 
[16:12:30.082]                             next
[16:12:30.082]                           if (!grepl(pattern, name)) 
[16:12:30.082]                             next
[16:12:30.082]                           invokeRestart(restart)
[16:12:30.082]                           muffled <- TRUE
[16:12:30.082]                           break
[16:12:30.082]                         }
[16:12:30.082]                       }
[16:12:30.082]                     }
[16:12:30.082]                     invisible(muffled)
[16:12:30.082]                   }
[16:12:30.082]                   muffleCondition(cond)
[16:12:30.082]                 })
[16:12:30.082]             }))
[16:12:30.082]             future::FutureResult(value = ...future.value$value, 
[16:12:30.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.082]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.082]                     ...future.globalenv.names))
[16:12:30.082]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.082]         }, condition = base::local({
[16:12:30.082]             c <- base::c
[16:12:30.082]             inherits <- base::inherits
[16:12:30.082]             invokeRestart <- base::invokeRestart
[16:12:30.082]             length <- base::length
[16:12:30.082]             list <- base::list
[16:12:30.082]             seq.int <- base::seq.int
[16:12:30.082]             signalCondition <- base::signalCondition
[16:12:30.082]             sys.calls <- base::sys.calls
[16:12:30.082]             `[[` <- base::`[[`
[16:12:30.082]             `+` <- base::`+`
[16:12:30.082]             `<<-` <- base::`<<-`
[16:12:30.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.082]                   3L)]
[16:12:30.082]             }
[16:12:30.082]             function(cond) {
[16:12:30.082]                 is_error <- inherits(cond, "error")
[16:12:30.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.082]                   NULL)
[16:12:30.082]                 if (is_error) {
[16:12:30.082]                   sessionInformation <- function() {
[16:12:30.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.082]                       search = base::search(), system = base::Sys.info())
[16:12:30.082]                   }
[16:12:30.082]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.082]                     cond$call), session = sessionInformation(), 
[16:12:30.082]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.082]                   signalCondition(cond)
[16:12:30.082]                 }
[16:12:30.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.082]                 "immediateCondition"))) {
[16:12:30.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.082]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.082]                   if (TRUE && !signal) {
[16:12:30.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.082]                     {
[16:12:30.082]                       inherits <- base::inherits
[16:12:30.082]                       invokeRestart <- base::invokeRestart
[16:12:30.082]                       is.null <- base::is.null
[16:12:30.082]                       muffled <- FALSE
[16:12:30.082]                       if (inherits(cond, "message")) {
[16:12:30.082]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.082]                         if (muffled) 
[16:12:30.082]                           invokeRestart("muffleMessage")
[16:12:30.082]                       }
[16:12:30.082]                       else if (inherits(cond, "warning")) {
[16:12:30.082]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.082]                         if (muffled) 
[16:12:30.082]                           invokeRestart("muffleWarning")
[16:12:30.082]                       }
[16:12:30.082]                       else if (inherits(cond, "condition")) {
[16:12:30.082]                         if (!is.null(pattern)) {
[16:12:30.082]                           computeRestarts <- base::computeRestarts
[16:12:30.082]                           grepl <- base::grepl
[16:12:30.082]                           restarts <- computeRestarts(cond)
[16:12:30.082]                           for (restart in restarts) {
[16:12:30.082]                             name <- restart$name
[16:12:30.082]                             if (is.null(name)) 
[16:12:30.082]                               next
[16:12:30.082]                             if (!grepl(pattern, name)) 
[16:12:30.082]                               next
[16:12:30.082]                             invokeRestart(restart)
[16:12:30.082]                             muffled <- TRUE
[16:12:30.082]                             break
[16:12:30.082]                           }
[16:12:30.082]                         }
[16:12:30.082]                       }
[16:12:30.082]                       invisible(muffled)
[16:12:30.082]                     }
[16:12:30.082]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.082]                   }
[16:12:30.082]                 }
[16:12:30.082]                 else {
[16:12:30.082]                   if (TRUE) {
[16:12:30.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.082]                     {
[16:12:30.082]                       inherits <- base::inherits
[16:12:30.082]                       invokeRestart <- base::invokeRestart
[16:12:30.082]                       is.null <- base::is.null
[16:12:30.082]                       muffled <- FALSE
[16:12:30.082]                       if (inherits(cond, "message")) {
[16:12:30.082]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.082]                         if (muffled) 
[16:12:30.082]                           invokeRestart("muffleMessage")
[16:12:30.082]                       }
[16:12:30.082]                       else if (inherits(cond, "warning")) {
[16:12:30.082]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.082]                         if (muffled) 
[16:12:30.082]                           invokeRestart("muffleWarning")
[16:12:30.082]                       }
[16:12:30.082]                       else if (inherits(cond, "condition")) {
[16:12:30.082]                         if (!is.null(pattern)) {
[16:12:30.082]                           computeRestarts <- base::computeRestarts
[16:12:30.082]                           grepl <- base::grepl
[16:12:30.082]                           restarts <- computeRestarts(cond)
[16:12:30.082]                           for (restart in restarts) {
[16:12:30.082]                             name <- restart$name
[16:12:30.082]                             if (is.null(name)) 
[16:12:30.082]                               next
[16:12:30.082]                             if (!grepl(pattern, name)) 
[16:12:30.082]                               next
[16:12:30.082]                             invokeRestart(restart)
[16:12:30.082]                             muffled <- TRUE
[16:12:30.082]                             break
[16:12:30.082]                           }
[16:12:30.082]                         }
[16:12:30.082]                       }
[16:12:30.082]                       invisible(muffled)
[16:12:30.082]                     }
[16:12:30.082]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.082]                   }
[16:12:30.082]                 }
[16:12:30.082]             }
[16:12:30.082]         }))
[16:12:30.082]     }, error = function(ex) {
[16:12:30.082]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.082]                 ...future.rng), started = ...future.startTime, 
[16:12:30.082]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.082]             version = "1.8"), class = "FutureResult")
[16:12:30.082]     }, finally = {
[16:12:30.082]         if (!identical(...future.workdir, getwd())) 
[16:12:30.082]             setwd(...future.workdir)
[16:12:30.082]         {
[16:12:30.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.082]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.082]             }
[16:12:30.082]             base::options(...future.oldOptions)
[16:12:30.082]             if (.Platform$OS.type == "windows") {
[16:12:30.082]                 old_names <- names(...future.oldEnvVars)
[16:12:30.082]                 envs <- base::Sys.getenv()
[16:12:30.082]                 names <- names(envs)
[16:12:30.082]                 common <- intersect(names, old_names)
[16:12:30.082]                 added <- setdiff(names, old_names)
[16:12:30.082]                 removed <- setdiff(old_names, names)
[16:12:30.082]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.082]                   envs[common]]
[16:12:30.082]                 NAMES <- toupper(changed)
[16:12:30.082]                 args <- list()
[16:12:30.082]                 for (kk in seq_along(NAMES)) {
[16:12:30.082]                   name <- changed[[kk]]
[16:12:30.082]                   NAME <- NAMES[[kk]]
[16:12:30.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.082]                     next
[16:12:30.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.082]                 }
[16:12:30.082]                 NAMES <- toupper(added)
[16:12:30.082]                 for (kk in seq_along(NAMES)) {
[16:12:30.082]                   name <- added[[kk]]
[16:12:30.082]                   NAME <- NAMES[[kk]]
[16:12:30.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.082]                     next
[16:12:30.082]                   args[[name]] <- ""
[16:12:30.082]                 }
[16:12:30.082]                 NAMES <- toupper(removed)
[16:12:30.082]                 for (kk in seq_along(NAMES)) {
[16:12:30.082]                   name <- removed[[kk]]
[16:12:30.082]                   NAME <- NAMES[[kk]]
[16:12:30.082]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.082]                     next
[16:12:30.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.082]                 }
[16:12:30.082]                 if (length(args) > 0) 
[16:12:30.082]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.082]             }
[16:12:30.082]             else {
[16:12:30.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.082]             }
[16:12:30.082]             {
[16:12:30.082]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.082]                   0L) {
[16:12:30.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.082]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.082]                   base::options(opts)
[16:12:30.082]                 }
[16:12:30.082]                 {
[16:12:30.082]                   {
[16:12:30.082]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.082]                     NULL
[16:12:30.082]                   }
[16:12:30.082]                   options(future.plan = NULL)
[16:12:30.082]                   if (is.na(NA_character_)) 
[16:12:30.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.082]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:30.082]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:30.082]                     envir = parent.frame()) 
[16:12:30.082]                   {
[16:12:30.082]                     if (is.function(workers)) 
[16:12:30.082]                       workers <- workers()
[16:12:30.082]                     workers <- structure(as.integer(workers), 
[16:12:30.082]                       class = class(workers))
[16:12:30.082]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:30.082]                       workers >= 1)
[16:12:30.082]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:30.082]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:30.082]                     }
[16:12:30.082]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:30.082]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:30.082]                       envir = envir)
[16:12:30.082]                     if (!future$lazy) 
[16:12:30.082]                       future <- run(future)
[16:12:30.082]                     invisible(future)
[16:12:30.082]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.082]                 }
[16:12:30.082]             }
[16:12:30.082]         }
[16:12:30.082]     })
[16:12:30.082]     if (TRUE) {
[16:12:30.082]         base::sink(type = "output", split = FALSE)
[16:12:30.082]         if (TRUE) {
[16:12:30.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.082]         }
[16:12:30.082]         else {
[16:12:30.082]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.082]         }
[16:12:30.082]         base::close(...future.stdout)
[16:12:30.082]         ...future.stdout <- NULL
[16:12:30.082]     }
[16:12:30.082]     ...future.result$conditions <- ...future.conditions
[16:12:30.082]     ...future.result$finished <- base::Sys.time()
[16:12:30.082]     ...future.result
[16:12:30.082] }
[16:12:30.084] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:30.095] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.095] - Validating connection of MultisessionFuture
[16:12:30.096] - received message: FutureResult
[16:12:30.096] - Received FutureResult
[16:12:30.096] - Erased future from FutureRegistry
[16:12:30.096] result() for ClusterFuture ...
[16:12:30.096] - result already collected: FutureResult
[16:12:30.096] result() for ClusterFuture ... done
[16:12:30.096] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:30.096] result() for ClusterFuture ...
[16:12:30.097] - result already collected: FutureResult
[16:12:30.097] result() for ClusterFuture ... done
[16:12:30.097] result() for ClusterFuture ...
[16:12:30.097] - result already collected: FutureResult
[16:12:30.097] result() for ClusterFuture ... done
[16:12:30.098] MultisessionFuture started
[16:12:30.098] - Launch lazy future ... done
[16:12:30.098] run() for ‘MultisessionFuture’ ... done
<environment: 0x560bb09a7740> 
<environment: 0x560bae010858> 
[16:12:30.108] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.109] - Validating connection of MultisessionFuture
[16:12:30.109] - received message: FutureResult
[16:12:30.109] - Received FutureResult
[16:12:30.109] - Erased future from FutureRegistry
[16:12:30.109] result() for ClusterFuture ...
[16:12:30.109] - result already collected: FutureResult
[16:12:30.109] result() for ClusterFuture ... done
[16:12:30.109] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:30.121] resolve() on environment ...
[16:12:30.121]  recursive: 0
[16:12:30.122]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:30.122] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.122] - nx: 4
[16:12:30.122] - relay: TRUE
[16:12:30.122] - stdout: TRUE
[16:12:30.122] - signal: TRUE
[16:12:30.122] - resignal: FALSE
[16:12:30.122] - force: TRUE
[16:12:30.122] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.123] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.123]  - until=2
[16:12:30.123]  - relaying element #2
[16:12:30.123] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:30.123] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.123] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.123]  length: 3 (resolved future 1)
[16:12:30.123] Future #2
[16:12:30.123] result() for ClusterFuture ...
[16:12:30.123] - result already collected: FutureResult
[16:12:30.123] result() for ClusterFuture ... done
[16:12:30.124] result() for ClusterFuture ...
[16:12:30.124] - result already collected: FutureResult
[16:12:30.124] result() for ClusterFuture ... done
[16:12:30.124] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:30.124] - nx: 4
[16:12:30.124] - relay: TRUE
[16:12:30.124] - stdout: TRUE
[16:12:30.124] - signal: TRUE
[16:12:30.124] - resignal: FALSE
[16:12:30.124] - force: TRUE
[16:12:30.124] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:30.125] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.125]  - until=2
[16:12:30.125]  - relaying element #2
[16:12:30.125] result() for ClusterFuture ...
[16:12:30.125] - result already collected: FutureResult
[16:12:30.125] result() for ClusterFuture ... done
[16:12:30.125] result() for ClusterFuture ...
[16:12:30.125] - result already collected: FutureResult
[16:12:30.125] result() for ClusterFuture ... done
[16:12:30.125] result() for ClusterFuture ...
[16:12:30.125] - result already collected: FutureResult
[16:12:30.126] result() for ClusterFuture ... done
[16:12:30.126] result() for ClusterFuture ...
[16:12:30.126] - result already collected: FutureResult
[16:12:30.126] result() for ClusterFuture ... done
[16:12:30.126] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:30.126] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:30.126] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:30.126]  length: 2 (resolved future 2)
[16:12:30.126] Future #3
[16:12:30.126] result() for ClusterFuture ...
[16:12:30.127] - result already collected: FutureResult
[16:12:30.127] result() for ClusterFuture ... done
[16:12:30.127] result() for ClusterFuture ...
[16:12:30.127] - result already collected: FutureResult
[16:12:30.127] result() for ClusterFuture ... done
[16:12:30.127] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:30.127] - nx: 4
[16:12:30.127] - relay: TRUE
[16:12:30.127] - stdout: TRUE
[16:12:30.127] - signal: TRUE
[16:12:30.127] - resignal: FALSE
[16:12:30.128] - force: TRUE
[16:12:30.128] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:30.128] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:30.128]  - until=3
[16:12:30.128]  - relaying element #3
[16:12:30.128] result() for ClusterFuture ...
[16:12:30.128] - result already collected: FutureResult
[16:12:30.128] result() for ClusterFuture ... done
[16:12:30.128] result() for ClusterFuture ...
[16:12:30.128] - result already collected: FutureResult
[16:12:30.128] result() for ClusterFuture ... done
[16:12:30.129] result() for ClusterFuture ...
[16:12:30.129] - result already collected: FutureResult
[16:12:30.129] result() for ClusterFuture ... done
[16:12:30.129] result() for ClusterFuture ...
[16:12:30.129] - result already collected: FutureResult
[16:12:30.129] result() for ClusterFuture ... done
[16:12:30.129] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:30.129] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:30.129] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:30.129]  length: 1 (resolved future 3)
[16:12:30.152] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.152] - Validating connection of MultisessionFuture
[16:12:30.152] - received message: FutureResult
[16:12:30.152] - Received FutureResult
[16:12:30.153] - Erased future from FutureRegistry
[16:12:30.153] result() for ClusterFuture ...
[16:12:30.153] - result already collected: FutureResult
[16:12:30.153] result() for ClusterFuture ... done
[16:12:30.153] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:30.153] Future #4
[16:12:30.153] result() for ClusterFuture ...
[16:12:30.154] - result already collected: FutureResult
[16:12:30.154] result() for ClusterFuture ... done
[16:12:30.154] result() for ClusterFuture ...
[16:12:30.154] - result already collected: FutureResult
[16:12:30.154] result() for ClusterFuture ... done
[16:12:30.154] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:30.154] - nx: 4
[16:12:30.154] - relay: TRUE
[16:12:30.155] - stdout: TRUE
[16:12:30.155] - signal: TRUE
[16:12:30.155] - resignal: FALSE
[16:12:30.155] - force: TRUE
[16:12:30.155] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:30.155] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:30.155]  - until=4
[16:12:30.155]  - relaying element #4
[16:12:30.156] result() for ClusterFuture ...
[16:12:30.156] - result already collected: FutureResult
[16:12:30.156] result() for ClusterFuture ... done
[16:12:30.156] result() for ClusterFuture ...
[16:12:30.156] - result already collected: FutureResult
[16:12:30.156] result() for ClusterFuture ... done
[16:12:30.156] result() for ClusterFuture ...
[16:12:30.157] - result already collected: FutureResult
[16:12:30.157] result() for ClusterFuture ... done
[16:12:30.157] result() for ClusterFuture ...
[16:12:30.157] - result already collected: FutureResult
[16:12:30.157] result() for ClusterFuture ... done
[16:12:30.157] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.157] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:30.157] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:30.158]  length: 0 (resolved future 4)
[16:12:30.158] Relaying remaining futures
[16:12:30.158] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.158] - nx: 4
[16:12:30.158] - relay: TRUE
[16:12:30.158] - stdout: TRUE
[16:12:30.158] - signal: TRUE
[16:12:30.158] - resignal: FALSE
[16:12:30.159] - force: TRUE
[16:12:30.159] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.159] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:30.159] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.159] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:30.159] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.159] resolve() on environment ... DONE
[16:12:30.159] result() for ClusterFuture ...
[16:12:30.160] - result already collected: FutureResult
[16:12:30.160] result() for ClusterFuture ... done
[16:12:30.160] result() for ClusterFuture ...
[16:12:30.160] - result already collected: FutureResult
[16:12:30.160] result() for ClusterFuture ... done
[16:12:30.160] result() for ClusterFuture ...
[16:12:30.160] - result already collected: FutureResult
[16:12:30.160] result() for ClusterFuture ... done
[16:12:30.161] result() for ClusterFuture ...
[16:12:30.161] - result already collected: FutureResult
[16:12:30.161] result() for ClusterFuture ... done
[16:12:30.161] result() for ClusterFuture ...
[16:12:30.161] - result already collected: FutureResult
[16:12:30.161] result() for ClusterFuture ... done
[16:12:30.161] result() for ClusterFuture ...
[16:12:30.161] - result already collected: FutureResult
[16:12:30.161] result() for ClusterFuture ... done
<environment: 0x560bacd0f720> 
Dimensions: c(2, 1, 3, 1)
[16:12:30.162] getGlobalsAndPackages() ...
[16:12:30.162] Searching for globals...
[16:12:30.163] 
[16:12:30.163] Searching for globals ... DONE
[16:12:30.163] - globals: [0] <none>
[16:12:30.163] getGlobalsAndPackages() ... DONE
[16:12:30.163] run() for ‘Future’ ...
[16:12:30.163] - state: ‘created’
[16:12:30.164] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.183] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.183] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:30.184]   - Field: ‘node’
[16:12:30.184]   - Field: ‘label’
[16:12:30.184]   - Field: ‘local’
[16:12:30.184]   - Field: ‘owner’
[16:12:30.184]   - Field: ‘envir’
[16:12:30.185]   - Field: ‘workers’
[16:12:30.185]   - Field: ‘packages’
[16:12:30.185]   - Field: ‘gc’
[16:12:30.185]   - Field: ‘conditions’
[16:12:30.185]   - Field: ‘persistent’
[16:12:30.185]   - Field: ‘expr’
[16:12:30.185]   - Field: ‘uuid’
[16:12:30.186]   - Field: ‘seed’
[16:12:30.186]   - Field: ‘version’
[16:12:30.186]   - Field: ‘result’
[16:12:30.186]   - Field: ‘asynchronous’
[16:12:30.186]   - Field: ‘calls’
[16:12:30.186]   - Field: ‘globals’
[16:12:30.186]   - Field: ‘stdout’
[16:12:30.187]   - Field: ‘earlySignal’
[16:12:30.187]   - Field: ‘lazy’
[16:12:30.187]   - Field: ‘state’
[16:12:30.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:30.187] - Launch lazy future ...
[16:12:30.187] Packages needed by the future expression (n = 0): <none>
[16:12:30.187] Packages needed by future strategies (n = 0): <none>
[16:12:30.188] {
[16:12:30.188]     {
[16:12:30.188]         {
[16:12:30.188]             ...future.startTime <- base::Sys.time()
[16:12:30.188]             {
[16:12:30.188]                 {
[16:12:30.188]                   {
[16:12:30.188]                     {
[16:12:30.188]                       base::local({
[16:12:30.188]                         has_future <- base::requireNamespace("future", 
[16:12:30.188]                           quietly = TRUE)
[16:12:30.188]                         if (has_future) {
[16:12:30.188]                           ns <- base::getNamespace("future")
[16:12:30.188]                           version <- ns[[".package"]][["version"]]
[16:12:30.188]                           if (is.null(version)) 
[16:12:30.188]                             version <- utils::packageVersion("future")
[16:12:30.188]                         }
[16:12:30.188]                         else {
[16:12:30.188]                           version <- NULL
[16:12:30.188]                         }
[16:12:30.188]                         if (!has_future || version < "1.8.0") {
[16:12:30.188]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.188]                             "", base::R.version$version.string), 
[16:12:30.188]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.188]                               "release", "version")], collapse = " "), 
[16:12:30.188]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.188]                             info)
[16:12:30.188]                           info <- base::paste(info, collapse = "; ")
[16:12:30.188]                           if (!has_future) {
[16:12:30.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.188]                               info)
[16:12:30.188]                           }
[16:12:30.188]                           else {
[16:12:30.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.188]                               info, version)
[16:12:30.188]                           }
[16:12:30.188]                           base::stop(msg)
[16:12:30.188]                         }
[16:12:30.188]                       })
[16:12:30.188]                     }
[16:12:30.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.188]                     base::options(mc.cores = 1L)
[16:12:30.188]                   }
[16:12:30.188]                   options(future.plan = NULL)
[16:12:30.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.188]                 }
[16:12:30.188]                 ...future.workdir <- getwd()
[16:12:30.188]             }
[16:12:30.188]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.188]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.188]         }
[16:12:30.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.188]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.188]             base::names(...future.oldOptions))
[16:12:30.188]     }
[16:12:30.188]     if (FALSE) {
[16:12:30.188]     }
[16:12:30.188]     else {
[16:12:30.188]         if (TRUE) {
[16:12:30.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.188]                 open = "w")
[16:12:30.188]         }
[16:12:30.188]         else {
[16:12:30.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.188]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.188]         }
[16:12:30.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.188]             base::sink(type = "output", split = FALSE)
[16:12:30.188]             base::close(...future.stdout)
[16:12:30.188]         }, add = TRUE)
[16:12:30.188]     }
[16:12:30.188]     ...future.frame <- base::sys.nframe()
[16:12:30.188]     ...future.conditions <- base::list()
[16:12:30.188]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.188]     if (FALSE) {
[16:12:30.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.188]     }
[16:12:30.188]     ...future.result <- base::tryCatch({
[16:12:30.188]         base::withCallingHandlers({
[16:12:30.188]             ...future.value <- base::withVisible(base::local({
[16:12:30.188]                 ...future.makeSendCondition <- local({
[16:12:30.188]                   sendCondition <- NULL
[16:12:30.188]                   function(frame = 1L) {
[16:12:30.188]                     if (is.function(sendCondition)) 
[16:12:30.188]                       return(sendCondition)
[16:12:30.188]                     ns <- getNamespace("parallel")
[16:12:30.188]                     if (exists("sendData", mode = "function", 
[16:12:30.188]                       envir = ns)) {
[16:12:30.188]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:30.188]                         envir = ns)
[16:12:30.188]                       envir <- sys.frame(frame)
[16:12:30.188]                       master <- NULL
[16:12:30.188]                       while (!identical(envir, .GlobalEnv) && 
[16:12:30.188]                         !identical(envir, emptyenv())) {
[16:12:30.188]                         if (exists("master", mode = "list", envir = envir, 
[16:12:30.188]                           inherits = FALSE)) {
[16:12:30.188]                           master <- get("master", mode = "list", 
[16:12:30.188]                             envir = envir, inherits = FALSE)
[16:12:30.188]                           if (inherits(master, c("SOCKnode", 
[16:12:30.188]                             "SOCK0node"))) {
[16:12:30.188]                             sendCondition <<- function(cond) {
[16:12:30.188]                               data <- list(type = "VALUE", value = cond, 
[16:12:30.188]                                 success = TRUE)
[16:12:30.188]                               parallel_sendData(master, data)
[16:12:30.188]                             }
[16:12:30.188]                             return(sendCondition)
[16:12:30.188]                           }
[16:12:30.188]                         }
[16:12:30.188]                         frame <- frame + 1L
[16:12:30.188]                         envir <- sys.frame(frame)
[16:12:30.188]                       }
[16:12:30.188]                     }
[16:12:30.188]                     sendCondition <<- function(cond) NULL
[16:12:30.188]                   }
[16:12:30.188]                 })
[16:12:30.188]                 withCallingHandlers({
[16:12:30.188]                   2
[16:12:30.188]                 }, immediateCondition = function(cond) {
[16:12:30.188]                   sendCondition <- ...future.makeSendCondition()
[16:12:30.188]                   sendCondition(cond)
[16:12:30.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.188]                   {
[16:12:30.188]                     inherits <- base::inherits
[16:12:30.188]                     invokeRestart <- base::invokeRestart
[16:12:30.188]                     is.null <- base::is.null
[16:12:30.188]                     muffled <- FALSE
[16:12:30.188]                     if (inherits(cond, "message")) {
[16:12:30.188]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.188]                       if (muffled) 
[16:12:30.188]                         invokeRestart("muffleMessage")
[16:12:30.188]                     }
[16:12:30.188]                     else if (inherits(cond, "warning")) {
[16:12:30.188]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.188]                       if (muffled) 
[16:12:30.188]                         invokeRestart("muffleWarning")
[16:12:30.188]                     }
[16:12:30.188]                     else if (inherits(cond, "condition")) {
[16:12:30.188]                       if (!is.null(pattern)) {
[16:12:30.188]                         computeRestarts <- base::computeRestarts
[16:12:30.188]                         grepl <- base::grepl
[16:12:30.188]                         restarts <- computeRestarts(cond)
[16:12:30.188]                         for (restart in restarts) {
[16:12:30.188]                           name <- restart$name
[16:12:30.188]                           if (is.null(name)) 
[16:12:30.188]                             next
[16:12:30.188]                           if (!grepl(pattern, name)) 
[16:12:30.188]                             next
[16:12:30.188]                           invokeRestart(restart)
[16:12:30.188]                           muffled <- TRUE
[16:12:30.188]                           break
[16:12:30.188]                         }
[16:12:30.188]                       }
[16:12:30.188]                     }
[16:12:30.188]                     invisible(muffled)
[16:12:30.188]                   }
[16:12:30.188]                   muffleCondition(cond)
[16:12:30.188]                 })
[16:12:30.188]             }))
[16:12:30.188]             future::FutureResult(value = ...future.value$value, 
[16:12:30.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.188]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.188]                     ...future.globalenv.names))
[16:12:30.188]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.188]         }, condition = base::local({
[16:12:30.188]             c <- base::c
[16:12:30.188]             inherits <- base::inherits
[16:12:30.188]             invokeRestart <- base::invokeRestart
[16:12:30.188]             length <- base::length
[16:12:30.188]             list <- base::list
[16:12:30.188]             seq.int <- base::seq.int
[16:12:30.188]             signalCondition <- base::signalCondition
[16:12:30.188]             sys.calls <- base::sys.calls
[16:12:30.188]             `[[` <- base::`[[`
[16:12:30.188]             `+` <- base::`+`
[16:12:30.188]             `<<-` <- base::`<<-`
[16:12:30.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.188]                   3L)]
[16:12:30.188]             }
[16:12:30.188]             function(cond) {
[16:12:30.188]                 is_error <- inherits(cond, "error")
[16:12:30.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.188]                   NULL)
[16:12:30.188]                 if (is_error) {
[16:12:30.188]                   sessionInformation <- function() {
[16:12:30.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.188]                       search = base::search(), system = base::Sys.info())
[16:12:30.188]                   }
[16:12:30.188]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.188]                     cond$call), session = sessionInformation(), 
[16:12:30.188]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.188]                   signalCondition(cond)
[16:12:30.188]                 }
[16:12:30.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.188]                 "immediateCondition"))) {
[16:12:30.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.188]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.188]                   if (TRUE && !signal) {
[16:12:30.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.188]                     {
[16:12:30.188]                       inherits <- base::inherits
[16:12:30.188]                       invokeRestart <- base::invokeRestart
[16:12:30.188]                       is.null <- base::is.null
[16:12:30.188]                       muffled <- FALSE
[16:12:30.188]                       if (inherits(cond, "message")) {
[16:12:30.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.188]                         if (muffled) 
[16:12:30.188]                           invokeRestart("muffleMessage")
[16:12:30.188]                       }
[16:12:30.188]                       else if (inherits(cond, "warning")) {
[16:12:30.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.188]                         if (muffled) 
[16:12:30.188]                           invokeRestart("muffleWarning")
[16:12:30.188]                       }
[16:12:30.188]                       else if (inherits(cond, "condition")) {
[16:12:30.188]                         if (!is.null(pattern)) {
[16:12:30.188]                           computeRestarts <- base::computeRestarts
[16:12:30.188]                           grepl <- base::grepl
[16:12:30.188]                           restarts <- computeRestarts(cond)
[16:12:30.188]                           for (restart in restarts) {
[16:12:30.188]                             name <- restart$name
[16:12:30.188]                             if (is.null(name)) 
[16:12:30.188]                               next
[16:12:30.188]                             if (!grepl(pattern, name)) 
[16:12:30.188]                               next
[16:12:30.188]                             invokeRestart(restart)
[16:12:30.188]                             muffled <- TRUE
[16:12:30.188]                             break
[16:12:30.188]                           }
[16:12:30.188]                         }
[16:12:30.188]                       }
[16:12:30.188]                       invisible(muffled)
[16:12:30.188]                     }
[16:12:30.188]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.188]                   }
[16:12:30.188]                 }
[16:12:30.188]                 else {
[16:12:30.188]                   if (TRUE) {
[16:12:30.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.188]                     {
[16:12:30.188]                       inherits <- base::inherits
[16:12:30.188]                       invokeRestart <- base::invokeRestart
[16:12:30.188]                       is.null <- base::is.null
[16:12:30.188]                       muffled <- FALSE
[16:12:30.188]                       if (inherits(cond, "message")) {
[16:12:30.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.188]                         if (muffled) 
[16:12:30.188]                           invokeRestart("muffleMessage")
[16:12:30.188]                       }
[16:12:30.188]                       else if (inherits(cond, "warning")) {
[16:12:30.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.188]                         if (muffled) 
[16:12:30.188]                           invokeRestart("muffleWarning")
[16:12:30.188]                       }
[16:12:30.188]                       else if (inherits(cond, "condition")) {
[16:12:30.188]                         if (!is.null(pattern)) {
[16:12:30.188]                           computeRestarts <- base::computeRestarts
[16:12:30.188]                           grepl <- base::grepl
[16:12:30.188]                           restarts <- computeRestarts(cond)
[16:12:30.188]                           for (restart in restarts) {
[16:12:30.188]                             name <- restart$name
[16:12:30.188]                             if (is.null(name)) 
[16:12:30.188]                               next
[16:12:30.188]                             if (!grepl(pattern, name)) 
[16:12:30.188]                               next
[16:12:30.188]                             invokeRestart(restart)
[16:12:30.188]                             muffled <- TRUE
[16:12:30.188]                             break
[16:12:30.188]                           }
[16:12:30.188]                         }
[16:12:30.188]                       }
[16:12:30.188]                       invisible(muffled)
[16:12:30.188]                     }
[16:12:30.188]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.188]                   }
[16:12:30.188]                 }
[16:12:30.188]             }
[16:12:30.188]         }))
[16:12:30.188]     }, error = function(ex) {
[16:12:30.188]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.188]                 ...future.rng), started = ...future.startTime, 
[16:12:30.188]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.188]             version = "1.8"), class = "FutureResult")
[16:12:30.188]     }, finally = {
[16:12:30.188]         if (!identical(...future.workdir, getwd())) 
[16:12:30.188]             setwd(...future.workdir)
[16:12:30.188]         {
[16:12:30.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.188]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.188]             }
[16:12:30.188]             base::options(...future.oldOptions)
[16:12:30.188]             if (.Platform$OS.type == "windows") {
[16:12:30.188]                 old_names <- names(...future.oldEnvVars)
[16:12:30.188]                 envs <- base::Sys.getenv()
[16:12:30.188]                 names <- names(envs)
[16:12:30.188]                 common <- intersect(names, old_names)
[16:12:30.188]                 added <- setdiff(names, old_names)
[16:12:30.188]                 removed <- setdiff(old_names, names)
[16:12:30.188]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.188]                   envs[common]]
[16:12:30.188]                 NAMES <- toupper(changed)
[16:12:30.188]                 args <- list()
[16:12:30.188]                 for (kk in seq_along(NAMES)) {
[16:12:30.188]                   name <- changed[[kk]]
[16:12:30.188]                   NAME <- NAMES[[kk]]
[16:12:30.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.188]                     next
[16:12:30.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.188]                 }
[16:12:30.188]                 NAMES <- toupper(added)
[16:12:30.188]                 for (kk in seq_along(NAMES)) {
[16:12:30.188]                   name <- added[[kk]]
[16:12:30.188]                   NAME <- NAMES[[kk]]
[16:12:30.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.188]                     next
[16:12:30.188]                   args[[name]] <- ""
[16:12:30.188]                 }
[16:12:30.188]                 NAMES <- toupper(removed)
[16:12:30.188]                 for (kk in seq_along(NAMES)) {
[16:12:30.188]                   name <- removed[[kk]]
[16:12:30.188]                   NAME <- NAMES[[kk]]
[16:12:30.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.188]                     next
[16:12:30.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.188]                 }
[16:12:30.188]                 if (length(args) > 0) 
[16:12:30.188]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.188]             }
[16:12:30.188]             else {
[16:12:30.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.188]             }
[16:12:30.188]             {
[16:12:30.188]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.188]                   0L) {
[16:12:30.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.188]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.188]                   base::options(opts)
[16:12:30.188]                 }
[16:12:30.188]                 {
[16:12:30.188]                   {
[16:12:30.188]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.188]                     NULL
[16:12:30.188]                   }
[16:12:30.188]                   options(future.plan = NULL)
[16:12:30.188]                   if (is.na(NA_character_)) 
[16:12:30.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.188]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:30.188]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:30.188]                     envir = parent.frame()) 
[16:12:30.188]                   {
[16:12:30.188]                     if (is.function(workers)) 
[16:12:30.188]                       workers <- workers()
[16:12:30.188]                     workers <- structure(as.integer(workers), 
[16:12:30.188]                       class = class(workers))
[16:12:30.188]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:30.188]                       workers >= 1)
[16:12:30.188]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:30.188]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:30.188]                     }
[16:12:30.188]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:30.188]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:30.188]                       envir = envir)
[16:12:30.188]                     if (!future$lazy) 
[16:12:30.188]                       future <- run(future)
[16:12:30.188]                     invisible(future)
[16:12:30.188]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.188]                 }
[16:12:30.188]             }
[16:12:30.188]         }
[16:12:30.188]     })
[16:12:30.188]     if (TRUE) {
[16:12:30.188]         base::sink(type = "output", split = FALSE)
[16:12:30.188]         if (TRUE) {
[16:12:30.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.188]         }
[16:12:30.188]         else {
[16:12:30.188]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.188]         }
[16:12:30.188]         base::close(...future.stdout)
[16:12:30.188]         ...future.stdout <- NULL
[16:12:30.188]     }
[16:12:30.188]     ...future.result$conditions <- ...future.conditions
[16:12:30.188]     ...future.result$finished <- base::Sys.time()
[16:12:30.188]     ...future.result
[16:12:30.188] }
[16:12:30.191] MultisessionFuture started
[16:12:30.191] - Launch lazy future ... done
[16:12:30.191] run() for ‘MultisessionFuture’ ... done
[16:12:30.192] getGlobalsAndPackages() ...
[16:12:30.192] Searching for globals...
[16:12:30.192] 
[16:12:30.192] Searching for globals ... DONE
[16:12:30.192] - globals: [0] <none>
[16:12:30.192] getGlobalsAndPackages() ... DONE
[16:12:30.193] run() for ‘Future’ ...
[16:12:30.193] - state: ‘created’
[16:12:30.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:30.207]   - Field: ‘node’
[16:12:30.207]   - Field: ‘label’
[16:12:30.208]   - Field: ‘local’
[16:12:30.208]   - Field: ‘owner’
[16:12:30.208]   - Field: ‘envir’
[16:12:30.208]   - Field: ‘workers’
[16:12:30.208]   - Field: ‘packages’
[16:12:30.208]   - Field: ‘gc’
[16:12:30.208]   - Field: ‘conditions’
[16:12:30.208]   - Field: ‘persistent’
[16:12:30.208]   - Field: ‘expr’
[16:12:30.208]   - Field: ‘uuid’
[16:12:30.209]   - Field: ‘seed’
[16:12:30.209]   - Field: ‘version’
[16:12:30.209]   - Field: ‘result’
[16:12:30.209]   - Field: ‘asynchronous’
[16:12:30.209]   - Field: ‘calls’
[16:12:30.209]   - Field: ‘globals’
[16:12:30.209]   - Field: ‘stdout’
[16:12:30.209]   - Field: ‘earlySignal’
[16:12:30.209]   - Field: ‘lazy’
[16:12:30.209]   - Field: ‘state’
[16:12:30.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:30.210] - Launch lazy future ...
[16:12:30.210] Packages needed by the future expression (n = 0): <none>
[16:12:30.210] Packages needed by future strategies (n = 0): <none>
[16:12:30.210] {
[16:12:30.210]     {
[16:12:30.210]         {
[16:12:30.210]             ...future.startTime <- base::Sys.time()
[16:12:30.210]             {
[16:12:30.210]                 {
[16:12:30.210]                   {
[16:12:30.210]                     {
[16:12:30.210]                       base::local({
[16:12:30.210]                         has_future <- base::requireNamespace("future", 
[16:12:30.210]                           quietly = TRUE)
[16:12:30.210]                         if (has_future) {
[16:12:30.210]                           ns <- base::getNamespace("future")
[16:12:30.210]                           version <- ns[[".package"]][["version"]]
[16:12:30.210]                           if (is.null(version)) 
[16:12:30.210]                             version <- utils::packageVersion("future")
[16:12:30.210]                         }
[16:12:30.210]                         else {
[16:12:30.210]                           version <- NULL
[16:12:30.210]                         }
[16:12:30.210]                         if (!has_future || version < "1.8.0") {
[16:12:30.210]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.210]                             "", base::R.version$version.string), 
[16:12:30.210]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.210]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.210]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.210]                               "release", "version")], collapse = " "), 
[16:12:30.210]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.210]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.210]                             info)
[16:12:30.210]                           info <- base::paste(info, collapse = "; ")
[16:12:30.210]                           if (!has_future) {
[16:12:30.210]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.210]                               info)
[16:12:30.210]                           }
[16:12:30.210]                           else {
[16:12:30.210]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.210]                               info, version)
[16:12:30.210]                           }
[16:12:30.210]                           base::stop(msg)
[16:12:30.210]                         }
[16:12:30.210]                       })
[16:12:30.210]                     }
[16:12:30.210]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.210]                     base::options(mc.cores = 1L)
[16:12:30.210]                   }
[16:12:30.210]                   options(future.plan = NULL)
[16:12:30.210]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.210]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.210]                 }
[16:12:30.210]                 ...future.workdir <- getwd()
[16:12:30.210]             }
[16:12:30.210]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.210]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.210]         }
[16:12:30.210]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.210]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.210]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.210]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.210]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.210]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.210]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.210]             base::names(...future.oldOptions))
[16:12:30.210]     }
[16:12:30.210]     if (FALSE) {
[16:12:30.210]     }
[16:12:30.210]     else {
[16:12:30.210]         if (TRUE) {
[16:12:30.210]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.210]                 open = "w")
[16:12:30.210]         }
[16:12:30.210]         else {
[16:12:30.210]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.210]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.210]         }
[16:12:30.210]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.210]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.210]             base::sink(type = "output", split = FALSE)
[16:12:30.210]             base::close(...future.stdout)
[16:12:30.210]         }, add = TRUE)
[16:12:30.210]     }
[16:12:30.210]     ...future.frame <- base::sys.nframe()
[16:12:30.210]     ...future.conditions <- base::list()
[16:12:30.210]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.210]     if (FALSE) {
[16:12:30.210]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.210]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.210]     }
[16:12:30.210]     ...future.result <- base::tryCatch({
[16:12:30.210]         base::withCallingHandlers({
[16:12:30.210]             ...future.value <- base::withVisible(base::local({
[16:12:30.210]                 ...future.makeSendCondition <- local({
[16:12:30.210]                   sendCondition <- NULL
[16:12:30.210]                   function(frame = 1L) {
[16:12:30.210]                     if (is.function(sendCondition)) 
[16:12:30.210]                       return(sendCondition)
[16:12:30.210]                     ns <- getNamespace("parallel")
[16:12:30.210]                     if (exists("sendData", mode = "function", 
[16:12:30.210]                       envir = ns)) {
[16:12:30.210]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:30.210]                         envir = ns)
[16:12:30.210]                       envir <- sys.frame(frame)
[16:12:30.210]                       master <- NULL
[16:12:30.210]                       while (!identical(envir, .GlobalEnv) && 
[16:12:30.210]                         !identical(envir, emptyenv())) {
[16:12:30.210]                         if (exists("master", mode = "list", envir = envir, 
[16:12:30.210]                           inherits = FALSE)) {
[16:12:30.210]                           master <- get("master", mode = "list", 
[16:12:30.210]                             envir = envir, inherits = FALSE)
[16:12:30.210]                           if (inherits(master, c("SOCKnode", 
[16:12:30.210]                             "SOCK0node"))) {
[16:12:30.210]                             sendCondition <<- function(cond) {
[16:12:30.210]                               data <- list(type = "VALUE", value = cond, 
[16:12:30.210]                                 success = TRUE)
[16:12:30.210]                               parallel_sendData(master, data)
[16:12:30.210]                             }
[16:12:30.210]                             return(sendCondition)
[16:12:30.210]                           }
[16:12:30.210]                         }
[16:12:30.210]                         frame <- frame + 1L
[16:12:30.210]                         envir <- sys.frame(frame)
[16:12:30.210]                       }
[16:12:30.210]                     }
[16:12:30.210]                     sendCondition <<- function(cond) NULL
[16:12:30.210]                   }
[16:12:30.210]                 })
[16:12:30.210]                 withCallingHandlers({
[16:12:30.210]                   NULL
[16:12:30.210]                 }, immediateCondition = function(cond) {
[16:12:30.210]                   sendCondition <- ...future.makeSendCondition()
[16:12:30.210]                   sendCondition(cond)
[16:12:30.210]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.210]                   {
[16:12:30.210]                     inherits <- base::inherits
[16:12:30.210]                     invokeRestart <- base::invokeRestart
[16:12:30.210]                     is.null <- base::is.null
[16:12:30.210]                     muffled <- FALSE
[16:12:30.210]                     if (inherits(cond, "message")) {
[16:12:30.210]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.210]                       if (muffled) 
[16:12:30.210]                         invokeRestart("muffleMessage")
[16:12:30.210]                     }
[16:12:30.210]                     else if (inherits(cond, "warning")) {
[16:12:30.210]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.210]                       if (muffled) 
[16:12:30.210]                         invokeRestart("muffleWarning")
[16:12:30.210]                     }
[16:12:30.210]                     else if (inherits(cond, "condition")) {
[16:12:30.210]                       if (!is.null(pattern)) {
[16:12:30.210]                         computeRestarts <- base::computeRestarts
[16:12:30.210]                         grepl <- base::grepl
[16:12:30.210]                         restarts <- computeRestarts(cond)
[16:12:30.210]                         for (restart in restarts) {
[16:12:30.210]                           name <- restart$name
[16:12:30.210]                           if (is.null(name)) 
[16:12:30.210]                             next
[16:12:30.210]                           if (!grepl(pattern, name)) 
[16:12:30.210]                             next
[16:12:30.210]                           invokeRestart(restart)
[16:12:30.210]                           muffled <- TRUE
[16:12:30.210]                           break
[16:12:30.210]                         }
[16:12:30.210]                       }
[16:12:30.210]                     }
[16:12:30.210]                     invisible(muffled)
[16:12:30.210]                   }
[16:12:30.210]                   muffleCondition(cond)
[16:12:30.210]                 })
[16:12:30.210]             }))
[16:12:30.210]             future::FutureResult(value = ...future.value$value, 
[16:12:30.210]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.210]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.210]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.210]                     ...future.globalenv.names))
[16:12:30.210]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.210]         }, condition = base::local({
[16:12:30.210]             c <- base::c
[16:12:30.210]             inherits <- base::inherits
[16:12:30.210]             invokeRestart <- base::invokeRestart
[16:12:30.210]             length <- base::length
[16:12:30.210]             list <- base::list
[16:12:30.210]             seq.int <- base::seq.int
[16:12:30.210]             signalCondition <- base::signalCondition
[16:12:30.210]             sys.calls <- base::sys.calls
[16:12:30.210]             `[[` <- base::`[[`
[16:12:30.210]             `+` <- base::`+`
[16:12:30.210]             `<<-` <- base::`<<-`
[16:12:30.210]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.210]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.210]                   3L)]
[16:12:30.210]             }
[16:12:30.210]             function(cond) {
[16:12:30.210]                 is_error <- inherits(cond, "error")
[16:12:30.210]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.210]                   NULL)
[16:12:30.210]                 if (is_error) {
[16:12:30.210]                   sessionInformation <- function() {
[16:12:30.210]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.210]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.210]                       search = base::search(), system = base::Sys.info())
[16:12:30.210]                   }
[16:12:30.210]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.210]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.210]                     cond$call), session = sessionInformation(), 
[16:12:30.210]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.210]                   signalCondition(cond)
[16:12:30.210]                 }
[16:12:30.210]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.210]                 "immediateCondition"))) {
[16:12:30.210]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.210]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.210]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.210]                   if (TRUE && !signal) {
[16:12:30.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.210]                     {
[16:12:30.210]                       inherits <- base::inherits
[16:12:30.210]                       invokeRestart <- base::invokeRestart
[16:12:30.210]                       is.null <- base::is.null
[16:12:30.210]                       muffled <- FALSE
[16:12:30.210]                       if (inherits(cond, "message")) {
[16:12:30.210]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.210]                         if (muffled) 
[16:12:30.210]                           invokeRestart("muffleMessage")
[16:12:30.210]                       }
[16:12:30.210]                       else if (inherits(cond, "warning")) {
[16:12:30.210]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.210]                         if (muffled) 
[16:12:30.210]                           invokeRestart("muffleWarning")
[16:12:30.210]                       }
[16:12:30.210]                       else if (inherits(cond, "condition")) {
[16:12:30.210]                         if (!is.null(pattern)) {
[16:12:30.210]                           computeRestarts <- base::computeRestarts
[16:12:30.210]                           grepl <- base::grepl
[16:12:30.210]                           restarts <- computeRestarts(cond)
[16:12:30.210]                           for (restart in restarts) {
[16:12:30.210]                             name <- restart$name
[16:12:30.210]                             if (is.null(name)) 
[16:12:30.210]                               next
[16:12:30.210]                             if (!grepl(pattern, name)) 
[16:12:30.210]                               next
[16:12:30.210]                             invokeRestart(restart)
[16:12:30.210]                             muffled <- TRUE
[16:12:30.210]                             break
[16:12:30.210]                           }
[16:12:30.210]                         }
[16:12:30.210]                       }
[16:12:30.210]                       invisible(muffled)
[16:12:30.210]                     }
[16:12:30.210]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.210]                   }
[16:12:30.210]                 }
[16:12:30.210]                 else {
[16:12:30.210]                   if (TRUE) {
[16:12:30.210]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.210]                     {
[16:12:30.210]                       inherits <- base::inherits
[16:12:30.210]                       invokeRestart <- base::invokeRestart
[16:12:30.210]                       is.null <- base::is.null
[16:12:30.210]                       muffled <- FALSE
[16:12:30.210]                       if (inherits(cond, "message")) {
[16:12:30.210]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.210]                         if (muffled) 
[16:12:30.210]                           invokeRestart("muffleMessage")
[16:12:30.210]                       }
[16:12:30.210]                       else if (inherits(cond, "warning")) {
[16:12:30.210]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.210]                         if (muffled) 
[16:12:30.210]                           invokeRestart("muffleWarning")
[16:12:30.210]                       }
[16:12:30.210]                       else if (inherits(cond, "condition")) {
[16:12:30.210]                         if (!is.null(pattern)) {
[16:12:30.210]                           computeRestarts <- base::computeRestarts
[16:12:30.210]                           grepl <- base::grepl
[16:12:30.210]                           restarts <- computeRestarts(cond)
[16:12:30.210]                           for (restart in restarts) {
[16:12:30.210]                             name <- restart$name
[16:12:30.210]                             if (is.null(name)) 
[16:12:30.210]                               next
[16:12:30.210]                             if (!grepl(pattern, name)) 
[16:12:30.210]                               next
[16:12:30.210]                             invokeRestart(restart)
[16:12:30.210]                             muffled <- TRUE
[16:12:30.210]                             break
[16:12:30.210]                           }
[16:12:30.210]                         }
[16:12:30.210]                       }
[16:12:30.210]                       invisible(muffled)
[16:12:30.210]                     }
[16:12:30.210]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.210]                   }
[16:12:30.210]                 }
[16:12:30.210]             }
[16:12:30.210]         }))
[16:12:30.210]     }, error = function(ex) {
[16:12:30.210]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.210]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.210]                 ...future.rng), started = ...future.startTime, 
[16:12:30.210]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.210]             version = "1.8"), class = "FutureResult")
[16:12:30.210]     }, finally = {
[16:12:30.210]         if (!identical(...future.workdir, getwd())) 
[16:12:30.210]             setwd(...future.workdir)
[16:12:30.210]         {
[16:12:30.210]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.210]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.210]             }
[16:12:30.210]             base::options(...future.oldOptions)
[16:12:30.210]             if (.Platform$OS.type == "windows") {
[16:12:30.210]                 old_names <- names(...future.oldEnvVars)
[16:12:30.210]                 envs <- base::Sys.getenv()
[16:12:30.210]                 names <- names(envs)
[16:12:30.210]                 common <- intersect(names, old_names)
[16:12:30.210]                 added <- setdiff(names, old_names)
[16:12:30.210]                 removed <- setdiff(old_names, names)
[16:12:30.210]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.210]                   envs[common]]
[16:12:30.210]                 NAMES <- toupper(changed)
[16:12:30.210]                 args <- list()
[16:12:30.210]                 for (kk in seq_along(NAMES)) {
[16:12:30.210]                   name <- changed[[kk]]
[16:12:30.210]                   NAME <- NAMES[[kk]]
[16:12:30.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.210]                     next
[16:12:30.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.210]                 }
[16:12:30.210]                 NAMES <- toupper(added)
[16:12:30.210]                 for (kk in seq_along(NAMES)) {
[16:12:30.210]                   name <- added[[kk]]
[16:12:30.210]                   NAME <- NAMES[[kk]]
[16:12:30.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.210]                     next
[16:12:30.210]                   args[[name]] <- ""
[16:12:30.210]                 }
[16:12:30.210]                 NAMES <- toupper(removed)
[16:12:30.210]                 for (kk in seq_along(NAMES)) {
[16:12:30.210]                   name <- removed[[kk]]
[16:12:30.210]                   NAME <- NAMES[[kk]]
[16:12:30.210]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.210]                     next
[16:12:30.210]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.210]                 }
[16:12:30.210]                 if (length(args) > 0) 
[16:12:30.210]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.210]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.210]             }
[16:12:30.210]             else {
[16:12:30.210]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.210]             }
[16:12:30.210]             {
[16:12:30.210]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.210]                   0L) {
[16:12:30.210]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.210]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.210]                   base::options(opts)
[16:12:30.210]                 }
[16:12:30.210]                 {
[16:12:30.210]                   {
[16:12:30.210]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.210]                     NULL
[16:12:30.210]                   }
[16:12:30.210]                   options(future.plan = NULL)
[16:12:30.210]                   if (is.na(NA_character_)) 
[16:12:30.210]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.210]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.210]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:30.210]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:30.210]                     envir = parent.frame()) 
[16:12:30.210]                   {
[16:12:30.210]                     if (is.function(workers)) 
[16:12:30.210]                       workers <- workers()
[16:12:30.210]                     workers <- structure(as.integer(workers), 
[16:12:30.210]                       class = class(workers))
[16:12:30.210]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:30.210]                       workers >= 1)
[16:12:30.210]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:30.210]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:30.210]                     }
[16:12:30.210]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:30.210]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:30.210]                       envir = envir)
[16:12:30.210]                     if (!future$lazy) 
[16:12:30.210]                       future <- run(future)
[16:12:30.210]                     invisible(future)
[16:12:30.210]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.210]                 }
[16:12:30.210]             }
[16:12:30.210]         }
[16:12:30.210]     })
[16:12:30.210]     if (TRUE) {
[16:12:30.210]         base::sink(type = "output", split = FALSE)
[16:12:30.210]         if (TRUE) {
[16:12:30.210]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.210]         }
[16:12:30.210]         else {
[16:12:30.210]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.210]         }
[16:12:30.210]         base::close(...future.stdout)
[16:12:30.210]         ...future.stdout <- NULL
[16:12:30.210]     }
[16:12:30.210]     ...future.result$conditions <- ...future.conditions
[16:12:30.210]     ...future.result$finished <- base::Sys.time()
[16:12:30.210]     ...future.result
[16:12:30.210] }
[16:12:30.214] MultisessionFuture started
[16:12:30.214] - Launch lazy future ... done
[16:12:30.214] run() for ‘MultisessionFuture’ ... done
[16:12:30.214] getGlobalsAndPackages() ...
[16:12:30.214] Searching for globals...
[16:12:30.215] - globals found: [1] ‘{’
[16:12:30.215] Searching for globals ... DONE
[16:12:30.215] Resolving globals: FALSE
[16:12:30.215] 
[16:12:30.215] 
[16:12:30.216] getGlobalsAndPackages() ... DONE
[16:12:30.216] run() for ‘Future’ ...
[16:12:30.216] - state: ‘created’
[16:12:30.216] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.231] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:30.231]   - Field: ‘node’
[16:12:30.231]   - Field: ‘label’
[16:12:30.231]   - Field: ‘local’
[16:12:30.231]   - Field: ‘owner’
[16:12:30.231]   - Field: ‘envir’
[16:12:30.231]   - Field: ‘workers’
[16:12:30.232]   - Field: ‘packages’
[16:12:30.232]   - Field: ‘gc’
[16:12:30.232]   - Field: ‘conditions’
[16:12:30.232]   - Field: ‘persistent’
[16:12:30.232]   - Field: ‘expr’
[16:12:30.232]   - Field: ‘uuid’
[16:12:30.232]   - Field: ‘seed’
[16:12:30.232]   - Field: ‘version’
[16:12:30.232]   - Field: ‘result’
[16:12:30.232]   - Field: ‘asynchronous’
[16:12:30.233]   - Field: ‘calls’
[16:12:30.233]   - Field: ‘globals’
[16:12:30.233]   - Field: ‘stdout’
[16:12:30.233]   - Field: ‘earlySignal’
[16:12:30.233]   - Field: ‘lazy’
[16:12:30.233]   - Field: ‘state’
[16:12:30.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:30.233] - Launch lazy future ...
[16:12:30.233] Packages needed by the future expression (n = 0): <none>
[16:12:30.234] Packages needed by future strategies (n = 0): <none>
[16:12:30.234] {
[16:12:30.234]     {
[16:12:30.234]         {
[16:12:30.234]             ...future.startTime <- base::Sys.time()
[16:12:30.234]             {
[16:12:30.234]                 {
[16:12:30.234]                   {
[16:12:30.234]                     {
[16:12:30.234]                       base::local({
[16:12:30.234]                         has_future <- base::requireNamespace("future", 
[16:12:30.234]                           quietly = TRUE)
[16:12:30.234]                         if (has_future) {
[16:12:30.234]                           ns <- base::getNamespace("future")
[16:12:30.234]                           version <- ns[[".package"]][["version"]]
[16:12:30.234]                           if (is.null(version)) 
[16:12:30.234]                             version <- utils::packageVersion("future")
[16:12:30.234]                         }
[16:12:30.234]                         else {
[16:12:30.234]                           version <- NULL
[16:12:30.234]                         }
[16:12:30.234]                         if (!has_future || version < "1.8.0") {
[16:12:30.234]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.234]                             "", base::R.version$version.string), 
[16:12:30.234]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.234]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.234]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.234]                               "release", "version")], collapse = " "), 
[16:12:30.234]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.234]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.234]                             info)
[16:12:30.234]                           info <- base::paste(info, collapse = "; ")
[16:12:30.234]                           if (!has_future) {
[16:12:30.234]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.234]                               info)
[16:12:30.234]                           }
[16:12:30.234]                           else {
[16:12:30.234]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.234]                               info, version)
[16:12:30.234]                           }
[16:12:30.234]                           base::stop(msg)
[16:12:30.234]                         }
[16:12:30.234]                       })
[16:12:30.234]                     }
[16:12:30.234]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.234]                     base::options(mc.cores = 1L)
[16:12:30.234]                   }
[16:12:30.234]                   options(future.plan = NULL)
[16:12:30.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.234]                 }
[16:12:30.234]                 ...future.workdir <- getwd()
[16:12:30.234]             }
[16:12:30.234]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.234]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.234]         }
[16:12:30.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.234]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.234]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.234]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.234]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.234]             base::names(...future.oldOptions))
[16:12:30.234]     }
[16:12:30.234]     if (FALSE) {
[16:12:30.234]     }
[16:12:30.234]     else {
[16:12:30.234]         if (TRUE) {
[16:12:30.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.234]                 open = "w")
[16:12:30.234]         }
[16:12:30.234]         else {
[16:12:30.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.234]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.234]         }
[16:12:30.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.234]             base::sink(type = "output", split = FALSE)
[16:12:30.234]             base::close(...future.stdout)
[16:12:30.234]         }, add = TRUE)
[16:12:30.234]     }
[16:12:30.234]     ...future.frame <- base::sys.nframe()
[16:12:30.234]     ...future.conditions <- base::list()
[16:12:30.234]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.234]     if (FALSE) {
[16:12:30.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.234]     }
[16:12:30.234]     ...future.result <- base::tryCatch({
[16:12:30.234]         base::withCallingHandlers({
[16:12:30.234]             ...future.value <- base::withVisible(base::local({
[16:12:30.234]                 ...future.makeSendCondition <- local({
[16:12:30.234]                   sendCondition <- NULL
[16:12:30.234]                   function(frame = 1L) {
[16:12:30.234]                     if (is.function(sendCondition)) 
[16:12:30.234]                       return(sendCondition)
[16:12:30.234]                     ns <- getNamespace("parallel")
[16:12:30.234]                     if (exists("sendData", mode = "function", 
[16:12:30.234]                       envir = ns)) {
[16:12:30.234]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:30.234]                         envir = ns)
[16:12:30.234]                       envir <- sys.frame(frame)
[16:12:30.234]                       master <- NULL
[16:12:30.234]                       while (!identical(envir, .GlobalEnv) && 
[16:12:30.234]                         !identical(envir, emptyenv())) {
[16:12:30.234]                         if (exists("master", mode = "list", envir = envir, 
[16:12:30.234]                           inherits = FALSE)) {
[16:12:30.234]                           master <- get("master", mode = "list", 
[16:12:30.234]                             envir = envir, inherits = FALSE)
[16:12:30.234]                           if (inherits(master, c("SOCKnode", 
[16:12:30.234]                             "SOCK0node"))) {
[16:12:30.234]                             sendCondition <<- function(cond) {
[16:12:30.234]                               data <- list(type = "VALUE", value = cond, 
[16:12:30.234]                                 success = TRUE)
[16:12:30.234]                               parallel_sendData(master, data)
[16:12:30.234]                             }
[16:12:30.234]                             return(sendCondition)
[16:12:30.234]                           }
[16:12:30.234]                         }
[16:12:30.234]                         frame <- frame + 1L
[16:12:30.234]                         envir <- sys.frame(frame)
[16:12:30.234]                       }
[16:12:30.234]                     }
[16:12:30.234]                     sendCondition <<- function(cond) NULL
[16:12:30.234]                   }
[16:12:30.234]                 })
[16:12:30.234]                 withCallingHandlers({
[16:12:30.234]                   {
[16:12:30.234]                     4
[16:12:30.234]                   }
[16:12:30.234]                 }, immediateCondition = function(cond) {
[16:12:30.234]                   sendCondition <- ...future.makeSendCondition()
[16:12:30.234]                   sendCondition(cond)
[16:12:30.234]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.234]                   {
[16:12:30.234]                     inherits <- base::inherits
[16:12:30.234]                     invokeRestart <- base::invokeRestart
[16:12:30.234]                     is.null <- base::is.null
[16:12:30.234]                     muffled <- FALSE
[16:12:30.234]                     if (inherits(cond, "message")) {
[16:12:30.234]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.234]                       if (muffled) 
[16:12:30.234]                         invokeRestart("muffleMessage")
[16:12:30.234]                     }
[16:12:30.234]                     else if (inherits(cond, "warning")) {
[16:12:30.234]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.234]                       if (muffled) 
[16:12:30.234]                         invokeRestart("muffleWarning")
[16:12:30.234]                     }
[16:12:30.234]                     else if (inherits(cond, "condition")) {
[16:12:30.234]                       if (!is.null(pattern)) {
[16:12:30.234]                         computeRestarts <- base::computeRestarts
[16:12:30.234]                         grepl <- base::grepl
[16:12:30.234]                         restarts <- computeRestarts(cond)
[16:12:30.234]                         for (restart in restarts) {
[16:12:30.234]                           name <- restart$name
[16:12:30.234]                           if (is.null(name)) 
[16:12:30.234]                             next
[16:12:30.234]                           if (!grepl(pattern, name)) 
[16:12:30.234]                             next
[16:12:30.234]                           invokeRestart(restart)
[16:12:30.234]                           muffled <- TRUE
[16:12:30.234]                           break
[16:12:30.234]                         }
[16:12:30.234]                       }
[16:12:30.234]                     }
[16:12:30.234]                     invisible(muffled)
[16:12:30.234]                   }
[16:12:30.234]                   muffleCondition(cond)
[16:12:30.234]                 })
[16:12:30.234]             }))
[16:12:30.234]             future::FutureResult(value = ...future.value$value, 
[16:12:30.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.234]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.234]                     ...future.globalenv.names))
[16:12:30.234]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.234]         }, condition = base::local({
[16:12:30.234]             c <- base::c
[16:12:30.234]             inherits <- base::inherits
[16:12:30.234]             invokeRestart <- base::invokeRestart
[16:12:30.234]             length <- base::length
[16:12:30.234]             list <- base::list
[16:12:30.234]             seq.int <- base::seq.int
[16:12:30.234]             signalCondition <- base::signalCondition
[16:12:30.234]             sys.calls <- base::sys.calls
[16:12:30.234]             `[[` <- base::`[[`
[16:12:30.234]             `+` <- base::`+`
[16:12:30.234]             `<<-` <- base::`<<-`
[16:12:30.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.234]                   3L)]
[16:12:30.234]             }
[16:12:30.234]             function(cond) {
[16:12:30.234]                 is_error <- inherits(cond, "error")
[16:12:30.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.234]                   NULL)
[16:12:30.234]                 if (is_error) {
[16:12:30.234]                   sessionInformation <- function() {
[16:12:30.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.234]                       search = base::search(), system = base::Sys.info())
[16:12:30.234]                   }
[16:12:30.234]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.234]                     cond$call), session = sessionInformation(), 
[16:12:30.234]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.234]                   signalCondition(cond)
[16:12:30.234]                 }
[16:12:30.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.234]                 "immediateCondition"))) {
[16:12:30.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.234]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.234]                   if (TRUE && !signal) {
[16:12:30.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.234]                     {
[16:12:30.234]                       inherits <- base::inherits
[16:12:30.234]                       invokeRestart <- base::invokeRestart
[16:12:30.234]                       is.null <- base::is.null
[16:12:30.234]                       muffled <- FALSE
[16:12:30.234]                       if (inherits(cond, "message")) {
[16:12:30.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.234]                         if (muffled) 
[16:12:30.234]                           invokeRestart("muffleMessage")
[16:12:30.234]                       }
[16:12:30.234]                       else if (inherits(cond, "warning")) {
[16:12:30.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.234]                         if (muffled) 
[16:12:30.234]                           invokeRestart("muffleWarning")
[16:12:30.234]                       }
[16:12:30.234]                       else if (inherits(cond, "condition")) {
[16:12:30.234]                         if (!is.null(pattern)) {
[16:12:30.234]                           computeRestarts <- base::computeRestarts
[16:12:30.234]                           grepl <- base::grepl
[16:12:30.234]                           restarts <- computeRestarts(cond)
[16:12:30.234]                           for (restart in restarts) {
[16:12:30.234]                             name <- restart$name
[16:12:30.234]                             if (is.null(name)) 
[16:12:30.234]                               next
[16:12:30.234]                             if (!grepl(pattern, name)) 
[16:12:30.234]                               next
[16:12:30.234]                             invokeRestart(restart)
[16:12:30.234]                             muffled <- TRUE
[16:12:30.234]                             break
[16:12:30.234]                           }
[16:12:30.234]                         }
[16:12:30.234]                       }
[16:12:30.234]                       invisible(muffled)
[16:12:30.234]                     }
[16:12:30.234]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.234]                   }
[16:12:30.234]                 }
[16:12:30.234]                 else {
[16:12:30.234]                   if (TRUE) {
[16:12:30.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.234]                     {
[16:12:30.234]                       inherits <- base::inherits
[16:12:30.234]                       invokeRestart <- base::invokeRestart
[16:12:30.234]                       is.null <- base::is.null
[16:12:30.234]                       muffled <- FALSE
[16:12:30.234]                       if (inherits(cond, "message")) {
[16:12:30.234]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.234]                         if (muffled) 
[16:12:30.234]                           invokeRestart("muffleMessage")
[16:12:30.234]                       }
[16:12:30.234]                       else if (inherits(cond, "warning")) {
[16:12:30.234]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.234]                         if (muffled) 
[16:12:30.234]                           invokeRestart("muffleWarning")
[16:12:30.234]                       }
[16:12:30.234]                       else if (inherits(cond, "condition")) {
[16:12:30.234]                         if (!is.null(pattern)) {
[16:12:30.234]                           computeRestarts <- base::computeRestarts
[16:12:30.234]                           grepl <- base::grepl
[16:12:30.234]                           restarts <- computeRestarts(cond)
[16:12:30.234]                           for (restart in restarts) {
[16:12:30.234]                             name <- restart$name
[16:12:30.234]                             if (is.null(name)) 
[16:12:30.234]                               next
[16:12:30.234]                             if (!grepl(pattern, name)) 
[16:12:30.234]                               next
[16:12:30.234]                             invokeRestart(restart)
[16:12:30.234]                             muffled <- TRUE
[16:12:30.234]                             break
[16:12:30.234]                           }
[16:12:30.234]                         }
[16:12:30.234]                       }
[16:12:30.234]                       invisible(muffled)
[16:12:30.234]                     }
[16:12:30.234]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.234]                   }
[16:12:30.234]                 }
[16:12:30.234]             }
[16:12:30.234]         }))
[16:12:30.234]     }, error = function(ex) {
[16:12:30.234]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.234]                 ...future.rng), started = ...future.startTime, 
[16:12:30.234]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.234]             version = "1.8"), class = "FutureResult")
[16:12:30.234]     }, finally = {
[16:12:30.234]         if (!identical(...future.workdir, getwd())) 
[16:12:30.234]             setwd(...future.workdir)
[16:12:30.234]         {
[16:12:30.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.234]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.234]             }
[16:12:30.234]             base::options(...future.oldOptions)
[16:12:30.234]             if (.Platform$OS.type == "windows") {
[16:12:30.234]                 old_names <- names(...future.oldEnvVars)
[16:12:30.234]                 envs <- base::Sys.getenv()
[16:12:30.234]                 names <- names(envs)
[16:12:30.234]                 common <- intersect(names, old_names)
[16:12:30.234]                 added <- setdiff(names, old_names)
[16:12:30.234]                 removed <- setdiff(old_names, names)
[16:12:30.234]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.234]                   envs[common]]
[16:12:30.234]                 NAMES <- toupper(changed)
[16:12:30.234]                 args <- list()
[16:12:30.234]                 for (kk in seq_along(NAMES)) {
[16:12:30.234]                   name <- changed[[kk]]
[16:12:30.234]                   NAME <- NAMES[[kk]]
[16:12:30.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.234]                     next
[16:12:30.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.234]                 }
[16:12:30.234]                 NAMES <- toupper(added)
[16:12:30.234]                 for (kk in seq_along(NAMES)) {
[16:12:30.234]                   name <- added[[kk]]
[16:12:30.234]                   NAME <- NAMES[[kk]]
[16:12:30.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.234]                     next
[16:12:30.234]                   args[[name]] <- ""
[16:12:30.234]                 }
[16:12:30.234]                 NAMES <- toupper(removed)
[16:12:30.234]                 for (kk in seq_along(NAMES)) {
[16:12:30.234]                   name <- removed[[kk]]
[16:12:30.234]                   NAME <- NAMES[[kk]]
[16:12:30.234]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.234]                     next
[16:12:30.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.234]                 }
[16:12:30.234]                 if (length(args) > 0) 
[16:12:30.234]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.234]             }
[16:12:30.234]             else {
[16:12:30.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.234]             }
[16:12:30.234]             {
[16:12:30.234]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.234]                   0L) {
[16:12:30.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.234]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.234]                   base::options(opts)
[16:12:30.234]                 }
[16:12:30.234]                 {
[16:12:30.234]                   {
[16:12:30.234]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.234]                     NULL
[16:12:30.234]                   }
[16:12:30.234]                   options(future.plan = NULL)
[16:12:30.234]                   if (is.na(NA_character_)) 
[16:12:30.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.234]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:30.234]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:30.234]                     envir = parent.frame()) 
[16:12:30.234]                   {
[16:12:30.234]                     if (is.function(workers)) 
[16:12:30.234]                       workers <- workers()
[16:12:30.234]                     workers <- structure(as.integer(workers), 
[16:12:30.234]                       class = class(workers))
[16:12:30.234]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:30.234]                       workers >= 1)
[16:12:30.234]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:30.234]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:30.234]                     }
[16:12:30.234]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:30.234]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:30.234]                       envir = envir)
[16:12:30.234]                     if (!future$lazy) 
[16:12:30.234]                       future <- run(future)
[16:12:30.234]                     invisible(future)
[16:12:30.234]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.234]                 }
[16:12:30.234]             }
[16:12:30.234]         }
[16:12:30.234]     })
[16:12:30.234]     if (TRUE) {
[16:12:30.234]         base::sink(type = "output", split = FALSE)
[16:12:30.234]         if (TRUE) {
[16:12:30.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.234]         }
[16:12:30.234]         else {
[16:12:30.234]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.234]         }
[16:12:30.234]         base::close(...future.stdout)
[16:12:30.234]         ...future.stdout <- NULL
[16:12:30.234]     }
[16:12:30.234]     ...future.result$conditions <- ...future.conditions
[16:12:30.234]     ...future.result$finished <- base::Sys.time()
[16:12:30.234]     ...future.result
[16:12:30.234] }
[16:12:30.236] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:30.247] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.247] - Validating connection of MultisessionFuture
[16:12:30.251] - received message: FutureResult
[16:12:30.251] - Received FutureResult
[16:12:30.251] - Erased future from FutureRegistry
[16:12:30.251] result() for ClusterFuture ...
[16:12:30.252] - result already collected: FutureResult
[16:12:30.252] result() for ClusterFuture ... done
[16:12:30.252] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:30.252] result() for ClusterFuture ...
[16:12:30.252] - result already collected: FutureResult
[16:12:30.252] result() for ClusterFuture ... done
[16:12:30.252] result() for ClusterFuture ...
[16:12:30.252] - result already collected: FutureResult
[16:12:30.252] result() for ClusterFuture ... done
[16:12:30.253] MultisessionFuture started
[16:12:30.254] - Launch lazy future ... done
[16:12:30.254] run() for ‘MultisessionFuture’ ... done
<environment: 0x560bafab5ae8> 
<environment: 0x560baf2887f8> 
[16:12:30.265] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.265] - Validating connection of MultisessionFuture
[16:12:30.265] - received message: FutureResult
[16:12:30.265] - Received FutureResult
[16:12:30.265] - Erased future from FutureRegistry
[16:12:30.265] result() for ClusterFuture ...
[16:12:30.265] - result already collected: FutureResult
[16:12:30.265] result() for ClusterFuture ... done
[16:12:30.266] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[16:12:30.277] resolve() on environment ...
[16:12:30.277]  recursive: 0
[16:12:30.278]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[16:12:30.278] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.278] - nx: 4
[16:12:30.278] - relay: TRUE
[16:12:30.278] - stdout: TRUE
[16:12:30.278] - signal: TRUE
[16:12:30.279] - resignal: FALSE
[16:12:30.279] - force: TRUE
[16:12:30.279] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.279] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.279]  - until=2
[16:12:30.279]  - relaying element #2
[16:12:30.279] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:30.279] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.279] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.279]  length: 3 (resolved future 1)
[16:12:30.279] Future #2
[16:12:30.280] result() for ClusterFuture ...
[16:12:30.280] - result already collected: FutureResult
[16:12:30.280] result() for ClusterFuture ... done
[16:12:30.280] result() for ClusterFuture ...
[16:12:30.280] - result already collected: FutureResult
[16:12:30.280] result() for ClusterFuture ... done
[16:12:30.280] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:30.280] - nx: 4
[16:12:30.280] - relay: TRUE
[16:12:30.280] - stdout: TRUE
[16:12:30.281] - signal: TRUE
[16:12:30.281] - resignal: FALSE
[16:12:30.281] - force: TRUE
[16:12:30.281] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[16:12:30.281] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[16:12:30.281]  - until=2
[16:12:30.281]  - relaying element #2
[16:12:30.281] result() for ClusterFuture ...
[16:12:30.281] - result already collected: FutureResult
[16:12:30.281] result() for ClusterFuture ... done
[16:12:30.281] result() for ClusterFuture ...
[16:12:30.281] - result already collected: FutureResult
[16:12:30.282] result() for ClusterFuture ... done
[16:12:30.282] result() for ClusterFuture ...
[16:12:30.282] - result already collected: FutureResult
[16:12:30.282] result() for ClusterFuture ... done
[16:12:30.282] result() for ClusterFuture ...
[16:12:30.282] - result already collected: FutureResult
[16:12:30.282] result() for ClusterFuture ... done
[16:12:30.282] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:30.282] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:30.282] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:30.283]  length: 2 (resolved future 2)
[16:12:30.283] Future #3
[16:12:30.283] result() for ClusterFuture ...
[16:12:30.283] - result already collected: FutureResult
[16:12:30.283] result() for ClusterFuture ... done
[16:12:30.283] result() for ClusterFuture ...
[16:12:30.283] - result already collected: FutureResult
[16:12:30.283] result() for ClusterFuture ... done
[16:12:30.283] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:30.283] - nx: 4
[16:12:30.283] - relay: TRUE
[16:12:30.284] - stdout: TRUE
[16:12:30.284] - signal: TRUE
[16:12:30.284] - resignal: FALSE
[16:12:30.284] - force: TRUE
[16:12:30.284] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[16:12:30.284] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[16:12:30.284]  - until=3
[16:12:30.284]  - relaying element #3
[16:12:30.284] result() for ClusterFuture ...
[16:12:30.284] - result already collected: FutureResult
[16:12:30.284] result() for ClusterFuture ... done
[16:12:30.285] result() for ClusterFuture ...
[16:12:30.285] - result already collected: FutureResult
[16:12:30.285] result() for ClusterFuture ... done
[16:12:30.285] result() for ClusterFuture ...
[16:12:30.285] - result already collected: FutureResult
[16:12:30.285] result() for ClusterFuture ... done
[16:12:30.285] result() for ClusterFuture ...
[16:12:30.285] - result already collected: FutureResult
[16:12:30.285] result() for ClusterFuture ... done
[16:12:30.285] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:30.285] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:30.286] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:30.286]  length: 1 (resolved future 3)
[16:12:30.307] receiveMessageFromWorker() for ClusterFuture ...
[16:12:30.307] - Validating connection of MultisessionFuture
[16:12:30.307] - received message: FutureResult
[16:12:30.307] - Received FutureResult
[16:12:30.307] - Erased future from FutureRegistry
[16:12:30.307] result() for ClusterFuture ...
[16:12:30.308] - result already collected: FutureResult
[16:12:30.308] result() for ClusterFuture ... done
[16:12:30.308] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:30.308] Future #4
[16:12:30.308] result() for ClusterFuture ...
[16:12:30.308] - result already collected: FutureResult
[16:12:30.308] result() for ClusterFuture ... done
[16:12:30.308] result() for ClusterFuture ...
[16:12:30.308] - result already collected: FutureResult
[16:12:30.308] result() for ClusterFuture ... done
[16:12:30.309] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:30.309] - nx: 4
[16:12:30.309] - relay: TRUE
[16:12:30.309] - stdout: TRUE
[16:12:30.309] - signal: TRUE
[16:12:30.309] - resignal: FALSE
[16:12:30.309] - force: TRUE
[16:12:30.309] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[16:12:30.309] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[16:12:30.309]  - until=4
[16:12:30.309]  - relaying element #4
[16:12:30.309] result() for ClusterFuture ...
[16:12:30.310] - result already collected: FutureResult
[16:12:30.310] result() for ClusterFuture ... done
[16:12:30.310] result() for ClusterFuture ...
[16:12:30.310] - result already collected: FutureResult
[16:12:30.310] result() for ClusterFuture ... done
[16:12:30.310] result() for ClusterFuture ...
[16:12:30.310] - result already collected: FutureResult
[16:12:30.310] result() for ClusterFuture ... done
[16:12:30.310] result() for ClusterFuture ...
[16:12:30.310] - result already collected: FutureResult
[16:12:30.310] result() for ClusterFuture ... done
[16:12:30.311] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.311] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:30.311] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:30.311]  length: 0 (resolved future 4)
[16:12:30.311] Relaying remaining futures
[16:12:30.311] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.311] - nx: 4
[16:12:30.311] - relay: TRUE
[16:12:30.311] - stdout: TRUE
[16:12:30.311] - signal: TRUE
[16:12:30.311] - resignal: FALSE
[16:12:30.312] - force: TRUE
[16:12:30.312] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.312] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[16:12:30.312] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[16:12:30.312] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[16:12:30.312] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.312] resolve() on environment ... DONE
[16:12:30.313] result() for ClusterFuture ...
[16:12:30.313] - result already collected: FutureResult
[16:12:30.313] result() for ClusterFuture ... done
[16:12:30.313] result() for ClusterFuture ...
[16:12:30.313] - result already collected: FutureResult
[16:12:30.313] result() for ClusterFuture ... done
[16:12:30.313] result() for ClusterFuture ...
[16:12:30.313] - result already collected: FutureResult
[16:12:30.314] result() for ClusterFuture ... done
[16:12:30.314] result() for ClusterFuture ...
[16:12:30.314] - result already collected: FutureResult
[16:12:30.314] result() for ClusterFuture ... done
[16:12:30.314] result() for ClusterFuture ...
[16:12:30.314] - result already collected: FutureResult
[16:12:30.314] result() for ClusterFuture ... done
[16:12:30.314] result() for ClusterFuture ...
[16:12:30.314] - result already collected: FutureResult
[16:12:30.314] result() for ClusterFuture ... done
<environment: 0x560baef671b8> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[16:12:30.315] plan(): Setting new future strategy stack:
[16:12:30.316] List of future strategies:
[16:12:30.316] 1. multicore:
[16:12:30.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.316]    - tweaked: FALSE
[16:12:30.316]    - call: plan(strategy)
[16:12:30.321] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:12:30.321] getGlobalsAndPackages() ...
[16:12:30.321] Searching for globals...
[16:12:30.322] 
[16:12:30.322] Searching for globals ... DONE
[16:12:30.322] - globals: [0] <none>
[16:12:30.322] getGlobalsAndPackages() ... DONE
[16:12:30.323] run() for ‘Future’ ...
[16:12:30.323] - state: ‘created’
[16:12:30.323] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.328] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.328]   - Field: ‘label’
[16:12:30.328]   - Field: ‘local’
[16:12:30.328]   - Field: ‘owner’
[16:12:30.328]   - Field: ‘envir’
[16:12:30.328]   - Field: ‘workers’
[16:12:30.328]   - Field: ‘packages’
[16:12:30.329]   - Field: ‘gc’
[16:12:30.329]   - Field: ‘job’
[16:12:30.329]   - Field: ‘conditions’
[16:12:30.329]   - Field: ‘expr’
[16:12:30.329]   - Field: ‘uuid’
[16:12:30.329]   - Field: ‘seed’
[16:12:30.329]   - Field: ‘version’
[16:12:30.329]   - Field: ‘result’
[16:12:30.329]   - Field: ‘asynchronous’
[16:12:30.329]   - Field: ‘calls’
[16:12:30.330]   - Field: ‘globals’
[16:12:30.330]   - Field: ‘stdout’
[16:12:30.330]   - Field: ‘earlySignal’
[16:12:30.330]   - Field: ‘lazy’
[16:12:30.330]   - Field: ‘state’
[16:12:30.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.330] - Launch lazy future ...
[16:12:30.330] Packages needed by the future expression (n = 0): <none>
[16:12:30.330] Packages needed by future strategies (n = 0): <none>
[16:12:30.331] {
[16:12:30.331]     {
[16:12:30.331]         {
[16:12:30.331]             ...future.startTime <- base::Sys.time()
[16:12:30.331]             {
[16:12:30.331]                 {
[16:12:30.331]                   {
[16:12:30.331]                     {
[16:12:30.331]                       base::local({
[16:12:30.331]                         has_future <- base::requireNamespace("future", 
[16:12:30.331]                           quietly = TRUE)
[16:12:30.331]                         if (has_future) {
[16:12:30.331]                           ns <- base::getNamespace("future")
[16:12:30.331]                           version <- ns[[".package"]][["version"]]
[16:12:30.331]                           if (is.null(version)) 
[16:12:30.331]                             version <- utils::packageVersion("future")
[16:12:30.331]                         }
[16:12:30.331]                         else {
[16:12:30.331]                           version <- NULL
[16:12:30.331]                         }
[16:12:30.331]                         if (!has_future || version < "1.8.0") {
[16:12:30.331]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.331]                             "", base::R.version$version.string), 
[16:12:30.331]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.331]                               "release", "version")], collapse = " "), 
[16:12:30.331]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.331]                             info)
[16:12:30.331]                           info <- base::paste(info, collapse = "; ")
[16:12:30.331]                           if (!has_future) {
[16:12:30.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.331]                               info)
[16:12:30.331]                           }
[16:12:30.331]                           else {
[16:12:30.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.331]                               info, version)
[16:12:30.331]                           }
[16:12:30.331]                           base::stop(msg)
[16:12:30.331]                         }
[16:12:30.331]                       })
[16:12:30.331]                     }
[16:12:30.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.331]                     base::options(mc.cores = 1L)
[16:12:30.331]                   }
[16:12:30.331]                   options(future.plan = NULL)
[16:12:30.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.331]                 }
[16:12:30.331]                 ...future.workdir <- getwd()
[16:12:30.331]             }
[16:12:30.331]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.331]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.331]         }
[16:12:30.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.331]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.331]             base::names(...future.oldOptions))
[16:12:30.331]     }
[16:12:30.331]     if (FALSE) {
[16:12:30.331]     }
[16:12:30.331]     else {
[16:12:30.331]         if (TRUE) {
[16:12:30.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.331]                 open = "w")
[16:12:30.331]         }
[16:12:30.331]         else {
[16:12:30.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.331]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.331]         }
[16:12:30.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.331]             base::sink(type = "output", split = FALSE)
[16:12:30.331]             base::close(...future.stdout)
[16:12:30.331]         }, add = TRUE)
[16:12:30.331]     }
[16:12:30.331]     ...future.frame <- base::sys.nframe()
[16:12:30.331]     ...future.conditions <- base::list()
[16:12:30.331]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.331]     if (FALSE) {
[16:12:30.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.331]     }
[16:12:30.331]     ...future.result <- base::tryCatch({
[16:12:30.331]         base::withCallingHandlers({
[16:12:30.331]             ...future.value <- base::withVisible(base::local({
[16:12:30.331]                 withCallingHandlers({
[16:12:30.331]                   2
[16:12:30.331]                 }, immediateCondition = function(cond) {
[16:12:30.331]                   save_rds <- function (object, pathname, ...) 
[16:12:30.331]                   {
[16:12:30.331]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.331]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.331]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.331]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.331]                         fi_tmp[["mtime"]])
[16:12:30.331]                     }
[16:12:30.331]                     tryCatch({
[16:12:30.331]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.331]                     }, error = function(ex) {
[16:12:30.331]                       msg <- conditionMessage(ex)
[16:12:30.331]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.331]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.331]                         fi_tmp[["mtime"]], msg)
[16:12:30.331]                       ex$message <- msg
[16:12:30.331]                       stop(ex)
[16:12:30.331]                     })
[16:12:30.331]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.331]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.331]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.331]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.331]                       fi <- file.info(pathname)
[16:12:30.331]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.331]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.331]                         fi[["size"]], fi[["mtime"]])
[16:12:30.331]                       stop(msg)
[16:12:30.331]                     }
[16:12:30.331]                     invisible(pathname)
[16:12:30.331]                   }
[16:12:30.331]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.331]                     rootPath = tempdir()) 
[16:12:30.331]                   {
[16:12:30.331]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.331]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.331]                       tmpdir = path, fileext = ".rds")
[16:12:30.331]                     save_rds(obj, file)
[16:12:30.331]                   }
[16:12:30.331]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.331]                   {
[16:12:30.331]                     inherits <- base::inherits
[16:12:30.331]                     invokeRestart <- base::invokeRestart
[16:12:30.331]                     is.null <- base::is.null
[16:12:30.331]                     muffled <- FALSE
[16:12:30.331]                     if (inherits(cond, "message")) {
[16:12:30.331]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.331]                       if (muffled) 
[16:12:30.331]                         invokeRestart("muffleMessage")
[16:12:30.331]                     }
[16:12:30.331]                     else if (inherits(cond, "warning")) {
[16:12:30.331]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.331]                       if (muffled) 
[16:12:30.331]                         invokeRestart("muffleWarning")
[16:12:30.331]                     }
[16:12:30.331]                     else if (inherits(cond, "condition")) {
[16:12:30.331]                       if (!is.null(pattern)) {
[16:12:30.331]                         computeRestarts <- base::computeRestarts
[16:12:30.331]                         grepl <- base::grepl
[16:12:30.331]                         restarts <- computeRestarts(cond)
[16:12:30.331]                         for (restart in restarts) {
[16:12:30.331]                           name <- restart$name
[16:12:30.331]                           if (is.null(name)) 
[16:12:30.331]                             next
[16:12:30.331]                           if (!grepl(pattern, name)) 
[16:12:30.331]                             next
[16:12:30.331]                           invokeRestart(restart)
[16:12:30.331]                           muffled <- TRUE
[16:12:30.331]                           break
[16:12:30.331]                         }
[16:12:30.331]                       }
[16:12:30.331]                     }
[16:12:30.331]                     invisible(muffled)
[16:12:30.331]                   }
[16:12:30.331]                   muffleCondition(cond)
[16:12:30.331]                 })
[16:12:30.331]             }))
[16:12:30.331]             future::FutureResult(value = ...future.value$value, 
[16:12:30.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.331]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.331]                     ...future.globalenv.names))
[16:12:30.331]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.331]         }, condition = base::local({
[16:12:30.331]             c <- base::c
[16:12:30.331]             inherits <- base::inherits
[16:12:30.331]             invokeRestart <- base::invokeRestart
[16:12:30.331]             length <- base::length
[16:12:30.331]             list <- base::list
[16:12:30.331]             seq.int <- base::seq.int
[16:12:30.331]             signalCondition <- base::signalCondition
[16:12:30.331]             sys.calls <- base::sys.calls
[16:12:30.331]             `[[` <- base::`[[`
[16:12:30.331]             `+` <- base::`+`
[16:12:30.331]             `<<-` <- base::`<<-`
[16:12:30.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.331]                   3L)]
[16:12:30.331]             }
[16:12:30.331]             function(cond) {
[16:12:30.331]                 is_error <- inherits(cond, "error")
[16:12:30.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.331]                   NULL)
[16:12:30.331]                 if (is_error) {
[16:12:30.331]                   sessionInformation <- function() {
[16:12:30.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.331]                       search = base::search(), system = base::Sys.info())
[16:12:30.331]                   }
[16:12:30.331]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.331]                     cond$call), session = sessionInformation(), 
[16:12:30.331]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.331]                   signalCondition(cond)
[16:12:30.331]                 }
[16:12:30.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.331]                 "immediateCondition"))) {
[16:12:30.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.331]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.331]                   if (TRUE && !signal) {
[16:12:30.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.331]                     {
[16:12:30.331]                       inherits <- base::inherits
[16:12:30.331]                       invokeRestart <- base::invokeRestart
[16:12:30.331]                       is.null <- base::is.null
[16:12:30.331]                       muffled <- FALSE
[16:12:30.331]                       if (inherits(cond, "message")) {
[16:12:30.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.331]                         if (muffled) 
[16:12:30.331]                           invokeRestart("muffleMessage")
[16:12:30.331]                       }
[16:12:30.331]                       else if (inherits(cond, "warning")) {
[16:12:30.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.331]                         if (muffled) 
[16:12:30.331]                           invokeRestart("muffleWarning")
[16:12:30.331]                       }
[16:12:30.331]                       else if (inherits(cond, "condition")) {
[16:12:30.331]                         if (!is.null(pattern)) {
[16:12:30.331]                           computeRestarts <- base::computeRestarts
[16:12:30.331]                           grepl <- base::grepl
[16:12:30.331]                           restarts <- computeRestarts(cond)
[16:12:30.331]                           for (restart in restarts) {
[16:12:30.331]                             name <- restart$name
[16:12:30.331]                             if (is.null(name)) 
[16:12:30.331]                               next
[16:12:30.331]                             if (!grepl(pattern, name)) 
[16:12:30.331]                               next
[16:12:30.331]                             invokeRestart(restart)
[16:12:30.331]                             muffled <- TRUE
[16:12:30.331]                             break
[16:12:30.331]                           }
[16:12:30.331]                         }
[16:12:30.331]                       }
[16:12:30.331]                       invisible(muffled)
[16:12:30.331]                     }
[16:12:30.331]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.331]                   }
[16:12:30.331]                 }
[16:12:30.331]                 else {
[16:12:30.331]                   if (TRUE) {
[16:12:30.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.331]                     {
[16:12:30.331]                       inherits <- base::inherits
[16:12:30.331]                       invokeRestart <- base::invokeRestart
[16:12:30.331]                       is.null <- base::is.null
[16:12:30.331]                       muffled <- FALSE
[16:12:30.331]                       if (inherits(cond, "message")) {
[16:12:30.331]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.331]                         if (muffled) 
[16:12:30.331]                           invokeRestart("muffleMessage")
[16:12:30.331]                       }
[16:12:30.331]                       else if (inherits(cond, "warning")) {
[16:12:30.331]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.331]                         if (muffled) 
[16:12:30.331]                           invokeRestart("muffleWarning")
[16:12:30.331]                       }
[16:12:30.331]                       else if (inherits(cond, "condition")) {
[16:12:30.331]                         if (!is.null(pattern)) {
[16:12:30.331]                           computeRestarts <- base::computeRestarts
[16:12:30.331]                           grepl <- base::grepl
[16:12:30.331]                           restarts <- computeRestarts(cond)
[16:12:30.331]                           for (restart in restarts) {
[16:12:30.331]                             name <- restart$name
[16:12:30.331]                             if (is.null(name)) 
[16:12:30.331]                               next
[16:12:30.331]                             if (!grepl(pattern, name)) 
[16:12:30.331]                               next
[16:12:30.331]                             invokeRestart(restart)
[16:12:30.331]                             muffled <- TRUE
[16:12:30.331]                             break
[16:12:30.331]                           }
[16:12:30.331]                         }
[16:12:30.331]                       }
[16:12:30.331]                       invisible(muffled)
[16:12:30.331]                     }
[16:12:30.331]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.331]                   }
[16:12:30.331]                 }
[16:12:30.331]             }
[16:12:30.331]         }))
[16:12:30.331]     }, error = function(ex) {
[16:12:30.331]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.331]                 ...future.rng), started = ...future.startTime, 
[16:12:30.331]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.331]             version = "1.8"), class = "FutureResult")
[16:12:30.331]     }, finally = {
[16:12:30.331]         if (!identical(...future.workdir, getwd())) 
[16:12:30.331]             setwd(...future.workdir)
[16:12:30.331]         {
[16:12:30.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.331]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.331]             }
[16:12:30.331]             base::options(...future.oldOptions)
[16:12:30.331]             if (.Platform$OS.type == "windows") {
[16:12:30.331]                 old_names <- names(...future.oldEnvVars)
[16:12:30.331]                 envs <- base::Sys.getenv()
[16:12:30.331]                 names <- names(envs)
[16:12:30.331]                 common <- intersect(names, old_names)
[16:12:30.331]                 added <- setdiff(names, old_names)
[16:12:30.331]                 removed <- setdiff(old_names, names)
[16:12:30.331]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.331]                   envs[common]]
[16:12:30.331]                 NAMES <- toupper(changed)
[16:12:30.331]                 args <- list()
[16:12:30.331]                 for (kk in seq_along(NAMES)) {
[16:12:30.331]                   name <- changed[[kk]]
[16:12:30.331]                   NAME <- NAMES[[kk]]
[16:12:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.331]                     next
[16:12:30.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.331]                 }
[16:12:30.331]                 NAMES <- toupper(added)
[16:12:30.331]                 for (kk in seq_along(NAMES)) {
[16:12:30.331]                   name <- added[[kk]]
[16:12:30.331]                   NAME <- NAMES[[kk]]
[16:12:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.331]                     next
[16:12:30.331]                   args[[name]] <- ""
[16:12:30.331]                 }
[16:12:30.331]                 NAMES <- toupper(removed)
[16:12:30.331]                 for (kk in seq_along(NAMES)) {
[16:12:30.331]                   name <- removed[[kk]]
[16:12:30.331]                   NAME <- NAMES[[kk]]
[16:12:30.331]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.331]                     next
[16:12:30.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.331]                 }
[16:12:30.331]                 if (length(args) > 0) 
[16:12:30.331]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.331]             }
[16:12:30.331]             else {
[16:12:30.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.331]             }
[16:12:30.331]             {
[16:12:30.331]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.331]                   0L) {
[16:12:30.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.331]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.331]                   base::options(opts)
[16:12:30.331]                 }
[16:12:30.331]                 {
[16:12:30.331]                   {
[16:12:30.331]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.331]                     NULL
[16:12:30.331]                   }
[16:12:30.331]                   options(future.plan = NULL)
[16:12:30.331]                   if (is.na(NA_character_)) 
[16:12:30.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.331]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.331]                     envir = parent.frame()) 
[16:12:30.331]                   {
[16:12:30.331]                     default_workers <- missing(workers)
[16:12:30.331]                     if (is.function(workers)) 
[16:12:30.331]                       workers <- workers()
[16:12:30.331]                     workers <- structure(as.integer(workers), 
[16:12:30.331]                       class = class(workers))
[16:12:30.331]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.331]                       1L)
[16:12:30.331]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.331]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.331]                       if (default_workers) 
[16:12:30.331]                         supportsMulticore(warn = TRUE)
[16:12:30.331]                       return(sequential(..., envir = envir))
[16:12:30.331]                     }
[16:12:30.331]                     oopts <- options(mc.cores = workers)
[16:12:30.331]                     on.exit(options(oopts))
[16:12:30.331]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.331]                       envir = envir)
[16:12:30.331]                     if (!future$lazy) 
[16:12:30.331]                       future <- run(future)
[16:12:30.331]                     invisible(future)
[16:12:30.331]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.331]                 }
[16:12:30.331]             }
[16:12:30.331]         }
[16:12:30.331]     })
[16:12:30.331]     if (TRUE) {
[16:12:30.331]         base::sink(type = "output", split = FALSE)
[16:12:30.331]         if (TRUE) {
[16:12:30.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.331]         }
[16:12:30.331]         else {
[16:12:30.331]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.331]         }
[16:12:30.331]         base::close(...future.stdout)
[16:12:30.331]         ...future.stdout <- NULL
[16:12:30.331]     }
[16:12:30.331]     ...future.result$conditions <- ...future.conditions
[16:12:30.331]     ...future.result$finished <- base::Sys.time()
[16:12:30.331]     ...future.result
[16:12:30.331] }
[16:12:30.333] requestCore(): workers = 2
[16:12:30.336] MulticoreFuture started
[16:12:30.336] - Launch lazy future ... done
[16:12:30.337] run() for ‘MulticoreFuture’ ... done
[16:12:30.337] getGlobalsAndPackages() ...
[16:12:30.337] Searching for globals...
[16:12:30.337] plan(): Setting new future strategy stack:
[16:12:30.338] 
[16:12:30.338] List of future strategies:
[16:12:30.338] 1. sequential:
[16:12:30.338]    - args: function (..., envir = parent.frame())
[16:12:30.338]    - tweaked: FALSE
[16:12:30.338]    - call: NULL
[16:12:30.338] Searching for globals ... DONE
[16:12:30.338] - globals: [0] <none>
[16:12:30.338] getGlobalsAndPackages() ... DONE
[16:12:30.338] plan(): nbrOfWorkers() = 1
[16:12:30.339] run() for ‘Future’ ...
[16:12:30.339] - state: ‘created’
[16:12:30.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.340] plan(): Setting new future strategy stack:
[16:12:30.341] List of future strategies:
[16:12:30.341] 1. multicore:
[16:12:30.341]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.341]    - tweaked: FALSE
[16:12:30.341]    - call: plan(strategy)
[16:12:30.345] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.345] plan(): nbrOfWorkers() = 2
[16:12:30.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.346]   - Field: ‘label’
[16:12:30.346]   - Field: ‘local’
[16:12:30.346]   - Field: ‘owner’
[16:12:30.346]   - Field: ‘envir’
[16:12:30.346]   - Field: ‘workers’
[16:12:30.346]   - Field: ‘packages’
[16:12:30.346]   - Field: ‘gc’
[16:12:30.347]   - Field: ‘job’
[16:12:30.347]   - Field: ‘conditions’
[16:12:30.347]   - Field: ‘expr’
[16:12:30.347]   - Field: ‘uuid’
[16:12:30.347]   - Field: ‘seed’
[16:12:30.347]   - Field: ‘version’
[16:12:30.347]   - Field: ‘result’
[16:12:30.347]   - Field: ‘asynchronous’
[16:12:30.348]   - Field: ‘calls’
[16:12:30.348]   - Field: ‘globals’
[16:12:30.348]   - Field: ‘stdout’
[16:12:30.348]   - Field: ‘earlySignal’
[16:12:30.348]   - Field: ‘lazy’
[16:12:30.348]   - Field: ‘state’
[16:12:30.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.349] - Launch lazy future ...
[16:12:30.349] Packages needed by the future expression (n = 0): <none>
[16:12:30.349] Packages needed by future strategies (n = 0): <none>
[16:12:30.350] {
[16:12:30.350]     {
[16:12:30.350]         {
[16:12:30.350]             ...future.startTime <- base::Sys.time()
[16:12:30.350]             {
[16:12:30.350]                 {
[16:12:30.350]                   {
[16:12:30.350]                     {
[16:12:30.350]                       base::local({
[16:12:30.350]                         has_future <- base::requireNamespace("future", 
[16:12:30.350]                           quietly = TRUE)
[16:12:30.350]                         if (has_future) {
[16:12:30.350]                           ns <- base::getNamespace("future")
[16:12:30.350]                           version <- ns[[".package"]][["version"]]
[16:12:30.350]                           if (is.null(version)) 
[16:12:30.350]                             version <- utils::packageVersion("future")
[16:12:30.350]                         }
[16:12:30.350]                         else {
[16:12:30.350]                           version <- NULL
[16:12:30.350]                         }
[16:12:30.350]                         if (!has_future || version < "1.8.0") {
[16:12:30.350]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.350]                             "", base::R.version$version.string), 
[16:12:30.350]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.350]                               "release", "version")], collapse = " "), 
[16:12:30.350]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.350]                             info)
[16:12:30.350]                           info <- base::paste(info, collapse = "; ")
[16:12:30.350]                           if (!has_future) {
[16:12:30.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.350]                               info)
[16:12:30.350]                           }
[16:12:30.350]                           else {
[16:12:30.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.350]                               info, version)
[16:12:30.350]                           }
[16:12:30.350]                           base::stop(msg)
[16:12:30.350]                         }
[16:12:30.350]                       })
[16:12:30.350]                     }
[16:12:30.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.350]                     base::options(mc.cores = 1L)
[16:12:30.350]                   }
[16:12:30.350]                   options(future.plan = NULL)
[16:12:30.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.350]                 }
[16:12:30.350]                 ...future.workdir <- getwd()
[16:12:30.350]             }
[16:12:30.350]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.350]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.350]         }
[16:12:30.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.350]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.350]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.350]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.350]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.350]             base::names(...future.oldOptions))
[16:12:30.350]     }
[16:12:30.350]     if (FALSE) {
[16:12:30.350]     }
[16:12:30.350]     else {
[16:12:30.350]         if (TRUE) {
[16:12:30.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.350]                 open = "w")
[16:12:30.350]         }
[16:12:30.350]         else {
[16:12:30.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.350]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.350]         }
[16:12:30.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.350]             base::sink(type = "output", split = FALSE)
[16:12:30.350]             base::close(...future.stdout)
[16:12:30.350]         }, add = TRUE)
[16:12:30.350]     }
[16:12:30.350]     ...future.frame <- base::sys.nframe()
[16:12:30.350]     ...future.conditions <- base::list()
[16:12:30.350]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.350]     if (FALSE) {
[16:12:30.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.350]     }
[16:12:30.350]     ...future.result <- base::tryCatch({
[16:12:30.350]         base::withCallingHandlers({
[16:12:30.350]             ...future.value <- base::withVisible(base::local({
[16:12:30.350]                 withCallingHandlers({
[16:12:30.350]                   NULL
[16:12:30.350]                 }, immediateCondition = function(cond) {
[16:12:30.350]                   save_rds <- function (object, pathname, ...) 
[16:12:30.350]                   {
[16:12:30.350]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.350]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.350]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.350]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.350]                         fi_tmp[["mtime"]])
[16:12:30.350]                     }
[16:12:30.350]                     tryCatch({
[16:12:30.350]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.350]                     }, error = function(ex) {
[16:12:30.350]                       msg <- conditionMessage(ex)
[16:12:30.350]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.350]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.350]                         fi_tmp[["mtime"]], msg)
[16:12:30.350]                       ex$message <- msg
[16:12:30.350]                       stop(ex)
[16:12:30.350]                     })
[16:12:30.350]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.350]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.350]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.350]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.350]                       fi <- file.info(pathname)
[16:12:30.350]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.350]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.350]                         fi[["size"]], fi[["mtime"]])
[16:12:30.350]                       stop(msg)
[16:12:30.350]                     }
[16:12:30.350]                     invisible(pathname)
[16:12:30.350]                   }
[16:12:30.350]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.350]                     rootPath = tempdir()) 
[16:12:30.350]                   {
[16:12:30.350]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.350]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.350]                       tmpdir = path, fileext = ".rds")
[16:12:30.350]                     save_rds(obj, file)
[16:12:30.350]                   }
[16:12:30.350]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.350]                   {
[16:12:30.350]                     inherits <- base::inherits
[16:12:30.350]                     invokeRestart <- base::invokeRestart
[16:12:30.350]                     is.null <- base::is.null
[16:12:30.350]                     muffled <- FALSE
[16:12:30.350]                     if (inherits(cond, "message")) {
[16:12:30.350]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.350]                       if (muffled) 
[16:12:30.350]                         invokeRestart("muffleMessage")
[16:12:30.350]                     }
[16:12:30.350]                     else if (inherits(cond, "warning")) {
[16:12:30.350]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.350]                       if (muffled) 
[16:12:30.350]                         invokeRestart("muffleWarning")
[16:12:30.350]                     }
[16:12:30.350]                     else if (inherits(cond, "condition")) {
[16:12:30.350]                       if (!is.null(pattern)) {
[16:12:30.350]                         computeRestarts <- base::computeRestarts
[16:12:30.350]                         grepl <- base::grepl
[16:12:30.350]                         restarts <- computeRestarts(cond)
[16:12:30.350]                         for (restart in restarts) {
[16:12:30.350]                           name <- restart$name
[16:12:30.350]                           if (is.null(name)) 
[16:12:30.350]                             next
[16:12:30.350]                           if (!grepl(pattern, name)) 
[16:12:30.350]                             next
[16:12:30.350]                           invokeRestart(restart)
[16:12:30.350]                           muffled <- TRUE
[16:12:30.350]                           break
[16:12:30.350]                         }
[16:12:30.350]                       }
[16:12:30.350]                     }
[16:12:30.350]                     invisible(muffled)
[16:12:30.350]                   }
[16:12:30.350]                   muffleCondition(cond)
[16:12:30.350]                 })
[16:12:30.350]             }))
[16:12:30.350]             future::FutureResult(value = ...future.value$value, 
[16:12:30.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.350]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.350]                     ...future.globalenv.names))
[16:12:30.350]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.350]         }, condition = base::local({
[16:12:30.350]             c <- base::c
[16:12:30.350]             inherits <- base::inherits
[16:12:30.350]             invokeRestart <- base::invokeRestart
[16:12:30.350]             length <- base::length
[16:12:30.350]             list <- base::list
[16:12:30.350]             seq.int <- base::seq.int
[16:12:30.350]             signalCondition <- base::signalCondition
[16:12:30.350]             sys.calls <- base::sys.calls
[16:12:30.350]             `[[` <- base::`[[`
[16:12:30.350]             `+` <- base::`+`
[16:12:30.350]             `<<-` <- base::`<<-`
[16:12:30.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.350]                   3L)]
[16:12:30.350]             }
[16:12:30.350]             function(cond) {
[16:12:30.350]                 is_error <- inherits(cond, "error")
[16:12:30.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.350]                   NULL)
[16:12:30.350]                 if (is_error) {
[16:12:30.350]                   sessionInformation <- function() {
[16:12:30.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.350]                       search = base::search(), system = base::Sys.info())
[16:12:30.350]                   }
[16:12:30.350]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.350]                     cond$call), session = sessionInformation(), 
[16:12:30.350]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.350]                   signalCondition(cond)
[16:12:30.350]                 }
[16:12:30.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.350]                 "immediateCondition"))) {
[16:12:30.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.350]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.350]                   if (TRUE && !signal) {
[16:12:30.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.350]                     {
[16:12:30.350]                       inherits <- base::inherits
[16:12:30.350]                       invokeRestart <- base::invokeRestart
[16:12:30.350]                       is.null <- base::is.null
[16:12:30.350]                       muffled <- FALSE
[16:12:30.350]                       if (inherits(cond, "message")) {
[16:12:30.350]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.350]                         if (muffled) 
[16:12:30.350]                           invokeRestart("muffleMessage")
[16:12:30.350]                       }
[16:12:30.350]                       else if (inherits(cond, "warning")) {
[16:12:30.350]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.350]                         if (muffled) 
[16:12:30.350]                           invokeRestart("muffleWarning")
[16:12:30.350]                       }
[16:12:30.350]                       else if (inherits(cond, "condition")) {
[16:12:30.350]                         if (!is.null(pattern)) {
[16:12:30.350]                           computeRestarts <- base::computeRestarts
[16:12:30.350]                           grepl <- base::grepl
[16:12:30.350]                           restarts <- computeRestarts(cond)
[16:12:30.350]                           for (restart in restarts) {
[16:12:30.350]                             name <- restart$name
[16:12:30.350]                             if (is.null(name)) 
[16:12:30.350]                               next
[16:12:30.350]                             if (!grepl(pattern, name)) 
[16:12:30.350]                               next
[16:12:30.350]                             invokeRestart(restart)
[16:12:30.350]                             muffled <- TRUE
[16:12:30.350]                             break
[16:12:30.350]                           }
[16:12:30.350]                         }
[16:12:30.350]                       }
[16:12:30.350]                       invisible(muffled)
[16:12:30.350]                     }
[16:12:30.350]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.350]                   }
[16:12:30.350]                 }
[16:12:30.350]                 else {
[16:12:30.350]                   if (TRUE) {
[16:12:30.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.350]                     {
[16:12:30.350]                       inherits <- base::inherits
[16:12:30.350]                       invokeRestart <- base::invokeRestart
[16:12:30.350]                       is.null <- base::is.null
[16:12:30.350]                       muffled <- FALSE
[16:12:30.350]                       if (inherits(cond, "message")) {
[16:12:30.350]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.350]                         if (muffled) 
[16:12:30.350]                           invokeRestart("muffleMessage")
[16:12:30.350]                       }
[16:12:30.350]                       else if (inherits(cond, "warning")) {
[16:12:30.350]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.350]                         if (muffled) 
[16:12:30.350]                           invokeRestart("muffleWarning")
[16:12:30.350]                       }
[16:12:30.350]                       else if (inherits(cond, "condition")) {
[16:12:30.350]                         if (!is.null(pattern)) {
[16:12:30.350]                           computeRestarts <- base::computeRestarts
[16:12:30.350]                           grepl <- base::grepl
[16:12:30.350]                           restarts <- computeRestarts(cond)
[16:12:30.350]                           for (restart in restarts) {
[16:12:30.350]                             name <- restart$name
[16:12:30.350]                             if (is.null(name)) 
[16:12:30.350]                               next
[16:12:30.350]                             if (!grepl(pattern, name)) 
[16:12:30.350]                               next
[16:12:30.350]                             invokeRestart(restart)
[16:12:30.350]                             muffled <- TRUE
[16:12:30.350]                             break
[16:12:30.350]                           }
[16:12:30.350]                         }
[16:12:30.350]                       }
[16:12:30.350]                       invisible(muffled)
[16:12:30.350]                     }
[16:12:30.350]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.350]                   }
[16:12:30.350]                 }
[16:12:30.350]             }
[16:12:30.350]         }))
[16:12:30.350]     }, error = function(ex) {
[16:12:30.350]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.350]                 ...future.rng), started = ...future.startTime, 
[16:12:30.350]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.350]             version = "1.8"), class = "FutureResult")
[16:12:30.350]     }, finally = {
[16:12:30.350]         if (!identical(...future.workdir, getwd())) 
[16:12:30.350]             setwd(...future.workdir)
[16:12:30.350]         {
[16:12:30.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.350]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.350]             }
[16:12:30.350]             base::options(...future.oldOptions)
[16:12:30.350]             if (.Platform$OS.type == "windows") {
[16:12:30.350]                 old_names <- names(...future.oldEnvVars)
[16:12:30.350]                 envs <- base::Sys.getenv()
[16:12:30.350]                 names <- names(envs)
[16:12:30.350]                 common <- intersect(names, old_names)
[16:12:30.350]                 added <- setdiff(names, old_names)
[16:12:30.350]                 removed <- setdiff(old_names, names)
[16:12:30.350]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.350]                   envs[common]]
[16:12:30.350]                 NAMES <- toupper(changed)
[16:12:30.350]                 args <- list()
[16:12:30.350]                 for (kk in seq_along(NAMES)) {
[16:12:30.350]                   name <- changed[[kk]]
[16:12:30.350]                   NAME <- NAMES[[kk]]
[16:12:30.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.350]                     next
[16:12:30.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.350]                 }
[16:12:30.350]                 NAMES <- toupper(added)
[16:12:30.350]                 for (kk in seq_along(NAMES)) {
[16:12:30.350]                   name <- added[[kk]]
[16:12:30.350]                   NAME <- NAMES[[kk]]
[16:12:30.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.350]                     next
[16:12:30.350]                   args[[name]] <- ""
[16:12:30.350]                 }
[16:12:30.350]                 NAMES <- toupper(removed)
[16:12:30.350]                 for (kk in seq_along(NAMES)) {
[16:12:30.350]                   name <- removed[[kk]]
[16:12:30.350]                   NAME <- NAMES[[kk]]
[16:12:30.350]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.350]                     next
[16:12:30.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.350]                 }
[16:12:30.350]                 if (length(args) > 0) 
[16:12:30.350]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.350]             }
[16:12:30.350]             else {
[16:12:30.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.350]             }
[16:12:30.350]             {
[16:12:30.350]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.350]                   0L) {
[16:12:30.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.350]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.350]                   base::options(opts)
[16:12:30.350]                 }
[16:12:30.350]                 {
[16:12:30.350]                   {
[16:12:30.350]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.350]                     NULL
[16:12:30.350]                   }
[16:12:30.350]                   options(future.plan = NULL)
[16:12:30.350]                   if (is.na(NA_character_)) 
[16:12:30.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.350]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.350]                     envir = parent.frame()) 
[16:12:30.350]                   {
[16:12:30.350]                     default_workers <- missing(workers)
[16:12:30.350]                     if (is.function(workers)) 
[16:12:30.350]                       workers <- workers()
[16:12:30.350]                     workers <- structure(as.integer(workers), 
[16:12:30.350]                       class = class(workers))
[16:12:30.350]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.350]                       1L)
[16:12:30.350]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.350]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.350]                       if (default_workers) 
[16:12:30.350]                         supportsMulticore(warn = TRUE)
[16:12:30.350]                       return(sequential(..., envir = envir))
[16:12:30.350]                     }
[16:12:30.350]                     oopts <- options(mc.cores = workers)
[16:12:30.350]                     on.exit(options(oopts))
[16:12:30.350]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.350]                       envir = envir)
[16:12:30.350]                     if (!future$lazy) 
[16:12:30.350]                       future <- run(future)
[16:12:30.350]                     invisible(future)
[16:12:30.350]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.350]                 }
[16:12:30.350]             }
[16:12:30.350]         }
[16:12:30.350]     })
[16:12:30.350]     if (TRUE) {
[16:12:30.350]         base::sink(type = "output", split = FALSE)
[16:12:30.350]         if (TRUE) {
[16:12:30.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.350]         }
[16:12:30.350]         else {
[16:12:30.350]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.350]         }
[16:12:30.350]         base::close(...future.stdout)
[16:12:30.350]         ...future.stdout <- NULL
[16:12:30.350]     }
[16:12:30.350]     ...future.result$conditions <- ...future.conditions
[16:12:30.350]     ...future.result$finished <- base::Sys.time()
[16:12:30.350]     ...future.result
[16:12:30.350] }
[16:12:30.354] requestCore(): workers = 2
[16:12:30.357] MulticoreFuture started
[16:12:30.357] - Launch lazy future ... done
[16:12:30.357] run() for ‘MulticoreFuture’ ... done
[16:12:30.358] plan(): Setting new future strategy stack:
[16:12:30.358] getGlobalsAndPackages() ...
[16:12:30.358] Searching for globals...
[16:12:30.358] List of future strategies:
[16:12:30.358] 1. sequential:
[16:12:30.358]    - args: function (..., envir = parent.frame())
[16:12:30.358]    - tweaked: FALSE
[16:12:30.358]    - call: NULL
[16:12:30.359] plan(): nbrOfWorkers() = 1
[16:12:30.360] - globals found: [1] ‘{’
[16:12:30.360] Searching for globals ... DONE
[16:12:30.360] Resolving globals: FALSE
[16:12:30.361] 
[16:12:30.361] 
[16:12:30.361] getGlobalsAndPackages() ... DONE
[16:12:30.362] run() for ‘Future’ ...
[16:12:30.362] - state: ‘created’
[16:12:30.362] plan(): Setting new future strategy stack:
[16:12:30.362] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.362] List of future strategies:
[16:12:30.362] 1. multicore:
[16:12:30.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.362]    - tweaked: FALSE
[16:12:30.362]    - call: plan(strategy)
[16:12:30.367] plan(): nbrOfWorkers() = 2
[16:12:30.368] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.368] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.368]   - Field: ‘label’
[16:12:30.368]   - Field: ‘local’
[16:12:30.368]   - Field: ‘owner’
[16:12:30.369]   - Field: ‘envir’
[16:12:30.369]   - Field: ‘workers’
[16:12:30.369]   - Field: ‘packages’
[16:12:30.369]   - Field: ‘gc’
[16:12:30.369]   - Field: ‘job’
[16:12:30.369]   - Field: ‘conditions’
[16:12:30.369]   - Field: ‘expr’
[16:12:30.370]   - Field: ‘uuid’
[16:12:30.370]   - Field: ‘seed’
[16:12:30.370]   - Field: ‘version’
[16:12:30.370]   - Field: ‘result’
[16:12:30.370]   - Field: ‘asynchronous’
[16:12:30.370]   - Field: ‘calls’
[16:12:30.370]   - Field: ‘globals’
[16:12:30.371]   - Field: ‘stdout’
[16:12:30.371]   - Field: ‘earlySignal’
[16:12:30.371]   - Field: ‘lazy’
[16:12:30.371]   - Field: ‘state’
[16:12:30.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.371] - Launch lazy future ...
[16:12:30.372] Packages needed by the future expression (n = 0): <none>
[16:12:30.372] Packages needed by future strategies (n = 0): <none>
[16:12:30.373] {
[16:12:30.373]     {
[16:12:30.373]         {
[16:12:30.373]             ...future.startTime <- base::Sys.time()
[16:12:30.373]             {
[16:12:30.373]                 {
[16:12:30.373]                   {
[16:12:30.373]                     {
[16:12:30.373]                       base::local({
[16:12:30.373]                         has_future <- base::requireNamespace("future", 
[16:12:30.373]                           quietly = TRUE)
[16:12:30.373]                         if (has_future) {
[16:12:30.373]                           ns <- base::getNamespace("future")
[16:12:30.373]                           version <- ns[[".package"]][["version"]]
[16:12:30.373]                           if (is.null(version)) 
[16:12:30.373]                             version <- utils::packageVersion("future")
[16:12:30.373]                         }
[16:12:30.373]                         else {
[16:12:30.373]                           version <- NULL
[16:12:30.373]                         }
[16:12:30.373]                         if (!has_future || version < "1.8.0") {
[16:12:30.373]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.373]                             "", base::R.version$version.string), 
[16:12:30.373]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.373]                               "release", "version")], collapse = " "), 
[16:12:30.373]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.373]                             info)
[16:12:30.373]                           info <- base::paste(info, collapse = "; ")
[16:12:30.373]                           if (!has_future) {
[16:12:30.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.373]                               info)
[16:12:30.373]                           }
[16:12:30.373]                           else {
[16:12:30.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.373]                               info, version)
[16:12:30.373]                           }
[16:12:30.373]                           base::stop(msg)
[16:12:30.373]                         }
[16:12:30.373]                       })
[16:12:30.373]                     }
[16:12:30.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.373]                     base::options(mc.cores = 1L)
[16:12:30.373]                   }
[16:12:30.373]                   options(future.plan = NULL)
[16:12:30.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.373]                 }
[16:12:30.373]                 ...future.workdir <- getwd()
[16:12:30.373]             }
[16:12:30.373]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.373]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.373]         }
[16:12:30.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.373]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.373]             base::names(...future.oldOptions))
[16:12:30.373]     }
[16:12:30.373]     if (FALSE) {
[16:12:30.373]     }
[16:12:30.373]     else {
[16:12:30.373]         if (TRUE) {
[16:12:30.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.373]                 open = "w")
[16:12:30.373]         }
[16:12:30.373]         else {
[16:12:30.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.373]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.373]         }
[16:12:30.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.373]             base::sink(type = "output", split = FALSE)
[16:12:30.373]             base::close(...future.stdout)
[16:12:30.373]         }, add = TRUE)
[16:12:30.373]     }
[16:12:30.373]     ...future.frame <- base::sys.nframe()
[16:12:30.373]     ...future.conditions <- base::list()
[16:12:30.373]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.373]     if (FALSE) {
[16:12:30.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.373]     }
[16:12:30.373]     ...future.result <- base::tryCatch({
[16:12:30.373]         base::withCallingHandlers({
[16:12:30.373]             ...future.value <- base::withVisible(base::local({
[16:12:30.373]                 withCallingHandlers({
[16:12:30.373]                   {
[16:12:30.373]                     4
[16:12:30.373]                   }
[16:12:30.373]                 }, immediateCondition = function(cond) {
[16:12:30.373]                   save_rds <- function (object, pathname, ...) 
[16:12:30.373]                   {
[16:12:30.373]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.373]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.373]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.373]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.373]                         fi_tmp[["mtime"]])
[16:12:30.373]                     }
[16:12:30.373]                     tryCatch({
[16:12:30.373]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.373]                     }, error = function(ex) {
[16:12:30.373]                       msg <- conditionMessage(ex)
[16:12:30.373]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.373]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.373]                         fi_tmp[["mtime"]], msg)
[16:12:30.373]                       ex$message <- msg
[16:12:30.373]                       stop(ex)
[16:12:30.373]                     })
[16:12:30.373]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.373]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.373]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.373]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.373]                       fi <- file.info(pathname)
[16:12:30.373]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.373]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.373]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.373]                         fi[["size"]], fi[["mtime"]])
[16:12:30.373]                       stop(msg)
[16:12:30.373]                     }
[16:12:30.373]                     invisible(pathname)
[16:12:30.373]                   }
[16:12:30.373]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.373]                     rootPath = tempdir()) 
[16:12:30.373]                   {
[16:12:30.373]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.373]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.373]                       tmpdir = path, fileext = ".rds")
[16:12:30.373]                     save_rds(obj, file)
[16:12:30.373]                   }
[16:12:30.373]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.373]                   {
[16:12:30.373]                     inherits <- base::inherits
[16:12:30.373]                     invokeRestart <- base::invokeRestart
[16:12:30.373]                     is.null <- base::is.null
[16:12:30.373]                     muffled <- FALSE
[16:12:30.373]                     if (inherits(cond, "message")) {
[16:12:30.373]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.373]                       if (muffled) 
[16:12:30.373]                         invokeRestart("muffleMessage")
[16:12:30.373]                     }
[16:12:30.373]                     else if (inherits(cond, "warning")) {
[16:12:30.373]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.373]                       if (muffled) 
[16:12:30.373]                         invokeRestart("muffleWarning")
[16:12:30.373]                     }
[16:12:30.373]                     else if (inherits(cond, "condition")) {
[16:12:30.373]                       if (!is.null(pattern)) {
[16:12:30.373]                         computeRestarts <- base::computeRestarts
[16:12:30.373]                         grepl <- base::grepl
[16:12:30.373]                         restarts <- computeRestarts(cond)
[16:12:30.373]                         for (restart in restarts) {
[16:12:30.373]                           name <- restart$name
[16:12:30.373]                           if (is.null(name)) 
[16:12:30.373]                             next
[16:12:30.373]                           if (!grepl(pattern, name)) 
[16:12:30.373]                             next
[16:12:30.373]                           invokeRestart(restart)
[16:12:30.373]                           muffled <- TRUE
[16:12:30.373]                           break
[16:12:30.373]                         }
[16:12:30.373]                       }
[16:12:30.373]                     }
[16:12:30.373]                     invisible(muffled)
[16:12:30.373]                   }
[16:12:30.373]                   muffleCondition(cond)
[16:12:30.373]                 })
[16:12:30.373]             }))
[16:12:30.373]             future::FutureResult(value = ...future.value$value, 
[16:12:30.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.373]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.373]                     ...future.globalenv.names))
[16:12:30.373]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.373]         }, condition = base::local({
[16:12:30.373]             c <- base::c
[16:12:30.373]             inherits <- base::inherits
[16:12:30.373]             invokeRestart <- base::invokeRestart
[16:12:30.373]             length <- base::length
[16:12:30.373]             list <- base::list
[16:12:30.373]             seq.int <- base::seq.int
[16:12:30.373]             signalCondition <- base::signalCondition
[16:12:30.373]             sys.calls <- base::sys.calls
[16:12:30.373]             `[[` <- base::`[[`
[16:12:30.373]             `+` <- base::`+`
[16:12:30.373]             `<<-` <- base::`<<-`
[16:12:30.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.373]                   3L)]
[16:12:30.373]             }
[16:12:30.373]             function(cond) {
[16:12:30.373]                 is_error <- inherits(cond, "error")
[16:12:30.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.373]                   NULL)
[16:12:30.373]                 if (is_error) {
[16:12:30.373]                   sessionInformation <- function() {
[16:12:30.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.373]                       search = base::search(), system = base::Sys.info())
[16:12:30.373]                   }
[16:12:30.373]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.373]                     cond$call), session = sessionInformation(), 
[16:12:30.373]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.373]                   signalCondition(cond)
[16:12:30.373]                 }
[16:12:30.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.373]                 "immediateCondition"))) {
[16:12:30.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.373]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.373]                   if (TRUE && !signal) {
[16:12:30.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.373]                     {
[16:12:30.373]                       inherits <- base::inherits
[16:12:30.373]                       invokeRestart <- base::invokeRestart
[16:12:30.373]                       is.null <- base::is.null
[16:12:30.373]                       muffled <- FALSE
[16:12:30.373]                       if (inherits(cond, "message")) {
[16:12:30.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.373]                         if (muffled) 
[16:12:30.373]                           invokeRestart("muffleMessage")
[16:12:30.373]                       }
[16:12:30.373]                       else if (inherits(cond, "warning")) {
[16:12:30.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.373]                         if (muffled) 
[16:12:30.373]                           invokeRestart("muffleWarning")
[16:12:30.373]                       }
[16:12:30.373]                       else if (inherits(cond, "condition")) {
[16:12:30.373]                         if (!is.null(pattern)) {
[16:12:30.373]                           computeRestarts <- base::computeRestarts
[16:12:30.373]                           grepl <- base::grepl
[16:12:30.373]                           restarts <- computeRestarts(cond)
[16:12:30.373]                           for (restart in restarts) {
[16:12:30.373]                             name <- restart$name
[16:12:30.373]                             if (is.null(name)) 
[16:12:30.373]                               next
[16:12:30.373]                             if (!grepl(pattern, name)) 
[16:12:30.373]                               next
[16:12:30.373]                             invokeRestart(restart)
[16:12:30.373]                             muffled <- TRUE
[16:12:30.373]                             break
[16:12:30.373]                           }
[16:12:30.373]                         }
[16:12:30.373]                       }
[16:12:30.373]                       invisible(muffled)
[16:12:30.373]                     }
[16:12:30.373]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.373]                   }
[16:12:30.373]                 }
[16:12:30.373]                 else {
[16:12:30.373]                   if (TRUE) {
[16:12:30.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.373]                     {
[16:12:30.373]                       inherits <- base::inherits
[16:12:30.373]                       invokeRestart <- base::invokeRestart
[16:12:30.373]                       is.null <- base::is.null
[16:12:30.373]                       muffled <- FALSE
[16:12:30.373]                       if (inherits(cond, "message")) {
[16:12:30.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.373]                         if (muffled) 
[16:12:30.373]                           invokeRestart("muffleMessage")
[16:12:30.373]                       }
[16:12:30.373]                       else if (inherits(cond, "warning")) {
[16:12:30.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.373]                         if (muffled) 
[16:12:30.373]                           invokeRestart("muffleWarning")
[16:12:30.373]                       }
[16:12:30.373]                       else if (inherits(cond, "condition")) {
[16:12:30.373]                         if (!is.null(pattern)) {
[16:12:30.373]                           computeRestarts <- base::computeRestarts
[16:12:30.373]                           grepl <- base::grepl
[16:12:30.373]                           restarts <- computeRestarts(cond)
[16:12:30.373]                           for (restart in restarts) {
[16:12:30.373]                             name <- restart$name
[16:12:30.373]                             if (is.null(name)) 
[16:12:30.373]                               next
[16:12:30.373]                             if (!grepl(pattern, name)) 
[16:12:30.373]                               next
[16:12:30.373]                             invokeRestart(restart)
[16:12:30.373]                             muffled <- TRUE
[16:12:30.373]                             break
[16:12:30.373]                           }
[16:12:30.373]                         }
[16:12:30.373]                       }
[16:12:30.373]                       invisible(muffled)
[16:12:30.373]                     }
[16:12:30.373]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.373]                   }
[16:12:30.373]                 }
[16:12:30.373]             }
[16:12:30.373]         }))
[16:12:30.373]     }, error = function(ex) {
[16:12:30.373]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.373]                 ...future.rng), started = ...future.startTime, 
[16:12:30.373]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.373]             version = "1.8"), class = "FutureResult")
[16:12:30.373]     }, finally = {
[16:12:30.373]         if (!identical(...future.workdir, getwd())) 
[16:12:30.373]             setwd(...future.workdir)
[16:12:30.373]         {
[16:12:30.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.373]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.373]             }
[16:12:30.373]             base::options(...future.oldOptions)
[16:12:30.373]             if (.Platform$OS.type == "windows") {
[16:12:30.373]                 old_names <- names(...future.oldEnvVars)
[16:12:30.373]                 envs <- base::Sys.getenv()
[16:12:30.373]                 names <- names(envs)
[16:12:30.373]                 common <- intersect(names, old_names)
[16:12:30.373]                 added <- setdiff(names, old_names)
[16:12:30.373]                 removed <- setdiff(old_names, names)
[16:12:30.373]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.373]                   envs[common]]
[16:12:30.373]                 NAMES <- toupper(changed)
[16:12:30.373]                 args <- list()
[16:12:30.373]                 for (kk in seq_along(NAMES)) {
[16:12:30.373]                   name <- changed[[kk]]
[16:12:30.373]                   NAME <- NAMES[[kk]]
[16:12:30.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.373]                     next
[16:12:30.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.373]                 }
[16:12:30.373]                 NAMES <- toupper(added)
[16:12:30.373]                 for (kk in seq_along(NAMES)) {
[16:12:30.373]                   name <- added[[kk]]
[16:12:30.373]                   NAME <- NAMES[[kk]]
[16:12:30.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.373]                     next
[16:12:30.373]                   args[[name]] <- ""
[16:12:30.373]                 }
[16:12:30.373]                 NAMES <- toupper(removed)
[16:12:30.373]                 for (kk in seq_along(NAMES)) {
[16:12:30.373]                   name <- removed[[kk]]
[16:12:30.373]                   NAME <- NAMES[[kk]]
[16:12:30.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.373]                     next
[16:12:30.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.373]                 }
[16:12:30.373]                 if (length(args) > 0) 
[16:12:30.373]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.373]             }
[16:12:30.373]             else {
[16:12:30.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.373]             }
[16:12:30.373]             {
[16:12:30.373]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.373]                   0L) {
[16:12:30.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.373]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.373]                   base::options(opts)
[16:12:30.373]                 }
[16:12:30.373]                 {
[16:12:30.373]                   {
[16:12:30.373]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.373]                     NULL
[16:12:30.373]                   }
[16:12:30.373]                   options(future.plan = NULL)
[16:12:30.373]                   if (is.na(NA_character_)) 
[16:12:30.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.373]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.373]                     envir = parent.frame()) 
[16:12:30.373]                   {
[16:12:30.373]                     default_workers <- missing(workers)
[16:12:30.373]                     if (is.function(workers)) 
[16:12:30.373]                       workers <- workers()
[16:12:30.373]                     workers <- structure(as.integer(workers), 
[16:12:30.373]                       class = class(workers))
[16:12:30.373]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.373]                       1L)
[16:12:30.373]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.373]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.373]                       if (default_workers) 
[16:12:30.373]                         supportsMulticore(warn = TRUE)
[16:12:30.373]                       return(sequential(..., envir = envir))
[16:12:30.373]                     }
[16:12:30.373]                     oopts <- options(mc.cores = workers)
[16:12:30.373]                     on.exit(options(oopts))
[16:12:30.373]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.373]                       envir = envir)
[16:12:30.373]                     if (!future$lazy) 
[16:12:30.373]                       future <- run(future)
[16:12:30.373]                     invisible(future)
[16:12:30.373]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.373]                 }
[16:12:30.373]             }
[16:12:30.373]         }
[16:12:30.373]     })
[16:12:30.373]     if (TRUE) {
[16:12:30.373]         base::sink(type = "output", split = FALSE)
[16:12:30.373]         if (TRUE) {
[16:12:30.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.373]         }
[16:12:30.373]         else {
[16:12:30.373]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.373]         }
[16:12:30.373]         base::close(...future.stdout)
[16:12:30.373]         ...future.stdout <- NULL
[16:12:30.373]     }
[16:12:30.373]     ...future.result$conditions <- ...future.conditions
[16:12:30.373]     ...future.result$finished <- base::Sys.time()
[16:12:30.373]     ...future.result
[16:12:30.373] }
[16:12:30.376] requestCore(): workers = 2
[16:12:30.377] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:30.391] MulticoreFuture started
[16:12:30.392] - Launch lazy future ... done
[16:12:30.392] run() for ‘MulticoreFuture’ ... done
[16:12:30.393] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x560baca79f98> 
[16:12:30.393] List of future strategies:
[16:12:30.393] 1. sequential:
[16:12:30.393]    - args: function (..., envir = parent.frame())
[16:12:30.393]    - tweaked: FALSE
[16:12:30.393]    - call: NULL
[16:12:30.394] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x560bb02b73b0> 
[16:12:30.397] plan(): Setting new future strategy stack:
[16:12:30.397] List of future strategies:
[16:12:30.397] 1. multicore:
[16:12:30.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.397]    - tweaked: FALSE
[16:12:30.397]    - call: plan(strategy)
[16:12:30.403] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:30.406] resolve() on list environment ...
[16:12:30.406]  recursive: 0
[16:12:30.408]  length: 6
[16:12:30.408]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:30.408] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.408] - nx: 6
[16:12:30.408] - relay: TRUE
[16:12:30.408] - stdout: TRUE
[16:12:30.409] - signal: TRUE
[16:12:30.409] - resignal: FALSE
[16:12:30.409] - force: TRUE
[16:12:30.409] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.409] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.409]  - until=2
[16:12:30.409]  - relaying element #2
[16:12:30.410] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.410] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.410] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.410]  length: 5 (resolved future 1)
[16:12:30.410] Future #2
[16:12:30.410] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:30.410] - nx: 6
[16:12:30.411] - relay: TRUE
[16:12:30.411] - stdout: TRUE
[16:12:30.411] - signal: TRUE
[16:12:30.411] - resignal: FALSE
[16:12:30.411] - force: TRUE
[16:12:30.411] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.411] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.411]  - until=2
[16:12:30.412]  - relaying element #2
[16:12:30.412] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.412] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.412] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:30.412]  length: 4 (resolved future 2)
[16:12:30.413] Future #3
[16:12:30.414] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:30.414] - nx: 6
[16:12:30.414] - relay: TRUE
[16:12:30.414] - stdout: TRUE
[16:12:30.414] - signal: TRUE
[16:12:30.415] - resignal: FALSE
[16:12:30.415] - force: TRUE
[16:12:30.415] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.415] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.415]  - until=3
[16:12:30.415]  - relaying element #3
[16:12:30.416] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.416] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.416] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:30.416]  length: 3 (resolved future 3)
[16:12:30.417] Future #4
[16:12:30.418] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:30.418] - nx: 6
[16:12:30.418] - relay: TRUE
[16:12:30.418] - stdout: TRUE
[16:12:30.418] - signal: TRUE
[16:12:30.418] - resignal: FALSE
[16:12:30.418] - force: TRUE
[16:12:30.419] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.419] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.419]  - until=4
[16:12:30.419]  - relaying element #4
[16:12:30.419] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.419] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.419] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:30.420]  length: 2 (resolved future 4)
[16:12:30.420] signalConditionsASAP(NULL, pos=5) ...
[16:12:30.420] - nx: 6
[16:12:30.420] - relay: TRUE
[16:12:30.420] - stdout: TRUE
[16:12:30.420] - signal: TRUE
[16:12:30.420] - resignal: FALSE
[16:12:30.420] - force: TRUE
[16:12:30.420] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.421] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.421]  - until=6
[16:12:30.421]  - relaying element #6
[16:12:30.421] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.421] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.421] signalConditionsASAP(NULL, pos=5) ... done
[16:12:30.421]  length: 1 (resolved future 5)
[16:12:30.421] signalConditionsASAP(numeric, pos=6) ...
[16:12:30.422] - nx: 6
[16:12:30.422] - relay: TRUE
[16:12:30.422] - stdout: TRUE
[16:12:30.422] - signal: TRUE
[16:12:30.422] - resignal: FALSE
[16:12:30.422] - force: TRUE
[16:12:30.422] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.422] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.422]  - until=6
[16:12:30.422] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.422] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.423] signalConditionsASAP(numeric, pos=6) ... done
[16:12:30.423]  length: 0 (resolved future 6)
[16:12:30.423] Relaying remaining futures
[16:12:30.423] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.423] - nx: 6
[16:12:30.423] - relay: TRUE
[16:12:30.423] - stdout: TRUE
[16:12:30.423] - signal: TRUE
[16:12:30.423] - resignal: FALSE
[16:12:30.423] - force: TRUE
[16:12:30.424] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.424] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:30.424] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.424] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.424] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.424] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bb05123a0> 
Dimensions: c(1, 6)
[16:12:30.425] getGlobalsAndPackages() ...
[16:12:30.425] Searching for globals...
[16:12:30.426] 
[16:12:30.426] Searching for globals ... DONE
[16:12:30.426] - globals: [0] <none>
[16:12:30.426] getGlobalsAndPackages() ... DONE
[16:12:30.426] run() for ‘Future’ ...
[16:12:30.427] - state: ‘created’
[16:12:30.427] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.436]   - Field: ‘label’
[16:12:30.436]   - Field: ‘local’
[16:12:30.436]   - Field: ‘owner’
[16:12:30.436]   - Field: ‘envir’
[16:12:30.436]   - Field: ‘workers’
[16:12:30.436]   - Field: ‘packages’
[16:12:30.436]   - Field: ‘gc’
[16:12:30.437]   - Field: ‘job’
[16:12:30.437]   - Field: ‘conditions’
[16:12:30.437]   - Field: ‘expr’
[16:12:30.437]   - Field: ‘uuid’
[16:12:30.437]   - Field: ‘seed’
[16:12:30.437]   - Field: ‘version’
[16:12:30.437]   - Field: ‘result’
[16:12:30.437]   - Field: ‘asynchronous’
[16:12:30.437]   - Field: ‘calls’
[16:12:30.438]   - Field: ‘globals’
[16:12:30.438]   - Field: ‘stdout’
[16:12:30.438]   - Field: ‘earlySignal’
[16:12:30.438]   - Field: ‘lazy’
[16:12:30.438]   - Field: ‘state’
[16:12:30.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.438] - Launch lazy future ...
[16:12:30.439] Packages needed by the future expression (n = 0): <none>
[16:12:30.439] Packages needed by future strategies (n = 0): <none>
[16:12:30.439] {
[16:12:30.439]     {
[16:12:30.439]         {
[16:12:30.439]             ...future.startTime <- base::Sys.time()
[16:12:30.439]             {
[16:12:30.439]                 {
[16:12:30.439]                   {
[16:12:30.439]                     {
[16:12:30.439]                       base::local({
[16:12:30.439]                         has_future <- base::requireNamespace("future", 
[16:12:30.439]                           quietly = TRUE)
[16:12:30.439]                         if (has_future) {
[16:12:30.439]                           ns <- base::getNamespace("future")
[16:12:30.439]                           version <- ns[[".package"]][["version"]]
[16:12:30.439]                           if (is.null(version)) 
[16:12:30.439]                             version <- utils::packageVersion("future")
[16:12:30.439]                         }
[16:12:30.439]                         else {
[16:12:30.439]                           version <- NULL
[16:12:30.439]                         }
[16:12:30.439]                         if (!has_future || version < "1.8.0") {
[16:12:30.439]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.439]                             "", base::R.version$version.string), 
[16:12:30.439]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.439]                               "release", "version")], collapse = " "), 
[16:12:30.439]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.439]                             info)
[16:12:30.439]                           info <- base::paste(info, collapse = "; ")
[16:12:30.439]                           if (!has_future) {
[16:12:30.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.439]                               info)
[16:12:30.439]                           }
[16:12:30.439]                           else {
[16:12:30.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.439]                               info, version)
[16:12:30.439]                           }
[16:12:30.439]                           base::stop(msg)
[16:12:30.439]                         }
[16:12:30.439]                       })
[16:12:30.439]                     }
[16:12:30.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.439]                     base::options(mc.cores = 1L)
[16:12:30.439]                   }
[16:12:30.439]                   options(future.plan = NULL)
[16:12:30.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.439]                 }
[16:12:30.439]                 ...future.workdir <- getwd()
[16:12:30.439]             }
[16:12:30.439]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.439]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.439]         }
[16:12:30.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.439]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.439]             base::names(...future.oldOptions))
[16:12:30.439]     }
[16:12:30.439]     if (FALSE) {
[16:12:30.439]     }
[16:12:30.439]     else {
[16:12:30.439]         if (TRUE) {
[16:12:30.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.439]                 open = "w")
[16:12:30.439]         }
[16:12:30.439]         else {
[16:12:30.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.439]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.439]         }
[16:12:30.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.439]             base::sink(type = "output", split = FALSE)
[16:12:30.439]             base::close(...future.stdout)
[16:12:30.439]         }, add = TRUE)
[16:12:30.439]     }
[16:12:30.439]     ...future.frame <- base::sys.nframe()
[16:12:30.439]     ...future.conditions <- base::list()
[16:12:30.439]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.439]     if (FALSE) {
[16:12:30.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.439]     }
[16:12:30.439]     ...future.result <- base::tryCatch({
[16:12:30.439]         base::withCallingHandlers({
[16:12:30.439]             ...future.value <- base::withVisible(base::local({
[16:12:30.439]                 withCallingHandlers({
[16:12:30.439]                   2
[16:12:30.439]                 }, immediateCondition = function(cond) {
[16:12:30.439]                   save_rds <- function (object, pathname, ...) 
[16:12:30.439]                   {
[16:12:30.439]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.439]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.439]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.439]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.439]                         fi_tmp[["mtime"]])
[16:12:30.439]                     }
[16:12:30.439]                     tryCatch({
[16:12:30.439]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.439]                     }, error = function(ex) {
[16:12:30.439]                       msg <- conditionMessage(ex)
[16:12:30.439]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.439]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.439]                         fi_tmp[["mtime"]], msg)
[16:12:30.439]                       ex$message <- msg
[16:12:30.439]                       stop(ex)
[16:12:30.439]                     })
[16:12:30.439]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.439]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.439]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.439]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.439]                       fi <- file.info(pathname)
[16:12:30.439]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.439]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.439]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.439]                         fi[["size"]], fi[["mtime"]])
[16:12:30.439]                       stop(msg)
[16:12:30.439]                     }
[16:12:30.439]                     invisible(pathname)
[16:12:30.439]                   }
[16:12:30.439]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.439]                     rootPath = tempdir()) 
[16:12:30.439]                   {
[16:12:30.439]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.439]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.439]                       tmpdir = path, fileext = ".rds")
[16:12:30.439]                     save_rds(obj, file)
[16:12:30.439]                   }
[16:12:30.439]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.439]                   {
[16:12:30.439]                     inherits <- base::inherits
[16:12:30.439]                     invokeRestart <- base::invokeRestart
[16:12:30.439]                     is.null <- base::is.null
[16:12:30.439]                     muffled <- FALSE
[16:12:30.439]                     if (inherits(cond, "message")) {
[16:12:30.439]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.439]                       if (muffled) 
[16:12:30.439]                         invokeRestart("muffleMessage")
[16:12:30.439]                     }
[16:12:30.439]                     else if (inherits(cond, "warning")) {
[16:12:30.439]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.439]                       if (muffled) 
[16:12:30.439]                         invokeRestart("muffleWarning")
[16:12:30.439]                     }
[16:12:30.439]                     else if (inherits(cond, "condition")) {
[16:12:30.439]                       if (!is.null(pattern)) {
[16:12:30.439]                         computeRestarts <- base::computeRestarts
[16:12:30.439]                         grepl <- base::grepl
[16:12:30.439]                         restarts <- computeRestarts(cond)
[16:12:30.439]                         for (restart in restarts) {
[16:12:30.439]                           name <- restart$name
[16:12:30.439]                           if (is.null(name)) 
[16:12:30.439]                             next
[16:12:30.439]                           if (!grepl(pattern, name)) 
[16:12:30.439]                             next
[16:12:30.439]                           invokeRestart(restart)
[16:12:30.439]                           muffled <- TRUE
[16:12:30.439]                           break
[16:12:30.439]                         }
[16:12:30.439]                       }
[16:12:30.439]                     }
[16:12:30.439]                     invisible(muffled)
[16:12:30.439]                   }
[16:12:30.439]                   muffleCondition(cond)
[16:12:30.439]                 })
[16:12:30.439]             }))
[16:12:30.439]             future::FutureResult(value = ...future.value$value, 
[16:12:30.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.439]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.439]                     ...future.globalenv.names))
[16:12:30.439]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.439]         }, condition = base::local({
[16:12:30.439]             c <- base::c
[16:12:30.439]             inherits <- base::inherits
[16:12:30.439]             invokeRestart <- base::invokeRestart
[16:12:30.439]             length <- base::length
[16:12:30.439]             list <- base::list
[16:12:30.439]             seq.int <- base::seq.int
[16:12:30.439]             signalCondition <- base::signalCondition
[16:12:30.439]             sys.calls <- base::sys.calls
[16:12:30.439]             `[[` <- base::`[[`
[16:12:30.439]             `+` <- base::`+`
[16:12:30.439]             `<<-` <- base::`<<-`
[16:12:30.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.439]                   3L)]
[16:12:30.439]             }
[16:12:30.439]             function(cond) {
[16:12:30.439]                 is_error <- inherits(cond, "error")
[16:12:30.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.439]                   NULL)
[16:12:30.439]                 if (is_error) {
[16:12:30.439]                   sessionInformation <- function() {
[16:12:30.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.439]                       search = base::search(), system = base::Sys.info())
[16:12:30.439]                   }
[16:12:30.439]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.439]                     cond$call), session = sessionInformation(), 
[16:12:30.439]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.439]                   signalCondition(cond)
[16:12:30.439]                 }
[16:12:30.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.439]                 "immediateCondition"))) {
[16:12:30.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.439]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.439]                   if (TRUE && !signal) {
[16:12:30.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.439]                     {
[16:12:30.439]                       inherits <- base::inherits
[16:12:30.439]                       invokeRestart <- base::invokeRestart
[16:12:30.439]                       is.null <- base::is.null
[16:12:30.439]                       muffled <- FALSE
[16:12:30.439]                       if (inherits(cond, "message")) {
[16:12:30.439]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.439]                         if (muffled) 
[16:12:30.439]                           invokeRestart("muffleMessage")
[16:12:30.439]                       }
[16:12:30.439]                       else if (inherits(cond, "warning")) {
[16:12:30.439]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.439]                         if (muffled) 
[16:12:30.439]                           invokeRestart("muffleWarning")
[16:12:30.439]                       }
[16:12:30.439]                       else if (inherits(cond, "condition")) {
[16:12:30.439]                         if (!is.null(pattern)) {
[16:12:30.439]                           computeRestarts <- base::computeRestarts
[16:12:30.439]                           grepl <- base::grepl
[16:12:30.439]                           restarts <- computeRestarts(cond)
[16:12:30.439]                           for (restart in restarts) {
[16:12:30.439]                             name <- restart$name
[16:12:30.439]                             if (is.null(name)) 
[16:12:30.439]                               next
[16:12:30.439]                             if (!grepl(pattern, name)) 
[16:12:30.439]                               next
[16:12:30.439]                             invokeRestart(restart)
[16:12:30.439]                             muffled <- TRUE
[16:12:30.439]                             break
[16:12:30.439]                           }
[16:12:30.439]                         }
[16:12:30.439]                       }
[16:12:30.439]                       invisible(muffled)
[16:12:30.439]                     }
[16:12:30.439]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.439]                   }
[16:12:30.439]                 }
[16:12:30.439]                 else {
[16:12:30.439]                   if (TRUE) {
[16:12:30.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.439]                     {
[16:12:30.439]                       inherits <- base::inherits
[16:12:30.439]                       invokeRestart <- base::invokeRestart
[16:12:30.439]                       is.null <- base::is.null
[16:12:30.439]                       muffled <- FALSE
[16:12:30.439]                       if (inherits(cond, "message")) {
[16:12:30.439]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.439]                         if (muffled) 
[16:12:30.439]                           invokeRestart("muffleMessage")
[16:12:30.439]                       }
[16:12:30.439]                       else if (inherits(cond, "warning")) {
[16:12:30.439]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.439]                         if (muffled) 
[16:12:30.439]                           invokeRestart("muffleWarning")
[16:12:30.439]                       }
[16:12:30.439]                       else if (inherits(cond, "condition")) {
[16:12:30.439]                         if (!is.null(pattern)) {
[16:12:30.439]                           computeRestarts <- base::computeRestarts
[16:12:30.439]                           grepl <- base::grepl
[16:12:30.439]                           restarts <- computeRestarts(cond)
[16:12:30.439]                           for (restart in restarts) {
[16:12:30.439]                             name <- restart$name
[16:12:30.439]                             if (is.null(name)) 
[16:12:30.439]                               next
[16:12:30.439]                             if (!grepl(pattern, name)) 
[16:12:30.439]                               next
[16:12:30.439]                             invokeRestart(restart)
[16:12:30.439]                             muffled <- TRUE
[16:12:30.439]                             break
[16:12:30.439]                           }
[16:12:30.439]                         }
[16:12:30.439]                       }
[16:12:30.439]                       invisible(muffled)
[16:12:30.439]                     }
[16:12:30.439]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.439]                   }
[16:12:30.439]                 }
[16:12:30.439]             }
[16:12:30.439]         }))
[16:12:30.439]     }, error = function(ex) {
[16:12:30.439]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.439]                 ...future.rng), started = ...future.startTime, 
[16:12:30.439]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.439]             version = "1.8"), class = "FutureResult")
[16:12:30.439]     }, finally = {
[16:12:30.439]         if (!identical(...future.workdir, getwd())) 
[16:12:30.439]             setwd(...future.workdir)
[16:12:30.439]         {
[16:12:30.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.439]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.439]             }
[16:12:30.439]             base::options(...future.oldOptions)
[16:12:30.439]             if (.Platform$OS.type == "windows") {
[16:12:30.439]                 old_names <- names(...future.oldEnvVars)
[16:12:30.439]                 envs <- base::Sys.getenv()
[16:12:30.439]                 names <- names(envs)
[16:12:30.439]                 common <- intersect(names, old_names)
[16:12:30.439]                 added <- setdiff(names, old_names)
[16:12:30.439]                 removed <- setdiff(old_names, names)
[16:12:30.439]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.439]                   envs[common]]
[16:12:30.439]                 NAMES <- toupper(changed)
[16:12:30.439]                 args <- list()
[16:12:30.439]                 for (kk in seq_along(NAMES)) {
[16:12:30.439]                   name <- changed[[kk]]
[16:12:30.439]                   NAME <- NAMES[[kk]]
[16:12:30.439]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.439]                     next
[16:12:30.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.439]                 }
[16:12:30.439]                 NAMES <- toupper(added)
[16:12:30.439]                 for (kk in seq_along(NAMES)) {
[16:12:30.439]                   name <- added[[kk]]
[16:12:30.439]                   NAME <- NAMES[[kk]]
[16:12:30.439]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.439]                     next
[16:12:30.439]                   args[[name]] <- ""
[16:12:30.439]                 }
[16:12:30.439]                 NAMES <- toupper(removed)
[16:12:30.439]                 for (kk in seq_along(NAMES)) {
[16:12:30.439]                   name <- removed[[kk]]
[16:12:30.439]                   NAME <- NAMES[[kk]]
[16:12:30.439]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.439]                     next
[16:12:30.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.439]                 }
[16:12:30.439]                 if (length(args) > 0) 
[16:12:30.439]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.439]             }
[16:12:30.439]             else {
[16:12:30.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.439]             }
[16:12:30.439]             {
[16:12:30.439]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.439]                   0L) {
[16:12:30.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.439]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.439]                   base::options(opts)
[16:12:30.439]                 }
[16:12:30.439]                 {
[16:12:30.439]                   {
[16:12:30.439]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.439]                     NULL
[16:12:30.439]                   }
[16:12:30.439]                   options(future.plan = NULL)
[16:12:30.439]                   if (is.na(NA_character_)) 
[16:12:30.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.439]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.439]                     envir = parent.frame()) 
[16:12:30.439]                   {
[16:12:30.439]                     default_workers <- missing(workers)
[16:12:30.439]                     if (is.function(workers)) 
[16:12:30.439]                       workers <- workers()
[16:12:30.439]                     workers <- structure(as.integer(workers), 
[16:12:30.439]                       class = class(workers))
[16:12:30.439]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.439]                       1L)
[16:12:30.439]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.439]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.439]                       if (default_workers) 
[16:12:30.439]                         supportsMulticore(warn = TRUE)
[16:12:30.439]                       return(sequential(..., envir = envir))
[16:12:30.439]                     }
[16:12:30.439]                     oopts <- options(mc.cores = workers)
[16:12:30.439]                     on.exit(options(oopts))
[16:12:30.439]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.439]                       envir = envir)
[16:12:30.439]                     if (!future$lazy) 
[16:12:30.439]                       future <- run(future)
[16:12:30.439]                     invisible(future)
[16:12:30.439]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.439]                 }
[16:12:30.439]             }
[16:12:30.439]         }
[16:12:30.439]     })
[16:12:30.439]     if (TRUE) {
[16:12:30.439]         base::sink(type = "output", split = FALSE)
[16:12:30.439]         if (TRUE) {
[16:12:30.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.439]         }
[16:12:30.439]         else {
[16:12:30.439]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.439]         }
[16:12:30.439]         base::close(...future.stdout)
[16:12:30.439]         ...future.stdout <- NULL
[16:12:30.439]     }
[16:12:30.439]     ...future.result$conditions <- ...future.conditions
[16:12:30.439]     ...future.result$finished <- base::Sys.time()
[16:12:30.439]     ...future.result
[16:12:30.439] }
[16:12:30.442] requestCore(): workers = 2
[16:12:30.444] MulticoreFuture started
[16:12:30.444] - Launch lazy future ... done
[16:12:30.445] run() for ‘MulticoreFuture’ ... done
[16:12:30.445] getGlobalsAndPackages() ...
[16:12:30.445] Searching for globals...
[16:12:30.445] plan(): Setting new future strategy stack:
[16:12:30.446] 
[16:12:30.446] List of future strategies:
[16:12:30.446] 1. sequential:
[16:12:30.446]    - args: function (..., envir = parent.frame())
[16:12:30.446]    - tweaked: FALSE
[16:12:30.446]    - call: NULL
[16:12:30.446] Searching for globals ... DONE
[16:12:30.446] - globals: [0] <none>
[16:12:30.446] plan(): nbrOfWorkers() = 1
[16:12:30.447] getGlobalsAndPackages() ... DONE
[16:12:30.447] run() for ‘Future’ ...
[16:12:30.447] - state: ‘created’
[16:12:30.448] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.448] plan(): Setting new future strategy stack:
[16:12:30.449] List of future strategies:
[16:12:30.449] 1. multicore:
[16:12:30.449]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.449]    - tweaked: FALSE
[16:12:30.449]    - call: plan(strategy)
[16:12:30.453] plan(): nbrOfWorkers() = 2
[16:12:30.453] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.454] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.454]   - Field: ‘label’
[16:12:30.454]   - Field: ‘local’
[16:12:30.454]   - Field: ‘owner’
[16:12:30.454]   - Field: ‘envir’
[16:12:30.455]   - Field: ‘workers’
[16:12:30.455]   - Field: ‘packages’
[16:12:30.455]   - Field: ‘gc’
[16:12:30.455]   - Field: ‘job’
[16:12:30.455]   - Field: ‘conditions’
[16:12:30.455]   - Field: ‘expr’
[16:12:30.456]   - Field: ‘uuid’
[16:12:30.456]   - Field: ‘seed’
[16:12:30.456]   - Field: ‘version’
[16:12:30.456]   - Field: ‘result’
[16:12:30.456]   - Field: ‘asynchronous’
[16:12:30.456]   - Field: ‘calls’
[16:12:30.457]   - Field: ‘globals’
[16:12:30.457]   - Field: ‘stdout’
[16:12:30.457]   - Field: ‘earlySignal’
[16:12:30.457]   - Field: ‘lazy’
[16:12:30.457]   - Field: ‘state’
[16:12:30.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.458] - Launch lazy future ...
[16:12:30.458] Packages needed by the future expression (n = 0): <none>
[16:12:30.458] Packages needed by future strategies (n = 0): <none>
[16:12:30.459] {
[16:12:30.459]     {
[16:12:30.459]         {
[16:12:30.459]             ...future.startTime <- base::Sys.time()
[16:12:30.459]             {
[16:12:30.459]                 {
[16:12:30.459]                   {
[16:12:30.459]                     {
[16:12:30.459]                       base::local({
[16:12:30.459]                         has_future <- base::requireNamespace("future", 
[16:12:30.459]                           quietly = TRUE)
[16:12:30.459]                         if (has_future) {
[16:12:30.459]                           ns <- base::getNamespace("future")
[16:12:30.459]                           version <- ns[[".package"]][["version"]]
[16:12:30.459]                           if (is.null(version)) 
[16:12:30.459]                             version <- utils::packageVersion("future")
[16:12:30.459]                         }
[16:12:30.459]                         else {
[16:12:30.459]                           version <- NULL
[16:12:30.459]                         }
[16:12:30.459]                         if (!has_future || version < "1.8.0") {
[16:12:30.459]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.459]                             "", base::R.version$version.string), 
[16:12:30.459]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.459]                               "release", "version")], collapse = " "), 
[16:12:30.459]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.459]                             info)
[16:12:30.459]                           info <- base::paste(info, collapse = "; ")
[16:12:30.459]                           if (!has_future) {
[16:12:30.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.459]                               info)
[16:12:30.459]                           }
[16:12:30.459]                           else {
[16:12:30.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.459]                               info, version)
[16:12:30.459]                           }
[16:12:30.459]                           base::stop(msg)
[16:12:30.459]                         }
[16:12:30.459]                       })
[16:12:30.459]                     }
[16:12:30.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.459]                     base::options(mc.cores = 1L)
[16:12:30.459]                   }
[16:12:30.459]                   options(future.plan = NULL)
[16:12:30.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.459]                 }
[16:12:30.459]                 ...future.workdir <- getwd()
[16:12:30.459]             }
[16:12:30.459]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.459]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.459]         }
[16:12:30.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.459]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.459]             base::names(...future.oldOptions))
[16:12:30.459]     }
[16:12:30.459]     if (FALSE) {
[16:12:30.459]     }
[16:12:30.459]     else {
[16:12:30.459]         if (TRUE) {
[16:12:30.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.459]                 open = "w")
[16:12:30.459]         }
[16:12:30.459]         else {
[16:12:30.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.459]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.459]         }
[16:12:30.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.459]             base::sink(type = "output", split = FALSE)
[16:12:30.459]             base::close(...future.stdout)
[16:12:30.459]         }, add = TRUE)
[16:12:30.459]     }
[16:12:30.459]     ...future.frame <- base::sys.nframe()
[16:12:30.459]     ...future.conditions <- base::list()
[16:12:30.459]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.459]     if (FALSE) {
[16:12:30.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.459]     }
[16:12:30.459]     ...future.result <- base::tryCatch({
[16:12:30.459]         base::withCallingHandlers({
[16:12:30.459]             ...future.value <- base::withVisible(base::local({
[16:12:30.459]                 withCallingHandlers({
[16:12:30.459]                   NULL
[16:12:30.459]                 }, immediateCondition = function(cond) {
[16:12:30.459]                   save_rds <- function (object, pathname, ...) 
[16:12:30.459]                   {
[16:12:30.459]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.459]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.459]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.459]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.459]                         fi_tmp[["mtime"]])
[16:12:30.459]                     }
[16:12:30.459]                     tryCatch({
[16:12:30.459]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.459]                     }, error = function(ex) {
[16:12:30.459]                       msg <- conditionMessage(ex)
[16:12:30.459]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.459]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.459]                         fi_tmp[["mtime"]], msg)
[16:12:30.459]                       ex$message <- msg
[16:12:30.459]                       stop(ex)
[16:12:30.459]                     })
[16:12:30.459]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.459]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.459]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.459]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.459]                       fi <- file.info(pathname)
[16:12:30.459]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.459]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.459]                         fi[["size"]], fi[["mtime"]])
[16:12:30.459]                       stop(msg)
[16:12:30.459]                     }
[16:12:30.459]                     invisible(pathname)
[16:12:30.459]                   }
[16:12:30.459]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.459]                     rootPath = tempdir()) 
[16:12:30.459]                   {
[16:12:30.459]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.459]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.459]                       tmpdir = path, fileext = ".rds")
[16:12:30.459]                     save_rds(obj, file)
[16:12:30.459]                   }
[16:12:30.459]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.459]                   {
[16:12:30.459]                     inherits <- base::inherits
[16:12:30.459]                     invokeRestart <- base::invokeRestart
[16:12:30.459]                     is.null <- base::is.null
[16:12:30.459]                     muffled <- FALSE
[16:12:30.459]                     if (inherits(cond, "message")) {
[16:12:30.459]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.459]                       if (muffled) 
[16:12:30.459]                         invokeRestart("muffleMessage")
[16:12:30.459]                     }
[16:12:30.459]                     else if (inherits(cond, "warning")) {
[16:12:30.459]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.459]                       if (muffled) 
[16:12:30.459]                         invokeRestart("muffleWarning")
[16:12:30.459]                     }
[16:12:30.459]                     else if (inherits(cond, "condition")) {
[16:12:30.459]                       if (!is.null(pattern)) {
[16:12:30.459]                         computeRestarts <- base::computeRestarts
[16:12:30.459]                         grepl <- base::grepl
[16:12:30.459]                         restarts <- computeRestarts(cond)
[16:12:30.459]                         for (restart in restarts) {
[16:12:30.459]                           name <- restart$name
[16:12:30.459]                           if (is.null(name)) 
[16:12:30.459]                             next
[16:12:30.459]                           if (!grepl(pattern, name)) 
[16:12:30.459]                             next
[16:12:30.459]                           invokeRestart(restart)
[16:12:30.459]                           muffled <- TRUE
[16:12:30.459]                           break
[16:12:30.459]                         }
[16:12:30.459]                       }
[16:12:30.459]                     }
[16:12:30.459]                     invisible(muffled)
[16:12:30.459]                   }
[16:12:30.459]                   muffleCondition(cond)
[16:12:30.459]                 })
[16:12:30.459]             }))
[16:12:30.459]             future::FutureResult(value = ...future.value$value, 
[16:12:30.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.459]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.459]                     ...future.globalenv.names))
[16:12:30.459]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.459]         }, condition = base::local({
[16:12:30.459]             c <- base::c
[16:12:30.459]             inherits <- base::inherits
[16:12:30.459]             invokeRestart <- base::invokeRestart
[16:12:30.459]             length <- base::length
[16:12:30.459]             list <- base::list
[16:12:30.459]             seq.int <- base::seq.int
[16:12:30.459]             signalCondition <- base::signalCondition
[16:12:30.459]             sys.calls <- base::sys.calls
[16:12:30.459]             `[[` <- base::`[[`
[16:12:30.459]             `+` <- base::`+`
[16:12:30.459]             `<<-` <- base::`<<-`
[16:12:30.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.459]                   3L)]
[16:12:30.459]             }
[16:12:30.459]             function(cond) {
[16:12:30.459]                 is_error <- inherits(cond, "error")
[16:12:30.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.459]                   NULL)
[16:12:30.459]                 if (is_error) {
[16:12:30.459]                   sessionInformation <- function() {
[16:12:30.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.459]                       search = base::search(), system = base::Sys.info())
[16:12:30.459]                   }
[16:12:30.459]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.459]                     cond$call), session = sessionInformation(), 
[16:12:30.459]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.459]                   signalCondition(cond)
[16:12:30.459]                 }
[16:12:30.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.459]                 "immediateCondition"))) {
[16:12:30.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.459]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.459]                   if (TRUE && !signal) {
[16:12:30.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.459]                     {
[16:12:30.459]                       inherits <- base::inherits
[16:12:30.459]                       invokeRestart <- base::invokeRestart
[16:12:30.459]                       is.null <- base::is.null
[16:12:30.459]                       muffled <- FALSE
[16:12:30.459]                       if (inherits(cond, "message")) {
[16:12:30.459]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.459]                         if (muffled) 
[16:12:30.459]                           invokeRestart("muffleMessage")
[16:12:30.459]                       }
[16:12:30.459]                       else if (inherits(cond, "warning")) {
[16:12:30.459]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.459]                         if (muffled) 
[16:12:30.459]                           invokeRestart("muffleWarning")
[16:12:30.459]                       }
[16:12:30.459]                       else if (inherits(cond, "condition")) {
[16:12:30.459]                         if (!is.null(pattern)) {
[16:12:30.459]                           computeRestarts <- base::computeRestarts
[16:12:30.459]                           grepl <- base::grepl
[16:12:30.459]                           restarts <- computeRestarts(cond)
[16:12:30.459]                           for (restart in restarts) {
[16:12:30.459]                             name <- restart$name
[16:12:30.459]                             if (is.null(name)) 
[16:12:30.459]                               next
[16:12:30.459]                             if (!grepl(pattern, name)) 
[16:12:30.459]                               next
[16:12:30.459]                             invokeRestart(restart)
[16:12:30.459]                             muffled <- TRUE
[16:12:30.459]                             break
[16:12:30.459]                           }
[16:12:30.459]                         }
[16:12:30.459]                       }
[16:12:30.459]                       invisible(muffled)
[16:12:30.459]                     }
[16:12:30.459]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.459]                   }
[16:12:30.459]                 }
[16:12:30.459]                 else {
[16:12:30.459]                   if (TRUE) {
[16:12:30.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.459]                     {
[16:12:30.459]                       inherits <- base::inherits
[16:12:30.459]                       invokeRestart <- base::invokeRestart
[16:12:30.459]                       is.null <- base::is.null
[16:12:30.459]                       muffled <- FALSE
[16:12:30.459]                       if (inherits(cond, "message")) {
[16:12:30.459]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.459]                         if (muffled) 
[16:12:30.459]                           invokeRestart("muffleMessage")
[16:12:30.459]                       }
[16:12:30.459]                       else if (inherits(cond, "warning")) {
[16:12:30.459]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.459]                         if (muffled) 
[16:12:30.459]                           invokeRestart("muffleWarning")
[16:12:30.459]                       }
[16:12:30.459]                       else if (inherits(cond, "condition")) {
[16:12:30.459]                         if (!is.null(pattern)) {
[16:12:30.459]                           computeRestarts <- base::computeRestarts
[16:12:30.459]                           grepl <- base::grepl
[16:12:30.459]                           restarts <- computeRestarts(cond)
[16:12:30.459]                           for (restart in restarts) {
[16:12:30.459]                             name <- restart$name
[16:12:30.459]                             if (is.null(name)) 
[16:12:30.459]                               next
[16:12:30.459]                             if (!grepl(pattern, name)) 
[16:12:30.459]                               next
[16:12:30.459]                             invokeRestart(restart)
[16:12:30.459]                             muffled <- TRUE
[16:12:30.459]                             break
[16:12:30.459]                           }
[16:12:30.459]                         }
[16:12:30.459]                       }
[16:12:30.459]                       invisible(muffled)
[16:12:30.459]                     }
[16:12:30.459]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.459]                   }
[16:12:30.459]                 }
[16:12:30.459]             }
[16:12:30.459]         }))
[16:12:30.459]     }, error = function(ex) {
[16:12:30.459]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.459]                 ...future.rng), started = ...future.startTime, 
[16:12:30.459]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.459]             version = "1.8"), class = "FutureResult")
[16:12:30.459]     }, finally = {
[16:12:30.459]         if (!identical(...future.workdir, getwd())) 
[16:12:30.459]             setwd(...future.workdir)
[16:12:30.459]         {
[16:12:30.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.459]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.459]             }
[16:12:30.459]             base::options(...future.oldOptions)
[16:12:30.459]             if (.Platform$OS.type == "windows") {
[16:12:30.459]                 old_names <- names(...future.oldEnvVars)
[16:12:30.459]                 envs <- base::Sys.getenv()
[16:12:30.459]                 names <- names(envs)
[16:12:30.459]                 common <- intersect(names, old_names)
[16:12:30.459]                 added <- setdiff(names, old_names)
[16:12:30.459]                 removed <- setdiff(old_names, names)
[16:12:30.459]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.459]                   envs[common]]
[16:12:30.459]                 NAMES <- toupper(changed)
[16:12:30.459]                 args <- list()
[16:12:30.459]                 for (kk in seq_along(NAMES)) {
[16:12:30.459]                   name <- changed[[kk]]
[16:12:30.459]                   NAME <- NAMES[[kk]]
[16:12:30.459]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.459]                     next
[16:12:30.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.459]                 }
[16:12:30.459]                 NAMES <- toupper(added)
[16:12:30.459]                 for (kk in seq_along(NAMES)) {
[16:12:30.459]                   name <- added[[kk]]
[16:12:30.459]                   NAME <- NAMES[[kk]]
[16:12:30.459]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.459]                     next
[16:12:30.459]                   args[[name]] <- ""
[16:12:30.459]                 }
[16:12:30.459]                 NAMES <- toupper(removed)
[16:12:30.459]                 for (kk in seq_along(NAMES)) {
[16:12:30.459]                   name <- removed[[kk]]
[16:12:30.459]                   NAME <- NAMES[[kk]]
[16:12:30.459]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.459]                     next
[16:12:30.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.459]                 }
[16:12:30.459]                 if (length(args) > 0) 
[16:12:30.459]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.459]             }
[16:12:30.459]             else {
[16:12:30.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.459]             }
[16:12:30.459]             {
[16:12:30.459]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.459]                   0L) {
[16:12:30.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.459]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.459]                   base::options(opts)
[16:12:30.459]                 }
[16:12:30.459]                 {
[16:12:30.459]                   {
[16:12:30.459]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.459]                     NULL
[16:12:30.459]                   }
[16:12:30.459]                   options(future.plan = NULL)
[16:12:30.459]                   if (is.na(NA_character_)) 
[16:12:30.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.459]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.459]                     envir = parent.frame()) 
[16:12:30.459]                   {
[16:12:30.459]                     default_workers <- missing(workers)
[16:12:30.459]                     if (is.function(workers)) 
[16:12:30.459]                       workers <- workers()
[16:12:30.459]                     workers <- structure(as.integer(workers), 
[16:12:30.459]                       class = class(workers))
[16:12:30.459]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.459]                       1L)
[16:12:30.459]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.459]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.459]                       if (default_workers) 
[16:12:30.459]                         supportsMulticore(warn = TRUE)
[16:12:30.459]                       return(sequential(..., envir = envir))
[16:12:30.459]                     }
[16:12:30.459]                     oopts <- options(mc.cores = workers)
[16:12:30.459]                     on.exit(options(oopts))
[16:12:30.459]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.459]                       envir = envir)
[16:12:30.459]                     if (!future$lazy) 
[16:12:30.459]                       future <- run(future)
[16:12:30.459]                     invisible(future)
[16:12:30.459]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.459]                 }
[16:12:30.459]             }
[16:12:30.459]         }
[16:12:30.459]     })
[16:12:30.459]     if (TRUE) {
[16:12:30.459]         base::sink(type = "output", split = FALSE)
[16:12:30.459]         if (TRUE) {
[16:12:30.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.459]         }
[16:12:30.459]         else {
[16:12:30.459]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.459]         }
[16:12:30.459]         base::close(...future.stdout)
[16:12:30.459]         ...future.stdout <- NULL
[16:12:30.459]     }
[16:12:30.459]     ...future.result$conditions <- ...future.conditions
[16:12:30.459]     ...future.result$finished <- base::Sys.time()
[16:12:30.459]     ...future.result
[16:12:30.459] }
[16:12:30.463] requestCore(): workers = 2
[16:12:30.466] MulticoreFuture started
[16:12:30.466] - Launch lazy future ... done
[16:12:30.466] run() for ‘MulticoreFuture’ ... done
[16:12:30.467] plan(): Setting new future strategy stack:
[16:12:30.467] getGlobalsAndPackages() ...
[16:12:30.467] Searching for globals...
[16:12:30.467] List of future strategies:
[16:12:30.467] 1. sequential:
[16:12:30.467]    - args: function (..., envir = parent.frame())
[16:12:30.467]    - tweaked: FALSE
[16:12:30.467]    - call: NULL
[16:12:30.468] plan(): nbrOfWorkers() = 1
[16:12:30.469] - globals found: [1] ‘{’
[16:12:30.469] Searching for globals ... DONE
[16:12:30.469] Resolving globals: FALSE
[16:12:30.470] 
[16:12:30.470] 
[16:12:30.470] plan(): Setting new future strategy stack:
[16:12:30.470] getGlobalsAndPackages() ... DONE
[16:12:30.470] List of future strategies:
[16:12:30.470] 1. multicore:
[16:12:30.470]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.470]    - tweaked: FALSE
[16:12:30.470]    - call: plan(strategy)
[16:12:30.470] run() for ‘Future’ ...
[16:12:30.470] - state: ‘created’
[16:12:30.471] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.475] plan(): nbrOfWorkers() = 2
[16:12:30.476] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.476]   - Field: ‘label’
[16:12:30.476]   - Field: ‘local’
[16:12:30.476]   - Field: ‘owner’
[16:12:30.477]   - Field: ‘envir’
[16:12:30.477]   - Field: ‘workers’
[16:12:30.477]   - Field: ‘packages’
[16:12:30.477]   - Field: ‘gc’
[16:12:30.477]   - Field: ‘job’
[16:12:30.477]   - Field: ‘conditions’
[16:12:30.477]   - Field: ‘expr’
[16:12:30.478]   - Field: ‘uuid’
[16:12:30.478]   - Field: ‘seed’
[16:12:30.478]   - Field: ‘version’
[16:12:30.478]   - Field: ‘result’
[16:12:30.478]   - Field: ‘asynchronous’
[16:12:30.478]   - Field: ‘calls’
[16:12:30.478]   - Field: ‘globals’
[16:12:30.479]   - Field: ‘stdout’
[16:12:30.479]   - Field: ‘earlySignal’
[16:12:30.479]   - Field: ‘lazy’
[16:12:30.479]   - Field: ‘state’
[16:12:30.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.479] - Launch lazy future ...
[16:12:30.480] Packages needed by the future expression (n = 0): <none>
[16:12:30.480] Packages needed by future strategies (n = 0): <none>
[16:12:30.481] {
[16:12:30.481]     {
[16:12:30.481]         {
[16:12:30.481]             ...future.startTime <- base::Sys.time()
[16:12:30.481]             {
[16:12:30.481]                 {
[16:12:30.481]                   {
[16:12:30.481]                     {
[16:12:30.481]                       base::local({
[16:12:30.481]                         has_future <- base::requireNamespace("future", 
[16:12:30.481]                           quietly = TRUE)
[16:12:30.481]                         if (has_future) {
[16:12:30.481]                           ns <- base::getNamespace("future")
[16:12:30.481]                           version <- ns[[".package"]][["version"]]
[16:12:30.481]                           if (is.null(version)) 
[16:12:30.481]                             version <- utils::packageVersion("future")
[16:12:30.481]                         }
[16:12:30.481]                         else {
[16:12:30.481]                           version <- NULL
[16:12:30.481]                         }
[16:12:30.481]                         if (!has_future || version < "1.8.0") {
[16:12:30.481]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.481]                             "", base::R.version$version.string), 
[16:12:30.481]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.481]                               "release", "version")], collapse = " "), 
[16:12:30.481]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.481]                             info)
[16:12:30.481]                           info <- base::paste(info, collapse = "; ")
[16:12:30.481]                           if (!has_future) {
[16:12:30.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.481]                               info)
[16:12:30.481]                           }
[16:12:30.481]                           else {
[16:12:30.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.481]                               info, version)
[16:12:30.481]                           }
[16:12:30.481]                           base::stop(msg)
[16:12:30.481]                         }
[16:12:30.481]                       })
[16:12:30.481]                     }
[16:12:30.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.481]                     base::options(mc.cores = 1L)
[16:12:30.481]                   }
[16:12:30.481]                   options(future.plan = NULL)
[16:12:30.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.481]                 }
[16:12:30.481]                 ...future.workdir <- getwd()
[16:12:30.481]             }
[16:12:30.481]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.481]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.481]         }
[16:12:30.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.481]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.481]             base::names(...future.oldOptions))
[16:12:30.481]     }
[16:12:30.481]     if (FALSE) {
[16:12:30.481]     }
[16:12:30.481]     else {
[16:12:30.481]         if (TRUE) {
[16:12:30.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.481]                 open = "w")
[16:12:30.481]         }
[16:12:30.481]         else {
[16:12:30.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.481]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.481]         }
[16:12:30.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.481]             base::sink(type = "output", split = FALSE)
[16:12:30.481]             base::close(...future.stdout)
[16:12:30.481]         }, add = TRUE)
[16:12:30.481]     }
[16:12:30.481]     ...future.frame <- base::sys.nframe()
[16:12:30.481]     ...future.conditions <- base::list()
[16:12:30.481]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.481]     if (FALSE) {
[16:12:30.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.481]     }
[16:12:30.481]     ...future.result <- base::tryCatch({
[16:12:30.481]         base::withCallingHandlers({
[16:12:30.481]             ...future.value <- base::withVisible(base::local({
[16:12:30.481]                 withCallingHandlers({
[16:12:30.481]                   {
[16:12:30.481]                     4
[16:12:30.481]                   }
[16:12:30.481]                 }, immediateCondition = function(cond) {
[16:12:30.481]                   save_rds <- function (object, pathname, ...) 
[16:12:30.481]                   {
[16:12:30.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.481]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.481]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.481]                         fi_tmp[["mtime"]])
[16:12:30.481]                     }
[16:12:30.481]                     tryCatch({
[16:12:30.481]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.481]                     }, error = function(ex) {
[16:12:30.481]                       msg <- conditionMessage(ex)
[16:12:30.481]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.481]                         fi_tmp[["mtime"]], msg)
[16:12:30.481]                       ex$message <- msg
[16:12:30.481]                       stop(ex)
[16:12:30.481]                     })
[16:12:30.481]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.481]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.481]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.481]                       fi <- file.info(pathname)
[16:12:30.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.481]                         fi[["size"]], fi[["mtime"]])
[16:12:30.481]                       stop(msg)
[16:12:30.481]                     }
[16:12:30.481]                     invisible(pathname)
[16:12:30.481]                   }
[16:12:30.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.481]                     rootPath = tempdir()) 
[16:12:30.481]                   {
[16:12:30.481]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.481]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.481]                       tmpdir = path, fileext = ".rds")
[16:12:30.481]                     save_rds(obj, file)
[16:12:30.481]                   }
[16:12:30.481]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.481]                   {
[16:12:30.481]                     inherits <- base::inherits
[16:12:30.481]                     invokeRestart <- base::invokeRestart
[16:12:30.481]                     is.null <- base::is.null
[16:12:30.481]                     muffled <- FALSE
[16:12:30.481]                     if (inherits(cond, "message")) {
[16:12:30.481]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.481]                       if (muffled) 
[16:12:30.481]                         invokeRestart("muffleMessage")
[16:12:30.481]                     }
[16:12:30.481]                     else if (inherits(cond, "warning")) {
[16:12:30.481]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.481]                       if (muffled) 
[16:12:30.481]                         invokeRestart("muffleWarning")
[16:12:30.481]                     }
[16:12:30.481]                     else if (inherits(cond, "condition")) {
[16:12:30.481]                       if (!is.null(pattern)) {
[16:12:30.481]                         computeRestarts <- base::computeRestarts
[16:12:30.481]                         grepl <- base::grepl
[16:12:30.481]                         restarts <- computeRestarts(cond)
[16:12:30.481]                         for (restart in restarts) {
[16:12:30.481]                           name <- restart$name
[16:12:30.481]                           if (is.null(name)) 
[16:12:30.481]                             next
[16:12:30.481]                           if (!grepl(pattern, name)) 
[16:12:30.481]                             next
[16:12:30.481]                           invokeRestart(restart)
[16:12:30.481]                           muffled <- TRUE
[16:12:30.481]                           break
[16:12:30.481]                         }
[16:12:30.481]                       }
[16:12:30.481]                     }
[16:12:30.481]                     invisible(muffled)
[16:12:30.481]                   }
[16:12:30.481]                   muffleCondition(cond)
[16:12:30.481]                 })
[16:12:30.481]             }))
[16:12:30.481]             future::FutureResult(value = ...future.value$value, 
[16:12:30.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.481]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.481]                     ...future.globalenv.names))
[16:12:30.481]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.481]         }, condition = base::local({
[16:12:30.481]             c <- base::c
[16:12:30.481]             inherits <- base::inherits
[16:12:30.481]             invokeRestart <- base::invokeRestart
[16:12:30.481]             length <- base::length
[16:12:30.481]             list <- base::list
[16:12:30.481]             seq.int <- base::seq.int
[16:12:30.481]             signalCondition <- base::signalCondition
[16:12:30.481]             sys.calls <- base::sys.calls
[16:12:30.481]             `[[` <- base::`[[`
[16:12:30.481]             `+` <- base::`+`
[16:12:30.481]             `<<-` <- base::`<<-`
[16:12:30.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.481]                   3L)]
[16:12:30.481]             }
[16:12:30.481]             function(cond) {
[16:12:30.481]                 is_error <- inherits(cond, "error")
[16:12:30.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.481]                   NULL)
[16:12:30.481]                 if (is_error) {
[16:12:30.481]                   sessionInformation <- function() {
[16:12:30.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.481]                       search = base::search(), system = base::Sys.info())
[16:12:30.481]                   }
[16:12:30.481]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.481]                     cond$call), session = sessionInformation(), 
[16:12:30.481]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.481]                   signalCondition(cond)
[16:12:30.481]                 }
[16:12:30.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.481]                 "immediateCondition"))) {
[16:12:30.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.481]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.481]                   if (TRUE && !signal) {
[16:12:30.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.481]                     {
[16:12:30.481]                       inherits <- base::inherits
[16:12:30.481]                       invokeRestart <- base::invokeRestart
[16:12:30.481]                       is.null <- base::is.null
[16:12:30.481]                       muffled <- FALSE
[16:12:30.481]                       if (inherits(cond, "message")) {
[16:12:30.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.481]                         if (muffled) 
[16:12:30.481]                           invokeRestart("muffleMessage")
[16:12:30.481]                       }
[16:12:30.481]                       else if (inherits(cond, "warning")) {
[16:12:30.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.481]                         if (muffled) 
[16:12:30.481]                           invokeRestart("muffleWarning")
[16:12:30.481]                       }
[16:12:30.481]                       else if (inherits(cond, "condition")) {
[16:12:30.481]                         if (!is.null(pattern)) {
[16:12:30.481]                           computeRestarts <- base::computeRestarts
[16:12:30.481]                           grepl <- base::grepl
[16:12:30.481]                           restarts <- computeRestarts(cond)
[16:12:30.481]                           for (restart in restarts) {
[16:12:30.481]                             name <- restart$name
[16:12:30.481]                             if (is.null(name)) 
[16:12:30.481]                               next
[16:12:30.481]                             if (!grepl(pattern, name)) 
[16:12:30.481]                               next
[16:12:30.481]                             invokeRestart(restart)
[16:12:30.481]                             muffled <- TRUE
[16:12:30.481]                             break
[16:12:30.481]                           }
[16:12:30.481]                         }
[16:12:30.481]                       }
[16:12:30.481]                       invisible(muffled)
[16:12:30.481]                     }
[16:12:30.481]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.481]                   }
[16:12:30.481]                 }
[16:12:30.481]                 else {
[16:12:30.481]                   if (TRUE) {
[16:12:30.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.481]                     {
[16:12:30.481]                       inherits <- base::inherits
[16:12:30.481]                       invokeRestart <- base::invokeRestart
[16:12:30.481]                       is.null <- base::is.null
[16:12:30.481]                       muffled <- FALSE
[16:12:30.481]                       if (inherits(cond, "message")) {
[16:12:30.481]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.481]                         if (muffled) 
[16:12:30.481]                           invokeRestart("muffleMessage")
[16:12:30.481]                       }
[16:12:30.481]                       else if (inherits(cond, "warning")) {
[16:12:30.481]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.481]                         if (muffled) 
[16:12:30.481]                           invokeRestart("muffleWarning")
[16:12:30.481]                       }
[16:12:30.481]                       else if (inherits(cond, "condition")) {
[16:12:30.481]                         if (!is.null(pattern)) {
[16:12:30.481]                           computeRestarts <- base::computeRestarts
[16:12:30.481]                           grepl <- base::grepl
[16:12:30.481]                           restarts <- computeRestarts(cond)
[16:12:30.481]                           for (restart in restarts) {
[16:12:30.481]                             name <- restart$name
[16:12:30.481]                             if (is.null(name)) 
[16:12:30.481]                               next
[16:12:30.481]                             if (!grepl(pattern, name)) 
[16:12:30.481]                               next
[16:12:30.481]                             invokeRestart(restart)
[16:12:30.481]                             muffled <- TRUE
[16:12:30.481]                             break
[16:12:30.481]                           }
[16:12:30.481]                         }
[16:12:30.481]                       }
[16:12:30.481]                       invisible(muffled)
[16:12:30.481]                     }
[16:12:30.481]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.481]                   }
[16:12:30.481]                 }
[16:12:30.481]             }
[16:12:30.481]         }))
[16:12:30.481]     }, error = function(ex) {
[16:12:30.481]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.481]                 ...future.rng), started = ...future.startTime, 
[16:12:30.481]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.481]             version = "1.8"), class = "FutureResult")
[16:12:30.481]     }, finally = {
[16:12:30.481]         if (!identical(...future.workdir, getwd())) 
[16:12:30.481]             setwd(...future.workdir)
[16:12:30.481]         {
[16:12:30.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.481]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.481]             }
[16:12:30.481]             base::options(...future.oldOptions)
[16:12:30.481]             if (.Platform$OS.type == "windows") {
[16:12:30.481]                 old_names <- names(...future.oldEnvVars)
[16:12:30.481]                 envs <- base::Sys.getenv()
[16:12:30.481]                 names <- names(envs)
[16:12:30.481]                 common <- intersect(names, old_names)
[16:12:30.481]                 added <- setdiff(names, old_names)
[16:12:30.481]                 removed <- setdiff(old_names, names)
[16:12:30.481]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.481]                   envs[common]]
[16:12:30.481]                 NAMES <- toupper(changed)
[16:12:30.481]                 args <- list()
[16:12:30.481]                 for (kk in seq_along(NAMES)) {
[16:12:30.481]                   name <- changed[[kk]]
[16:12:30.481]                   NAME <- NAMES[[kk]]
[16:12:30.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.481]                     next
[16:12:30.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.481]                 }
[16:12:30.481]                 NAMES <- toupper(added)
[16:12:30.481]                 for (kk in seq_along(NAMES)) {
[16:12:30.481]                   name <- added[[kk]]
[16:12:30.481]                   NAME <- NAMES[[kk]]
[16:12:30.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.481]                     next
[16:12:30.481]                   args[[name]] <- ""
[16:12:30.481]                 }
[16:12:30.481]                 NAMES <- toupper(removed)
[16:12:30.481]                 for (kk in seq_along(NAMES)) {
[16:12:30.481]                   name <- removed[[kk]]
[16:12:30.481]                   NAME <- NAMES[[kk]]
[16:12:30.481]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.481]                     next
[16:12:30.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.481]                 }
[16:12:30.481]                 if (length(args) > 0) 
[16:12:30.481]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.481]             }
[16:12:30.481]             else {
[16:12:30.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.481]             }
[16:12:30.481]             {
[16:12:30.481]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.481]                   0L) {
[16:12:30.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.481]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.481]                   base::options(opts)
[16:12:30.481]                 }
[16:12:30.481]                 {
[16:12:30.481]                   {
[16:12:30.481]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.481]                     NULL
[16:12:30.481]                   }
[16:12:30.481]                   options(future.plan = NULL)
[16:12:30.481]                   if (is.na(NA_character_)) 
[16:12:30.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.481]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.481]                     envir = parent.frame()) 
[16:12:30.481]                   {
[16:12:30.481]                     default_workers <- missing(workers)
[16:12:30.481]                     if (is.function(workers)) 
[16:12:30.481]                       workers <- workers()
[16:12:30.481]                     workers <- structure(as.integer(workers), 
[16:12:30.481]                       class = class(workers))
[16:12:30.481]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.481]                       1L)
[16:12:30.481]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.481]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.481]                       if (default_workers) 
[16:12:30.481]                         supportsMulticore(warn = TRUE)
[16:12:30.481]                       return(sequential(..., envir = envir))
[16:12:30.481]                     }
[16:12:30.481]                     oopts <- options(mc.cores = workers)
[16:12:30.481]                     on.exit(options(oopts))
[16:12:30.481]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.481]                       envir = envir)
[16:12:30.481]                     if (!future$lazy) 
[16:12:30.481]                       future <- run(future)
[16:12:30.481]                     invisible(future)
[16:12:30.481]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.481]                 }
[16:12:30.481]             }
[16:12:30.481]         }
[16:12:30.481]     })
[16:12:30.481]     if (TRUE) {
[16:12:30.481]         base::sink(type = "output", split = FALSE)
[16:12:30.481]         if (TRUE) {
[16:12:30.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.481]         }
[16:12:30.481]         else {
[16:12:30.481]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.481]         }
[16:12:30.481]         base::close(...future.stdout)
[16:12:30.481]         ...future.stdout <- NULL
[16:12:30.481]     }
[16:12:30.481]     ...future.result$conditions <- ...future.conditions
[16:12:30.481]     ...future.result$finished <- base::Sys.time()
[16:12:30.481]     ...future.result
[16:12:30.481] }
[16:12:30.485] requestCore(): workers = 2
[16:12:30.485] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:30.499] MulticoreFuture started
[16:12:30.500] - Launch lazy future ... done
[16:12:30.500] run() for ‘MulticoreFuture’ ... done
[16:12:30.501] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x560bb0b34088> 
[16:12:30.501] List of future strategies:
[16:12:30.501] 1. sequential:
[16:12:30.501]    - args: function (..., envir = parent.frame())
[16:12:30.501]    - tweaked: FALSE
[16:12:30.501]    - call: NULL
[16:12:30.502] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x560bad80ac08> 
 - attr(*, "dim.")=[16:12:30.505] plan(): Setting new future strategy stack:
[16:12:30.505] List of future strategies:
[16:12:30.505] 1. multicore:
[16:12:30.505]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.505]    - tweaked: FALSE
[16:12:30.505]    - call: plan(strategy)
 int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:12:30.513] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:30.517] resolve() on list environment ...
[16:12:30.517]  recursive: 0
[16:12:30.519]  length: 6
[16:12:30.519]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:30.519] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.519] - nx: 6
[16:12:30.519] - relay: TRUE
[16:12:30.520] - stdout: TRUE
[16:12:30.520] - signal: TRUE
[16:12:30.520] - resignal: FALSE
[16:12:30.520] - force: TRUE
[16:12:30.520] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.520] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.520]  - until=2
[16:12:30.521]  - relaying element #2
[16:12:30.521] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.521] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.521] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.521]  length: 5 (resolved future 1)
[16:12:30.521] Future #2
[16:12:30.522] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:30.522] - nx: 6
[16:12:30.522] - relay: TRUE
[16:12:30.522] - stdout: TRUE
[16:12:30.522] - signal: TRUE
[16:12:30.522] - resignal: FALSE
[16:12:30.522] - force: TRUE
[16:12:30.522] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.523] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.523]  - until=2
[16:12:30.523]  - relaying element #2
[16:12:30.523] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.523] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.523] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:30.524]  length: 4 (resolved future 2)
[16:12:30.524] Future #3
[16:12:30.525] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:30.525] - nx: 6
[16:12:30.525] - relay: TRUE
[16:12:30.525] - stdout: TRUE
[16:12:30.525] - signal: TRUE
[16:12:30.525] - resignal: FALSE
[16:12:30.526] - force: TRUE
[16:12:30.526] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.526] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.526]  - until=3
[16:12:30.526]  - relaying element #3
[16:12:30.526] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.527] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.527] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:30.527]  length: 3 (resolved future 3)
[16:12:30.527] Future #4
[16:12:30.528] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:30.528] - nx: 6
[16:12:30.528] - relay: TRUE
[16:12:30.529] - stdout: TRUE
[16:12:30.529] - signal: TRUE
[16:12:30.529] - resignal: FALSE
[16:12:30.529] - force: TRUE
[16:12:30.529] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.529] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.530]  - until=4
[16:12:30.530]  - relaying element #4
[16:12:30.530] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.530] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.531] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:30.531]  length: 2 (resolved future 4)
[16:12:30.531] signalConditionsASAP(NULL, pos=5) ...
[16:12:30.531] - nx: 6
[16:12:30.531] - relay: TRUE
[16:12:30.531] - stdout: TRUE
[16:12:30.532] - signal: TRUE
[16:12:30.532] - resignal: FALSE
[16:12:30.532] - force: TRUE
[16:12:30.532] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.532] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.532]  - until=6
[16:12:30.532]  - relaying element #6
[16:12:30.532] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.533] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.533] signalConditionsASAP(NULL, pos=5) ... done
[16:12:30.533]  length: 1 (resolved future 5)
[16:12:30.533] signalConditionsASAP(numeric, pos=6) ...
[16:12:30.533] - nx: 6
[16:12:30.533] - relay: TRUE
[16:12:30.533] - stdout: TRUE
[16:12:30.533] - signal: TRUE
[16:12:30.533] - resignal: FALSE
[16:12:30.534] - force: TRUE
[16:12:30.534] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.534] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.534]  - until=6
[16:12:30.534] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.534] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.534] signalConditionsASAP(numeric, pos=6) ... done
[16:12:30.534]  length: 0 (resolved future 6)
[16:12:30.534] Relaying remaining futures
[16:12:30.534] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.535] - nx: 6
[16:12:30.535] - relay: TRUE
[16:12:30.535] - stdout: TRUE
[16:12:30.535] - signal: TRUE
[16:12:30.535] - resignal: FALSE
[16:12:30.535] - force: TRUE
[16:12:30.535] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.535] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:30.535] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.535] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.536] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.536] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bac99f290> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:12:30.538] getGlobalsAndPackages() ...
[16:12:30.538] Searching for globals...
[16:12:30.539] 
[16:12:30.539] Searching for globals ... DONE
[16:12:30.539] - globals: [0] <none>
[16:12:30.539] getGlobalsAndPackages() ... DONE
[16:12:30.539] run() for ‘Future’ ...
[16:12:30.539] - state: ‘created’
[16:12:30.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.544] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.544] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.544]   - Field: ‘label’
[16:12:30.544]   - Field: ‘local’
[16:12:30.544]   - Field: ‘owner’
[16:12:30.544]   - Field: ‘envir’
[16:12:30.544]   - Field: ‘workers’
[16:12:30.545]   - Field: ‘packages’
[16:12:30.545]   - Field: ‘gc’
[16:12:30.545]   - Field: ‘job’
[16:12:30.545]   - Field: ‘conditions’
[16:12:30.545]   - Field: ‘expr’
[16:12:30.545]   - Field: ‘uuid’
[16:12:30.545]   - Field: ‘seed’
[16:12:30.545]   - Field: ‘version’
[16:12:30.545]   - Field: ‘result’
[16:12:30.546]   - Field: ‘asynchronous’
[16:12:30.546]   - Field: ‘calls’
[16:12:30.546]   - Field: ‘globals’
[16:12:30.546]   - Field: ‘stdout’
[16:12:30.546]   - Field: ‘earlySignal’
[16:12:30.546]   - Field: ‘lazy’
[16:12:30.546]   - Field: ‘state’
[16:12:30.546] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.546] - Launch lazy future ...
[16:12:30.547] Packages needed by the future expression (n = 0): <none>
[16:12:30.547] Packages needed by future strategies (n = 0): <none>
[16:12:30.547] {
[16:12:30.547]     {
[16:12:30.547]         {
[16:12:30.547]             ...future.startTime <- base::Sys.time()
[16:12:30.547]             {
[16:12:30.547]                 {
[16:12:30.547]                   {
[16:12:30.547]                     {
[16:12:30.547]                       base::local({
[16:12:30.547]                         has_future <- base::requireNamespace("future", 
[16:12:30.547]                           quietly = TRUE)
[16:12:30.547]                         if (has_future) {
[16:12:30.547]                           ns <- base::getNamespace("future")
[16:12:30.547]                           version <- ns[[".package"]][["version"]]
[16:12:30.547]                           if (is.null(version)) 
[16:12:30.547]                             version <- utils::packageVersion("future")
[16:12:30.547]                         }
[16:12:30.547]                         else {
[16:12:30.547]                           version <- NULL
[16:12:30.547]                         }
[16:12:30.547]                         if (!has_future || version < "1.8.0") {
[16:12:30.547]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.547]                             "", base::R.version$version.string), 
[16:12:30.547]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.547]                               "release", "version")], collapse = " "), 
[16:12:30.547]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.547]                             info)
[16:12:30.547]                           info <- base::paste(info, collapse = "; ")
[16:12:30.547]                           if (!has_future) {
[16:12:30.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.547]                               info)
[16:12:30.547]                           }
[16:12:30.547]                           else {
[16:12:30.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.547]                               info, version)
[16:12:30.547]                           }
[16:12:30.547]                           base::stop(msg)
[16:12:30.547]                         }
[16:12:30.547]                       })
[16:12:30.547]                     }
[16:12:30.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.547]                     base::options(mc.cores = 1L)
[16:12:30.547]                   }
[16:12:30.547]                   options(future.plan = NULL)
[16:12:30.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.547]                 }
[16:12:30.547]                 ...future.workdir <- getwd()
[16:12:30.547]             }
[16:12:30.547]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.547]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.547]         }
[16:12:30.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.547]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.547]             base::names(...future.oldOptions))
[16:12:30.547]     }
[16:12:30.547]     if (FALSE) {
[16:12:30.547]     }
[16:12:30.547]     else {
[16:12:30.547]         if (TRUE) {
[16:12:30.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.547]                 open = "w")
[16:12:30.547]         }
[16:12:30.547]         else {
[16:12:30.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.547]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.547]         }
[16:12:30.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.547]             base::sink(type = "output", split = FALSE)
[16:12:30.547]             base::close(...future.stdout)
[16:12:30.547]         }, add = TRUE)
[16:12:30.547]     }
[16:12:30.547]     ...future.frame <- base::sys.nframe()
[16:12:30.547]     ...future.conditions <- base::list()
[16:12:30.547]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.547]     if (FALSE) {
[16:12:30.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.547]     }
[16:12:30.547]     ...future.result <- base::tryCatch({
[16:12:30.547]         base::withCallingHandlers({
[16:12:30.547]             ...future.value <- base::withVisible(base::local({
[16:12:30.547]                 withCallingHandlers({
[16:12:30.547]                   2
[16:12:30.547]                 }, immediateCondition = function(cond) {
[16:12:30.547]                   save_rds <- function (object, pathname, ...) 
[16:12:30.547]                   {
[16:12:30.547]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.547]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.547]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.547]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.547]                         fi_tmp[["mtime"]])
[16:12:30.547]                     }
[16:12:30.547]                     tryCatch({
[16:12:30.547]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.547]                     }, error = function(ex) {
[16:12:30.547]                       msg <- conditionMessage(ex)
[16:12:30.547]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.547]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.547]                         fi_tmp[["mtime"]], msg)
[16:12:30.547]                       ex$message <- msg
[16:12:30.547]                       stop(ex)
[16:12:30.547]                     })
[16:12:30.547]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.547]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.547]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.547]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.547]                       fi <- file.info(pathname)
[16:12:30.547]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.547]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.547]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.547]                         fi[["size"]], fi[["mtime"]])
[16:12:30.547]                       stop(msg)
[16:12:30.547]                     }
[16:12:30.547]                     invisible(pathname)
[16:12:30.547]                   }
[16:12:30.547]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.547]                     rootPath = tempdir()) 
[16:12:30.547]                   {
[16:12:30.547]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.547]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.547]                       tmpdir = path, fileext = ".rds")
[16:12:30.547]                     save_rds(obj, file)
[16:12:30.547]                   }
[16:12:30.547]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.547]                   {
[16:12:30.547]                     inherits <- base::inherits
[16:12:30.547]                     invokeRestart <- base::invokeRestart
[16:12:30.547]                     is.null <- base::is.null
[16:12:30.547]                     muffled <- FALSE
[16:12:30.547]                     if (inherits(cond, "message")) {
[16:12:30.547]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.547]                       if (muffled) 
[16:12:30.547]                         invokeRestart("muffleMessage")
[16:12:30.547]                     }
[16:12:30.547]                     else if (inherits(cond, "warning")) {
[16:12:30.547]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.547]                       if (muffled) 
[16:12:30.547]                         invokeRestart("muffleWarning")
[16:12:30.547]                     }
[16:12:30.547]                     else if (inherits(cond, "condition")) {
[16:12:30.547]                       if (!is.null(pattern)) {
[16:12:30.547]                         computeRestarts <- base::computeRestarts
[16:12:30.547]                         grepl <- base::grepl
[16:12:30.547]                         restarts <- computeRestarts(cond)
[16:12:30.547]                         for (restart in restarts) {
[16:12:30.547]                           name <- restart$name
[16:12:30.547]                           if (is.null(name)) 
[16:12:30.547]                             next
[16:12:30.547]                           if (!grepl(pattern, name)) 
[16:12:30.547]                             next
[16:12:30.547]                           invokeRestart(restart)
[16:12:30.547]                           muffled <- TRUE
[16:12:30.547]                           break
[16:12:30.547]                         }
[16:12:30.547]                       }
[16:12:30.547]                     }
[16:12:30.547]                     invisible(muffled)
[16:12:30.547]                   }
[16:12:30.547]                   muffleCondition(cond)
[16:12:30.547]                 })
[16:12:30.547]             }))
[16:12:30.547]             future::FutureResult(value = ...future.value$value, 
[16:12:30.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.547]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.547]                     ...future.globalenv.names))
[16:12:30.547]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.547]         }, condition = base::local({
[16:12:30.547]             c <- base::c
[16:12:30.547]             inherits <- base::inherits
[16:12:30.547]             invokeRestart <- base::invokeRestart
[16:12:30.547]             length <- base::length
[16:12:30.547]             list <- base::list
[16:12:30.547]             seq.int <- base::seq.int
[16:12:30.547]             signalCondition <- base::signalCondition
[16:12:30.547]             sys.calls <- base::sys.calls
[16:12:30.547]             `[[` <- base::`[[`
[16:12:30.547]             `+` <- base::`+`
[16:12:30.547]             `<<-` <- base::`<<-`
[16:12:30.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.547]                   3L)]
[16:12:30.547]             }
[16:12:30.547]             function(cond) {
[16:12:30.547]                 is_error <- inherits(cond, "error")
[16:12:30.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.547]                   NULL)
[16:12:30.547]                 if (is_error) {
[16:12:30.547]                   sessionInformation <- function() {
[16:12:30.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.547]                       search = base::search(), system = base::Sys.info())
[16:12:30.547]                   }
[16:12:30.547]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.547]                     cond$call), session = sessionInformation(), 
[16:12:30.547]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.547]                   signalCondition(cond)
[16:12:30.547]                 }
[16:12:30.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.547]                 "immediateCondition"))) {
[16:12:30.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.547]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.547]                   if (TRUE && !signal) {
[16:12:30.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.547]                     {
[16:12:30.547]                       inherits <- base::inherits
[16:12:30.547]                       invokeRestart <- base::invokeRestart
[16:12:30.547]                       is.null <- base::is.null
[16:12:30.547]                       muffled <- FALSE
[16:12:30.547]                       if (inherits(cond, "message")) {
[16:12:30.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.547]                         if (muffled) 
[16:12:30.547]                           invokeRestart("muffleMessage")
[16:12:30.547]                       }
[16:12:30.547]                       else if (inherits(cond, "warning")) {
[16:12:30.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.547]                         if (muffled) 
[16:12:30.547]                           invokeRestart("muffleWarning")
[16:12:30.547]                       }
[16:12:30.547]                       else if (inherits(cond, "condition")) {
[16:12:30.547]                         if (!is.null(pattern)) {
[16:12:30.547]                           computeRestarts <- base::computeRestarts
[16:12:30.547]                           grepl <- base::grepl
[16:12:30.547]                           restarts <- computeRestarts(cond)
[16:12:30.547]                           for (restart in restarts) {
[16:12:30.547]                             name <- restart$name
[16:12:30.547]                             if (is.null(name)) 
[16:12:30.547]                               next
[16:12:30.547]                             if (!grepl(pattern, name)) 
[16:12:30.547]                               next
[16:12:30.547]                             invokeRestart(restart)
[16:12:30.547]                             muffled <- TRUE
[16:12:30.547]                             break
[16:12:30.547]                           }
[16:12:30.547]                         }
[16:12:30.547]                       }
[16:12:30.547]                       invisible(muffled)
[16:12:30.547]                     }
[16:12:30.547]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.547]                   }
[16:12:30.547]                 }
[16:12:30.547]                 else {
[16:12:30.547]                   if (TRUE) {
[16:12:30.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.547]                     {
[16:12:30.547]                       inherits <- base::inherits
[16:12:30.547]                       invokeRestart <- base::invokeRestart
[16:12:30.547]                       is.null <- base::is.null
[16:12:30.547]                       muffled <- FALSE
[16:12:30.547]                       if (inherits(cond, "message")) {
[16:12:30.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.547]                         if (muffled) 
[16:12:30.547]                           invokeRestart("muffleMessage")
[16:12:30.547]                       }
[16:12:30.547]                       else if (inherits(cond, "warning")) {
[16:12:30.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.547]                         if (muffled) 
[16:12:30.547]                           invokeRestart("muffleWarning")
[16:12:30.547]                       }
[16:12:30.547]                       else if (inherits(cond, "condition")) {
[16:12:30.547]                         if (!is.null(pattern)) {
[16:12:30.547]                           computeRestarts <- base::computeRestarts
[16:12:30.547]                           grepl <- base::grepl
[16:12:30.547]                           restarts <- computeRestarts(cond)
[16:12:30.547]                           for (restart in restarts) {
[16:12:30.547]                             name <- restart$name
[16:12:30.547]                             if (is.null(name)) 
[16:12:30.547]                               next
[16:12:30.547]                             if (!grepl(pattern, name)) 
[16:12:30.547]                               next
[16:12:30.547]                             invokeRestart(restart)
[16:12:30.547]                             muffled <- TRUE
[16:12:30.547]                             break
[16:12:30.547]                           }
[16:12:30.547]                         }
[16:12:30.547]                       }
[16:12:30.547]                       invisible(muffled)
[16:12:30.547]                     }
[16:12:30.547]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.547]                   }
[16:12:30.547]                 }
[16:12:30.547]             }
[16:12:30.547]         }))
[16:12:30.547]     }, error = function(ex) {
[16:12:30.547]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.547]                 ...future.rng), started = ...future.startTime, 
[16:12:30.547]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.547]             version = "1.8"), class = "FutureResult")
[16:12:30.547]     }, finally = {
[16:12:30.547]         if (!identical(...future.workdir, getwd())) 
[16:12:30.547]             setwd(...future.workdir)
[16:12:30.547]         {
[16:12:30.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.547]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.547]             }
[16:12:30.547]             base::options(...future.oldOptions)
[16:12:30.547]             if (.Platform$OS.type == "windows") {
[16:12:30.547]                 old_names <- names(...future.oldEnvVars)
[16:12:30.547]                 envs <- base::Sys.getenv()
[16:12:30.547]                 names <- names(envs)
[16:12:30.547]                 common <- intersect(names, old_names)
[16:12:30.547]                 added <- setdiff(names, old_names)
[16:12:30.547]                 removed <- setdiff(old_names, names)
[16:12:30.547]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.547]                   envs[common]]
[16:12:30.547]                 NAMES <- toupper(changed)
[16:12:30.547]                 args <- list()
[16:12:30.547]                 for (kk in seq_along(NAMES)) {
[16:12:30.547]                   name <- changed[[kk]]
[16:12:30.547]                   NAME <- NAMES[[kk]]
[16:12:30.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.547]                     next
[16:12:30.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.547]                 }
[16:12:30.547]                 NAMES <- toupper(added)
[16:12:30.547]                 for (kk in seq_along(NAMES)) {
[16:12:30.547]                   name <- added[[kk]]
[16:12:30.547]                   NAME <- NAMES[[kk]]
[16:12:30.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.547]                     next
[16:12:30.547]                   args[[name]] <- ""
[16:12:30.547]                 }
[16:12:30.547]                 NAMES <- toupper(removed)
[16:12:30.547]                 for (kk in seq_along(NAMES)) {
[16:12:30.547]                   name <- removed[[kk]]
[16:12:30.547]                   NAME <- NAMES[[kk]]
[16:12:30.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.547]                     next
[16:12:30.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.547]                 }
[16:12:30.547]                 if (length(args) > 0) 
[16:12:30.547]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.547]             }
[16:12:30.547]             else {
[16:12:30.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.547]             }
[16:12:30.547]             {
[16:12:30.547]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.547]                   0L) {
[16:12:30.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.547]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.547]                   base::options(opts)
[16:12:30.547]                 }
[16:12:30.547]                 {
[16:12:30.547]                   {
[16:12:30.547]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.547]                     NULL
[16:12:30.547]                   }
[16:12:30.547]                   options(future.plan = NULL)
[16:12:30.547]                   if (is.na(NA_character_)) 
[16:12:30.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.547]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.547]                     envir = parent.frame()) 
[16:12:30.547]                   {
[16:12:30.547]                     default_workers <- missing(workers)
[16:12:30.547]                     if (is.function(workers)) 
[16:12:30.547]                       workers <- workers()
[16:12:30.547]                     workers <- structure(as.integer(workers), 
[16:12:30.547]                       class = class(workers))
[16:12:30.547]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.547]                       1L)
[16:12:30.547]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.547]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.547]                       if (default_workers) 
[16:12:30.547]                         supportsMulticore(warn = TRUE)
[16:12:30.547]                       return(sequential(..., envir = envir))
[16:12:30.547]                     }
[16:12:30.547]                     oopts <- options(mc.cores = workers)
[16:12:30.547]                     on.exit(options(oopts))
[16:12:30.547]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.547]                       envir = envir)
[16:12:30.547]                     if (!future$lazy) 
[16:12:30.547]                       future <- run(future)
[16:12:30.547]                     invisible(future)
[16:12:30.547]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.547]                 }
[16:12:30.547]             }
[16:12:30.547]         }
[16:12:30.547]     })
[16:12:30.547]     if (TRUE) {
[16:12:30.547]         base::sink(type = "output", split = FALSE)
[16:12:30.547]         if (TRUE) {
[16:12:30.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.547]         }
[16:12:30.547]         else {
[16:12:30.547]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.547]         }
[16:12:30.547]         base::close(...future.stdout)
[16:12:30.547]         ...future.stdout <- NULL
[16:12:30.547]     }
[16:12:30.547]     ...future.result$conditions <- ...future.conditions
[16:12:30.547]     ...future.result$finished <- base::Sys.time()
[16:12:30.547]     ...future.result
[16:12:30.547] }
[16:12:30.550] requestCore(): workers = 2
[16:12:30.552] MulticoreFuture started
[16:12:30.553] - Launch lazy future ... done
[16:12:30.553] run() for ‘MulticoreFuture’ ... done
[16:12:30.553] getGlobalsAndPackages() ...
[16:12:30.553] Searching for globals...
[16:12:30.553] plan(): Setting new future strategy stack:
[16:12:30.554] 
[16:12:30.554] List of future strategies:
[16:12:30.554] 1. sequential:
[16:12:30.554]    - args: function (..., envir = parent.frame())
[16:12:30.554]    - tweaked: FALSE
[16:12:30.554]    - call: NULL
[16:12:30.554] Searching for globals ... DONE
[16:12:30.555] plan(): nbrOfWorkers() = 1
[16:12:30.555] - globals: [0] <none>
[16:12:30.555] getGlobalsAndPackages() ... DONE
[16:12:30.555] run() for ‘Future’ ...
[16:12:30.555] - state: ‘created’
[16:12:30.556] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.557] plan(): Setting new future strategy stack:
[16:12:30.557] List of future strategies:
[16:12:30.557] 1. multicore:
[16:12:30.557]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.557]    - tweaked: FALSE
[16:12:30.557]    - call: plan(strategy)
[16:12:30.561] plan(): nbrOfWorkers() = 2
[16:12:30.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.561]   - Field: ‘label’
[16:12:30.561]   - Field: ‘local’
[16:12:30.562]   - Field: ‘owner’
[16:12:30.562]   - Field: ‘envir’
[16:12:30.562]   - Field: ‘workers’
[16:12:30.562]   - Field: ‘packages’
[16:12:30.562]   - Field: ‘gc’
[16:12:30.562]   - Field: ‘job’
[16:12:30.562]   - Field: ‘conditions’
[16:12:30.563]   - Field: ‘expr’
[16:12:30.563]   - Field: ‘uuid’
[16:12:30.563]   - Field: ‘seed’
[16:12:30.563]   - Field: ‘version’
[16:12:30.563]   - Field: ‘result’
[16:12:30.563]   - Field: ‘asynchronous’
[16:12:30.563]   - Field: ‘calls’
[16:12:30.564]   - Field: ‘globals’
[16:12:30.564]   - Field: ‘stdout’
[16:12:30.564]   - Field: ‘earlySignal’
[16:12:30.564]   - Field: ‘lazy’
[16:12:30.564]   - Field: ‘state’
[16:12:30.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.564] - Launch lazy future ...
[16:12:30.565] Packages needed by the future expression (n = 0): <none>
[16:12:30.565] Packages needed by future strategies (n = 0): <none>
[16:12:30.566] {
[16:12:30.566]     {
[16:12:30.566]         {
[16:12:30.566]             ...future.startTime <- base::Sys.time()
[16:12:30.566]             {
[16:12:30.566]                 {
[16:12:30.566]                   {
[16:12:30.566]                     {
[16:12:30.566]                       base::local({
[16:12:30.566]                         has_future <- base::requireNamespace("future", 
[16:12:30.566]                           quietly = TRUE)
[16:12:30.566]                         if (has_future) {
[16:12:30.566]                           ns <- base::getNamespace("future")
[16:12:30.566]                           version <- ns[[".package"]][["version"]]
[16:12:30.566]                           if (is.null(version)) 
[16:12:30.566]                             version <- utils::packageVersion("future")
[16:12:30.566]                         }
[16:12:30.566]                         else {
[16:12:30.566]                           version <- NULL
[16:12:30.566]                         }
[16:12:30.566]                         if (!has_future || version < "1.8.0") {
[16:12:30.566]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.566]                             "", base::R.version$version.string), 
[16:12:30.566]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.566]                               "release", "version")], collapse = " "), 
[16:12:30.566]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.566]                             info)
[16:12:30.566]                           info <- base::paste(info, collapse = "; ")
[16:12:30.566]                           if (!has_future) {
[16:12:30.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.566]                               info)
[16:12:30.566]                           }
[16:12:30.566]                           else {
[16:12:30.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.566]                               info, version)
[16:12:30.566]                           }
[16:12:30.566]                           base::stop(msg)
[16:12:30.566]                         }
[16:12:30.566]                       })
[16:12:30.566]                     }
[16:12:30.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.566]                     base::options(mc.cores = 1L)
[16:12:30.566]                   }
[16:12:30.566]                   options(future.plan = NULL)
[16:12:30.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.566]                 }
[16:12:30.566]                 ...future.workdir <- getwd()
[16:12:30.566]             }
[16:12:30.566]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.566]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.566]         }
[16:12:30.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.566]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.566]             base::names(...future.oldOptions))
[16:12:30.566]     }
[16:12:30.566]     if (FALSE) {
[16:12:30.566]     }
[16:12:30.566]     else {
[16:12:30.566]         if (TRUE) {
[16:12:30.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.566]                 open = "w")
[16:12:30.566]         }
[16:12:30.566]         else {
[16:12:30.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.566]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.566]         }
[16:12:30.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.566]             base::sink(type = "output", split = FALSE)
[16:12:30.566]             base::close(...future.stdout)
[16:12:30.566]         }, add = TRUE)
[16:12:30.566]     }
[16:12:30.566]     ...future.frame <- base::sys.nframe()
[16:12:30.566]     ...future.conditions <- base::list()
[16:12:30.566]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.566]     if (FALSE) {
[16:12:30.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.566]     }
[16:12:30.566]     ...future.result <- base::tryCatch({
[16:12:30.566]         base::withCallingHandlers({
[16:12:30.566]             ...future.value <- base::withVisible(base::local({
[16:12:30.566]                 withCallingHandlers({
[16:12:30.566]                   NULL
[16:12:30.566]                 }, immediateCondition = function(cond) {
[16:12:30.566]                   save_rds <- function (object, pathname, ...) 
[16:12:30.566]                   {
[16:12:30.566]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.566]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.566]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.566]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.566]                         fi_tmp[["mtime"]])
[16:12:30.566]                     }
[16:12:30.566]                     tryCatch({
[16:12:30.566]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.566]                     }, error = function(ex) {
[16:12:30.566]                       msg <- conditionMessage(ex)
[16:12:30.566]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.566]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.566]                         fi_tmp[["mtime"]], msg)
[16:12:30.566]                       ex$message <- msg
[16:12:30.566]                       stop(ex)
[16:12:30.566]                     })
[16:12:30.566]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.566]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.566]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.566]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.566]                       fi <- file.info(pathname)
[16:12:30.566]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.566]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.566]                         fi[["size"]], fi[["mtime"]])
[16:12:30.566]                       stop(msg)
[16:12:30.566]                     }
[16:12:30.566]                     invisible(pathname)
[16:12:30.566]                   }
[16:12:30.566]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.566]                     rootPath = tempdir()) 
[16:12:30.566]                   {
[16:12:30.566]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.566]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.566]                       tmpdir = path, fileext = ".rds")
[16:12:30.566]                     save_rds(obj, file)
[16:12:30.566]                   }
[16:12:30.566]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.566]                   {
[16:12:30.566]                     inherits <- base::inherits
[16:12:30.566]                     invokeRestart <- base::invokeRestart
[16:12:30.566]                     is.null <- base::is.null
[16:12:30.566]                     muffled <- FALSE
[16:12:30.566]                     if (inherits(cond, "message")) {
[16:12:30.566]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.566]                       if (muffled) 
[16:12:30.566]                         invokeRestart("muffleMessage")
[16:12:30.566]                     }
[16:12:30.566]                     else if (inherits(cond, "warning")) {
[16:12:30.566]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.566]                       if (muffled) 
[16:12:30.566]                         invokeRestart("muffleWarning")
[16:12:30.566]                     }
[16:12:30.566]                     else if (inherits(cond, "condition")) {
[16:12:30.566]                       if (!is.null(pattern)) {
[16:12:30.566]                         computeRestarts <- base::computeRestarts
[16:12:30.566]                         grepl <- base::grepl
[16:12:30.566]                         restarts <- computeRestarts(cond)
[16:12:30.566]                         for (restart in restarts) {
[16:12:30.566]                           name <- restart$name
[16:12:30.566]                           if (is.null(name)) 
[16:12:30.566]                             next
[16:12:30.566]                           if (!grepl(pattern, name)) 
[16:12:30.566]                             next
[16:12:30.566]                           invokeRestart(restart)
[16:12:30.566]                           muffled <- TRUE
[16:12:30.566]                           break
[16:12:30.566]                         }
[16:12:30.566]                       }
[16:12:30.566]                     }
[16:12:30.566]                     invisible(muffled)
[16:12:30.566]                   }
[16:12:30.566]                   muffleCondition(cond)
[16:12:30.566]                 })
[16:12:30.566]             }))
[16:12:30.566]             future::FutureResult(value = ...future.value$value, 
[16:12:30.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.566]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.566]                     ...future.globalenv.names))
[16:12:30.566]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.566]         }, condition = base::local({
[16:12:30.566]             c <- base::c
[16:12:30.566]             inherits <- base::inherits
[16:12:30.566]             invokeRestart <- base::invokeRestart
[16:12:30.566]             length <- base::length
[16:12:30.566]             list <- base::list
[16:12:30.566]             seq.int <- base::seq.int
[16:12:30.566]             signalCondition <- base::signalCondition
[16:12:30.566]             sys.calls <- base::sys.calls
[16:12:30.566]             `[[` <- base::`[[`
[16:12:30.566]             `+` <- base::`+`
[16:12:30.566]             `<<-` <- base::`<<-`
[16:12:30.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.566]                   3L)]
[16:12:30.566]             }
[16:12:30.566]             function(cond) {
[16:12:30.566]                 is_error <- inherits(cond, "error")
[16:12:30.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.566]                   NULL)
[16:12:30.566]                 if (is_error) {
[16:12:30.566]                   sessionInformation <- function() {
[16:12:30.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.566]                       search = base::search(), system = base::Sys.info())
[16:12:30.566]                   }
[16:12:30.566]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.566]                     cond$call), session = sessionInformation(), 
[16:12:30.566]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.566]                   signalCondition(cond)
[16:12:30.566]                 }
[16:12:30.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.566]                 "immediateCondition"))) {
[16:12:30.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.566]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.566]                   if (TRUE && !signal) {
[16:12:30.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.566]                     {
[16:12:30.566]                       inherits <- base::inherits
[16:12:30.566]                       invokeRestart <- base::invokeRestart
[16:12:30.566]                       is.null <- base::is.null
[16:12:30.566]                       muffled <- FALSE
[16:12:30.566]                       if (inherits(cond, "message")) {
[16:12:30.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.566]                         if (muffled) 
[16:12:30.566]                           invokeRestart("muffleMessage")
[16:12:30.566]                       }
[16:12:30.566]                       else if (inherits(cond, "warning")) {
[16:12:30.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.566]                         if (muffled) 
[16:12:30.566]                           invokeRestart("muffleWarning")
[16:12:30.566]                       }
[16:12:30.566]                       else if (inherits(cond, "condition")) {
[16:12:30.566]                         if (!is.null(pattern)) {
[16:12:30.566]                           computeRestarts <- base::computeRestarts
[16:12:30.566]                           grepl <- base::grepl
[16:12:30.566]                           restarts <- computeRestarts(cond)
[16:12:30.566]                           for (restart in restarts) {
[16:12:30.566]                             name <- restart$name
[16:12:30.566]                             if (is.null(name)) 
[16:12:30.566]                               next
[16:12:30.566]                             if (!grepl(pattern, name)) 
[16:12:30.566]                               next
[16:12:30.566]                             invokeRestart(restart)
[16:12:30.566]                             muffled <- TRUE
[16:12:30.566]                             break
[16:12:30.566]                           }
[16:12:30.566]                         }
[16:12:30.566]                       }
[16:12:30.566]                       invisible(muffled)
[16:12:30.566]                     }
[16:12:30.566]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.566]                   }
[16:12:30.566]                 }
[16:12:30.566]                 else {
[16:12:30.566]                   if (TRUE) {
[16:12:30.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.566]                     {
[16:12:30.566]                       inherits <- base::inherits
[16:12:30.566]                       invokeRestart <- base::invokeRestart
[16:12:30.566]                       is.null <- base::is.null
[16:12:30.566]                       muffled <- FALSE
[16:12:30.566]                       if (inherits(cond, "message")) {
[16:12:30.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.566]                         if (muffled) 
[16:12:30.566]                           invokeRestart("muffleMessage")
[16:12:30.566]                       }
[16:12:30.566]                       else if (inherits(cond, "warning")) {
[16:12:30.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.566]                         if (muffled) 
[16:12:30.566]                           invokeRestart("muffleWarning")
[16:12:30.566]                       }
[16:12:30.566]                       else if (inherits(cond, "condition")) {
[16:12:30.566]                         if (!is.null(pattern)) {
[16:12:30.566]                           computeRestarts <- base::computeRestarts
[16:12:30.566]                           grepl <- base::grepl
[16:12:30.566]                           restarts <- computeRestarts(cond)
[16:12:30.566]                           for (restart in restarts) {
[16:12:30.566]                             name <- restart$name
[16:12:30.566]                             if (is.null(name)) 
[16:12:30.566]                               next
[16:12:30.566]                             if (!grepl(pattern, name)) 
[16:12:30.566]                               next
[16:12:30.566]                             invokeRestart(restart)
[16:12:30.566]                             muffled <- TRUE
[16:12:30.566]                             break
[16:12:30.566]                           }
[16:12:30.566]                         }
[16:12:30.566]                       }
[16:12:30.566]                       invisible(muffled)
[16:12:30.566]                     }
[16:12:30.566]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.566]                   }
[16:12:30.566]                 }
[16:12:30.566]             }
[16:12:30.566]         }))
[16:12:30.566]     }, error = function(ex) {
[16:12:30.566]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.566]                 ...future.rng), started = ...future.startTime, 
[16:12:30.566]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.566]             version = "1.8"), class = "FutureResult")
[16:12:30.566]     }, finally = {
[16:12:30.566]         if (!identical(...future.workdir, getwd())) 
[16:12:30.566]             setwd(...future.workdir)
[16:12:30.566]         {
[16:12:30.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.566]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.566]             }
[16:12:30.566]             base::options(...future.oldOptions)
[16:12:30.566]             if (.Platform$OS.type == "windows") {
[16:12:30.566]                 old_names <- names(...future.oldEnvVars)
[16:12:30.566]                 envs <- base::Sys.getenv()
[16:12:30.566]                 names <- names(envs)
[16:12:30.566]                 common <- intersect(names, old_names)
[16:12:30.566]                 added <- setdiff(names, old_names)
[16:12:30.566]                 removed <- setdiff(old_names, names)
[16:12:30.566]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.566]                   envs[common]]
[16:12:30.566]                 NAMES <- toupper(changed)
[16:12:30.566]                 args <- list()
[16:12:30.566]                 for (kk in seq_along(NAMES)) {
[16:12:30.566]                   name <- changed[[kk]]
[16:12:30.566]                   NAME <- NAMES[[kk]]
[16:12:30.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.566]                     next
[16:12:30.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.566]                 }
[16:12:30.566]                 NAMES <- toupper(added)
[16:12:30.566]                 for (kk in seq_along(NAMES)) {
[16:12:30.566]                   name <- added[[kk]]
[16:12:30.566]                   NAME <- NAMES[[kk]]
[16:12:30.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.566]                     next
[16:12:30.566]                   args[[name]] <- ""
[16:12:30.566]                 }
[16:12:30.566]                 NAMES <- toupper(removed)
[16:12:30.566]                 for (kk in seq_along(NAMES)) {
[16:12:30.566]                   name <- removed[[kk]]
[16:12:30.566]                   NAME <- NAMES[[kk]]
[16:12:30.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.566]                     next
[16:12:30.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.566]                 }
[16:12:30.566]                 if (length(args) > 0) 
[16:12:30.566]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.566]             }
[16:12:30.566]             else {
[16:12:30.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.566]             }
[16:12:30.566]             {
[16:12:30.566]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.566]                   0L) {
[16:12:30.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.566]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.566]                   base::options(opts)
[16:12:30.566]                 }
[16:12:30.566]                 {
[16:12:30.566]                   {
[16:12:30.566]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.566]                     NULL
[16:12:30.566]                   }
[16:12:30.566]                   options(future.plan = NULL)
[16:12:30.566]                   if (is.na(NA_character_)) 
[16:12:30.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.566]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.566]                     envir = parent.frame()) 
[16:12:30.566]                   {
[16:12:30.566]                     default_workers <- missing(workers)
[16:12:30.566]                     if (is.function(workers)) 
[16:12:30.566]                       workers <- workers()
[16:12:30.566]                     workers <- structure(as.integer(workers), 
[16:12:30.566]                       class = class(workers))
[16:12:30.566]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.566]                       1L)
[16:12:30.566]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.566]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.566]                       if (default_workers) 
[16:12:30.566]                         supportsMulticore(warn = TRUE)
[16:12:30.566]                       return(sequential(..., envir = envir))
[16:12:30.566]                     }
[16:12:30.566]                     oopts <- options(mc.cores = workers)
[16:12:30.566]                     on.exit(options(oopts))
[16:12:30.566]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.566]                       envir = envir)
[16:12:30.566]                     if (!future$lazy) 
[16:12:30.566]                       future <- run(future)
[16:12:30.566]                     invisible(future)
[16:12:30.566]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.566]                 }
[16:12:30.566]             }
[16:12:30.566]         }
[16:12:30.566]     })
[16:12:30.566]     if (TRUE) {
[16:12:30.566]         base::sink(type = "output", split = FALSE)
[16:12:30.566]         if (TRUE) {
[16:12:30.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.566]         }
[16:12:30.566]         else {
[16:12:30.566]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.566]         }
[16:12:30.566]         base::close(...future.stdout)
[16:12:30.566]         ...future.stdout <- NULL
[16:12:30.566]     }
[16:12:30.566]     ...future.result$conditions <- ...future.conditions
[16:12:30.566]     ...future.result$finished <- base::Sys.time()
[16:12:30.566]     ...future.result
[16:12:30.566] }
[16:12:30.569] requestCore(): workers = 2
[16:12:30.572] MulticoreFuture started
[16:12:30.572] - Launch lazy future ... done
[16:12:30.572] run() for ‘MulticoreFuture’ ... done
[16:12:30.573] plan(): Setting new future strategy stack:
[16:12:30.573] getGlobalsAndPackages() ...
[16:12:30.573] Searching for globals...
[16:12:30.573] List of future strategies:
[16:12:30.573] 1. sequential:
[16:12:30.573]    - args: function (..., envir = parent.frame())
[16:12:30.573]    - tweaked: FALSE
[16:12:30.573]    - call: NULL
[16:12:30.574] plan(): nbrOfWorkers() = 1
[16:12:30.575] - globals found: [1] ‘{’
[16:12:30.575] Searching for globals ... DONE
[16:12:30.575] Resolving globals: FALSE
[16:12:30.575] 
[16:12:30.576] 
[16:12:30.576] plan(): Setting new future strategy stack:
[16:12:30.576] getGlobalsAndPackages() ... DONE
[16:12:30.576] List of future strategies:
[16:12:30.576] 1. multicore:
[16:12:30.576]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.576]    - tweaked: FALSE
[16:12:30.576]    - call: plan(strategy)
[16:12:30.576] run() for ‘Future’ ...
[16:12:30.576] - state: ‘created’
[16:12:30.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.581] plan(): nbrOfWorkers() = 2
[16:12:30.581] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.582]   - Field: ‘label’
[16:12:30.582]   - Field: ‘local’
[16:12:30.582]   - Field: ‘owner’
[16:12:30.582]   - Field: ‘envir’
[16:12:30.582]   - Field: ‘workers’
[16:12:30.582]   - Field: ‘packages’
[16:12:30.583]   - Field: ‘gc’
[16:12:30.583]   - Field: ‘job’
[16:12:30.583]   - Field: ‘conditions’
[16:12:30.583]   - Field: ‘expr’
[16:12:30.583]   - Field: ‘uuid’
[16:12:30.583]   - Field: ‘seed’
[16:12:30.583]   - Field: ‘version’
[16:12:30.584]   - Field: ‘result’
[16:12:30.584]   - Field: ‘asynchronous’
[16:12:30.584]   - Field: ‘calls’
[16:12:30.584]   - Field: ‘globals’
[16:12:30.584]   - Field: ‘stdout’
[16:12:30.584]   - Field: ‘earlySignal’
[16:12:30.584]   - Field: ‘lazy’
[16:12:30.585]   - Field: ‘state’
[16:12:30.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.585] - Launch lazy future ...
[16:12:30.585] Packages needed by the future expression (n = 0): <none>
[16:12:30.586] Packages needed by future strategies (n = 0): <none>
[16:12:30.586] {
[16:12:30.586]     {
[16:12:30.586]         {
[16:12:30.586]             ...future.startTime <- base::Sys.time()
[16:12:30.586]             {
[16:12:30.586]                 {
[16:12:30.586]                   {
[16:12:30.586]                     {
[16:12:30.586]                       base::local({
[16:12:30.586]                         has_future <- base::requireNamespace("future", 
[16:12:30.586]                           quietly = TRUE)
[16:12:30.586]                         if (has_future) {
[16:12:30.586]                           ns <- base::getNamespace("future")
[16:12:30.586]                           version <- ns[[".package"]][["version"]]
[16:12:30.586]                           if (is.null(version)) 
[16:12:30.586]                             version <- utils::packageVersion("future")
[16:12:30.586]                         }
[16:12:30.586]                         else {
[16:12:30.586]                           version <- NULL
[16:12:30.586]                         }
[16:12:30.586]                         if (!has_future || version < "1.8.0") {
[16:12:30.586]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.586]                             "", base::R.version$version.string), 
[16:12:30.586]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.586]                               "release", "version")], collapse = " "), 
[16:12:30.586]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.586]                             info)
[16:12:30.586]                           info <- base::paste(info, collapse = "; ")
[16:12:30.586]                           if (!has_future) {
[16:12:30.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.586]                               info)
[16:12:30.586]                           }
[16:12:30.586]                           else {
[16:12:30.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.586]                               info, version)
[16:12:30.586]                           }
[16:12:30.586]                           base::stop(msg)
[16:12:30.586]                         }
[16:12:30.586]                       })
[16:12:30.586]                     }
[16:12:30.586]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.586]                     base::options(mc.cores = 1L)
[16:12:30.586]                   }
[16:12:30.586]                   options(future.plan = NULL)
[16:12:30.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.586]                 }
[16:12:30.586]                 ...future.workdir <- getwd()
[16:12:30.586]             }
[16:12:30.586]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.586]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.586]         }
[16:12:30.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.586]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.586]             base::names(...future.oldOptions))
[16:12:30.586]     }
[16:12:30.586]     if (FALSE) {
[16:12:30.586]     }
[16:12:30.586]     else {
[16:12:30.586]         if (TRUE) {
[16:12:30.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.586]                 open = "w")
[16:12:30.586]         }
[16:12:30.586]         else {
[16:12:30.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.586]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.586]         }
[16:12:30.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.586]             base::sink(type = "output", split = FALSE)
[16:12:30.586]             base::close(...future.stdout)
[16:12:30.586]         }, add = TRUE)
[16:12:30.586]     }
[16:12:30.586]     ...future.frame <- base::sys.nframe()
[16:12:30.586]     ...future.conditions <- base::list()
[16:12:30.586]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.586]     if (FALSE) {
[16:12:30.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.586]     }
[16:12:30.586]     ...future.result <- base::tryCatch({
[16:12:30.586]         base::withCallingHandlers({
[16:12:30.586]             ...future.value <- base::withVisible(base::local({
[16:12:30.586]                 withCallingHandlers({
[16:12:30.586]                   {
[16:12:30.586]                     4
[16:12:30.586]                   }
[16:12:30.586]                 }, immediateCondition = function(cond) {
[16:12:30.586]                   save_rds <- function (object, pathname, ...) 
[16:12:30.586]                   {
[16:12:30.586]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.586]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.586]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.586]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.586]                         fi_tmp[["mtime"]])
[16:12:30.586]                     }
[16:12:30.586]                     tryCatch({
[16:12:30.586]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.586]                     }, error = function(ex) {
[16:12:30.586]                       msg <- conditionMessage(ex)
[16:12:30.586]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.586]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.586]                         fi_tmp[["mtime"]], msg)
[16:12:30.586]                       ex$message <- msg
[16:12:30.586]                       stop(ex)
[16:12:30.586]                     })
[16:12:30.586]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.586]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.586]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.586]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.586]                       fi <- file.info(pathname)
[16:12:30.586]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.586]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.586]                         fi[["size"]], fi[["mtime"]])
[16:12:30.586]                       stop(msg)
[16:12:30.586]                     }
[16:12:30.586]                     invisible(pathname)
[16:12:30.586]                   }
[16:12:30.586]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.586]                     rootPath = tempdir()) 
[16:12:30.586]                   {
[16:12:30.586]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.586]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.586]                       tmpdir = path, fileext = ".rds")
[16:12:30.586]                     save_rds(obj, file)
[16:12:30.586]                   }
[16:12:30.586]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.586]                   {
[16:12:30.586]                     inherits <- base::inherits
[16:12:30.586]                     invokeRestart <- base::invokeRestart
[16:12:30.586]                     is.null <- base::is.null
[16:12:30.586]                     muffled <- FALSE
[16:12:30.586]                     if (inherits(cond, "message")) {
[16:12:30.586]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.586]                       if (muffled) 
[16:12:30.586]                         invokeRestart("muffleMessage")
[16:12:30.586]                     }
[16:12:30.586]                     else if (inherits(cond, "warning")) {
[16:12:30.586]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.586]                       if (muffled) 
[16:12:30.586]                         invokeRestart("muffleWarning")
[16:12:30.586]                     }
[16:12:30.586]                     else if (inherits(cond, "condition")) {
[16:12:30.586]                       if (!is.null(pattern)) {
[16:12:30.586]                         computeRestarts <- base::computeRestarts
[16:12:30.586]                         grepl <- base::grepl
[16:12:30.586]                         restarts <- computeRestarts(cond)
[16:12:30.586]                         for (restart in restarts) {
[16:12:30.586]                           name <- restart$name
[16:12:30.586]                           if (is.null(name)) 
[16:12:30.586]                             next
[16:12:30.586]                           if (!grepl(pattern, name)) 
[16:12:30.586]                             next
[16:12:30.586]                           invokeRestart(restart)
[16:12:30.586]                           muffled <- TRUE
[16:12:30.586]                           break
[16:12:30.586]                         }
[16:12:30.586]                       }
[16:12:30.586]                     }
[16:12:30.586]                     invisible(muffled)
[16:12:30.586]                   }
[16:12:30.586]                   muffleCondition(cond)
[16:12:30.586]                 })
[16:12:30.586]             }))
[16:12:30.586]             future::FutureResult(value = ...future.value$value, 
[16:12:30.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.586]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.586]                     ...future.globalenv.names))
[16:12:30.586]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.586]         }, condition = base::local({
[16:12:30.586]             c <- base::c
[16:12:30.586]             inherits <- base::inherits
[16:12:30.586]             invokeRestart <- base::invokeRestart
[16:12:30.586]             length <- base::length
[16:12:30.586]             list <- base::list
[16:12:30.586]             seq.int <- base::seq.int
[16:12:30.586]             signalCondition <- base::signalCondition
[16:12:30.586]             sys.calls <- base::sys.calls
[16:12:30.586]             `[[` <- base::`[[`
[16:12:30.586]             `+` <- base::`+`
[16:12:30.586]             `<<-` <- base::`<<-`
[16:12:30.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.586]                   3L)]
[16:12:30.586]             }
[16:12:30.586]             function(cond) {
[16:12:30.586]                 is_error <- inherits(cond, "error")
[16:12:30.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.586]                   NULL)
[16:12:30.586]                 if (is_error) {
[16:12:30.586]                   sessionInformation <- function() {
[16:12:30.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.586]                       search = base::search(), system = base::Sys.info())
[16:12:30.586]                   }
[16:12:30.586]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.586]                     cond$call), session = sessionInformation(), 
[16:12:30.586]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.586]                   signalCondition(cond)
[16:12:30.586]                 }
[16:12:30.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.586]                 "immediateCondition"))) {
[16:12:30.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.586]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.586]                   if (TRUE && !signal) {
[16:12:30.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.586]                     {
[16:12:30.586]                       inherits <- base::inherits
[16:12:30.586]                       invokeRestart <- base::invokeRestart
[16:12:30.586]                       is.null <- base::is.null
[16:12:30.586]                       muffled <- FALSE
[16:12:30.586]                       if (inherits(cond, "message")) {
[16:12:30.586]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.586]                         if (muffled) 
[16:12:30.586]                           invokeRestart("muffleMessage")
[16:12:30.586]                       }
[16:12:30.586]                       else if (inherits(cond, "warning")) {
[16:12:30.586]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.586]                         if (muffled) 
[16:12:30.586]                           invokeRestart("muffleWarning")
[16:12:30.586]                       }
[16:12:30.586]                       else if (inherits(cond, "condition")) {
[16:12:30.586]                         if (!is.null(pattern)) {
[16:12:30.586]                           computeRestarts <- base::computeRestarts
[16:12:30.586]                           grepl <- base::grepl
[16:12:30.586]                           restarts <- computeRestarts(cond)
[16:12:30.586]                           for (restart in restarts) {
[16:12:30.586]                             name <- restart$name
[16:12:30.586]                             if (is.null(name)) 
[16:12:30.586]                               next
[16:12:30.586]                             if (!grepl(pattern, name)) 
[16:12:30.586]                               next
[16:12:30.586]                             invokeRestart(restart)
[16:12:30.586]                             muffled <- TRUE
[16:12:30.586]                             break
[16:12:30.586]                           }
[16:12:30.586]                         }
[16:12:30.586]                       }
[16:12:30.586]                       invisible(muffled)
[16:12:30.586]                     }
[16:12:30.586]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.586]                   }
[16:12:30.586]                 }
[16:12:30.586]                 else {
[16:12:30.586]                   if (TRUE) {
[16:12:30.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.586]                     {
[16:12:30.586]                       inherits <- base::inherits
[16:12:30.586]                       invokeRestart <- base::invokeRestart
[16:12:30.586]                       is.null <- base::is.null
[16:12:30.586]                       muffled <- FALSE
[16:12:30.586]                       if (inherits(cond, "message")) {
[16:12:30.586]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.586]                         if (muffled) 
[16:12:30.586]                           invokeRestart("muffleMessage")
[16:12:30.586]                       }
[16:12:30.586]                       else if (inherits(cond, "warning")) {
[16:12:30.586]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.586]                         if (muffled) 
[16:12:30.586]                           invokeRestart("muffleWarning")
[16:12:30.586]                       }
[16:12:30.586]                       else if (inherits(cond, "condition")) {
[16:12:30.586]                         if (!is.null(pattern)) {
[16:12:30.586]                           computeRestarts <- base::computeRestarts
[16:12:30.586]                           grepl <- base::grepl
[16:12:30.586]                           restarts <- computeRestarts(cond)
[16:12:30.586]                           for (restart in restarts) {
[16:12:30.586]                             name <- restart$name
[16:12:30.586]                             if (is.null(name)) 
[16:12:30.586]                               next
[16:12:30.586]                             if (!grepl(pattern, name)) 
[16:12:30.586]                               next
[16:12:30.586]                             invokeRestart(restart)
[16:12:30.586]                             muffled <- TRUE
[16:12:30.586]                             break
[16:12:30.586]                           }
[16:12:30.586]                         }
[16:12:30.586]                       }
[16:12:30.586]                       invisible(muffled)
[16:12:30.586]                     }
[16:12:30.586]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.586]                   }
[16:12:30.586]                 }
[16:12:30.586]             }
[16:12:30.586]         }))
[16:12:30.586]     }, error = function(ex) {
[16:12:30.586]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.586]                 ...future.rng), started = ...future.startTime, 
[16:12:30.586]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.586]             version = "1.8"), class = "FutureResult")
[16:12:30.586]     }, finally = {
[16:12:30.586]         if (!identical(...future.workdir, getwd())) 
[16:12:30.586]             setwd(...future.workdir)
[16:12:30.586]         {
[16:12:30.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.586]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.586]             }
[16:12:30.586]             base::options(...future.oldOptions)
[16:12:30.586]             if (.Platform$OS.type == "windows") {
[16:12:30.586]                 old_names <- names(...future.oldEnvVars)
[16:12:30.586]                 envs <- base::Sys.getenv()
[16:12:30.586]                 names <- names(envs)
[16:12:30.586]                 common <- intersect(names, old_names)
[16:12:30.586]                 added <- setdiff(names, old_names)
[16:12:30.586]                 removed <- setdiff(old_names, names)
[16:12:30.586]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.586]                   envs[common]]
[16:12:30.586]                 NAMES <- toupper(changed)
[16:12:30.586]                 args <- list()
[16:12:30.586]                 for (kk in seq_along(NAMES)) {
[16:12:30.586]                   name <- changed[[kk]]
[16:12:30.586]                   NAME <- NAMES[[kk]]
[16:12:30.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.586]                     next
[16:12:30.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.586]                 }
[16:12:30.586]                 NAMES <- toupper(added)
[16:12:30.586]                 for (kk in seq_along(NAMES)) {
[16:12:30.586]                   name <- added[[kk]]
[16:12:30.586]                   NAME <- NAMES[[kk]]
[16:12:30.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.586]                     next
[16:12:30.586]                   args[[name]] <- ""
[16:12:30.586]                 }
[16:12:30.586]                 NAMES <- toupper(removed)
[16:12:30.586]                 for (kk in seq_along(NAMES)) {
[16:12:30.586]                   name <- removed[[kk]]
[16:12:30.586]                   NAME <- NAMES[[kk]]
[16:12:30.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.586]                     next
[16:12:30.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.586]                 }
[16:12:30.586]                 if (length(args) > 0) 
[16:12:30.586]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.586]             }
[16:12:30.586]             else {
[16:12:30.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.586]             }
[16:12:30.586]             {
[16:12:30.586]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.586]                   0L) {
[16:12:30.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.586]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.586]                   base::options(opts)
[16:12:30.586]                 }
[16:12:30.586]                 {
[16:12:30.586]                   {
[16:12:30.586]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.586]                     NULL
[16:12:30.586]                   }
[16:12:30.586]                   options(future.plan = NULL)
[16:12:30.586]                   if (is.na(NA_character_)) 
[16:12:30.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.586]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.586]                     envir = parent.frame()) 
[16:12:30.586]                   {
[16:12:30.586]                     default_workers <- missing(workers)
[16:12:30.586]                     if (is.function(workers)) 
[16:12:30.586]                       workers <- workers()
[16:12:30.586]                     workers <- structure(as.integer(workers), 
[16:12:30.586]                       class = class(workers))
[16:12:30.586]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.586]                       1L)
[16:12:30.586]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.586]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.586]                       if (default_workers) 
[16:12:30.586]                         supportsMulticore(warn = TRUE)
[16:12:30.586]                       return(sequential(..., envir = envir))
[16:12:30.586]                     }
[16:12:30.586]                     oopts <- options(mc.cores = workers)
[16:12:30.586]                     on.exit(options(oopts))
[16:12:30.586]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.586]                       envir = envir)
[16:12:30.586]                     if (!future$lazy) 
[16:12:30.586]                       future <- run(future)
[16:12:30.586]                     invisible(future)
[16:12:30.586]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.586]                 }
[16:12:30.586]             }
[16:12:30.586]         }
[16:12:30.586]     })
[16:12:30.586]     if (TRUE) {
[16:12:30.586]         base::sink(type = "output", split = FALSE)
[16:12:30.586]         if (TRUE) {
[16:12:30.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.586]         }
[16:12:30.586]         else {
[16:12:30.586]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.586]         }
[16:12:30.586]         base::close(...future.stdout)
[16:12:30.586]         ...future.stdout <- NULL
[16:12:30.586]     }
[16:12:30.586]     ...future.result$conditions <- ...future.conditions
[16:12:30.586]     ...future.result$finished <- base::Sys.time()
[16:12:30.586]     ...future.result
[16:12:30.586] }
[16:12:30.590] requestCore(): workers = 2
[16:12:30.590] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:30.604] MulticoreFuture started
[16:12:30.604] - Launch lazy future ... done
[16:12:30.605] run() for ‘MulticoreFuture’ ... done
[16:12:30.605] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x560baff35d28> 
[16:12:30.606] List of future strategies:
[16:12:30.606] 1. sequential:
[16:12:30.606]    - args: function (..., envir = parent.frame())
[16:12:30.606]    - tweaked: FALSE
[16:12:30.606]    - call: NULL
[16:12:30.607] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x560bb0aacd88> 
 - attr(*, "dim.")=[16:12:30.609] plan(): Setting new future strategy stack:
 int [1:2] 2 3
 - attr(*, "dimnames.")=[16:12:30.610] List of future strategies:
[16:12:30.610] 1. multicore:
[16:12:30.610]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.610]    - tweaked: FALSE
[16:12:30.610]    - call: plan(strategy)
List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:12:30.616] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:30.629] resolve() on list environment ...
[16:12:30.629]  recursive: 0
[16:12:30.630]  length: 6
[16:12:30.631]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:30.631] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.631] - nx: 6
[16:12:30.631] - relay: TRUE
[16:12:30.631] - stdout: TRUE
[16:12:30.631] - signal: TRUE
[16:12:30.632] - resignal: FALSE
[16:12:30.632] - force: TRUE
[16:12:30.632] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.632] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.632]  - until=2
[16:12:30.632]  - relaying element #2
[16:12:30.632] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.632] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.633] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.633]  length: 5 (resolved future 1)
[16:12:30.633] Future #2
[16:12:30.633] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:30.633] - nx: 6
[16:12:30.633] - relay: TRUE
[16:12:30.634] - stdout: TRUE
[16:12:30.634] - signal: TRUE
[16:12:30.634] - resignal: FALSE
[16:12:30.634] - force: TRUE
[16:12:30.634] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.634] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.634]  - until=2
[16:12:30.634]  - relaying element #2
[16:12:30.635] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.635] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.635] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:30.635]  length: 4 (resolved future 2)
[16:12:30.635] Future #3
[16:12:30.636] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:30.636] - nx: 6
[16:12:30.637] - relay: TRUE
[16:12:30.637] - stdout: TRUE
[16:12:30.637] - signal: TRUE
[16:12:30.637] - resignal: FALSE
[16:12:30.637] - force: TRUE
[16:12:30.637] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.637] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.638]  - until=3
[16:12:30.638]  - relaying element #3
[16:12:30.638] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.638] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.638] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:30.638]  length: 3 (resolved future 3)
[16:12:30.639] Future #4
[16:12:30.640] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:30.640] - nx: 6
[16:12:30.640] - relay: TRUE
[16:12:30.640] - stdout: TRUE
[16:12:30.640] - signal: TRUE
[16:12:30.640] - resignal: FALSE
[16:12:30.641] - force: TRUE
[16:12:30.641] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.641] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.641]  - until=4
[16:12:30.641]  - relaying element #4
[16:12:30.641] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.642] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.642] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:30.642]  length: 2 (resolved future 4)
[16:12:30.642] signalConditionsASAP(NULL, pos=5) ...
[16:12:30.642] - nx: 6
[16:12:30.642] - relay: TRUE
[16:12:30.643] - stdout: TRUE
[16:12:30.643] - signal: TRUE
[16:12:30.643] - resignal: FALSE
[16:12:30.643] - force: TRUE
[16:12:30.643] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.643] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.643]  - until=6
[16:12:30.644]  - relaying element #6
[16:12:30.644] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.644] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.644] signalConditionsASAP(NULL, pos=5) ... done
[16:12:30.644]  length: 1 (resolved future 5)
[16:12:30.644] signalConditionsASAP(numeric, pos=6) ...
[16:12:30.644] - nx: 6
[16:12:30.644] - relay: TRUE
[16:12:30.644] - stdout: TRUE
[16:12:30.645] - signal: TRUE
[16:12:30.645] - resignal: FALSE
[16:12:30.645] - force: TRUE
[16:12:30.645] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.645] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.645]  - until=6
[16:12:30.645] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.645] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.645] signalConditionsASAP(numeric, pos=6) ... done
[16:12:30.646]  length: 0 (resolved future 6)
[16:12:30.646] Relaying remaining futures
[16:12:30.646] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.646] - nx: 6
[16:12:30.646] - relay: TRUE
[16:12:30.646] - stdout: TRUE
[16:12:30.646] - signal: TRUE
[16:12:30.646] - resignal: FALSE
[16:12:30.646] - force: TRUE
[16:12:30.646] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.647] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:30.647] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.647] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.647] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.647] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560baf308960> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:12:30.649] getGlobalsAndPackages() ...
[16:12:30.650] Searching for globals...
[16:12:30.650] 
[16:12:30.650] Searching for globals ... DONE
[16:12:30.650] - globals: [0] <none>
[16:12:30.650] getGlobalsAndPackages() ... DONE
[16:12:30.651] run() for ‘Future’ ...
[16:12:30.651] - state: ‘created’
[16:12:30.651] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.655] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.655] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.656]   - Field: ‘label’
[16:12:30.656]   - Field: ‘local’
[16:12:30.656]   - Field: ‘owner’
[16:12:30.656]   - Field: ‘envir’
[16:12:30.656]   - Field: ‘workers’
[16:12:30.656]   - Field: ‘packages’
[16:12:30.656]   - Field: ‘gc’
[16:12:30.657]   - Field: ‘job’
[16:12:30.657]   - Field: ‘conditions’
[16:12:30.657]   - Field: ‘expr’
[16:12:30.657]   - Field: ‘uuid’
[16:12:30.657]   - Field: ‘seed’
[16:12:30.657]   - Field: ‘version’
[16:12:30.658]   - Field: ‘result’
[16:12:30.658]   - Field: ‘asynchronous’
[16:12:30.658]   - Field: ‘calls’
[16:12:30.658]   - Field: ‘globals’
[16:12:30.658]   - Field: ‘stdout’
[16:12:30.658]   - Field: ‘earlySignal’
[16:12:30.658]   - Field: ‘lazy’
[16:12:30.658]   - Field: ‘state’
[16:12:30.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.659] - Launch lazy future ...
[16:12:30.659] Packages needed by the future expression (n = 0): <none>
[16:12:30.659] Packages needed by future strategies (n = 0): <none>
[16:12:30.660] {
[16:12:30.660]     {
[16:12:30.660]         {
[16:12:30.660]             ...future.startTime <- base::Sys.time()
[16:12:30.660]             {
[16:12:30.660]                 {
[16:12:30.660]                   {
[16:12:30.660]                     {
[16:12:30.660]                       base::local({
[16:12:30.660]                         has_future <- base::requireNamespace("future", 
[16:12:30.660]                           quietly = TRUE)
[16:12:30.660]                         if (has_future) {
[16:12:30.660]                           ns <- base::getNamespace("future")
[16:12:30.660]                           version <- ns[[".package"]][["version"]]
[16:12:30.660]                           if (is.null(version)) 
[16:12:30.660]                             version <- utils::packageVersion("future")
[16:12:30.660]                         }
[16:12:30.660]                         else {
[16:12:30.660]                           version <- NULL
[16:12:30.660]                         }
[16:12:30.660]                         if (!has_future || version < "1.8.0") {
[16:12:30.660]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.660]                             "", base::R.version$version.string), 
[16:12:30.660]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.660]                               "release", "version")], collapse = " "), 
[16:12:30.660]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.660]                             info)
[16:12:30.660]                           info <- base::paste(info, collapse = "; ")
[16:12:30.660]                           if (!has_future) {
[16:12:30.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.660]                               info)
[16:12:30.660]                           }
[16:12:30.660]                           else {
[16:12:30.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.660]                               info, version)
[16:12:30.660]                           }
[16:12:30.660]                           base::stop(msg)
[16:12:30.660]                         }
[16:12:30.660]                       })
[16:12:30.660]                     }
[16:12:30.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.660]                     base::options(mc.cores = 1L)
[16:12:30.660]                   }
[16:12:30.660]                   options(future.plan = NULL)
[16:12:30.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.660]                 }
[16:12:30.660]                 ...future.workdir <- getwd()
[16:12:30.660]             }
[16:12:30.660]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.660]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.660]         }
[16:12:30.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.660]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.660]             base::names(...future.oldOptions))
[16:12:30.660]     }
[16:12:30.660]     if (FALSE) {
[16:12:30.660]     }
[16:12:30.660]     else {
[16:12:30.660]         if (TRUE) {
[16:12:30.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.660]                 open = "w")
[16:12:30.660]         }
[16:12:30.660]         else {
[16:12:30.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.660]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.660]         }
[16:12:30.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.660]             base::sink(type = "output", split = FALSE)
[16:12:30.660]             base::close(...future.stdout)
[16:12:30.660]         }, add = TRUE)
[16:12:30.660]     }
[16:12:30.660]     ...future.frame <- base::sys.nframe()
[16:12:30.660]     ...future.conditions <- base::list()
[16:12:30.660]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.660]     if (FALSE) {
[16:12:30.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.660]     }
[16:12:30.660]     ...future.result <- base::tryCatch({
[16:12:30.660]         base::withCallingHandlers({
[16:12:30.660]             ...future.value <- base::withVisible(base::local({
[16:12:30.660]                 withCallingHandlers({
[16:12:30.660]                   2
[16:12:30.660]                 }, immediateCondition = function(cond) {
[16:12:30.660]                   save_rds <- function (object, pathname, ...) 
[16:12:30.660]                   {
[16:12:30.660]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.660]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.660]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.660]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.660]                         fi_tmp[["mtime"]])
[16:12:30.660]                     }
[16:12:30.660]                     tryCatch({
[16:12:30.660]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.660]                     }, error = function(ex) {
[16:12:30.660]                       msg <- conditionMessage(ex)
[16:12:30.660]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.660]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.660]                         fi_tmp[["mtime"]], msg)
[16:12:30.660]                       ex$message <- msg
[16:12:30.660]                       stop(ex)
[16:12:30.660]                     })
[16:12:30.660]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.660]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.660]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.660]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.660]                       fi <- file.info(pathname)
[16:12:30.660]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.660]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.660]                         fi[["size"]], fi[["mtime"]])
[16:12:30.660]                       stop(msg)
[16:12:30.660]                     }
[16:12:30.660]                     invisible(pathname)
[16:12:30.660]                   }
[16:12:30.660]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.660]                     rootPath = tempdir()) 
[16:12:30.660]                   {
[16:12:30.660]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.660]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.660]                       tmpdir = path, fileext = ".rds")
[16:12:30.660]                     save_rds(obj, file)
[16:12:30.660]                   }
[16:12:30.660]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.660]                   {
[16:12:30.660]                     inherits <- base::inherits
[16:12:30.660]                     invokeRestart <- base::invokeRestart
[16:12:30.660]                     is.null <- base::is.null
[16:12:30.660]                     muffled <- FALSE
[16:12:30.660]                     if (inherits(cond, "message")) {
[16:12:30.660]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.660]                       if (muffled) 
[16:12:30.660]                         invokeRestart("muffleMessage")
[16:12:30.660]                     }
[16:12:30.660]                     else if (inherits(cond, "warning")) {
[16:12:30.660]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.660]                       if (muffled) 
[16:12:30.660]                         invokeRestart("muffleWarning")
[16:12:30.660]                     }
[16:12:30.660]                     else if (inherits(cond, "condition")) {
[16:12:30.660]                       if (!is.null(pattern)) {
[16:12:30.660]                         computeRestarts <- base::computeRestarts
[16:12:30.660]                         grepl <- base::grepl
[16:12:30.660]                         restarts <- computeRestarts(cond)
[16:12:30.660]                         for (restart in restarts) {
[16:12:30.660]                           name <- restart$name
[16:12:30.660]                           if (is.null(name)) 
[16:12:30.660]                             next
[16:12:30.660]                           if (!grepl(pattern, name)) 
[16:12:30.660]                             next
[16:12:30.660]                           invokeRestart(restart)
[16:12:30.660]                           muffled <- TRUE
[16:12:30.660]                           break
[16:12:30.660]                         }
[16:12:30.660]                       }
[16:12:30.660]                     }
[16:12:30.660]                     invisible(muffled)
[16:12:30.660]                   }
[16:12:30.660]                   muffleCondition(cond)
[16:12:30.660]                 })
[16:12:30.660]             }))
[16:12:30.660]             future::FutureResult(value = ...future.value$value, 
[16:12:30.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.660]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.660]                     ...future.globalenv.names))
[16:12:30.660]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.660]         }, condition = base::local({
[16:12:30.660]             c <- base::c
[16:12:30.660]             inherits <- base::inherits
[16:12:30.660]             invokeRestart <- base::invokeRestart
[16:12:30.660]             length <- base::length
[16:12:30.660]             list <- base::list
[16:12:30.660]             seq.int <- base::seq.int
[16:12:30.660]             signalCondition <- base::signalCondition
[16:12:30.660]             sys.calls <- base::sys.calls
[16:12:30.660]             `[[` <- base::`[[`
[16:12:30.660]             `+` <- base::`+`
[16:12:30.660]             `<<-` <- base::`<<-`
[16:12:30.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.660]                   3L)]
[16:12:30.660]             }
[16:12:30.660]             function(cond) {
[16:12:30.660]                 is_error <- inherits(cond, "error")
[16:12:30.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.660]                   NULL)
[16:12:30.660]                 if (is_error) {
[16:12:30.660]                   sessionInformation <- function() {
[16:12:30.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.660]                       search = base::search(), system = base::Sys.info())
[16:12:30.660]                   }
[16:12:30.660]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.660]                     cond$call), session = sessionInformation(), 
[16:12:30.660]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.660]                   signalCondition(cond)
[16:12:30.660]                 }
[16:12:30.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.660]                 "immediateCondition"))) {
[16:12:30.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.660]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.660]                   if (TRUE && !signal) {
[16:12:30.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.660]                     {
[16:12:30.660]                       inherits <- base::inherits
[16:12:30.660]                       invokeRestart <- base::invokeRestart
[16:12:30.660]                       is.null <- base::is.null
[16:12:30.660]                       muffled <- FALSE
[16:12:30.660]                       if (inherits(cond, "message")) {
[16:12:30.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.660]                         if (muffled) 
[16:12:30.660]                           invokeRestart("muffleMessage")
[16:12:30.660]                       }
[16:12:30.660]                       else if (inherits(cond, "warning")) {
[16:12:30.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.660]                         if (muffled) 
[16:12:30.660]                           invokeRestart("muffleWarning")
[16:12:30.660]                       }
[16:12:30.660]                       else if (inherits(cond, "condition")) {
[16:12:30.660]                         if (!is.null(pattern)) {
[16:12:30.660]                           computeRestarts <- base::computeRestarts
[16:12:30.660]                           grepl <- base::grepl
[16:12:30.660]                           restarts <- computeRestarts(cond)
[16:12:30.660]                           for (restart in restarts) {
[16:12:30.660]                             name <- restart$name
[16:12:30.660]                             if (is.null(name)) 
[16:12:30.660]                               next
[16:12:30.660]                             if (!grepl(pattern, name)) 
[16:12:30.660]                               next
[16:12:30.660]                             invokeRestart(restart)
[16:12:30.660]                             muffled <- TRUE
[16:12:30.660]                             break
[16:12:30.660]                           }
[16:12:30.660]                         }
[16:12:30.660]                       }
[16:12:30.660]                       invisible(muffled)
[16:12:30.660]                     }
[16:12:30.660]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.660]                   }
[16:12:30.660]                 }
[16:12:30.660]                 else {
[16:12:30.660]                   if (TRUE) {
[16:12:30.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.660]                     {
[16:12:30.660]                       inherits <- base::inherits
[16:12:30.660]                       invokeRestart <- base::invokeRestart
[16:12:30.660]                       is.null <- base::is.null
[16:12:30.660]                       muffled <- FALSE
[16:12:30.660]                       if (inherits(cond, "message")) {
[16:12:30.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.660]                         if (muffled) 
[16:12:30.660]                           invokeRestart("muffleMessage")
[16:12:30.660]                       }
[16:12:30.660]                       else if (inherits(cond, "warning")) {
[16:12:30.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.660]                         if (muffled) 
[16:12:30.660]                           invokeRestart("muffleWarning")
[16:12:30.660]                       }
[16:12:30.660]                       else if (inherits(cond, "condition")) {
[16:12:30.660]                         if (!is.null(pattern)) {
[16:12:30.660]                           computeRestarts <- base::computeRestarts
[16:12:30.660]                           grepl <- base::grepl
[16:12:30.660]                           restarts <- computeRestarts(cond)
[16:12:30.660]                           for (restart in restarts) {
[16:12:30.660]                             name <- restart$name
[16:12:30.660]                             if (is.null(name)) 
[16:12:30.660]                               next
[16:12:30.660]                             if (!grepl(pattern, name)) 
[16:12:30.660]                               next
[16:12:30.660]                             invokeRestart(restart)
[16:12:30.660]                             muffled <- TRUE
[16:12:30.660]                             break
[16:12:30.660]                           }
[16:12:30.660]                         }
[16:12:30.660]                       }
[16:12:30.660]                       invisible(muffled)
[16:12:30.660]                     }
[16:12:30.660]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.660]                   }
[16:12:30.660]                 }
[16:12:30.660]             }
[16:12:30.660]         }))
[16:12:30.660]     }, error = function(ex) {
[16:12:30.660]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.660]                 ...future.rng), started = ...future.startTime, 
[16:12:30.660]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.660]             version = "1.8"), class = "FutureResult")
[16:12:30.660]     }, finally = {
[16:12:30.660]         if (!identical(...future.workdir, getwd())) 
[16:12:30.660]             setwd(...future.workdir)
[16:12:30.660]         {
[16:12:30.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.660]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.660]             }
[16:12:30.660]             base::options(...future.oldOptions)
[16:12:30.660]             if (.Platform$OS.type == "windows") {
[16:12:30.660]                 old_names <- names(...future.oldEnvVars)
[16:12:30.660]                 envs <- base::Sys.getenv()
[16:12:30.660]                 names <- names(envs)
[16:12:30.660]                 common <- intersect(names, old_names)
[16:12:30.660]                 added <- setdiff(names, old_names)
[16:12:30.660]                 removed <- setdiff(old_names, names)
[16:12:30.660]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.660]                   envs[common]]
[16:12:30.660]                 NAMES <- toupper(changed)
[16:12:30.660]                 args <- list()
[16:12:30.660]                 for (kk in seq_along(NAMES)) {
[16:12:30.660]                   name <- changed[[kk]]
[16:12:30.660]                   NAME <- NAMES[[kk]]
[16:12:30.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.660]                     next
[16:12:30.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.660]                 }
[16:12:30.660]                 NAMES <- toupper(added)
[16:12:30.660]                 for (kk in seq_along(NAMES)) {
[16:12:30.660]                   name <- added[[kk]]
[16:12:30.660]                   NAME <- NAMES[[kk]]
[16:12:30.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.660]                     next
[16:12:30.660]                   args[[name]] <- ""
[16:12:30.660]                 }
[16:12:30.660]                 NAMES <- toupper(removed)
[16:12:30.660]                 for (kk in seq_along(NAMES)) {
[16:12:30.660]                   name <- removed[[kk]]
[16:12:30.660]                   NAME <- NAMES[[kk]]
[16:12:30.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.660]                     next
[16:12:30.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.660]                 }
[16:12:30.660]                 if (length(args) > 0) 
[16:12:30.660]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.660]             }
[16:12:30.660]             else {
[16:12:30.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.660]             }
[16:12:30.660]             {
[16:12:30.660]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.660]                   0L) {
[16:12:30.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.660]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.660]                   base::options(opts)
[16:12:30.660]                 }
[16:12:30.660]                 {
[16:12:30.660]                   {
[16:12:30.660]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.660]                     NULL
[16:12:30.660]                   }
[16:12:30.660]                   options(future.plan = NULL)
[16:12:30.660]                   if (is.na(NA_character_)) 
[16:12:30.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.660]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.660]                     envir = parent.frame()) 
[16:12:30.660]                   {
[16:12:30.660]                     default_workers <- missing(workers)
[16:12:30.660]                     if (is.function(workers)) 
[16:12:30.660]                       workers <- workers()
[16:12:30.660]                     workers <- structure(as.integer(workers), 
[16:12:30.660]                       class = class(workers))
[16:12:30.660]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.660]                       1L)
[16:12:30.660]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.660]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.660]                       if (default_workers) 
[16:12:30.660]                         supportsMulticore(warn = TRUE)
[16:12:30.660]                       return(sequential(..., envir = envir))
[16:12:30.660]                     }
[16:12:30.660]                     oopts <- options(mc.cores = workers)
[16:12:30.660]                     on.exit(options(oopts))
[16:12:30.660]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.660]                       envir = envir)
[16:12:30.660]                     if (!future$lazy) 
[16:12:30.660]                       future <- run(future)
[16:12:30.660]                     invisible(future)
[16:12:30.660]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.660]                 }
[16:12:30.660]             }
[16:12:30.660]         }
[16:12:30.660]     })
[16:12:30.660]     if (TRUE) {
[16:12:30.660]         base::sink(type = "output", split = FALSE)
[16:12:30.660]         if (TRUE) {
[16:12:30.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.660]         }
[16:12:30.660]         else {
[16:12:30.660]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.660]         }
[16:12:30.660]         base::close(...future.stdout)
[16:12:30.660]         ...future.stdout <- NULL
[16:12:30.660]     }
[16:12:30.660]     ...future.result$conditions <- ...future.conditions
[16:12:30.660]     ...future.result$finished <- base::Sys.time()
[16:12:30.660]     ...future.result
[16:12:30.660] }
[16:12:30.662] requestCore(): workers = 2
[16:12:30.665] MulticoreFuture started
[16:12:30.665] - Launch lazy future ... done
[16:12:30.665] run() for ‘MulticoreFuture’ ... done
[16:12:30.666] getGlobalsAndPackages() ...
[16:12:30.666] plan(): Setting new future strategy stack:
[16:12:30.666] Searching for globals...
[16:12:30.666] List of future strategies:
[16:12:30.666] 1. sequential:
[16:12:30.666]    - args: function (..., envir = parent.frame())
[16:12:30.666]    - tweaked: FALSE
[16:12:30.666]    - call: NULL
[16:12:30.667] 
[16:12:30.667] Searching for globals ... DONE
[16:12:30.667] plan(): nbrOfWorkers() = 1
[16:12:30.667] - globals: [0] <none>
[16:12:30.667] getGlobalsAndPackages() ... DONE
[16:12:30.668] run() for ‘Future’ ...
[16:12:30.668] - state: ‘created’
[16:12:30.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.669] plan(): Setting new future strategy stack:
[16:12:30.669] List of future strategies:
[16:12:30.669] 1. multicore:
[16:12:30.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.669]    - tweaked: FALSE
[16:12:30.669]    - call: plan(strategy)
[16:12:30.674] plan(): nbrOfWorkers() = 2
[16:12:30.674] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.675]   - Field: ‘label’
[16:12:30.675]   - Field: ‘local’
[16:12:30.675]   - Field: ‘owner’
[16:12:30.675]   - Field: ‘envir’
[16:12:30.675]   - Field: ‘workers’
[16:12:30.675]   - Field: ‘packages’
[16:12:30.676]   - Field: ‘gc’
[16:12:30.676]   - Field: ‘job’
[16:12:30.676]   - Field: ‘conditions’
[16:12:30.676]   - Field: ‘expr’
[16:12:30.676]   - Field: ‘uuid’
[16:12:30.676]   - Field: ‘seed’
[16:12:30.677]   - Field: ‘version’
[16:12:30.677]   - Field: ‘result’
[16:12:30.677]   - Field: ‘asynchronous’
[16:12:30.677]   - Field: ‘calls’
[16:12:30.677]   - Field: ‘globals’
[16:12:30.677]   - Field: ‘stdout’
[16:12:30.678]   - Field: ‘earlySignal’
[16:12:30.678]   - Field: ‘lazy’
[16:12:30.678]   - Field: ‘state’
[16:12:30.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.678] - Launch lazy future ...
[16:12:30.679] Packages needed by the future expression (n = 0): <none>
[16:12:30.679] Packages needed by future strategies (n = 0): <none>
[16:12:30.680] {
[16:12:30.680]     {
[16:12:30.680]         {
[16:12:30.680]             ...future.startTime <- base::Sys.time()
[16:12:30.680]             {
[16:12:30.680]                 {
[16:12:30.680]                   {
[16:12:30.680]                     {
[16:12:30.680]                       base::local({
[16:12:30.680]                         has_future <- base::requireNamespace("future", 
[16:12:30.680]                           quietly = TRUE)
[16:12:30.680]                         if (has_future) {
[16:12:30.680]                           ns <- base::getNamespace("future")
[16:12:30.680]                           version <- ns[[".package"]][["version"]]
[16:12:30.680]                           if (is.null(version)) 
[16:12:30.680]                             version <- utils::packageVersion("future")
[16:12:30.680]                         }
[16:12:30.680]                         else {
[16:12:30.680]                           version <- NULL
[16:12:30.680]                         }
[16:12:30.680]                         if (!has_future || version < "1.8.0") {
[16:12:30.680]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.680]                             "", base::R.version$version.string), 
[16:12:30.680]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.680]                               "release", "version")], collapse = " "), 
[16:12:30.680]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.680]                             info)
[16:12:30.680]                           info <- base::paste(info, collapse = "; ")
[16:12:30.680]                           if (!has_future) {
[16:12:30.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.680]                               info)
[16:12:30.680]                           }
[16:12:30.680]                           else {
[16:12:30.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.680]                               info, version)
[16:12:30.680]                           }
[16:12:30.680]                           base::stop(msg)
[16:12:30.680]                         }
[16:12:30.680]                       })
[16:12:30.680]                     }
[16:12:30.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.680]                     base::options(mc.cores = 1L)
[16:12:30.680]                   }
[16:12:30.680]                   options(future.plan = NULL)
[16:12:30.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.680]                 }
[16:12:30.680]                 ...future.workdir <- getwd()
[16:12:30.680]             }
[16:12:30.680]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.680]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.680]         }
[16:12:30.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.680]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.680]             base::names(...future.oldOptions))
[16:12:30.680]     }
[16:12:30.680]     if (FALSE) {
[16:12:30.680]     }
[16:12:30.680]     else {
[16:12:30.680]         if (TRUE) {
[16:12:30.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.680]                 open = "w")
[16:12:30.680]         }
[16:12:30.680]         else {
[16:12:30.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.680]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.680]         }
[16:12:30.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.680]             base::sink(type = "output", split = FALSE)
[16:12:30.680]             base::close(...future.stdout)
[16:12:30.680]         }, add = TRUE)
[16:12:30.680]     }
[16:12:30.680]     ...future.frame <- base::sys.nframe()
[16:12:30.680]     ...future.conditions <- base::list()
[16:12:30.680]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.680]     if (FALSE) {
[16:12:30.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.680]     }
[16:12:30.680]     ...future.result <- base::tryCatch({
[16:12:30.680]         base::withCallingHandlers({
[16:12:30.680]             ...future.value <- base::withVisible(base::local({
[16:12:30.680]                 withCallingHandlers({
[16:12:30.680]                   NULL
[16:12:30.680]                 }, immediateCondition = function(cond) {
[16:12:30.680]                   save_rds <- function (object, pathname, ...) 
[16:12:30.680]                   {
[16:12:30.680]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.680]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.680]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.680]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.680]                         fi_tmp[["mtime"]])
[16:12:30.680]                     }
[16:12:30.680]                     tryCatch({
[16:12:30.680]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.680]                     }, error = function(ex) {
[16:12:30.680]                       msg <- conditionMessage(ex)
[16:12:30.680]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.680]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.680]                         fi_tmp[["mtime"]], msg)
[16:12:30.680]                       ex$message <- msg
[16:12:30.680]                       stop(ex)
[16:12:30.680]                     })
[16:12:30.680]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.680]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.680]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.680]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.680]                       fi <- file.info(pathname)
[16:12:30.680]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.680]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.680]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.680]                         fi[["size"]], fi[["mtime"]])
[16:12:30.680]                       stop(msg)
[16:12:30.680]                     }
[16:12:30.680]                     invisible(pathname)
[16:12:30.680]                   }
[16:12:30.680]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.680]                     rootPath = tempdir()) 
[16:12:30.680]                   {
[16:12:30.680]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.680]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.680]                       tmpdir = path, fileext = ".rds")
[16:12:30.680]                     save_rds(obj, file)
[16:12:30.680]                   }
[16:12:30.680]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.680]                   {
[16:12:30.680]                     inherits <- base::inherits
[16:12:30.680]                     invokeRestart <- base::invokeRestart
[16:12:30.680]                     is.null <- base::is.null
[16:12:30.680]                     muffled <- FALSE
[16:12:30.680]                     if (inherits(cond, "message")) {
[16:12:30.680]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.680]                       if (muffled) 
[16:12:30.680]                         invokeRestart("muffleMessage")
[16:12:30.680]                     }
[16:12:30.680]                     else if (inherits(cond, "warning")) {
[16:12:30.680]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.680]                       if (muffled) 
[16:12:30.680]                         invokeRestart("muffleWarning")
[16:12:30.680]                     }
[16:12:30.680]                     else if (inherits(cond, "condition")) {
[16:12:30.680]                       if (!is.null(pattern)) {
[16:12:30.680]                         computeRestarts <- base::computeRestarts
[16:12:30.680]                         grepl <- base::grepl
[16:12:30.680]                         restarts <- computeRestarts(cond)
[16:12:30.680]                         for (restart in restarts) {
[16:12:30.680]                           name <- restart$name
[16:12:30.680]                           if (is.null(name)) 
[16:12:30.680]                             next
[16:12:30.680]                           if (!grepl(pattern, name)) 
[16:12:30.680]                             next
[16:12:30.680]                           invokeRestart(restart)
[16:12:30.680]                           muffled <- TRUE
[16:12:30.680]                           break
[16:12:30.680]                         }
[16:12:30.680]                       }
[16:12:30.680]                     }
[16:12:30.680]                     invisible(muffled)
[16:12:30.680]                   }
[16:12:30.680]                   muffleCondition(cond)
[16:12:30.680]                 })
[16:12:30.680]             }))
[16:12:30.680]             future::FutureResult(value = ...future.value$value, 
[16:12:30.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.680]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.680]                     ...future.globalenv.names))
[16:12:30.680]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.680]         }, condition = base::local({
[16:12:30.680]             c <- base::c
[16:12:30.680]             inherits <- base::inherits
[16:12:30.680]             invokeRestart <- base::invokeRestart
[16:12:30.680]             length <- base::length
[16:12:30.680]             list <- base::list
[16:12:30.680]             seq.int <- base::seq.int
[16:12:30.680]             signalCondition <- base::signalCondition
[16:12:30.680]             sys.calls <- base::sys.calls
[16:12:30.680]             `[[` <- base::`[[`
[16:12:30.680]             `+` <- base::`+`
[16:12:30.680]             `<<-` <- base::`<<-`
[16:12:30.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.680]                   3L)]
[16:12:30.680]             }
[16:12:30.680]             function(cond) {
[16:12:30.680]                 is_error <- inherits(cond, "error")
[16:12:30.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.680]                   NULL)
[16:12:30.680]                 if (is_error) {
[16:12:30.680]                   sessionInformation <- function() {
[16:12:30.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.680]                       search = base::search(), system = base::Sys.info())
[16:12:30.680]                   }
[16:12:30.680]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.680]                     cond$call), session = sessionInformation(), 
[16:12:30.680]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.680]                   signalCondition(cond)
[16:12:30.680]                 }
[16:12:30.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.680]                 "immediateCondition"))) {
[16:12:30.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.680]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.680]                   if (TRUE && !signal) {
[16:12:30.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.680]                     {
[16:12:30.680]                       inherits <- base::inherits
[16:12:30.680]                       invokeRestart <- base::invokeRestart
[16:12:30.680]                       is.null <- base::is.null
[16:12:30.680]                       muffled <- FALSE
[16:12:30.680]                       if (inherits(cond, "message")) {
[16:12:30.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.680]                         if (muffled) 
[16:12:30.680]                           invokeRestart("muffleMessage")
[16:12:30.680]                       }
[16:12:30.680]                       else if (inherits(cond, "warning")) {
[16:12:30.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.680]                         if (muffled) 
[16:12:30.680]                           invokeRestart("muffleWarning")
[16:12:30.680]                       }
[16:12:30.680]                       else if (inherits(cond, "condition")) {
[16:12:30.680]                         if (!is.null(pattern)) {
[16:12:30.680]                           computeRestarts <- base::computeRestarts
[16:12:30.680]                           grepl <- base::grepl
[16:12:30.680]                           restarts <- computeRestarts(cond)
[16:12:30.680]                           for (restart in restarts) {
[16:12:30.680]                             name <- restart$name
[16:12:30.680]                             if (is.null(name)) 
[16:12:30.680]                               next
[16:12:30.680]                             if (!grepl(pattern, name)) 
[16:12:30.680]                               next
[16:12:30.680]                             invokeRestart(restart)
[16:12:30.680]                             muffled <- TRUE
[16:12:30.680]                             break
[16:12:30.680]                           }
[16:12:30.680]                         }
[16:12:30.680]                       }
[16:12:30.680]                       invisible(muffled)
[16:12:30.680]                     }
[16:12:30.680]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.680]                   }
[16:12:30.680]                 }
[16:12:30.680]                 else {
[16:12:30.680]                   if (TRUE) {
[16:12:30.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.680]                     {
[16:12:30.680]                       inherits <- base::inherits
[16:12:30.680]                       invokeRestart <- base::invokeRestart
[16:12:30.680]                       is.null <- base::is.null
[16:12:30.680]                       muffled <- FALSE
[16:12:30.680]                       if (inherits(cond, "message")) {
[16:12:30.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.680]                         if (muffled) 
[16:12:30.680]                           invokeRestart("muffleMessage")
[16:12:30.680]                       }
[16:12:30.680]                       else if (inherits(cond, "warning")) {
[16:12:30.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.680]                         if (muffled) 
[16:12:30.680]                           invokeRestart("muffleWarning")
[16:12:30.680]                       }
[16:12:30.680]                       else if (inherits(cond, "condition")) {
[16:12:30.680]                         if (!is.null(pattern)) {
[16:12:30.680]                           computeRestarts <- base::computeRestarts
[16:12:30.680]                           grepl <- base::grepl
[16:12:30.680]                           restarts <- computeRestarts(cond)
[16:12:30.680]                           for (restart in restarts) {
[16:12:30.680]                             name <- restart$name
[16:12:30.680]                             if (is.null(name)) 
[16:12:30.680]                               next
[16:12:30.680]                             if (!grepl(pattern, name)) 
[16:12:30.680]                               next
[16:12:30.680]                             invokeRestart(restart)
[16:12:30.680]                             muffled <- TRUE
[16:12:30.680]                             break
[16:12:30.680]                           }
[16:12:30.680]                         }
[16:12:30.680]                       }
[16:12:30.680]                       invisible(muffled)
[16:12:30.680]                     }
[16:12:30.680]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.680]                   }
[16:12:30.680]                 }
[16:12:30.680]             }
[16:12:30.680]         }))
[16:12:30.680]     }, error = function(ex) {
[16:12:30.680]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.680]                 ...future.rng), started = ...future.startTime, 
[16:12:30.680]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.680]             version = "1.8"), class = "FutureResult")
[16:12:30.680]     }, finally = {
[16:12:30.680]         if (!identical(...future.workdir, getwd())) 
[16:12:30.680]             setwd(...future.workdir)
[16:12:30.680]         {
[16:12:30.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.680]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.680]             }
[16:12:30.680]             base::options(...future.oldOptions)
[16:12:30.680]             if (.Platform$OS.type == "windows") {
[16:12:30.680]                 old_names <- names(...future.oldEnvVars)
[16:12:30.680]                 envs <- base::Sys.getenv()
[16:12:30.680]                 names <- names(envs)
[16:12:30.680]                 common <- intersect(names, old_names)
[16:12:30.680]                 added <- setdiff(names, old_names)
[16:12:30.680]                 removed <- setdiff(old_names, names)
[16:12:30.680]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.680]                   envs[common]]
[16:12:30.680]                 NAMES <- toupper(changed)
[16:12:30.680]                 args <- list()
[16:12:30.680]                 for (kk in seq_along(NAMES)) {
[16:12:30.680]                   name <- changed[[kk]]
[16:12:30.680]                   NAME <- NAMES[[kk]]
[16:12:30.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.680]                     next
[16:12:30.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.680]                 }
[16:12:30.680]                 NAMES <- toupper(added)
[16:12:30.680]                 for (kk in seq_along(NAMES)) {
[16:12:30.680]                   name <- added[[kk]]
[16:12:30.680]                   NAME <- NAMES[[kk]]
[16:12:30.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.680]                     next
[16:12:30.680]                   args[[name]] <- ""
[16:12:30.680]                 }
[16:12:30.680]                 NAMES <- toupper(removed)
[16:12:30.680]                 for (kk in seq_along(NAMES)) {
[16:12:30.680]                   name <- removed[[kk]]
[16:12:30.680]                   NAME <- NAMES[[kk]]
[16:12:30.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.680]                     next
[16:12:30.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.680]                 }
[16:12:30.680]                 if (length(args) > 0) 
[16:12:30.680]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.680]             }
[16:12:30.680]             else {
[16:12:30.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.680]             }
[16:12:30.680]             {
[16:12:30.680]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.680]                   0L) {
[16:12:30.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.680]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.680]                   base::options(opts)
[16:12:30.680]                 }
[16:12:30.680]                 {
[16:12:30.680]                   {
[16:12:30.680]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.680]                     NULL
[16:12:30.680]                   }
[16:12:30.680]                   options(future.plan = NULL)
[16:12:30.680]                   if (is.na(NA_character_)) 
[16:12:30.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.680]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.680]                     envir = parent.frame()) 
[16:12:30.680]                   {
[16:12:30.680]                     default_workers <- missing(workers)
[16:12:30.680]                     if (is.function(workers)) 
[16:12:30.680]                       workers <- workers()
[16:12:30.680]                     workers <- structure(as.integer(workers), 
[16:12:30.680]                       class = class(workers))
[16:12:30.680]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.680]                       1L)
[16:12:30.680]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.680]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.680]                       if (default_workers) 
[16:12:30.680]                         supportsMulticore(warn = TRUE)
[16:12:30.680]                       return(sequential(..., envir = envir))
[16:12:30.680]                     }
[16:12:30.680]                     oopts <- options(mc.cores = workers)
[16:12:30.680]                     on.exit(options(oopts))
[16:12:30.680]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.680]                       envir = envir)
[16:12:30.680]                     if (!future$lazy) 
[16:12:30.680]                       future <- run(future)
[16:12:30.680]                     invisible(future)
[16:12:30.680]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.680]                 }
[16:12:30.680]             }
[16:12:30.680]         }
[16:12:30.680]     })
[16:12:30.680]     if (TRUE) {
[16:12:30.680]         base::sink(type = "output", split = FALSE)
[16:12:30.680]         if (TRUE) {
[16:12:30.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.680]         }
[16:12:30.680]         else {
[16:12:30.680]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.680]         }
[16:12:30.680]         base::close(...future.stdout)
[16:12:30.680]         ...future.stdout <- NULL
[16:12:30.680]     }
[16:12:30.680]     ...future.result$conditions <- ...future.conditions
[16:12:30.680]     ...future.result$finished <- base::Sys.time()
[16:12:30.680]     ...future.result
[16:12:30.680] }
[16:12:30.683] requestCore(): workers = 2
[16:12:30.686] MulticoreFuture started
[16:12:30.686] - Launch lazy future ... done
[16:12:30.687] run() for ‘MulticoreFuture’ ... done
[16:12:30.687] plan(): Setting new future strategy stack:
[16:12:30.687] getGlobalsAndPackages() ...
[16:12:30.688] Searching for globals...
[16:12:30.687] List of future strategies:
[16:12:30.687] 1. sequential:
[16:12:30.687]    - args: function (..., envir = parent.frame())
[16:12:30.687]    - tweaked: FALSE
[16:12:30.687]    - call: NULL
[16:12:30.688] plan(): nbrOfWorkers() = 1
[16:12:30.689] - globals found: [1] ‘{’
[16:12:30.689] Searching for globals ... DONE
[16:12:30.689] Resolving globals: FALSE
[16:12:30.690] 
[16:12:30.690] 
[16:12:30.690] getGlobalsAndPackages() ... DONE
[16:12:30.690] plan(): Setting new future strategy stack:
[16:12:30.691] run() for ‘Future’ ...
[16:12:30.691] - state: ‘created’
[16:12:30.690] List of future strategies:
[16:12:30.690] 1. multicore:
[16:12:30.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.690]    - tweaked: FALSE
[16:12:30.690]    - call: plan(strategy)
[16:12:30.691] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.696] plan(): nbrOfWorkers() = 2
[16:12:30.696] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.697]   - Field: ‘label’
[16:12:30.697]   - Field: ‘local’
[16:12:30.697]   - Field: ‘owner’
[16:12:30.697]   - Field: ‘envir’
[16:12:30.697]   - Field: ‘workers’
[16:12:30.698]   - Field: ‘packages’
[16:12:30.698]   - Field: ‘gc’
[16:12:30.698]   - Field: ‘job’
[16:12:30.698]   - Field: ‘conditions’
[16:12:30.698]   - Field: ‘expr’
[16:12:30.698]   - Field: ‘uuid’
[16:12:30.698]   - Field: ‘seed’
[16:12:30.699]   - Field: ‘version’
[16:12:30.699]   - Field: ‘result’
[16:12:30.699]   - Field: ‘asynchronous’
[16:12:30.699]   - Field: ‘calls’
[16:12:30.699]   - Field: ‘globals’
[16:12:30.699]   - Field: ‘stdout’
[16:12:30.699]   - Field: ‘earlySignal’
[16:12:30.699]   - Field: ‘lazy’
[16:12:30.700]   - Field: ‘state’
[16:12:30.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.700] - Launch lazy future ...
[16:12:30.700] Packages needed by the future expression (n = 0): <none>
[16:12:30.701] Packages needed by future strategies (n = 0): <none>
[16:12:30.701] {
[16:12:30.701]     {
[16:12:30.701]         {
[16:12:30.701]             ...future.startTime <- base::Sys.time()
[16:12:30.701]             {
[16:12:30.701]                 {
[16:12:30.701]                   {
[16:12:30.701]                     {
[16:12:30.701]                       base::local({
[16:12:30.701]                         has_future <- base::requireNamespace("future", 
[16:12:30.701]                           quietly = TRUE)
[16:12:30.701]                         if (has_future) {
[16:12:30.701]                           ns <- base::getNamespace("future")
[16:12:30.701]                           version <- ns[[".package"]][["version"]]
[16:12:30.701]                           if (is.null(version)) 
[16:12:30.701]                             version <- utils::packageVersion("future")
[16:12:30.701]                         }
[16:12:30.701]                         else {
[16:12:30.701]                           version <- NULL
[16:12:30.701]                         }
[16:12:30.701]                         if (!has_future || version < "1.8.0") {
[16:12:30.701]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.701]                             "", base::R.version$version.string), 
[16:12:30.701]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.701]                               "release", "version")], collapse = " "), 
[16:12:30.701]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.701]                             info)
[16:12:30.701]                           info <- base::paste(info, collapse = "; ")
[16:12:30.701]                           if (!has_future) {
[16:12:30.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.701]                               info)
[16:12:30.701]                           }
[16:12:30.701]                           else {
[16:12:30.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.701]                               info, version)
[16:12:30.701]                           }
[16:12:30.701]                           base::stop(msg)
[16:12:30.701]                         }
[16:12:30.701]                       })
[16:12:30.701]                     }
[16:12:30.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.701]                     base::options(mc.cores = 1L)
[16:12:30.701]                   }
[16:12:30.701]                   options(future.plan = NULL)
[16:12:30.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.701]                 }
[16:12:30.701]                 ...future.workdir <- getwd()
[16:12:30.701]             }
[16:12:30.701]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.701]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.701]         }
[16:12:30.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.701]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.701]             base::names(...future.oldOptions))
[16:12:30.701]     }
[16:12:30.701]     if (FALSE) {
[16:12:30.701]     }
[16:12:30.701]     else {
[16:12:30.701]         if (TRUE) {
[16:12:30.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.701]                 open = "w")
[16:12:30.701]         }
[16:12:30.701]         else {
[16:12:30.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.701]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.701]         }
[16:12:30.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.701]             base::sink(type = "output", split = FALSE)
[16:12:30.701]             base::close(...future.stdout)
[16:12:30.701]         }, add = TRUE)
[16:12:30.701]     }
[16:12:30.701]     ...future.frame <- base::sys.nframe()
[16:12:30.701]     ...future.conditions <- base::list()
[16:12:30.701]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.701]     if (FALSE) {
[16:12:30.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.701]     }
[16:12:30.701]     ...future.result <- base::tryCatch({
[16:12:30.701]         base::withCallingHandlers({
[16:12:30.701]             ...future.value <- base::withVisible(base::local({
[16:12:30.701]                 withCallingHandlers({
[16:12:30.701]                   {
[16:12:30.701]                     4
[16:12:30.701]                   }
[16:12:30.701]                 }, immediateCondition = function(cond) {
[16:12:30.701]                   save_rds <- function (object, pathname, ...) 
[16:12:30.701]                   {
[16:12:30.701]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.701]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.701]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.701]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.701]                         fi_tmp[["mtime"]])
[16:12:30.701]                     }
[16:12:30.701]                     tryCatch({
[16:12:30.701]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.701]                     }, error = function(ex) {
[16:12:30.701]                       msg <- conditionMessage(ex)
[16:12:30.701]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.701]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.701]                         fi_tmp[["mtime"]], msg)
[16:12:30.701]                       ex$message <- msg
[16:12:30.701]                       stop(ex)
[16:12:30.701]                     })
[16:12:30.701]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.701]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.701]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.701]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.701]                       fi <- file.info(pathname)
[16:12:30.701]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.701]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.701]                         fi[["size"]], fi[["mtime"]])
[16:12:30.701]                       stop(msg)
[16:12:30.701]                     }
[16:12:30.701]                     invisible(pathname)
[16:12:30.701]                   }
[16:12:30.701]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.701]                     rootPath = tempdir()) 
[16:12:30.701]                   {
[16:12:30.701]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.701]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.701]                       tmpdir = path, fileext = ".rds")
[16:12:30.701]                     save_rds(obj, file)
[16:12:30.701]                   }
[16:12:30.701]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.701]                   {
[16:12:30.701]                     inherits <- base::inherits
[16:12:30.701]                     invokeRestart <- base::invokeRestart
[16:12:30.701]                     is.null <- base::is.null
[16:12:30.701]                     muffled <- FALSE
[16:12:30.701]                     if (inherits(cond, "message")) {
[16:12:30.701]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.701]                       if (muffled) 
[16:12:30.701]                         invokeRestart("muffleMessage")
[16:12:30.701]                     }
[16:12:30.701]                     else if (inherits(cond, "warning")) {
[16:12:30.701]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.701]                       if (muffled) 
[16:12:30.701]                         invokeRestart("muffleWarning")
[16:12:30.701]                     }
[16:12:30.701]                     else if (inherits(cond, "condition")) {
[16:12:30.701]                       if (!is.null(pattern)) {
[16:12:30.701]                         computeRestarts <- base::computeRestarts
[16:12:30.701]                         grepl <- base::grepl
[16:12:30.701]                         restarts <- computeRestarts(cond)
[16:12:30.701]                         for (restart in restarts) {
[16:12:30.701]                           name <- restart$name
[16:12:30.701]                           if (is.null(name)) 
[16:12:30.701]                             next
[16:12:30.701]                           if (!grepl(pattern, name)) 
[16:12:30.701]                             next
[16:12:30.701]                           invokeRestart(restart)
[16:12:30.701]                           muffled <- TRUE
[16:12:30.701]                           break
[16:12:30.701]                         }
[16:12:30.701]                       }
[16:12:30.701]                     }
[16:12:30.701]                     invisible(muffled)
[16:12:30.701]                   }
[16:12:30.701]                   muffleCondition(cond)
[16:12:30.701]                 })
[16:12:30.701]             }))
[16:12:30.701]             future::FutureResult(value = ...future.value$value, 
[16:12:30.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.701]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.701]                     ...future.globalenv.names))
[16:12:30.701]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.701]         }, condition = base::local({
[16:12:30.701]             c <- base::c
[16:12:30.701]             inherits <- base::inherits
[16:12:30.701]             invokeRestart <- base::invokeRestart
[16:12:30.701]             length <- base::length
[16:12:30.701]             list <- base::list
[16:12:30.701]             seq.int <- base::seq.int
[16:12:30.701]             signalCondition <- base::signalCondition
[16:12:30.701]             sys.calls <- base::sys.calls
[16:12:30.701]             `[[` <- base::`[[`
[16:12:30.701]             `+` <- base::`+`
[16:12:30.701]             `<<-` <- base::`<<-`
[16:12:30.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.701]                   3L)]
[16:12:30.701]             }
[16:12:30.701]             function(cond) {
[16:12:30.701]                 is_error <- inherits(cond, "error")
[16:12:30.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.701]                   NULL)
[16:12:30.701]                 if (is_error) {
[16:12:30.701]                   sessionInformation <- function() {
[16:12:30.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.701]                       search = base::search(), system = base::Sys.info())
[16:12:30.701]                   }
[16:12:30.701]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.701]                     cond$call), session = sessionInformation(), 
[16:12:30.701]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.701]                   signalCondition(cond)
[16:12:30.701]                 }
[16:12:30.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.701]                 "immediateCondition"))) {
[16:12:30.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.701]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.701]                   if (TRUE && !signal) {
[16:12:30.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.701]                     {
[16:12:30.701]                       inherits <- base::inherits
[16:12:30.701]                       invokeRestart <- base::invokeRestart
[16:12:30.701]                       is.null <- base::is.null
[16:12:30.701]                       muffled <- FALSE
[16:12:30.701]                       if (inherits(cond, "message")) {
[16:12:30.701]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.701]                         if (muffled) 
[16:12:30.701]                           invokeRestart("muffleMessage")
[16:12:30.701]                       }
[16:12:30.701]                       else if (inherits(cond, "warning")) {
[16:12:30.701]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.701]                         if (muffled) 
[16:12:30.701]                           invokeRestart("muffleWarning")
[16:12:30.701]                       }
[16:12:30.701]                       else if (inherits(cond, "condition")) {
[16:12:30.701]                         if (!is.null(pattern)) {
[16:12:30.701]                           computeRestarts <- base::computeRestarts
[16:12:30.701]                           grepl <- base::grepl
[16:12:30.701]                           restarts <- computeRestarts(cond)
[16:12:30.701]                           for (restart in restarts) {
[16:12:30.701]                             name <- restart$name
[16:12:30.701]                             if (is.null(name)) 
[16:12:30.701]                               next
[16:12:30.701]                             if (!grepl(pattern, name)) 
[16:12:30.701]                               next
[16:12:30.701]                             invokeRestart(restart)
[16:12:30.701]                             muffled <- TRUE
[16:12:30.701]                             break
[16:12:30.701]                           }
[16:12:30.701]                         }
[16:12:30.701]                       }
[16:12:30.701]                       invisible(muffled)
[16:12:30.701]                     }
[16:12:30.701]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.701]                   }
[16:12:30.701]                 }
[16:12:30.701]                 else {
[16:12:30.701]                   if (TRUE) {
[16:12:30.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.701]                     {
[16:12:30.701]                       inherits <- base::inherits
[16:12:30.701]                       invokeRestart <- base::invokeRestart
[16:12:30.701]                       is.null <- base::is.null
[16:12:30.701]                       muffled <- FALSE
[16:12:30.701]                       if (inherits(cond, "message")) {
[16:12:30.701]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.701]                         if (muffled) 
[16:12:30.701]                           invokeRestart("muffleMessage")
[16:12:30.701]                       }
[16:12:30.701]                       else if (inherits(cond, "warning")) {
[16:12:30.701]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.701]                         if (muffled) 
[16:12:30.701]                           invokeRestart("muffleWarning")
[16:12:30.701]                       }
[16:12:30.701]                       else if (inherits(cond, "condition")) {
[16:12:30.701]                         if (!is.null(pattern)) {
[16:12:30.701]                           computeRestarts <- base::computeRestarts
[16:12:30.701]                           grepl <- base::grepl
[16:12:30.701]                           restarts <- computeRestarts(cond)
[16:12:30.701]                           for (restart in restarts) {
[16:12:30.701]                             name <- restart$name
[16:12:30.701]                             if (is.null(name)) 
[16:12:30.701]                               next
[16:12:30.701]                             if (!grepl(pattern, name)) 
[16:12:30.701]                               next
[16:12:30.701]                             invokeRestart(restart)
[16:12:30.701]                             muffled <- TRUE
[16:12:30.701]                             break
[16:12:30.701]                           }
[16:12:30.701]                         }
[16:12:30.701]                       }
[16:12:30.701]                       invisible(muffled)
[16:12:30.701]                     }
[16:12:30.701]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.701]                   }
[16:12:30.701]                 }
[16:12:30.701]             }
[16:12:30.701]         }))
[16:12:30.701]     }, error = function(ex) {
[16:12:30.701]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.701]                 ...future.rng), started = ...future.startTime, 
[16:12:30.701]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.701]             version = "1.8"), class = "FutureResult")
[16:12:30.701]     }, finally = {
[16:12:30.701]         if (!identical(...future.workdir, getwd())) 
[16:12:30.701]             setwd(...future.workdir)
[16:12:30.701]         {
[16:12:30.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.701]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.701]             }
[16:12:30.701]             base::options(...future.oldOptions)
[16:12:30.701]             if (.Platform$OS.type == "windows") {
[16:12:30.701]                 old_names <- names(...future.oldEnvVars)
[16:12:30.701]                 envs <- base::Sys.getenv()
[16:12:30.701]                 names <- names(envs)
[16:12:30.701]                 common <- intersect(names, old_names)
[16:12:30.701]                 added <- setdiff(names, old_names)
[16:12:30.701]                 removed <- setdiff(old_names, names)
[16:12:30.701]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.701]                   envs[common]]
[16:12:30.701]                 NAMES <- toupper(changed)
[16:12:30.701]                 args <- list()
[16:12:30.701]                 for (kk in seq_along(NAMES)) {
[16:12:30.701]                   name <- changed[[kk]]
[16:12:30.701]                   NAME <- NAMES[[kk]]
[16:12:30.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.701]                     next
[16:12:30.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.701]                 }
[16:12:30.701]                 NAMES <- toupper(added)
[16:12:30.701]                 for (kk in seq_along(NAMES)) {
[16:12:30.701]                   name <- added[[kk]]
[16:12:30.701]                   NAME <- NAMES[[kk]]
[16:12:30.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.701]                     next
[16:12:30.701]                   args[[name]] <- ""
[16:12:30.701]                 }
[16:12:30.701]                 NAMES <- toupper(removed)
[16:12:30.701]                 for (kk in seq_along(NAMES)) {
[16:12:30.701]                   name <- removed[[kk]]
[16:12:30.701]                   NAME <- NAMES[[kk]]
[16:12:30.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.701]                     next
[16:12:30.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.701]                 }
[16:12:30.701]                 if (length(args) > 0) 
[16:12:30.701]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.701]             }
[16:12:30.701]             else {
[16:12:30.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.701]             }
[16:12:30.701]             {
[16:12:30.701]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.701]                   0L) {
[16:12:30.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.701]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.701]                   base::options(opts)
[16:12:30.701]                 }
[16:12:30.701]                 {
[16:12:30.701]                   {
[16:12:30.701]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.701]                     NULL
[16:12:30.701]                   }
[16:12:30.701]                   options(future.plan = NULL)
[16:12:30.701]                   if (is.na(NA_character_)) 
[16:12:30.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.701]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.701]                     envir = parent.frame()) 
[16:12:30.701]                   {
[16:12:30.701]                     default_workers <- missing(workers)
[16:12:30.701]                     if (is.function(workers)) 
[16:12:30.701]                       workers <- workers()
[16:12:30.701]                     workers <- structure(as.integer(workers), 
[16:12:30.701]                       class = class(workers))
[16:12:30.701]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.701]                       1L)
[16:12:30.701]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.701]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.701]                       if (default_workers) 
[16:12:30.701]                         supportsMulticore(warn = TRUE)
[16:12:30.701]                       return(sequential(..., envir = envir))
[16:12:30.701]                     }
[16:12:30.701]                     oopts <- options(mc.cores = workers)
[16:12:30.701]                     on.exit(options(oopts))
[16:12:30.701]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.701]                       envir = envir)
[16:12:30.701]                     if (!future$lazy) 
[16:12:30.701]                       future <- run(future)
[16:12:30.701]                     invisible(future)
[16:12:30.701]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.701]                 }
[16:12:30.701]             }
[16:12:30.701]         }
[16:12:30.701]     })
[16:12:30.701]     if (TRUE) {
[16:12:30.701]         base::sink(type = "output", split = FALSE)
[16:12:30.701]         if (TRUE) {
[16:12:30.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.701]         }
[16:12:30.701]         else {
[16:12:30.701]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.701]         }
[16:12:30.701]         base::close(...future.stdout)
[16:12:30.701]         ...future.stdout <- NULL
[16:12:30.701]     }
[16:12:30.701]     ...future.result$conditions <- ...future.conditions
[16:12:30.701]     ...future.result$finished <- base::Sys.time()
[16:12:30.701]     ...future.result
[16:12:30.701] }
[16:12:30.705] requestCore(): workers = 2
[16:12:30.705] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:30.720] MulticoreFuture started
[16:12:30.721] - Launch lazy future ... done
[16:12:30.721] run() for ‘MulticoreFuture’ ... done
[16:12:30.721] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x560bae493688> 
[16:12:30.721] List of future strategies:
[16:12:30.721] 1. sequential:
[16:12:30.721]    - args: function (..., envir = parent.frame())
[16:12:30.721]    - tweaked: FALSE
[16:12:30.721]    - call: NULL
[16:12:30.722] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x560bafed49c8> 
 - attr(*, "dim.")=[16:12:30.724] plan(): Setting new future strategy stack:
 int [1:3] 2 3 1
 - attr(*, "dimnames.")=[16:12:30.724] List of future strategies:
[16:12:30.724] 1. multicore:
[16:12:30.724]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.724]    - tweaked: FALSE
[16:12:30.724]    - call: plan(strategy)
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:30.729] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:30.734] resolve() on list environment ...
[16:12:30.734]  recursive: 0
[16:12:30.735]  length: 6
[16:12:30.735]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:30.736] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.736] - nx: 6
[16:12:30.736] - relay: TRUE
[16:12:30.736] - stdout: TRUE
[16:12:30.736] - signal: TRUE
[16:12:30.736] - resignal: FALSE
[16:12:30.736] - force: TRUE
[16:12:30.736] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.737] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.737]  - until=2
[16:12:30.737]  - relaying element #2
[16:12:30.737] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.737] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.737] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.737]  length: 5 (resolved future 1)
[16:12:30.738] Future #2
[16:12:30.738] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:30.738] - nx: 6
[16:12:30.738] - relay: TRUE
[16:12:30.738] - stdout: TRUE
[16:12:30.738] - signal: TRUE
[16:12:30.738] - resignal: FALSE
[16:12:30.739] - force: TRUE
[16:12:30.739] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.739] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.739]  - until=2
[16:12:30.739]  - relaying element #2
[16:12:30.739] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.739] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.740] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:30.740]  length: 4 (resolved future 2)
[16:12:30.740] Future #3
[16:12:30.741] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:30.741] - nx: 6
[16:12:30.741] - relay: TRUE
[16:12:30.741] - stdout: TRUE
[16:12:30.742] - signal: TRUE
[16:12:30.742] - resignal: FALSE
[16:12:30.742] - force: TRUE
[16:12:30.742] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.742] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.742]  - until=3
[16:12:30.742]  - relaying element #3
[16:12:30.743] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.743] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.743] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:30.743]  length: 3 (resolved future 3)
[16:12:30.743] Future #4
[16:12:30.744] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:30.744] - nx: 6
[16:12:30.744] - relay: TRUE
[16:12:30.744] - stdout: TRUE
[16:12:30.745] - signal: TRUE
[16:12:30.745] - resignal: FALSE
[16:12:30.745] - force: TRUE
[16:12:30.745] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.745] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.745]  - until=4
[16:12:30.745]  - relaying element #4
[16:12:30.746] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.746] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.746] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:30.746]  length: 2 (resolved future 4)
[16:12:30.746] signalConditionsASAP(NULL, pos=5) ...
[16:12:30.746] - nx: 6
[16:12:30.746] - relay: TRUE
[16:12:30.746] - stdout: TRUE
[16:12:30.746] - signal: TRUE
[16:12:30.747] - resignal: FALSE
[16:12:30.747] - force: TRUE
[16:12:30.747] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.747] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.747]  - until=6
[16:12:30.747]  - relaying element #6
[16:12:30.747] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.747] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.747] signalConditionsASAP(NULL, pos=5) ... done
[16:12:30.748]  length: 1 (resolved future 5)
[16:12:30.748] signalConditionsASAP(numeric, pos=6) ...
[16:12:30.748] - nx: 6
[16:12:30.748] - relay: TRUE
[16:12:30.748] - stdout: TRUE
[16:12:30.748] - signal: TRUE
[16:12:30.748] - resignal: FALSE
[16:12:30.748] - force: TRUE
[16:12:30.748] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.749] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.749]  - until=6
[16:12:30.749] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.749] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.749] signalConditionsASAP(numeric, pos=6) ... done
[16:12:30.749]  length: 0 (resolved future 6)
[16:12:30.749] Relaying remaining futures
[16:12:30.749] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.749] - nx: 6
[16:12:30.749] - relay: TRUE
[16:12:30.750] - stdout: TRUE
[16:12:30.750] - signal: TRUE
[16:12:30.750] - resignal: FALSE
[16:12:30.750] - force: TRUE
[16:12:30.750] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.750] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:30.750] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.750] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.750] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.751] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bb0214290> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:12:30.753] getGlobalsAndPackages() ...
[16:12:30.753] Searching for globals...
[16:12:30.754] 
[16:12:30.754] Searching for globals ... DONE
[16:12:30.754] - globals: [0] <none>
[16:12:30.754] getGlobalsAndPackages() ... DONE
[16:12:30.754] run() for ‘Future’ ...
[16:12:30.754] - state: ‘created’
[16:12:30.755] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.759] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.759]   - Field: ‘label’
[16:12:30.759]   - Field: ‘local’
[16:12:30.759]   - Field: ‘owner’
[16:12:30.760]   - Field: ‘envir’
[16:12:30.760]   - Field: ‘workers’
[16:12:30.760]   - Field: ‘packages’
[16:12:30.760]   - Field: ‘gc’
[16:12:30.760]   - Field: ‘job’
[16:12:30.760]   - Field: ‘conditions’
[16:12:30.760]   - Field: ‘expr’
[16:12:30.760]   - Field: ‘uuid’
[16:12:30.760]   - Field: ‘seed’
[16:12:30.761]   - Field: ‘version’
[16:12:30.761]   - Field: ‘result’
[16:12:30.761]   - Field: ‘asynchronous’
[16:12:30.761]   - Field: ‘calls’
[16:12:30.761]   - Field: ‘globals’
[16:12:30.761]   - Field: ‘stdout’
[16:12:30.765]   - Field: ‘earlySignal’
[16:12:30.766]   - Field: ‘lazy’
[16:12:30.766]   - Field: ‘state’
[16:12:30.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.766] - Launch lazy future ...
[16:12:30.767] Packages needed by the future expression (n = 0): <none>
[16:12:30.767] Packages needed by future strategies (n = 0): <none>
[16:12:30.767] {
[16:12:30.767]     {
[16:12:30.767]         {
[16:12:30.767]             ...future.startTime <- base::Sys.time()
[16:12:30.767]             {
[16:12:30.767]                 {
[16:12:30.767]                   {
[16:12:30.767]                     {
[16:12:30.767]                       base::local({
[16:12:30.767]                         has_future <- base::requireNamespace("future", 
[16:12:30.767]                           quietly = TRUE)
[16:12:30.767]                         if (has_future) {
[16:12:30.767]                           ns <- base::getNamespace("future")
[16:12:30.767]                           version <- ns[[".package"]][["version"]]
[16:12:30.767]                           if (is.null(version)) 
[16:12:30.767]                             version <- utils::packageVersion("future")
[16:12:30.767]                         }
[16:12:30.767]                         else {
[16:12:30.767]                           version <- NULL
[16:12:30.767]                         }
[16:12:30.767]                         if (!has_future || version < "1.8.0") {
[16:12:30.767]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.767]                             "", base::R.version$version.string), 
[16:12:30.767]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.767]                               "release", "version")], collapse = " "), 
[16:12:30.767]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.767]                             info)
[16:12:30.767]                           info <- base::paste(info, collapse = "; ")
[16:12:30.767]                           if (!has_future) {
[16:12:30.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.767]                               info)
[16:12:30.767]                           }
[16:12:30.767]                           else {
[16:12:30.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.767]                               info, version)
[16:12:30.767]                           }
[16:12:30.767]                           base::stop(msg)
[16:12:30.767]                         }
[16:12:30.767]                       })
[16:12:30.767]                     }
[16:12:30.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.767]                     base::options(mc.cores = 1L)
[16:12:30.767]                   }
[16:12:30.767]                   options(future.plan = NULL)
[16:12:30.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.767]                 }
[16:12:30.767]                 ...future.workdir <- getwd()
[16:12:30.767]             }
[16:12:30.767]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.767]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.767]         }
[16:12:30.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.767]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.767]             base::names(...future.oldOptions))
[16:12:30.767]     }
[16:12:30.767]     if (FALSE) {
[16:12:30.767]     }
[16:12:30.767]     else {
[16:12:30.767]         if (TRUE) {
[16:12:30.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.767]                 open = "w")
[16:12:30.767]         }
[16:12:30.767]         else {
[16:12:30.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.767]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.767]         }
[16:12:30.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.767]             base::sink(type = "output", split = FALSE)
[16:12:30.767]             base::close(...future.stdout)
[16:12:30.767]         }, add = TRUE)
[16:12:30.767]     }
[16:12:30.767]     ...future.frame <- base::sys.nframe()
[16:12:30.767]     ...future.conditions <- base::list()
[16:12:30.767]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.767]     if (FALSE) {
[16:12:30.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.767]     }
[16:12:30.767]     ...future.result <- base::tryCatch({
[16:12:30.767]         base::withCallingHandlers({
[16:12:30.767]             ...future.value <- base::withVisible(base::local({
[16:12:30.767]                 withCallingHandlers({
[16:12:30.767]                   2
[16:12:30.767]                 }, immediateCondition = function(cond) {
[16:12:30.767]                   save_rds <- function (object, pathname, ...) 
[16:12:30.767]                   {
[16:12:30.767]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.767]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.767]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.767]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.767]                         fi_tmp[["mtime"]])
[16:12:30.767]                     }
[16:12:30.767]                     tryCatch({
[16:12:30.767]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.767]                     }, error = function(ex) {
[16:12:30.767]                       msg <- conditionMessage(ex)
[16:12:30.767]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.767]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.767]                         fi_tmp[["mtime"]], msg)
[16:12:30.767]                       ex$message <- msg
[16:12:30.767]                       stop(ex)
[16:12:30.767]                     })
[16:12:30.767]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.767]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.767]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.767]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.767]                       fi <- file.info(pathname)
[16:12:30.767]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.767]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.767]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.767]                         fi[["size"]], fi[["mtime"]])
[16:12:30.767]                       stop(msg)
[16:12:30.767]                     }
[16:12:30.767]                     invisible(pathname)
[16:12:30.767]                   }
[16:12:30.767]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.767]                     rootPath = tempdir()) 
[16:12:30.767]                   {
[16:12:30.767]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.767]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.767]                       tmpdir = path, fileext = ".rds")
[16:12:30.767]                     save_rds(obj, file)
[16:12:30.767]                   }
[16:12:30.767]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.767]                   {
[16:12:30.767]                     inherits <- base::inherits
[16:12:30.767]                     invokeRestart <- base::invokeRestart
[16:12:30.767]                     is.null <- base::is.null
[16:12:30.767]                     muffled <- FALSE
[16:12:30.767]                     if (inherits(cond, "message")) {
[16:12:30.767]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.767]                       if (muffled) 
[16:12:30.767]                         invokeRestart("muffleMessage")
[16:12:30.767]                     }
[16:12:30.767]                     else if (inherits(cond, "warning")) {
[16:12:30.767]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.767]                       if (muffled) 
[16:12:30.767]                         invokeRestart("muffleWarning")
[16:12:30.767]                     }
[16:12:30.767]                     else if (inherits(cond, "condition")) {
[16:12:30.767]                       if (!is.null(pattern)) {
[16:12:30.767]                         computeRestarts <- base::computeRestarts
[16:12:30.767]                         grepl <- base::grepl
[16:12:30.767]                         restarts <- computeRestarts(cond)
[16:12:30.767]                         for (restart in restarts) {
[16:12:30.767]                           name <- restart$name
[16:12:30.767]                           if (is.null(name)) 
[16:12:30.767]                             next
[16:12:30.767]                           if (!grepl(pattern, name)) 
[16:12:30.767]                             next
[16:12:30.767]                           invokeRestart(restart)
[16:12:30.767]                           muffled <- TRUE
[16:12:30.767]                           break
[16:12:30.767]                         }
[16:12:30.767]                       }
[16:12:30.767]                     }
[16:12:30.767]                     invisible(muffled)
[16:12:30.767]                   }
[16:12:30.767]                   muffleCondition(cond)
[16:12:30.767]                 })
[16:12:30.767]             }))
[16:12:30.767]             future::FutureResult(value = ...future.value$value, 
[16:12:30.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.767]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.767]                     ...future.globalenv.names))
[16:12:30.767]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.767]         }, condition = base::local({
[16:12:30.767]             c <- base::c
[16:12:30.767]             inherits <- base::inherits
[16:12:30.767]             invokeRestart <- base::invokeRestart
[16:12:30.767]             length <- base::length
[16:12:30.767]             list <- base::list
[16:12:30.767]             seq.int <- base::seq.int
[16:12:30.767]             signalCondition <- base::signalCondition
[16:12:30.767]             sys.calls <- base::sys.calls
[16:12:30.767]             `[[` <- base::`[[`
[16:12:30.767]             `+` <- base::`+`
[16:12:30.767]             `<<-` <- base::`<<-`
[16:12:30.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.767]                   3L)]
[16:12:30.767]             }
[16:12:30.767]             function(cond) {
[16:12:30.767]                 is_error <- inherits(cond, "error")
[16:12:30.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.767]                   NULL)
[16:12:30.767]                 if (is_error) {
[16:12:30.767]                   sessionInformation <- function() {
[16:12:30.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.767]                       search = base::search(), system = base::Sys.info())
[16:12:30.767]                   }
[16:12:30.767]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.767]                     cond$call), session = sessionInformation(), 
[16:12:30.767]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.767]                   signalCondition(cond)
[16:12:30.767]                 }
[16:12:30.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.767]                 "immediateCondition"))) {
[16:12:30.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.767]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.767]                   if (TRUE && !signal) {
[16:12:30.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.767]                     {
[16:12:30.767]                       inherits <- base::inherits
[16:12:30.767]                       invokeRestart <- base::invokeRestart
[16:12:30.767]                       is.null <- base::is.null
[16:12:30.767]                       muffled <- FALSE
[16:12:30.767]                       if (inherits(cond, "message")) {
[16:12:30.767]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.767]                         if (muffled) 
[16:12:30.767]                           invokeRestart("muffleMessage")
[16:12:30.767]                       }
[16:12:30.767]                       else if (inherits(cond, "warning")) {
[16:12:30.767]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.767]                         if (muffled) 
[16:12:30.767]                           invokeRestart("muffleWarning")
[16:12:30.767]                       }
[16:12:30.767]                       else if (inherits(cond, "condition")) {
[16:12:30.767]                         if (!is.null(pattern)) {
[16:12:30.767]                           computeRestarts <- base::computeRestarts
[16:12:30.767]                           grepl <- base::grepl
[16:12:30.767]                           restarts <- computeRestarts(cond)
[16:12:30.767]                           for (restart in restarts) {
[16:12:30.767]                             name <- restart$name
[16:12:30.767]                             if (is.null(name)) 
[16:12:30.767]                               next
[16:12:30.767]                             if (!grepl(pattern, name)) 
[16:12:30.767]                               next
[16:12:30.767]                             invokeRestart(restart)
[16:12:30.767]                             muffled <- TRUE
[16:12:30.767]                             break
[16:12:30.767]                           }
[16:12:30.767]                         }
[16:12:30.767]                       }
[16:12:30.767]                       invisible(muffled)
[16:12:30.767]                     }
[16:12:30.767]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.767]                   }
[16:12:30.767]                 }
[16:12:30.767]                 else {
[16:12:30.767]                   if (TRUE) {
[16:12:30.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.767]                     {
[16:12:30.767]                       inherits <- base::inherits
[16:12:30.767]                       invokeRestart <- base::invokeRestart
[16:12:30.767]                       is.null <- base::is.null
[16:12:30.767]                       muffled <- FALSE
[16:12:30.767]                       if (inherits(cond, "message")) {
[16:12:30.767]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.767]                         if (muffled) 
[16:12:30.767]                           invokeRestart("muffleMessage")
[16:12:30.767]                       }
[16:12:30.767]                       else if (inherits(cond, "warning")) {
[16:12:30.767]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.767]                         if (muffled) 
[16:12:30.767]                           invokeRestart("muffleWarning")
[16:12:30.767]                       }
[16:12:30.767]                       else if (inherits(cond, "condition")) {
[16:12:30.767]                         if (!is.null(pattern)) {
[16:12:30.767]                           computeRestarts <- base::computeRestarts
[16:12:30.767]                           grepl <- base::grepl
[16:12:30.767]                           restarts <- computeRestarts(cond)
[16:12:30.767]                           for (restart in restarts) {
[16:12:30.767]                             name <- restart$name
[16:12:30.767]                             if (is.null(name)) 
[16:12:30.767]                               next
[16:12:30.767]                             if (!grepl(pattern, name)) 
[16:12:30.767]                               next
[16:12:30.767]                             invokeRestart(restart)
[16:12:30.767]                             muffled <- TRUE
[16:12:30.767]                             break
[16:12:30.767]                           }
[16:12:30.767]                         }
[16:12:30.767]                       }
[16:12:30.767]                       invisible(muffled)
[16:12:30.767]                     }
[16:12:30.767]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.767]                   }
[16:12:30.767]                 }
[16:12:30.767]             }
[16:12:30.767]         }))
[16:12:30.767]     }, error = function(ex) {
[16:12:30.767]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.767]                 ...future.rng), started = ...future.startTime, 
[16:12:30.767]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.767]             version = "1.8"), class = "FutureResult")
[16:12:30.767]     }, finally = {
[16:12:30.767]         if (!identical(...future.workdir, getwd())) 
[16:12:30.767]             setwd(...future.workdir)
[16:12:30.767]         {
[16:12:30.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.767]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.767]             }
[16:12:30.767]             base::options(...future.oldOptions)
[16:12:30.767]             if (.Platform$OS.type == "windows") {
[16:12:30.767]                 old_names <- names(...future.oldEnvVars)
[16:12:30.767]                 envs <- base::Sys.getenv()
[16:12:30.767]                 names <- names(envs)
[16:12:30.767]                 common <- intersect(names, old_names)
[16:12:30.767]                 added <- setdiff(names, old_names)
[16:12:30.767]                 removed <- setdiff(old_names, names)
[16:12:30.767]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.767]                   envs[common]]
[16:12:30.767]                 NAMES <- toupper(changed)
[16:12:30.767]                 args <- list()
[16:12:30.767]                 for (kk in seq_along(NAMES)) {
[16:12:30.767]                   name <- changed[[kk]]
[16:12:30.767]                   NAME <- NAMES[[kk]]
[16:12:30.767]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.767]                     next
[16:12:30.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.767]                 }
[16:12:30.767]                 NAMES <- toupper(added)
[16:12:30.767]                 for (kk in seq_along(NAMES)) {
[16:12:30.767]                   name <- added[[kk]]
[16:12:30.767]                   NAME <- NAMES[[kk]]
[16:12:30.767]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.767]                     next
[16:12:30.767]                   args[[name]] <- ""
[16:12:30.767]                 }
[16:12:30.767]                 NAMES <- toupper(removed)
[16:12:30.767]                 for (kk in seq_along(NAMES)) {
[16:12:30.767]                   name <- removed[[kk]]
[16:12:30.767]                   NAME <- NAMES[[kk]]
[16:12:30.767]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.767]                     next
[16:12:30.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.767]                 }
[16:12:30.767]                 if (length(args) > 0) 
[16:12:30.767]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.767]             }
[16:12:30.767]             else {
[16:12:30.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.767]             }
[16:12:30.767]             {
[16:12:30.767]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.767]                   0L) {
[16:12:30.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.767]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.767]                   base::options(opts)
[16:12:30.767]                 }
[16:12:30.767]                 {
[16:12:30.767]                   {
[16:12:30.767]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.767]                     NULL
[16:12:30.767]                   }
[16:12:30.767]                   options(future.plan = NULL)
[16:12:30.767]                   if (is.na(NA_character_)) 
[16:12:30.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.767]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.767]                     envir = parent.frame()) 
[16:12:30.767]                   {
[16:12:30.767]                     default_workers <- missing(workers)
[16:12:30.767]                     if (is.function(workers)) 
[16:12:30.767]                       workers <- workers()
[16:12:30.767]                     workers <- structure(as.integer(workers), 
[16:12:30.767]                       class = class(workers))
[16:12:30.767]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.767]                       1L)
[16:12:30.767]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.767]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.767]                       if (default_workers) 
[16:12:30.767]                         supportsMulticore(warn = TRUE)
[16:12:30.767]                       return(sequential(..., envir = envir))
[16:12:30.767]                     }
[16:12:30.767]                     oopts <- options(mc.cores = workers)
[16:12:30.767]                     on.exit(options(oopts))
[16:12:30.767]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.767]                       envir = envir)
[16:12:30.767]                     if (!future$lazy) 
[16:12:30.767]                       future <- run(future)
[16:12:30.767]                     invisible(future)
[16:12:30.767]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.767]                 }
[16:12:30.767]             }
[16:12:30.767]         }
[16:12:30.767]     })
[16:12:30.767]     if (TRUE) {
[16:12:30.767]         base::sink(type = "output", split = FALSE)
[16:12:30.767]         if (TRUE) {
[16:12:30.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.767]         }
[16:12:30.767]         else {
[16:12:30.767]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.767]         }
[16:12:30.767]         base::close(...future.stdout)
[16:12:30.767]         ...future.stdout <- NULL
[16:12:30.767]     }
[16:12:30.767]     ...future.result$conditions <- ...future.conditions
[16:12:30.767]     ...future.result$finished <- base::Sys.time()
[16:12:30.767]     ...future.result
[16:12:30.767] }
[16:12:30.770] requestCore(): workers = 2
[16:12:30.772] MulticoreFuture started
[16:12:30.773] - Launch lazy future ... done
[16:12:30.773] run() for ‘MulticoreFuture’ ... done
[16:12:30.773] getGlobalsAndPackages() ...
[16:12:30.774] Searching for globals...
[16:12:30.774] plan(): Setting new future strategy stack:
[16:12:30.774] List of future strategies:
[16:12:30.774] 1. sequential:
[16:12:30.774]    - args: function (..., envir = parent.frame())
[16:12:30.774]    - tweaked: FALSE
[16:12:30.774]    - call: NULL
[16:12:30.775] 
[16:12:30.775] Searching for globals ... DONE
[16:12:30.775] plan(): nbrOfWorkers() = 1
[16:12:30.775] - globals: [0] <none>
[16:12:30.775] getGlobalsAndPackages() ... DONE
[16:12:30.776] run() for ‘Future’ ...
[16:12:30.776] - state: ‘created’
[16:12:30.776] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.777] plan(): Setting new future strategy stack:
[16:12:30.777] List of future strategies:
[16:12:30.777] 1. multicore:
[16:12:30.777]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.777]    - tweaked: FALSE
[16:12:30.777]    - call: plan(strategy)
[16:12:30.781] plan(): nbrOfWorkers() = 2
[16:12:30.782] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.782]   - Field: ‘label’
[16:12:30.782]   - Field: ‘local’
[16:12:30.782]   - Field: ‘owner’
[16:12:30.782]   - Field: ‘envir’
[16:12:30.783]   - Field: ‘workers’
[16:12:30.783]   - Field: ‘packages’
[16:12:30.783]   - Field: ‘gc’
[16:12:30.783]   - Field: ‘job’
[16:12:30.783]   - Field: ‘conditions’
[16:12:30.783]   - Field: ‘expr’
[16:12:30.783]   - Field: ‘uuid’
[16:12:30.784]   - Field: ‘seed’
[16:12:30.784]   - Field: ‘version’
[16:12:30.784]   - Field: ‘result’
[16:12:30.784]   - Field: ‘asynchronous’
[16:12:30.784]   - Field: ‘calls’
[16:12:30.784]   - Field: ‘globals’
[16:12:30.785]   - Field: ‘stdout’
[16:12:30.785]   - Field: ‘earlySignal’
[16:12:30.785]   - Field: ‘lazy’
[16:12:30.785]   - Field: ‘state’
[16:12:30.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.785] - Launch lazy future ...
[16:12:30.786] Packages needed by the future expression (n = 0): <none>
[16:12:30.786] Packages needed by future strategies (n = 0): <none>
[16:12:30.787] {
[16:12:30.787]     {
[16:12:30.787]         {
[16:12:30.787]             ...future.startTime <- base::Sys.time()
[16:12:30.787]             {
[16:12:30.787]                 {
[16:12:30.787]                   {
[16:12:30.787]                     {
[16:12:30.787]                       base::local({
[16:12:30.787]                         has_future <- base::requireNamespace("future", 
[16:12:30.787]                           quietly = TRUE)
[16:12:30.787]                         if (has_future) {
[16:12:30.787]                           ns <- base::getNamespace("future")
[16:12:30.787]                           version <- ns[[".package"]][["version"]]
[16:12:30.787]                           if (is.null(version)) 
[16:12:30.787]                             version <- utils::packageVersion("future")
[16:12:30.787]                         }
[16:12:30.787]                         else {
[16:12:30.787]                           version <- NULL
[16:12:30.787]                         }
[16:12:30.787]                         if (!has_future || version < "1.8.0") {
[16:12:30.787]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.787]                             "", base::R.version$version.string), 
[16:12:30.787]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.787]                               "release", "version")], collapse = " "), 
[16:12:30.787]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.787]                             info)
[16:12:30.787]                           info <- base::paste(info, collapse = "; ")
[16:12:30.787]                           if (!has_future) {
[16:12:30.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.787]                               info)
[16:12:30.787]                           }
[16:12:30.787]                           else {
[16:12:30.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.787]                               info, version)
[16:12:30.787]                           }
[16:12:30.787]                           base::stop(msg)
[16:12:30.787]                         }
[16:12:30.787]                       })
[16:12:30.787]                     }
[16:12:30.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.787]                     base::options(mc.cores = 1L)
[16:12:30.787]                   }
[16:12:30.787]                   options(future.plan = NULL)
[16:12:30.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.787]                 }
[16:12:30.787]                 ...future.workdir <- getwd()
[16:12:30.787]             }
[16:12:30.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.787]         }
[16:12:30.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.787]             base::names(...future.oldOptions))
[16:12:30.787]     }
[16:12:30.787]     if (FALSE) {
[16:12:30.787]     }
[16:12:30.787]     else {
[16:12:30.787]         if (TRUE) {
[16:12:30.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.787]                 open = "w")
[16:12:30.787]         }
[16:12:30.787]         else {
[16:12:30.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.787]         }
[16:12:30.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.787]             base::sink(type = "output", split = FALSE)
[16:12:30.787]             base::close(...future.stdout)
[16:12:30.787]         }, add = TRUE)
[16:12:30.787]     }
[16:12:30.787]     ...future.frame <- base::sys.nframe()
[16:12:30.787]     ...future.conditions <- base::list()
[16:12:30.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.787]     if (FALSE) {
[16:12:30.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.787]     }
[16:12:30.787]     ...future.result <- base::tryCatch({
[16:12:30.787]         base::withCallingHandlers({
[16:12:30.787]             ...future.value <- base::withVisible(base::local({
[16:12:30.787]                 withCallingHandlers({
[16:12:30.787]                   NULL
[16:12:30.787]                 }, immediateCondition = function(cond) {
[16:12:30.787]                   save_rds <- function (object, pathname, ...) 
[16:12:30.787]                   {
[16:12:30.787]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.787]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.787]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.787]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.787]                         fi_tmp[["mtime"]])
[16:12:30.787]                     }
[16:12:30.787]                     tryCatch({
[16:12:30.787]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.787]                     }, error = function(ex) {
[16:12:30.787]                       msg <- conditionMessage(ex)
[16:12:30.787]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.787]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.787]                         fi_tmp[["mtime"]], msg)
[16:12:30.787]                       ex$message <- msg
[16:12:30.787]                       stop(ex)
[16:12:30.787]                     })
[16:12:30.787]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.787]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.787]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.787]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.787]                       fi <- file.info(pathname)
[16:12:30.787]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.787]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.787]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.787]                         fi[["size"]], fi[["mtime"]])
[16:12:30.787]                       stop(msg)
[16:12:30.787]                     }
[16:12:30.787]                     invisible(pathname)
[16:12:30.787]                   }
[16:12:30.787]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.787]                     rootPath = tempdir()) 
[16:12:30.787]                   {
[16:12:30.787]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.787]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.787]                       tmpdir = path, fileext = ".rds")
[16:12:30.787]                     save_rds(obj, file)
[16:12:30.787]                   }
[16:12:30.787]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.787]                   {
[16:12:30.787]                     inherits <- base::inherits
[16:12:30.787]                     invokeRestart <- base::invokeRestart
[16:12:30.787]                     is.null <- base::is.null
[16:12:30.787]                     muffled <- FALSE
[16:12:30.787]                     if (inherits(cond, "message")) {
[16:12:30.787]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.787]                       if (muffled) 
[16:12:30.787]                         invokeRestart("muffleMessage")
[16:12:30.787]                     }
[16:12:30.787]                     else if (inherits(cond, "warning")) {
[16:12:30.787]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.787]                       if (muffled) 
[16:12:30.787]                         invokeRestart("muffleWarning")
[16:12:30.787]                     }
[16:12:30.787]                     else if (inherits(cond, "condition")) {
[16:12:30.787]                       if (!is.null(pattern)) {
[16:12:30.787]                         computeRestarts <- base::computeRestarts
[16:12:30.787]                         grepl <- base::grepl
[16:12:30.787]                         restarts <- computeRestarts(cond)
[16:12:30.787]                         for (restart in restarts) {
[16:12:30.787]                           name <- restart$name
[16:12:30.787]                           if (is.null(name)) 
[16:12:30.787]                             next
[16:12:30.787]                           if (!grepl(pattern, name)) 
[16:12:30.787]                             next
[16:12:30.787]                           invokeRestart(restart)
[16:12:30.787]                           muffled <- TRUE
[16:12:30.787]                           break
[16:12:30.787]                         }
[16:12:30.787]                       }
[16:12:30.787]                     }
[16:12:30.787]                     invisible(muffled)
[16:12:30.787]                   }
[16:12:30.787]                   muffleCondition(cond)
[16:12:30.787]                 })
[16:12:30.787]             }))
[16:12:30.787]             future::FutureResult(value = ...future.value$value, 
[16:12:30.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.787]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.787]                     ...future.globalenv.names))
[16:12:30.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.787]         }, condition = base::local({
[16:12:30.787]             c <- base::c
[16:12:30.787]             inherits <- base::inherits
[16:12:30.787]             invokeRestart <- base::invokeRestart
[16:12:30.787]             length <- base::length
[16:12:30.787]             list <- base::list
[16:12:30.787]             seq.int <- base::seq.int
[16:12:30.787]             signalCondition <- base::signalCondition
[16:12:30.787]             sys.calls <- base::sys.calls
[16:12:30.787]             `[[` <- base::`[[`
[16:12:30.787]             `+` <- base::`+`
[16:12:30.787]             `<<-` <- base::`<<-`
[16:12:30.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.787]                   3L)]
[16:12:30.787]             }
[16:12:30.787]             function(cond) {
[16:12:30.787]                 is_error <- inherits(cond, "error")
[16:12:30.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.787]                   NULL)
[16:12:30.787]                 if (is_error) {
[16:12:30.787]                   sessionInformation <- function() {
[16:12:30.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.787]                       search = base::search(), system = base::Sys.info())
[16:12:30.787]                   }
[16:12:30.787]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.787]                     cond$call), session = sessionInformation(), 
[16:12:30.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.787]                   signalCondition(cond)
[16:12:30.787]                 }
[16:12:30.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.787]                 "immediateCondition"))) {
[16:12:30.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.787]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.787]                   if (TRUE && !signal) {
[16:12:30.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.787]                     {
[16:12:30.787]                       inherits <- base::inherits
[16:12:30.787]                       invokeRestart <- base::invokeRestart
[16:12:30.787]                       is.null <- base::is.null
[16:12:30.787]                       muffled <- FALSE
[16:12:30.787]                       if (inherits(cond, "message")) {
[16:12:30.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.787]                         if (muffled) 
[16:12:30.787]                           invokeRestart("muffleMessage")
[16:12:30.787]                       }
[16:12:30.787]                       else if (inherits(cond, "warning")) {
[16:12:30.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.787]                         if (muffled) 
[16:12:30.787]                           invokeRestart("muffleWarning")
[16:12:30.787]                       }
[16:12:30.787]                       else if (inherits(cond, "condition")) {
[16:12:30.787]                         if (!is.null(pattern)) {
[16:12:30.787]                           computeRestarts <- base::computeRestarts
[16:12:30.787]                           grepl <- base::grepl
[16:12:30.787]                           restarts <- computeRestarts(cond)
[16:12:30.787]                           for (restart in restarts) {
[16:12:30.787]                             name <- restart$name
[16:12:30.787]                             if (is.null(name)) 
[16:12:30.787]                               next
[16:12:30.787]                             if (!grepl(pattern, name)) 
[16:12:30.787]                               next
[16:12:30.787]                             invokeRestart(restart)
[16:12:30.787]                             muffled <- TRUE
[16:12:30.787]                             break
[16:12:30.787]                           }
[16:12:30.787]                         }
[16:12:30.787]                       }
[16:12:30.787]                       invisible(muffled)
[16:12:30.787]                     }
[16:12:30.787]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.787]                   }
[16:12:30.787]                 }
[16:12:30.787]                 else {
[16:12:30.787]                   if (TRUE) {
[16:12:30.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.787]                     {
[16:12:30.787]                       inherits <- base::inherits
[16:12:30.787]                       invokeRestart <- base::invokeRestart
[16:12:30.787]                       is.null <- base::is.null
[16:12:30.787]                       muffled <- FALSE
[16:12:30.787]                       if (inherits(cond, "message")) {
[16:12:30.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.787]                         if (muffled) 
[16:12:30.787]                           invokeRestart("muffleMessage")
[16:12:30.787]                       }
[16:12:30.787]                       else if (inherits(cond, "warning")) {
[16:12:30.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.787]                         if (muffled) 
[16:12:30.787]                           invokeRestart("muffleWarning")
[16:12:30.787]                       }
[16:12:30.787]                       else if (inherits(cond, "condition")) {
[16:12:30.787]                         if (!is.null(pattern)) {
[16:12:30.787]                           computeRestarts <- base::computeRestarts
[16:12:30.787]                           grepl <- base::grepl
[16:12:30.787]                           restarts <- computeRestarts(cond)
[16:12:30.787]                           for (restart in restarts) {
[16:12:30.787]                             name <- restart$name
[16:12:30.787]                             if (is.null(name)) 
[16:12:30.787]                               next
[16:12:30.787]                             if (!grepl(pattern, name)) 
[16:12:30.787]                               next
[16:12:30.787]                             invokeRestart(restart)
[16:12:30.787]                             muffled <- TRUE
[16:12:30.787]                             break
[16:12:30.787]                           }
[16:12:30.787]                         }
[16:12:30.787]                       }
[16:12:30.787]                       invisible(muffled)
[16:12:30.787]                     }
[16:12:30.787]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.787]                   }
[16:12:30.787]                 }
[16:12:30.787]             }
[16:12:30.787]         }))
[16:12:30.787]     }, error = function(ex) {
[16:12:30.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.787]                 ...future.rng), started = ...future.startTime, 
[16:12:30.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.787]             version = "1.8"), class = "FutureResult")
[16:12:30.787]     }, finally = {
[16:12:30.787]         if (!identical(...future.workdir, getwd())) 
[16:12:30.787]             setwd(...future.workdir)
[16:12:30.787]         {
[16:12:30.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.787]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.787]             }
[16:12:30.787]             base::options(...future.oldOptions)
[16:12:30.787]             if (.Platform$OS.type == "windows") {
[16:12:30.787]                 old_names <- names(...future.oldEnvVars)
[16:12:30.787]                 envs <- base::Sys.getenv()
[16:12:30.787]                 names <- names(envs)
[16:12:30.787]                 common <- intersect(names, old_names)
[16:12:30.787]                 added <- setdiff(names, old_names)
[16:12:30.787]                 removed <- setdiff(old_names, names)
[16:12:30.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.787]                   envs[common]]
[16:12:30.787]                 NAMES <- toupper(changed)
[16:12:30.787]                 args <- list()
[16:12:30.787]                 for (kk in seq_along(NAMES)) {
[16:12:30.787]                   name <- changed[[kk]]
[16:12:30.787]                   NAME <- NAMES[[kk]]
[16:12:30.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.787]                     next
[16:12:30.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.787]                 }
[16:12:30.787]                 NAMES <- toupper(added)
[16:12:30.787]                 for (kk in seq_along(NAMES)) {
[16:12:30.787]                   name <- added[[kk]]
[16:12:30.787]                   NAME <- NAMES[[kk]]
[16:12:30.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.787]                     next
[16:12:30.787]                   args[[name]] <- ""
[16:12:30.787]                 }
[16:12:30.787]                 NAMES <- toupper(removed)
[16:12:30.787]                 for (kk in seq_along(NAMES)) {
[16:12:30.787]                   name <- removed[[kk]]
[16:12:30.787]                   NAME <- NAMES[[kk]]
[16:12:30.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.787]                     next
[16:12:30.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.787]                 }
[16:12:30.787]                 if (length(args) > 0) 
[16:12:30.787]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.787]             }
[16:12:30.787]             else {
[16:12:30.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.787]             }
[16:12:30.787]             {
[16:12:30.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.787]                   0L) {
[16:12:30.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.787]                   base::options(opts)
[16:12:30.787]                 }
[16:12:30.787]                 {
[16:12:30.787]                   {
[16:12:30.787]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.787]                     NULL
[16:12:30.787]                   }
[16:12:30.787]                   options(future.plan = NULL)
[16:12:30.787]                   if (is.na(NA_character_)) 
[16:12:30.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.787]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.787]                     envir = parent.frame()) 
[16:12:30.787]                   {
[16:12:30.787]                     default_workers <- missing(workers)
[16:12:30.787]                     if (is.function(workers)) 
[16:12:30.787]                       workers <- workers()
[16:12:30.787]                     workers <- structure(as.integer(workers), 
[16:12:30.787]                       class = class(workers))
[16:12:30.787]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.787]                       1L)
[16:12:30.787]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.787]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.787]                       if (default_workers) 
[16:12:30.787]                         supportsMulticore(warn = TRUE)
[16:12:30.787]                       return(sequential(..., envir = envir))
[16:12:30.787]                     }
[16:12:30.787]                     oopts <- options(mc.cores = workers)
[16:12:30.787]                     on.exit(options(oopts))
[16:12:30.787]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.787]                       envir = envir)
[16:12:30.787]                     if (!future$lazy) 
[16:12:30.787]                       future <- run(future)
[16:12:30.787]                     invisible(future)
[16:12:30.787]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.787]                 }
[16:12:30.787]             }
[16:12:30.787]         }
[16:12:30.787]     })
[16:12:30.787]     if (TRUE) {
[16:12:30.787]         base::sink(type = "output", split = FALSE)
[16:12:30.787]         if (TRUE) {
[16:12:30.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.787]         }
[16:12:30.787]         else {
[16:12:30.787]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.787]         }
[16:12:30.787]         base::close(...future.stdout)
[16:12:30.787]         ...future.stdout <- NULL
[16:12:30.787]     }
[16:12:30.787]     ...future.result$conditions <- ...future.conditions
[16:12:30.787]     ...future.result$finished <- base::Sys.time()
[16:12:30.787]     ...future.result
[16:12:30.787] }
[16:12:30.791] requestCore(): workers = 2
[16:12:30.794] MulticoreFuture started
[16:12:30.794] - Launch lazy future ... done
[16:12:30.794] run() for ‘MulticoreFuture’ ... done
[16:12:30.795] plan(): Setting new future strategy stack:
[16:12:30.795] getGlobalsAndPackages() ...
[16:12:30.795] Searching for globals...
[16:12:30.795] List of future strategies:
[16:12:30.795] 1. sequential:
[16:12:30.795]    - args: function (..., envir = parent.frame())
[16:12:30.795]    - tweaked: FALSE
[16:12:30.795]    - call: NULL
[16:12:30.796] plan(): nbrOfWorkers() = 1
[16:12:30.797] - globals found: [1] ‘{’
[16:12:30.797] Searching for globals ... DONE
[16:12:30.797] Resolving globals: FALSE
[16:12:30.798] 
[16:12:30.798] 
[16:12:30.798] getGlobalsAndPackages() ... DONE
[16:12:30.798] plan(): Setting new future strategy stack:
[16:12:30.799] run() for ‘Future’ ...
[16:12:30.798] List of future strategies:
[16:12:30.798] 1. multicore:
[16:12:30.798]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.798]    - tweaked: FALSE
[16:12:30.798]    - call: plan(strategy)
[16:12:30.799] - state: ‘created’
[16:12:30.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:12:30.804] plan(): nbrOfWorkers() = 2
[16:12:30.804] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:30.804] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:12:30.804]   - Field: ‘label’
[16:12:30.805]   - Field: ‘local’
[16:12:30.805]   - Field: ‘owner’
[16:12:30.805]   - Field: ‘envir’
[16:12:30.805]   - Field: ‘workers’
[16:12:30.805]   - Field: ‘packages’
[16:12:30.805]   - Field: ‘gc’
[16:12:30.805]   - Field: ‘job’
[16:12:30.806]   - Field: ‘conditions’
[16:12:30.806]   - Field: ‘expr’
[16:12:30.806]   - Field: ‘uuid’
[16:12:30.806]   - Field: ‘seed’
[16:12:30.806]   - Field: ‘version’
[16:12:30.806]   - Field: ‘result’
[16:12:30.806]   - Field: ‘asynchronous’
[16:12:30.807]   - Field: ‘calls’
[16:12:30.807]   - Field: ‘globals’
[16:12:30.807]   - Field: ‘stdout’
[16:12:30.807]   - Field: ‘earlySignal’
[16:12:30.807]   - Field: ‘lazy’
[16:12:30.807]   - Field: ‘state’
[16:12:30.807] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:12:30.808] - Launch lazy future ...
[16:12:30.808] Packages needed by the future expression (n = 0): <none>
[16:12:30.808] Packages needed by future strategies (n = 0): <none>
[16:12:30.809] {
[16:12:30.809]     {
[16:12:30.809]         {
[16:12:30.809]             ...future.startTime <- base::Sys.time()
[16:12:30.809]             {
[16:12:30.809]                 {
[16:12:30.809]                   {
[16:12:30.809]                     {
[16:12:30.809]                       base::local({
[16:12:30.809]                         has_future <- base::requireNamespace("future", 
[16:12:30.809]                           quietly = TRUE)
[16:12:30.809]                         if (has_future) {
[16:12:30.809]                           ns <- base::getNamespace("future")
[16:12:30.809]                           version <- ns[[".package"]][["version"]]
[16:12:30.809]                           if (is.null(version)) 
[16:12:30.809]                             version <- utils::packageVersion("future")
[16:12:30.809]                         }
[16:12:30.809]                         else {
[16:12:30.809]                           version <- NULL
[16:12:30.809]                         }
[16:12:30.809]                         if (!has_future || version < "1.8.0") {
[16:12:30.809]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:30.809]                             "", base::R.version$version.string), 
[16:12:30.809]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:30.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:30.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:30.809]                               "release", "version")], collapse = " "), 
[16:12:30.809]                             hostname = base::Sys.info()[["nodename"]])
[16:12:30.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:30.809]                             info)
[16:12:30.809]                           info <- base::paste(info, collapse = "; ")
[16:12:30.809]                           if (!has_future) {
[16:12:30.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:30.809]                               info)
[16:12:30.809]                           }
[16:12:30.809]                           else {
[16:12:30.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:30.809]                               info, version)
[16:12:30.809]                           }
[16:12:30.809]                           base::stop(msg)
[16:12:30.809]                         }
[16:12:30.809]                       })
[16:12:30.809]                     }
[16:12:30.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:30.809]                     base::options(mc.cores = 1L)
[16:12:30.809]                   }
[16:12:30.809]                   options(future.plan = NULL)
[16:12:30.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:30.809]                 }
[16:12:30.809]                 ...future.workdir <- getwd()
[16:12:30.809]             }
[16:12:30.809]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:30.809]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:30.809]         }
[16:12:30.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:30.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:30.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:30.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:30.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:30.809]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:30.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:30.809]             base::names(...future.oldOptions))
[16:12:30.809]     }
[16:12:30.809]     if (FALSE) {
[16:12:30.809]     }
[16:12:30.809]     else {
[16:12:30.809]         if (TRUE) {
[16:12:30.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:30.809]                 open = "w")
[16:12:30.809]         }
[16:12:30.809]         else {
[16:12:30.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:30.809]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:30.809]         }
[16:12:30.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:30.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:30.809]             base::sink(type = "output", split = FALSE)
[16:12:30.809]             base::close(...future.stdout)
[16:12:30.809]         }, add = TRUE)
[16:12:30.809]     }
[16:12:30.809]     ...future.frame <- base::sys.nframe()
[16:12:30.809]     ...future.conditions <- base::list()
[16:12:30.809]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:30.809]     if (FALSE) {
[16:12:30.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:30.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:30.809]     }
[16:12:30.809]     ...future.result <- base::tryCatch({
[16:12:30.809]         base::withCallingHandlers({
[16:12:30.809]             ...future.value <- base::withVisible(base::local({
[16:12:30.809]                 withCallingHandlers({
[16:12:30.809]                   {
[16:12:30.809]                     4
[16:12:30.809]                   }
[16:12:30.809]                 }, immediateCondition = function(cond) {
[16:12:30.809]                   save_rds <- function (object, pathname, ...) 
[16:12:30.809]                   {
[16:12:30.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:12:30.809]                     if (file_test("-f", pathname_tmp)) {
[16:12:30.809]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:12:30.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.809]                         fi_tmp[["mtime"]])
[16:12:30.809]                     }
[16:12:30.809]                     tryCatch({
[16:12:30.809]                       saveRDS(object, file = pathname_tmp, ...)
[16:12:30.809]                     }, error = function(ex) {
[16:12:30.809]                       msg <- conditionMessage(ex)
[16:12:30.809]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:12:30.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.809]                         fi_tmp[["mtime"]], msg)
[16:12:30.809]                       ex$message <- msg
[16:12:30.809]                       stop(ex)
[16:12:30.809]                     })
[16:12:30.809]                     stopifnot(file_test("-f", pathname_tmp))
[16:12:30.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:12:30.809]                     if (!res || file_test("-f", pathname_tmp)) {
[16:12:30.809]                       fi_tmp <- file.info(pathname_tmp)
[16:12:30.809]                       fi <- file.info(pathname)
[16:12:30.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:12:30.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:12:30.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:12:30.809]                         fi[["size"]], fi[["mtime"]])
[16:12:30.809]                       stop(msg)
[16:12:30.809]                     }
[16:12:30.809]                     invisible(pathname)
[16:12:30.809]                   }
[16:12:30.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:12:30.809]                     rootPath = tempdir()) 
[16:12:30.809]                   {
[16:12:30.809]                     obj <- list(time = Sys.time(), condition = cond)
[16:12:30.809]                     file <- tempfile(pattern = class(cond)[1], 
[16:12:30.809]                       tmpdir = path, fileext = ".rds")
[16:12:30.809]                     save_rds(obj, file)
[16:12:30.809]                   }
[16:12:30.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpEHnG6O/.future/immediateConditions")
[16:12:30.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.809]                   {
[16:12:30.809]                     inherits <- base::inherits
[16:12:30.809]                     invokeRestart <- base::invokeRestart
[16:12:30.809]                     is.null <- base::is.null
[16:12:30.809]                     muffled <- FALSE
[16:12:30.809]                     if (inherits(cond, "message")) {
[16:12:30.809]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:30.809]                       if (muffled) 
[16:12:30.809]                         invokeRestart("muffleMessage")
[16:12:30.809]                     }
[16:12:30.809]                     else if (inherits(cond, "warning")) {
[16:12:30.809]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:30.809]                       if (muffled) 
[16:12:30.809]                         invokeRestart("muffleWarning")
[16:12:30.809]                     }
[16:12:30.809]                     else if (inherits(cond, "condition")) {
[16:12:30.809]                       if (!is.null(pattern)) {
[16:12:30.809]                         computeRestarts <- base::computeRestarts
[16:12:30.809]                         grepl <- base::grepl
[16:12:30.809]                         restarts <- computeRestarts(cond)
[16:12:30.809]                         for (restart in restarts) {
[16:12:30.809]                           name <- restart$name
[16:12:30.809]                           if (is.null(name)) 
[16:12:30.809]                             next
[16:12:30.809]                           if (!grepl(pattern, name)) 
[16:12:30.809]                             next
[16:12:30.809]                           invokeRestart(restart)
[16:12:30.809]                           muffled <- TRUE
[16:12:30.809]                           break
[16:12:30.809]                         }
[16:12:30.809]                       }
[16:12:30.809]                     }
[16:12:30.809]                     invisible(muffled)
[16:12:30.809]                   }
[16:12:30.809]                   muffleCondition(cond)
[16:12:30.809]                 })
[16:12:30.809]             }))
[16:12:30.809]             future::FutureResult(value = ...future.value$value, 
[16:12:30.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.809]                   ...future.rng), globalenv = if (FALSE) 
[16:12:30.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:30.809]                     ...future.globalenv.names))
[16:12:30.809]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:30.809]         }, condition = base::local({
[16:12:30.809]             c <- base::c
[16:12:30.809]             inherits <- base::inherits
[16:12:30.809]             invokeRestart <- base::invokeRestart
[16:12:30.809]             length <- base::length
[16:12:30.809]             list <- base::list
[16:12:30.809]             seq.int <- base::seq.int
[16:12:30.809]             signalCondition <- base::signalCondition
[16:12:30.809]             sys.calls <- base::sys.calls
[16:12:30.809]             `[[` <- base::`[[`
[16:12:30.809]             `+` <- base::`+`
[16:12:30.809]             `<<-` <- base::`<<-`
[16:12:30.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:30.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:30.809]                   3L)]
[16:12:30.809]             }
[16:12:30.809]             function(cond) {
[16:12:30.809]                 is_error <- inherits(cond, "error")
[16:12:30.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:30.809]                   NULL)
[16:12:30.809]                 if (is_error) {
[16:12:30.809]                   sessionInformation <- function() {
[16:12:30.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:30.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:30.809]                       search = base::search(), system = base::Sys.info())
[16:12:30.809]                   }
[16:12:30.809]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:30.809]                     cond$call), session = sessionInformation(), 
[16:12:30.809]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:30.809]                   signalCondition(cond)
[16:12:30.809]                 }
[16:12:30.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:30.809]                 "immediateCondition"))) {
[16:12:30.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:30.809]                   ...future.conditions[[length(...future.conditions) + 
[16:12:30.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:30.809]                   if (TRUE && !signal) {
[16:12:30.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.809]                     {
[16:12:30.809]                       inherits <- base::inherits
[16:12:30.809]                       invokeRestart <- base::invokeRestart
[16:12:30.809]                       is.null <- base::is.null
[16:12:30.809]                       muffled <- FALSE
[16:12:30.809]                       if (inherits(cond, "message")) {
[16:12:30.809]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.809]                         if (muffled) 
[16:12:30.809]                           invokeRestart("muffleMessage")
[16:12:30.809]                       }
[16:12:30.809]                       else if (inherits(cond, "warning")) {
[16:12:30.809]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.809]                         if (muffled) 
[16:12:30.809]                           invokeRestart("muffleWarning")
[16:12:30.809]                       }
[16:12:30.809]                       else if (inherits(cond, "condition")) {
[16:12:30.809]                         if (!is.null(pattern)) {
[16:12:30.809]                           computeRestarts <- base::computeRestarts
[16:12:30.809]                           grepl <- base::grepl
[16:12:30.809]                           restarts <- computeRestarts(cond)
[16:12:30.809]                           for (restart in restarts) {
[16:12:30.809]                             name <- restart$name
[16:12:30.809]                             if (is.null(name)) 
[16:12:30.809]                               next
[16:12:30.809]                             if (!grepl(pattern, name)) 
[16:12:30.809]                               next
[16:12:30.809]                             invokeRestart(restart)
[16:12:30.809]                             muffled <- TRUE
[16:12:30.809]                             break
[16:12:30.809]                           }
[16:12:30.809]                         }
[16:12:30.809]                       }
[16:12:30.809]                       invisible(muffled)
[16:12:30.809]                     }
[16:12:30.809]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.809]                   }
[16:12:30.809]                 }
[16:12:30.809]                 else {
[16:12:30.809]                   if (TRUE) {
[16:12:30.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:30.809]                     {
[16:12:30.809]                       inherits <- base::inherits
[16:12:30.809]                       invokeRestart <- base::invokeRestart
[16:12:30.809]                       is.null <- base::is.null
[16:12:30.809]                       muffled <- FALSE
[16:12:30.809]                       if (inherits(cond, "message")) {
[16:12:30.809]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:30.809]                         if (muffled) 
[16:12:30.809]                           invokeRestart("muffleMessage")
[16:12:30.809]                       }
[16:12:30.809]                       else if (inherits(cond, "warning")) {
[16:12:30.809]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:30.809]                         if (muffled) 
[16:12:30.809]                           invokeRestart("muffleWarning")
[16:12:30.809]                       }
[16:12:30.809]                       else if (inherits(cond, "condition")) {
[16:12:30.809]                         if (!is.null(pattern)) {
[16:12:30.809]                           computeRestarts <- base::computeRestarts
[16:12:30.809]                           grepl <- base::grepl
[16:12:30.809]                           restarts <- computeRestarts(cond)
[16:12:30.809]                           for (restart in restarts) {
[16:12:30.809]                             name <- restart$name
[16:12:30.809]                             if (is.null(name)) 
[16:12:30.809]                               next
[16:12:30.809]                             if (!grepl(pattern, name)) 
[16:12:30.809]                               next
[16:12:30.809]                             invokeRestart(restart)
[16:12:30.809]                             muffled <- TRUE
[16:12:30.809]                             break
[16:12:30.809]                           }
[16:12:30.809]                         }
[16:12:30.809]                       }
[16:12:30.809]                       invisible(muffled)
[16:12:30.809]                     }
[16:12:30.809]                     muffleCondition(cond, pattern = "^muffle")
[16:12:30.809]                   }
[16:12:30.809]                 }
[16:12:30.809]             }
[16:12:30.809]         }))
[16:12:30.809]     }, error = function(ex) {
[16:12:30.809]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:30.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:30.809]                 ...future.rng), started = ...future.startTime, 
[16:12:30.809]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:30.809]             version = "1.8"), class = "FutureResult")
[16:12:30.809]     }, finally = {
[16:12:30.809]         if (!identical(...future.workdir, getwd())) 
[16:12:30.809]             setwd(...future.workdir)
[16:12:30.809]         {
[16:12:30.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:30.809]                 ...future.oldOptions$nwarnings <- NULL
[16:12:30.809]             }
[16:12:30.809]             base::options(...future.oldOptions)
[16:12:30.809]             if (.Platform$OS.type == "windows") {
[16:12:30.809]                 old_names <- names(...future.oldEnvVars)
[16:12:30.809]                 envs <- base::Sys.getenv()
[16:12:30.809]                 names <- names(envs)
[16:12:30.809]                 common <- intersect(names, old_names)
[16:12:30.809]                 added <- setdiff(names, old_names)
[16:12:30.809]                 removed <- setdiff(old_names, names)
[16:12:30.809]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:30.809]                   envs[common]]
[16:12:30.809]                 NAMES <- toupper(changed)
[16:12:30.809]                 args <- list()
[16:12:30.809]                 for (kk in seq_along(NAMES)) {
[16:12:30.809]                   name <- changed[[kk]]
[16:12:30.809]                   NAME <- NAMES[[kk]]
[16:12:30.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.809]                     next
[16:12:30.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.809]                 }
[16:12:30.809]                 NAMES <- toupper(added)
[16:12:30.809]                 for (kk in seq_along(NAMES)) {
[16:12:30.809]                   name <- added[[kk]]
[16:12:30.809]                   NAME <- NAMES[[kk]]
[16:12:30.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.809]                     next
[16:12:30.809]                   args[[name]] <- ""
[16:12:30.809]                 }
[16:12:30.809]                 NAMES <- toupper(removed)
[16:12:30.809]                 for (kk in seq_along(NAMES)) {
[16:12:30.809]                   name <- removed[[kk]]
[16:12:30.809]                   NAME <- NAMES[[kk]]
[16:12:30.809]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:30.809]                     next
[16:12:30.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:30.809]                 }
[16:12:30.809]                 if (length(args) > 0) 
[16:12:30.809]                   base::do.call(base::Sys.setenv, args = args)
[16:12:30.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:30.809]             }
[16:12:30.809]             else {
[16:12:30.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:30.809]             }
[16:12:30.809]             {
[16:12:30.809]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:30.809]                   0L) {
[16:12:30.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:30.809]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:30.809]                   base::options(opts)
[16:12:30.809]                 }
[16:12:30.809]                 {
[16:12:30.809]                   {
[16:12:30.809]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:30.809]                     NULL
[16:12:30.809]                   }
[16:12:30.809]                   options(future.plan = NULL)
[16:12:30.809]                   if (is.na(NA_character_)) 
[16:12:30.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:30.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:30.809]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:12:30.809]                     envir = parent.frame()) 
[16:12:30.809]                   {
[16:12:30.809]                     default_workers <- missing(workers)
[16:12:30.809]                     if (is.function(workers)) 
[16:12:30.809]                       workers <- workers()
[16:12:30.809]                     workers <- structure(as.integer(workers), 
[16:12:30.809]                       class = class(workers))
[16:12:30.809]                     stop_if_not(is.finite(workers), workers >= 
[16:12:30.809]                       1L)
[16:12:30.809]                     if ((workers == 1L && !inherits(workers, 
[16:12:30.809]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:12:30.809]                       if (default_workers) 
[16:12:30.809]                         supportsMulticore(warn = TRUE)
[16:12:30.809]                       return(sequential(..., envir = envir))
[16:12:30.809]                     }
[16:12:30.809]                     oopts <- options(mc.cores = workers)
[16:12:30.809]                     on.exit(options(oopts))
[16:12:30.809]                     future <- MulticoreFuture(..., workers = workers, 
[16:12:30.809]                       envir = envir)
[16:12:30.809]                     if (!future$lazy) 
[16:12:30.809]                       future <- run(future)
[16:12:30.809]                     invisible(future)
[16:12:30.809]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:30.809]                 }
[16:12:30.809]             }
[16:12:30.809]         }
[16:12:30.809]     })
[16:12:30.809]     if (TRUE) {
[16:12:30.809]         base::sink(type = "output", split = FALSE)
[16:12:30.809]         if (TRUE) {
[16:12:30.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:30.809]         }
[16:12:30.809]         else {
[16:12:30.809]             ...future.result["stdout"] <- base::list(NULL)
[16:12:30.809]         }
[16:12:30.809]         base::close(...future.stdout)
[16:12:30.809]         ...future.stdout <- NULL
[16:12:30.809]     }
[16:12:30.809]     ...future.result$conditions <- ...future.conditions
[16:12:30.809]     ...future.result$finished <- base::Sys.time()
[16:12:30.809]     ...future.result
[16:12:30.809] }
[16:12:30.813] requestCore(): workers = 2
[16:12:30.813] Poll #1 (0): usedCores() = 2, workers = 2
[16:12:30.828] MulticoreFuture started
[16:12:30.829] - Launch lazy future ... done
[16:12:30.829] run() for ‘MulticoreFuture’ ... done
[16:12:30.830] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x560bb0a1eb70> 
[16:12:30.830] List of future strategies:
[16:12:30.830] 1. sequential:
[16:12:30.830]    - args: function (..., envir = parent.frame())
[16:12:30.830]    - tweaked: FALSE
[16:12:30.830]    - call: NULL
[16:12:30.832] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x560bae4927a8> 
 - attr(*, "dim.")=[16:12:30.835] plan(): Setting new future strategy stack:
 int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ :[16:12:30.835] List of future strategies:
[16:12:30.835] 1. multicore:
[16:12:30.835]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:12:30.835]    - tweaked: FALSE
[16:12:30.835]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:30.842] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:30.848] resolve() on list environment ...
[16:12:30.848]  recursive: 0
[16:12:30.850]  length: 6
[16:12:30.850]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:30.850] signalConditionsASAP(numeric, pos=1) ...
[16:12:30.850] - nx: 6
[16:12:30.850] - relay: TRUE
[16:12:30.850] - stdout: TRUE
[16:12:30.851] - signal: TRUE
[16:12:30.851] - resignal: FALSE
[16:12:30.851] - force: TRUE
[16:12:30.851] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.851] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.851]  - until=2
[16:12:30.851]  - relaying element #2
[16:12:30.852] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.852] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.852] signalConditionsASAP(NULL, pos=1) ... done
[16:12:30.852]  length: 5 (resolved future 1)
[16:12:30.852] Future #2
[16:12:30.853] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:12:30.853] - nx: 6
[16:12:30.853] - relay: TRUE
[16:12:30.853] - stdout: TRUE
[16:12:30.853] - signal: TRUE
[16:12:30.853] - resignal: FALSE
[16:12:30.853] - force: TRUE
[16:12:30.853] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.854] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:30.854]  - until=2
[16:12:30.854]  - relaying element #2
[16:12:30.854] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.854] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.854] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:12:30.855]  length: 4 (resolved future 2)
[16:12:30.855] Future #3
[16:12:30.856] signalConditionsASAP(MulticoreFuture, pos=3) ...
[16:12:30.856] - nx: 6
[16:12:30.856] - relay: TRUE
[16:12:30.856] - stdout: TRUE
[16:12:30.857] - signal: TRUE
[16:12:30.857] - resignal: FALSE
[16:12:30.857] - force: TRUE
[16:12:30.857] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.857] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:30.857]  - until=3
[16:12:30.857]  - relaying element #3
[16:12:30.858] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.858] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.858] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[16:12:30.858]  length: 3 (resolved future 3)
[16:12:30.858] Future #4
[16:12:30.859] signalConditionsASAP(MulticoreFuture, pos=4) ...
[16:12:30.859] - nx: 6
[16:12:30.860] - relay: TRUE
[16:12:30.860] - stdout: TRUE
[16:12:30.860] - signal: TRUE
[16:12:30.860] - resignal: FALSE
[16:12:30.860] - force: TRUE
[16:12:30.860] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.861] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:30.861]  - until=4
[16:12:30.861]  - relaying element #4
[16:12:30.861] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.861] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.862] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[16:12:30.862]  length: 2 (resolved future 4)
[16:12:30.862] signalConditionsASAP(NULL, pos=5) ...
[16:12:30.862] - nx: 6
[16:12:30.862] - relay: TRUE
[16:12:30.862] - stdout: TRUE
[16:12:30.863] - signal: TRUE
[16:12:30.863] - resignal: FALSE
[16:12:30.863] - force: TRUE
[16:12:30.863] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.863] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.863]  - until=6
[16:12:30.863]  - relaying element #6
[16:12:30.864] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.864] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.864] signalConditionsASAP(NULL, pos=5) ... done
[16:12:30.864]  length: 1 (resolved future 5)
[16:12:30.864] signalConditionsASAP(numeric, pos=6) ...
[16:12:30.864] - nx: 6
[16:12:30.864] - relay: TRUE
[16:12:30.864] - stdout: TRUE
[16:12:30.865] - signal: TRUE
[16:12:30.865] - resignal: FALSE
[16:12:30.865] - force: TRUE
[16:12:30.865] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[16:12:30.865] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.865]  - until=6
[16:12:30.865] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.865] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.865] signalConditionsASAP(numeric, pos=6) ... done
[16:12:30.865]  length: 0 (resolved future 6)
[16:12:30.866] Relaying remaining futures
[16:12:30.866] signalConditionsASAP(NULL, pos=0) ...
[16:12:30.866] - nx: 6
[16:12:30.866] - relay: TRUE
[16:12:30.866] - stdout: TRUE
[16:12:30.866] - signal: TRUE
[16:12:30.866] - resignal: FALSE
[16:12:30.866] - force: TRUE
[16:12:30.866] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.866] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:30.867] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:30.867] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:30.867] signalConditionsASAP(NULL, pos=0) ... done
[16:12:30.867] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x560bacc40730> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[16:12:30.870] plan(): Setting new future strategy stack:
[16:12:30.870] List of future strategies:
[16:12:30.870] 1. multisession:
[16:12:30.870]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:30.870]    - tweaked: FALSE
[16:12:30.870]    - call: plan(strategy)
[16:12:30.871] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:12:30.871] multisession:
[16:12:30.871] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:12:30.871] - tweaked: FALSE
[16:12:30.871] - call: plan(strategy)
[16:12:30.875] getGlobalsAndPackages() ...
[16:12:30.875] Not searching for globals
[16:12:30.875] - globals: [0] <none>
[16:12:30.875] getGlobalsAndPackages() ... DONE
[16:12:30.876] [local output] makeClusterPSOCK() ...
[16:12:30.876] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:12:30.877] [local output] Base port: 11499
[16:12:30.877] [local output] Getting setup options for 2 cluster nodes ...
[16:12:30.877] [local output]  - Node 1 of 2 ...
[16:12:30.877] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:30.878] [local output] Rscript port: 11499

[16:12:30.879] [local output]  - Node 2 of 2 ...
[16:12:30.879] [local output] localMachine=TRUE => revtunnel=FALSE

[16:12:30.880] [local output] Rscript port: 11499

[16:12:30.880] [local output] Getting setup options for 2 cluster nodes ... done
[16:12:30.880] [local output]  - Parallel setup requested for some PSOCK nodes
[16:12:30.880] [local output] Setting up PSOCK nodes in parallel
[16:12:30.881] List of 36
[16:12:30.881]  $ worker          : chr "localhost"
[16:12:30.881]   ..- attr(*, "localhost")= logi TRUE
[16:12:30.881]  $ master          : chr "localhost"
[16:12:30.881]  $ port            : int 11499
[16:12:30.881]  $ connectTimeout  : num 120
[16:12:30.881]  $ timeout         : num 2592000
[16:12:30.881]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:12:30.881]  $ homogeneous     : logi TRUE
[16:12:30.881]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:12:30.881]  $ rscript_envs    : NULL
[16:12:30.881]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:30.881]  $ rscript_startup : NULL
[16:12:30.881]  $ rscript_sh      : chr "sh"
[16:12:30.881]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:30.881]  $ methods         : logi TRUE
[16:12:30.881]  $ socketOptions   : chr "no-delay"
[16:12:30.881]  $ useXDR          : logi FALSE
[16:12:30.881]  $ outfile         : chr "/dev/null"
[16:12:30.881]  $ renice          : int NA
[16:12:30.881]  $ rshcmd          : NULL
[16:12:30.881]  $ user            : chr(0) 
[16:12:30.881]  $ revtunnel       : logi FALSE
[16:12:30.881]  $ rshlogfile      : NULL
[16:12:30.881]  $ rshopts         : chr(0) 
[16:12:30.881]  $ rank            : int 1
[16:12:30.881]  $ manual          : logi FALSE
[16:12:30.881]  $ dryrun          : logi FALSE
[16:12:30.881]  $ quiet           : logi FALSE
[16:12:30.881]  $ setup_strategy  : chr "parallel"
[16:12:30.881]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:30.881]  $ pidfile         : chr "/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454a2b2c18e9.pid"
[16:12:30.881]  $ rshcmd_label    : NULL
[16:12:30.881]  $ rsh_call        : NULL
[16:12:30.881]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:12:30.881]  $ localMachine    : logi TRUE
[16:12:30.881]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:12:30.881]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:12:30.881]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:12:30.881]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:12:30.881]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:12:30.881]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:12:30.881]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:12:30.881]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:12:30.881]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:12:30.881]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:12:30.881]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:12:30.881]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:12:30.881]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:12:30.881]  $ arguments       :List of 28
[16:12:30.881]   ..$ worker          : chr "localhost"
[16:12:30.881]   ..$ master          : NULL
[16:12:30.881]   ..$ port            : int 11499
[16:12:30.881]   ..$ connectTimeout  : num 120
[16:12:30.881]   ..$ timeout         : num 2592000
[16:12:30.881]   ..$ rscript         : NULL
[16:12:30.881]   ..$ homogeneous     : NULL
[16:12:30.881]   ..$ rscript_args    : NULL
[16:12:30.881]   ..$ rscript_envs    : NULL
[16:12:30.881]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:12:30.881]   ..$ rscript_startup : NULL
[16:12:30.881]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:12:30.881]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:12:30.881]   ..$ methods         : logi TRUE
[16:12:30.881]   ..$ socketOptions   : chr "no-delay"
[16:12:30.881]   ..$ useXDR          : logi FALSE
[16:12:30.881]   ..$ outfile         : chr "/dev/null"
[16:12:30.881]   ..$ renice          : int NA
[16:12:30.881]   ..$ rshcmd          : NULL
[16:12:30.881]   ..$ user            : NULL
[16:12:30.881]   ..$ revtunnel       : logi NA
[16:12:30.881]   ..$ rshlogfile      : NULL
[16:12:30.881]   ..$ rshopts         : NULL
[16:12:30.881]   ..$ rank            : int 1
[16:12:30.881]   ..$ manual          : logi FALSE
[16:12:30.881]   ..$ dryrun          : logi FALSE
[16:12:30.881]   ..$ quiet           : logi FALSE
[16:12:30.881]   ..$ setup_strategy  : chr "parallel"
[16:12:30.881]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:12:30.905] [local output] System call to launch all workers:
[16:12:30.905] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpEHnG6O/worker.rank=1.parallelly.parent=83274.1454a2b2c18e9.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11499 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:12:30.905] [local output] Starting PSOCK main server
[16:12:30.907] [local output] Workers launched
[16:12:30.907] [local output] Waiting for workers to connect back
[16:12:30.907]  - [local output] 0 workers out of 2 ready
[16:12:31.153]  - [local output] 0 workers out of 2 ready
[16:12:31.153]  - [local output] 1 workers out of 2 ready
[16:12:31.173]  - [local output] 1 workers out of 2 ready
[16:12:31.173]  - [local output] 2 workers out of 2 ready
[16:12:31.174] [local output] Launching of workers completed
[16:12:31.174] [local output] Collecting session information from workers
[16:12:31.174] [local output]  - Worker #1 of 2
[16:12:31.175] [local output]  - Worker #2 of 2
[16:12:31.175] [local output] makeClusterPSOCK() ... done
[16:12:31.187] Packages needed by the future expression (n = 0): <none>
[16:12:31.187] Packages needed by future strategies (n = 0): <none>
[16:12:31.188] {
[16:12:31.188]     {
[16:12:31.188]         {
[16:12:31.188]             ...future.startTime <- base::Sys.time()
[16:12:31.188]             {
[16:12:31.188]                 {
[16:12:31.188]                   {
[16:12:31.188]                     {
[16:12:31.188]                       base::local({
[16:12:31.188]                         has_future <- base::requireNamespace("future", 
[16:12:31.188]                           quietly = TRUE)
[16:12:31.188]                         if (has_future) {
[16:12:31.188]                           ns <- base::getNamespace("future")
[16:12:31.188]                           version <- ns[[".package"]][["version"]]
[16:12:31.188]                           if (is.null(version)) 
[16:12:31.188]                             version <- utils::packageVersion("future")
[16:12:31.188]                         }
[16:12:31.188]                         else {
[16:12:31.188]                           version <- NULL
[16:12:31.188]                         }
[16:12:31.188]                         if (!has_future || version < "1.8.0") {
[16:12:31.188]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.188]                             "", base::R.version$version.string), 
[16:12:31.188]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.188]                               "release", "version")], collapse = " "), 
[16:12:31.188]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.188]                             info)
[16:12:31.188]                           info <- base::paste(info, collapse = "; ")
[16:12:31.188]                           if (!has_future) {
[16:12:31.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.188]                               info)
[16:12:31.188]                           }
[16:12:31.188]                           else {
[16:12:31.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.188]                               info, version)
[16:12:31.188]                           }
[16:12:31.188]                           base::stop(msg)
[16:12:31.188]                         }
[16:12:31.188]                       })
[16:12:31.188]                     }
[16:12:31.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.188]                     base::options(mc.cores = 1L)
[16:12:31.188]                   }
[16:12:31.188]                   options(future.plan = NULL)
[16:12:31.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.188]                 }
[16:12:31.188]                 ...future.workdir <- getwd()
[16:12:31.188]             }
[16:12:31.188]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.188]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.188]         }
[16:12:31.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.188]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.188]             base::names(...future.oldOptions))
[16:12:31.188]     }
[16:12:31.188]     if (FALSE) {
[16:12:31.188]     }
[16:12:31.188]     else {
[16:12:31.188]         if (TRUE) {
[16:12:31.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.188]                 open = "w")
[16:12:31.188]         }
[16:12:31.188]         else {
[16:12:31.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.188]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.188]         }
[16:12:31.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.188]             base::sink(type = "output", split = FALSE)
[16:12:31.188]             base::close(...future.stdout)
[16:12:31.188]         }, add = TRUE)
[16:12:31.188]     }
[16:12:31.188]     ...future.frame <- base::sys.nframe()
[16:12:31.188]     ...future.conditions <- base::list()
[16:12:31.188]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.188]     if (FALSE) {
[16:12:31.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.188]     }
[16:12:31.188]     ...future.result <- base::tryCatch({
[16:12:31.188]         base::withCallingHandlers({
[16:12:31.188]             ...future.value <- base::withVisible(base::local({
[16:12:31.188]                 ...future.makeSendCondition <- local({
[16:12:31.188]                   sendCondition <- NULL
[16:12:31.188]                   function(frame = 1L) {
[16:12:31.188]                     if (is.function(sendCondition)) 
[16:12:31.188]                       return(sendCondition)
[16:12:31.188]                     ns <- getNamespace("parallel")
[16:12:31.188]                     if (exists("sendData", mode = "function", 
[16:12:31.188]                       envir = ns)) {
[16:12:31.188]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.188]                         envir = ns)
[16:12:31.188]                       envir <- sys.frame(frame)
[16:12:31.188]                       master <- NULL
[16:12:31.188]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.188]                         !identical(envir, emptyenv())) {
[16:12:31.188]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.188]                           inherits = FALSE)) {
[16:12:31.188]                           master <- get("master", mode = "list", 
[16:12:31.188]                             envir = envir, inherits = FALSE)
[16:12:31.188]                           if (inherits(master, c("SOCKnode", 
[16:12:31.188]                             "SOCK0node"))) {
[16:12:31.188]                             sendCondition <<- function(cond) {
[16:12:31.188]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.188]                                 success = TRUE)
[16:12:31.188]                               parallel_sendData(master, data)
[16:12:31.188]                             }
[16:12:31.188]                             return(sendCondition)
[16:12:31.188]                           }
[16:12:31.188]                         }
[16:12:31.188]                         frame <- frame + 1L
[16:12:31.188]                         envir <- sys.frame(frame)
[16:12:31.188]                       }
[16:12:31.188]                     }
[16:12:31.188]                     sendCondition <<- function(cond) NULL
[16:12:31.188]                   }
[16:12:31.188]                 })
[16:12:31.188]                 withCallingHandlers({
[16:12:31.188]                   NA
[16:12:31.188]                 }, immediateCondition = function(cond) {
[16:12:31.188]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.188]                   sendCondition(cond)
[16:12:31.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.188]                   {
[16:12:31.188]                     inherits <- base::inherits
[16:12:31.188]                     invokeRestart <- base::invokeRestart
[16:12:31.188]                     is.null <- base::is.null
[16:12:31.188]                     muffled <- FALSE
[16:12:31.188]                     if (inherits(cond, "message")) {
[16:12:31.188]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.188]                       if (muffled) 
[16:12:31.188]                         invokeRestart("muffleMessage")
[16:12:31.188]                     }
[16:12:31.188]                     else if (inherits(cond, "warning")) {
[16:12:31.188]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.188]                       if (muffled) 
[16:12:31.188]                         invokeRestart("muffleWarning")
[16:12:31.188]                     }
[16:12:31.188]                     else if (inherits(cond, "condition")) {
[16:12:31.188]                       if (!is.null(pattern)) {
[16:12:31.188]                         computeRestarts <- base::computeRestarts
[16:12:31.188]                         grepl <- base::grepl
[16:12:31.188]                         restarts <- computeRestarts(cond)
[16:12:31.188]                         for (restart in restarts) {
[16:12:31.188]                           name <- restart$name
[16:12:31.188]                           if (is.null(name)) 
[16:12:31.188]                             next
[16:12:31.188]                           if (!grepl(pattern, name)) 
[16:12:31.188]                             next
[16:12:31.188]                           invokeRestart(restart)
[16:12:31.188]                           muffled <- TRUE
[16:12:31.188]                           break
[16:12:31.188]                         }
[16:12:31.188]                       }
[16:12:31.188]                     }
[16:12:31.188]                     invisible(muffled)
[16:12:31.188]                   }
[16:12:31.188]                   muffleCondition(cond)
[16:12:31.188]                 })
[16:12:31.188]             }))
[16:12:31.188]             future::FutureResult(value = ...future.value$value, 
[16:12:31.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.188]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.188]                     ...future.globalenv.names))
[16:12:31.188]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.188]         }, condition = base::local({
[16:12:31.188]             c <- base::c
[16:12:31.188]             inherits <- base::inherits
[16:12:31.188]             invokeRestart <- base::invokeRestart
[16:12:31.188]             length <- base::length
[16:12:31.188]             list <- base::list
[16:12:31.188]             seq.int <- base::seq.int
[16:12:31.188]             signalCondition <- base::signalCondition
[16:12:31.188]             sys.calls <- base::sys.calls
[16:12:31.188]             `[[` <- base::`[[`
[16:12:31.188]             `+` <- base::`+`
[16:12:31.188]             `<<-` <- base::`<<-`
[16:12:31.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.188]                   3L)]
[16:12:31.188]             }
[16:12:31.188]             function(cond) {
[16:12:31.188]                 is_error <- inherits(cond, "error")
[16:12:31.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.188]                   NULL)
[16:12:31.188]                 if (is_error) {
[16:12:31.188]                   sessionInformation <- function() {
[16:12:31.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.188]                       search = base::search(), system = base::Sys.info())
[16:12:31.188]                   }
[16:12:31.188]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.188]                     cond$call), session = sessionInformation(), 
[16:12:31.188]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.188]                   signalCondition(cond)
[16:12:31.188]                 }
[16:12:31.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.188]                 "immediateCondition"))) {
[16:12:31.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.188]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.188]                   if (TRUE && !signal) {
[16:12:31.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.188]                     {
[16:12:31.188]                       inherits <- base::inherits
[16:12:31.188]                       invokeRestart <- base::invokeRestart
[16:12:31.188]                       is.null <- base::is.null
[16:12:31.188]                       muffled <- FALSE
[16:12:31.188]                       if (inherits(cond, "message")) {
[16:12:31.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.188]                         if (muffled) 
[16:12:31.188]                           invokeRestart("muffleMessage")
[16:12:31.188]                       }
[16:12:31.188]                       else if (inherits(cond, "warning")) {
[16:12:31.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.188]                         if (muffled) 
[16:12:31.188]                           invokeRestart("muffleWarning")
[16:12:31.188]                       }
[16:12:31.188]                       else if (inherits(cond, "condition")) {
[16:12:31.188]                         if (!is.null(pattern)) {
[16:12:31.188]                           computeRestarts <- base::computeRestarts
[16:12:31.188]                           grepl <- base::grepl
[16:12:31.188]                           restarts <- computeRestarts(cond)
[16:12:31.188]                           for (restart in restarts) {
[16:12:31.188]                             name <- restart$name
[16:12:31.188]                             if (is.null(name)) 
[16:12:31.188]                               next
[16:12:31.188]                             if (!grepl(pattern, name)) 
[16:12:31.188]                               next
[16:12:31.188]                             invokeRestart(restart)
[16:12:31.188]                             muffled <- TRUE
[16:12:31.188]                             break
[16:12:31.188]                           }
[16:12:31.188]                         }
[16:12:31.188]                       }
[16:12:31.188]                       invisible(muffled)
[16:12:31.188]                     }
[16:12:31.188]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.188]                   }
[16:12:31.188]                 }
[16:12:31.188]                 else {
[16:12:31.188]                   if (TRUE) {
[16:12:31.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.188]                     {
[16:12:31.188]                       inherits <- base::inherits
[16:12:31.188]                       invokeRestart <- base::invokeRestart
[16:12:31.188]                       is.null <- base::is.null
[16:12:31.188]                       muffled <- FALSE
[16:12:31.188]                       if (inherits(cond, "message")) {
[16:12:31.188]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.188]                         if (muffled) 
[16:12:31.188]                           invokeRestart("muffleMessage")
[16:12:31.188]                       }
[16:12:31.188]                       else if (inherits(cond, "warning")) {
[16:12:31.188]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.188]                         if (muffled) 
[16:12:31.188]                           invokeRestart("muffleWarning")
[16:12:31.188]                       }
[16:12:31.188]                       else if (inherits(cond, "condition")) {
[16:12:31.188]                         if (!is.null(pattern)) {
[16:12:31.188]                           computeRestarts <- base::computeRestarts
[16:12:31.188]                           grepl <- base::grepl
[16:12:31.188]                           restarts <- computeRestarts(cond)
[16:12:31.188]                           for (restart in restarts) {
[16:12:31.188]                             name <- restart$name
[16:12:31.188]                             if (is.null(name)) 
[16:12:31.188]                               next
[16:12:31.188]                             if (!grepl(pattern, name)) 
[16:12:31.188]                               next
[16:12:31.188]                             invokeRestart(restart)
[16:12:31.188]                             muffled <- TRUE
[16:12:31.188]                             break
[16:12:31.188]                           }
[16:12:31.188]                         }
[16:12:31.188]                       }
[16:12:31.188]                       invisible(muffled)
[16:12:31.188]                     }
[16:12:31.188]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.188]                   }
[16:12:31.188]                 }
[16:12:31.188]             }
[16:12:31.188]         }))
[16:12:31.188]     }, error = function(ex) {
[16:12:31.188]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.188]                 ...future.rng), started = ...future.startTime, 
[16:12:31.188]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.188]             version = "1.8"), class = "FutureResult")
[16:12:31.188]     }, finally = {
[16:12:31.188]         if (!identical(...future.workdir, getwd())) 
[16:12:31.188]             setwd(...future.workdir)
[16:12:31.188]         {
[16:12:31.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.188]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.188]             }
[16:12:31.188]             base::options(...future.oldOptions)
[16:12:31.188]             if (.Platform$OS.type == "windows") {
[16:12:31.188]                 old_names <- names(...future.oldEnvVars)
[16:12:31.188]                 envs <- base::Sys.getenv()
[16:12:31.188]                 names <- names(envs)
[16:12:31.188]                 common <- intersect(names, old_names)
[16:12:31.188]                 added <- setdiff(names, old_names)
[16:12:31.188]                 removed <- setdiff(old_names, names)
[16:12:31.188]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.188]                   envs[common]]
[16:12:31.188]                 NAMES <- toupper(changed)
[16:12:31.188]                 args <- list()
[16:12:31.188]                 for (kk in seq_along(NAMES)) {
[16:12:31.188]                   name <- changed[[kk]]
[16:12:31.188]                   NAME <- NAMES[[kk]]
[16:12:31.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.188]                     next
[16:12:31.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.188]                 }
[16:12:31.188]                 NAMES <- toupper(added)
[16:12:31.188]                 for (kk in seq_along(NAMES)) {
[16:12:31.188]                   name <- added[[kk]]
[16:12:31.188]                   NAME <- NAMES[[kk]]
[16:12:31.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.188]                     next
[16:12:31.188]                   args[[name]] <- ""
[16:12:31.188]                 }
[16:12:31.188]                 NAMES <- toupper(removed)
[16:12:31.188]                 for (kk in seq_along(NAMES)) {
[16:12:31.188]                   name <- removed[[kk]]
[16:12:31.188]                   NAME <- NAMES[[kk]]
[16:12:31.188]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.188]                     next
[16:12:31.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.188]                 }
[16:12:31.188]                 if (length(args) > 0) 
[16:12:31.188]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.188]             }
[16:12:31.188]             else {
[16:12:31.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.188]             }
[16:12:31.188]             {
[16:12:31.188]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.188]                   0L) {
[16:12:31.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.188]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.188]                   base::options(opts)
[16:12:31.188]                 }
[16:12:31.188]                 {
[16:12:31.188]                   {
[16:12:31.188]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.188]                     NULL
[16:12:31.188]                   }
[16:12:31.188]                   options(future.plan = NULL)
[16:12:31.188]                   if (is.na(NA_character_)) 
[16:12:31.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.188]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.188]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.188]                     envir = parent.frame()) 
[16:12:31.188]                   {
[16:12:31.188]                     if (is.function(workers)) 
[16:12:31.188]                       workers <- workers()
[16:12:31.188]                     workers <- structure(as.integer(workers), 
[16:12:31.188]                       class = class(workers))
[16:12:31.188]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.188]                       workers >= 1)
[16:12:31.188]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.188]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.188]                     }
[16:12:31.188]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.188]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.188]                       envir = envir)
[16:12:31.188]                     if (!future$lazy) 
[16:12:31.188]                       future <- run(future)
[16:12:31.188]                     invisible(future)
[16:12:31.188]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.188]                 }
[16:12:31.188]             }
[16:12:31.188]         }
[16:12:31.188]     })
[16:12:31.188]     if (TRUE) {
[16:12:31.188]         base::sink(type = "output", split = FALSE)
[16:12:31.188]         if (TRUE) {
[16:12:31.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.188]         }
[16:12:31.188]         else {
[16:12:31.188]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.188]         }
[16:12:31.188]         base::close(...future.stdout)
[16:12:31.188]         ...future.stdout <- NULL
[16:12:31.188]     }
[16:12:31.188]     ...future.result$conditions <- ...future.conditions
[16:12:31.188]     ...future.result$finished <- base::Sys.time()
[16:12:31.188]     ...future.result
[16:12:31.188] }
[16:12:31.260] MultisessionFuture started
[16:12:31.260] result() for ClusterFuture ...
[16:12:31.260] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.260] - Validating connection of MultisessionFuture
[16:12:31.292] - received message: FutureResult
[16:12:31.292] - Received FutureResult
[16:12:31.293] - Erased future from FutureRegistry
[16:12:31.293] result() for ClusterFuture ...
[16:12:31.293] - result already collected: FutureResult
[16:12:31.293] result() for ClusterFuture ... done
[16:12:31.293] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.293] result() for ClusterFuture ... done
[16:12:31.293] result() for ClusterFuture ...
[16:12:31.293] - result already collected: FutureResult
[16:12:31.293] result() for ClusterFuture ... done
[16:12:31.294] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:12:31.297] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[16:12:31.298] getGlobalsAndPackages() ...
[16:12:31.298] Searching for globals...
[16:12:31.298] 
[16:12:31.298] Searching for globals ... DONE
[16:12:31.298] - globals: [0] <none>
[16:12:31.298] getGlobalsAndPackages() ... DONE
[16:12:31.299] run() for ‘Future’ ...
[16:12:31.299] - state: ‘created’
[16:12:31.299] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.314] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.314]   - Field: ‘node’
[16:12:31.314]   - Field: ‘label’
[16:12:31.314]   - Field: ‘local’
[16:12:31.314]   - Field: ‘owner’
[16:12:31.314]   - Field: ‘envir’
[16:12:31.314]   - Field: ‘workers’
[16:12:31.315]   - Field: ‘packages’
[16:12:31.315]   - Field: ‘gc’
[16:12:31.315]   - Field: ‘conditions’
[16:12:31.315]   - Field: ‘persistent’
[16:12:31.315]   - Field: ‘expr’
[16:12:31.315]   - Field: ‘uuid’
[16:12:31.315]   - Field: ‘seed’
[16:12:31.315]   - Field: ‘version’
[16:12:31.315]   - Field: ‘result’
[16:12:31.315]   - Field: ‘asynchronous’
[16:12:31.316]   - Field: ‘calls’
[16:12:31.316]   - Field: ‘globals’
[16:12:31.316]   - Field: ‘stdout’
[16:12:31.316]   - Field: ‘earlySignal’
[16:12:31.316]   - Field: ‘lazy’
[16:12:31.316]   - Field: ‘state’
[16:12:31.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.316] - Launch lazy future ...
[16:12:31.317] Packages needed by the future expression (n = 0): <none>
[16:12:31.317] Packages needed by future strategies (n = 0): <none>
[16:12:31.317] {
[16:12:31.317]     {
[16:12:31.317]         {
[16:12:31.317]             ...future.startTime <- base::Sys.time()
[16:12:31.317]             {
[16:12:31.317]                 {
[16:12:31.317]                   {
[16:12:31.317]                     {
[16:12:31.317]                       base::local({
[16:12:31.317]                         has_future <- base::requireNamespace("future", 
[16:12:31.317]                           quietly = TRUE)
[16:12:31.317]                         if (has_future) {
[16:12:31.317]                           ns <- base::getNamespace("future")
[16:12:31.317]                           version <- ns[[".package"]][["version"]]
[16:12:31.317]                           if (is.null(version)) 
[16:12:31.317]                             version <- utils::packageVersion("future")
[16:12:31.317]                         }
[16:12:31.317]                         else {
[16:12:31.317]                           version <- NULL
[16:12:31.317]                         }
[16:12:31.317]                         if (!has_future || version < "1.8.0") {
[16:12:31.317]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.317]                             "", base::R.version$version.string), 
[16:12:31.317]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.317]                               "release", "version")], collapse = " "), 
[16:12:31.317]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.317]                             info)
[16:12:31.317]                           info <- base::paste(info, collapse = "; ")
[16:12:31.317]                           if (!has_future) {
[16:12:31.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.317]                               info)
[16:12:31.317]                           }
[16:12:31.317]                           else {
[16:12:31.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.317]                               info, version)
[16:12:31.317]                           }
[16:12:31.317]                           base::stop(msg)
[16:12:31.317]                         }
[16:12:31.317]                       })
[16:12:31.317]                     }
[16:12:31.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.317]                     base::options(mc.cores = 1L)
[16:12:31.317]                   }
[16:12:31.317]                   options(future.plan = NULL)
[16:12:31.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.317]                 }
[16:12:31.317]                 ...future.workdir <- getwd()
[16:12:31.317]             }
[16:12:31.317]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.317]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.317]         }
[16:12:31.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.317]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.317]             base::names(...future.oldOptions))
[16:12:31.317]     }
[16:12:31.317]     if (FALSE) {
[16:12:31.317]     }
[16:12:31.317]     else {
[16:12:31.317]         if (TRUE) {
[16:12:31.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.317]                 open = "w")
[16:12:31.317]         }
[16:12:31.317]         else {
[16:12:31.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.317]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.317]         }
[16:12:31.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.317]             base::sink(type = "output", split = FALSE)
[16:12:31.317]             base::close(...future.stdout)
[16:12:31.317]         }, add = TRUE)
[16:12:31.317]     }
[16:12:31.317]     ...future.frame <- base::sys.nframe()
[16:12:31.317]     ...future.conditions <- base::list()
[16:12:31.317]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.317]     if (FALSE) {
[16:12:31.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.317]     }
[16:12:31.317]     ...future.result <- base::tryCatch({
[16:12:31.317]         base::withCallingHandlers({
[16:12:31.317]             ...future.value <- base::withVisible(base::local({
[16:12:31.317]                 ...future.makeSendCondition <- local({
[16:12:31.317]                   sendCondition <- NULL
[16:12:31.317]                   function(frame = 1L) {
[16:12:31.317]                     if (is.function(sendCondition)) 
[16:12:31.317]                       return(sendCondition)
[16:12:31.317]                     ns <- getNamespace("parallel")
[16:12:31.317]                     if (exists("sendData", mode = "function", 
[16:12:31.317]                       envir = ns)) {
[16:12:31.317]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.317]                         envir = ns)
[16:12:31.317]                       envir <- sys.frame(frame)
[16:12:31.317]                       master <- NULL
[16:12:31.317]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.317]                         !identical(envir, emptyenv())) {
[16:12:31.317]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.317]                           inherits = FALSE)) {
[16:12:31.317]                           master <- get("master", mode = "list", 
[16:12:31.317]                             envir = envir, inherits = FALSE)
[16:12:31.317]                           if (inherits(master, c("SOCKnode", 
[16:12:31.317]                             "SOCK0node"))) {
[16:12:31.317]                             sendCondition <<- function(cond) {
[16:12:31.317]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.317]                                 success = TRUE)
[16:12:31.317]                               parallel_sendData(master, data)
[16:12:31.317]                             }
[16:12:31.317]                             return(sendCondition)
[16:12:31.317]                           }
[16:12:31.317]                         }
[16:12:31.317]                         frame <- frame + 1L
[16:12:31.317]                         envir <- sys.frame(frame)
[16:12:31.317]                       }
[16:12:31.317]                     }
[16:12:31.317]                     sendCondition <<- function(cond) NULL
[16:12:31.317]                   }
[16:12:31.317]                 })
[16:12:31.317]                 withCallingHandlers({
[16:12:31.317]                   2
[16:12:31.317]                 }, immediateCondition = function(cond) {
[16:12:31.317]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.317]                   sendCondition(cond)
[16:12:31.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.317]                   {
[16:12:31.317]                     inherits <- base::inherits
[16:12:31.317]                     invokeRestart <- base::invokeRestart
[16:12:31.317]                     is.null <- base::is.null
[16:12:31.317]                     muffled <- FALSE
[16:12:31.317]                     if (inherits(cond, "message")) {
[16:12:31.317]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.317]                       if (muffled) 
[16:12:31.317]                         invokeRestart("muffleMessage")
[16:12:31.317]                     }
[16:12:31.317]                     else if (inherits(cond, "warning")) {
[16:12:31.317]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.317]                       if (muffled) 
[16:12:31.317]                         invokeRestart("muffleWarning")
[16:12:31.317]                     }
[16:12:31.317]                     else if (inherits(cond, "condition")) {
[16:12:31.317]                       if (!is.null(pattern)) {
[16:12:31.317]                         computeRestarts <- base::computeRestarts
[16:12:31.317]                         grepl <- base::grepl
[16:12:31.317]                         restarts <- computeRestarts(cond)
[16:12:31.317]                         for (restart in restarts) {
[16:12:31.317]                           name <- restart$name
[16:12:31.317]                           if (is.null(name)) 
[16:12:31.317]                             next
[16:12:31.317]                           if (!grepl(pattern, name)) 
[16:12:31.317]                             next
[16:12:31.317]                           invokeRestart(restart)
[16:12:31.317]                           muffled <- TRUE
[16:12:31.317]                           break
[16:12:31.317]                         }
[16:12:31.317]                       }
[16:12:31.317]                     }
[16:12:31.317]                     invisible(muffled)
[16:12:31.317]                   }
[16:12:31.317]                   muffleCondition(cond)
[16:12:31.317]                 })
[16:12:31.317]             }))
[16:12:31.317]             future::FutureResult(value = ...future.value$value, 
[16:12:31.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.317]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.317]                     ...future.globalenv.names))
[16:12:31.317]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.317]         }, condition = base::local({
[16:12:31.317]             c <- base::c
[16:12:31.317]             inherits <- base::inherits
[16:12:31.317]             invokeRestart <- base::invokeRestart
[16:12:31.317]             length <- base::length
[16:12:31.317]             list <- base::list
[16:12:31.317]             seq.int <- base::seq.int
[16:12:31.317]             signalCondition <- base::signalCondition
[16:12:31.317]             sys.calls <- base::sys.calls
[16:12:31.317]             `[[` <- base::`[[`
[16:12:31.317]             `+` <- base::`+`
[16:12:31.317]             `<<-` <- base::`<<-`
[16:12:31.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.317]                   3L)]
[16:12:31.317]             }
[16:12:31.317]             function(cond) {
[16:12:31.317]                 is_error <- inherits(cond, "error")
[16:12:31.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.317]                   NULL)
[16:12:31.317]                 if (is_error) {
[16:12:31.317]                   sessionInformation <- function() {
[16:12:31.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.317]                       search = base::search(), system = base::Sys.info())
[16:12:31.317]                   }
[16:12:31.317]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.317]                     cond$call), session = sessionInformation(), 
[16:12:31.317]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.317]                   signalCondition(cond)
[16:12:31.317]                 }
[16:12:31.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.317]                 "immediateCondition"))) {
[16:12:31.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.317]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.317]                   if (TRUE && !signal) {
[16:12:31.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.317]                     {
[16:12:31.317]                       inherits <- base::inherits
[16:12:31.317]                       invokeRestart <- base::invokeRestart
[16:12:31.317]                       is.null <- base::is.null
[16:12:31.317]                       muffled <- FALSE
[16:12:31.317]                       if (inherits(cond, "message")) {
[16:12:31.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.317]                         if (muffled) 
[16:12:31.317]                           invokeRestart("muffleMessage")
[16:12:31.317]                       }
[16:12:31.317]                       else if (inherits(cond, "warning")) {
[16:12:31.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.317]                         if (muffled) 
[16:12:31.317]                           invokeRestart("muffleWarning")
[16:12:31.317]                       }
[16:12:31.317]                       else if (inherits(cond, "condition")) {
[16:12:31.317]                         if (!is.null(pattern)) {
[16:12:31.317]                           computeRestarts <- base::computeRestarts
[16:12:31.317]                           grepl <- base::grepl
[16:12:31.317]                           restarts <- computeRestarts(cond)
[16:12:31.317]                           for (restart in restarts) {
[16:12:31.317]                             name <- restart$name
[16:12:31.317]                             if (is.null(name)) 
[16:12:31.317]                               next
[16:12:31.317]                             if (!grepl(pattern, name)) 
[16:12:31.317]                               next
[16:12:31.317]                             invokeRestart(restart)
[16:12:31.317]                             muffled <- TRUE
[16:12:31.317]                             break
[16:12:31.317]                           }
[16:12:31.317]                         }
[16:12:31.317]                       }
[16:12:31.317]                       invisible(muffled)
[16:12:31.317]                     }
[16:12:31.317]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.317]                   }
[16:12:31.317]                 }
[16:12:31.317]                 else {
[16:12:31.317]                   if (TRUE) {
[16:12:31.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.317]                     {
[16:12:31.317]                       inherits <- base::inherits
[16:12:31.317]                       invokeRestart <- base::invokeRestart
[16:12:31.317]                       is.null <- base::is.null
[16:12:31.317]                       muffled <- FALSE
[16:12:31.317]                       if (inherits(cond, "message")) {
[16:12:31.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.317]                         if (muffled) 
[16:12:31.317]                           invokeRestart("muffleMessage")
[16:12:31.317]                       }
[16:12:31.317]                       else if (inherits(cond, "warning")) {
[16:12:31.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.317]                         if (muffled) 
[16:12:31.317]                           invokeRestart("muffleWarning")
[16:12:31.317]                       }
[16:12:31.317]                       else if (inherits(cond, "condition")) {
[16:12:31.317]                         if (!is.null(pattern)) {
[16:12:31.317]                           computeRestarts <- base::computeRestarts
[16:12:31.317]                           grepl <- base::grepl
[16:12:31.317]                           restarts <- computeRestarts(cond)
[16:12:31.317]                           for (restart in restarts) {
[16:12:31.317]                             name <- restart$name
[16:12:31.317]                             if (is.null(name)) 
[16:12:31.317]                               next
[16:12:31.317]                             if (!grepl(pattern, name)) 
[16:12:31.317]                               next
[16:12:31.317]                             invokeRestart(restart)
[16:12:31.317]                             muffled <- TRUE
[16:12:31.317]                             break
[16:12:31.317]                           }
[16:12:31.317]                         }
[16:12:31.317]                       }
[16:12:31.317]                       invisible(muffled)
[16:12:31.317]                     }
[16:12:31.317]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.317]                   }
[16:12:31.317]                 }
[16:12:31.317]             }
[16:12:31.317]         }))
[16:12:31.317]     }, error = function(ex) {
[16:12:31.317]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.317]                 ...future.rng), started = ...future.startTime, 
[16:12:31.317]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.317]             version = "1.8"), class = "FutureResult")
[16:12:31.317]     }, finally = {
[16:12:31.317]         if (!identical(...future.workdir, getwd())) 
[16:12:31.317]             setwd(...future.workdir)
[16:12:31.317]         {
[16:12:31.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.317]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.317]             }
[16:12:31.317]             base::options(...future.oldOptions)
[16:12:31.317]             if (.Platform$OS.type == "windows") {
[16:12:31.317]                 old_names <- names(...future.oldEnvVars)
[16:12:31.317]                 envs <- base::Sys.getenv()
[16:12:31.317]                 names <- names(envs)
[16:12:31.317]                 common <- intersect(names, old_names)
[16:12:31.317]                 added <- setdiff(names, old_names)
[16:12:31.317]                 removed <- setdiff(old_names, names)
[16:12:31.317]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.317]                   envs[common]]
[16:12:31.317]                 NAMES <- toupper(changed)
[16:12:31.317]                 args <- list()
[16:12:31.317]                 for (kk in seq_along(NAMES)) {
[16:12:31.317]                   name <- changed[[kk]]
[16:12:31.317]                   NAME <- NAMES[[kk]]
[16:12:31.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.317]                     next
[16:12:31.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.317]                 }
[16:12:31.317]                 NAMES <- toupper(added)
[16:12:31.317]                 for (kk in seq_along(NAMES)) {
[16:12:31.317]                   name <- added[[kk]]
[16:12:31.317]                   NAME <- NAMES[[kk]]
[16:12:31.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.317]                     next
[16:12:31.317]                   args[[name]] <- ""
[16:12:31.317]                 }
[16:12:31.317]                 NAMES <- toupper(removed)
[16:12:31.317]                 for (kk in seq_along(NAMES)) {
[16:12:31.317]                   name <- removed[[kk]]
[16:12:31.317]                   NAME <- NAMES[[kk]]
[16:12:31.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.317]                     next
[16:12:31.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.317]                 }
[16:12:31.317]                 if (length(args) > 0) 
[16:12:31.317]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.317]             }
[16:12:31.317]             else {
[16:12:31.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.317]             }
[16:12:31.317]             {
[16:12:31.317]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.317]                   0L) {
[16:12:31.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.317]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.317]                   base::options(opts)
[16:12:31.317]                 }
[16:12:31.317]                 {
[16:12:31.317]                   {
[16:12:31.317]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.317]                     NULL
[16:12:31.317]                   }
[16:12:31.317]                   options(future.plan = NULL)
[16:12:31.317]                   if (is.na(NA_character_)) 
[16:12:31.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.317]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.317]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.317]                     envir = parent.frame()) 
[16:12:31.317]                   {
[16:12:31.317]                     if (is.function(workers)) 
[16:12:31.317]                       workers <- workers()
[16:12:31.317]                     workers <- structure(as.integer(workers), 
[16:12:31.317]                       class = class(workers))
[16:12:31.317]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.317]                       workers >= 1)
[16:12:31.317]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.317]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.317]                     }
[16:12:31.317]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.317]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.317]                       envir = envir)
[16:12:31.317]                     if (!future$lazy) 
[16:12:31.317]                       future <- run(future)
[16:12:31.317]                     invisible(future)
[16:12:31.317]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.317]                 }
[16:12:31.317]             }
[16:12:31.317]         }
[16:12:31.317]     })
[16:12:31.317]     if (TRUE) {
[16:12:31.317]         base::sink(type = "output", split = FALSE)
[16:12:31.317]         if (TRUE) {
[16:12:31.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.317]         }
[16:12:31.317]         else {
[16:12:31.317]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.317]         }
[16:12:31.317]         base::close(...future.stdout)
[16:12:31.317]         ...future.stdout <- NULL
[16:12:31.317]     }
[16:12:31.317]     ...future.result$conditions <- ...future.conditions
[16:12:31.317]     ...future.result$finished <- base::Sys.time()
[16:12:31.317]     ...future.result
[16:12:31.317] }
[16:12:31.321] MultisessionFuture started
[16:12:31.321] - Launch lazy future ... done
[16:12:31.321] run() for ‘MultisessionFuture’ ... done
[16:12:31.321] getGlobalsAndPackages() ...
[16:12:31.321] Searching for globals...
[16:12:31.322] 
[16:12:31.322] Searching for globals ... DONE
[16:12:31.322] - globals: [0] <none>
[16:12:31.322] getGlobalsAndPackages() ... DONE
[16:12:31.322] run() for ‘Future’ ...
[16:12:31.322] - state: ‘created’
[16:12:31.322] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.337] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.337] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.337]   - Field: ‘node’
[16:12:31.337]   - Field: ‘label’
[16:12:31.337]   - Field: ‘local’
[16:12:31.337]   - Field: ‘owner’
[16:12:31.337]   - Field: ‘envir’
[16:12:31.337]   - Field: ‘workers’
[16:12:31.338]   - Field: ‘packages’
[16:12:31.338]   - Field: ‘gc’
[16:12:31.338]   - Field: ‘conditions’
[16:12:31.338]   - Field: ‘persistent’
[16:12:31.338]   - Field: ‘expr’
[16:12:31.338]   - Field: ‘uuid’
[16:12:31.338]   - Field: ‘seed’
[16:12:31.338]   - Field: ‘version’
[16:12:31.338]   - Field: ‘result’
[16:12:31.338]   - Field: ‘asynchronous’
[16:12:31.339]   - Field: ‘calls’
[16:12:31.339]   - Field: ‘globals’
[16:12:31.339]   - Field: ‘stdout’
[16:12:31.339]   - Field: ‘earlySignal’
[16:12:31.339]   - Field: ‘lazy’
[16:12:31.339]   - Field: ‘state’
[16:12:31.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.339] - Launch lazy future ...
[16:12:31.339] Packages needed by the future expression (n = 0): <none>
[16:12:31.340] Packages needed by future strategies (n = 0): <none>
[16:12:31.340] {
[16:12:31.340]     {
[16:12:31.340]         {
[16:12:31.340]             ...future.startTime <- base::Sys.time()
[16:12:31.340]             {
[16:12:31.340]                 {
[16:12:31.340]                   {
[16:12:31.340]                     {
[16:12:31.340]                       base::local({
[16:12:31.340]                         has_future <- base::requireNamespace("future", 
[16:12:31.340]                           quietly = TRUE)
[16:12:31.340]                         if (has_future) {
[16:12:31.340]                           ns <- base::getNamespace("future")
[16:12:31.340]                           version <- ns[[".package"]][["version"]]
[16:12:31.340]                           if (is.null(version)) 
[16:12:31.340]                             version <- utils::packageVersion("future")
[16:12:31.340]                         }
[16:12:31.340]                         else {
[16:12:31.340]                           version <- NULL
[16:12:31.340]                         }
[16:12:31.340]                         if (!has_future || version < "1.8.0") {
[16:12:31.340]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.340]                             "", base::R.version$version.string), 
[16:12:31.340]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.340]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.340]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.340]                               "release", "version")], collapse = " "), 
[16:12:31.340]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.340]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.340]                             info)
[16:12:31.340]                           info <- base::paste(info, collapse = "; ")
[16:12:31.340]                           if (!has_future) {
[16:12:31.340]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.340]                               info)
[16:12:31.340]                           }
[16:12:31.340]                           else {
[16:12:31.340]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.340]                               info, version)
[16:12:31.340]                           }
[16:12:31.340]                           base::stop(msg)
[16:12:31.340]                         }
[16:12:31.340]                       })
[16:12:31.340]                     }
[16:12:31.340]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.340]                     base::options(mc.cores = 1L)
[16:12:31.340]                   }
[16:12:31.340]                   options(future.plan = NULL)
[16:12:31.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.340]                 }
[16:12:31.340]                 ...future.workdir <- getwd()
[16:12:31.340]             }
[16:12:31.340]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.340]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.340]         }
[16:12:31.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.340]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.340]             base::names(...future.oldOptions))
[16:12:31.340]     }
[16:12:31.340]     if (FALSE) {
[16:12:31.340]     }
[16:12:31.340]     else {
[16:12:31.340]         if (TRUE) {
[16:12:31.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.340]                 open = "w")
[16:12:31.340]         }
[16:12:31.340]         else {
[16:12:31.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.340]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.340]         }
[16:12:31.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.340]             base::sink(type = "output", split = FALSE)
[16:12:31.340]             base::close(...future.stdout)
[16:12:31.340]         }, add = TRUE)
[16:12:31.340]     }
[16:12:31.340]     ...future.frame <- base::sys.nframe()
[16:12:31.340]     ...future.conditions <- base::list()
[16:12:31.340]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.340]     if (FALSE) {
[16:12:31.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.340]     }
[16:12:31.340]     ...future.result <- base::tryCatch({
[16:12:31.340]         base::withCallingHandlers({
[16:12:31.340]             ...future.value <- base::withVisible(base::local({
[16:12:31.340]                 ...future.makeSendCondition <- local({
[16:12:31.340]                   sendCondition <- NULL
[16:12:31.340]                   function(frame = 1L) {
[16:12:31.340]                     if (is.function(sendCondition)) 
[16:12:31.340]                       return(sendCondition)
[16:12:31.340]                     ns <- getNamespace("parallel")
[16:12:31.340]                     if (exists("sendData", mode = "function", 
[16:12:31.340]                       envir = ns)) {
[16:12:31.340]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.340]                         envir = ns)
[16:12:31.340]                       envir <- sys.frame(frame)
[16:12:31.340]                       master <- NULL
[16:12:31.340]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.340]                         !identical(envir, emptyenv())) {
[16:12:31.340]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.340]                           inherits = FALSE)) {
[16:12:31.340]                           master <- get("master", mode = "list", 
[16:12:31.340]                             envir = envir, inherits = FALSE)
[16:12:31.340]                           if (inherits(master, c("SOCKnode", 
[16:12:31.340]                             "SOCK0node"))) {
[16:12:31.340]                             sendCondition <<- function(cond) {
[16:12:31.340]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.340]                                 success = TRUE)
[16:12:31.340]                               parallel_sendData(master, data)
[16:12:31.340]                             }
[16:12:31.340]                             return(sendCondition)
[16:12:31.340]                           }
[16:12:31.340]                         }
[16:12:31.340]                         frame <- frame + 1L
[16:12:31.340]                         envir <- sys.frame(frame)
[16:12:31.340]                       }
[16:12:31.340]                     }
[16:12:31.340]                     sendCondition <<- function(cond) NULL
[16:12:31.340]                   }
[16:12:31.340]                 })
[16:12:31.340]                 withCallingHandlers({
[16:12:31.340]                   NULL
[16:12:31.340]                 }, immediateCondition = function(cond) {
[16:12:31.340]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.340]                   sendCondition(cond)
[16:12:31.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.340]                   {
[16:12:31.340]                     inherits <- base::inherits
[16:12:31.340]                     invokeRestart <- base::invokeRestart
[16:12:31.340]                     is.null <- base::is.null
[16:12:31.340]                     muffled <- FALSE
[16:12:31.340]                     if (inherits(cond, "message")) {
[16:12:31.340]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.340]                       if (muffled) 
[16:12:31.340]                         invokeRestart("muffleMessage")
[16:12:31.340]                     }
[16:12:31.340]                     else if (inherits(cond, "warning")) {
[16:12:31.340]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.340]                       if (muffled) 
[16:12:31.340]                         invokeRestart("muffleWarning")
[16:12:31.340]                     }
[16:12:31.340]                     else if (inherits(cond, "condition")) {
[16:12:31.340]                       if (!is.null(pattern)) {
[16:12:31.340]                         computeRestarts <- base::computeRestarts
[16:12:31.340]                         grepl <- base::grepl
[16:12:31.340]                         restarts <- computeRestarts(cond)
[16:12:31.340]                         for (restart in restarts) {
[16:12:31.340]                           name <- restart$name
[16:12:31.340]                           if (is.null(name)) 
[16:12:31.340]                             next
[16:12:31.340]                           if (!grepl(pattern, name)) 
[16:12:31.340]                             next
[16:12:31.340]                           invokeRestart(restart)
[16:12:31.340]                           muffled <- TRUE
[16:12:31.340]                           break
[16:12:31.340]                         }
[16:12:31.340]                       }
[16:12:31.340]                     }
[16:12:31.340]                     invisible(muffled)
[16:12:31.340]                   }
[16:12:31.340]                   muffleCondition(cond)
[16:12:31.340]                 })
[16:12:31.340]             }))
[16:12:31.340]             future::FutureResult(value = ...future.value$value, 
[16:12:31.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.340]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.340]                     ...future.globalenv.names))
[16:12:31.340]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.340]         }, condition = base::local({
[16:12:31.340]             c <- base::c
[16:12:31.340]             inherits <- base::inherits
[16:12:31.340]             invokeRestart <- base::invokeRestart
[16:12:31.340]             length <- base::length
[16:12:31.340]             list <- base::list
[16:12:31.340]             seq.int <- base::seq.int
[16:12:31.340]             signalCondition <- base::signalCondition
[16:12:31.340]             sys.calls <- base::sys.calls
[16:12:31.340]             `[[` <- base::`[[`
[16:12:31.340]             `+` <- base::`+`
[16:12:31.340]             `<<-` <- base::`<<-`
[16:12:31.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.340]                   3L)]
[16:12:31.340]             }
[16:12:31.340]             function(cond) {
[16:12:31.340]                 is_error <- inherits(cond, "error")
[16:12:31.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.340]                   NULL)
[16:12:31.340]                 if (is_error) {
[16:12:31.340]                   sessionInformation <- function() {
[16:12:31.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.340]                       search = base::search(), system = base::Sys.info())
[16:12:31.340]                   }
[16:12:31.340]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.340]                     cond$call), session = sessionInformation(), 
[16:12:31.340]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.340]                   signalCondition(cond)
[16:12:31.340]                 }
[16:12:31.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.340]                 "immediateCondition"))) {
[16:12:31.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.340]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.340]                   if (TRUE && !signal) {
[16:12:31.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.340]                     {
[16:12:31.340]                       inherits <- base::inherits
[16:12:31.340]                       invokeRestart <- base::invokeRestart
[16:12:31.340]                       is.null <- base::is.null
[16:12:31.340]                       muffled <- FALSE
[16:12:31.340]                       if (inherits(cond, "message")) {
[16:12:31.340]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.340]                         if (muffled) 
[16:12:31.340]                           invokeRestart("muffleMessage")
[16:12:31.340]                       }
[16:12:31.340]                       else if (inherits(cond, "warning")) {
[16:12:31.340]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.340]                         if (muffled) 
[16:12:31.340]                           invokeRestart("muffleWarning")
[16:12:31.340]                       }
[16:12:31.340]                       else if (inherits(cond, "condition")) {
[16:12:31.340]                         if (!is.null(pattern)) {
[16:12:31.340]                           computeRestarts <- base::computeRestarts
[16:12:31.340]                           grepl <- base::grepl
[16:12:31.340]                           restarts <- computeRestarts(cond)
[16:12:31.340]                           for (restart in restarts) {
[16:12:31.340]                             name <- restart$name
[16:12:31.340]                             if (is.null(name)) 
[16:12:31.340]                               next
[16:12:31.340]                             if (!grepl(pattern, name)) 
[16:12:31.340]                               next
[16:12:31.340]                             invokeRestart(restart)
[16:12:31.340]                             muffled <- TRUE
[16:12:31.340]                             break
[16:12:31.340]                           }
[16:12:31.340]                         }
[16:12:31.340]                       }
[16:12:31.340]                       invisible(muffled)
[16:12:31.340]                     }
[16:12:31.340]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.340]                   }
[16:12:31.340]                 }
[16:12:31.340]                 else {
[16:12:31.340]                   if (TRUE) {
[16:12:31.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.340]                     {
[16:12:31.340]                       inherits <- base::inherits
[16:12:31.340]                       invokeRestart <- base::invokeRestart
[16:12:31.340]                       is.null <- base::is.null
[16:12:31.340]                       muffled <- FALSE
[16:12:31.340]                       if (inherits(cond, "message")) {
[16:12:31.340]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.340]                         if (muffled) 
[16:12:31.340]                           invokeRestart("muffleMessage")
[16:12:31.340]                       }
[16:12:31.340]                       else if (inherits(cond, "warning")) {
[16:12:31.340]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.340]                         if (muffled) 
[16:12:31.340]                           invokeRestart("muffleWarning")
[16:12:31.340]                       }
[16:12:31.340]                       else if (inherits(cond, "condition")) {
[16:12:31.340]                         if (!is.null(pattern)) {
[16:12:31.340]                           computeRestarts <- base::computeRestarts
[16:12:31.340]                           grepl <- base::grepl
[16:12:31.340]                           restarts <- computeRestarts(cond)
[16:12:31.340]                           for (restart in restarts) {
[16:12:31.340]                             name <- restart$name
[16:12:31.340]                             if (is.null(name)) 
[16:12:31.340]                               next
[16:12:31.340]                             if (!grepl(pattern, name)) 
[16:12:31.340]                               next
[16:12:31.340]                             invokeRestart(restart)
[16:12:31.340]                             muffled <- TRUE
[16:12:31.340]                             break
[16:12:31.340]                           }
[16:12:31.340]                         }
[16:12:31.340]                       }
[16:12:31.340]                       invisible(muffled)
[16:12:31.340]                     }
[16:12:31.340]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.340]                   }
[16:12:31.340]                 }
[16:12:31.340]             }
[16:12:31.340]         }))
[16:12:31.340]     }, error = function(ex) {
[16:12:31.340]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.340]                 ...future.rng), started = ...future.startTime, 
[16:12:31.340]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.340]             version = "1.8"), class = "FutureResult")
[16:12:31.340]     }, finally = {
[16:12:31.340]         if (!identical(...future.workdir, getwd())) 
[16:12:31.340]             setwd(...future.workdir)
[16:12:31.340]         {
[16:12:31.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.340]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.340]             }
[16:12:31.340]             base::options(...future.oldOptions)
[16:12:31.340]             if (.Platform$OS.type == "windows") {
[16:12:31.340]                 old_names <- names(...future.oldEnvVars)
[16:12:31.340]                 envs <- base::Sys.getenv()
[16:12:31.340]                 names <- names(envs)
[16:12:31.340]                 common <- intersect(names, old_names)
[16:12:31.340]                 added <- setdiff(names, old_names)
[16:12:31.340]                 removed <- setdiff(old_names, names)
[16:12:31.340]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.340]                   envs[common]]
[16:12:31.340]                 NAMES <- toupper(changed)
[16:12:31.340]                 args <- list()
[16:12:31.340]                 for (kk in seq_along(NAMES)) {
[16:12:31.340]                   name <- changed[[kk]]
[16:12:31.340]                   NAME <- NAMES[[kk]]
[16:12:31.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.340]                     next
[16:12:31.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.340]                 }
[16:12:31.340]                 NAMES <- toupper(added)
[16:12:31.340]                 for (kk in seq_along(NAMES)) {
[16:12:31.340]                   name <- added[[kk]]
[16:12:31.340]                   NAME <- NAMES[[kk]]
[16:12:31.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.340]                     next
[16:12:31.340]                   args[[name]] <- ""
[16:12:31.340]                 }
[16:12:31.340]                 NAMES <- toupper(removed)
[16:12:31.340]                 for (kk in seq_along(NAMES)) {
[16:12:31.340]                   name <- removed[[kk]]
[16:12:31.340]                   NAME <- NAMES[[kk]]
[16:12:31.340]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.340]                     next
[16:12:31.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.340]                 }
[16:12:31.340]                 if (length(args) > 0) 
[16:12:31.340]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.340]             }
[16:12:31.340]             else {
[16:12:31.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.340]             }
[16:12:31.340]             {
[16:12:31.340]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.340]                   0L) {
[16:12:31.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.340]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.340]                   base::options(opts)
[16:12:31.340]                 }
[16:12:31.340]                 {
[16:12:31.340]                   {
[16:12:31.340]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.340]                     NULL
[16:12:31.340]                   }
[16:12:31.340]                   options(future.plan = NULL)
[16:12:31.340]                   if (is.na(NA_character_)) 
[16:12:31.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.340]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.340]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.340]                     envir = parent.frame()) 
[16:12:31.340]                   {
[16:12:31.340]                     if (is.function(workers)) 
[16:12:31.340]                       workers <- workers()
[16:12:31.340]                     workers <- structure(as.integer(workers), 
[16:12:31.340]                       class = class(workers))
[16:12:31.340]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.340]                       workers >= 1)
[16:12:31.340]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.340]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.340]                     }
[16:12:31.340]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.340]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.340]                       envir = envir)
[16:12:31.340]                     if (!future$lazy) 
[16:12:31.340]                       future <- run(future)
[16:12:31.340]                     invisible(future)
[16:12:31.340]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.340]                 }
[16:12:31.340]             }
[16:12:31.340]         }
[16:12:31.340]     })
[16:12:31.340]     if (TRUE) {
[16:12:31.340]         base::sink(type = "output", split = FALSE)
[16:12:31.340]         if (TRUE) {
[16:12:31.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.340]         }
[16:12:31.340]         else {
[16:12:31.340]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.340]         }
[16:12:31.340]         base::close(...future.stdout)
[16:12:31.340]         ...future.stdout <- NULL
[16:12:31.340]     }
[16:12:31.340]     ...future.result$conditions <- ...future.conditions
[16:12:31.340]     ...future.result$finished <- base::Sys.time()
[16:12:31.340]     ...future.result
[16:12:31.340] }
[16:12:31.412] MultisessionFuture started
[16:12:31.412] - Launch lazy future ... done
[16:12:31.412] run() for ‘MultisessionFuture’ ... done
[16:12:31.413] getGlobalsAndPackages() ...
[16:12:31.413] Searching for globals...
[16:12:31.414] - globals found: [1] ‘{’
[16:12:31.414] Searching for globals ... DONE
[16:12:31.414] Resolving globals: FALSE
[16:12:31.414] 
[16:12:31.414] 
[16:12:31.414] getGlobalsAndPackages() ... DONE
[16:12:31.415] run() for ‘Future’ ...
[16:12:31.415] - state: ‘created’
[16:12:31.415] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.430] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.430]   - Field: ‘node’
[16:12:31.430]   - Field: ‘label’
[16:12:31.431]   - Field: ‘local’
[16:12:31.431]   - Field: ‘owner’
[16:12:31.431]   - Field: ‘envir’
[16:12:31.431]   - Field: ‘workers’
[16:12:31.431]   - Field: ‘packages’
[16:12:31.431]   - Field: ‘gc’
[16:12:31.431]   - Field: ‘conditions’
[16:12:31.431]   - Field: ‘persistent’
[16:12:31.431]   - Field: ‘expr’
[16:12:31.431]   - Field: ‘uuid’
[16:12:31.432]   - Field: ‘seed’
[16:12:31.432]   - Field: ‘version’
[16:12:31.432]   - Field: ‘result’
[16:12:31.432]   - Field: ‘asynchronous’
[16:12:31.432]   - Field: ‘calls’
[16:12:31.432]   - Field: ‘globals’
[16:12:31.432]   - Field: ‘stdout’
[16:12:31.432]   - Field: ‘earlySignal’
[16:12:31.432]   - Field: ‘lazy’
[16:12:31.432]   - Field: ‘state’
[16:12:31.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.433] - Launch lazy future ...
[16:12:31.433] Packages needed by the future expression (n = 0): <none>
[16:12:31.433] Packages needed by future strategies (n = 0): <none>
[16:12:31.433] {
[16:12:31.433]     {
[16:12:31.433]         {
[16:12:31.433]             ...future.startTime <- base::Sys.time()
[16:12:31.433]             {
[16:12:31.433]                 {
[16:12:31.433]                   {
[16:12:31.433]                     {
[16:12:31.433]                       base::local({
[16:12:31.433]                         has_future <- base::requireNamespace("future", 
[16:12:31.433]                           quietly = TRUE)
[16:12:31.433]                         if (has_future) {
[16:12:31.433]                           ns <- base::getNamespace("future")
[16:12:31.433]                           version <- ns[[".package"]][["version"]]
[16:12:31.433]                           if (is.null(version)) 
[16:12:31.433]                             version <- utils::packageVersion("future")
[16:12:31.433]                         }
[16:12:31.433]                         else {
[16:12:31.433]                           version <- NULL
[16:12:31.433]                         }
[16:12:31.433]                         if (!has_future || version < "1.8.0") {
[16:12:31.433]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.433]                             "", base::R.version$version.string), 
[16:12:31.433]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.433]                               "release", "version")], collapse = " "), 
[16:12:31.433]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.433]                             info)
[16:12:31.433]                           info <- base::paste(info, collapse = "; ")
[16:12:31.433]                           if (!has_future) {
[16:12:31.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.433]                               info)
[16:12:31.433]                           }
[16:12:31.433]                           else {
[16:12:31.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.433]                               info, version)
[16:12:31.433]                           }
[16:12:31.433]                           base::stop(msg)
[16:12:31.433]                         }
[16:12:31.433]                       })
[16:12:31.433]                     }
[16:12:31.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.433]                     base::options(mc.cores = 1L)
[16:12:31.433]                   }
[16:12:31.433]                   options(future.plan = NULL)
[16:12:31.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.433]                 }
[16:12:31.433]                 ...future.workdir <- getwd()
[16:12:31.433]             }
[16:12:31.433]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.433]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.433]         }
[16:12:31.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.433]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.433]             base::names(...future.oldOptions))
[16:12:31.433]     }
[16:12:31.433]     if (FALSE) {
[16:12:31.433]     }
[16:12:31.433]     else {
[16:12:31.433]         if (TRUE) {
[16:12:31.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.433]                 open = "w")
[16:12:31.433]         }
[16:12:31.433]         else {
[16:12:31.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.433]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.433]         }
[16:12:31.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.433]             base::sink(type = "output", split = FALSE)
[16:12:31.433]             base::close(...future.stdout)
[16:12:31.433]         }, add = TRUE)
[16:12:31.433]     }
[16:12:31.433]     ...future.frame <- base::sys.nframe()
[16:12:31.433]     ...future.conditions <- base::list()
[16:12:31.433]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.433]     if (FALSE) {
[16:12:31.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.433]     }
[16:12:31.433]     ...future.result <- base::tryCatch({
[16:12:31.433]         base::withCallingHandlers({
[16:12:31.433]             ...future.value <- base::withVisible(base::local({
[16:12:31.433]                 ...future.makeSendCondition <- local({
[16:12:31.433]                   sendCondition <- NULL
[16:12:31.433]                   function(frame = 1L) {
[16:12:31.433]                     if (is.function(sendCondition)) 
[16:12:31.433]                       return(sendCondition)
[16:12:31.433]                     ns <- getNamespace("parallel")
[16:12:31.433]                     if (exists("sendData", mode = "function", 
[16:12:31.433]                       envir = ns)) {
[16:12:31.433]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.433]                         envir = ns)
[16:12:31.433]                       envir <- sys.frame(frame)
[16:12:31.433]                       master <- NULL
[16:12:31.433]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.433]                         !identical(envir, emptyenv())) {
[16:12:31.433]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.433]                           inherits = FALSE)) {
[16:12:31.433]                           master <- get("master", mode = "list", 
[16:12:31.433]                             envir = envir, inherits = FALSE)
[16:12:31.433]                           if (inherits(master, c("SOCKnode", 
[16:12:31.433]                             "SOCK0node"))) {
[16:12:31.433]                             sendCondition <<- function(cond) {
[16:12:31.433]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.433]                                 success = TRUE)
[16:12:31.433]                               parallel_sendData(master, data)
[16:12:31.433]                             }
[16:12:31.433]                             return(sendCondition)
[16:12:31.433]                           }
[16:12:31.433]                         }
[16:12:31.433]                         frame <- frame + 1L
[16:12:31.433]                         envir <- sys.frame(frame)
[16:12:31.433]                       }
[16:12:31.433]                     }
[16:12:31.433]                     sendCondition <<- function(cond) NULL
[16:12:31.433]                   }
[16:12:31.433]                 })
[16:12:31.433]                 withCallingHandlers({
[16:12:31.433]                   {
[16:12:31.433]                     4
[16:12:31.433]                   }
[16:12:31.433]                 }, immediateCondition = function(cond) {
[16:12:31.433]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.433]                   sendCondition(cond)
[16:12:31.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.433]                   {
[16:12:31.433]                     inherits <- base::inherits
[16:12:31.433]                     invokeRestart <- base::invokeRestart
[16:12:31.433]                     is.null <- base::is.null
[16:12:31.433]                     muffled <- FALSE
[16:12:31.433]                     if (inherits(cond, "message")) {
[16:12:31.433]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.433]                       if (muffled) 
[16:12:31.433]                         invokeRestart("muffleMessage")
[16:12:31.433]                     }
[16:12:31.433]                     else if (inherits(cond, "warning")) {
[16:12:31.433]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.433]                       if (muffled) 
[16:12:31.433]                         invokeRestart("muffleWarning")
[16:12:31.433]                     }
[16:12:31.433]                     else if (inherits(cond, "condition")) {
[16:12:31.433]                       if (!is.null(pattern)) {
[16:12:31.433]                         computeRestarts <- base::computeRestarts
[16:12:31.433]                         grepl <- base::grepl
[16:12:31.433]                         restarts <- computeRestarts(cond)
[16:12:31.433]                         for (restart in restarts) {
[16:12:31.433]                           name <- restart$name
[16:12:31.433]                           if (is.null(name)) 
[16:12:31.433]                             next
[16:12:31.433]                           if (!grepl(pattern, name)) 
[16:12:31.433]                             next
[16:12:31.433]                           invokeRestart(restart)
[16:12:31.433]                           muffled <- TRUE
[16:12:31.433]                           break
[16:12:31.433]                         }
[16:12:31.433]                       }
[16:12:31.433]                     }
[16:12:31.433]                     invisible(muffled)
[16:12:31.433]                   }
[16:12:31.433]                   muffleCondition(cond)
[16:12:31.433]                 })
[16:12:31.433]             }))
[16:12:31.433]             future::FutureResult(value = ...future.value$value, 
[16:12:31.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.433]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.433]                     ...future.globalenv.names))
[16:12:31.433]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.433]         }, condition = base::local({
[16:12:31.433]             c <- base::c
[16:12:31.433]             inherits <- base::inherits
[16:12:31.433]             invokeRestart <- base::invokeRestart
[16:12:31.433]             length <- base::length
[16:12:31.433]             list <- base::list
[16:12:31.433]             seq.int <- base::seq.int
[16:12:31.433]             signalCondition <- base::signalCondition
[16:12:31.433]             sys.calls <- base::sys.calls
[16:12:31.433]             `[[` <- base::`[[`
[16:12:31.433]             `+` <- base::`+`
[16:12:31.433]             `<<-` <- base::`<<-`
[16:12:31.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.433]                   3L)]
[16:12:31.433]             }
[16:12:31.433]             function(cond) {
[16:12:31.433]                 is_error <- inherits(cond, "error")
[16:12:31.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.433]                   NULL)
[16:12:31.433]                 if (is_error) {
[16:12:31.433]                   sessionInformation <- function() {
[16:12:31.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.433]                       search = base::search(), system = base::Sys.info())
[16:12:31.433]                   }
[16:12:31.433]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.433]                     cond$call), session = sessionInformation(), 
[16:12:31.433]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.433]                   signalCondition(cond)
[16:12:31.433]                 }
[16:12:31.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.433]                 "immediateCondition"))) {
[16:12:31.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.433]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.433]                   if (TRUE && !signal) {
[16:12:31.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.433]                     {
[16:12:31.433]                       inherits <- base::inherits
[16:12:31.433]                       invokeRestart <- base::invokeRestart
[16:12:31.433]                       is.null <- base::is.null
[16:12:31.433]                       muffled <- FALSE
[16:12:31.433]                       if (inherits(cond, "message")) {
[16:12:31.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.433]                         if (muffled) 
[16:12:31.433]                           invokeRestart("muffleMessage")
[16:12:31.433]                       }
[16:12:31.433]                       else if (inherits(cond, "warning")) {
[16:12:31.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.433]                         if (muffled) 
[16:12:31.433]                           invokeRestart("muffleWarning")
[16:12:31.433]                       }
[16:12:31.433]                       else if (inherits(cond, "condition")) {
[16:12:31.433]                         if (!is.null(pattern)) {
[16:12:31.433]                           computeRestarts <- base::computeRestarts
[16:12:31.433]                           grepl <- base::grepl
[16:12:31.433]                           restarts <- computeRestarts(cond)
[16:12:31.433]                           for (restart in restarts) {
[16:12:31.433]                             name <- restart$name
[16:12:31.433]                             if (is.null(name)) 
[16:12:31.433]                               next
[16:12:31.433]                             if (!grepl(pattern, name)) 
[16:12:31.433]                               next
[16:12:31.433]                             invokeRestart(restart)
[16:12:31.433]                             muffled <- TRUE
[16:12:31.433]                             break
[16:12:31.433]                           }
[16:12:31.433]                         }
[16:12:31.433]                       }
[16:12:31.433]                       invisible(muffled)
[16:12:31.433]                     }
[16:12:31.433]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.433]                   }
[16:12:31.433]                 }
[16:12:31.433]                 else {
[16:12:31.433]                   if (TRUE) {
[16:12:31.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.433]                     {
[16:12:31.433]                       inherits <- base::inherits
[16:12:31.433]                       invokeRestart <- base::invokeRestart
[16:12:31.433]                       is.null <- base::is.null
[16:12:31.433]                       muffled <- FALSE
[16:12:31.433]                       if (inherits(cond, "message")) {
[16:12:31.433]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.433]                         if (muffled) 
[16:12:31.433]                           invokeRestart("muffleMessage")
[16:12:31.433]                       }
[16:12:31.433]                       else if (inherits(cond, "warning")) {
[16:12:31.433]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.433]                         if (muffled) 
[16:12:31.433]                           invokeRestart("muffleWarning")
[16:12:31.433]                       }
[16:12:31.433]                       else if (inherits(cond, "condition")) {
[16:12:31.433]                         if (!is.null(pattern)) {
[16:12:31.433]                           computeRestarts <- base::computeRestarts
[16:12:31.433]                           grepl <- base::grepl
[16:12:31.433]                           restarts <- computeRestarts(cond)
[16:12:31.433]                           for (restart in restarts) {
[16:12:31.433]                             name <- restart$name
[16:12:31.433]                             if (is.null(name)) 
[16:12:31.433]                               next
[16:12:31.433]                             if (!grepl(pattern, name)) 
[16:12:31.433]                               next
[16:12:31.433]                             invokeRestart(restart)
[16:12:31.433]                             muffled <- TRUE
[16:12:31.433]                             break
[16:12:31.433]                           }
[16:12:31.433]                         }
[16:12:31.433]                       }
[16:12:31.433]                       invisible(muffled)
[16:12:31.433]                     }
[16:12:31.433]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.433]                   }
[16:12:31.433]                 }
[16:12:31.433]             }
[16:12:31.433]         }))
[16:12:31.433]     }, error = function(ex) {
[16:12:31.433]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.433]                 ...future.rng), started = ...future.startTime, 
[16:12:31.433]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.433]             version = "1.8"), class = "FutureResult")
[16:12:31.433]     }, finally = {
[16:12:31.433]         if (!identical(...future.workdir, getwd())) 
[16:12:31.433]             setwd(...future.workdir)
[16:12:31.433]         {
[16:12:31.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.433]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.433]             }
[16:12:31.433]             base::options(...future.oldOptions)
[16:12:31.433]             if (.Platform$OS.type == "windows") {
[16:12:31.433]                 old_names <- names(...future.oldEnvVars)
[16:12:31.433]                 envs <- base::Sys.getenv()
[16:12:31.433]                 names <- names(envs)
[16:12:31.433]                 common <- intersect(names, old_names)
[16:12:31.433]                 added <- setdiff(names, old_names)
[16:12:31.433]                 removed <- setdiff(old_names, names)
[16:12:31.433]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.433]                   envs[common]]
[16:12:31.433]                 NAMES <- toupper(changed)
[16:12:31.433]                 args <- list()
[16:12:31.433]                 for (kk in seq_along(NAMES)) {
[16:12:31.433]                   name <- changed[[kk]]
[16:12:31.433]                   NAME <- NAMES[[kk]]
[16:12:31.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.433]                     next
[16:12:31.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.433]                 }
[16:12:31.433]                 NAMES <- toupper(added)
[16:12:31.433]                 for (kk in seq_along(NAMES)) {
[16:12:31.433]                   name <- added[[kk]]
[16:12:31.433]                   NAME <- NAMES[[kk]]
[16:12:31.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.433]                     next
[16:12:31.433]                   args[[name]] <- ""
[16:12:31.433]                 }
[16:12:31.433]                 NAMES <- toupper(removed)
[16:12:31.433]                 for (kk in seq_along(NAMES)) {
[16:12:31.433]                   name <- removed[[kk]]
[16:12:31.433]                   NAME <- NAMES[[kk]]
[16:12:31.433]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.433]                     next
[16:12:31.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.433]                 }
[16:12:31.433]                 if (length(args) > 0) 
[16:12:31.433]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.433]             }
[16:12:31.433]             else {
[16:12:31.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.433]             }
[16:12:31.433]             {
[16:12:31.433]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.433]                   0L) {
[16:12:31.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.433]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.433]                   base::options(opts)
[16:12:31.433]                 }
[16:12:31.433]                 {
[16:12:31.433]                   {
[16:12:31.433]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.433]                     NULL
[16:12:31.433]                   }
[16:12:31.433]                   options(future.plan = NULL)
[16:12:31.433]                   if (is.na(NA_character_)) 
[16:12:31.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.433]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.433]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.433]                     envir = parent.frame()) 
[16:12:31.433]                   {
[16:12:31.433]                     if (is.function(workers)) 
[16:12:31.433]                       workers <- workers()
[16:12:31.433]                     workers <- structure(as.integer(workers), 
[16:12:31.433]                       class = class(workers))
[16:12:31.433]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.433]                       workers >= 1)
[16:12:31.433]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.433]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.433]                     }
[16:12:31.433]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.433]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.433]                       envir = envir)
[16:12:31.433]                     if (!future$lazy) 
[16:12:31.433]                       future <- run(future)
[16:12:31.433]                     invisible(future)
[16:12:31.433]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.433]                 }
[16:12:31.433]             }
[16:12:31.433]         }
[16:12:31.433]     })
[16:12:31.433]     if (TRUE) {
[16:12:31.433]         base::sink(type = "output", split = FALSE)
[16:12:31.433]         if (TRUE) {
[16:12:31.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.433]         }
[16:12:31.433]         else {
[16:12:31.433]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.433]         }
[16:12:31.433]         base::close(...future.stdout)
[16:12:31.433]         ...future.stdout <- NULL
[16:12:31.433]     }
[16:12:31.433]     ...future.result$conditions <- ...future.conditions
[16:12:31.433]     ...future.result$finished <- base::Sys.time()
[16:12:31.433]     ...future.result
[16:12:31.433] }
[16:12:31.436] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:31.447] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.447] - Validating connection of MultisessionFuture
[16:12:31.447] - received message: FutureResult
[16:12:31.447] - Received FutureResult
[16:12:31.447] - Erased future from FutureRegistry
[16:12:31.447] result() for ClusterFuture ...
[16:12:31.447] - result already collected: FutureResult
[16:12:31.447] result() for ClusterFuture ... done
[16:12:31.448] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.448] result() for ClusterFuture ...
[16:12:31.448] - result already collected: FutureResult
[16:12:31.448] result() for ClusterFuture ... done
[16:12:31.448] result() for ClusterFuture ...
[16:12:31.448] - result already collected: FutureResult
[16:12:31.448] result() for ClusterFuture ... done
[16:12:31.449] MultisessionFuture started
[16:12:31.449] - Launch lazy future ... done
[16:12:31.450] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560baee019b8> 
Classes 'listenv', 'environment' <environment: 0x560bafc7f2d8> 
[16:12:31.452] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.452] - Validating connection of MultisessionFuture
[16:12:31.453] - received message: FutureResult
[16:12:31.453] - Received FutureResult
[16:12:31.453] - Erased future from FutureRegistry
[16:12:31.453] result() for ClusterFuture ...
[16:12:31.453] - result already collected: FutureResult
[16:12:31.453] result() for ClusterFuture ... done
[16:12:31.453] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:31.465] resolve() on list environment ...
[16:12:31.465]  recursive: 0
[16:12:31.466]  length: 6
[16:12:31.466]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:31.466] signalConditionsASAP(numeric, pos=1) ...
[16:12:31.467] - nx: 6
[16:12:31.467] - relay: TRUE
[16:12:31.467] - stdout: TRUE
[16:12:31.467] - signal: TRUE
[16:12:31.467] - resignal: FALSE
[16:12:31.467] - force: TRUE
[16:12:31.467] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.467] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.467]  - until=2
[16:12:31.467]  - relaying element #2
[16:12:31.467] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.467] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.468] signalConditionsASAP(NULL, pos=1) ... done
[16:12:31.468]  length: 5 (resolved future 1)
[16:12:31.468] Future #2
[16:12:31.468] result() for ClusterFuture ...
[16:12:31.468] - result already collected: FutureResult
[16:12:31.468] result() for ClusterFuture ... done
[16:12:31.468] result() for ClusterFuture ...
[16:12:31.468] - result already collected: FutureResult
[16:12:31.468] result() for ClusterFuture ... done
[16:12:31.469] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:31.469] - nx: 6
[16:12:31.469] - relay: TRUE
[16:12:31.469] - stdout: TRUE
[16:12:31.469] - signal: TRUE
[16:12:31.469] - resignal: FALSE
[16:12:31.469] - force: TRUE
[16:12:31.469] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.469] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.469]  - until=2
[16:12:31.469]  - relaying element #2
[16:12:31.470] result() for ClusterFuture ...
[16:12:31.470] - result already collected: FutureResult
[16:12:31.470] result() for ClusterFuture ... done
[16:12:31.470] result() for ClusterFuture ...
[16:12:31.470] - result already collected: FutureResult
[16:12:31.470] result() for ClusterFuture ... done
[16:12:31.470] result() for ClusterFuture ...
[16:12:31.470] - result already collected: FutureResult
[16:12:31.470] result() for ClusterFuture ... done
[16:12:31.470] result() for ClusterFuture ...
[16:12:31.470] - result already collected: FutureResult
[16:12:31.471] result() for ClusterFuture ... done
[16:12:31.471] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.471] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.471] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:31.471]  length: 4 (resolved future 2)
[16:12:31.471] Future #3
[16:12:31.471] result() for ClusterFuture ...
[16:12:31.471] - result already collected: FutureResult
[16:12:31.471] result() for ClusterFuture ... done
[16:12:31.471] result() for ClusterFuture ...
[16:12:31.471] - result already collected: FutureResult
[16:12:31.472] result() for ClusterFuture ... done
[16:12:31.472] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:31.472] - nx: 6
[16:12:31.472] - relay: TRUE
[16:12:31.472] - stdout: TRUE
[16:12:31.472] - signal: TRUE
[16:12:31.472] - resignal: FALSE
[16:12:31.472] - force: TRUE
[16:12:31.472] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.472] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.472]  - until=3
[16:12:31.473]  - relaying element #3
[16:12:31.473] result() for ClusterFuture ...
[16:12:31.473] - result already collected: FutureResult
[16:12:31.473] result() for ClusterFuture ... done
[16:12:31.473] result() for ClusterFuture ...
[16:12:31.473] - result already collected: FutureResult
[16:12:31.473] result() for ClusterFuture ... done
[16:12:31.473] result() for ClusterFuture ...
[16:12:31.473] - result already collected: FutureResult
[16:12:31.473] result() for ClusterFuture ... done
[16:12:31.473] result() for ClusterFuture ...
[16:12:31.474] - result already collected: FutureResult
[16:12:31.474] result() for ClusterFuture ... done
[16:12:31.474] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.474] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.474] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:31.474]  length: 3 (resolved future 3)
[16:12:31.485] signalConditionsASAP(NULL, pos=5) ...
[16:12:31.485] - nx: 6
[16:12:31.485] - relay: TRUE
[16:12:31.485] - stdout: TRUE
[16:12:31.485] - signal: TRUE
[16:12:31.485] - resignal: FALSE
[16:12:31.485] - force: TRUE
[16:12:31.485] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.485]  - until=6
[16:12:31.485]  - relaying element #4
[16:12:31.486]  - relaying element #6
[16:12:31.486] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.486] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.486] signalConditionsASAP(NULL, pos=5) ... done
[16:12:31.486]  length: 2 (resolved future 5)
[16:12:31.486] signalConditionsASAP(numeric, pos=6) ...
[16:12:31.486] - nx: 6
[16:12:31.486] - relay: TRUE
[16:12:31.486] - stdout: TRUE
[16:12:31.486] - signal: TRUE
[16:12:31.486] - resignal: FALSE
[16:12:31.486] - force: TRUE
[16:12:31.487] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.487] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.487]  - until=6
[16:12:31.487]  - relaying element #4
[16:12:31.487] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.487] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.487] signalConditionsASAP(NULL, pos=6) ... done
[16:12:31.487]  length: 1 (resolved future 6)
[16:12:31.498] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.498] - Validating connection of MultisessionFuture
[16:12:31.498] - received message: FutureResult
[16:12:31.498] - Received FutureResult
[16:12:31.498] - Erased future from FutureRegistry
[16:12:31.499] result() for ClusterFuture ...
[16:12:31.499] - result already collected: FutureResult
[16:12:31.499] result() for ClusterFuture ... done
[16:12:31.499] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.499] Future #4
[16:12:31.499] result() for ClusterFuture ...
[16:12:31.499] - result already collected: FutureResult
[16:12:31.499] result() for ClusterFuture ... done
[16:12:31.499] result() for ClusterFuture ...
[16:12:31.499] - result already collected: FutureResult
[16:12:31.499] result() for ClusterFuture ... done
[16:12:31.500] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:31.500] - nx: 6
[16:12:31.500] - relay: TRUE
[16:12:31.500] - stdout: TRUE
[16:12:31.500] - signal: TRUE
[16:12:31.500] - resignal: FALSE
[16:12:31.500] - force: TRUE
[16:12:31.500] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.500] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.500]  - until=6
[16:12:31.501]  - relaying element #4
[16:12:31.501] result() for ClusterFuture ...
[16:12:31.501] - result already collected: FutureResult
[16:12:31.501] result() for ClusterFuture ... done
[16:12:31.501] result() for ClusterFuture ...
[16:12:31.501] - result already collected: FutureResult
[16:12:31.501] result() for ClusterFuture ... done
[16:12:31.501] result() for ClusterFuture ...
[16:12:31.501] - result already collected: FutureResult
[16:12:31.501] result() for ClusterFuture ... done
[16:12:31.502] result() for ClusterFuture ...
[16:12:31.502] - result already collected: FutureResult
[16:12:31.502] result() for ClusterFuture ... done
[16:12:31.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.502] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.502] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:31.502]  length: 0 (resolved future 4)
[16:12:31.502] Relaying remaining futures
[16:12:31.502] signalConditionsASAP(NULL, pos=0) ...
[16:12:31.502] - nx: 6
[16:12:31.502] - relay: TRUE
[16:12:31.503] - stdout: TRUE
[16:12:31.503] - signal: TRUE
[16:12:31.503] - resignal: FALSE
[16:12:31.503] - force: TRUE
[16:12:31.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.503] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:31.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.503] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.503] signalConditionsASAP(NULL, pos=0) ... done
[16:12:31.503] resolve() on list environment ... DONE
[16:12:31.504] result() for ClusterFuture ...
[16:12:31.504] - result already collected: FutureResult
[16:12:31.504] result() for ClusterFuture ... done
[16:12:31.504] result() for ClusterFuture ...
[16:12:31.504] - result already collected: FutureResult
[16:12:31.504] result() for ClusterFuture ... done
[16:12:31.504] result() for ClusterFuture ...
[16:12:31.504] - result already collected: FutureResult
[16:12:31.504] result() for ClusterFuture ... done
[16:12:31.504] result() for ClusterFuture ...
[16:12:31.505] - result already collected: FutureResult
[16:12:31.505] result() for ClusterFuture ... done
[16:12:31.505] result() for ClusterFuture ...
[16:12:31.505] - result already collected: FutureResult
[16:12:31.505] result() for ClusterFuture ... done
[16:12:31.505] result() for ClusterFuture ...
[16:12:31.505] - result already collected: FutureResult
[16:12:31.505] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x560bafed4680> 
Dimensions: c(1, 6)
[16:12:31.506] getGlobalsAndPackages() ...
[16:12:31.506] Searching for globals...
[16:12:31.506] 
[16:12:31.506] Searching for globals ... DONE
[16:12:31.507] - globals: [0] <none>
[16:12:31.507] getGlobalsAndPackages() ... DONE
[16:12:31.507] run() for ‘Future’ ...
[16:12:31.507] - state: ‘created’
[16:12:31.507] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.526]   - Field: ‘node’
[16:12:31.526]   - Field: ‘label’
[16:12:31.526]   - Field: ‘local’
[16:12:31.526]   - Field: ‘owner’
[16:12:31.526]   - Field: ‘envir’
[16:12:31.527]   - Field: ‘workers’
[16:12:31.527]   - Field: ‘packages’
[16:12:31.527]   - Field: ‘gc’
[16:12:31.527]   - Field: ‘conditions’
[16:12:31.527]   - Field: ‘persistent’
[16:12:31.527]   - Field: ‘expr’
[16:12:31.527]   - Field: ‘uuid’
[16:12:31.527]   - Field: ‘seed’
[16:12:31.527]   - Field: ‘version’
[16:12:31.527]   - Field: ‘result’
[16:12:31.528]   - Field: ‘asynchronous’
[16:12:31.528]   - Field: ‘calls’
[16:12:31.528]   - Field: ‘globals’
[16:12:31.528]   - Field: ‘stdout’
[16:12:31.528]   - Field: ‘earlySignal’
[16:12:31.528]   - Field: ‘lazy’
[16:12:31.528]   - Field: ‘state’
[16:12:31.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.528] - Launch lazy future ...
[16:12:31.529] Packages needed by the future expression (n = 0): <none>
[16:12:31.529] Packages needed by future strategies (n = 0): <none>
[16:12:31.529] {
[16:12:31.529]     {
[16:12:31.529]         {
[16:12:31.529]             ...future.startTime <- base::Sys.time()
[16:12:31.529]             {
[16:12:31.529]                 {
[16:12:31.529]                   {
[16:12:31.529]                     {
[16:12:31.529]                       base::local({
[16:12:31.529]                         has_future <- base::requireNamespace("future", 
[16:12:31.529]                           quietly = TRUE)
[16:12:31.529]                         if (has_future) {
[16:12:31.529]                           ns <- base::getNamespace("future")
[16:12:31.529]                           version <- ns[[".package"]][["version"]]
[16:12:31.529]                           if (is.null(version)) 
[16:12:31.529]                             version <- utils::packageVersion("future")
[16:12:31.529]                         }
[16:12:31.529]                         else {
[16:12:31.529]                           version <- NULL
[16:12:31.529]                         }
[16:12:31.529]                         if (!has_future || version < "1.8.0") {
[16:12:31.529]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.529]                             "", base::R.version$version.string), 
[16:12:31.529]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.529]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.529]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.529]                               "release", "version")], collapse = " "), 
[16:12:31.529]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.529]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.529]                             info)
[16:12:31.529]                           info <- base::paste(info, collapse = "; ")
[16:12:31.529]                           if (!has_future) {
[16:12:31.529]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.529]                               info)
[16:12:31.529]                           }
[16:12:31.529]                           else {
[16:12:31.529]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.529]                               info, version)
[16:12:31.529]                           }
[16:12:31.529]                           base::stop(msg)
[16:12:31.529]                         }
[16:12:31.529]                       })
[16:12:31.529]                     }
[16:12:31.529]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.529]                     base::options(mc.cores = 1L)
[16:12:31.529]                   }
[16:12:31.529]                   options(future.plan = NULL)
[16:12:31.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.529]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.529]                 }
[16:12:31.529]                 ...future.workdir <- getwd()
[16:12:31.529]             }
[16:12:31.529]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.529]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.529]         }
[16:12:31.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.529]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.529]             base::names(...future.oldOptions))
[16:12:31.529]     }
[16:12:31.529]     if (FALSE) {
[16:12:31.529]     }
[16:12:31.529]     else {
[16:12:31.529]         if (TRUE) {
[16:12:31.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.529]                 open = "w")
[16:12:31.529]         }
[16:12:31.529]         else {
[16:12:31.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.529]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.529]         }
[16:12:31.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.529]             base::sink(type = "output", split = FALSE)
[16:12:31.529]             base::close(...future.stdout)
[16:12:31.529]         }, add = TRUE)
[16:12:31.529]     }
[16:12:31.529]     ...future.frame <- base::sys.nframe()
[16:12:31.529]     ...future.conditions <- base::list()
[16:12:31.529]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.529]     if (FALSE) {
[16:12:31.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.529]     }
[16:12:31.529]     ...future.result <- base::tryCatch({
[16:12:31.529]         base::withCallingHandlers({
[16:12:31.529]             ...future.value <- base::withVisible(base::local({
[16:12:31.529]                 ...future.makeSendCondition <- local({
[16:12:31.529]                   sendCondition <- NULL
[16:12:31.529]                   function(frame = 1L) {
[16:12:31.529]                     if (is.function(sendCondition)) 
[16:12:31.529]                       return(sendCondition)
[16:12:31.529]                     ns <- getNamespace("parallel")
[16:12:31.529]                     if (exists("sendData", mode = "function", 
[16:12:31.529]                       envir = ns)) {
[16:12:31.529]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.529]                         envir = ns)
[16:12:31.529]                       envir <- sys.frame(frame)
[16:12:31.529]                       master <- NULL
[16:12:31.529]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.529]                         !identical(envir, emptyenv())) {
[16:12:31.529]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.529]                           inherits = FALSE)) {
[16:12:31.529]                           master <- get("master", mode = "list", 
[16:12:31.529]                             envir = envir, inherits = FALSE)
[16:12:31.529]                           if (inherits(master, c("SOCKnode", 
[16:12:31.529]                             "SOCK0node"))) {
[16:12:31.529]                             sendCondition <<- function(cond) {
[16:12:31.529]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.529]                                 success = TRUE)
[16:12:31.529]                               parallel_sendData(master, data)
[16:12:31.529]                             }
[16:12:31.529]                             return(sendCondition)
[16:12:31.529]                           }
[16:12:31.529]                         }
[16:12:31.529]                         frame <- frame + 1L
[16:12:31.529]                         envir <- sys.frame(frame)
[16:12:31.529]                       }
[16:12:31.529]                     }
[16:12:31.529]                     sendCondition <<- function(cond) NULL
[16:12:31.529]                   }
[16:12:31.529]                 })
[16:12:31.529]                 withCallingHandlers({
[16:12:31.529]                   2
[16:12:31.529]                 }, immediateCondition = function(cond) {
[16:12:31.529]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.529]                   sendCondition(cond)
[16:12:31.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.529]                   {
[16:12:31.529]                     inherits <- base::inherits
[16:12:31.529]                     invokeRestart <- base::invokeRestart
[16:12:31.529]                     is.null <- base::is.null
[16:12:31.529]                     muffled <- FALSE
[16:12:31.529]                     if (inherits(cond, "message")) {
[16:12:31.529]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.529]                       if (muffled) 
[16:12:31.529]                         invokeRestart("muffleMessage")
[16:12:31.529]                     }
[16:12:31.529]                     else if (inherits(cond, "warning")) {
[16:12:31.529]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.529]                       if (muffled) 
[16:12:31.529]                         invokeRestart("muffleWarning")
[16:12:31.529]                     }
[16:12:31.529]                     else if (inherits(cond, "condition")) {
[16:12:31.529]                       if (!is.null(pattern)) {
[16:12:31.529]                         computeRestarts <- base::computeRestarts
[16:12:31.529]                         grepl <- base::grepl
[16:12:31.529]                         restarts <- computeRestarts(cond)
[16:12:31.529]                         for (restart in restarts) {
[16:12:31.529]                           name <- restart$name
[16:12:31.529]                           if (is.null(name)) 
[16:12:31.529]                             next
[16:12:31.529]                           if (!grepl(pattern, name)) 
[16:12:31.529]                             next
[16:12:31.529]                           invokeRestart(restart)
[16:12:31.529]                           muffled <- TRUE
[16:12:31.529]                           break
[16:12:31.529]                         }
[16:12:31.529]                       }
[16:12:31.529]                     }
[16:12:31.529]                     invisible(muffled)
[16:12:31.529]                   }
[16:12:31.529]                   muffleCondition(cond)
[16:12:31.529]                 })
[16:12:31.529]             }))
[16:12:31.529]             future::FutureResult(value = ...future.value$value, 
[16:12:31.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.529]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.529]                     ...future.globalenv.names))
[16:12:31.529]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.529]         }, condition = base::local({
[16:12:31.529]             c <- base::c
[16:12:31.529]             inherits <- base::inherits
[16:12:31.529]             invokeRestart <- base::invokeRestart
[16:12:31.529]             length <- base::length
[16:12:31.529]             list <- base::list
[16:12:31.529]             seq.int <- base::seq.int
[16:12:31.529]             signalCondition <- base::signalCondition
[16:12:31.529]             sys.calls <- base::sys.calls
[16:12:31.529]             `[[` <- base::`[[`
[16:12:31.529]             `+` <- base::`+`
[16:12:31.529]             `<<-` <- base::`<<-`
[16:12:31.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.529]                   3L)]
[16:12:31.529]             }
[16:12:31.529]             function(cond) {
[16:12:31.529]                 is_error <- inherits(cond, "error")
[16:12:31.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.529]                   NULL)
[16:12:31.529]                 if (is_error) {
[16:12:31.529]                   sessionInformation <- function() {
[16:12:31.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.529]                       search = base::search(), system = base::Sys.info())
[16:12:31.529]                   }
[16:12:31.529]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.529]                     cond$call), session = sessionInformation(), 
[16:12:31.529]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.529]                   signalCondition(cond)
[16:12:31.529]                 }
[16:12:31.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.529]                 "immediateCondition"))) {
[16:12:31.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.529]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.529]                   if (TRUE && !signal) {
[16:12:31.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.529]                     {
[16:12:31.529]                       inherits <- base::inherits
[16:12:31.529]                       invokeRestart <- base::invokeRestart
[16:12:31.529]                       is.null <- base::is.null
[16:12:31.529]                       muffled <- FALSE
[16:12:31.529]                       if (inherits(cond, "message")) {
[16:12:31.529]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.529]                         if (muffled) 
[16:12:31.529]                           invokeRestart("muffleMessage")
[16:12:31.529]                       }
[16:12:31.529]                       else if (inherits(cond, "warning")) {
[16:12:31.529]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.529]                         if (muffled) 
[16:12:31.529]                           invokeRestart("muffleWarning")
[16:12:31.529]                       }
[16:12:31.529]                       else if (inherits(cond, "condition")) {
[16:12:31.529]                         if (!is.null(pattern)) {
[16:12:31.529]                           computeRestarts <- base::computeRestarts
[16:12:31.529]                           grepl <- base::grepl
[16:12:31.529]                           restarts <- computeRestarts(cond)
[16:12:31.529]                           for (restart in restarts) {
[16:12:31.529]                             name <- restart$name
[16:12:31.529]                             if (is.null(name)) 
[16:12:31.529]                               next
[16:12:31.529]                             if (!grepl(pattern, name)) 
[16:12:31.529]                               next
[16:12:31.529]                             invokeRestart(restart)
[16:12:31.529]                             muffled <- TRUE
[16:12:31.529]                             break
[16:12:31.529]                           }
[16:12:31.529]                         }
[16:12:31.529]                       }
[16:12:31.529]                       invisible(muffled)
[16:12:31.529]                     }
[16:12:31.529]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.529]                   }
[16:12:31.529]                 }
[16:12:31.529]                 else {
[16:12:31.529]                   if (TRUE) {
[16:12:31.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.529]                     {
[16:12:31.529]                       inherits <- base::inherits
[16:12:31.529]                       invokeRestart <- base::invokeRestart
[16:12:31.529]                       is.null <- base::is.null
[16:12:31.529]                       muffled <- FALSE
[16:12:31.529]                       if (inherits(cond, "message")) {
[16:12:31.529]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.529]                         if (muffled) 
[16:12:31.529]                           invokeRestart("muffleMessage")
[16:12:31.529]                       }
[16:12:31.529]                       else if (inherits(cond, "warning")) {
[16:12:31.529]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.529]                         if (muffled) 
[16:12:31.529]                           invokeRestart("muffleWarning")
[16:12:31.529]                       }
[16:12:31.529]                       else if (inherits(cond, "condition")) {
[16:12:31.529]                         if (!is.null(pattern)) {
[16:12:31.529]                           computeRestarts <- base::computeRestarts
[16:12:31.529]                           grepl <- base::grepl
[16:12:31.529]                           restarts <- computeRestarts(cond)
[16:12:31.529]                           for (restart in restarts) {
[16:12:31.529]                             name <- restart$name
[16:12:31.529]                             if (is.null(name)) 
[16:12:31.529]                               next
[16:12:31.529]                             if (!grepl(pattern, name)) 
[16:12:31.529]                               next
[16:12:31.529]                             invokeRestart(restart)
[16:12:31.529]                             muffled <- TRUE
[16:12:31.529]                             break
[16:12:31.529]                           }
[16:12:31.529]                         }
[16:12:31.529]                       }
[16:12:31.529]                       invisible(muffled)
[16:12:31.529]                     }
[16:12:31.529]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.529]                   }
[16:12:31.529]                 }
[16:12:31.529]             }
[16:12:31.529]         }))
[16:12:31.529]     }, error = function(ex) {
[16:12:31.529]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.529]                 ...future.rng), started = ...future.startTime, 
[16:12:31.529]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.529]             version = "1.8"), class = "FutureResult")
[16:12:31.529]     }, finally = {
[16:12:31.529]         if (!identical(...future.workdir, getwd())) 
[16:12:31.529]             setwd(...future.workdir)
[16:12:31.529]         {
[16:12:31.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.529]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.529]             }
[16:12:31.529]             base::options(...future.oldOptions)
[16:12:31.529]             if (.Platform$OS.type == "windows") {
[16:12:31.529]                 old_names <- names(...future.oldEnvVars)
[16:12:31.529]                 envs <- base::Sys.getenv()
[16:12:31.529]                 names <- names(envs)
[16:12:31.529]                 common <- intersect(names, old_names)
[16:12:31.529]                 added <- setdiff(names, old_names)
[16:12:31.529]                 removed <- setdiff(old_names, names)
[16:12:31.529]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.529]                   envs[common]]
[16:12:31.529]                 NAMES <- toupper(changed)
[16:12:31.529]                 args <- list()
[16:12:31.529]                 for (kk in seq_along(NAMES)) {
[16:12:31.529]                   name <- changed[[kk]]
[16:12:31.529]                   NAME <- NAMES[[kk]]
[16:12:31.529]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.529]                     next
[16:12:31.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.529]                 }
[16:12:31.529]                 NAMES <- toupper(added)
[16:12:31.529]                 for (kk in seq_along(NAMES)) {
[16:12:31.529]                   name <- added[[kk]]
[16:12:31.529]                   NAME <- NAMES[[kk]]
[16:12:31.529]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.529]                     next
[16:12:31.529]                   args[[name]] <- ""
[16:12:31.529]                 }
[16:12:31.529]                 NAMES <- toupper(removed)
[16:12:31.529]                 for (kk in seq_along(NAMES)) {
[16:12:31.529]                   name <- removed[[kk]]
[16:12:31.529]                   NAME <- NAMES[[kk]]
[16:12:31.529]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.529]                     next
[16:12:31.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.529]                 }
[16:12:31.529]                 if (length(args) > 0) 
[16:12:31.529]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.529]             }
[16:12:31.529]             else {
[16:12:31.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.529]             }
[16:12:31.529]             {
[16:12:31.529]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.529]                   0L) {
[16:12:31.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.529]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.529]                   base::options(opts)
[16:12:31.529]                 }
[16:12:31.529]                 {
[16:12:31.529]                   {
[16:12:31.529]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.529]                     NULL
[16:12:31.529]                   }
[16:12:31.529]                   options(future.plan = NULL)
[16:12:31.529]                   if (is.na(NA_character_)) 
[16:12:31.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.529]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.529]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.529]                     envir = parent.frame()) 
[16:12:31.529]                   {
[16:12:31.529]                     if (is.function(workers)) 
[16:12:31.529]                       workers <- workers()
[16:12:31.529]                     workers <- structure(as.integer(workers), 
[16:12:31.529]                       class = class(workers))
[16:12:31.529]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.529]                       workers >= 1)
[16:12:31.529]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.529]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.529]                     }
[16:12:31.529]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.529]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.529]                       envir = envir)
[16:12:31.529]                     if (!future$lazy) 
[16:12:31.529]                       future <- run(future)
[16:12:31.529]                     invisible(future)
[16:12:31.529]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.529]                 }
[16:12:31.529]             }
[16:12:31.529]         }
[16:12:31.529]     })
[16:12:31.529]     if (TRUE) {
[16:12:31.529]         base::sink(type = "output", split = FALSE)
[16:12:31.529]         if (TRUE) {
[16:12:31.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.529]         }
[16:12:31.529]         else {
[16:12:31.529]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.529]         }
[16:12:31.529]         base::close(...future.stdout)
[16:12:31.529]         ...future.stdout <- NULL
[16:12:31.529]     }
[16:12:31.529]     ...future.result$conditions <- ...future.conditions
[16:12:31.529]     ...future.result$finished <- base::Sys.time()
[16:12:31.529]     ...future.result
[16:12:31.529] }
[16:12:31.532] MultisessionFuture started
[16:12:31.532] - Launch lazy future ... done
[16:12:31.533] run() for ‘MultisessionFuture’ ... done
[16:12:31.533] getGlobalsAndPackages() ...
[16:12:31.533] Searching for globals...
[16:12:31.533] 
[16:12:31.533] Searching for globals ... DONE
[16:12:31.533] - globals: [0] <none>
[16:12:31.533] getGlobalsAndPackages() ... DONE
[16:12:31.534] run() for ‘Future’ ...
[16:12:31.534] - state: ‘created’
[16:12:31.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.549]   - Field: ‘node’
[16:12:31.549]   - Field: ‘label’
[16:12:31.549]   - Field: ‘local’
[16:12:31.549]   - Field: ‘owner’
[16:12:31.549]   - Field: ‘envir’
[16:12:31.549]   - Field: ‘workers’
[16:12:31.549]   - Field: ‘packages’
[16:12:31.549]   - Field: ‘gc’
[16:12:31.549]   - Field: ‘conditions’
[16:12:31.549]   - Field: ‘persistent’
[16:12:31.550]   - Field: ‘expr’
[16:12:31.550]   - Field: ‘uuid’
[16:12:31.550]   - Field: ‘seed’
[16:12:31.550]   - Field: ‘version’
[16:12:31.550]   - Field: ‘result’
[16:12:31.550]   - Field: ‘asynchronous’
[16:12:31.550]   - Field: ‘calls’
[16:12:31.550]   - Field: ‘globals’
[16:12:31.550]   - Field: ‘stdout’
[16:12:31.550]   - Field: ‘earlySignal’
[16:12:31.551]   - Field: ‘lazy’
[16:12:31.551]   - Field: ‘state’
[16:12:31.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.551] - Launch lazy future ...
[16:12:31.551] Packages needed by the future expression (n = 0): <none>
[16:12:31.551] Packages needed by future strategies (n = 0): <none>
[16:12:31.552] {
[16:12:31.552]     {
[16:12:31.552]         {
[16:12:31.552]             ...future.startTime <- base::Sys.time()
[16:12:31.552]             {
[16:12:31.552]                 {
[16:12:31.552]                   {
[16:12:31.552]                     {
[16:12:31.552]                       base::local({
[16:12:31.552]                         has_future <- base::requireNamespace("future", 
[16:12:31.552]                           quietly = TRUE)
[16:12:31.552]                         if (has_future) {
[16:12:31.552]                           ns <- base::getNamespace("future")
[16:12:31.552]                           version <- ns[[".package"]][["version"]]
[16:12:31.552]                           if (is.null(version)) 
[16:12:31.552]                             version <- utils::packageVersion("future")
[16:12:31.552]                         }
[16:12:31.552]                         else {
[16:12:31.552]                           version <- NULL
[16:12:31.552]                         }
[16:12:31.552]                         if (!has_future || version < "1.8.0") {
[16:12:31.552]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.552]                             "", base::R.version$version.string), 
[16:12:31.552]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.552]                               "release", "version")], collapse = " "), 
[16:12:31.552]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.552]                             info)
[16:12:31.552]                           info <- base::paste(info, collapse = "; ")
[16:12:31.552]                           if (!has_future) {
[16:12:31.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.552]                               info)
[16:12:31.552]                           }
[16:12:31.552]                           else {
[16:12:31.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.552]                               info, version)
[16:12:31.552]                           }
[16:12:31.552]                           base::stop(msg)
[16:12:31.552]                         }
[16:12:31.552]                       })
[16:12:31.552]                     }
[16:12:31.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.552]                     base::options(mc.cores = 1L)
[16:12:31.552]                   }
[16:12:31.552]                   options(future.plan = NULL)
[16:12:31.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.552]                 }
[16:12:31.552]                 ...future.workdir <- getwd()
[16:12:31.552]             }
[16:12:31.552]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.552]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.552]         }
[16:12:31.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.552]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.552]             base::names(...future.oldOptions))
[16:12:31.552]     }
[16:12:31.552]     if (FALSE) {
[16:12:31.552]     }
[16:12:31.552]     else {
[16:12:31.552]         if (TRUE) {
[16:12:31.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.552]                 open = "w")
[16:12:31.552]         }
[16:12:31.552]         else {
[16:12:31.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.552]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.552]         }
[16:12:31.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.552]             base::sink(type = "output", split = FALSE)
[16:12:31.552]             base::close(...future.stdout)
[16:12:31.552]         }, add = TRUE)
[16:12:31.552]     }
[16:12:31.552]     ...future.frame <- base::sys.nframe()
[16:12:31.552]     ...future.conditions <- base::list()
[16:12:31.552]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.552]     if (FALSE) {
[16:12:31.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.552]     }
[16:12:31.552]     ...future.result <- base::tryCatch({
[16:12:31.552]         base::withCallingHandlers({
[16:12:31.552]             ...future.value <- base::withVisible(base::local({
[16:12:31.552]                 ...future.makeSendCondition <- local({
[16:12:31.552]                   sendCondition <- NULL
[16:12:31.552]                   function(frame = 1L) {
[16:12:31.552]                     if (is.function(sendCondition)) 
[16:12:31.552]                       return(sendCondition)
[16:12:31.552]                     ns <- getNamespace("parallel")
[16:12:31.552]                     if (exists("sendData", mode = "function", 
[16:12:31.552]                       envir = ns)) {
[16:12:31.552]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.552]                         envir = ns)
[16:12:31.552]                       envir <- sys.frame(frame)
[16:12:31.552]                       master <- NULL
[16:12:31.552]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.552]                         !identical(envir, emptyenv())) {
[16:12:31.552]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.552]                           inherits = FALSE)) {
[16:12:31.552]                           master <- get("master", mode = "list", 
[16:12:31.552]                             envir = envir, inherits = FALSE)
[16:12:31.552]                           if (inherits(master, c("SOCKnode", 
[16:12:31.552]                             "SOCK0node"))) {
[16:12:31.552]                             sendCondition <<- function(cond) {
[16:12:31.552]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.552]                                 success = TRUE)
[16:12:31.552]                               parallel_sendData(master, data)
[16:12:31.552]                             }
[16:12:31.552]                             return(sendCondition)
[16:12:31.552]                           }
[16:12:31.552]                         }
[16:12:31.552]                         frame <- frame + 1L
[16:12:31.552]                         envir <- sys.frame(frame)
[16:12:31.552]                       }
[16:12:31.552]                     }
[16:12:31.552]                     sendCondition <<- function(cond) NULL
[16:12:31.552]                   }
[16:12:31.552]                 })
[16:12:31.552]                 withCallingHandlers({
[16:12:31.552]                   NULL
[16:12:31.552]                 }, immediateCondition = function(cond) {
[16:12:31.552]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.552]                   sendCondition(cond)
[16:12:31.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.552]                   {
[16:12:31.552]                     inherits <- base::inherits
[16:12:31.552]                     invokeRestart <- base::invokeRestart
[16:12:31.552]                     is.null <- base::is.null
[16:12:31.552]                     muffled <- FALSE
[16:12:31.552]                     if (inherits(cond, "message")) {
[16:12:31.552]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.552]                       if (muffled) 
[16:12:31.552]                         invokeRestart("muffleMessage")
[16:12:31.552]                     }
[16:12:31.552]                     else if (inherits(cond, "warning")) {
[16:12:31.552]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.552]                       if (muffled) 
[16:12:31.552]                         invokeRestart("muffleWarning")
[16:12:31.552]                     }
[16:12:31.552]                     else if (inherits(cond, "condition")) {
[16:12:31.552]                       if (!is.null(pattern)) {
[16:12:31.552]                         computeRestarts <- base::computeRestarts
[16:12:31.552]                         grepl <- base::grepl
[16:12:31.552]                         restarts <- computeRestarts(cond)
[16:12:31.552]                         for (restart in restarts) {
[16:12:31.552]                           name <- restart$name
[16:12:31.552]                           if (is.null(name)) 
[16:12:31.552]                             next
[16:12:31.552]                           if (!grepl(pattern, name)) 
[16:12:31.552]                             next
[16:12:31.552]                           invokeRestart(restart)
[16:12:31.552]                           muffled <- TRUE
[16:12:31.552]                           break
[16:12:31.552]                         }
[16:12:31.552]                       }
[16:12:31.552]                     }
[16:12:31.552]                     invisible(muffled)
[16:12:31.552]                   }
[16:12:31.552]                   muffleCondition(cond)
[16:12:31.552]                 })
[16:12:31.552]             }))
[16:12:31.552]             future::FutureResult(value = ...future.value$value, 
[16:12:31.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.552]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.552]                     ...future.globalenv.names))
[16:12:31.552]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.552]         }, condition = base::local({
[16:12:31.552]             c <- base::c
[16:12:31.552]             inherits <- base::inherits
[16:12:31.552]             invokeRestart <- base::invokeRestart
[16:12:31.552]             length <- base::length
[16:12:31.552]             list <- base::list
[16:12:31.552]             seq.int <- base::seq.int
[16:12:31.552]             signalCondition <- base::signalCondition
[16:12:31.552]             sys.calls <- base::sys.calls
[16:12:31.552]             `[[` <- base::`[[`
[16:12:31.552]             `+` <- base::`+`
[16:12:31.552]             `<<-` <- base::`<<-`
[16:12:31.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.552]                   3L)]
[16:12:31.552]             }
[16:12:31.552]             function(cond) {
[16:12:31.552]                 is_error <- inherits(cond, "error")
[16:12:31.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.552]                   NULL)
[16:12:31.552]                 if (is_error) {
[16:12:31.552]                   sessionInformation <- function() {
[16:12:31.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.552]                       search = base::search(), system = base::Sys.info())
[16:12:31.552]                   }
[16:12:31.552]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.552]                     cond$call), session = sessionInformation(), 
[16:12:31.552]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.552]                   signalCondition(cond)
[16:12:31.552]                 }
[16:12:31.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.552]                 "immediateCondition"))) {
[16:12:31.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.552]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.552]                   if (TRUE && !signal) {
[16:12:31.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.552]                     {
[16:12:31.552]                       inherits <- base::inherits
[16:12:31.552]                       invokeRestart <- base::invokeRestart
[16:12:31.552]                       is.null <- base::is.null
[16:12:31.552]                       muffled <- FALSE
[16:12:31.552]                       if (inherits(cond, "message")) {
[16:12:31.552]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.552]                         if (muffled) 
[16:12:31.552]                           invokeRestart("muffleMessage")
[16:12:31.552]                       }
[16:12:31.552]                       else if (inherits(cond, "warning")) {
[16:12:31.552]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.552]                         if (muffled) 
[16:12:31.552]                           invokeRestart("muffleWarning")
[16:12:31.552]                       }
[16:12:31.552]                       else if (inherits(cond, "condition")) {
[16:12:31.552]                         if (!is.null(pattern)) {
[16:12:31.552]                           computeRestarts <- base::computeRestarts
[16:12:31.552]                           grepl <- base::grepl
[16:12:31.552]                           restarts <- computeRestarts(cond)
[16:12:31.552]                           for (restart in restarts) {
[16:12:31.552]                             name <- restart$name
[16:12:31.552]                             if (is.null(name)) 
[16:12:31.552]                               next
[16:12:31.552]                             if (!grepl(pattern, name)) 
[16:12:31.552]                               next
[16:12:31.552]                             invokeRestart(restart)
[16:12:31.552]                             muffled <- TRUE
[16:12:31.552]                             break
[16:12:31.552]                           }
[16:12:31.552]                         }
[16:12:31.552]                       }
[16:12:31.552]                       invisible(muffled)
[16:12:31.552]                     }
[16:12:31.552]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.552]                   }
[16:12:31.552]                 }
[16:12:31.552]                 else {
[16:12:31.552]                   if (TRUE) {
[16:12:31.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.552]                     {
[16:12:31.552]                       inherits <- base::inherits
[16:12:31.552]                       invokeRestart <- base::invokeRestart
[16:12:31.552]                       is.null <- base::is.null
[16:12:31.552]                       muffled <- FALSE
[16:12:31.552]                       if (inherits(cond, "message")) {
[16:12:31.552]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.552]                         if (muffled) 
[16:12:31.552]                           invokeRestart("muffleMessage")
[16:12:31.552]                       }
[16:12:31.552]                       else if (inherits(cond, "warning")) {
[16:12:31.552]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.552]                         if (muffled) 
[16:12:31.552]                           invokeRestart("muffleWarning")
[16:12:31.552]                       }
[16:12:31.552]                       else if (inherits(cond, "condition")) {
[16:12:31.552]                         if (!is.null(pattern)) {
[16:12:31.552]                           computeRestarts <- base::computeRestarts
[16:12:31.552]                           grepl <- base::grepl
[16:12:31.552]                           restarts <- computeRestarts(cond)
[16:12:31.552]                           for (restart in restarts) {
[16:12:31.552]                             name <- restart$name
[16:12:31.552]                             if (is.null(name)) 
[16:12:31.552]                               next
[16:12:31.552]                             if (!grepl(pattern, name)) 
[16:12:31.552]                               next
[16:12:31.552]                             invokeRestart(restart)
[16:12:31.552]                             muffled <- TRUE
[16:12:31.552]                             break
[16:12:31.552]                           }
[16:12:31.552]                         }
[16:12:31.552]                       }
[16:12:31.552]                       invisible(muffled)
[16:12:31.552]                     }
[16:12:31.552]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.552]                   }
[16:12:31.552]                 }
[16:12:31.552]             }
[16:12:31.552]         }))
[16:12:31.552]     }, error = function(ex) {
[16:12:31.552]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.552]                 ...future.rng), started = ...future.startTime, 
[16:12:31.552]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.552]             version = "1.8"), class = "FutureResult")
[16:12:31.552]     }, finally = {
[16:12:31.552]         if (!identical(...future.workdir, getwd())) 
[16:12:31.552]             setwd(...future.workdir)
[16:12:31.552]         {
[16:12:31.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.552]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.552]             }
[16:12:31.552]             base::options(...future.oldOptions)
[16:12:31.552]             if (.Platform$OS.type == "windows") {
[16:12:31.552]                 old_names <- names(...future.oldEnvVars)
[16:12:31.552]                 envs <- base::Sys.getenv()
[16:12:31.552]                 names <- names(envs)
[16:12:31.552]                 common <- intersect(names, old_names)
[16:12:31.552]                 added <- setdiff(names, old_names)
[16:12:31.552]                 removed <- setdiff(old_names, names)
[16:12:31.552]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.552]                   envs[common]]
[16:12:31.552]                 NAMES <- toupper(changed)
[16:12:31.552]                 args <- list()
[16:12:31.552]                 for (kk in seq_along(NAMES)) {
[16:12:31.552]                   name <- changed[[kk]]
[16:12:31.552]                   NAME <- NAMES[[kk]]
[16:12:31.552]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.552]                     next
[16:12:31.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.552]                 }
[16:12:31.552]                 NAMES <- toupper(added)
[16:12:31.552]                 for (kk in seq_along(NAMES)) {
[16:12:31.552]                   name <- added[[kk]]
[16:12:31.552]                   NAME <- NAMES[[kk]]
[16:12:31.552]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.552]                     next
[16:12:31.552]                   args[[name]] <- ""
[16:12:31.552]                 }
[16:12:31.552]                 NAMES <- toupper(removed)
[16:12:31.552]                 for (kk in seq_along(NAMES)) {
[16:12:31.552]                   name <- removed[[kk]]
[16:12:31.552]                   NAME <- NAMES[[kk]]
[16:12:31.552]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.552]                     next
[16:12:31.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.552]                 }
[16:12:31.552]                 if (length(args) > 0) 
[16:12:31.552]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.552]             }
[16:12:31.552]             else {
[16:12:31.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.552]             }
[16:12:31.552]             {
[16:12:31.552]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.552]                   0L) {
[16:12:31.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.552]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.552]                   base::options(opts)
[16:12:31.552]                 }
[16:12:31.552]                 {
[16:12:31.552]                   {
[16:12:31.552]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.552]                     NULL
[16:12:31.552]                   }
[16:12:31.552]                   options(future.plan = NULL)
[16:12:31.552]                   if (is.na(NA_character_)) 
[16:12:31.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.552]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.552]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.552]                     envir = parent.frame()) 
[16:12:31.552]                   {
[16:12:31.552]                     if (is.function(workers)) 
[16:12:31.552]                       workers <- workers()
[16:12:31.552]                     workers <- structure(as.integer(workers), 
[16:12:31.552]                       class = class(workers))
[16:12:31.552]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.552]                       workers >= 1)
[16:12:31.552]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.552]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.552]                     }
[16:12:31.552]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.552]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.552]                       envir = envir)
[16:12:31.552]                     if (!future$lazy) 
[16:12:31.552]                       future <- run(future)
[16:12:31.552]                     invisible(future)
[16:12:31.552]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.552]                 }
[16:12:31.552]             }
[16:12:31.552]         }
[16:12:31.552]     })
[16:12:31.552]     if (TRUE) {
[16:12:31.552]         base::sink(type = "output", split = FALSE)
[16:12:31.552]         if (TRUE) {
[16:12:31.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.552]         }
[16:12:31.552]         else {
[16:12:31.552]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.552]         }
[16:12:31.552]         base::close(...future.stdout)
[16:12:31.552]         ...future.stdout <- NULL
[16:12:31.552]     }
[16:12:31.552]     ...future.result$conditions <- ...future.conditions
[16:12:31.552]     ...future.result$finished <- base::Sys.time()
[16:12:31.552]     ...future.result
[16:12:31.552] }
[16:12:31.555] MultisessionFuture started
[16:12:31.555] - Launch lazy future ... done
[16:12:31.555] run() for ‘MultisessionFuture’ ... done
[16:12:31.555] getGlobalsAndPackages() ...
[16:12:31.555] Searching for globals...
[16:12:31.556] - globals found: [1] ‘{’
[16:12:31.556] Searching for globals ... DONE
[16:12:31.556] Resolving globals: FALSE
[16:12:31.557] 
[16:12:31.557] 
[16:12:31.557] getGlobalsAndPackages() ... DONE
[16:12:31.557] run() for ‘Future’ ...
[16:12:31.557] - state: ‘created’
[16:12:31.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.572] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.572]   - Field: ‘node’
[16:12:31.572]   - Field: ‘label’
[16:12:31.572]   - Field: ‘local’
[16:12:31.572]   - Field: ‘owner’
[16:12:31.572]   - Field: ‘envir’
[16:12:31.572]   - Field: ‘workers’
[16:12:31.572]   - Field: ‘packages’
[16:12:31.573]   - Field: ‘gc’
[16:12:31.573]   - Field: ‘conditions’
[16:12:31.573]   - Field: ‘persistent’
[16:12:31.573]   - Field: ‘expr’
[16:12:31.573]   - Field: ‘uuid’
[16:12:31.573]   - Field: ‘seed’
[16:12:31.573]   - Field: ‘version’
[16:12:31.573]   - Field: ‘result’
[16:12:31.573]   - Field: ‘asynchronous’
[16:12:31.573]   - Field: ‘calls’
[16:12:31.574]   - Field: ‘globals’
[16:12:31.574]   - Field: ‘stdout’
[16:12:31.574]   - Field: ‘earlySignal’
[16:12:31.574]   - Field: ‘lazy’
[16:12:31.574]   - Field: ‘state’
[16:12:31.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.574] - Launch lazy future ...
[16:12:31.574] Packages needed by the future expression (n = 0): <none>
[16:12:31.574] Packages needed by future strategies (n = 0): <none>
[16:12:31.575] {
[16:12:31.575]     {
[16:12:31.575]         {
[16:12:31.575]             ...future.startTime <- base::Sys.time()
[16:12:31.575]             {
[16:12:31.575]                 {
[16:12:31.575]                   {
[16:12:31.575]                     {
[16:12:31.575]                       base::local({
[16:12:31.575]                         has_future <- base::requireNamespace("future", 
[16:12:31.575]                           quietly = TRUE)
[16:12:31.575]                         if (has_future) {
[16:12:31.575]                           ns <- base::getNamespace("future")
[16:12:31.575]                           version <- ns[[".package"]][["version"]]
[16:12:31.575]                           if (is.null(version)) 
[16:12:31.575]                             version <- utils::packageVersion("future")
[16:12:31.575]                         }
[16:12:31.575]                         else {
[16:12:31.575]                           version <- NULL
[16:12:31.575]                         }
[16:12:31.575]                         if (!has_future || version < "1.8.0") {
[16:12:31.575]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.575]                             "", base::R.version$version.string), 
[16:12:31.575]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.575]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.575]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.575]                               "release", "version")], collapse = " "), 
[16:12:31.575]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.575]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.575]                             info)
[16:12:31.575]                           info <- base::paste(info, collapse = "; ")
[16:12:31.575]                           if (!has_future) {
[16:12:31.575]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.575]                               info)
[16:12:31.575]                           }
[16:12:31.575]                           else {
[16:12:31.575]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.575]                               info, version)
[16:12:31.575]                           }
[16:12:31.575]                           base::stop(msg)
[16:12:31.575]                         }
[16:12:31.575]                       })
[16:12:31.575]                     }
[16:12:31.575]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.575]                     base::options(mc.cores = 1L)
[16:12:31.575]                   }
[16:12:31.575]                   options(future.plan = NULL)
[16:12:31.575]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.575]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.575]                 }
[16:12:31.575]                 ...future.workdir <- getwd()
[16:12:31.575]             }
[16:12:31.575]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.575]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.575]         }
[16:12:31.575]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.575]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.575]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.575]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.575]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.575]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.575]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.575]             base::names(...future.oldOptions))
[16:12:31.575]     }
[16:12:31.575]     if (FALSE) {
[16:12:31.575]     }
[16:12:31.575]     else {
[16:12:31.575]         if (TRUE) {
[16:12:31.575]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.575]                 open = "w")
[16:12:31.575]         }
[16:12:31.575]         else {
[16:12:31.575]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.575]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.575]         }
[16:12:31.575]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.575]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.575]             base::sink(type = "output", split = FALSE)
[16:12:31.575]             base::close(...future.stdout)
[16:12:31.575]         }, add = TRUE)
[16:12:31.575]     }
[16:12:31.575]     ...future.frame <- base::sys.nframe()
[16:12:31.575]     ...future.conditions <- base::list()
[16:12:31.575]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.575]     if (FALSE) {
[16:12:31.575]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.575]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.575]     }
[16:12:31.575]     ...future.result <- base::tryCatch({
[16:12:31.575]         base::withCallingHandlers({
[16:12:31.575]             ...future.value <- base::withVisible(base::local({
[16:12:31.575]                 ...future.makeSendCondition <- local({
[16:12:31.575]                   sendCondition <- NULL
[16:12:31.575]                   function(frame = 1L) {
[16:12:31.575]                     if (is.function(sendCondition)) 
[16:12:31.575]                       return(sendCondition)
[16:12:31.575]                     ns <- getNamespace("parallel")
[16:12:31.575]                     if (exists("sendData", mode = "function", 
[16:12:31.575]                       envir = ns)) {
[16:12:31.575]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.575]                         envir = ns)
[16:12:31.575]                       envir <- sys.frame(frame)
[16:12:31.575]                       master <- NULL
[16:12:31.575]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.575]                         !identical(envir, emptyenv())) {
[16:12:31.575]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.575]                           inherits = FALSE)) {
[16:12:31.575]                           master <- get("master", mode = "list", 
[16:12:31.575]                             envir = envir, inherits = FALSE)
[16:12:31.575]                           if (inherits(master, c("SOCKnode", 
[16:12:31.575]                             "SOCK0node"))) {
[16:12:31.575]                             sendCondition <<- function(cond) {
[16:12:31.575]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.575]                                 success = TRUE)
[16:12:31.575]                               parallel_sendData(master, data)
[16:12:31.575]                             }
[16:12:31.575]                             return(sendCondition)
[16:12:31.575]                           }
[16:12:31.575]                         }
[16:12:31.575]                         frame <- frame + 1L
[16:12:31.575]                         envir <- sys.frame(frame)
[16:12:31.575]                       }
[16:12:31.575]                     }
[16:12:31.575]                     sendCondition <<- function(cond) NULL
[16:12:31.575]                   }
[16:12:31.575]                 })
[16:12:31.575]                 withCallingHandlers({
[16:12:31.575]                   {
[16:12:31.575]                     4
[16:12:31.575]                   }
[16:12:31.575]                 }, immediateCondition = function(cond) {
[16:12:31.575]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.575]                   sendCondition(cond)
[16:12:31.575]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.575]                   {
[16:12:31.575]                     inherits <- base::inherits
[16:12:31.575]                     invokeRestart <- base::invokeRestart
[16:12:31.575]                     is.null <- base::is.null
[16:12:31.575]                     muffled <- FALSE
[16:12:31.575]                     if (inherits(cond, "message")) {
[16:12:31.575]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.575]                       if (muffled) 
[16:12:31.575]                         invokeRestart("muffleMessage")
[16:12:31.575]                     }
[16:12:31.575]                     else if (inherits(cond, "warning")) {
[16:12:31.575]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.575]                       if (muffled) 
[16:12:31.575]                         invokeRestart("muffleWarning")
[16:12:31.575]                     }
[16:12:31.575]                     else if (inherits(cond, "condition")) {
[16:12:31.575]                       if (!is.null(pattern)) {
[16:12:31.575]                         computeRestarts <- base::computeRestarts
[16:12:31.575]                         grepl <- base::grepl
[16:12:31.575]                         restarts <- computeRestarts(cond)
[16:12:31.575]                         for (restart in restarts) {
[16:12:31.575]                           name <- restart$name
[16:12:31.575]                           if (is.null(name)) 
[16:12:31.575]                             next
[16:12:31.575]                           if (!grepl(pattern, name)) 
[16:12:31.575]                             next
[16:12:31.575]                           invokeRestart(restart)
[16:12:31.575]                           muffled <- TRUE
[16:12:31.575]                           break
[16:12:31.575]                         }
[16:12:31.575]                       }
[16:12:31.575]                     }
[16:12:31.575]                     invisible(muffled)
[16:12:31.575]                   }
[16:12:31.575]                   muffleCondition(cond)
[16:12:31.575]                 })
[16:12:31.575]             }))
[16:12:31.575]             future::FutureResult(value = ...future.value$value, 
[16:12:31.575]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.575]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.575]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.575]                     ...future.globalenv.names))
[16:12:31.575]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.575]         }, condition = base::local({
[16:12:31.575]             c <- base::c
[16:12:31.575]             inherits <- base::inherits
[16:12:31.575]             invokeRestart <- base::invokeRestart
[16:12:31.575]             length <- base::length
[16:12:31.575]             list <- base::list
[16:12:31.575]             seq.int <- base::seq.int
[16:12:31.575]             signalCondition <- base::signalCondition
[16:12:31.575]             sys.calls <- base::sys.calls
[16:12:31.575]             `[[` <- base::`[[`
[16:12:31.575]             `+` <- base::`+`
[16:12:31.575]             `<<-` <- base::`<<-`
[16:12:31.575]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.575]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.575]                   3L)]
[16:12:31.575]             }
[16:12:31.575]             function(cond) {
[16:12:31.575]                 is_error <- inherits(cond, "error")
[16:12:31.575]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.575]                   NULL)
[16:12:31.575]                 if (is_error) {
[16:12:31.575]                   sessionInformation <- function() {
[16:12:31.575]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.575]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.575]                       search = base::search(), system = base::Sys.info())
[16:12:31.575]                   }
[16:12:31.575]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.575]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.575]                     cond$call), session = sessionInformation(), 
[16:12:31.575]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.575]                   signalCondition(cond)
[16:12:31.575]                 }
[16:12:31.575]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.575]                 "immediateCondition"))) {
[16:12:31.575]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.575]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.575]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.575]                   if (TRUE && !signal) {
[16:12:31.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.575]                     {
[16:12:31.575]                       inherits <- base::inherits
[16:12:31.575]                       invokeRestart <- base::invokeRestart
[16:12:31.575]                       is.null <- base::is.null
[16:12:31.575]                       muffled <- FALSE
[16:12:31.575]                       if (inherits(cond, "message")) {
[16:12:31.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.575]                         if (muffled) 
[16:12:31.575]                           invokeRestart("muffleMessage")
[16:12:31.575]                       }
[16:12:31.575]                       else if (inherits(cond, "warning")) {
[16:12:31.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.575]                         if (muffled) 
[16:12:31.575]                           invokeRestart("muffleWarning")
[16:12:31.575]                       }
[16:12:31.575]                       else if (inherits(cond, "condition")) {
[16:12:31.575]                         if (!is.null(pattern)) {
[16:12:31.575]                           computeRestarts <- base::computeRestarts
[16:12:31.575]                           grepl <- base::grepl
[16:12:31.575]                           restarts <- computeRestarts(cond)
[16:12:31.575]                           for (restart in restarts) {
[16:12:31.575]                             name <- restart$name
[16:12:31.575]                             if (is.null(name)) 
[16:12:31.575]                               next
[16:12:31.575]                             if (!grepl(pattern, name)) 
[16:12:31.575]                               next
[16:12:31.575]                             invokeRestart(restart)
[16:12:31.575]                             muffled <- TRUE
[16:12:31.575]                             break
[16:12:31.575]                           }
[16:12:31.575]                         }
[16:12:31.575]                       }
[16:12:31.575]                       invisible(muffled)
[16:12:31.575]                     }
[16:12:31.575]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.575]                   }
[16:12:31.575]                 }
[16:12:31.575]                 else {
[16:12:31.575]                   if (TRUE) {
[16:12:31.575]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.575]                     {
[16:12:31.575]                       inherits <- base::inherits
[16:12:31.575]                       invokeRestart <- base::invokeRestart
[16:12:31.575]                       is.null <- base::is.null
[16:12:31.575]                       muffled <- FALSE
[16:12:31.575]                       if (inherits(cond, "message")) {
[16:12:31.575]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.575]                         if (muffled) 
[16:12:31.575]                           invokeRestart("muffleMessage")
[16:12:31.575]                       }
[16:12:31.575]                       else if (inherits(cond, "warning")) {
[16:12:31.575]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.575]                         if (muffled) 
[16:12:31.575]                           invokeRestart("muffleWarning")
[16:12:31.575]                       }
[16:12:31.575]                       else if (inherits(cond, "condition")) {
[16:12:31.575]                         if (!is.null(pattern)) {
[16:12:31.575]                           computeRestarts <- base::computeRestarts
[16:12:31.575]                           grepl <- base::grepl
[16:12:31.575]                           restarts <- computeRestarts(cond)
[16:12:31.575]                           for (restart in restarts) {
[16:12:31.575]                             name <- restart$name
[16:12:31.575]                             if (is.null(name)) 
[16:12:31.575]                               next
[16:12:31.575]                             if (!grepl(pattern, name)) 
[16:12:31.575]                               next
[16:12:31.575]                             invokeRestart(restart)
[16:12:31.575]                             muffled <- TRUE
[16:12:31.575]                             break
[16:12:31.575]                           }
[16:12:31.575]                         }
[16:12:31.575]                       }
[16:12:31.575]                       invisible(muffled)
[16:12:31.575]                     }
[16:12:31.575]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.575]                   }
[16:12:31.575]                 }
[16:12:31.575]             }
[16:12:31.575]         }))
[16:12:31.575]     }, error = function(ex) {
[16:12:31.575]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.575]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.575]                 ...future.rng), started = ...future.startTime, 
[16:12:31.575]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.575]             version = "1.8"), class = "FutureResult")
[16:12:31.575]     }, finally = {
[16:12:31.575]         if (!identical(...future.workdir, getwd())) 
[16:12:31.575]             setwd(...future.workdir)
[16:12:31.575]         {
[16:12:31.575]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.575]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.575]             }
[16:12:31.575]             base::options(...future.oldOptions)
[16:12:31.575]             if (.Platform$OS.type == "windows") {
[16:12:31.575]                 old_names <- names(...future.oldEnvVars)
[16:12:31.575]                 envs <- base::Sys.getenv()
[16:12:31.575]                 names <- names(envs)
[16:12:31.575]                 common <- intersect(names, old_names)
[16:12:31.575]                 added <- setdiff(names, old_names)
[16:12:31.575]                 removed <- setdiff(old_names, names)
[16:12:31.575]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.575]                   envs[common]]
[16:12:31.575]                 NAMES <- toupper(changed)
[16:12:31.575]                 args <- list()
[16:12:31.575]                 for (kk in seq_along(NAMES)) {
[16:12:31.575]                   name <- changed[[kk]]
[16:12:31.575]                   NAME <- NAMES[[kk]]
[16:12:31.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.575]                     next
[16:12:31.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.575]                 }
[16:12:31.575]                 NAMES <- toupper(added)
[16:12:31.575]                 for (kk in seq_along(NAMES)) {
[16:12:31.575]                   name <- added[[kk]]
[16:12:31.575]                   NAME <- NAMES[[kk]]
[16:12:31.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.575]                     next
[16:12:31.575]                   args[[name]] <- ""
[16:12:31.575]                 }
[16:12:31.575]                 NAMES <- toupper(removed)
[16:12:31.575]                 for (kk in seq_along(NAMES)) {
[16:12:31.575]                   name <- removed[[kk]]
[16:12:31.575]                   NAME <- NAMES[[kk]]
[16:12:31.575]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.575]                     next
[16:12:31.575]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.575]                 }
[16:12:31.575]                 if (length(args) > 0) 
[16:12:31.575]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.575]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.575]             }
[16:12:31.575]             else {
[16:12:31.575]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.575]             }
[16:12:31.575]             {
[16:12:31.575]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.575]                   0L) {
[16:12:31.575]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.575]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.575]                   base::options(opts)
[16:12:31.575]                 }
[16:12:31.575]                 {
[16:12:31.575]                   {
[16:12:31.575]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.575]                     NULL
[16:12:31.575]                   }
[16:12:31.575]                   options(future.plan = NULL)
[16:12:31.575]                   if (is.na(NA_character_)) 
[16:12:31.575]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.575]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.575]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.575]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.575]                     envir = parent.frame()) 
[16:12:31.575]                   {
[16:12:31.575]                     if (is.function(workers)) 
[16:12:31.575]                       workers <- workers()
[16:12:31.575]                     workers <- structure(as.integer(workers), 
[16:12:31.575]                       class = class(workers))
[16:12:31.575]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.575]                       workers >= 1)
[16:12:31.575]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.575]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.575]                     }
[16:12:31.575]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.575]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.575]                       envir = envir)
[16:12:31.575]                     if (!future$lazy) 
[16:12:31.575]                       future <- run(future)
[16:12:31.575]                     invisible(future)
[16:12:31.575]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.575]                 }
[16:12:31.575]             }
[16:12:31.575]         }
[16:12:31.575]     })
[16:12:31.575]     if (TRUE) {
[16:12:31.575]         base::sink(type = "output", split = FALSE)
[16:12:31.575]         if (TRUE) {
[16:12:31.575]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.575]         }
[16:12:31.575]         else {
[16:12:31.575]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.575]         }
[16:12:31.575]         base::close(...future.stdout)
[16:12:31.575]         ...future.stdout <- NULL
[16:12:31.575]     }
[16:12:31.575]     ...future.result$conditions <- ...future.conditions
[16:12:31.575]     ...future.result$finished <- base::Sys.time()
[16:12:31.575]     ...future.result
[16:12:31.575] }
[16:12:31.577] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:31.588] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.588] - Validating connection of MultisessionFuture
[16:12:31.588] - received message: FutureResult
[16:12:31.589] - Received FutureResult
[16:12:31.589] - Erased future from FutureRegistry
[16:12:31.589] result() for ClusterFuture ...
[16:12:31.589] - result already collected: FutureResult
[16:12:31.589] result() for ClusterFuture ... done
[16:12:31.589] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.589] result() for ClusterFuture ...
[16:12:31.589] - result already collected: FutureResult
[16:12:31.589] result() for ClusterFuture ... done
[16:12:31.589] result() for ClusterFuture ...
[16:12:31.590] - result already collected: FutureResult
[16:12:31.590] result() for ClusterFuture ... done
[16:12:31.591] MultisessionFuture started
[16:12:31.591] - Launch lazy future ... done
[16:12:31.591] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560bb0a1cf98> 
Classes 'listenv', 'environment' <environment: 0x560baca521e8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[16:12:31.600] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.601] - Validating connection of MultisessionFuture
[16:12:31.601] - received message: FutureResult
[16:12:31.601] - Received FutureResult
[16:12:31.601] - Erased future from FutureRegistry
[16:12:31.601] result() for ClusterFuture ...
[16:12:31.601] - result already collected: FutureResult
[16:12:31.601] result() for ClusterFuture ... done
[16:12:31.601] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:31.614] resolve() on list environment ...
[16:12:31.614]  recursive: 0
[16:12:31.615]  length: 6
[16:12:31.615]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:31.615] signalConditionsASAP(numeric, pos=1) ...
[16:12:31.616] - nx: 6
[16:12:31.616] - relay: TRUE
[16:12:31.616] - stdout: TRUE
[16:12:31.616] - signal: TRUE
[16:12:31.616] - resignal: FALSE
[16:12:31.616] - force: TRUE
[16:12:31.616] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.616] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.616]  - until=2
[16:12:31.616]  - relaying element #2
[16:12:31.617] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.617] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.617] signalConditionsASAP(NULL, pos=1) ... done
[16:12:31.617]  length: 5 (resolved future 1)
[16:12:31.617] Future #2
[16:12:31.617] result() for ClusterFuture ...
[16:12:31.617] - result already collected: FutureResult
[16:12:31.617] result() for ClusterFuture ... done
[16:12:31.617] result() for ClusterFuture ...
[16:12:31.617] - result already collected: FutureResult
[16:12:31.617] result() for ClusterFuture ... done
[16:12:31.618] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:31.618] - nx: 6
[16:12:31.618] - relay: TRUE
[16:12:31.618] - stdout: TRUE
[16:12:31.618] - signal: TRUE
[16:12:31.618] - resignal: FALSE
[16:12:31.618] - force: TRUE
[16:12:31.618] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.618] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.618]  - until=2
[16:12:31.618]  - relaying element #2
[16:12:31.619] result() for ClusterFuture ...
[16:12:31.619] - result already collected: FutureResult
[16:12:31.619] result() for ClusterFuture ... done
[16:12:31.619] result() for ClusterFuture ...
[16:12:31.619] - result already collected: FutureResult
[16:12:31.619] result() for ClusterFuture ... done
[16:12:31.619] result() for ClusterFuture ...
[16:12:31.619] - result already collected: FutureResult
[16:12:31.619] result() for ClusterFuture ... done
[16:12:31.619] result() for ClusterFuture ...
[16:12:31.619] - result already collected: FutureResult
[16:12:31.620] result() for ClusterFuture ... done
[16:12:31.620] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.620] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.620] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:31.620]  length: 4 (resolved future 2)
[16:12:31.620] Future #3
[16:12:31.620] result() for ClusterFuture ...
[16:12:31.620] - result already collected: FutureResult
[16:12:31.620] result() for ClusterFuture ... done
[16:12:31.620] result() for ClusterFuture ...
[16:12:31.620] - result already collected: FutureResult
[16:12:31.621] result() for ClusterFuture ... done
[16:12:31.621] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:31.621] - nx: 6
[16:12:31.621] - relay: TRUE
[16:12:31.621] - stdout: TRUE
[16:12:31.621] - signal: TRUE
[16:12:31.621] - resignal: FALSE
[16:12:31.621] - force: TRUE
[16:12:31.621] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.621] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.621]  - until=3
[16:12:31.622]  - relaying element #3
[16:12:31.622] result() for ClusterFuture ...
[16:12:31.622] - result already collected: FutureResult
[16:12:31.622] result() for ClusterFuture ... done
[16:12:31.622] result() for ClusterFuture ...
[16:12:31.622] - result already collected: FutureResult
[16:12:31.622] result() for ClusterFuture ... done
[16:12:31.622] result() for ClusterFuture ...
[16:12:31.622] - result already collected: FutureResult
[16:12:31.622] result() for ClusterFuture ... done
[16:12:31.622] result() for ClusterFuture ...
[16:12:31.623] - result already collected: FutureResult
[16:12:31.623] result() for ClusterFuture ... done
[16:12:31.623] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.623] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.623] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:31.623]  length: 3 (resolved future 3)
[16:12:31.634] signalConditionsASAP(NULL, pos=5) ...
[16:12:31.634] - nx: 6
[16:12:31.634] - relay: TRUE
[16:12:31.634] - stdout: TRUE
[16:12:31.634] - signal: TRUE
[16:12:31.634] - resignal: FALSE
[16:12:31.634] - force: TRUE
[16:12:31.634] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.634] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.634]  - until=6
[16:12:31.635]  - relaying element #4
[16:12:31.635]  - relaying element #6
[16:12:31.635] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.635] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.635] signalConditionsASAP(NULL, pos=5) ... done
[16:12:31.635]  length: 2 (resolved future 5)
[16:12:31.635] signalConditionsASAP(numeric, pos=6) ...
[16:12:31.635] - nx: 6
[16:12:31.635] - relay: TRUE
[16:12:31.635] - stdout: TRUE
[16:12:31.636] - signal: TRUE
[16:12:31.636] - resignal: FALSE
[16:12:31.636] - force: TRUE
[16:12:31.636] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.636] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.636]  - until=6
[16:12:31.637]  - relaying element #4
[16:12:31.637] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.637] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.637] signalConditionsASAP(NULL, pos=6) ... done
[16:12:31.637]  length: 1 (resolved future 6)
[16:12:31.648] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.648] - Validating connection of MultisessionFuture
[16:12:31.648] - received message: FutureResult
[16:12:31.648] - Received FutureResult
[16:12:31.648] - Erased future from FutureRegistry
[16:12:31.649] result() for ClusterFuture ...
[16:12:31.649] - result already collected: FutureResult
[16:12:31.649] result() for ClusterFuture ... done
[16:12:31.649] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.649] Future #4
[16:12:31.649] result() for ClusterFuture ...
[16:12:31.649] - result already collected: FutureResult
[16:12:31.649] result() for ClusterFuture ... done
[16:12:31.649] result() for ClusterFuture ...
[16:12:31.649] - result already collected: FutureResult
[16:12:31.649] result() for ClusterFuture ... done
[16:12:31.650] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:31.650] - nx: 6
[16:12:31.650] - relay: TRUE
[16:12:31.650] - stdout: TRUE
[16:12:31.650] - signal: TRUE
[16:12:31.650] - resignal: FALSE
[16:12:31.650] - force: TRUE
[16:12:31.650] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.650] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.650]  - until=6
[16:12:31.651]  - relaying element #4
[16:12:31.651] result() for ClusterFuture ...
[16:12:31.651] - result already collected: FutureResult
[16:12:31.651] result() for ClusterFuture ... done
[16:12:31.651] result() for ClusterFuture ...
[16:12:31.651] - result already collected: FutureResult
[16:12:31.651] result() for ClusterFuture ... done
[16:12:31.651] result() for ClusterFuture ...
[16:12:31.651] - result already collected: FutureResult
[16:12:31.651] result() for ClusterFuture ... done
[16:12:31.651] result() for ClusterFuture ...
[16:12:31.652] - result already collected: FutureResult
[16:12:31.652] result() for ClusterFuture ... done
[16:12:31.652] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.652] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.652] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:31.652]  length: 0 (resolved future 4)
[16:12:31.652] Relaying remaining futures
[16:12:31.652] signalConditionsASAP(NULL, pos=0) ...
[16:12:31.652] - nx: 6
[16:12:31.652] - relay: TRUE
[16:12:31.652] - stdout: TRUE
[16:12:31.653] - signal: TRUE
[16:12:31.653] - resignal: FALSE
[16:12:31.653] - force: TRUE
[16:12:31.653] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.653] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:31.653] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.653] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.653] signalConditionsASAP(NULL, pos=0) ... done
[16:12:31.653] resolve() on list environment ... DONE
[16:12:31.653] result() for ClusterFuture ...
[16:12:31.654] - result already collected: FutureResult
[16:12:31.654] result() for ClusterFuture ... done
[16:12:31.654] result() for ClusterFuture ...
[16:12:31.654] - result already collected: FutureResult
[16:12:31.654] result() for ClusterFuture ... done
[16:12:31.654] result() for ClusterFuture ...
[16:12:31.654] - result already collected: FutureResult
[16:12:31.654] result() for ClusterFuture ... done
[16:12:31.654] result() for ClusterFuture ...
[16:12:31.654] - result already collected: FutureResult
[16:12:31.654] result() for ClusterFuture ... done
[16:12:31.655] result() for ClusterFuture ...
[16:12:31.655] - result already collected: FutureResult
[16:12:31.655] result() for ClusterFuture ... done
[16:12:31.655] result() for ClusterFuture ...
[16:12:31.655] - result already collected: FutureResult
[16:12:31.655] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x560bafab9e88> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[16:12:31.657] getGlobalsAndPackages() ...
[16:12:31.657] Searching for globals...
[16:12:31.657] 
[16:12:31.657] Searching for globals ... DONE
[16:12:31.657] - globals: [0] <none>
[16:12:31.658] getGlobalsAndPackages() ... DONE
[16:12:31.658] run() for ‘Future’ ...
[16:12:31.658] - state: ‘created’
[16:12:31.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.673] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.673]   - Field: ‘node’
[16:12:31.673]   - Field: ‘label’
[16:12:31.673]   - Field: ‘local’
[16:12:31.673]   - Field: ‘owner’
[16:12:31.673]   - Field: ‘envir’
[16:12:31.673]   - Field: ‘workers’
[16:12:31.673]   - Field: ‘packages’
[16:12:31.673]   - Field: ‘gc’
[16:12:31.673]   - Field: ‘conditions’
[16:12:31.674]   - Field: ‘persistent’
[16:12:31.674]   - Field: ‘expr’
[16:12:31.674]   - Field: ‘uuid’
[16:12:31.674]   - Field: ‘seed’
[16:12:31.674]   - Field: ‘version’
[16:12:31.674]   - Field: ‘result’
[16:12:31.674]   - Field: ‘asynchronous’
[16:12:31.674]   - Field: ‘calls’
[16:12:31.674]   - Field: ‘globals’
[16:12:31.674]   - Field: ‘stdout’
[16:12:31.674]   - Field: ‘earlySignal’
[16:12:31.675]   - Field: ‘lazy’
[16:12:31.675]   - Field: ‘state’
[16:12:31.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.675] - Launch lazy future ...
[16:12:31.675] Packages needed by the future expression (n = 0): <none>
[16:12:31.675] Packages needed by future strategies (n = 0): <none>
[16:12:31.676] {
[16:12:31.676]     {
[16:12:31.676]         {
[16:12:31.676]             ...future.startTime <- base::Sys.time()
[16:12:31.676]             {
[16:12:31.676]                 {
[16:12:31.676]                   {
[16:12:31.676]                     {
[16:12:31.676]                       base::local({
[16:12:31.676]                         has_future <- base::requireNamespace("future", 
[16:12:31.676]                           quietly = TRUE)
[16:12:31.676]                         if (has_future) {
[16:12:31.676]                           ns <- base::getNamespace("future")
[16:12:31.676]                           version <- ns[[".package"]][["version"]]
[16:12:31.676]                           if (is.null(version)) 
[16:12:31.676]                             version <- utils::packageVersion("future")
[16:12:31.676]                         }
[16:12:31.676]                         else {
[16:12:31.676]                           version <- NULL
[16:12:31.676]                         }
[16:12:31.676]                         if (!has_future || version < "1.8.0") {
[16:12:31.676]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.676]                             "", base::R.version$version.string), 
[16:12:31.676]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.676]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.676]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.676]                               "release", "version")], collapse = " "), 
[16:12:31.676]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.676]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.676]                             info)
[16:12:31.676]                           info <- base::paste(info, collapse = "; ")
[16:12:31.676]                           if (!has_future) {
[16:12:31.676]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.676]                               info)
[16:12:31.676]                           }
[16:12:31.676]                           else {
[16:12:31.676]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.676]                               info, version)
[16:12:31.676]                           }
[16:12:31.676]                           base::stop(msg)
[16:12:31.676]                         }
[16:12:31.676]                       })
[16:12:31.676]                     }
[16:12:31.676]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.676]                     base::options(mc.cores = 1L)
[16:12:31.676]                   }
[16:12:31.676]                   options(future.plan = NULL)
[16:12:31.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.676]                 }
[16:12:31.676]                 ...future.workdir <- getwd()
[16:12:31.676]             }
[16:12:31.676]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.676]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.676]         }
[16:12:31.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.676]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.676]             base::names(...future.oldOptions))
[16:12:31.676]     }
[16:12:31.676]     if (FALSE) {
[16:12:31.676]     }
[16:12:31.676]     else {
[16:12:31.676]         if (TRUE) {
[16:12:31.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.676]                 open = "w")
[16:12:31.676]         }
[16:12:31.676]         else {
[16:12:31.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.676]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.676]         }
[16:12:31.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.676]             base::sink(type = "output", split = FALSE)
[16:12:31.676]             base::close(...future.stdout)
[16:12:31.676]         }, add = TRUE)
[16:12:31.676]     }
[16:12:31.676]     ...future.frame <- base::sys.nframe()
[16:12:31.676]     ...future.conditions <- base::list()
[16:12:31.676]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.676]     if (FALSE) {
[16:12:31.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.676]     }
[16:12:31.676]     ...future.result <- base::tryCatch({
[16:12:31.676]         base::withCallingHandlers({
[16:12:31.676]             ...future.value <- base::withVisible(base::local({
[16:12:31.676]                 ...future.makeSendCondition <- local({
[16:12:31.676]                   sendCondition <- NULL
[16:12:31.676]                   function(frame = 1L) {
[16:12:31.676]                     if (is.function(sendCondition)) 
[16:12:31.676]                       return(sendCondition)
[16:12:31.676]                     ns <- getNamespace("parallel")
[16:12:31.676]                     if (exists("sendData", mode = "function", 
[16:12:31.676]                       envir = ns)) {
[16:12:31.676]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.676]                         envir = ns)
[16:12:31.676]                       envir <- sys.frame(frame)
[16:12:31.676]                       master <- NULL
[16:12:31.676]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.676]                         !identical(envir, emptyenv())) {
[16:12:31.676]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.676]                           inherits = FALSE)) {
[16:12:31.676]                           master <- get("master", mode = "list", 
[16:12:31.676]                             envir = envir, inherits = FALSE)
[16:12:31.676]                           if (inherits(master, c("SOCKnode", 
[16:12:31.676]                             "SOCK0node"))) {
[16:12:31.676]                             sendCondition <<- function(cond) {
[16:12:31.676]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.676]                                 success = TRUE)
[16:12:31.676]                               parallel_sendData(master, data)
[16:12:31.676]                             }
[16:12:31.676]                             return(sendCondition)
[16:12:31.676]                           }
[16:12:31.676]                         }
[16:12:31.676]                         frame <- frame + 1L
[16:12:31.676]                         envir <- sys.frame(frame)
[16:12:31.676]                       }
[16:12:31.676]                     }
[16:12:31.676]                     sendCondition <<- function(cond) NULL
[16:12:31.676]                   }
[16:12:31.676]                 })
[16:12:31.676]                 withCallingHandlers({
[16:12:31.676]                   2
[16:12:31.676]                 }, immediateCondition = function(cond) {
[16:12:31.676]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.676]                   sendCondition(cond)
[16:12:31.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.676]                   {
[16:12:31.676]                     inherits <- base::inherits
[16:12:31.676]                     invokeRestart <- base::invokeRestart
[16:12:31.676]                     is.null <- base::is.null
[16:12:31.676]                     muffled <- FALSE
[16:12:31.676]                     if (inherits(cond, "message")) {
[16:12:31.676]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.676]                       if (muffled) 
[16:12:31.676]                         invokeRestart("muffleMessage")
[16:12:31.676]                     }
[16:12:31.676]                     else if (inherits(cond, "warning")) {
[16:12:31.676]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.676]                       if (muffled) 
[16:12:31.676]                         invokeRestart("muffleWarning")
[16:12:31.676]                     }
[16:12:31.676]                     else if (inherits(cond, "condition")) {
[16:12:31.676]                       if (!is.null(pattern)) {
[16:12:31.676]                         computeRestarts <- base::computeRestarts
[16:12:31.676]                         grepl <- base::grepl
[16:12:31.676]                         restarts <- computeRestarts(cond)
[16:12:31.676]                         for (restart in restarts) {
[16:12:31.676]                           name <- restart$name
[16:12:31.676]                           if (is.null(name)) 
[16:12:31.676]                             next
[16:12:31.676]                           if (!grepl(pattern, name)) 
[16:12:31.676]                             next
[16:12:31.676]                           invokeRestart(restart)
[16:12:31.676]                           muffled <- TRUE
[16:12:31.676]                           break
[16:12:31.676]                         }
[16:12:31.676]                       }
[16:12:31.676]                     }
[16:12:31.676]                     invisible(muffled)
[16:12:31.676]                   }
[16:12:31.676]                   muffleCondition(cond)
[16:12:31.676]                 })
[16:12:31.676]             }))
[16:12:31.676]             future::FutureResult(value = ...future.value$value, 
[16:12:31.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.676]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.676]                     ...future.globalenv.names))
[16:12:31.676]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.676]         }, condition = base::local({
[16:12:31.676]             c <- base::c
[16:12:31.676]             inherits <- base::inherits
[16:12:31.676]             invokeRestart <- base::invokeRestart
[16:12:31.676]             length <- base::length
[16:12:31.676]             list <- base::list
[16:12:31.676]             seq.int <- base::seq.int
[16:12:31.676]             signalCondition <- base::signalCondition
[16:12:31.676]             sys.calls <- base::sys.calls
[16:12:31.676]             `[[` <- base::`[[`
[16:12:31.676]             `+` <- base::`+`
[16:12:31.676]             `<<-` <- base::`<<-`
[16:12:31.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.676]                   3L)]
[16:12:31.676]             }
[16:12:31.676]             function(cond) {
[16:12:31.676]                 is_error <- inherits(cond, "error")
[16:12:31.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.676]                   NULL)
[16:12:31.676]                 if (is_error) {
[16:12:31.676]                   sessionInformation <- function() {
[16:12:31.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.676]                       search = base::search(), system = base::Sys.info())
[16:12:31.676]                   }
[16:12:31.676]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.676]                     cond$call), session = sessionInformation(), 
[16:12:31.676]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.676]                   signalCondition(cond)
[16:12:31.676]                 }
[16:12:31.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.676]                 "immediateCondition"))) {
[16:12:31.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.676]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.676]                   if (TRUE && !signal) {
[16:12:31.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.676]                     {
[16:12:31.676]                       inherits <- base::inherits
[16:12:31.676]                       invokeRestart <- base::invokeRestart
[16:12:31.676]                       is.null <- base::is.null
[16:12:31.676]                       muffled <- FALSE
[16:12:31.676]                       if (inherits(cond, "message")) {
[16:12:31.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.676]                         if (muffled) 
[16:12:31.676]                           invokeRestart("muffleMessage")
[16:12:31.676]                       }
[16:12:31.676]                       else if (inherits(cond, "warning")) {
[16:12:31.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.676]                         if (muffled) 
[16:12:31.676]                           invokeRestart("muffleWarning")
[16:12:31.676]                       }
[16:12:31.676]                       else if (inherits(cond, "condition")) {
[16:12:31.676]                         if (!is.null(pattern)) {
[16:12:31.676]                           computeRestarts <- base::computeRestarts
[16:12:31.676]                           grepl <- base::grepl
[16:12:31.676]                           restarts <- computeRestarts(cond)
[16:12:31.676]                           for (restart in restarts) {
[16:12:31.676]                             name <- restart$name
[16:12:31.676]                             if (is.null(name)) 
[16:12:31.676]                               next
[16:12:31.676]                             if (!grepl(pattern, name)) 
[16:12:31.676]                               next
[16:12:31.676]                             invokeRestart(restart)
[16:12:31.676]                             muffled <- TRUE
[16:12:31.676]                             break
[16:12:31.676]                           }
[16:12:31.676]                         }
[16:12:31.676]                       }
[16:12:31.676]                       invisible(muffled)
[16:12:31.676]                     }
[16:12:31.676]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.676]                   }
[16:12:31.676]                 }
[16:12:31.676]                 else {
[16:12:31.676]                   if (TRUE) {
[16:12:31.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.676]                     {
[16:12:31.676]                       inherits <- base::inherits
[16:12:31.676]                       invokeRestart <- base::invokeRestart
[16:12:31.676]                       is.null <- base::is.null
[16:12:31.676]                       muffled <- FALSE
[16:12:31.676]                       if (inherits(cond, "message")) {
[16:12:31.676]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.676]                         if (muffled) 
[16:12:31.676]                           invokeRestart("muffleMessage")
[16:12:31.676]                       }
[16:12:31.676]                       else if (inherits(cond, "warning")) {
[16:12:31.676]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.676]                         if (muffled) 
[16:12:31.676]                           invokeRestart("muffleWarning")
[16:12:31.676]                       }
[16:12:31.676]                       else if (inherits(cond, "condition")) {
[16:12:31.676]                         if (!is.null(pattern)) {
[16:12:31.676]                           computeRestarts <- base::computeRestarts
[16:12:31.676]                           grepl <- base::grepl
[16:12:31.676]                           restarts <- computeRestarts(cond)
[16:12:31.676]                           for (restart in restarts) {
[16:12:31.676]                             name <- restart$name
[16:12:31.676]                             if (is.null(name)) 
[16:12:31.676]                               next
[16:12:31.676]                             if (!grepl(pattern, name)) 
[16:12:31.676]                               next
[16:12:31.676]                             invokeRestart(restart)
[16:12:31.676]                             muffled <- TRUE
[16:12:31.676]                             break
[16:12:31.676]                           }
[16:12:31.676]                         }
[16:12:31.676]                       }
[16:12:31.676]                       invisible(muffled)
[16:12:31.676]                     }
[16:12:31.676]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.676]                   }
[16:12:31.676]                 }
[16:12:31.676]             }
[16:12:31.676]         }))
[16:12:31.676]     }, error = function(ex) {
[16:12:31.676]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.676]                 ...future.rng), started = ...future.startTime, 
[16:12:31.676]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.676]             version = "1.8"), class = "FutureResult")
[16:12:31.676]     }, finally = {
[16:12:31.676]         if (!identical(...future.workdir, getwd())) 
[16:12:31.676]             setwd(...future.workdir)
[16:12:31.676]         {
[16:12:31.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.676]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.676]             }
[16:12:31.676]             base::options(...future.oldOptions)
[16:12:31.676]             if (.Platform$OS.type == "windows") {
[16:12:31.676]                 old_names <- names(...future.oldEnvVars)
[16:12:31.676]                 envs <- base::Sys.getenv()
[16:12:31.676]                 names <- names(envs)
[16:12:31.676]                 common <- intersect(names, old_names)
[16:12:31.676]                 added <- setdiff(names, old_names)
[16:12:31.676]                 removed <- setdiff(old_names, names)
[16:12:31.676]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.676]                   envs[common]]
[16:12:31.676]                 NAMES <- toupper(changed)
[16:12:31.676]                 args <- list()
[16:12:31.676]                 for (kk in seq_along(NAMES)) {
[16:12:31.676]                   name <- changed[[kk]]
[16:12:31.676]                   NAME <- NAMES[[kk]]
[16:12:31.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.676]                     next
[16:12:31.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.676]                 }
[16:12:31.676]                 NAMES <- toupper(added)
[16:12:31.676]                 for (kk in seq_along(NAMES)) {
[16:12:31.676]                   name <- added[[kk]]
[16:12:31.676]                   NAME <- NAMES[[kk]]
[16:12:31.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.676]                     next
[16:12:31.676]                   args[[name]] <- ""
[16:12:31.676]                 }
[16:12:31.676]                 NAMES <- toupper(removed)
[16:12:31.676]                 for (kk in seq_along(NAMES)) {
[16:12:31.676]                   name <- removed[[kk]]
[16:12:31.676]                   NAME <- NAMES[[kk]]
[16:12:31.676]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.676]                     next
[16:12:31.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.676]                 }
[16:12:31.676]                 if (length(args) > 0) 
[16:12:31.676]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.676]             }
[16:12:31.676]             else {
[16:12:31.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.676]             }
[16:12:31.676]             {
[16:12:31.676]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.676]                   0L) {
[16:12:31.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.676]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.676]                   base::options(opts)
[16:12:31.676]                 }
[16:12:31.676]                 {
[16:12:31.676]                   {
[16:12:31.676]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.676]                     NULL
[16:12:31.676]                   }
[16:12:31.676]                   options(future.plan = NULL)
[16:12:31.676]                   if (is.na(NA_character_)) 
[16:12:31.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.676]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.676]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.676]                     envir = parent.frame()) 
[16:12:31.676]                   {
[16:12:31.676]                     if (is.function(workers)) 
[16:12:31.676]                       workers <- workers()
[16:12:31.676]                     workers <- structure(as.integer(workers), 
[16:12:31.676]                       class = class(workers))
[16:12:31.676]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.676]                       workers >= 1)
[16:12:31.676]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.676]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.676]                     }
[16:12:31.676]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.676]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.676]                       envir = envir)
[16:12:31.676]                     if (!future$lazy) 
[16:12:31.676]                       future <- run(future)
[16:12:31.676]                     invisible(future)
[16:12:31.676]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.676]                 }
[16:12:31.676]             }
[16:12:31.676]         }
[16:12:31.676]     })
[16:12:31.676]     if (TRUE) {
[16:12:31.676]         base::sink(type = "output", split = FALSE)
[16:12:31.676]         if (TRUE) {
[16:12:31.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.676]         }
[16:12:31.676]         else {
[16:12:31.676]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.676]         }
[16:12:31.676]         base::close(...future.stdout)
[16:12:31.676]         ...future.stdout <- NULL
[16:12:31.676]     }
[16:12:31.676]     ...future.result$conditions <- ...future.conditions
[16:12:31.676]     ...future.result$finished <- base::Sys.time()
[16:12:31.676]     ...future.result
[16:12:31.676] }
[16:12:31.679] MultisessionFuture started
[16:12:31.679] - Launch lazy future ... done
[16:12:31.679] run() for ‘MultisessionFuture’ ... done
[16:12:31.679] getGlobalsAndPackages() ...
[16:12:31.679] Searching for globals...
[16:12:31.680] 
[16:12:31.680] Searching for globals ... DONE
[16:12:31.680] - globals: [0] <none>
[16:12:31.680] getGlobalsAndPackages() ... DONE
[16:12:31.680] run() for ‘Future’ ...
[16:12:31.680] - state: ‘created’
[16:12:31.681] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.698] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.698]   - Field: ‘node’
[16:12:31.699]   - Field: ‘label’
[16:12:31.699]   - Field: ‘local’
[16:12:31.699]   - Field: ‘owner’
[16:12:31.699]   - Field: ‘envir’
[16:12:31.699]   - Field: ‘workers’
[16:12:31.699]   - Field: ‘packages’
[16:12:31.699]   - Field: ‘gc’
[16:12:31.699]   - Field: ‘conditions’
[16:12:31.699]   - Field: ‘persistent’
[16:12:31.699]   - Field: ‘expr’
[16:12:31.699]   - Field: ‘uuid’
[16:12:31.700]   - Field: ‘seed’
[16:12:31.700]   - Field: ‘version’
[16:12:31.700]   - Field: ‘result’
[16:12:31.700]   - Field: ‘asynchronous’
[16:12:31.700]   - Field: ‘calls’
[16:12:31.700]   - Field: ‘globals’
[16:12:31.700]   - Field: ‘stdout’
[16:12:31.700]   - Field: ‘earlySignal’
[16:12:31.700]   - Field: ‘lazy’
[16:12:31.700]   - Field: ‘state’
[16:12:31.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.701] - Launch lazy future ...
[16:12:31.701] Packages needed by the future expression (n = 0): <none>
[16:12:31.701] Packages needed by future strategies (n = 0): <none>
[16:12:31.701] {
[16:12:31.701]     {
[16:12:31.701]         {
[16:12:31.701]             ...future.startTime <- base::Sys.time()
[16:12:31.701]             {
[16:12:31.701]                 {
[16:12:31.701]                   {
[16:12:31.701]                     {
[16:12:31.701]                       base::local({
[16:12:31.701]                         has_future <- base::requireNamespace("future", 
[16:12:31.701]                           quietly = TRUE)
[16:12:31.701]                         if (has_future) {
[16:12:31.701]                           ns <- base::getNamespace("future")
[16:12:31.701]                           version <- ns[[".package"]][["version"]]
[16:12:31.701]                           if (is.null(version)) 
[16:12:31.701]                             version <- utils::packageVersion("future")
[16:12:31.701]                         }
[16:12:31.701]                         else {
[16:12:31.701]                           version <- NULL
[16:12:31.701]                         }
[16:12:31.701]                         if (!has_future || version < "1.8.0") {
[16:12:31.701]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.701]                             "", base::R.version$version.string), 
[16:12:31.701]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.701]                               "release", "version")], collapse = " "), 
[16:12:31.701]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.701]                             info)
[16:12:31.701]                           info <- base::paste(info, collapse = "; ")
[16:12:31.701]                           if (!has_future) {
[16:12:31.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.701]                               info)
[16:12:31.701]                           }
[16:12:31.701]                           else {
[16:12:31.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.701]                               info, version)
[16:12:31.701]                           }
[16:12:31.701]                           base::stop(msg)
[16:12:31.701]                         }
[16:12:31.701]                       })
[16:12:31.701]                     }
[16:12:31.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.701]                     base::options(mc.cores = 1L)
[16:12:31.701]                   }
[16:12:31.701]                   options(future.plan = NULL)
[16:12:31.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.701]                 }
[16:12:31.701]                 ...future.workdir <- getwd()
[16:12:31.701]             }
[16:12:31.701]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.701]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.701]         }
[16:12:31.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.701]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.701]             base::names(...future.oldOptions))
[16:12:31.701]     }
[16:12:31.701]     if (FALSE) {
[16:12:31.701]     }
[16:12:31.701]     else {
[16:12:31.701]         if (TRUE) {
[16:12:31.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.701]                 open = "w")
[16:12:31.701]         }
[16:12:31.701]         else {
[16:12:31.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.701]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.701]         }
[16:12:31.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.701]             base::sink(type = "output", split = FALSE)
[16:12:31.701]             base::close(...future.stdout)
[16:12:31.701]         }, add = TRUE)
[16:12:31.701]     }
[16:12:31.701]     ...future.frame <- base::sys.nframe()
[16:12:31.701]     ...future.conditions <- base::list()
[16:12:31.701]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.701]     if (FALSE) {
[16:12:31.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.701]     }
[16:12:31.701]     ...future.result <- base::tryCatch({
[16:12:31.701]         base::withCallingHandlers({
[16:12:31.701]             ...future.value <- base::withVisible(base::local({
[16:12:31.701]                 ...future.makeSendCondition <- local({
[16:12:31.701]                   sendCondition <- NULL
[16:12:31.701]                   function(frame = 1L) {
[16:12:31.701]                     if (is.function(sendCondition)) 
[16:12:31.701]                       return(sendCondition)
[16:12:31.701]                     ns <- getNamespace("parallel")
[16:12:31.701]                     if (exists("sendData", mode = "function", 
[16:12:31.701]                       envir = ns)) {
[16:12:31.701]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.701]                         envir = ns)
[16:12:31.701]                       envir <- sys.frame(frame)
[16:12:31.701]                       master <- NULL
[16:12:31.701]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.701]                         !identical(envir, emptyenv())) {
[16:12:31.701]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.701]                           inherits = FALSE)) {
[16:12:31.701]                           master <- get("master", mode = "list", 
[16:12:31.701]                             envir = envir, inherits = FALSE)
[16:12:31.701]                           if (inherits(master, c("SOCKnode", 
[16:12:31.701]                             "SOCK0node"))) {
[16:12:31.701]                             sendCondition <<- function(cond) {
[16:12:31.701]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.701]                                 success = TRUE)
[16:12:31.701]                               parallel_sendData(master, data)
[16:12:31.701]                             }
[16:12:31.701]                             return(sendCondition)
[16:12:31.701]                           }
[16:12:31.701]                         }
[16:12:31.701]                         frame <- frame + 1L
[16:12:31.701]                         envir <- sys.frame(frame)
[16:12:31.701]                       }
[16:12:31.701]                     }
[16:12:31.701]                     sendCondition <<- function(cond) NULL
[16:12:31.701]                   }
[16:12:31.701]                 })
[16:12:31.701]                 withCallingHandlers({
[16:12:31.701]                   NULL
[16:12:31.701]                 }, immediateCondition = function(cond) {
[16:12:31.701]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.701]                   sendCondition(cond)
[16:12:31.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.701]                   {
[16:12:31.701]                     inherits <- base::inherits
[16:12:31.701]                     invokeRestart <- base::invokeRestart
[16:12:31.701]                     is.null <- base::is.null
[16:12:31.701]                     muffled <- FALSE
[16:12:31.701]                     if (inherits(cond, "message")) {
[16:12:31.701]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.701]                       if (muffled) 
[16:12:31.701]                         invokeRestart("muffleMessage")
[16:12:31.701]                     }
[16:12:31.701]                     else if (inherits(cond, "warning")) {
[16:12:31.701]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.701]                       if (muffled) 
[16:12:31.701]                         invokeRestart("muffleWarning")
[16:12:31.701]                     }
[16:12:31.701]                     else if (inherits(cond, "condition")) {
[16:12:31.701]                       if (!is.null(pattern)) {
[16:12:31.701]                         computeRestarts <- base::computeRestarts
[16:12:31.701]                         grepl <- base::grepl
[16:12:31.701]                         restarts <- computeRestarts(cond)
[16:12:31.701]                         for (restart in restarts) {
[16:12:31.701]                           name <- restart$name
[16:12:31.701]                           if (is.null(name)) 
[16:12:31.701]                             next
[16:12:31.701]                           if (!grepl(pattern, name)) 
[16:12:31.701]                             next
[16:12:31.701]                           invokeRestart(restart)
[16:12:31.701]                           muffled <- TRUE
[16:12:31.701]                           break
[16:12:31.701]                         }
[16:12:31.701]                       }
[16:12:31.701]                     }
[16:12:31.701]                     invisible(muffled)
[16:12:31.701]                   }
[16:12:31.701]                   muffleCondition(cond)
[16:12:31.701]                 })
[16:12:31.701]             }))
[16:12:31.701]             future::FutureResult(value = ...future.value$value, 
[16:12:31.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.701]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.701]                     ...future.globalenv.names))
[16:12:31.701]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.701]         }, condition = base::local({
[16:12:31.701]             c <- base::c
[16:12:31.701]             inherits <- base::inherits
[16:12:31.701]             invokeRestart <- base::invokeRestart
[16:12:31.701]             length <- base::length
[16:12:31.701]             list <- base::list
[16:12:31.701]             seq.int <- base::seq.int
[16:12:31.701]             signalCondition <- base::signalCondition
[16:12:31.701]             sys.calls <- base::sys.calls
[16:12:31.701]             `[[` <- base::`[[`
[16:12:31.701]             `+` <- base::`+`
[16:12:31.701]             `<<-` <- base::`<<-`
[16:12:31.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.701]                   3L)]
[16:12:31.701]             }
[16:12:31.701]             function(cond) {
[16:12:31.701]                 is_error <- inherits(cond, "error")
[16:12:31.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.701]                   NULL)
[16:12:31.701]                 if (is_error) {
[16:12:31.701]                   sessionInformation <- function() {
[16:12:31.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.701]                       search = base::search(), system = base::Sys.info())
[16:12:31.701]                   }
[16:12:31.701]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.701]                     cond$call), session = sessionInformation(), 
[16:12:31.701]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.701]                   signalCondition(cond)
[16:12:31.701]                 }
[16:12:31.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.701]                 "immediateCondition"))) {
[16:12:31.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.701]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.701]                   if (TRUE && !signal) {
[16:12:31.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.701]                     {
[16:12:31.701]                       inherits <- base::inherits
[16:12:31.701]                       invokeRestart <- base::invokeRestart
[16:12:31.701]                       is.null <- base::is.null
[16:12:31.701]                       muffled <- FALSE
[16:12:31.701]                       if (inherits(cond, "message")) {
[16:12:31.701]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.701]                         if (muffled) 
[16:12:31.701]                           invokeRestart("muffleMessage")
[16:12:31.701]                       }
[16:12:31.701]                       else if (inherits(cond, "warning")) {
[16:12:31.701]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.701]                         if (muffled) 
[16:12:31.701]                           invokeRestart("muffleWarning")
[16:12:31.701]                       }
[16:12:31.701]                       else if (inherits(cond, "condition")) {
[16:12:31.701]                         if (!is.null(pattern)) {
[16:12:31.701]                           computeRestarts <- base::computeRestarts
[16:12:31.701]                           grepl <- base::grepl
[16:12:31.701]                           restarts <- computeRestarts(cond)
[16:12:31.701]                           for (restart in restarts) {
[16:12:31.701]                             name <- restart$name
[16:12:31.701]                             if (is.null(name)) 
[16:12:31.701]                               next
[16:12:31.701]                             if (!grepl(pattern, name)) 
[16:12:31.701]                               next
[16:12:31.701]                             invokeRestart(restart)
[16:12:31.701]                             muffled <- TRUE
[16:12:31.701]                             break
[16:12:31.701]                           }
[16:12:31.701]                         }
[16:12:31.701]                       }
[16:12:31.701]                       invisible(muffled)
[16:12:31.701]                     }
[16:12:31.701]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.701]                   }
[16:12:31.701]                 }
[16:12:31.701]                 else {
[16:12:31.701]                   if (TRUE) {
[16:12:31.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.701]                     {
[16:12:31.701]                       inherits <- base::inherits
[16:12:31.701]                       invokeRestart <- base::invokeRestart
[16:12:31.701]                       is.null <- base::is.null
[16:12:31.701]                       muffled <- FALSE
[16:12:31.701]                       if (inherits(cond, "message")) {
[16:12:31.701]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.701]                         if (muffled) 
[16:12:31.701]                           invokeRestart("muffleMessage")
[16:12:31.701]                       }
[16:12:31.701]                       else if (inherits(cond, "warning")) {
[16:12:31.701]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.701]                         if (muffled) 
[16:12:31.701]                           invokeRestart("muffleWarning")
[16:12:31.701]                       }
[16:12:31.701]                       else if (inherits(cond, "condition")) {
[16:12:31.701]                         if (!is.null(pattern)) {
[16:12:31.701]                           computeRestarts <- base::computeRestarts
[16:12:31.701]                           grepl <- base::grepl
[16:12:31.701]                           restarts <- computeRestarts(cond)
[16:12:31.701]                           for (restart in restarts) {
[16:12:31.701]                             name <- restart$name
[16:12:31.701]                             if (is.null(name)) 
[16:12:31.701]                               next
[16:12:31.701]                             if (!grepl(pattern, name)) 
[16:12:31.701]                               next
[16:12:31.701]                             invokeRestart(restart)
[16:12:31.701]                             muffled <- TRUE
[16:12:31.701]                             break
[16:12:31.701]                           }
[16:12:31.701]                         }
[16:12:31.701]                       }
[16:12:31.701]                       invisible(muffled)
[16:12:31.701]                     }
[16:12:31.701]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.701]                   }
[16:12:31.701]                 }
[16:12:31.701]             }
[16:12:31.701]         }))
[16:12:31.701]     }, error = function(ex) {
[16:12:31.701]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.701]                 ...future.rng), started = ...future.startTime, 
[16:12:31.701]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.701]             version = "1.8"), class = "FutureResult")
[16:12:31.701]     }, finally = {
[16:12:31.701]         if (!identical(...future.workdir, getwd())) 
[16:12:31.701]             setwd(...future.workdir)
[16:12:31.701]         {
[16:12:31.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.701]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.701]             }
[16:12:31.701]             base::options(...future.oldOptions)
[16:12:31.701]             if (.Platform$OS.type == "windows") {
[16:12:31.701]                 old_names <- names(...future.oldEnvVars)
[16:12:31.701]                 envs <- base::Sys.getenv()
[16:12:31.701]                 names <- names(envs)
[16:12:31.701]                 common <- intersect(names, old_names)
[16:12:31.701]                 added <- setdiff(names, old_names)
[16:12:31.701]                 removed <- setdiff(old_names, names)
[16:12:31.701]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.701]                   envs[common]]
[16:12:31.701]                 NAMES <- toupper(changed)
[16:12:31.701]                 args <- list()
[16:12:31.701]                 for (kk in seq_along(NAMES)) {
[16:12:31.701]                   name <- changed[[kk]]
[16:12:31.701]                   NAME <- NAMES[[kk]]
[16:12:31.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.701]                     next
[16:12:31.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.701]                 }
[16:12:31.701]                 NAMES <- toupper(added)
[16:12:31.701]                 for (kk in seq_along(NAMES)) {
[16:12:31.701]                   name <- added[[kk]]
[16:12:31.701]                   NAME <- NAMES[[kk]]
[16:12:31.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.701]                     next
[16:12:31.701]                   args[[name]] <- ""
[16:12:31.701]                 }
[16:12:31.701]                 NAMES <- toupper(removed)
[16:12:31.701]                 for (kk in seq_along(NAMES)) {
[16:12:31.701]                   name <- removed[[kk]]
[16:12:31.701]                   NAME <- NAMES[[kk]]
[16:12:31.701]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.701]                     next
[16:12:31.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.701]                 }
[16:12:31.701]                 if (length(args) > 0) 
[16:12:31.701]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.701]             }
[16:12:31.701]             else {
[16:12:31.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.701]             }
[16:12:31.701]             {
[16:12:31.701]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.701]                   0L) {
[16:12:31.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.701]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.701]                   base::options(opts)
[16:12:31.701]                 }
[16:12:31.701]                 {
[16:12:31.701]                   {
[16:12:31.701]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.701]                     NULL
[16:12:31.701]                   }
[16:12:31.701]                   options(future.plan = NULL)
[16:12:31.701]                   if (is.na(NA_character_)) 
[16:12:31.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.701]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.701]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.701]                     envir = parent.frame()) 
[16:12:31.701]                   {
[16:12:31.701]                     if (is.function(workers)) 
[16:12:31.701]                       workers <- workers()
[16:12:31.701]                     workers <- structure(as.integer(workers), 
[16:12:31.701]                       class = class(workers))
[16:12:31.701]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.701]                       workers >= 1)
[16:12:31.701]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.701]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.701]                     }
[16:12:31.701]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.701]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.701]                       envir = envir)
[16:12:31.701]                     if (!future$lazy) 
[16:12:31.701]                       future <- run(future)
[16:12:31.701]                     invisible(future)
[16:12:31.701]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.701]                 }
[16:12:31.701]             }
[16:12:31.701]         }
[16:12:31.701]     })
[16:12:31.701]     if (TRUE) {
[16:12:31.701]         base::sink(type = "output", split = FALSE)
[16:12:31.701]         if (TRUE) {
[16:12:31.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.701]         }
[16:12:31.701]         else {
[16:12:31.701]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.701]         }
[16:12:31.701]         base::close(...future.stdout)
[16:12:31.701]         ...future.stdout <- NULL
[16:12:31.701]     }
[16:12:31.701]     ...future.result$conditions <- ...future.conditions
[16:12:31.701]     ...future.result$finished <- base::Sys.time()
[16:12:31.701]     ...future.result
[16:12:31.701] }
[16:12:31.705] MultisessionFuture started
[16:12:31.705] - Launch lazy future ... done
[16:12:31.705] run() for ‘MultisessionFuture’ ... done
[16:12:31.705] getGlobalsAndPackages() ...
[16:12:31.705] Searching for globals...
[16:12:31.706] - globals found: [1] ‘{’
[16:12:31.706] Searching for globals ... DONE
[16:12:31.706] Resolving globals: FALSE
[16:12:31.707] 
[16:12:31.707] 
[16:12:31.707] getGlobalsAndPackages() ... DONE
[16:12:31.707] run() for ‘Future’ ...
[16:12:31.707] - state: ‘created’
[16:12:31.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.722] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.722]   - Field: ‘node’
[16:12:31.722]   - Field: ‘label’
[16:12:31.722]   - Field: ‘local’
[16:12:31.723]   - Field: ‘owner’
[16:12:31.723]   - Field: ‘envir’
[16:12:31.723]   - Field: ‘workers’
[16:12:31.723]   - Field: ‘packages’
[16:12:31.723]   - Field: ‘gc’
[16:12:31.723]   - Field: ‘conditions’
[16:12:31.723]   - Field: ‘persistent’
[16:12:31.723]   - Field: ‘expr’
[16:12:31.723]   - Field: ‘uuid’
[16:12:31.723]   - Field: ‘seed’
[16:12:31.724]   - Field: ‘version’
[16:12:31.724]   - Field: ‘result’
[16:12:31.724]   - Field: ‘asynchronous’
[16:12:31.724]   - Field: ‘calls’
[16:12:31.724]   - Field: ‘globals’
[16:12:31.724]   - Field: ‘stdout’
[16:12:31.724]   - Field: ‘earlySignal’
[16:12:31.725]   - Field: ‘lazy’
[16:12:31.725]   - Field: ‘state’
[16:12:31.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.725] - Launch lazy future ...
[16:12:31.725] Packages needed by the future expression (n = 0): <none>
[16:12:31.726] Packages needed by future strategies (n = 0): <none>
[16:12:31.726] {
[16:12:31.726]     {
[16:12:31.726]         {
[16:12:31.726]             ...future.startTime <- base::Sys.time()
[16:12:31.726]             {
[16:12:31.726]                 {
[16:12:31.726]                   {
[16:12:31.726]                     {
[16:12:31.726]                       base::local({
[16:12:31.726]                         has_future <- base::requireNamespace("future", 
[16:12:31.726]                           quietly = TRUE)
[16:12:31.726]                         if (has_future) {
[16:12:31.726]                           ns <- base::getNamespace("future")
[16:12:31.726]                           version <- ns[[".package"]][["version"]]
[16:12:31.726]                           if (is.null(version)) 
[16:12:31.726]                             version <- utils::packageVersion("future")
[16:12:31.726]                         }
[16:12:31.726]                         else {
[16:12:31.726]                           version <- NULL
[16:12:31.726]                         }
[16:12:31.726]                         if (!has_future || version < "1.8.0") {
[16:12:31.726]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.726]                             "", base::R.version$version.string), 
[16:12:31.726]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.726]                               "release", "version")], collapse = " "), 
[16:12:31.726]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.726]                             info)
[16:12:31.726]                           info <- base::paste(info, collapse = "; ")
[16:12:31.726]                           if (!has_future) {
[16:12:31.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.726]                               info)
[16:12:31.726]                           }
[16:12:31.726]                           else {
[16:12:31.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.726]                               info, version)
[16:12:31.726]                           }
[16:12:31.726]                           base::stop(msg)
[16:12:31.726]                         }
[16:12:31.726]                       })
[16:12:31.726]                     }
[16:12:31.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.726]                     base::options(mc.cores = 1L)
[16:12:31.726]                   }
[16:12:31.726]                   options(future.plan = NULL)
[16:12:31.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.726]                 }
[16:12:31.726]                 ...future.workdir <- getwd()
[16:12:31.726]             }
[16:12:31.726]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.726]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.726]         }
[16:12:31.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.726]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.726]             base::names(...future.oldOptions))
[16:12:31.726]     }
[16:12:31.726]     if (FALSE) {
[16:12:31.726]     }
[16:12:31.726]     else {
[16:12:31.726]         if (TRUE) {
[16:12:31.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.726]                 open = "w")
[16:12:31.726]         }
[16:12:31.726]         else {
[16:12:31.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.726]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.726]         }
[16:12:31.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.726]             base::sink(type = "output", split = FALSE)
[16:12:31.726]             base::close(...future.stdout)
[16:12:31.726]         }, add = TRUE)
[16:12:31.726]     }
[16:12:31.726]     ...future.frame <- base::sys.nframe()
[16:12:31.726]     ...future.conditions <- base::list()
[16:12:31.726]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.726]     if (FALSE) {
[16:12:31.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.726]     }
[16:12:31.726]     ...future.result <- base::tryCatch({
[16:12:31.726]         base::withCallingHandlers({
[16:12:31.726]             ...future.value <- base::withVisible(base::local({
[16:12:31.726]                 ...future.makeSendCondition <- local({
[16:12:31.726]                   sendCondition <- NULL
[16:12:31.726]                   function(frame = 1L) {
[16:12:31.726]                     if (is.function(sendCondition)) 
[16:12:31.726]                       return(sendCondition)
[16:12:31.726]                     ns <- getNamespace("parallel")
[16:12:31.726]                     if (exists("sendData", mode = "function", 
[16:12:31.726]                       envir = ns)) {
[16:12:31.726]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.726]                         envir = ns)
[16:12:31.726]                       envir <- sys.frame(frame)
[16:12:31.726]                       master <- NULL
[16:12:31.726]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.726]                         !identical(envir, emptyenv())) {
[16:12:31.726]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.726]                           inherits = FALSE)) {
[16:12:31.726]                           master <- get("master", mode = "list", 
[16:12:31.726]                             envir = envir, inherits = FALSE)
[16:12:31.726]                           if (inherits(master, c("SOCKnode", 
[16:12:31.726]                             "SOCK0node"))) {
[16:12:31.726]                             sendCondition <<- function(cond) {
[16:12:31.726]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.726]                                 success = TRUE)
[16:12:31.726]                               parallel_sendData(master, data)
[16:12:31.726]                             }
[16:12:31.726]                             return(sendCondition)
[16:12:31.726]                           }
[16:12:31.726]                         }
[16:12:31.726]                         frame <- frame + 1L
[16:12:31.726]                         envir <- sys.frame(frame)
[16:12:31.726]                       }
[16:12:31.726]                     }
[16:12:31.726]                     sendCondition <<- function(cond) NULL
[16:12:31.726]                   }
[16:12:31.726]                 })
[16:12:31.726]                 withCallingHandlers({
[16:12:31.726]                   {
[16:12:31.726]                     4
[16:12:31.726]                   }
[16:12:31.726]                 }, immediateCondition = function(cond) {
[16:12:31.726]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.726]                   sendCondition(cond)
[16:12:31.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.726]                   {
[16:12:31.726]                     inherits <- base::inherits
[16:12:31.726]                     invokeRestart <- base::invokeRestart
[16:12:31.726]                     is.null <- base::is.null
[16:12:31.726]                     muffled <- FALSE
[16:12:31.726]                     if (inherits(cond, "message")) {
[16:12:31.726]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.726]                       if (muffled) 
[16:12:31.726]                         invokeRestart("muffleMessage")
[16:12:31.726]                     }
[16:12:31.726]                     else if (inherits(cond, "warning")) {
[16:12:31.726]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.726]                       if (muffled) 
[16:12:31.726]                         invokeRestart("muffleWarning")
[16:12:31.726]                     }
[16:12:31.726]                     else if (inherits(cond, "condition")) {
[16:12:31.726]                       if (!is.null(pattern)) {
[16:12:31.726]                         computeRestarts <- base::computeRestarts
[16:12:31.726]                         grepl <- base::grepl
[16:12:31.726]                         restarts <- computeRestarts(cond)
[16:12:31.726]                         for (restart in restarts) {
[16:12:31.726]                           name <- restart$name
[16:12:31.726]                           if (is.null(name)) 
[16:12:31.726]                             next
[16:12:31.726]                           if (!grepl(pattern, name)) 
[16:12:31.726]                             next
[16:12:31.726]                           invokeRestart(restart)
[16:12:31.726]                           muffled <- TRUE
[16:12:31.726]                           break
[16:12:31.726]                         }
[16:12:31.726]                       }
[16:12:31.726]                     }
[16:12:31.726]                     invisible(muffled)
[16:12:31.726]                   }
[16:12:31.726]                   muffleCondition(cond)
[16:12:31.726]                 })
[16:12:31.726]             }))
[16:12:31.726]             future::FutureResult(value = ...future.value$value, 
[16:12:31.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.726]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.726]                     ...future.globalenv.names))
[16:12:31.726]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.726]         }, condition = base::local({
[16:12:31.726]             c <- base::c
[16:12:31.726]             inherits <- base::inherits
[16:12:31.726]             invokeRestart <- base::invokeRestart
[16:12:31.726]             length <- base::length
[16:12:31.726]             list <- base::list
[16:12:31.726]             seq.int <- base::seq.int
[16:12:31.726]             signalCondition <- base::signalCondition
[16:12:31.726]             sys.calls <- base::sys.calls
[16:12:31.726]             `[[` <- base::`[[`
[16:12:31.726]             `+` <- base::`+`
[16:12:31.726]             `<<-` <- base::`<<-`
[16:12:31.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.726]                   3L)]
[16:12:31.726]             }
[16:12:31.726]             function(cond) {
[16:12:31.726]                 is_error <- inherits(cond, "error")
[16:12:31.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.726]                   NULL)
[16:12:31.726]                 if (is_error) {
[16:12:31.726]                   sessionInformation <- function() {
[16:12:31.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.726]                       search = base::search(), system = base::Sys.info())
[16:12:31.726]                   }
[16:12:31.726]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.726]                     cond$call), session = sessionInformation(), 
[16:12:31.726]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.726]                   signalCondition(cond)
[16:12:31.726]                 }
[16:12:31.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.726]                 "immediateCondition"))) {
[16:12:31.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.726]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.726]                   if (TRUE && !signal) {
[16:12:31.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.726]                     {
[16:12:31.726]                       inherits <- base::inherits
[16:12:31.726]                       invokeRestart <- base::invokeRestart
[16:12:31.726]                       is.null <- base::is.null
[16:12:31.726]                       muffled <- FALSE
[16:12:31.726]                       if (inherits(cond, "message")) {
[16:12:31.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.726]                         if (muffled) 
[16:12:31.726]                           invokeRestart("muffleMessage")
[16:12:31.726]                       }
[16:12:31.726]                       else if (inherits(cond, "warning")) {
[16:12:31.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.726]                         if (muffled) 
[16:12:31.726]                           invokeRestart("muffleWarning")
[16:12:31.726]                       }
[16:12:31.726]                       else if (inherits(cond, "condition")) {
[16:12:31.726]                         if (!is.null(pattern)) {
[16:12:31.726]                           computeRestarts <- base::computeRestarts
[16:12:31.726]                           grepl <- base::grepl
[16:12:31.726]                           restarts <- computeRestarts(cond)
[16:12:31.726]                           for (restart in restarts) {
[16:12:31.726]                             name <- restart$name
[16:12:31.726]                             if (is.null(name)) 
[16:12:31.726]                               next
[16:12:31.726]                             if (!grepl(pattern, name)) 
[16:12:31.726]                               next
[16:12:31.726]                             invokeRestart(restart)
[16:12:31.726]                             muffled <- TRUE
[16:12:31.726]                             break
[16:12:31.726]                           }
[16:12:31.726]                         }
[16:12:31.726]                       }
[16:12:31.726]                       invisible(muffled)
[16:12:31.726]                     }
[16:12:31.726]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.726]                   }
[16:12:31.726]                 }
[16:12:31.726]                 else {
[16:12:31.726]                   if (TRUE) {
[16:12:31.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.726]                     {
[16:12:31.726]                       inherits <- base::inherits
[16:12:31.726]                       invokeRestart <- base::invokeRestart
[16:12:31.726]                       is.null <- base::is.null
[16:12:31.726]                       muffled <- FALSE
[16:12:31.726]                       if (inherits(cond, "message")) {
[16:12:31.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.726]                         if (muffled) 
[16:12:31.726]                           invokeRestart("muffleMessage")
[16:12:31.726]                       }
[16:12:31.726]                       else if (inherits(cond, "warning")) {
[16:12:31.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.726]                         if (muffled) 
[16:12:31.726]                           invokeRestart("muffleWarning")
[16:12:31.726]                       }
[16:12:31.726]                       else if (inherits(cond, "condition")) {
[16:12:31.726]                         if (!is.null(pattern)) {
[16:12:31.726]                           computeRestarts <- base::computeRestarts
[16:12:31.726]                           grepl <- base::grepl
[16:12:31.726]                           restarts <- computeRestarts(cond)
[16:12:31.726]                           for (restart in restarts) {
[16:12:31.726]                             name <- restart$name
[16:12:31.726]                             if (is.null(name)) 
[16:12:31.726]                               next
[16:12:31.726]                             if (!grepl(pattern, name)) 
[16:12:31.726]                               next
[16:12:31.726]                             invokeRestart(restart)
[16:12:31.726]                             muffled <- TRUE
[16:12:31.726]                             break
[16:12:31.726]                           }
[16:12:31.726]                         }
[16:12:31.726]                       }
[16:12:31.726]                       invisible(muffled)
[16:12:31.726]                     }
[16:12:31.726]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.726]                   }
[16:12:31.726]                 }
[16:12:31.726]             }
[16:12:31.726]         }))
[16:12:31.726]     }, error = function(ex) {
[16:12:31.726]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.726]                 ...future.rng), started = ...future.startTime, 
[16:12:31.726]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.726]             version = "1.8"), class = "FutureResult")
[16:12:31.726]     }, finally = {
[16:12:31.726]         if (!identical(...future.workdir, getwd())) 
[16:12:31.726]             setwd(...future.workdir)
[16:12:31.726]         {
[16:12:31.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.726]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.726]             }
[16:12:31.726]             base::options(...future.oldOptions)
[16:12:31.726]             if (.Platform$OS.type == "windows") {
[16:12:31.726]                 old_names <- names(...future.oldEnvVars)
[16:12:31.726]                 envs <- base::Sys.getenv()
[16:12:31.726]                 names <- names(envs)
[16:12:31.726]                 common <- intersect(names, old_names)
[16:12:31.726]                 added <- setdiff(names, old_names)
[16:12:31.726]                 removed <- setdiff(old_names, names)
[16:12:31.726]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.726]                   envs[common]]
[16:12:31.726]                 NAMES <- toupper(changed)
[16:12:31.726]                 args <- list()
[16:12:31.726]                 for (kk in seq_along(NAMES)) {
[16:12:31.726]                   name <- changed[[kk]]
[16:12:31.726]                   NAME <- NAMES[[kk]]
[16:12:31.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.726]                     next
[16:12:31.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.726]                 }
[16:12:31.726]                 NAMES <- toupper(added)
[16:12:31.726]                 for (kk in seq_along(NAMES)) {
[16:12:31.726]                   name <- added[[kk]]
[16:12:31.726]                   NAME <- NAMES[[kk]]
[16:12:31.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.726]                     next
[16:12:31.726]                   args[[name]] <- ""
[16:12:31.726]                 }
[16:12:31.726]                 NAMES <- toupper(removed)
[16:12:31.726]                 for (kk in seq_along(NAMES)) {
[16:12:31.726]                   name <- removed[[kk]]
[16:12:31.726]                   NAME <- NAMES[[kk]]
[16:12:31.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.726]                     next
[16:12:31.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.726]                 }
[16:12:31.726]                 if (length(args) > 0) 
[16:12:31.726]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.726]             }
[16:12:31.726]             else {
[16:12:31.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.726]             }
[16:12:31.726]             {
[16:12:31.726]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.726]                   0L) {
[16:12:31.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.726]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.726]                   base::options(opts)
[16:12:31.726]                 }
[16:12:31.726]                 {
[16:12:31.726]                   {
[16:12:31.726]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.726]                     NULL
[16:12:31.726]                   }
[16:12:31.726]                   options(future.plan = NULL)
[16:12:31.726]                   if (is.na(NA_character_)) 
[16:12:31.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.726]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.726]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.726]                     envir = parent.frame()) 
[16:12:31.726]                   {
[16:12:31.726]                     if (is.function(workers)) 
[16:12:31.726]                       workers <- workers()
[16:12:31.726]                     workers <- structure(as.integer(workers), 
[16:12:31.726]                       class = class(workers))
[16:12:31.726]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.726]                       workers >= 1)
[16:12:31.726]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.726]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.726]                     }
[16:12:31.726]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.726]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.726]                       envir = envir)
[16:12:31.726]                     if (!future$lazy) 
[16:12:31.726]                       future <- run(future)
[16:12:31.726]                     invisible(future)
[16:12:31.726]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.726]                 }
[16:12:31.726]             }
[16:12:31.726]         }
[16:12:31.726]     })
[16:12:31.726]     if (TRUE) {
[16:12:31.726]         base::sink(type = "output", split = FALSE)
[16:12:31.726]         if (TRUE) {
[16:12:31.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.726]         }
[16:12:31.726]         else {
[16:12:31.726]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.726]         }
[16:12:31.726]         base::close(...future.stdout)
[16:12:31.726]         ...future.stdout <- NULL
[16:12:31.726]     }
[16:12:31.726]     ...future.result$conditions <- ...future.conditions
[16:12:31.726]     ...future.result$finished <- base::Sys.time()
[16:12:31.726]     ...future.result
[16:12:31.726] }
[16:12:31.728] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:31.739] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.739] - Validating connection of MultisessionFuture
[16:12:31.740] - received message: FutureResult
[16:12:31.740] - Received FutureResult
[16:12:31.740] - Erased future from FutureRegistry
[16:12:31.740] result() for ClusterFuture ...
[16:12:31.740] - result already collected: FutureResult
[16:12:31.740] result() for ClusterFuture ... done
[16:12:31.740] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.740] result() for ClusterFuture ...
[16:12:31.740] - result already collected: FutureResult
[16:12:31.741] result() for ClusterFuture ... done
[16:12:31.741] result() for ClusterFuture ...
[16:12:31.741] - result already collected: FutureResult
[16:12:31.741] result() for ClusterFuture ... done
[16:12:31.742] MultisessionFuture started
[16:12:31.742] - Launch lazy future ... done
[16:12:31.742] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560bb0727290> 
Classes 'listenv', 'environment' <environment: 0x560bae4266e0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[16:12:31.752] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.752] - Validating connection of MultisessionFuture
[16:12:31.753] - received message: FutureResult
[16:12:31.753] - Received FutureResult
[16:12:31.753] - Erased future from FutureRegistry
[16:12:31.753] result() for ClusterFuture ...
[16:12:31.753] - result already collected: FutureResult
[16:12:31.753] result() for ClusterFuture ... done
[16:12:31.753] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:31.766] resolve() on list environment ...
[16:12:31.766]  recursive: 0
[16:12:31.767]  length: 6
[16:12:31.767]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:31.767] signalConditionsASAP(numeric, pos=1) ...
[16:12:31.767] - nx: 6
[16:12:31.767] - relay: TRUE
[16:12:31.767] - stdout: TRUE
[16:12:31.768] - signal: TRUE
[16:12:31.768] - resignal: FALSE
[16:12:31.768] - force: TRUE
[16:12:31.768] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.768] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.768]  - until=2
[16:12:31.768]  - relaying element #2
[16:12:31.768] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.768] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.768] signalConditionsASAP(NULL, pos=1) ... done
[16:12:31.769]  length: 5 (resolved future 1)
[16:12:31.769] Future #2
[16:12:31.769] result() for ClusterFuture ...
[16:12:31.769] - result already collected: FutureResult
[16:12:31.769] result() for ClusterFuture ... done
[16:12:31.769] result() for ClusterFuture ...
[16:12:31.769] - result already collected: FutureResult
[16:12:31.769] result() for ClusterFuture ... done
[16:12:31.769] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:31.769] - nx: 6
[16:12:31.769] - relay: TRUE
[16:12:31.770] - stdout: TRUE
[16:12:31.770] - signal: TRUE
[16:12:31.770] - resignal: FALSE
[16:12:31.770] - force: TRUE
[16:12:31.770] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.770] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.770]  - until=2
[16:12:31.770]  - relaying element #2
[16:12:31.770] result() for ClusterFuture ...
[16:12:31.770] - result already collected: FutureResult
[16:12:31.770] result() for ClusterFuture ... done
[16:12:31.770] result() for ClusterFuture ...
[16:12:31.771] - result already collected: FutureResult
[16:12:31.771] result() for ClusterFuture ... done
[16:12:31.771] result() for ClusterFuture ...
[16:12:31.771] - result already collected: FutureResult
[16:12:31.771] result() for ClusterFuture ... done
[16:12:31.771] result() for ClusterFuture ...
[16:12:31.771] - result already collected: FutureResult
[16:12:31.771] result() for ClusterFuture ... done
[16:12:31.771] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.771] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.771] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:31.772]  length: 4 (resolved future 2)
[16:12:31.772] Future #3
[16:12:31.772] result() for ClusterFuture ...
[16:12:31.772] - result already collected: FutureResult
[16:12:31.772] result() for ClusterFuture ... done
[16:12:31.772] result() for ClusterFuture ...
[16:12:31.772] - result already collected: FutureResult
[16:12:31.772] result() for ClusterFuture ... done
[16:12:31.772] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:31.772] - nx: 6
[16:12:31.773] - relay: TRUE
[16:12:31.773] - stdout: TRUE
[16:12:31.773] - signal: TRUE
[16:12:31.773] - resignal: FALSE
[16:12:31.773] - force: TRUE
[16:12:31.773] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.773] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.773]  - until=3
[16:12:31.773]  - relaying element #3
[16:12:31.773] result() for ClusterFuture ...
[16:12:31.773] - result already collected: FutureResult
[16:12:31.773] result() for ClusterFuture ... done
[16:12:31.774] result() for ClusterFuture ...
[16:12:31.774] - result already collected: FutureResult
[16:12:31.774] result() for ClusterFuture ... done
[16:12:31.774] result() for ClusterFuture ...
[16:12:31.774] - result already collected: FutureResult
[16:12:31.774] result() for ClusterFuture ... done
[16:12:31.774] result() for ClusterFuture ...
[16:12:31.774] - result already collected: FutureResult
[16:12:31.774] result() for ClusterFuture ... done
[16:12:31.774] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.775] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:31.775]  length: 3 (resolved future 3)
[16:12:31.785] signalConditionsASAP(NULL, pos=5) ...
[16:12:31.785] - nx: 6
[16:12:31.786] - relay: TRUE
[16:12:31.786] - stdout: TRUE
[16:12:31.786] - signal: TRUE
[16:12:31.786] - resignal: FALSE
[16:12:31.786] - force: TRUE
[16:12:31.786] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.786] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.786]  - until=6
[16:12:31.786]  - relaying element #4
[16:12:31.786]  - relaying element #6
[16:12:31.787] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.787] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.787] signalConditionsASAP(NULL, pos=5) ... done
[16:12:31.787]  length: 2 (resolved future 5)
[16:12:31.787] signalConditionsASAP(numeric, pos=6) ...
[16:12:31.787] - nx: 6
[16:12:31.787] - relay: TRUE
[16:12:31.787] - stdout: TRUE
[16:12:31.787] - signal: TRUE
[16:12:31.788] - resignal: FALSE
[16:12:31.788] - force: TRUE
[16:12:31.788] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.788] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.788]  - until=6
[16:12:31.788]  - relaying element #4
[16:12:31.789] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.789] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.789] signalConditionsASAP(NULL, pos=6) ... done
[16:12:31.789]  length: 1 (resolved future 6)
[16:12:31.800] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.800] - Validating connection of MultisessionFuture
[16:12:31.800] - received message: FutureResult
[16:12:31.800] - Received FutureResult
[16:12:31.800] - Erased future from FutureRegistry
[16:12:31.800] result() for ClusterFuture ...
[16:12:31.801] - result already collected: FutureResult
[16:12:31.801] result() for ClusterFuture ... done
[16:12:31.801] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.801] Future #4
[16:12:31.801] result() for ClusterFuture ...
[16:12:31.801] - result already collected: FutureResult
[16:12:31.801] result() for ClusterFuture ... done
[16:12:31.801] result() for ClusterFuture ...
[16:12:31.801] - result already collected: FutureResult
[16:12:31.801] result() for ClusterFuture ... done
[16:12:31.801] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:31.802] - nx: 6
[16:12:31.802] - relay: TRUE
[16:12:31.802] - stdout: TRUE
[16:12:31.802] - signal: TRUE
[16:12:31.802] - resignal: FALSE
[16:12:31.802] - force: TRUE
[16:12:31.802] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.802] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.802]  - until=6
[16:12:31.802]  - relaying element #4
[16:12:31.802] result() for ClusterFuture ...
[16:12:31.803] - result already collected: FutureResult
[16:12:31.803] result() for ClusterFuture ... done
[16:12:31.803] result() for ClusterFuture ...
[16:12:31.803] - result already collected: FutureResult
[16:12:31.803] result() for ClusterFuture ... done
[16:12:31.803] result() for ClusterFuture ...
[16:12:31.803] - result already collected: FutureResult
[16:12:31.803] result() for ClusterFuture ... done
[16:12:31.803] result() for ClusterFuture ...
[16:12:31.803] - result already collected: FutureResult
[16:12:31.803] result() for ClusterFuture ... done
[16:12:31.803] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.804] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.804] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:31.804]  length: 0 (resolved future 4)
[16:12:31.804] Relaying remaining futures
[16:12:31.804] signalConditionsASAP(NULL, pos=0) ...
[16:12:31.804] - nx: 6
[16:12:31.804] - relay: TRUE
[16:12:31.804] - stdout: TRUE
[16:12:31.804] - signal: TRUE
[16:12:31.804] - resignal: FALSE
[16:12:31.804] - force: TRUE
[16:12:31.805] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.805] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:31.805] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.805] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.805] signalConditionsASAP(NULL, pos=0) ... done
[16:12:31.805] resolve() on list environment ... DONE
[16:12:31.805] result() for ClusterFuture ...
[16:12:31.805] - result already collected: FutureResult
[16:12:31.805] result() for ClusterFuture ... done
[16:12:31.805] result() for ClusterFuture ...
[16:12:31.806] - result already collected: FutureResult
[16:12:31.806] result() for ClusterFuture ... done
[16:12:31.806] result() for ClusterFuture ...
[16:12:31.806] - result already collected: FutureResult
[16:12:31.806] result() for ClusterFuture ... done
[16:12:31.806] result() for ClusterFuture ...
[16:12:31.806] - result already collected: FutureResult
[16:12:31.806] result() for ClusterFuture ... done
[16:12:31.806] result() for ClusterFuture ...
[16:12:31.807] - result already collected: FutureResult
[16:12:31.807] result() for ClusterFuture ... done
[16:12:31.807] result() for ClusterFuture ...
[16:12:31.807] - result already collected: FutureResult
[16:12:31.807] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x560bac9b7348> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[16:12:31.809] getGlobalsAndPackages() ...
[16:12:31.809] Searching for globals...
[16:12:31.809] 
[16:12:31.809] Searching for globals ... DONE
[16:12:31.809] - globals: [0] <none>
[16:12:31.809] getGlobalsAndPackages() ... DONE
[16:12:31.810] run() for ‘Future’ ...
[16:12:31.810] - state: ‘created’
[16:12:31.810] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.824] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.825]   - Field: ‘node’
[16:12:31.825]   - Field: ‘label’
[16:12:31.825]   - Field: ‘local’
[16:12:31.825]   - Field: ‘owner’
[16:12:31.825]   - Field: ‘envir’
[16:12:31.825]   - Field: ‘workers’
[16:12:31.825]   - Field: ‘packages’
[16:12:31.825]   - Field: ‘gc’
[16:12:31.825]   - Field: ‘conditions’
[16:12:31.825]   - Field: ‘persistent’
[16:12:31.826]   - Field: ‘expr’
[16:12:31.826]   - Field: ‘uuid’
[16:12:31.826]   - Field: ‘seed’
[16:12:31.826]   - Field: ‘version’
[16:12:31.826]   - Field: ‘result’
[16:12:31.826]   - Field: ‘asynchronous’
[16:12:31.826]   - Field: ‘calls’
[16:12:31.826]   - Field: ‘globals’
[16:12:31.826]   - Field: ‘stdout’
[16:12:31.826]   - Field: ‘earlySignal’
[16:12:31.826]   - Field: ‘lazy’
[16:12:31.827]   - Field: ‘state’
[16:12:31.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.827] - Launch lazy future ...
[16:12:31.827] Packages needed by the future expression (n = 0): <none>
[16:12:31.827] Packages needed by future strategies (n = 0): <none>
[16:12:31.828] {
[16:12:31.828]     {
[16:12:31.828]         {
[16:12:31.828]             ...future.startTime <- base::Sys.time()
[16:12:31.828]             {
[16:12:31.828]                 {
[16:12:31.828]                   {
[16:12:31.828]                     {
[16:12:31.828]                       base::local({
[16:12:31.828]                         has_future <- base::requireNamespace("future", 
[16:12:31.828]                           quietly = TRUE)
[16:12:31.828]                         if (has_future) {
[16:12:31.828]                           ns <- base::getNamespace("future")
[16:12:31.828]                           version <- ns[[".package"]][["version"]]
[16:12:31.828]                           if (is.null(version)) 
[16:12:31.828]                             version <- utils::packageVersion("future")
[16:12:31.828]                         }
[16:12:31.828]                         else {
[16:12:31.828]                           version <- NULL
[16:12:31.828]                         }
[16:12:31.828]                         if (!has_future || version < "1.8.0") {
[16:12:31.828]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.828]                             "", base::R.version$version.string), 
[16:12:31.828]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.828]                               "release", "version")], collapse = " "), 
[16:12:31.828]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.828]                             info)
[16:12:31.828]                           info <- base::paste(info, collapse = "; ")
[16:12:31.828]                           if (!has_future) {
[16:12:31.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.828]                               info)
[16:12:31.828]                           }
[16:12:31.828]                           else {
[16:12:31.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.828]                               info, version)
[16:12:31.828]                           }
[16:12:31.828]                           base::stop(msg)
[16:12:31.828]                         }
[16:12:31.828]                       })
[16:12:31.828]                     }
[16:12:31.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.828]                     base::options(mc.cores = 1L)
[16:12:31.828]                   }
[16:12:31.828]                   options(future.plan = NULL)
[16:12:31.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.828]                 }
[16:12:31.828]                 ...future.workdir <- getwd()
[16:12:31.828]             }
[16:12:31.828]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.828]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.828]         }
[16:12:31.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.828]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.828]             base::names(...future.oldOptions))
[16:12:31.828]     }
[16:12:31.828]     if (FALSE) {
[16:12:31.828]     }
[16:12:31.828]     else {
[16:12:31.828]         if (TRUE) {
[16:12:31.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.828]                 open = "w")
[16:12:31.828]         }
[16:12:31.828]         else {
[16:12:31.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.828]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.828]         }
[16:12:31.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.828]             base::sink(type = "output", split = FALSE)
[16:12:31.828]             base::close(...future.stdout)
[16:12:31.828]         }, add = TRUE)
[16:12:31.828]     }
[16:12:31.828]     ...future.frame <- base::sys.nframe()
[16:12:31.828]     ...future.conditions <- base::list()
[16:12:31.828]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.828]     if (FALSE) {
[16:12:31.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.828]     }
[16:12:31.828]     ...future.result <- base::tryCatch({
[16:12:31.828]         base::withCallingHandlers({
[16:12:31.828]             ...future.value <- base::withVisible(base::local({
[16:12:31.828]                 ...future.makeSendCondition <- local({
[16:12:31.828]                   sendCondition <- NULL
[16:12:31.828]                   function(frame = 1L) {
[16:12:31.828]                     if (is.function(sendCondition)) 
[16:12:31.828]                       return(sendCondition)
[16:12:31.828]                     ns <- getNamespace("parallel")
[16:12:31.828]                     if (exists("sendData", mode = "function", 
[16:12:31.828]                       envir = ns)) {
[16:12:31.828]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.828]                         envir = ns)
[16:12:31.828]                       envir <- sys.frame(frame)
[16:12:31.828]                       master <- NULL
[16:12:31.828]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.828]                         !identical(envir, emptyenv())) {
[16:12:31.828]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.828]                           inherits = FALSE)) {
[16:12:31.828]                           master <- get("master", mode = "list", 
[16:12:31.828]                             envir = envir, inherits = FALSE)
[16:12:31.828]                           if (inherits(master, c("SOCKnode", 
[16:12:31.828]                             "SOCK0node"))) {
[16:12:31.828]                             sendCondition <<- function(cond) {
[16:12:31.828]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.828]                                 success = TRUE)
[16:12:31.828]                               parallel_sendData(master, data)
[16:12:31.828]                             }
[16:12:31.828]                             return(sendCondition)
[16:12:31.828]                           }
[16:12:31.828]                         }
[16:12:31.828]                         frame <- frame + 1L
[16:12:31.828]                         envir <- sys.frame(frame)
[16:12:31.828]                       }
[16:12:31.828]                     }
[16:12:31.828]                     sendCondition <<- function(cond) NULL
[16:12:31.828]                   }
[16:12:31.828]                 })
[16:12:31.828]                 withCallingHandlers({
[16:12:31.828]                   2
[16:12:31.828]                 }, immediateCondition = function(cond) {
[16:12:31.828]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.828]                   sendCondition(cond)
[16:12:31.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.828]                   {
[16:12:31.828]                     inherits <- base::inherits
[16:12:31.828]                     invokeRestart <- base::invokeRestart
[16:12:31.828]                     is.null <- base::is.null
[16:12:31.828]                     muffled <- FALSE
[16:12:31.828]                     if (inherits(cond, "message")) {
[16:12:31.828]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.828]                       if (muffled) 
[16:12:31.828]                         invokeRestart("muffleMessage")
[16:12:31.828]                     }
[16:12:31.828]                     else if (inherits(cond, "warning")) {
[16:12:31.828]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.828]                       if (muffled) 
[16:12:31.828]                         invokeRestart("muffleWarning")
[16:12:31.828]                     }
[16:12:31.828]                     else if (inherits(cond, "condition")) {
[16:12:31.828]                       if (!is.null(pattern)) {
[16:12:31.828]                         computeRestarts <- base::computeRestarts
[16:12:31.828]                         grepl <- base::grepl
[16:12:31.828]                         restarts <- computeRestarts(cond)
[16:12:31.828]                         for (restart in restarts) {
[16:12:31.828]                           name <- restart$name
[16:12:31.828]                           if (is.null(name)) 
[16:12:31.828]                             next
[16:12:31.828]                           if (!grepl(pattern, name)) 
[16:12:31.828]                             next
[16:12:31.828]                           invokeRestart(restart)
[16:12:31.828]                           muffled <- TRUE
[16:12:31.828]                           break
[16:12:31.828]                         }
[16:12:31.828]                       }
[16:12:31.828]                     }
[16:12:31.828]                     invisible(muffled)
[16:12:31.828]                   }
[16:12:31.828]                   muffleCondition(cond)
[16:12:31.828]                 })
[16:12:31.828]             }))
[16:12:31.828]             future::FutureResult(value = ...future.value$value, 
[16:12:31.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.828]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.828]                     ...future.globalenv.names))
[16:12:31.828]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.828]         }, condition = base::local({
[16:12:31.828]             c <- base::c
[16:12:31.828]             inherits <- base::inherits
[16:12:31.828]             invokeRestart <- base::invokeRestart
[16:12:31.828]             length <- base::length
[16:12:31.828]             list <- base::list
[16:12:31.828]             seq.int <- base::seq.int
[16:12:31.828]             signalCondition <- base::signalCondition
[16:12:31.828]             sys.calls <- base::sys.calls
[16:12:31.828]             `[[` <- base::`[[`
[16:12:31.828]             `+` <- base::`+`
[16:12:31.828]             `<<-` <- base::`<<-`
[16:12:31.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.828]                   3L)]
[16:12:31.828]             }
[16:12:31.828]             function(cond) {
[16:12:31.828]                 is_error <- inherits(cond, "error")
[16:12:31.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.828]                   NULL)
[16:12:31.828]                 if (is_error) {
[16:12:31.828]                   sessionInformation <- function() {
[16:12:31.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.828]                       search = base::search(), system = base::Sys.info())
[16:12:31.828]                   }
[16:12:31.828]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.828]                     cond$call), session = sessionInformation(), 
[16:12:31.828]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.828]                   signalCondition(cond)
[16:12:31.828]                 }
[16:12:31.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.828]                 "immediateCondition"))) {
[16:12:31.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.828]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.828]                   if (TRUE && !signal) {
[16:12:31.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.828]                     {
[16:12:31.828]                       inherits <- base::inherits
[16:12:31.828]                       invokeRestart <- base::invokeRestart
[16:12:31.828]                       is.null <- base::is.null
[16:12:31.828]                       muffled <- FALSE
[16:12:31.828]                       if (inherits(cond, "message")) {
[16:12:31.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.828]                         if (muffled) 
[16:12:31.828]                           invokeRestart("muffleMessage")
[16:12:31.828]                       }
[16:12:31.828]                       else if (inherits(cond, "warning")) {
[16:12:31.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.828]                         if (muffled) 
[16:12:31.828]                           invokeRestart("muffleWarning")
[16:12:31.828]                       }
[16:12:31.828]                       else if (inherits(cond, "condition")) {
[16:12:31.828]                         if (!is.null(pattern)) {
[16:12:31.828]                           computeRestarts <- base::computeRestarts
[16:12:31.828]                           grepl <- base::grepl
[16:12:31.828]                           restarts <- computeRestarts(cond)
[16:12:31.828]                           for (restart in restarts) {
[16:12:31.828]                             name <- restart$name
[16:12:31.828]                             if (is.null(name)) 
[16:12:31.828]                               next
[16:12:31.828]                             if (!grepl(pattern, name)) 
[16:12:31.828]                               next
[16:12:31.828]                             invokeRestart(restart)
[16:12:31.828]                             muffled <- TRUE
[16:12:31.828]                             break
[16:12:31.828]                           }
[16:12:31.828]                         }
[16:12:31.828]                       }
[16:12:31.828]                       invisible(muffled)
[16:12:31.828]                     }
[16:12:31.828]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.828]                   }
[16:12:31.828]                 }
[16:12:31.828]                 else {
[16:12:31.828]                   if (TRUE) {
[16:12:31.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.828]                     {
[16:12:31.828]                       inherits <- base::inherits
[16:12:31.828]                       invokeRestart <- base::invokeRestart
[16:12:31.828]                       is.null <- base::is.null
[16:12:31.828]                       muffled <- FALSE
[16:12:31.828]                       if (inherits(cond, "message")) {
[16:12:31.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.828]                         if (muffled) 
[16:12:31.828]                           invokeRestart("muffleMessage")
[16:12:31.828]                       }
[16:12:31.828]                       else if (inherits(cond, "warning")) {
[16:12:31.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.828]                         if (muffled) 
[16:12:31.828]                           invokeRestart("muffleWarning")
[16:12:31.828]                       }
[16:12:31.828]                       else if (inherits(cond, "condition")) {
[16:12:31.828]                         if (!is.null(pattern)) {
[16:12:31.828]                           computeRestarts <- base::computeRestarts
[16:12:31.828]                           grepl <- base::grepl
[16:12:31.828]                           restarts <- computeRestarts(cond)
[16:12:31.828]                           for (restart in restarts) {
[16:12:31.828]                             name <- restart$name
[16:12:31.828]                             if (is.null(name)) 
[16:12:31.828]                               next
[16:12:31.828]                             if (!grepl(pattern, name)) 
[16:12:31.828]                               next
[16:12:31.828]                             invokeRestart(restart)
[16:12:31.828]                             muffled <- TRUE
[16:12:31.828]                             break
[16:12:31.828]                           }
[16:12:31.828]                         }
[16:12:31.828]                       }
[16:12:31.828]                       invisible(muffled)
[16:12:31.828]                     }
[16:12:31.828]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.828]                   }
[16:12:31.828]                 }
[16:12:31.828]             }
[16:12:31.828]         }))
[16:12:31.828]     }, error = function(ex) {
[16:12:31.828]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.828]                 ...future.rng), started = ...future.startTime, 
[16:12:31.828]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.828]             version = "1.8"), class = "FutureResult")
[16:12:31.828]     }, finally = {
[16:12:31.828]         if (!identical(...future.workdir, getwd())) 
[16:12:31.828]             setwd(...future.workdir)
[16:12:31.828]         {
[16:12:31.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.828]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.828]             }
[16:12:31.828]             base::options(...future.oldOptions)
[16:12:31.828]             if (.Platform$OS.type == "windows") {
[16:12:31.828]                 old_names <- names(...future.oldEnvVars)
[16:12:31.828]                 envs <- base::Sys.getenv()
[16:12:31.828]                 names <- names(envs)
[16:12:31.828]                 common <- intersect(names, old_names)
[16:12:31.828]                 added <- setdiff(names, old_names)
[16:12:31.828]                 removed <- setdiff(old_names, names)
[16:12:31.828]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.828]                   envs[common]]
[16:12:31.828]                 NAMES <- toupper(changed)
[16:12:31.828]                 args <- list()
[16:12:31.828]                 for (kk in seq_along(NAMES)) {
[16:12:31.828]                   name <- changed[[kk]]
[16:12:31.828]                   NAME <- NAMES[[kk]]
[16:12:31.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.828]                     next
[16:12:31.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.828]                 }
[16:12:31.828]                 NAMES <- toupper(added)
[16:12:31.828]                 for (kk in seq_along(NAMES)) {
[16:12:31.828]                   name <- added[[kk]]
[16:12:31.828]                   NAME <- NAMES[[kk]]
[16:12:31.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.828]                     next
[16:12:31.828]                   args[[name]] <- ""
[16:12:31.828]                 }
[16:12:31.828]                 NAMES <- toupper(removed)
[16:12:31.828]                 for (kk in seq_along(NAMES)) {
[16:12:31.828]                   name <- removed[[kk]]
[16:12:31.828]                   NAME <- NAMES[[kk]]
[16:12:31.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.828]                     next
[16:12:31.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.828]                 }
[16:12:31.828]                 if (length(args) > 0) 
[16:12:31.828]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.828]             }
[16:12:31.828]             else {
[16:12:31.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.828]             }
[16:12:31.828]             {
[16:12:31.828]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.828]                   0L) {
[16:12:31.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.828]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.828]                   base::options(opts)
[16:12:31.828]                 }
[16:12:31.828]                 {
[16:12:31.828]                   {
[16:12:31.828]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.828]                     NULL
[16:12:31.828]                   }
[16:12:31.828]                   options(future.plan = NULL)
[16:12:31.828]                   if (is.na(NA_character_)) 
[16:12:31.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.828]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.828]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.828]                     envir = parent.frame()) 
[16:12:31.828]                   {
[16:12:31.828]                     if (is.function(workers)) 
[16:12:31.828]                       workers <- workers()
[16:12:31.828]                     workers <- structure(as.integer(workers), 
[16:12:31.828]                       class = class(workers))
[16:12:31.828]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.828]                       workers >= 1)
[16:12:31.828]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.828]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.828]                     }
[16:12:31.828]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.828]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.828]                       envir = envir)
[16:12:31.828]                     if (!future$lazy) 
[16:12:31.828]                       future <- run(future)
[16:12:31.828]                     invisible(future)
[16:12:31.828]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.828]                 }
[16:12:31.828]             }
[16:12:31.828]         }
[16:12:31.828]     })
[16:12:31.828]     if (TRUE) {
[16:12:31.828]         base::sink(type = "output", split = FALSE)
[16:12:31.828]         if (TRUE) {
[16:12:31.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.828]         }
[16:12:31.828]         else {
[16:12:31.828]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.828]         }
[16:12:31.828]         base::close(...future.stdout)
[16:12:31.828]         ...future.stdout <- NULL
[16:12:31.828]     }
[16:12:31.828]     ...future.result$conditions <- ...future.conditions
[16:12:31.828]     ...future.result$finished <- base::Sys.time()
[16:12:31.828]     ...future.result
[16:12:31.828] }
[16:12:31.831] MultisessionFuture started
[16:12:31.831] - Launch lazy future ... done
[16:12:31.831] run() for ‘MultisessionFuture’ ... done
[16:12:31.831] getGlobalsAndPackages() ...
[16:12:31.831] Searching for globals...
[16:12:31.832] 
[16:12:31.832] Searching for globals ... DONE
[16:12:31.832] - globals: [0] <none>
[16:12:31.832] getGlobalsAndPackages() ... DONE
[16:12:31.832] run() for ‘Future’ ...
[16:12:31.832] - state: ‘created’
[16:12:31.833] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.847] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.847]   - Field: ‘node’
[16:12:31.847]   - Field: ‘label’
[16:12:31.847]   - Field: ‘local’
[16:12:31.847]   - Field: ‘owner’
[16:12:31.847]   - Field: ‘envir’
[16:12:31.847]   - Field: ‘workers’
[16:12:31.848]   - Field: ‘packages’
[16:12:31.848]   - Field: ‘gc’
[16:12:31.848]   - Field: ‘conditions’
[16:12:31.848]   - Field: ‘persistent’
[16:12:31.848]   - Field: ‘expr’
[16:12:31.848]   - Field: ‘uuid’
[16:12:31.848]   - Field: ‘seed’
[16:12:31.848]   - Field: ‘version’
[16:12:31.848]   - Field: ‘result’
[16:12:31.848]   - Field: ‘asynchronous’
[16:12:31.848]   - Field: ‘calls’
[16:12:31.849]   - Field: ‘globals’
[16:12:31.849]   - Field: ‘stdout’
[16:12:31.849]   - Field: ‘earlySignal’
[16:12:31.849]   - Field: ‘lazy’
[16:12:31.849]   - Field: ‘state’
[16:12:31.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.849] - Launch lazy future ...
[16:12:31.849] Packages needed by the future expression (n = 0): <none>
[16:12:31.850] Packages needed by future strategies (n = 0): <none>
[16:12:31.850] {
[16:12:31.850]     {
[16:12:31.850]         {
[16:12:31.850]             ...future.startTime <- base::Sys.time()
[16:12:31.850]             {
[16:12:31.850]                 {
[16:12:31.850]                   {
[16:12:31.850]                     {
[16:12:31.850]                       base::local({
[16:12:31.850]                         has_future <- base::requireNamespace("future", 
[16:12:31.850]                           quietly = TRUE)
[16:12:31.850]                         if (has_future) {
[16:12:31.850]                           ns <- base::getNamespace("future")
[16:12:31.850]                           version <- ns[[".package"]][["version"]]
[16:12:31.850]                           if (is.null(version)) 
[16:12:31.850]                             version <- utils::packageVersion("future")
[16:12:31.850]                         }
[16:12:31.850]                         else {
[16:12:31.850]                           version <- NULL
[16:12:31.850]                         }
[16:12:31.850]                         if (!has_future || version < "1.8.0") {
[16:12:31.850]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.850]                             "", base::R.version$version.string), 
[16:12:31.850]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.850]                               "release", "version")], collapse = " "), 
[16:12:31.850]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.850]                             info)
[16:12:31.850]                           info <- base::paste(info, collapse = "; ")
[16:12:31.850]                           if (!has_future) {
[16:12:31.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.850]                               info)
[16:12:31.850]                           }
[16:12:31.850]                           else {
[16:12:31.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.850]                               info, version)
[16:12:31.850]                           }
[16:12:31.850]                           base::stop(msg)
[16:12:31.850]                         }
[16:12:31.850]                       })
[16:12:31.850]                     }
[16:12:31.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.850]                     base::options(mc.cores = 1L)
[16:12:31.850]                   }
[16:12:31.850]                   options(future.plan = NULL)
[16:12:31.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.850]                 }
[16:12:31.850]                 ...future.workdir <- getwd()
[16:12:31.850]             }
[16:12:31.850]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.850]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.850]         }
[16:12:31.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.850]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.850]             base::names(...future.oldOptions))
[16:12:31.850]     }
[16:12:31.850]     if (FALSE) {
[16:12:31.850]     }
[16:12:31.850]     else {
[16:12:31.850]         if (TRUE) {
[16:12:31.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.850]                 open = "w")
[16:12:31.850]         }
[16:12:31.850]         else {
[16:12:31.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.850]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.850]         }
[16:12:31.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.850]             base::sink(type = "output", split = FALSE)
[16:12:31.850]             base::close(...future.stdout)
[16:12:31.850]         }, add = TRUE)
[16:12:31.850]     }
[16:12:31.850]     ...future.frame <- base::sys.nframe()
[16:12:31.850]     ...future.conditions <- base::list()
[16:12:31.850]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.850]     if (FALSE) {
[16:12:31.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.850]     }
[16:12:31.850]     ...future.result <- base::tryCatch({
[16:12:31.850]         base::withCallingHandlers({
[16:12:31.850]             ...future.value <- base::withVisible(base::local({
[16:12:31.850]                 ...future.makeSendCondition <- local({
[16:12:31.850]                   sendCondition <- NULL
[16:12:31.850]                   function(frame = 1L) {
[16:12:31.850]                     if (is.function(sendCondition)) 
[16:12:31.850]                       return(sendCondition)
[16:12:31.850]                     ns <- getNamespace("parallel")
[16:12:31.850]                     if (exists("sendData", mode = "function", 
[16:12:31.850]                       envir = ns)) {
[16:12:31.850]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.850]                         envir = ns)
[16:12:31.850]                       envir <- sys.frame(frame)
[16:12:31.850]                       master <- NULL
[16:12:31.850]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.850]                         !identical(envir, emptyenv())) {
[16:12:31.850]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.850]                           inherits = FALSE)) {
[16:12:31.850]                           master <- get("master", mode = "list", 
[16:12:31.850]                             envir = envir, inherits = FALSE)
[16:12:31.850]                           if (inherits(master, c("SOCKnode", 
[16:12:31.850]                             "SOCK0node"))) {
[16:12:31.850]                             sendCondition <<- function(cond) {
[16:12:31.850]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.850]                                 success = TRUE)
[16:12:31.850]                               parallel_sendData(master, data)
[16:12:31.850]                             }
[16:12:31.850]                             return(sendCondition)
[16:12:31.850]                           }
[16:12:31.850]                         }
[16:12:31.850]                         frame <- frame + 1L
[16:12:31.850]                         envir <- sys.frame(frame)
[16:12:31.850]                       }
[16:12:31.850]                     }
[16:12:31.850]                     sendCondition <<- function(cond) NULL
[16:12:31.850]                   }
[16:12:31.850]                 })
[16:12:31.850]                 withCallingHandlers({
[16:12:31.850]                   NULL
[16:12:31.850]                 }, immediateCondition = function(cond) {
[16:12:31.850]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.850]                   sendCondition(cond)
[16:12:31.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.850]                   {
[16:12:31.850]                     inherits <- base::inherits
[16:12:31.850]                     invokeRestart <- base::invokeRestart
[16:12:31.850]                     is.null <- base::is.null
[16:12:31.850]                     muffled <- FALSE
[16:12:31.850]                     if (inherits(cond, "message")) {
[16:12:31.850]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.850]                       if (muffled) 
[16:12:31.850]                         invokeRestart("muffleMessage")
[16:12:31.850]                     }
[16:12:31.850]                     else if (inherits(cond, "warning")) {
[16:12:31.850]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.850]                       if (muffled) 
[16:12:31.850]                         invokeRestart("muffleWarning")
[16:12:31.850]                     }
[16:12:31.850]                     else if (inherits(cond, "condition")) {
[16:12:31.850]                       if (!is.null(pattern)) {
[16:12:31.850]                         computeRestarts <- base::computeRestarts
[16:12:31.850]                         grepl <- base::grepl
[16:12:31.850]                         restarts <- computeRestarts(cond)
[16:12:31.850]                         for (restart in restarts) {
[16:12:31.850]                           name <- restart$name
[16:12:31.850]                           if (is.null(name)) 
[16:12:31.850]                             next
[16:12:31.850]                           if (!grepl(pattern, name)) 
[16:12:31.850]                             next
[16:12:31.850]                           invokeRestart(restart)
[16:12:31.850]                           muffled <- TRUE
[16:12:31.850]                           break
[16:12:31.850]                         }
[16:12:31.850]                       }
[16:12:31.850]                     }
[16:12:31.850]                     invisible(muffled)
[16:12:31.850]                   }
[16:12:31.850]                   muffleCondition(cond)
[16:12:31.850]                 })
[16:12:31.850]             }))
[16:12:31.850]             future::FutureResult(value = ...future.value$value, 
[16:12:31.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.850]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.850]                     ...future.globalenv.names))
[16:12:31.850]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.850]         }, condition = base::local({
[16:12:31.850]             c <- base::c
[16:12:31.850]             inherits <- base::inherits
[16:12:31.850]             invokeRestart <- base::invokeRestart
[16:12:31.850]             length <- base::length
[16:12:31.850]             list <- base::list
[16:12:31.850]             seq.int <- base::seq.int
[16:12:31.850]             signalCondition <- base::signalCondition
[16:12:31.850]             sys.calls <- base::sys.calls
[16:12:31.850]             `[[` <- base::`[[`
[16:12:31.850]             `+` <- base::`+`
[16:12:31.850]             `<<-` <- base::`<<-`
[16:12:31.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.850]                   3L)]
[16:12:31.850]             }
[16:12:31.850]             function(cond) {
[16:12:31.850]                 is_error <- inherits(cond, "error")
[16:12:31.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.850]                   NULL)
[16:12:31.850]                 if (is_error) {
[16:12:31.850]                   sessionInformation <- function() {
[16:12:31.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.850]                       search = base::search(), system = base::Sys.info())
[16:12:31.850]                   }
[16:12:31.850]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.850]                     cond$call), session = sessionInformation(), 
[16:12:31.850]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.850]                   signalCondition(cond)
[16:12:31.850]                 }
[16:12:31.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.850]                 "immediateCondition"))) {
[16:12:31.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.850]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.850]                   if (TRUE && !signal) {
[16:12:31.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.850]                     {
[16:12:31.850]                       inherits <- base::inherits
[16:12:31.850]                       invokeRestart <- base::invokeRestart
[16:12:31.850]                       is.null <- base::is.null
[16:12:31.850]                       muffled <- FALSE
[16:12:31.850]                       if (inherits(cond, "message")) {
[16:12:31.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.850]                         if (muffled) 
[16:12:31.850]                           invokeRestart("muffleMessage")
[16:12:31.850]                       }
[16:12:31.850]                       else if (inherits(cond, "warning")) {
[16:12:31.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.850]                         if (muffled) 
[16:12:31.850]                           invokeRestart("muffleWarning")
[16:12:31.850]                       }
[16:12:31.850]                       else if (inherits(cond, "condition")) {
[16:12:31.850]                         if (!is.null(pattern)) {
[16:12:31.850]                           computeRestarts <- base::computeRestarts
[16:12:31.850]                           grepl <- base::grepl
[16:12:31.850]                           restarts <- computeRestarts(cond)
[16:12:31.850]                           for (restart in restarts) {
[16:12:31.850]                             name <- restart$name
[16:12:31.850]                             if (is.null(name)) 
[16:12:31.850]                               next
[16:12:31.850]                             if (!grepl(pattern, name)) 
[16:12:31.850]                               next
[16:12:31.850]                             invokeRestart(restart)
[16:12:31.850]                             muffled <- TRUE
[16:12:31.850]                             break
[16:12:31.850]                           }
[16:12:31.850]                         }
[16:12:31.850]                       }
[16:12:31.850]                       invisible(muffled)
[16:12:31.850]                     }
[16:12:31.850]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.850]                   }
[16:12:31.850]                 }
[16:12:31.850]                 else {
[16:12:31.850]                   if (TRUE) {
[16:12:31.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.850]                     {
[16:12:31.850]                       inherits <- base::inherits
[16:12:31.850]                       invokeRestart <- base::invokeRestart
[16:12:31.850]                       is.null <- base::is.null
[16:12:31.850]                       muffled <- FALSE
[16:12:31.850]                       if (inherits(cond, "message")) {
[16:12:31.850]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.850]                         if (muffled) 
[16:12:31.850]                           invokeRestart("muffleMessage")
[16:12:31.850]                       }
[16:12:31.850]                       else if (inherits(cond, "warning")) {
[16:12:31.850]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.850]                         if (muffled) 
[16:12:31.850]                           invokeRestart("muffleWarning")
[16:12:31.850]                       }
[16:12:31.850]                       else if (inherits(cond, "condition")) {
[16:12:31.850]                         if (!is.null(pattern)) {
[16:12:31.850]                           computeRestarts <- base::computeRestarts
[16:12:31.850]                           grepl <- base::grepl
[16:12:31.850]                           restarts <- computeRestarts(cond)
[16:12:31.850]                           for (restart in restarts) {
[16:12:31.850]                             name <- restart$name
[16:12:31.850]                             if (is.null(name)) 
[16:12:31.850]                               next
[16:12:31.850]                             if (!grepl(pattern, name)) 
[16:12:31.850]                               next
[16:12:31.850]                             invokeRestart(restart)
[16:12:31.850]                             muffled <- TRUE
[16:12:31.850]                             break
[16:12:31.850]                           }
[16:12:31.850]                         }
[16:12:31.850]                       }
[16:12:31.850]                       invisible(muffled)
[16:12:31.850]                     }
[16:12:31.850]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.850]                   }
[16:12:31.850]                 }
[16:12:31.850]             }
[16:12:31.850]         }))
[16:12:31.850]     }, error = function(ex) {
[16:12:31.850]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.850]                 ...future.rng), started = ...future.startTime, 
[16:12:31.850]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.850]             version = "1.8"), class = "FutureResult")
[16:12:31.850]     }, finally = {
[16:12:31.850]         if (!identical(...future.workdir, getwd())) 
[16:12:31.850]             setwd(...future.workdir)
[16:12:31.850]         {
[16:12:31.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.850]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.850]             }
[16:12:31.850]             base::options(...future.oldOptions)
[16:12:31.850]             if (.Platform$OS.type == "windows") {
[16:12:31.850]                 old_names <- names(...future.oldEnvVars)
[16:12:31.850]                 envs <- base::Sys.getenv()
[16:12:31.850]                 names <- names(envs)
[16:12:31.850]                 common <- intersect(names, old_names)
[16:12:31.850]                 added <- setdiff(names, old_names)
[16:12:31.850]                 removed <- setdiff(old_names, names)
[16:12:31.850]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.850]                   envs[common]]
[16:12:31.850]                 NAMES <- toupper(changed)
[16:12:31.850]                 args <- list()
[16:12:31.850]                 for (kk in seq_along(NAMES)) {
[16:12:31.850]                   name <- changed[[kk]]
[16:12:31.850]                   NAME <- NAMES[[kk]]
[16:12:31.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.850]                     next
[16:12:31.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.850]                 }
[16:12:31.850]                 NAMES <- toupper(added)
[16:12:31.850]                 for (kk in seq_along(NAMES)) {
[16:12:31.850]                   name <- added[[kk]]
[16:12:31.850]                   NAME <- NAMES[[kk]]
[16:12:31.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.850]                     next
[16:12:31.850]                   args[[name]] <- ""
[16:12:31.850]                 }
[16:12:31.850]                 NAMES <- toupper(removed)
[16:12:31.850]                 for (kk in seq_along(NAMES)) {
[16:12:31.850]                   name <- removed[[kk]]
[16:12:31.850]                   NAME <- NAMES[[kk]]
[16:12:31.850]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.850]                     next
[16:12:31.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.850]                 }
[16:12:31.850]                 if (length(args) > 0) 
[16:12:31.850]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.850]             }
[16:12:31.850]             else {
[16:12:31.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.850]             }
[16:12:31.850]             {
[16:12:31.850]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.850]                   0L) {
[16:12:31.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.850]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.850]                   base::options(opts)
[16:12:31.850]                 }
[16:12:31.850]                 {
[16:12:31.850]                   {
[16:12:31.850]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.850]                     NULL
[16:12:31.850]                   }
[16:12:31.850]                   options(future.plan = NULL)
[16:12:31.850]                   if (is.na(NA_character_)) 
[16:12:31.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.850]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.850]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.850]                     envir = parent.frame()) 
[16:12:31.850]                   {
[16:12:31.850]                     if (is.function(workers)) 
[16:12:31.850]                       workers <- workers()
[16:12:31.850]                     workers <- structure(as.integer(workers), 
[16:12:31.850]                       class = class(workers))
[16:12:31.850]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.850]                       workers >= 1)
[16:12:31.850]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.850]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.850]                     }
[16:12:31.850]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.850]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.850]                       envir = envir)
[16:12:31.850]                     if (!future$lazy) 
[16:12:31.850]                       future <- run(future)
[16:12:31.850]                     invisible(future)
[16:12:31.850]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.850]                 }
[16:12:31.850]             }
[16:12:31.850]         }
[16:12:31.850]     })
[16:12:31.850]     if (TRUE) {
[16:12:31.850]         base::sink(type = "output", split = FALSE)
[16:12:31.850]         if (TRUE) {
[16:12:31.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.850]         }
[16:12:31.850]         else {
[16:12:31.850]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.850]         }
[16:12:31.850]         base::close(...future.stdout)
[16:12:31.850]         ...future.stdout <- NULL
[16:12:31.850]     }
[16:12:31.850]     ...future.result$conditions <- ...future.conditions
[16:12:31.850]     ...future.result$finished <- base::Sys.time()
[16:12:31.850]     ...future.result
[16:12:31.850] }
[16:12:31.853] MultisessionFuture started
[16:12:31.856] - Launch lazy future ... done
[16:12:31.856] run() for ‘MultisessionFuture’ ... done
[16:12:31.857] getGlobalsAndPackages() ...
[16:12:31.857] Searching for globals...
[16:12:31.858] - globals found: [1] ‘{’
[16:12:31.858] Searching for globals ... DONE
[16:12:31.858] Resolving globals: FALSE
[16:12:31.858] 
[16:12:31.858] 
[16:12:31.858] getGlobalsAndPackages() ... DONE
[16:12:31.858] run() for ‘Future’ ...
[16:12:31.859] - state: ‘created’
[16:12:31.859] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.873] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.873] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.873]   - Field: ‘node’
[16:12:31.873]   - Field: ‘label’
[16:12:31.873]   - Field: ‘local’
[16:12:31.873]   - Field: ‘owner’
[16:12:31.873]   - Field: ‘envir’
[16:12:31.873]   - Field: ‘workers’
[16:12:31.874]   - Field: ‘packages’
[16:12:31.874]   - Field: ‘gc’
[16:12:31.874]   - Field: ‘conditions’
[16:12:31.874]   - Field: ‘persistent’
[16:12:31.874]   - Field: ‘expr’
[16:12:31.874]   - Field: ‘uuid’
[16:12:31.874]   - Field: ‘seed’
[16:12:31.874]   - Field: ‘version’
[16:12:31.874]   - Field: ‘result’
[16:12:31.874]   - Field: ‘asynchronous’
[16:12:31.874]   - Field: ‘calls’
[16:12:31.875]   - Field: ‘globals’
[16:12:31.875]   - Field: ‘stdout’
[16:12:31.875]   - Field: ‘earlySignal’
[16:12:31.875]   - Field: ‘lazy’
[16:12:31.875]   - Field: ‘state’
[16:12:31.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.875] - Launch lazy future ...
[16:12:31.875] Packages needed by the future expression (n = 0): <none>
[16:12:31.875] Packages needed by future strategies (n = 0): <none>
[16:12:31.876] {
[16:12:31.876]     {
[16:12:31.876]         {
[16:12:31.876]             ...future.startTime <- base::Sys.time()
[16:12:31.876]             {
[16:12:31.876]                 {
[16:12:31.876]                   {
[16:12:31.876]                     {
[16:12:31.876]                       base::local({
[16:12:31.876]                         has_future <- base::requireNamespace("future", 
[16:12:31.876]                           quietly = TRUE)
[16:12:31.876]                         if (has_future) {
[16:12:31.876]                           ns <- base::getNamespace("future")
[16:12:31.876]                           version <- ns[[".package"]][["version"]]
[16:12:31.876]                           if (is.null(version)) 
[16:12:31.876]                             version <- utils::packageVersion("future")
[16:12:31.876]                         }
[16:12:31.876]                         else {
[16:12:31.876]                           version <- NULL
[16:12:31.876]                         }
[16:12:31.876]                         if (!has_future || version < "1.8.0") {
[16:12:31.876]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.876]                             "", base::R.version$version.string), 
[16:12:31.876]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.876]                               "release", "version")], collapse = " "), 
[16:12:31.876]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.876]                             info)
[16:12:31.876]                           info <- base::paste(info, collapse = "; ")
[16:12:31.876]                           if (!has_future) {
[16:12:31.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.876]                               info)
[16:12:31.876]                           }
[16:12:31.876]                           else {
[16:12:31.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.876]                               info, version)
[16:12:31.876]                           }
[16:12:31.876]                           base::stop(msg)
[16:12:31.876]                         }
[16:12:31.876]                       })
[16:12:31.876]                     }
[16:12:31.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.876]                     base::options(mc.cores = 1L)
[16:12:31.876]                   }
[16:12:31.876]                   options(future.plan = NULL)
[16:12:31.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.876]                 }
[16:12:31.876]                 ...future.workdir <- getwd()
[16:12:31.876]             }
[16:12:31.876]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.876]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.876]         }
[16:12:31.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.876]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.876]             base::names(...future.oldOptions))
[16:12:31.876]     }
[16:12:31.876]     if (FALSE) {
[16:12:31.876]     }
[16:12:31.876]     else {
[16:12:31.876]         if (TRUE) {
[16:12:31.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.876]                 open = "w")
[16:12:31.876]         }
[16:12:31.876]         else {
[16:12:31.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.876]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.876]         }
[16:12:31.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.876]             base::sink(type = "output", split = FALSE)
[16:12:31.876]             base::close(...future.stdout)
[16:12:31.876]         }, add = TRUE)
[16:12:31.876]     }
[16:12:31.876]     ...future.frame <- base::sys.nframe()
[16:12:31.876]     ...future.conditions <- base::list()
[16:12:31.876]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.876]     if (FALSE) {
[16:12:31.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.876]     }
[16:12:31.876]     ...future.result <- base::tryCatch({
[16:12:31.876]         base::withCallingHandlers({
[16:12:31.876]             ...future.value <- base::withVisible(base::local({
[16:12:31.876]                 ...future.makeSendCondition <- local({
[16:12:31.876]                   sendCondition <- NULL
[16:12:31.876]                   function(frame = 1L) {
[16:12:31.876]                     if (is.function(sendCondition)) 
[16:12:31.876]                       return(sendCondition)
[16:12:31.876]                     ns <- getNamespace("parallel")
[16:12:31.876]                     if (exists("sendData", mode = "function", 
[16:12:31.876]                       envir = ns)) {
[16:12:31.876]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.876]                         envir = ns)
[16:12:31.876]                       envir <- sys.frame(frame)
[16:12:31.876]                       master <- NULL
[16:12:31.876]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.876]                         !identical(envir, emptyenv())) {
[16:12:31.876]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.876]                           inherits = FALSE)) {
[16:12:31.876]                           master <- get("master", mode = "list", 
[16:12:31.876]                             envir = envir, inherits = FALSE)
[16:12:31.876]                           if (inherits(master, c("SOCKnode", 
[16:12:31.876]                             "SOCK0node"))) {
[16:12:31.876]                             sendCondition <<- function(cond) {
[16:12:31.876]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.876]                                 success = TRUE)
[16:12:31.876]                               parallel_sendData(master, data)
[16:12:31.876]                             }
[16:12:31.876]                             return(sendCondition)
[16:12:31.876]                           }
[16:12:31.876]                         }
[16:12:31.876]                         frame <- frame + 1L
[16:12:31.876]                         envir <- sys.frame(frame)
[16:12:31.876]                       }
[16:12:31.876]                     }
[16:12:31.876]                     sendCondition <<- function(cond) NULL
[16:12:31.876]                   }
[16:12:31.876]                 })
[16:12:31.876]                 withCallingHandlers({
[16:12:31.876]                   {
[16:12:31.876]                     4
[16:12:31.876]                   }
[16:12:31.876]                 }, immediateCondition = function(cond) {
[16:12:31.876]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.876]                   sendCondition(cond)
[16:12:31.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.876]                   {
[16:12:31.876]                     inherits <- base::inherits
[16:12:31.876]                     invokeRestart <- base::invokeRestart
[16:12:31.876]                     is.null <- base::is.null
[16:12:31.876]                     muffled <- FALSE
[16:12:31.876]                     if (inherits(cond, "message")) {
[16:12:31.876]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.876]                       if (muffled) 
[16:12:31.876]                         invokeRestart("muffleMessage")
[16:12:31.876]                     }
[16:12:31.876]                     else if (inherits(cond, "warning")) {
[16:12:31.876]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.876]                       if (muffled) 
[16:12:31.876]                         invokeRestart("muffleWarning")
[16:12:31.876]                     }
[16:12:31.876]                     else if (inherits(cond, "condition")) {
[16:12:31.876]                       if (!is.null(pattern)) {
[16:12:31.876]                         computeRestarts <- base::computeRestarts
[16:12:31.876]                         grepl <- base::grepl
[16:12:31.876]                         restarts <- computeRestarts(cond)
[16:12:31.876]                         for (restart in restarts) {
[16:12:31.876]                           name <- restart$name
[16:12:31.876]                           if (is.null(name)) 
[16:12:31.876]                             next
[16:12:31.876]                           if (!grepl(pattern, name)) 
[16:12:31.876]                             next
[16:12:31.876]                           invokeRestart(restart)
[16:12:31.876]                           muffled <- TRUE
[16:12:31.876]                           break
[16:12:31.876]                         }
[16:12:31.876]                       }
[16:12:31.876]                     }
[16:12:31.876]                     invisible(muffled)
[16:12:31.876]                   }
[16:12:31.876]                   muffleCondition(cond)
[16:12:31.876]                 })
[16:12:31.876]             }))
[16:12:31.876]             future::FutureResult(value = ...future.value$value, 
[16:12:31.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.876]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.876]                     ...future.globalenv.names))
[16:12:31.876]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.876]         }, condition = base::local({
[16:12:31.876]             c <- base::c
[16:12:31.876]             inherits <- base::inherits
[16:12:31.876]             invokeRestart <- base::invokeRestart
[16:12:31.876]             length <- base::length
[16:12:31.876]             list <- base::list
[16:12:31.876]             seq.int <- base::seq.int
[16:12:31.876]             signalCondition <- base::signalCondition
[16:12:31.876]             sys.calls <- base::sys.calls
[16:12:31.876]             `[[` <- base::`[[`
[16:12:31.876]             `+` <- base::`+`
[16:12:31.876]             `<<-` <- base::`<<-`
[16:12:31.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.876]                   3L)]
[16:12:31.876]             }
[16:12:31.876]             function(cond) {
[16:12:31.876]                 is_error <- inherits(cond, "error")
[16:12:31.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.876]                   NULL)
[16:12:31.876]                 if (is_error) {
[16:12:31.876]                   sessionInformation <- function() {
[16:12:31.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.876]                       search = base::search(), system = base::Sys.info())
[16:12:31.876]                   }
[16:12:31.876]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.876]                     cond$call), session = sessionInformation(), 
[16:12:31.876]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.876]                   signalCondition(cond)
[16:12:31.876]                 }
[16:12:31.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.876]                 "immediateCondition"))) {
[16:12:31.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.876]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.876]                   if (TRUE && !signal) {
[16:12:31.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.876]                     {
[16:12:31.876]                       inherits <- base::inherits
[16:12:31.876]                       invokeRestart <- base::invokeRestart
[16:12:31.876]                       is.null <- base::is.null
[16:12:31.876]                       muffled <- FALSE
[16:12:31.876]                       if (inherits(cond, "message")) {
[16:12:31.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.876]                         if (muffled) 
[16:12:31.876]                           invokeRestart("muffleMessage")
[16:12:31.876]                       }
[16:12:31.876]                       else if (inherits(cond, "warning")) {
[16:12:31.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.876]                         if (muffled) 
[16:12:31.876]                           invokeRestart("muffleWarning")
[16:12:31.876]                       }
[16:12:31.876]                       else if (inherits(cond, "condition")) {
[16:12:31.876]                         if (!is.null(pattern)) {
[16:12:31.876]                           computeRestarts <- base::computeRestarts
[16:12:31.876]                           grepl <- base::grepl
[16:12:31.876]                           restarts <- computeRestarts(cond)
[16:12:31.876]                           for (restart in restarts) {
[16:12:31.876]                             name <- restart$name
[16:12:31.876]                             if (is.null(name)) 
[16:12:31.876]                               next
[16:12:31.876]                             if (!grepl(pattern, name)) 
[16:12:31.876]                               next
[16:12:31.876]                             invokeRestart(restart)
[16:12:31.876]                             muffled <- TRUE
[16:12:31.876]                             break
[16:12:31.876]                           }
[16:12:31.876]                         }
[16:12:31.876]                       }
[16:12:31.876]                       invisible(muffled)
[16:12:31.876]                     }
[16:12:31.876]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.876]                   }
[16:12:31.876]                 }
[16:12:31.876]                 else {
[16:12:31.876]                   if (TRUE) {
[16:12:31.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.876]                     {
[16:12:31.876]                       inherits <- base::inherits
[16:12:31.876]                       invokeRestart <- base::invokeRestart
[16:12:31.876]                       is.null <- base::is.null
[16:12:31.876]                       muffled <- FALSE
[16:12:31.876]                       if (inherits(cond, "message")) {
[16:12:31.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.876]                         if (muffled) 
[16:12:31.876]                           invokeRestart("muffleMessage")
[16:12:31.876]                       }
[16:12:31.876]                       else if (inherits(cond, "warning")) {
[16:12:31.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.876]                         if (muffled) 
[16:12:31.876]                           invokeRestart("muffleWarning")
[16:12:31.876]                       }
[16:12:31.876]                       else if (inherits(cond, "condition")) {
[16:12:31.876]                         if (!is.null(pattern)) {
[16:12:31.876]                           computeRestarts <- base::computeRestarts
[16:12:31.876]                           grepl <- base::grepl
[16:12:31.876]                           restarts <- computeRestarts(cond)
[16:12:31.876]                           for (restart in restarts) {
[16:12:31.876]                             name <- restart$name
[16:12:31.876]                             if (is.null(name)) 
[16:12:31.876]                               next
[16:12:31.876]                             if (!grepl(pattern, name)) 
[16:12:31.876]                               next
[16:12:31.876]                             invokeRestart(restart)
[16:12:31.876]                             muffled <- TRUE
[16:12:31.876]                             break
[16:12:31.876]                           }
[16:12:31.876]                         }
[16:12:31.876]                       }
[16:12:31.876]                       invisible(muffled)
[16:12:31.876]                     }
[16:12:31.876]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.876]                   }
[16:12:31.876]                 }
[16:12:31.876]             }
[16:12:31.876]         }))
[16:12:31.876]     }, error = function(ex) {
[16:12:31.876]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.876]                 ...future.rng), started = ...future.startTime, 
[16:12:31.876]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.876]             version = "1.8"), class = "FutureResult")
[16:12:31.876]     }, finally = {
[16:12:31.876]         if (!identical(...future.workdir, getwd())) 
[16:12:31.876]             setwd(...future.workdir)
[16:12:31.876]         {
[16:12:31.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.876]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.876]             }
[16:12:31.876]             base::options(...future.oldOptions)
[16:12:31.876]             if (.Platform$OS.type == "windows") {
[16:12:31.876]                 old_names <- names(...future.oldEnvVars)
[16:12:31.876]                 envs <- base::Sys.getenv()
[16:12:31.876]                 names <- names(envs)
[16:12:31.876]                 common <- intersect(names, old_names)
[16:12:31.876]                 added <- setdiff(names, old_names)
[16:12:31.876]                 removed <- setdiff(old_names, names)
[16:12:31.876]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.876]                   envs[common]]
[16:12:31.876]                 NAMES <- toupper(changed)
[16:12:31.876]                 args <- list()
[16:12:31.876]                 for (kk in seq_along(NAMES)) {
[16:12:31.876]                   name <- changed[[kk]]
[16:12:31.876]                   NAME <- NAMES[[kk]]
[16:12:31.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.876]                     next
[16:12:31.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.876]                 }
[16:12:31.876]                 NAMES <- toupper(added)
[16:12:31.876]                 for (kk in seq_along(NAMES)) {
[16:12:31.876]                   name <- added[[kk]]
[16:12:31.876]                   NAME <- NAMES[[kk]]
[16:12:31.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.876]                     next
[16:12:31.876]                   args[[name]] <- ""
[16:12:31.876]                 }
[16:12:31.876]                 NAMES <- toupper(removed)
[16:12:31.876]                 for (kk in seq_along(NAMES)) {
[16:12:31.876]                   name <- removed[[kk]]
[16:12:31.876]                   NAME <- NAMES[[kk]]
[16:12:31.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.876]                     next
[16:12:31.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.876]                 }
[16:12:31.876]                 if (length(args) > 0) 
[16:12:31.876]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.876]             }
[16:12:31.876]             else {
[16:12:31.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.876]             }
[16:12:31.876]             {
[16:12:31.876]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.876]                   0L) {
[16:12:31.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.876]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.876]                   base::options(opts)
[16:12:31.876]                 }
[16:12:31.876]                 {
[16:12:31.876]                   {
[16:12:31.876]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.876]                     NULL
[16:12:31.876]                   }
[16:12:31.876]                   options(future.plan = NULL)
[16:12:31.876]                   if (is.na(NA_character_)) 
[16:12:31.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.876]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.876]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.876]                     envir = parent.frame()) 
[16:12:31.876]                   {
[16:12:31.876]                     if (is.function(workers)) 
[16:12:31.876]                       workers <- workers()
[16:12:31.876]                     workers <- structure(as.integer(workers), 
[16:12:31.876]                       class = class(workers))
[16:12:31.876]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.876]                       workers >= 1)
[16:12:31.876]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.876]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.876]                     }
[16:12:31.876]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.876]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.876]                       envir = envir)
[16:12:31.876]                     if (!future$lazy) 
[16:12:31.876]                       future <- run(future)
[16:12:31.876]                     invisible(future)
[16:12:31.876]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.876]                 }
[16:12:31.876]             }
[16:12:31.876]         }
[16:12:31.876]     })
[16:12:31.876]     if (TRUE) {
[16:12:31.876]         base::sink(type = "output", split = FALSE)
[16:12:31.876]         if (TRUE) {
[16:12:31.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.876]         }
[16:12:31.876]         else {
[16:12:31.876]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.876]         }
[16:12:31.876]         base::close(...future.stdout)
[16:12:31.876]         ...future.stdout <- NULL
[16:12:31.876]     }
[16:12:31.876]     ...future.result$conditions <- ...future.conditions
[16:12:31.876]     ...future.result$finished <- base::Sys.time()
[16:12:31.876]     ...future.result
[16:12:31.876] }
[16:12:31.879] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:31.890] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.890] - Validating connection of MultisessionFuture
[16:12:31.890] - received message: FutureResult
[16:12:31.891] - Received FutureResult
[16:12:31.891] - Erased future from FutureRegistry
[16:12:31.891] result() for ClusterFuture ...
[16:12:31.891] - result already collected: FutureResult
[16:12:31.891] result() for ClusterFuture ... done
[16:12:31.891] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.891] result() for ClusterFuture ...
[16:12:31.891] - result already collected: FutureResult
[16:12:31.891] result() for ClusterFuture ... done
[16:12:31.891] result() for ClusterFuture ...
[16:12:31.892] - result already collected: FutureResult
[16:12:31.892] result() for ClusterFuture ... done
[16:12:31.893] MultisessionFuture started
[16:12:31.893] - Launch lazy future ... done
[16:12:31.893] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560bb03a2fc8> 
Classes 'listenv', 'environment' <environment: 0x560baea66120> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:31.904] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.904] - Validating connection of MultisessionFuture
[16:12:31.905] - received message: FutureResult
[16:12:31.905] - Received FutureResult
[16:12:31.905] - Erased future from FutureRegistry
[16:12:31.905] result() for ClusterFuture ...
[16:12:31.905] - result already collected: FutureResult
[16:12:31.905] result() for ClusterFuture ... done
[16:12:31.905] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:31.918] resolve() on list environment ...
[16:12:31.918]  recursive: 0
[16:12:31.919]  length: 6
[16:12:31.920]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:31.920] signalConditionsASAP(numeric, pos=1) ...
[16:12:31.920] - nx: 6
[16:12:31.920] - relay: TRUE
[16:12:31.920] - stdout: TRUE
[16:12:31.920] - signal: TRUE
[16:12:31.920] - resignal: FALSE
[16:12:31.920] - force: TRUE
[16:12:31.920] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.920] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.921]  - until=2
[16:12:31.921]  - relaying element #2
[16:12:31.921] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.921] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.921] signalConditionsASAP(NULL, pos=1) ... done
[16:12:31.921]  length: 5 (resolved future 1)
[16:12:31.921] Future #2
[16:12:31.921] result() for ClusterFuture ...
[16:12:31.921] - result already collected: FutureResult
[16:12:31.921] result() for ClusterFuture ... done
[16:12:31.922] result() for ClusterFuture ...
[16:12:31.922] - result already collected: FutureResult
[16:12:31.922] result() for ClusterFuture ... done
[16:12:31.922] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:31.922] - nx: 6
[16:12:31.922] - relay: TRUE
[16:12:31.922] - stdout: TRUE
[16:12:31.922] - signal: TRUE
[16:12:31.922] - resignal: FALSE
[16:12:31.922] - force: TRUE
[16:12:31.922] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.922] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:31.923]  - until=2
[16:12:31.923]  - relaying element #2
[16:12:31.923] result() for ClusterFuture ...
[16:12:31.923] - result already collected: FutureResult
[16:12:31.923] result() for ClusterFuture ... done
[16:12:31.923] result() for ClusterFuture ...
[16:12:31.923] - result already collected: FutureResult
[16:12:31.923] result() for ClusterFuture ... done
[16:12:31.923] result() for ClusterFuture ...
[16:12:31.923] - result already collected: FutureResult
[16:12:31.924] result() for ClusterFuture ... done
[16:12:31.924] result() for ClusterFuture ...
[16:12:31.924] - result already collected: FutureResult
[16:12:31.924] result() for ClusterFuture ... done
[16:12:31.924] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.924] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.924] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:31.924]  length: 4 (resolved future 2)
[16:12:31.924] Future #3
[16:12:31.924] result() for ClusterFuture ...
[16:12:31.925] - result already collected: FutureResult
[16:12:31.925] result() for ClusterFuture ... done
[16:12:31.925] result() for ClusterFuture ...
[16:12:31.925] - result already collected: FutureResult
[16:12:31.925] result() for ClusterFuture ... done
[16:12:31.925] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:31.925] - nx: 6
[16:12:31.925] - relay: TRUE
[16:12:31.925] - stdout: TRUE
[16:12:31.925] - signal: TRUE
[16:12:31.925] - resignal: FALSE
[16:12:31.925] - force: TRUE
[16:12:31.926] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.926] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:31.926]  - until=3
[16:12:31.926]  - relaying element #3
[16:12:31.926] result() for ClusterFuture ...
[16:12:31.926] - result already collected: FutureResult
[16:12:31.926] result() for ClusterFuture ... done
[16:12:31.926] result() for ClusterFuture ...
[16:12:31.926] - result already collected: FutureResult
[16:12:31.926] result() for ClusterFuture ... done
[16:12:31.926] result() for ClusterFuture ...
[16:12:31.927] - result already collected: FutureResult
[16:12:31.927] result() for ClusterFuture ... done
[16:12:31.927] result() for ClusterFuture ...
[16:12:31.927] - result already collected: FutureResult
[16:12:31.927] result() for ClusterFuture ... done
[16:12:31.927] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.927] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.927] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:31.927]  length: 3 (resolved future 3)
[16:12:31.938] signalConditionsASAP(NULL, pos=5) ...
[16:12:31.938] - nx: 6
[16:12:31.938] - relay: TRUE
[16:12:31.938] - stdout: TRUE
[16:12:31.938] - signal: TRUE
[16:12:31.938] - resignal: FALSE
[16:12:31.939] - force: TRUE
[16:12:31.939] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.939] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.939]  - until=6
[16:12:31.939]  - relaying element #4
[16:12:31.939]  - relaying element #6
[16:12:31.939] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.939] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.940] signalConditionsASAP(NULL, pos=5) ... done
[16:12:31.940]  length: 2 (resolved future 5)
[16:12:31.940] signalConditionsASAP(numeric, pos=6) ...
[16:12:31.940] - nx: 6
[16:12:31.940] - relay: TRUE
[16:12:31.940] - stdout: TRUE
[16:12:31.941] - signal: TRUE
[16:12:31.941] - resignal: FALSE
[16:12:31.941] - force: TRUE
[16:12:31.941] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:31.941] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.941]  - until=6
[16:12:31.941]  - relaying element #4
[16:12:31.941] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.942] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.942] signalConditionsASAP(NULL, pos=6) ... done
[16:12:31.942]  length: 1 (resolved future 6)
[16:12:31.952] receiveMessageFromWorker() for ClusterFuture ...
[16:12:31.953] - Validating connection of MultisessionFuture
[16:12:31.953] - received message: FutureResult
[16:12:31.953] - Received FutureResult
[16:12:31.953] - Erased future from FutureRegistry
[16:12:31.953] result() for ClusterFuture ...
[16:12:31.953] - result already collected: FutureResult
[16:12:31.953] result() for ClusterFuture ... done
[16:12:31.953] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:31.953] Future #4
[16:12:31.954] result() for ClusterFuture ...
[16:12:31.954] - result already collected: FutureResult
[16:12:31.954] result() for ClusterFuture ... done
[16:12:31.954] result() for ClusterFuture ...
[16:12:31.954] - result already collected: FutureResult
[16:12:31.954] result() for ClusterFuture ... done
[16:12:31.954] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:31.954] - nx: 6
[16:12:31.954] - relay: TRUE
[16:12:31.954] - stdout: TRUE
[16:12:31.954] - signal: TRUE
[16:12:31.955] - resignal: FALSE
[16:12:31.955] - force: TRUE
[16:12:31.955] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:31.955] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:31.955]  - until=6
[16:12:31.955]  - relaying element #4
[16:12:31.955] result() for ClusterFuture ...
[16:12:31.955] - result already collected: FutureResult
[16:12:31.955] result() for ClusterFuture ... done
[16:12:31.955] result() for ClusterFuture ...
[16:12:31.955] - result already collected: FutureResult
[16:12:31.956] result() for ClusterFuture ... done
[16:12:31.956] result() for ClusterFuture ...
[16:12:31.956] - result already collected: FutureResult
[16:12:31.956] result() for ClusterFuture ... done
[16:12:31.956] result() for ClusterFuture ...
[16:12:31.956] - result already collected: FutureResult
[16:12:31.956] result() for ClusterFuture ... done
[16:12:31.956] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.956] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.956] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:31.956]  length: 0 (resolved future 4)
[16:12:31.957] Relaying remaining futures
[16:12:31.957] signalConditionsASAP(NULL, pos=0) ...
[16:12:31.957] - nx: 6
[16:12:31.957] - relay: TRUE
[16:12:31.957] - stdout: TRUE
[16:12:31.957] - signal: TRUE
[16:12:31.957] - resignal: FALSE
[16:12:31.957] - force: TRUE
[16:12:31.957] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.957] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:31.957] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:31.958] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:31.958] signalConditionsASAP(NULL, pos=0) ... done
[16:12:31.958] resolve() on list environment ... DONE
[16:12:31.958] result() for ClusterFuture ...
[16:12:31.958] - result already collected: FutureResult
[16:12:31.958] result() for ClusterFuture ... done
[16:12:31.958] result() for ClusterFuture ...
[16:12:31.958] - result already collected: FutureResult
[16:12:31.958] result() for ClusterFuture ... done
[16:12:31.958] result() for ClusterFuture ...
[16:12:31.959] - result already collected: FutureResult
[16:12:31.959] result() for ClusterFuture ... done
[16:12:31.959] result() for ClusterFuture ...
[16:12:31.959] - result already collected: FutureResult
[16:12:31.959] result() for ClusterFuture ... done
[16:12:31.959] result() for ClusterFuture ...
[16:12:31.959] - result already collected: FutureResult
[16:12:31.959] result() for ClusterFuture ... done
[16:12:31.959] result() for ClusterFuture ...
[16:12:31.959] - result already collected: FutureResult
[16:12:31.959] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x560bacf3ff58> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[16:12:31.961] getGlobalsAndPackages() ...
[16:12:31.962] Searching for globals...
[16:12:31.962] 
[16:12:31.962] Searching for globals ... DONE
[16:12:31.962] - globals: [0] <none>
[16:12:31.962] getGlobalsAndPackages() ... DONE
[16:12:31.962] run() for ‘Future’ ...
[16:12:31.962] - state: ‘created’
[16:12:31.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.977]   - Field: ‘node’
[16:12:31.977]   - Field: ‘label’
[16:12:31.978]   - Field: ‘local’
[16:12:31.978]   - Field: ‘owner’
[16:12:31.978]   - Field: ‘envir’
[16:12:31.978]   - Field: ‘workers’
[16:12:31.978]   - Field: ‘packages’
[16:12:31.978]   - Field: ‘gc’
[16:12:31.978]   - Field: ‘conditions’
[16:12:31.978]   - Field: ‘persistent’
[16:12:31.978]   - Field: ‘expr’
[16:12:31.978]   - Field: ‘uuid’
[16:12:31.978]   - Field: ‘seed’
[16:12:31.979]   - Field: ‘version’
[16:12:31.979]   - Field: ‘result’
[16:12:31.979]   - Field: ‘asynchronous’
[16:12:31.979]   - Field: ‘calls’
[16:12:31.979]   - Field: ‘globals’
[16:12:31.979]   - Field: ‘stdout’
[16:12:31.979]   - Field: ‘earlySignal’
[16:12:31.979]   - Field: ‘lazy’
[16:12:31.979]   - Field: ‘state’
[16:12:31.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:31.979] - Launch lazy future ...
[16:12:31.980] Packages needed by the future expression (n = 0): <none>
[16:12:31.980] Packages needed by future strategies (n = 0): <none>
[16:12:31.980] {
[16:12:31.980]     {
[16:12:31.980]         {
[16:12:31.980]             ...future.startTime <- base::Sys.time()
[16:12:31.980]             {
[16:12:31.980]                 {
[16:12:31.980]                   {
[16:12:31.980]                     {
[16:12:31.980]                       base::local({
[16:12:31.980]                         has_future <- base::requireNamespace("future", 
[16:12:31.980]                           quietly = TRUE)
[16:12:31.980]                         if (has_future) {
[16:12:31.980]                           ns <- base::getNamespace("future")
[16:12:31.980]                           version <- ns[[".package"]][["version"]]
[16:12:31.980]                           if (is.null(version)) 
[16:12:31.980]                             version <- utils::packageVersion("future")
[16:12:31.980]                         }
[16:12:31.980]                         else {
[16:12:31.980]                           version <- NULL
[16:12:31.980]                         }
[16:12:31.980]                         if (!has_future || version < "1.8.0") {
[16:12:31.980]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:31.980]                             "", base::R.version$version.string), 
[16:12:31.980]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:31.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:31.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:31.980]                               "release", "version")], collapse = " "), 
[16:12:31.980]                             hostname = base::Sys.info()[["nodename"]])
[16:12:31.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:31.980]                             info)
[16:12:31.980]                           info <- base::paste(info, collapse = "; ")
[16:12:31.980]                           if (!has_future) {
[16:12:31.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:31.980]                               info)
[16:12:31.980]                           }
[16:12:31.980]                           else {
[16:12:31.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:31.980]                               info, version)
[16:12:31.980]                           }
[16:12:31.980]                           base::stop(msg)
[16:12:31.980]                         }
[16:12:31.980]                       })
[16:12:31.980]                     }
[16:12:31.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:31.980]                     base::options(mc.cores = 1L)
[16:12:31.980]                   }
[16:12:31.980]                   options(future.plan = NULL)
[16:12:31.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:31.980]                 }
[16:12:31.980]                 ...future.workdir <- getwd()
[16:12:31.980]             }
[16:12:31.980]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:31.980]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:31.980]         }
[16:12:31.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:31.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:31.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:31.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:31.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:31.980]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:31.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:31.980]             base::names(...future.oldOptions))
[16:12:31.980]     }
[16:12:31.980]     if (FALSE) {
[16:12:31.980]     }
[16:12:31.980]     else {
[16:12:31.980]         if (TRUE) {
[16:12:31.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:31.980]                 open = "w")
[16:12:31.980]         }
[16:12:31.980]         else {
[16:12:31.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:31.980]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:31.980]         }
[16:12:31.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:31.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:31.980]             base::sink(type = "output", split = FALSE)
[16:12:31.980]             base::close(...future.stdout)
[16:12:31.980]         }, add = TRUE)
[16:12:31.980]     }
[16:12:31.980]     ...future.frame <- base::sys.nframe()
[16:12:31.980]     ...future.conditions <- base::list()
[16:12:31.980]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:31.980]     if (FALSE) {
[16:12:31.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:31.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:31.980]     }
[16:12:31.980]     ...future.result <- base::tryCatch({
[16:12:31.980]         base::withCallingHandlers({
[16:12:31.980]             ...future.value <- base::withVisible(base::local({
[16:12:31.980]                 ...future.makeSendCondition <- local({
[16:12:31.980]                   sendCondition <- NULL
[16:12:31.980]                   function(frame = 1L) {
[16:12:31.980]                     if (is.function(sendCondition)) 
[16:12:31.980]                       return(sendCondition)
[16:12:31.980]                     ns <- getNamespace("parallel")
[16:12:31.980]                     if (exists("sendData", mode = "function", 
[16:12:31.980]                       envir = ns)) {
[16:12:31.980]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:31.980]                         envir = ns)
[16:12:31.980]                       envir <- sys.frame(frame)
[16:12:31.980]                       master <- NULL
[16:12:31.980]                       while (!identical(envir, .GlobalEnv) && 
[16:12:31.980]                         !identical(envir, emptyenv())) {
[16:12:31.980]                         if (exists("master", mode = "list", envir = envir, 
[16:12:31.980]                           inherits = FALSE)) {
[16:12:31.980]                           master <- get("master", mode = "list", 
[16:12:31.980]                             envir = envir, inherits = FALSE)
[16:12:31.980]                           if (inherits(master, c("SOCKnode", 
[16:12:31.980]                             "SOCK0node"))) {
[16:12:31.980]                             sendCondition <<- function(cond) {
[16:12:31.980]                               data <- list(type = "VALUE", value = cond, 
[16:12:31.980]                                 success = TRUE)
[16:12:31.980]                               parallel_sendData(master, data)
[16:12:31.980]                             }
[16:12:31.980]                             return(sendCondition)
[16:12:31.980]                           }
[16:12:31.980]                         }
[16:12:31.980]                         frame <- frame + 1L
[16:12:31.980]                         envir <- sys.frame(frame)
[16:12:31.980]                       }
[16:12:31.980]                     }
[16:12:31.980]                     sendCondition <<- function(cond) NULL
[16:12:31.980]                   }
[16:12:31.980]                 })
[16:12:31.980]                 withCallingHandlers({
[16:12:31.980]                   2
[16:12:31.980]                 }, immediateCondition = function(cond) {
[16:12:31.980]                   sendCondition <- ...future.makeSendCondition()
[16:12:31.980]                   sendCondition(cond)
[16:12:31.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.980]                   {
[16:12:31.980]                     inherits <- base::inherits
[16:12:31.980]                     invokeRestart <- base::invokeRestart
[16:12:31.980]                     is.null <- base::is.null
[16:12:31.980]                     muffled <- FALSE
[16:12:31.980]                     if (inherits(cond, "message")) {
[16:12:31.980]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:31.980]                       if (muffled) 
[16:12:31.980]                         invokeRestart("muffleMessage")
[16:12:31.980]                     }
[16:12:31.980]                     else if (inherits(cond, "warning")) {
[16:12:31.980]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:31.980]                       if (muffled) 
[16:12:31.980]                         invokeRestart("muffleWarning")
[16:12:31.980]                     }
[16:12:31.980]                     else if (inherits(cond, "condition")) {
[16:12:31.980]                       if (!is.null(pattern)) {
[16:12:31.980]                         computeRestarts <- base::computeRestarts
[16:12:31.980]                         grepl <- base::grepl
[16:12:31.980]                         restarts <- computeRestarts(cond)
[16:12:31.980]                         for (restart in restarts) {
[16:12:31.980]                           name <- restart$name
[16:12:31.980]                           if (is.null(name)) 
[16:12:31.980]                             next
[16:12:31.980]                           if (!grepl(pattern, name)) 
[16:12:31.980]                             next
[16:12:31.980]                           invokeRestart(restart)
[16:12:31.980]                           muffled <- TRUE
[16:12:31.980]                           break
[16:12:31.980]                         }
[16:12:31.980]                       }
[16:12:31.980]                     }
[16:12:31.980]                     invisible(muffled)
[16:12:31.980]                   }
[16:12:31.980]                   muffleCondition(cond)
[16:12:31.980]                 })
[16:12:31.980]             }))
[16:12:31.980]             future::FutureResult(value = ...future.value$value, 
[16:12:31.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.980]                   ...future.rng), globalenv = if (FALSE) 
[16:12:31.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:31.980]                     ...future.globalenv.names))
[16:12:31.980]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:31.980]         }, condition = base::local({
[16:12:31.980]             c <- base::c
[16:12:31.980]             inherits <- base::inherits
[16:12:31.980]             invokeRestart <- base::invokeRestart
[16:12:31.980]             length <- base::length
[16:12:31.980]             list <- base::list
[16:12:31.980]             seq.int <- base::seq.int
[16:12:31.980]             signalCondition <- base::signalCondition
[16:12:31.980]             sys.calls <- base::sys.calls
[16:12:31.980]             `[[` <- base::`[[`
[16:12:31.980]             `+` <- base::`+`
[16:12:31.980]             `<<-` <- base::`<<-`
[16:12:31.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:31.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:31.980]                   3L)]
[16:12:31.980]             }
[16:12:31.980]             function(cond) {
[16:12:31.980]                 is_error <- inherits(cond, "error")
[16:12:31.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:31.980]                   NULL)
[16:12:31.980]                 if (is_error) {
[16:12:31.980]                   sessionInformation <- function() {
[16:12:31.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:31.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:31.980]                       search = base::search(), system = base::Sys.info())
[16:12:31.980]                   }
[16:12:31.980]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:31.980]                     cond$call), session = sessionInformation(), 
[16:12:31.980]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:31.980]                   signalCondition(cond)
[16:12:31.980]                 }
[16:12:31.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:31.980]                 "immediateCondition"))) {
[16:12:31.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:31.980]                   ...future.conditions[[length(...future.conditions) + 
[16:12:31.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:31.980]                   if (TRUE && !signal) {
[16:12:31.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.980]                     {
[16:12:31.980]                       inherits <- base::inherits
[16:12:31.980]                       invokeRestart <- base::invokeRestart
[16:12:31.980]                       is.null <- base::is.null
[16:12:31.980]                       muffled <- FALSE
[16:12:31.980]                       if (inherits(cond, "message")) {
[16:12:31.980]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.980]                         if (muffled) 
[16:12:31.980]                           invokeRestart("muffleMessage")
[16:12:31.980]                       }
[16:12:31.980]                       else if (inherits(cond, "warning")) {
[16:12:31.980]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.980]                         if (muffled) 
[16:12:31.980]                           invokeRestart("muffleWarning")
[16:12:31.980]                       }
[16:12:31.980]                       else if (inherits(cond, "condition")) {
[16:12:31.980]                         if (!is.null(pattern)) {
[16:12:31.980]                           computeRestarts <- base::computeRestarts
[16:12:31.980]                           grepl <- base::grepl
[16:12:31.980]                           restarts <- computeRestarts(cond)
[16:12:31.980]                           for (restart in restarts) {
[16:12:31.980]                             name <- restart$name
[16:12:31.980]                             if (is.null(name)) 
[16:12:31.980]                               next
[16:12:31.980]                             if (!grepl(pattern, name)) 
[16:12:31.980]                               next
[16:12:31.980]                             invokeRestart(restart)
[16:12:31.980]                             muffled <- TRUE
[16:12:31.980]                             break
[16:12:31.980]                           }
[16:12:31.980]                         }
[16:12:31.980]                       }
[16:12:31.980]                       invisible(muffled)
[16:12:31.980]                     }
[16:12:31.980]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.980]                   }
[16:12:31.980]                 }
[16:12:31.980]                 else {
[16:12:31.980]                   if (TRUE) {
[16:12:31.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:31.980]                     {
[16:12:31.980]                       inherits <- base::inherits
[16:12:31.980]                       invokeRestart <- base::invokeRestart
[16:12:31.980]                       is.null <- base::is.null
[16:12:31.980]                       muffled <- FALSE
[16:12:31.980]                       if (inherits(cond, "message")) {
[16:12:31.980]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:31.980]                         if (muffled) 
[16:12:31.980]                           invokeRestart("muffleMessage")
[16:12:31.980]                       }
[16:12:31.980]                       else if (inherits(cond, "warning")) {
[16:12:31.980]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:31.980]                         if (muffled) 
[16:12:31.980]                           invokeRestart("muffleWarning")
[16:12:31.980]                       }
[16:12:31.980]                       else if (inherits(cond, "condition")) {
[16:12:31.980]                         if (!is.null(pattern)) {
[16:12:31.980]                           computeRestarts <- base::computeRestarts
[16:12:31.980]                           grepl <- base::grepl
[16:12:31.980]                           restarts <- computeRestarts(cond)
[16:12:31.980]                           for (restart in restarts) {
[16:12:31.980]                             name <- restart$name
[16:12:31.980]                             if (is.null(name)) 
[16:12:31.980]                               next
[16:12:31.980]                             if (!grepl(pattern, name)) 
[16:12:31.980]                               next
[16:12:31.980]                             invokeRestart(restart)
[16:12:31.980]                             muffled <- TRUE
[16:12:31.980]                             break
[16:12:31.980]                           }
[16:12:31.980]                         }
[16:12:31.980]                       }
[16:12:31.980]                       invisible(muffled)
[16:12:31.980]                     }
[16:12:31.980]                     muffleCondition(cond, pattern = "^muffle")
[16:12:31.980]                   }
[16:12:31.980]                 }
[16:12:31.980]             }
[16:12:31.980]         }))
[16:12:31.980]     }, error = function(ex) {
[16:12:31.980]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:31.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:31.980]                 ...future.rng), started = ...future.startTime, 
[16:12:31.980]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:31.980]             version = "1.8"), class = "FutureResult")
[16:12:31.980]     }, finally = {
[16:12:31.980]         if (!identical(...future.workdir, getwd())) 
[16:12:31.980]             setwd(...future.workdir)
[16:12:31.980]         {
[16:12:31.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:31.980]                 ...future.oldOptions$nwarnings <- NULL
[16:12:31.980]             }
[16:12:31.980]             base::options(...future.oldOptions)
[16:12:31.980]             if (.Platform$OS.type == "windows") {
[16:12:31.980]                 old_names <- names(...future.oldEnvVars)
[16:12:31.980]                 envs <- base::Sys.getenv()
[16:12:31.980]                 names <- names(envs)
[16:12:31.980]                 common <- intersect(names, old_names)
[16:12:31.980]                 added <- setdiff(names, old_names)
[16:12:31.980]                 removed <- setdiff(old_names, names)
[16:12:31.980]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:31.980]                   envs[common]]
[16:12:31.980]                 NAMES <- toupper(changed)
[16:12:31.980]                 args <- list()
[16:12:31.980]                 for (kk in seq_along(NAMES)) {
[16:12:31.980]                   name <- changed[[kk]]
[16:12:31.980]                   NAME <- NAMES[[kk]]
[16:12:31.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.980]                     next
[16:12:31.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.980]                 }
[16:12:31.980]                 NAMES <- toupper(added)
[16:12:31.980]                 for (kk in seq_along(NAMES)) {
[16:12:31.980]                   name <- added[[kk]]
[16:12:31.980]                   NAME <- NAMES[[kk]]
[16:12:31.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.980]                     next
[16:12:31.980]                   args[[name]] <- ""
[16:12:31.980]                 }
[16:12:31.980]                 NAMES <- toupper(removed)
[16:12:31.980]                 for (kk in seq_along(NAMES)) {
[16:12:31.980]                   name <- removed[[kk]]
[16:12:31.980]                   NAME <- NAMES[[kk]]
[16:12:31.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:31.980]                     next
[16:12:31.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:31.980]                 }
[16:12:31.980]                 if (length(args) > 0) 
[16:12:31.980]                   base::do.call(base::Sys.setenv, args = args)
[16:12:31.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:31.980]             }
[16:12:31.980]             else {
[16:12:31.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:31.980]             }
[16:12:31.980]             {
[16:12:31.980]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:31.980]                   0L) {
[16:12:31.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:31.980]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:31.980]                   base::options(opts)
[16:12:31.980]                 }
[16:12:31.980]                 {
[16:12:31.980]                   {
[16:12:31.980]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:31.980]                     NULL
[16:12:31.980]                   }
[16:12:31.980]                   options(future.plan = NULL)
[16:12:31.980]                   if (is.na(NA_character_)) 
[16:12:31.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:31.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:31.980]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:31.980]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:31.980]                     envir = parent.frame()) 
[16:12:31.980]                   {
[16:12:31.980]                     if (is.function(workers)) 
[16:12:31.980]                       workers <- workers()
[16:12:31.980]                     workers <- structure(as.integer(workers), 
[16:12:31.980]                       class = class(workers))
[16:12:31.980]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:31.980]                       workers >= 1)
[16:12:31.980]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:31.980]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:31.980]                     }
[16:12:31.980]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:31.980]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:31.980]                       envir = envir)
[16:12:31.980]                     if (!future$lazy) 
[16:12:31.980]                       future <- run(future)
[16:12:31.980]                     invisible(future)
[16:12:31.980]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:31.980]                 }
[16:12:31.980]             }
[16:12:31.980]         }
[16:12:31.980]     })
[16:12:31.980]     if (TRUE) {
[16:12:31.980]         base::sink(type = "output", split = FALSE)
[16:12:31.980]         if (TRUE) {
[16:12:31.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:31.980]         }
[16:12:31.980]         else {
[16:12:31.980]             ...future.result["stdout"] <- base::list(NULL)
[16:12:31.980]         }
[16:12:31.980]         base::close(...future.stdout)
[16:12:31.980]         ...future.stdout <- NULL
[16:12:31.980]     }
[16:12:31.980]     ...future.result$conditions <- ...future.conditions
[16:12:31.980]     ...future.result$finished <- base::Sys.time()
[16:12:31.980]     ...future.result
[16:12:31.980] }
[16:12:31.983] MultisessionFuture started
[16:12:31.983] - Launch lazy future ... done
[16:12:31.984] run() for ‘MultisessionFuture’ ... done
[16:12:31.984] getGlobalsAndPackages() ...
[16:12:31.984] Searching for globals...
[16:12:31.984] 
[16:12:31.984] Searching for globals ... DONE
[16:12:31.984] - globals: [0] <none>
[16:12:31.984] getGlobalsAndPackages() ... DONE
[16:12:31.985] run() for ‘Future’ ...
[16:12:31.985] - state: ‘created’
[16:12:31.985] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:31.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:31.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:31.999]   - Field: ‘node’
[16:12:31.999]   - Field: ‘label’
[16:12:32.000]   - Field: ‘local’
[16:12:32.000]   - Field: ‘owner’
[16:12:32.000]   - Field: ‘envir’
[16:12:32.000]   - Field: ‘workers’
[16:12:32.000]   - Field: ‘packages’
[16:12:32.000]   - Field: ‘gc’
[16:12:32.000]   - Field: ‘conditions’
[16:12:32.000]   - Field: ‘persistent’
[16:12:32.000]   - Field: ‘expr’
[16:12:32.000]   - Field: ‘uuid’
[16:12:32.000]   - Field: ‘seed’
[16:12:32.001]   - Field: ‘version’
[16:12:32.001]   - Field: ‘result’
[16:12:32.001]   - Field: ‘asynchronous’
[16:12:32.001]   - Field: ‘calls’
[16:12:32.001]   - Field: ‘globals’
[16:12:32.001]   - Field: ‘stdout’
[16:12:32.001]   - Field: ‘earlySignal’
[16:12:32.001]   - Field: ‘lazy’
[16:12:32.001]   - Field: ‘state’
[16:12:32.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:32.002] - Launch lazy future ...
[16:12:32.002] Packages needed by the future expression (n = 0): <none>
[16:12:32.002] Packages needed by future strategies (n = 0): <none>
[16:12:32.002] {
[16:12:32.002]     {
[16:12:32.002]         {
[16:12:32.002]             ...future.startTime <- base::Sys.time()
[16:12:32.002]             {
[16:12:32.002]                 {
[16:12:32.002]                   {
[16:12:32.002]                     {
[16:12:32.002]                       base::local({
[16:12:32.002]                         has_future <- base::requireNamespace("future", 
[16:12:32.002]                           quietly = TRUE)
[16:12:32.002]                         if (has_future) {
[16:12:32.002]                           ns <- base::getNamespace("future")
[16:12:32.002]                           version <- ns[[".package"]][["version"]]
[16:12:32.002]                           if (is.null(version)) 
[16:12:32.002]                             version <- utils::packageVersion("future")
[16:12:32.002]                         }
[16:12:32.002]                         else {
[16:12:32.002]                           version <- NULL
[16:12:32.002]                         }
[16:12:32.002]                         if (!has_future || version < "1.8.0") {
[16:12:32.002]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.002]                             "", base::R.version$version.string), 
[16:12:32.002]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.002]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.002]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.002]                               "release", "version")], collapse = " "), 
[16:12:32.002]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.002]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.002]                             info)
[16:12:32.002]                           info <- base::paste(info, collapse = "; ")
[16:12:32.002]                           if (!has_future) {
[16:12:32.002]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.002]                               info)
[16:12:32.002]                           }
[16:12:32.002]                           else {
[16:12:32.002]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.002]                               info, version)
[16:12:32.002]                           }
[16:12:32.002]                           base::stop(msg)
[16:12:32.002]                         }
[16:12:32.002]                       })
[16:12:32.002]                     }
[16:12:32.002]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:32.002]                     base::options(mc.cores = 1L)
[16:12:32.002]                   }
[16:12:32.002]                   options(future.plan = NULL)
[16:12:32.002]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.002]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.002]                 }
[16:12:32.002]                 ...future.workdir <- getwd()
[16:12:32.002]             }
[16:12:32.002]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.002]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.002]         }
[16:12:32.002]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.002]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.002]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.002]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.002]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.002]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.002]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.002]             base::names(...future.oldOptions))
[16:12:32.002]     }
[16:12:32.002]     if (FALSE) {
[16:12:32.002]     }
[16:12:32.002]     else {
[16:12:32.002]         if (TRUE) {
[16:12:32.002]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.002]                 open = "w")
[16:12:32.002]         }
[16:12:32.002]         else {
[16:12:32.002]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.002]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.002]         }
[16:12:32.002]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.002]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.002]             base::sink(type = "output", split = FALSE)
[16:12:32.002]             base::close(...future.stdout)
[16:12:32.002]         }, add = TRUE)
[16:12:32.002]     }
[16:12:32.002]     ...future.frame <- base::sys.nframe()
[16:12:32.002]     ...future.conditions <- base::list()
[16:12:32.002]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.002]     if (FALSE) {
[16:12:32.002]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.002]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.002]     }
[16:12:32.002]     ...future.result <- base::tryCatch({
[16:12:32.002]         base::withCallingHandlers({
[16:12:32.002]             ...future.value <- base::withVisible(base::local({
[16:12:32.002]                 ...future.makeSendCondition <- local({
[16:12:32.002]                   sendCondition <- NULL
[16:12:32.002]                   function(frame = 1L) {
[16:12:32.002]                     if (is.function(sendCondition)) 
[16:12:32.002]                       return(sendCondition)
[16:12:32.002]                     ns <- getNamespace("parallel")
[16:12:32.002]                     if (exists("sendData", mode = "function", 
[16:12:32.002]                       envir = ns)) {
[16:12:32.002]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:32.002]                         envir = ns)
[16:12:32.002]                       envir <- sys.frame(frame)
[16:12:32.002]                       master <- NULL
[16:12:32.002]                       while (!identical(envir, .GlobalEnv) && 
[16:12:32.002]                         !identical(envir, emptyenv())) {
[16:12:32.002]                         if (exists("master", mode = "list", envir = envir, 
[16:12:32.002]                           inherits = FALSE)) {
[16:12:32.002]                           master <- get("master", mode = "list", 
[16:12:32.002]                             envir = envir, inherits = FALSE)
[16:12:32.002]                           if (inherits(master, c("SOCKnode", 
[16:12:32.002]                             "SOCK0node"))) {
[16:12:32.002]                             sendCondition <<- function(cond) {
[16:12:32.002]                               data <- list(type = "VALUE", value = cond, 
[16:12:32.002]                                 success = TRUE)
[16:12:32.002]                               parallel_sendData(master, data)
[16:12:32.002]                             }
[16:12:32.002]                             return(sendCondition)
[16:12:32.002]                           }
[16:12:32.002]                         }
[16:12:32.002]                         frame <- frame + 1L
[16:12:32.002]                         envir <- sys.frame(frame)
[16:12:32.002]                       }
[16:12:32.002]                     }
[16:12:32.002]                     sendCondition <<- function(cond) NULL
[16:12:32.002]                   }
[16:12:32.002]                 })
[16:12:32.002]                 withCallingHandlers({
[16:12:32.002]                   NULL
[16:12:32.002]                 }, immediateCondition = function(cond) {
[16:12:32.002]                   sendCondition <- ...future.makeSendCondition()
[16:12:32.002]                   sendCondition(cond)
[16:12:32.002]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.002]                   {
[16:12:32.002]                     inherits <- base::inherits
[16:12:32.002]                     invokeRestart <- base::invokeRestart
[16:12:32.002]                     is.null <- base::is.null
[16:12:32.002]                     muffled <- FALSE
[16:12:32.002]                     if (inherits(cond, "message")) {
[16:12:32.002]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:32.002]                       if (muffled) 
[16:12:32.002]                         invokeRestart("muffleMessage")
[16:12:32.002]                     }
[16:12:32.002]                     else if (inherits(cond, "warning")) {
[16:12:32.002]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:32.002]                       if (muffled) 
[16:12:32.002]                         invokeRestart("muffleWarning")
[16:12:32.002]                     }
[16:12:32.002]                     else if (inherits(cond, "condition")) {
[16:12:32.002]                       if (!is.null(pattern)) {
[16:12:32.002]                         computeRestarts <- base::computeRestarts
[16:12:32.002]                         grepl <- base::grepl
[16:12:32.002]                         restarts <- computeRestarts(cond)
[16:12:32.002]                         for (restart in restarts) {
[16:12:32.002]                           name <- restart$name
[16:12:32.002]                           if (is.null(name)) 
[16:12:32.002]                             next
[16:12:32.002]                           if (!grepl(pattern, name)) 
[16:12:32.002]                             next
[16:12:32.002]                           invokeRestart(restart)
[16:12:32.002]                           muffled <- TRUE
[16:12:32.002]                           break
[16:12:32.002]                         }
[16:12:32.002]                       }
[16:12:32.002]                     }
[16:12:32.002]                     invisible(muffled)
[16:12:32.002]                   }
[16:12:32.002]                   muffleCondition(cond)
[16:12:32.002]                 })
[16:12:32.002]             }))
[16:12:32.002]             future::FutureResult(value = ...future.value$value, 
[16:12:32.002]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.002]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.002]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.002]                     ...future.globalenv.names))
[16:12:32.002]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.002]         }, condition = base::local({
[16:12:32.002]             c <- base::c
[16:12:32.002]             inherits <- base::inherits
[16:12:32.002]             invokeRestart <- base::invokeRestart
[16:12:32.002]             length <- base::length
[16:12:32.002]             list <- base::list
[16:12:32.002]             seq.int <- base::seq.int
[16:12:32.002]             signalCondition <- base::signalCondition
[16:12:32.002]             sys.calls <- base::sys.calls
[16:12:32.002]             `[[` <- base::`[[`
[16:12:32.002]             `+` <- base::`+`
[16:12:32.002]             `<<-` <- base::`<<-`
[16:12:32.002]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.002]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.002]                   3L)]
[16:12:32.002]             }
[16:12:32.002]             function(cond) {
[16:12:32.002]                 is_error <- inherits(cond, "error")
[16:12:32.002]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.002]                   NULL)
[16:12:32.002]                 if (is_error) {
[16:12:32.002]                   sessionInformation <- function() {
[16:12:32.002]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.002]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.002]                       search = base::search(), system = base::Sys.info())
[16:12:32.002]                   }
[16:12:32.002]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.002]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.002]                     cond$call), session = sessionInformation(), 
[16:12:32.002]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.002]                   signalCondition(cond)
[16:12:32.002]                 }
[16:12:32.002]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.002]                 "immediateCondition"))) {
[16:12:32.002]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.002]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.002]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.002]                   if (TRUE && !signal) {
[16:12:32.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.002]                     {
[16:12:32.002]                       inherits <- base::inherits
[16:12:32.002]                       invokeRestart <- base::invokeRestart
[16:12:32.002]                       is.null <- base::is.null
[16:12:32.002]                       muffled <- FALSE
[16:12:32.002]                       if (inherits(cond, "message")) {
[16:12:32.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.002]                         if (muffled) 
[16:12:32.002]                           invokeRestart("muffleMessage")
[16:12:32.002]                       }
[16:12:32.002]                       else if (inherits(cond, "warning")) {
[16:12:32.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.002]                         if (muffled) 
[16:12:32.002]                           invokeRestart("muffleWarning")
[16:12:32.002]                       }
[16:12:32.002]                       else if (inherits(cond, "condition")) {
[16:12:32.002]                         if (!is.null(pattern)) {
[16:12:32.002]                           computeRestarts <- base::computeRestarts
[16:12:32.002]                           grepl <- base::grepl
[16:12:32.002]                           restarts <- computeRestarts(cond)
[16:12:32.002]                           for (restart in restarts) {
[16:12:32.002]                             name <- restart$name
[16:12:32.002]                             if (is.null(name)) 
[16:12:32.002]                               next
[16:12:32.002]                             if (!grepl(pattern, name)) 
[16:12:32.002]                               next
[16:12:32.002]                             invokeRestart(restart)
[16:12:32.002]                             muffled <- TRUE
[16:12:32.002]                             break
[16:12:32.002]                           }
[16:12:32.002]                         }
[16:12:32.002]                       }
[16:12:32.002]                       invisible(muffled)
[16:12:32.002]                     }
[16:12:32.002]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.002]                   }
[16:12:32.002]                 }
[16:12:32.002]                 else {
[16:12:32.002]                   if (TRUE) {
[16:12:32.002]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.002]                     {
[16:12:32.002]                       inherits <- base::inherits
[16:12:32.002]                       invokeRestart <- base::invokeRestart
[16:12:32.002]                       is.null <- base::is.null
[16:12:32.002]                       muffled <- FALSE
[16:12:32.002]                       if (inherits(cond, "message")) {
[16:12:32.002]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.002]                         if (muffled) 
[16:12:32.002]                           invokeRestart("muffleMessage")
[16:12:32.002]                       }
[16:12:32.002]                       else if (inherits(cond, "warning")) {
[16:12:32.002]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.002]                         if (muffled) 
[16:12:32.002]                           invokeRestart("muffleWarning")
[16:12:32.002]                       }
[16:12:32.002]                       else if (inherits(cond, "condition")) {
[16:12:32.002]                         if (!is.null(pattern)) {
[16:12:32.002]                           computeRestarts <- base::computeRestarts
[16:12:32.002]                           grepl <- base::grepl
[16:12:32.002]                           restarts <- computeRestarts(cond)
[16:12:32.002]                           for (restart in restarts) {
[16:12:32.002]                             name <- restart$name
[16:12:32.002]                             if (is.null(name)) 
[16:12:32.002]                               next
[16:12:32.002]                             if (!grepl(pattern, name)) 
[16:12:32.002]                               next
[16:12:32.002]                             invokeRestart(restart)
[16:12:32.002]                             muffled <- TRUE
[16:12:32.002]                             break
[16:12:32.002]                           }
[16:12:32.002]                         }
[16:12:32.002]                       }
[16:12:32.002]                       invisible(muffled)
[16:12:32.002]                     }
[16:12:32.002]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.002]                   }
[16:12:32.002]                 }
[16:12:32.002]             }
[16:12:32.002]         }))
[16:12:32.002]     }, error = function(ex) {
[16:12:32.002]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.002]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.002]                 ...future.rng), started = ...future.startTime, 
[16:12:32.002]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.002]             version = "1.8"), class = "FutureResult")
[16:12:32.002]     }, finally = {
[16:12:32.002]         if (!identical(...future.workdir, getwd())) 
[16:12:32.002]             setwd(...future.workdir)
[16:12:32.002]         {
[16:12:32.002]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.002]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.002]             }
[16:12:32.002]             base::options(...future.oldOptions)
[16:12:32.002]             if (.Platform$OS.type == "windows") {
[16:12:32.002]                 old_names <- names(...future.oldEnvVars)
[16:12:32.002]                 envs <- base::Sys.getenv()
[16:12:32.002]                 names <- names(envs)
[16:12:32.002]                 common <- intersect(names, old_names)
[16:12:32.002]                 added <- setdiff(names, old_names)
[16:12:32.002]                 removed <- setdiff(old_names, names)
[16:12:32.002]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.002]                   envs[common]]
[16:12:32.002]                 NAMES <- toupper(changed)
[16:12:32.002]                 args <- list()
[16:12:32.002]                 for (kk in seq_along(NAMES)) {
[16:12:32.002]                   name <- changed[[kk]]
[16:12:32.002]                   NAME <- NAMES[[kk]]
[16:12:32.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.002]                     next
[16:12:32.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.002]                 }
[16:12:32.002]                 NAMES <- toupper(added)
[16:12:32.002]                 for (kk in seq_along(NAMES)) {
[16:12:32.002]                   name <- added[[kk]]
[16:12:32.002]                   NAME <- NAMES[[kk]]
[16:12:32.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.002]                     next
[16:12:32.002]                   args[[name]] <- ""
[16:12:32.002]                 }
[16:12:32.002]                 NAMES <- toupper(removed)
[16:12:32.002]                 for (kk in seq_along(NAMES)) {
[16:12:32.002]                   name <- removed[[kk]]
[16:12:32.002]                   NAME <- NAMES[[kk]]
[16:12:32.002]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.002]                     next
[16:12:32.002]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.002]                 }
[16:12:32.002]                 if (length(args) > 0) 
[16:12:32.002]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.002]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.002]             }
[16:12:32.002]             else {
[16:12:32.002]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.002]             }
[16:12:32.002]             {
[16:12:32.002]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.002]                   0L) {
[16:12:32.002]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.002]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.002]                   base::options(opts)
[16:12:32.002]                 }
[16:12:32.002]                 {
[16:12:32.002]                   {
[16:12:32.002]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:32.002]                     NULL
[16:12:32.002]                   }
[16:12:32.002]                   options(future.plan = NULL)
[16:12:32.002]                   if (is.na(NA_character_)) 
[16:12:32.002]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.002]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.002]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:32.002]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:32.002]                     envir = parent.frame()) 
[16:12:32.002]                   {
[16:12:32.002]                     if (is.function(workers)) 
[16:12:32.002]                       workers <- workers()
[16:12:32.002]                     workers <- structure(as.integer(workers), 
[16:12:32.002]                       class = class(workers))
[16:12:32.002]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:32.002]                       workers >= 1)
[16:12:32.002]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:32.002]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:32.002]                     }
[16:12:32.002]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:32.002]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:32.002]                       envir = envir)
[16:12:32.002]                     if (!future$lazy) 
[16:12:32.002]                       future <- run(future)
[16:12:32.002]                     invisible(future)
[16:12:32.002]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.002]                 }
[16:12:32.002]             }
[16:12:32.002]         }
[16:12:32.002]     })
[16:12:32.002]     if (TRUE) {
[16:12:32.002]         base::sink(type = "output", split = FALSE)
[16:12:32.002]         if (TRUE) {
[16:12:32.002]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.002]         }
[16:12:32.002]         else {
[16:12:32.002]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.002]         }
[16:12:32.002]         base::close(...future.stdout)
[16:12:32.002]         ...future.stdout <- NULL
[16:12:32.002]     }
[16:12:32.002]     ...future.result$conditions <- ...future.conditions
[16:12:32.002]     ...future.result$finished <- base::Sys.time()
[16:12:32.002]     ...future.result
[16:12:32.002] }
[16:12:32.005] MultisessionFuture started
[16:12:32.006] - Launch lazy future ... done
[16:12:32.006] run() for ‘MultisessionFuture’ ... done
[16:12:32.006] getGlobalsAndPackages() ...
[16:12:32.006] Searching for globals...
[16:12:32.007] - globals found: [1] ‘{’
[16:12:32.007] Searching for globals ... DONE
[16:12:32.007] Resolving globals: FALSE
[16:12:32.007] 
[16:12:32.007] 
[16:12:32.007] getGlobalsAndPackages() ... DONE
[16:12:32.008] run() for ‘Future’ ...
[16:12:32.008] - state: ‘created’
[16:12:32.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:12:32.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:12:32.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:12:32.025]   - Field: ‘node’
[16:12:32.026]   - Field: ‘label’
[16:12:32.026]   - Field: ‘local’
[16:12:32.026]   - Field: ‘owner’
[16:12:32.026]   - Field: ‘envir’
[16:12:32.026]   - Field: ‘workers’
[16:12:32.026]   - Field: ‘packages’
[16:12:32.026]   - Field: ‘gc’
[16:12:32.026]   - Field: ‘conditions’
[16:12:32.026]   - Field: ‘persistent’
[16:12:32.027]   - Field: ‘expr’
[16:12:32.027]   - Field: ‘uuid’
[16:12:32.027]   - Field: ‘seed’
[16:12:32.027]   - Field: ‘version’
[16:12:32.027]   - Field: ‘result’
[16:12:32.027]   - Field: ‘asynchronous’
[16:12:32.027]   - Field: ‘calls’
[16:12:32.027]   - Field: ‘globals’
[16:12:32.027]   - Field: ‘stdout’
[16:12:32.027]   - Field: ‘earlySignal’
[16:12:32.027]   - Field: ‘lazy’
[16:12:32.028]   - Field: ‘state’
[16:12:32.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:12:32.028] - Launch lazy future ...
[16:12:32.028] Packages needed by the future expression (n = 0): <none>
[16:12:32.028] Packages needed by future strategies (n = 0): <none>
[16:12:32.029] {
[16:12:32.029]     {
[16:12:32.029]         {
[16:12:32.029]             ...future.startTime <- base::Sys.time()
[16:12:32.029]             {
[16:12:32.029]                 {
[16:12:32.029]                   {
[16:12:32.029]                     {
[16:12:32.029]                       base::local({
[16:12:32.029]                         has_future <- base::requireNamespace("future", 
[16:12:32.029]                           quietly = TRUE)
[16:12:32.029]                         if (has_future) {
[16:12:32.029]                           ns <- base::getNamespace("future")
[16:12:32.029]                           version <- ns[[".package"]][["version"]]
[16:12:32.029]                           if (is.null(version)) 
[16:12:32.029]                             version <- utils::packageVersion("future")
[16:12:32.029]                         }
[16:12:32.029]                         else {
[16:12:32.029]                           version <- NULL
[16:12:32.029]                         }
[16:12:32.029]                         if (!has_future || version < "1.8.0") {
[16:12:32.029]                           info <- base::c(r_version = base::gsub("R version ", 
[16:12:32.029]                             "", base::R.version$version.string), 
[16:12:32.029]                             platform = base::sprintf("%s (%s-bit)", 
[16:12:32.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:12:32.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:12:32.029]                               "release", "version")], collapse = " "), 
[16:12:32.029]                             hostname = base::Sys.info()[["nodename"]])
[16:12:32.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:12:32.029]                             info)
[16:12:32.029]                           info <- base::paste(info, collapse = "; ")
[16:12:32.029]                           if (!has_future) {
[16:12:32.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:12:32.029]                               info)
[16:12:32.029]                           }
[16:12:32.029]                           else {
[16:12:32.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:12:32.029]                               info, version)
[16:12:32.029]                           }
[16:12:32.029]                           base::stop(msg)
[16:12:32.029]                         }
[16:12:32.029]                       })
[16:12:32.029]                     }
[16:12:32.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:12:32.029]                     base::options(mc.cores = 1L)
[16:12:32.029]                   }
[16:12:32.029]                   options(future.plan = NULL)
[16:12:32.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:12:32.029]                 }
[16:12:32.029]                 ...future.workdir <- getwd()
[16:12:32.029]             }
[16:12:32.029]             ...future.oldOptions <- base::as.list(base::.Options)
[16:12:32.029]             ...future.oldEnvVars <- base::Sys.getenv()
[16:12:32.029]         }
[16:12:32.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:12:32.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:12:32.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:12:32.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:12:32.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:12:32.029]             future.stdout.windows.reencode = NULL, width = 80L)
[16:12:32.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:12:32.029]             base::names(...future.oldOptions))
[16:12:32.029]     }
[16:12:32.029]     if (FALSE) {
[16:12:32.029]     }
[16:12:32.029]     else {
[16:12:32.029]         if (TRUE) {
[16:12:32.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:12:32.029]                 open = "w")
[16:12:32.029]         }
[16:12:32.029]         else {
[16:12:32.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:12:32.029]                 windows = "NUL", "/dev/null"), open = "w")
[16:12:32.029]         }
[16:12:32.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:12:32.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:12:32.029]             base::sink(type = "output", split = FALSE)
[16:12:32.029]             base::close(...future.stdout)
[16:12:32.029]         }, add = TRUE)
[16:12:32.029]     }
[16:12:32.029]     ...future.frame <- base::sys.nframe()
[16:12:32.029]     ...future.conditions <- base::list()
[16:12:32.029]     ...future.rng <- base::globalenv()$.Random.seed
[16:12:32.029]     if (FALSE) {
[16:12:32.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:12:32.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:12:32.029]     }
[16:12:32.029]     ...future.result <- base::tryCatch({
[16:12:32.029]         base::withCallingHandlers({
[16:12:32.029]             ...future.value <- base::withVisible(base::local({
[16:12:32.029]                 ...future.makeSendCondition <- local({
[16:12:32.029]                   sendCondition <- NULL
[16:12:32.029]                   function(frame = 1L) {
[16:12:32.029]                     if (is.function(sendCondition)) 
[16:12:32.029]                       return(sendCondition)
[16:12:32.029]                     ns <- getNamespace("parallel")
[16:12:32.029]                     if (exists("sendData", mode = "function", 
[16:12:32.029]                       envir = ns)) {
[16:12:32.029]                       parallel_sendData <- get("sendData", mode = "function", 
[16:12:32.029]                         envir = ns)
[16:12:32.029]                       envir <- sys.frame(frame)
[16:12:32.029]                       master <- NULL
[16:12:32.029]                       while (!identical(envir, .GlobalEnv) && 
[16:12:32.029]                         !identical(envir, emptyenv())) {
[16:12:32.029]                         if (exists("master", mode = "list", envir = envir, 
[16:12:32.029]                           inherits = FALSE)) {
[16:12:32.029]                           master <- get("master", mode = "list", 
[16:12:32.029]                             envir = envir, inherits = FALSE)
[16:12:32.029]                           if (inherits(master, c("SOCKnode", 
[16:12:32.029]                             "SOCK0node"))) {
[16:12:32.029]                             sendCondition <<- function(cond) {
[16:12:32.029]                               data <- list(type = "VALUE", value = cond, 
[16:12:32.029]                                 success = TRUE)
[16:12:32.029]                               parallel_sendData(master, data)
[16:12:32.029]                             }
[16:12:32.029]                             return(sendCondition)
[16:12:32.029]                           }
[16:12:32.029]                         }
[16:12:32.029]                         frame <- frame + 1L
[16:12:32.029]                         envir <- sys.frame(frame)
[16:12:32.029]                       }
[16:12:32.029]                     }
[16:12:32.029]                     sendCondition <<- function(cond) NULL
[16:12:32.029]                   }
[16:12:32.029]                 })
[16:12:32.029]                 withCallingHandlers({
[16:12:32.029]                   {
[16:12:32.029]                     4
[16:12:32.029]                   }
[16:12:32.029]                 }, immediateCondition = function(cond) {
[16:12:32.029]                   sendCondition <- ...future.makeSendCondition()
[16:12:32.029]                   sendCondition(cond)
[16:12:32.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.029]                   {
[16:12:32.029]                     inherits <- base::inherits
[16:12:32.029]                     invokeRestart <- base::invokeRestart
[16:12:32.029]                     is.null <- base::is.null
[16:12:32.029]                     muffled <- FALSE
[16:12:32.029]                     if (inherits(cond, "message")) {
[16:12:32.029]                       muffled <- grepl(pattern, "muffleMessage")
[16:12:32.029]                       if (muffled) 
[16:12:32.029]                         invokeRestart("muffleMessage")
[16:12:32.029]                     }
[16:12:32.029]                     else if (inherits(cond, "warning")) {
[16:12:32.029]                       muffled <- grepl(pattern, "muffleWarning")
[16:12:32.029]                       if (muffled) 
[16:12:32.029]                         invokeRestart("muffleWarning")
[16:12:32.029]                     }
[16:12:32.029]                     else if (inherits(cond, "condition")) {
[16:12:32.029]                       if (!is.null(pattern)) {
[16:12:32.029]                         computeRestarts <- base::computeRestarts
[16:12:32.029]                         grepl <- base::grepl
[16:12:32.029]                         restarts <- computeRestarts(cond)
[16:12:32.029]                         for (restart in restarts) {
[16:12:32.029]                           name <- restart$name
[16:12:32.029]                           if (is.null(name)) 
[16:12:32.029]                             next
[16:12:32.029]                           if (!grepl(pattern, name)) 
[16:12:32.029]                             next
[16:12:32.029]                           invokeRestart(restart)
[16:12:32.029]                           muffled <- TRUE
[16:12:32.029]                           break
[16:12:32.029]                         }
[16:12:32.029]                       }
[16:12:32.029]                     }
[16:12:32.029]                     invisible(muffled)
[16:12:32.029]                   }
[16:12:32.029]                   muffleCondition(cond)
[16:12:32.029]                 })
[16:12:32.029]             }))
[16:12:32.029]             future::FutureResult(value = ...future.value$value, 
[16:12:32.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.029]                   ...future.rng), globalenv = if (FALSE) 
[16:12:32.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:12:32.029]                     ...future.globalenv.names))
[16:12:32.029]                 else NULL, started = ...future.startTime, version = "1.8")
[16:12:32.029]         }, condition = base::local({
[16:12:32.029]             c <- base::c
[16:12:32.029]             inherits <- base::inherits
[16:12:32.029]             invokeRestart <- base::invokeRestart
[16:12:32.029]             length <- base::length
[16:12:32.029]             list <- base::list
[16:12:32.029]             seq.int <- base::seq.int
[16:12:32.029]             signalCondition <- base::signalCondition
[16:12:32.029]             sys.calls <- base::sys.calls
[16:12:32.029]             `[[` <- base::`[[`
[16:12:32.029]             `+` <- base::`+`
[16:12:32.029]             `<<-` <- base::`<<-`
[16:12:32.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:12:32.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:12:32.029]                   3L)]
[16:12:32.029]             }
[16:12:32.029]             function(cond) {
[16:12:32.029]                 is_error <- inherits(cond, "error")
[16:12:32.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:12:32.029]                   NULL)
[16:12:32.029]                 if (is_error) {
[16:12:32.029]                   sessionInformation <- function() {
[16:12:32.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:12:32.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:12:32.029]                       search = base::search(), system = base::Sys.info())
[16:12:32.029]                   }
[16:12:32.029]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:12:32.029]                     cond$call), session = sessionInformation(), 
[16:12:32.029]                     timestamp = base::Sys.time(), signaled = 0L)
[16:12:32.029]                   signalCondition(cond)
[16:12:32.029]                 }
[16:12:32.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:12:32.029]                 "immediateCondition"))) {
[16:12:32.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:12:32.029]                   ...future.conditions[[length(...future.conditions) + 
[16:12:32.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:12:32.029]                   if (TRUE && !signal) {
[16:12:32.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.029]                     {
[16:12:32.029]                       inherits <- base::inherits
[16:12:32.029]                       invokeRestart <- base::invokeRestart
[16:12:32.029]                       is.null <- base::is.null
[16:12:32.029]                       muffled <- FALSE
[16:12:32.029]                       if (inherits(cond, "message")) {
[16:12:32.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.029]                         if (muffled) 
[16:12:32.029]                           invokeRestart("muffleMessage")
[16:12:32.029]                       }
[16:12:32.029]                       else if (inherits(cond, "warning")) {
[16:12:32.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.029]                         if (muffled) 
[16:12:32.029]                           invokeRestart("muffleWarning")
[16:12:32.029]                       }
[16:12:32.029]                       else if (inherits(cond, "condition")) {
[16:12:32.029]                         if (!is.null(pattern)) {
[16:12:32.029]                           computeRestarts <- base::computeRestarts
[16:12:32.029]                           grepl <- base::grepl
[16:12:32.029]                           restarts <- computeRestarts(cond)
[16:12:32.029]                           for (restart in restarts) {
[16:12:32.029]                             name <- restart$name
[16:12:32.029]                             if (is.null(name)) 
[16:12:32.029]                               next
[16:12:32.029]                             if (!grepl(pattern, name)) 
[16:12:32.029]                               next
[16:12:32.029]                             invokeRestart(restart)
[16:12:32.029]                             muffled <- TRUE
[16:12:32.029]                             break
[16:12:32.029]                           }
[16:12:32.029]                         }
[16:12:32.029]                       }
[16:12:32.029]                       invisible(muffled)
[16:12:32.029]                     }
[16:12:32.029]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.029]                   }
[16:12:32.029]                 }
[16:12:32.029]                 else {
[16:12:32.029]                   if (TRUE) {
[16:12:32.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:12:32.029]                     {
[16:12:32.029]                       inherits <- base::inherits
[16:12:32.029]                       invokeRestart <- base::invokeRestart
[16:12:32.029]                       is.null <- base::is.null
[16:12:32.029]                       muffled <- FALSE
[16:12:32.029]                       if (inherits(cond, "message")) {
[16:12:32.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:12:32.029]                         if (muffled) 
[16:12:32.029]                           invokeRestart("muffleMessage")
[16:12:32.029]                       }
[16:12:32.029]                       else if (inherits(cond, "warning")) {
[16:12:32.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:12:32.029]                         if (muffled) 
[16:12:32.029]                           invokeRestart("muffleWarning")
[16:12:32.029]                       }
[16:12:32.029]                       else if (inherits(cond, "condition")) {
[16:12:32.029]                         if (!is.null(pattern)) {
[16:12:32.029]                           computeRestarts <- base::computeRestarts
[16:12:32.029]                           grepl <- base::grepl
[16:12:32.029]                           restarts <- computeRestarts(cond)
[16:12:32.029]                           for (restart in restarts) {
[16:12:32.029]                             name <- restart$name
[16:12:32.029]                             if (is.null(name)) 
[16:12:32.029]                               next
[16:12:32.029]                             if (!grepl(pattern, name)) 
[16:12:32.029]                               next
[16:12:32.029]                             invokeRestart(restart)
[16:12:32.029]                             muffled <- TRUE
[16:12:32.029]                             break
[16:12:32.029]                           }
[16:12:32.029]                         }
[16:12:32.029]                       }
[16:12:32.029]                       invisible(muffled)
[16:12:32.029]                     }
[16:12:32.029]                     muffleCondition(cond, pattern = "^muffle")
[16:12:32.029]                   }
[16:12:32.029]                 }
[16:12:32.029]             }
[16:12:32.029]         }))
[16:12:32.029]     }, error = function(ex) {
[16:12:32.029]         base::structure(base::list(value = NULL, visible = NULL, 
[16:12:32.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:12:32.029]                 ...future.rng), started = ...future.startTime, 
[16:12:32.029]             finished = Sys.time(), session_uuid = NA_character_, 
[16:12:32.029]             version = "1.8"), class = "FutureResult")
[16:12:32.029]     }, finally = {
[16:12:32.029]         if (!identical(...future.workdir, getwd())) 
[16:12:32.029]             setwd(...future.workdir)
[16:12:32.029]         {
[16:12:32.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:12:32.029]                 ...future.oldOptions$nwarnings <- NULL
[16:12:32.029]             }
[16:12:32.029]             base::options(...future.oldOptions)
[16:12:32.029]             if (.Platform$OS.type == "windows") {
[16:12:32.029]                 old_names <- names(...future.oldEnvVars)
[16:12:32.029]                 envs <- base::Sys.getenv()
[16:12:32.029]                 names <- names(envs)
[16:12:32.029]                 common <- intersect(names, old_names)
[16:12:32.029]                 added <- setdiff(names, old_names)
[16:12:32.029]                 removed <- setdiff(old_names, names)
[16:12:32.029]                 changed <- common[...future.oldEnvVars[common] != 
[16:12:32.029]                   envs[common]]
[16:12:32.029]                 NAMES <- toupper(changed)
[16:12:32.029]                 args <- list()
[16:12:32.029]                 for (kk in seq_along(NAMES)) {
[16:12:32.029]                   name <- changed[[kk]]
[16:12:32.029]                   NAME <- NAMES[[kk]]
[16:12:32.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.029]                     next
[16:12:32.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.029]                 }
[16:12:32.029]                 NAMES <- toupper(added)
[16:12:32.029]                 for (kk in seq_along(NAMES)) {
[16:12:32.029]                   name <- added[[kk]]
[16:12:32.029]                   NAME <- NAMES[[kk]]
[16:12:32.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.029]                     next
[16:12:32.029]                   args[[name]] <- ""
[16:12:32.029]                 }
[16:12:32.029]                 NAMES <- toupper(removed)
[16:12:32.029]                 for (kk in seq_along(NAMES)) {
[16:12:32.029]                   name <- removed[[kk]]
[16:12:32.029]                   NAME <- NAMES[[kk]]
[16:12:32.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:12:32.029]                     next
[16:12:32.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:12:32.029]                 }
[16:12:32.029]                 if (length(args) > 0) 
[16:12:32.029]                   base::do.call(base::Sys.setenv, args = args)
[16:12:32.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:12:32.029]             }
[16:12:32.029]             else {
[16:12:32.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:12:32.029]             }
[16:12:32.029]             {
[16:12:32.029]                 if (base::length(...future.futureOptionsAdded) > 
[16:12:32.029]                   0L) {
[16:12:32.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:12:32.029]                   base::names(opts) <- ...future.futureOptionsAdded
[16:12:32.029]                   base::options(opts)
[16:12:32.029]                 }
[16:12:32.029]                 {
[16:12:32.029]                   {
[16:12:32.029]                     base::options(mc.cores = ...future.mc.cores.old)
[16:12:32.029]                     NULL
[16:12:32.029]                   }
[16:12:32.029]                   options(future.plan = NULL)
[16:12:32.029]                   if (is.na(NA_character_)) 
[16:12:32.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:12:32.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:12:32.029]                   future::plan(list(function (..., workers = availableCores(), 
[16:12:32.029]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:12:32.029]                     envir = parent.frame()) 
[16:12:32.029]                   {
[16:12:32.029]                     if (is.function(workers)) 
[16:12:32.029]                       workers <- workers()
[16:12:32.029]                     workers <- structure(as.integer(workers), 
[16:12:32.029]                       class = class(workers))
[16:12:32.029]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:12:32.029]                       workers >= 1)
[16:12:32.029]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:12:32.029]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:12:32.029]                     }
[16:12:32.029]                     future <- MultisessionFuture(..., workers = workers, 
[16:12:32.029]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:12:32.029]                       envir = envir)
[16:12:32.029]                     if (!future$lazy) 
[16:12:32.029]                       future <- run(future)
[16:12:32.029]                     invisible(future)
[16:12:32.029]                   }), .cleanup = FALSE, .init = FALSE)
[16:12:32.029]                 }
[16:12:32.029]             }
[16:12:32.029]         }
[16:12:32.029]     })
[16:12:32.029]     if (TRUE) {
[16:12:32.029]         base::sink(type = "output", split = FALSE)
[16:12:32.029]         if (TRUE) {
[16:12:32.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:12:32.029]         }
[16:12:32.029]         else {
[16:12:32.029]             ...future.result["stdout"] <- base::list(NULL)
[16:12:32.029]         }
[16:12:32.029]         base::close(...future.stdout)
[16:12:32.029]         ...future.stdout <- NULL
[16:12:32.029]     }
[16:12:32.029]     ...future.result$conditions <- ...future.conditions
[16:12:32.029]     ...future.result$finished <- base::Sys.time()
[16:12:32.029]     ...future.result
[16:12:32.029] }
[16:12:32.031] Poll #1 (0): usedNodes() = 2, workers = 2
[16:12:32.041] receiveMessageFromWorker() for ClusterFuture ...
[16:12:32.042] - Validating connection of MultisessionFuture
[16:12:32.042] - received message: FutureResult
[16:12:32.042] - Received FutureResult
[16:12:32.042] - Erased future from FutureRegistry
[16:12:32.042] result() for ClusterFuture ...
[16:12:32.042] - result already collected: FutureResult
[16:12:32.042] result() for ClusterFuture ... done
[16:12:32.042] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:32.042] result() for ClusterFuture ...
[16:12:32.043] - result already collected: FutureResult
[16:12:32.043] result() for ClusterFuture ... done
[16:12:32.043] result() for ClusterFuture ...
[16:12:32.043] - result already collected: FutureResult
[16:12:32.043] result() for ClusterFuture ... done
[16:12:32.044] MultisessionFuture started
[16:12:32.044] - Launch lazy future ... done
[16:12:32.044] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x560bb00eed48> 
Classes 'listenv', 'environment' <environment: 0x560baee2c458> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[16:12:32.053] receiveMessageFromWorker() for ClusterFuture ...
[16:12:32.053] - Validating connection of MultisessionFuture
[16:12:32.053] - received message: FutureResult
[16:12:32.053] - Received FutureResult
[16:12:32.053] - Erased future from FutureRegistry
[16:12:32.053] result() for ClusterFuture ...
[16:12:32.053] - result already collected: FutureResult
[16:12:32.053] result() for ClusterFuture ... done
[16:12:32.054] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[16:12:32.067] resolve() on list environment ...
[16:12:32.067]  recursive: 0
[16:12:32.068]  length: 6
[16:12:32.068]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[16:12:32.068] signalConditionsASAP(numeric, pos=1) ...
[16:12:32.068] - nx: 6
[16:12:32.068] - relay: TRUE
[16:12:32.069] - stdout: TRUE
[16:12:32.069] - signal: TRUE
[16:12:32.069] - resignal: FALSE
[16:12:32.069] - force: TRUE
[16:12:32.069] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:32.069] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:32.069]  - until=2
[16:12:32.069]  - relaying element #2
[16:12:32.069] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:32.069] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:32.069] signalConditionsASAP(NULL, pos=1) ... done
[16:12:32.069]  length: 5 (resolved future 1)
[16:12:32.070] Future #2
[16:12:32.070] result() for ClusterFuture ...
[16:12:32.070] - result already collected: FutureResult
[16:12:32.070] result() for ClusterFuture ... done
[16:12:32.070] result() for ClusterFuture ...
[16:12:32.070] - result already collected: FutureResult
[16:12:32.070] result() for ClusterFuture ... done
[16:12:32.070] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:12:32.070] - nx: 6
[16:12:32.070] - relay: TRUE
[16:12:32.071] - stdout: TRUE
[16:12:32.071] - signal: TRUE
[16:12:32.071] - resignal: FALSE
[16:12:32.071] - force: TRUE
[16:12:32.071] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:32.071] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[16:12:32.071]  - until=2
[16:12:32.071]  - relaying element #2
[16:12:32.071] result() for ClusterFuture ...
[16:12:32.071] - result already collected: FutureResult
[16:12:32.071] result() for ClusterFuture ... done
[16:12:32.071] result() for ClusterFuture ...
[16:12:32.072] - result already collected: FutureResult
[16:12:32.072] result() for ClusterFuture ... done
[16:12:32.072] result() for ClusterFuture ...
[16:12:32.072] - result already collected: FutureResult
[16:12:32.072] result() for ClusterFuture ... done
[16:12:32.072] result() for ClusterFuture ...
[16:12:32.072] - result already collected: FutureResult
[16:12:32.072] result() for ClusterFuture ... done
[16:12:32.072] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:32.072] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:32.073] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:12:32.073]  length: 4 (resolved future 2)
[16:12:32.073] Future #3
[16:12:32.073] result() for ClusterFuture ...
[16:12:32.073] - result already collected: FutureResult
[16:12:32.073] result() for ClusterFuture ... done
[16:12:32.073] result() for ClusterFuture ...
[16:12:32.073] - result already collected: FutureResult
[16:12:32.073] result() for ClusterFuture ... done
[16:12:32.073] signalConditionsASAP(MultisessionFuture, pos=3) ...
[16:12:32.074] - nx: 6
[16:12:32.074] - relay: TRUE
[16:12:32.074] - stdout: TRUE
[16:12:32.074] - signal: TRUE
[16:12:32.074] - resignal: FALSE
[16:12:32.074] - force: TRUE
[16:12:32.074] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:32.074] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[16:12:32.074]  - until=3
[16:12:32.074]  - relaying element #3
[16:12:32.074] result() for ClusterFuture ...
[16:12:32.075] - result already collected: FutureResult
[16:12:32.075] result() for ClusterFuture ... done
[16:12:32.075] result() for ClusterFuture ...
[16:12:32.075] - result already collected: FutureResult
[16:12:32.075] result() for ClusterFuture ... done
[16:12:32.075] result() for ClusterFuture ...
[16:12:32.075] - result already collected: FutureResult
[16:12:32.075] result() for ClusterFuture ... done
[16:12:32.075] result() for ClusterFuture ...
[16:12:32.075] - result already collected: FutureResult
[16:12:32.075] result() for ClusterFuture ... done
[16:12:32.075] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.076] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.076] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[16:12:32.076]  length: 3 (resolved future 3)
[16:12:32.086] signalConditionsASAP(NULL, pos=5) ...
[16:12:32.087] - nx: 6
[16:12:32.087] - relay: TRUE
[16:12:32.087] - stdout: TRUE
[16:12:32.087] - signal: TRUE
[16:12:32.087] - resignal: FALSE
[16:12:32.087] - force: TRUE
[16:12:32.087] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.087] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.087]  - until=6
[16:12:32.088]  - relaying element #4
[16:12:32.088]  - relaying element #6
[16:12:32.088] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:32.088] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.088] signalConditionsASAP(NULL, pos=5) ... done
[16:12:32.088]  length: 2 (resolved future 5)
[16:12:32.088] signalConditionsASAP(numeric, pos=6) ...
[16:12:32.088] - nx: 6
[16:12:32.088] - relay: TRUE
[16:12:32.088] - stdout: TRUE
[16:12:32.089] - signal: TRUE
[16:12:32.089] - resignal: FALSE
[16:12:32.089] - force: TRUE
[16:12:32.089] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[16:12:32.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.089]  - until=6
[16:12:32.089]  - relaying element #4
[16:12:32.089] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:32.089] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.089] signalConditionsASAP(NULL, pos=6) ... done
[16:12:32.089]  length: 1 (resolved future 6)
[16:12:32.100] receiveMessageFromWorker() for ClusterFuture ...
[16:12:32.100] - Validating connection of MultisessionFuture
[16:12:32.100] - received message: FutureResult
[16:12:32.101] - Received FutureResult
[16:12:32.101] - Erased future from FutureRegistry
[16:12:32.101] result() for ClusterFuture ...
[16:12:32.101] - result already collected: FutureResult
[16:12:32.101] result() for ClusterFuture ... done
[16:12:32.101] receiveMessageFromWorker() for ClusterFuture ... done
[16:12:32.101] Future #4
[16:12:32.101] result() for ClusterFuture ...
[16:12:32.101] - result already collected: FutureResult
[16:12:32.101] result() for ClusterFuture ... done
[16:12:32.102] result() for ClusterFuture ...
[16:12:32.102] - result already collected: FutureResult
[16:12:32.102] result() for ClusterFuture ... done
[16:12:32.102] signalConditionsASAP(MultisessionFuture, pos=4) ...
[16:12:32.102] - nx: 6
[16:12:32.102] - relay: TRUE
[16:12:32.102] - stdout: TRUE
[16:12:32.102] - signal: TRUE
[16:12:32.102] - resignal: FALSE
[16:12:32.102] - force: TRUE
[16:12:32.102] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[16:12:32.103] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[16:12:32.103]  - until=6
[16:12:32.103]  - relaying element #4
[16:12:32.103] result() for ClusterFuture ...
[16:12:32.103] - result already collected: FutureResult
[16:12:32.103] result() for ClusterFuture ... done
[16:12:32.103] result() for ClusterFuture ...
[16:12:32.103] - result already collected: FutureResult
[16:12:32.103] result() for ClusterFuture ... done
[16:12:32.103] result() for ClusterFuture ...
[16:12:32.103] - result already collected: FutureResult
[16:12:32.104] result() for ClusterFuture ... done
[16:12:32.104] result() for ClusterFuture ...
[16:12:32.104] - result already collected: FutureResult
[16:12:32.104] result() for ClusterFuture ... done
[16:12:32.104] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:32.104] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:32.104] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[16:12:32.104]  length: 0 (resolved future 4)
[16:12:32.104] Relaying remaining futures
[16:12:32.104] signalConditionsASAP(NULL, pos=0) ...
[16:12:32.105] - nx: 6
[16:12:32.105] - relay: TRUE
[16:12:32.105] - stdout: TRUE
[16:12:32.105] - signal: TRUE
[16:12:32.105] - resignal: FALSE
[16:12:32.105] - force: TRUE
[16:12:32.105] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:32.105] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[16:12:32.105] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[16:12:32.105] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[16:12:32.105] signalConditionsASAP(NULL, pos=0) ... done
[16:12:32.106] resolve() on list environment ... DONE
[16:12:32.106] result() for ClusterFuture ...
[16:12:32.106] - result already collected: FutureResult
[16:12:32.106] result() for ClusterFuture ... done
[16:12:32.106] result() for ClusterFuture ...
[16:12:32.106] - result already collected: FutureResult
[16:12:32.106] result() for ClusterFuture ... done
[16:12:32.106] result() for ClusterFuture ...
[16:12:32.106] - result already collected: FutureResult
[16:12:32.106] result() for ClusterFuture ... done
[16:12:32.107] result() for ClusterFuture ...
[16:12:32.107] - result already collected: FutureResult
[16:12:32.107] result() for ClusterFuture ... done
[16:12:32.107] result() for ClusterFuture ...
[16:12:32.107] - result already collected: FutureResult
[16:12:32.107] result() for ClusterFuture ... done
[16:12:32.107] result() for ClusterFuture ...
[16:12:32.107] - result already collected: FutureResult
[16:12:32.107] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x560bae67e1e0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[16:12:32.110] plan(): Setting new future strategy stack:
[16:12:32.110] List of future strategies:
[16:12:32.110] 1. FutureStrategy:
[16:12:32.110]    - args: function (..., envir = parent.frame())
[16:12:32.110]    - tweaked: FALSE
[16:12:32.110]    - call: future::plan(oplan)
[16:12:32.111] plan(): nbrOfWorkers() = 1
> 
